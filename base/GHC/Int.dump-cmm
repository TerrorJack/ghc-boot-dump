
==================== Output Cmm ====================
2018-03-16 15:59:08.481945119 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:08.483012802 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cfromEnum_closure" {
     GHC.Int.$fEnumInt8_$cfromEnum_closure:
         const GHC.Int.$fEnumInt8_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt8_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4ly9,
                       label: GHC.Int.$fEnumInt8_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ly9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lyd; else goto c4lye;
       c4lyd: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lye: // global
           I64[Sp - 8] = block_c4ly6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lyi; else goto c4ly7;
       u4lyi: // global
           call _c4ly6(R1) args: 0, res: 0, upd: 0;
       c4ly7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ly6() //  [R1]
         { info_tbl: [(c4ly6,
                       label: block_c4ly6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ly6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lyh; else goto c4lyg;
       c4lyh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4lyg: // global
           _s4kPJ::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.484435894 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cfromEnum_closure" {
     GHC.Int.$fEnumInt16_$cfromEnum_closure:
         const GHC.Int.$fEnumInt16_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt16_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4lyq,
                       label: GHC.Int.$fEnumInt16_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lyq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lyu; else goto c4lyv;
       c4lyu: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lyv: // global
           I64[Sp - 8] = block_c4lyn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lyz; else goto c4lyo;
       u4lyz: // global
           call _c4lyn(R1) args: 0, res: 0, upd: 0;
       c4lyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lyn() //  [R1]
         { info_tbl: [(c4lyn,
                       label: block_c4lyn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lyn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lyy; else goto c4lyx;
       c4lyy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4lyx: // global
           _s4kPM::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPM::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.485782776 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cfromEnum_closure" {
     GHC.Int.$fEnumInt32_$cfromEnum_closure:
         const GHC.Int.$fEnumInt32_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt32_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4lyH,
                       label: GHC.Int.$fEnumInt32_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lyH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lyL; else goto c4lyM;
       c4lyL: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lyM: // global
           I64[Sp - 8] = block_c4lyE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lyQ; else goto c4lyF;
       u4lyQ: // global
           call _c4lyE(R1) args: 0, res: 0, upd: 0;
       c4lyF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lyE() //  [R1]
         { info_tbl: [(c4lyE,
                       label: block_c4lyE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lyE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lyP; else goto c4lyO;
       c4lyP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4lyO: // global
           _s4kPP::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.487073627 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cfromEnum_closure" {
     GHC.Int.$fEnumInt64_$cfromEnum_closure:
         const GHC.Int.$fEnumInt64_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt64_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4lyY,
                       label: GHC.Int.$fEnumInt64_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lyY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lz2; else goto c4lz3;
       c4lz2: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lz3: // global
           I64[Sp - 8] = block_c4lyV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lz7; else goto c4lyW;
       u4lz7: // global
           call _c4lyV(R1) args: 0, res: 0, upd: 0;
       c4lyW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lyV() //  [R1]
         { info_tbl: [(c4lyV,
                       label: block_c4lyV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lyV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lz6; else goto c4lz5;
       c4lz6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4lz5: // global
           _s4kPS::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.488465726 UTC

[section ""data" . GHC.Int.$fEnumInt64_$ctoEnum_closure" {
     GHC.Int.$fEnumInt64_$ctoEnum_closure:
         const GHC.Int.$fEnumInt64_$ctoEnum_info;
 },
 GHC.Int.$fEnumInt64_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4lzf,
                       label: GHC.Int.$fEnumInt64_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lzf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lzj; else goto c4lzk;
       c4lzj: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lzk: // global
           I64[Sp - 8] = block_c4lzc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lzo; else goto c4lzd;
       u4lzo: // global
           call _c4lzc(R1) args: 0, res: 0, upd: 0;
       c4lzd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lzc() //  [R1]
         { info_tbl: [(c4lzc,
                       label: block_c4lzc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lzc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lzn; else goto c4lzm;
       c4lzn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4lzm: // global
           _s4kPV::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kPV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.491382139 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo2_closure" {
     GHC.Int.$w$cenumFromThenTo2_closure:
         const GHC.Int.$w$cenumFromThenTo2_info;
 },
 sat_s4kQ9_entry() //  [R1]
         { info_tbl: [(c4lzX,
                       label: sat_s4kQ9_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lzX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lzY; else goto c4lzZ;
       c4lzY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lzZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kQ4_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kQ4_entry() //  [R1, R2]
         { info_tbl: [(c4lA3,
                       label: go_dn_s4kQ4_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lA3: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4lA7; else goto c4lA6;
       c4lA7: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lA6: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4lA1; else goto c4lA2;
       c4lA1: // global
           _s4kQ2::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQ9_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQ2::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lA2: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lAc::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lAc::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kQb_entry() //  [R1]
         { info_tbl: [(c4lAd,
                       label: sat_s4kQb_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lAd: // global
           _s4kQb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lAe; else goto c4lAf;
       c4lAf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lAh; else goto c4lAg;
       c4lAh: // global
           HpAlloc = 24;
           goto c4lAe;
       c4lAe: // global
           R1 = _s4kQb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lAg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kQb::P64;
           _s4kPX::I64 = I64[_s4kQb::P64 + 24];
           _s4kQ2::I64 = _s4kPX::I64 - I64[_s4kQb::P64 + 16];
           _s4kQ3::I64 = I64[_s4kQb::P64 + 32] - _s4kQ2::I64;
           I64[Hp - 16] = go_dn_s4kQ4_info;
           I64[Hp - 8] = _s4kQ2::I64;
           I64[Hp] = _s4kQ3::I64;
           R2 = _s4kPX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kQ4_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kQn_entry() //  [R1]
         { info_tbl: [(c4lAK,
                       label: sat_s4kQn_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lAK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lAL; else goto c4lAM;
       c4lAL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lAM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kQi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kQi_entry() //  [R1, R2]
         { info_tbl: [(c4lAQ,
                       label: go_up_s4kQi_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lAQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4lAU; else goto c4lAT;
       c4lAU: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lAT: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4lAO; else goto c4lAP;
       c4lAO: // global
           _s4kQg::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQn_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQg::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lAP: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lAZ::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lAZ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kQp_entry() //  [R1]
         { info_tbl: [(c4lB0,
                       label: sat_s4kQp_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lB0: // global
           _s4kQp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lB1; else goto c4lB2;
       c4lB2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lB4; else goto c4lB3;
       c4lB4: // global
           HpAlloc = 24;
           goto c4lB1;
       c4lB1: // global
           R1 = _s4kQp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lB3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kQp::P64;
           _s4kPX::I64 = I64[_s4kQp::P64 + 24];
           _s4kQg::I64 = _s4kPX::I64 - I64[_s4kQp::P64 + 16];
           _s4kQh::I64 = I64[_s4kQp::P64 + 32] - _s4kQg::I64;
           I64[Hp - 16] = go_up_s4kQi_info;
           I64[Hp - 8] = _s4kQg::I64;
           I64[Hp] = _s4kQh::I64;
           R2 = _s4kPX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kQi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { info_tbl: [(c4lB8,
                       label: GHC.Int.$w$cenumFromThenTo2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lB8: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4lBc; else goto c4lBb;
       c4lBc: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lBb: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4lB6; else goto c4lB7;
       c4lB6: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4lBg; else goto c4lBq;
       c4lBg: // global
           I64[Hp - 72] = sat_s4kQb_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lBq: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4lBD; else goto c4lBo;
       c4lBo: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lBm::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lBm::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lB7: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4lBu; else goto c4lBE;
       c4lBu: // global
           I64[Hp - 72] = sat_s4kQp_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lBE: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4lBD; else goto c4lBC;
       c4lBD: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lBC: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lBA::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lBA::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.504751612 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4lBM,
                       label: GHC.Int.$fEnumInt64_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lBM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4lBV; else goto c4lBW;
       c4lBV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lBW: // global
           I64[Sp - 24] = block_c4lBJ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4lC5; else goto c4lBK;
       u4lC5: // global
           call _c4lBJ(R1) args: 0, res: 0, upd: 0;
       c4lBK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lBJ() //  [R1]
         { info_tbl: [(c4lBJ,
                       label: block_c4lBJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lBJ: // global
           I64[Sp] = block_c4lBP_info;
           _s4kQw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQw::I64;
           if (R1 & 7 != 0) goto u4lC4; else goto c4lBQ;
       u4lC4: // global
           call _c4lBP(R1) args: 0, res: 0, upd: 0;
       c4lBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lBP() //  [R1]
         { info_tbl: [(c4lBP,
                       label: block_c4lBP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lBP: // global
           I64[Sp] = block_c4lBU_info;
           _s4kQy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kQy::I64;
           if (R1 & 7 != 0) goto u4lC6; else goto c4lBZ;
       u4lC6: // global
           call _c4lBU(R1) args: 0, res: 0, upd: 0;
       c4lBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lBU() //  [R1]
         { info_tbl: [(c4lBU,
                       label: block_c4lBU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lBU: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo2_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.506900335 UTC

[section ""data" . GHC.Int.$w$cenumFromTo2_closure" {
     GHC.Int.$w$cenumFromTo2_closure:
         const GHC.Int.$w$cenumFromTo2_info;
 },
 sat_s4kQJ_entry() //  [R1]
         { info_tbl: [(c4lCs,
                       label: sat_s4kQJ_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lCs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lCt; else goto c4lCu;
       c4lCt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lCu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kQF::I64 = I64[R1 + 32];
           if (_s4kQF::I64 == I64[R1 + 24]) goto c4lCr; else goto c4lCq;
       c4lCr: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4lCq: // global
           R2 = _s4kQF::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kQE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kQE_entry() //  [R1, R2]
         { info_tbl: [(c4lCz,
                       label: go_s4kQE_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lCz: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4lCD; else goto c4lCC;
       c4lCD: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lCC: // global
           _s4kQC::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQJ_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQC::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo2_entry() //  [R2, R3]
         { info_tbl: [(c4lCH,
                       label: GHC.Int.$w$cenumFromTo2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lCH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lCL; else goto c4lCK;
       c4lCL: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lCK: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4lCF; else goto c4lCG;
       c4lCF: // global
           I64[Hp - 8] = go_s4kQE_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kQE_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4lCG: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.508720476 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4lCT,
                       label: GHC.Int.$fEnumInt64_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lCT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lCX; else goto c4lCY;
       c4lCX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lCY: // global
           I64[Sp - 16] = block_c4lCQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4lD6; else goto c4lCR;
       u4lD6: // global
           call _c4lCQ(R1) args: 0, res: 0, upd: 0;
       c4lCR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lCQ() //  [R1]
         { info_tbl: [(c4lCQ,
                       label: block_c4lCQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lCQ: // global
           I64[Sp] = block_c4lCW_info;
           _s4kQN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQN::I64;
           if (R1 & 7 != 0) goto u4lD5; else goto c4lD0;
       u4lD5: // global
           call _c4lCW(R1) args: 0, res: 0, upd: 0;
       c4lD0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lCW() //  [R1]
         { info_tbl: [(c4lCW,
                       label: block_c4lCW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lCW: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.509943231 UTC

[section ""cstring" . GHC.Int.$tcInt9_bytes" {
     GHC.Int.$tcInt9_bytes:
         I8[] [73,110,116,56]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.510739442 UTC

[section ""data" . GHC.Int.$fEnumInt7_closure" {
     GHC.Int.$fEnumInt7_closure:
         const GHC.Int.$fEnumInt7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt7_entry() //  [R1]
         { info_tbl: [(c4lDf,
                       label: GHC.Int.$fEnumInt7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lDf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4lDg; else goto c4lDh;
       c4lDg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lDh: // global
           (_c4lDa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4lDa::I64 == 0) goto c4lDc; else goto c4lDb;
       c4lDc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4lDb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4lDa::I64;
           I64[Sp - 24] = block_c4lDd_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4lDd() //  [R1]
         { info_tbl: [(c4lDd,
                       label: block_c4lDd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lDd: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.511985483 UTC

[section ""data" . GHC.Int.$fEnumInt9_closure" {
     GHC.Int.$fEnumInt9_closure:
         const GHC.Int.$fEnumInt9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt9_entry() //  [R1]
         { info_tbl: [(c4lDu,
                       label: GHC.Int.$fEnumInt9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lDu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4lDv; else goto c4lDw;
       c4lDv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lDw: // global
           (_c4lDp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4lDp::I64 == 0) goto c4lDr; else goto c4lDq;
       c4lDr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4lDq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4lDp::I64;
           I64[Sp - 24] = block_c4lDs_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4lDs() //  [R1]
         { info_tbl: [(c4lDs,
                       label: block_c4lDs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lDs: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.513493174 UTC

[section ""data" . GHC.Int.neInt8_closure" {
     GHC.Int.neInt8_closure:
         const GHC.Int.neInt8_info;
 },
 GHC.Int.neInt8_entry() //  [R2, R3]
         { info_tbl: [(c4lDH,
                       label: GHC.Int.neInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lDH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lDL; else goto c4lDM;
       c4lDL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lDM: // global
           I64[Sp - 16] = block_c4lDE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4lDV; else goto c4lDF;
       u4lDV: // global
           call _c4lDE(R1) args: 0, res: 0, upd: 0;
       c4lDF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lDE() //  [R1]
         { info_tbl: [(c4lDE,
                       label: block_c4lDE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lDE: // global
           I64[Sp] = block_c4lDK_info;
           _s4kQV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQV::I64;
           if (R1 & 7 != 0) goto u4lDU; else goto c4lDO;
       u4lDU: // global
           call _c4lDK(R1) args: 0, res: 0, upd: 0;
       c4lDO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lDK() //  [R1]
         { info_tbl: [(c4lDK,
                       label: block_c4lDK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lDK: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.514831857 UTC

[section ""data" . lvl_r4kPr_closure" {
     lvl_r4kPr_closure:
         const lvl_r4kPr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r4kPr_entry() //  [R1]
         { info_tbl: [(c4lE2,
                       label: lvl_r4kPr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lE2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lE3; else goto c4lE4;
       c4lE3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lE4: // global
           (_c4lDZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4lDZ::I64 == 0) goto c4lE1; else goto c4lE0;
       c4lE1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4lE0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4lDZ::I64;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.515693338 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cminBound_closure" {
     GHC.Int.$fBoundedInt8_$cminBound_closure:
         const GHC.Int.I8#_con_info;
         const (-128);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.516592746 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cpred_closure" {
     GHC.Int.$fEnumInt8_$cpred_closure:
         const GHC.Int.$fEnumInt8_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cpred_entry() //  [R2]
         { info_tbl: [(c4lEc,
                       label: GHC.Int.$fEnumInt8_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lEc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lEd; else goto c4lEe;
       c4lEd: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lEe: // global
           I64[Sp - 8] = block_c4lE9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lEw; else goto c4lEa;
       u4lEw: // global
           call _c4lE9(R1) args: 0, res: 0, upd: 0;
       c4lEa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lE9() //  [R1]
         { info_tbl: [(c4lE9,
                       label: block_c4lE9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lE9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lEj; else goto c4lEi;
       c4lEj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4lEi: // global
           _s4kR2::I64 = I64[R1 + 7];
           if (_s4kR2::I64 != (-128)) goto c4lEu; else goto c4lEv;
       c4lEu: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4kR2::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lEv: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.517820178 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt8_$cmaxBound_closure:
         const GHC.Int.I8#_con_info;
         const 127;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.518396565 UTC

[section ""data" . GHC.Int.$fBoundedInt8_closure" {
     GHC.Int.$fBoundedInt8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt8_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.519303934 UTC

[section ""data" . GHC.Int.$fEnumInt8_$csucc_closure" {
     GHC.Int.$fEnumInt8_$csucc_closure:
         const GHC.Int.$fEnumInt8_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$csucc_entry() //  [R2]
         { info_tbl: [(c4lEE,
                       label: GHC.Int.$fEnumInt8_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lEE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lEF; else goto c4lEG;
       c4lEF: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lEG: // global
           I64[Sp - 8] = block_c4lEB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lEY; else goto c4lEC;
       u4lEY: // global
           call _c4lEB(R1) args: 0, res: 0, upd: 0;
       c4lEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lEB() //  [R1]
         { info_tbl: [(c4lEB,
                       label: block_c4lEB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lEB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lEL; else goto c4lEK;
       c4lEL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4lEK: // global
           _s4kR8::I64 = I64[R1 + 7];
           if (_s4kR8::I64 != 127) goto c4lEW; else goto c4lEX;
       c4lEW: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4kR8::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lEX: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.520938395 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowsPrec_closure" {
     GHC.Int.$fShowInt8_$cshowsPrec_closure:
         const GHC.Int.$fShowInt8_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt8_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4lF6,
                       label: GHC.Int.$fShowInt8_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lF6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4lFh; else goto c4lFi;
       c4lFh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lFi: // global
           I64[Sp - 24] = block_c4lF3_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4lFp; else goto c4lF4;
       u4lFp: // global
           call _c4lF3(R1) args: 0, res: 0, upd: 0;
       c4lF4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lF3() //  [R1]
         { info_tbl: [(c4lF3,
                       label: block_c4lF3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lF3: // global
           I64[Sp] = block_c4lF9_info;
           _s4kRf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kRf::I64;
           if (R1 & 7 != 0) goto u4lFo; else goto c4lFa;
       u4lFo: // global
           call _c4lF9(R1) args: 0, res: 0, upd: 0;
       c4lFa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lF9() //  [R1]
         { info_tbl: [(c4lF9,
                       label: block_c4lF9_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lF9: // global
           _s4kRd::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4lFe_info;
           R4 = _s4kRd::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4lFe() //  [R1, R2]
         { info_tbl: [(c4lFe,
                       label: block_c4lFe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lFe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lFn; else goto c4lFm;
       c4lFn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4lFm: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.522836554 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshow_closure" {
     GHC.Int.$fShowInt8_$cshow_closure:
         const GHC.Int.$fShowInt8_$cshow_info;
 },
 GHC.Int.$fShowInt8_$cshow_entry() //  [R2]
         { info_tbl: [(c4lFx,
                       label: GHC.Int.$fShowInt8_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lFx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lFD; else goto c4lFE;
       c4lFD: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lFE: // global
           I64[Sp - 8] = block_c4lFu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lFJ; else goto c4lFv;
       u4lFJ: // global
           call _c4lFu(R1) args: 0, res: 0, upd: 0;
       c4lFv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lFu() //  [R1]
         { info_tbl: [(c4lFu,
                       label: block_c4lFu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lFu: // global
           I64[Sp] = block_c4lFA_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4lFA() //  [R1, R2]
         { info_tbl: [(c4lFA,
                       label: block_c4lFA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lFA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lFI; else goto c4lFH;
       c4lFI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4lFH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.525447545 UTC

[section ""data" . GHC.Int.$fShowInt4_closure" {
     GHC.Int.$fShowInt4_closure:
         const GHC.Int.$fShowInt4_info;
 },
 GHC.Int.$fShowInt4_entry() //  [R2, R3]
         { info_tbl: [(c4lFR,
                       label: GHC.Int.$fShowInt4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lFR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lFX; else goto c4lFY;
       c4lFX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lFY: // global
           I64[Sp - 16] = block_c4lFO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4lG3; else goto c4lFP;
       u4lG3: // global
           call _c4lFO(R1) args: 0, res: 0, upd: 0;
       c4lFP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lFO() //  [R1]
         { info_tbl: [(c4lFO,
                       label: block_c4lFO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lFO: // global
           _s4kRs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4lFU_info;
           R4 = _s4kRs::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4lFU() //  [R1, R2]
         { info_tbl: [(c4lFU,
                       label: block_c4lFU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lFU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lG2; else goto c4lG1;
       c4lG2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4lG1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.526801056 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowList_closure" {
     GHC.Int.$fShowInt8_$cshowList_closure:
         const GHC.Int.$fShowInt8_$cshowList_info;
 },
 GHC.Int.$fShowInt8_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4lG8,
                       label: GHC.Int.$fShowInt8_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lG8: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.52753118 UTC

[section ""data" . GHC.Int.$fShowInt8_closure" {
     GHC.Int.$fShowInt8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt8_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt8_$cshow_closure+1;
         const GHC.Int.$fShowInt8_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.528203782 UTC

[section ""data" . GHC.Int.$wlvl2_closure" {
     GHC.Int.$wlvl2_closure:
         const GHC.Int.$wlvl2_info;
         const 0;
 },
 GHC.Int.$wlvl2_entry() //  [R2]
         { info_tbl: [(c4lGf,
                       label: GHC.Int.$wlvl2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lGf: // global
           R6 = GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl_r4kPr_closure;
           R2 = GHC.Int.$fShowInt8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.529284316 UTC

[section ""data" . GHC.Int.$w$ctoEnum2_closure" {
     GHC.Int.$w$ctoEnum2_closure:
         const GHC.Int.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum2_entry() //  [R2]
         { info_tbl: [(c4lGr,
                       label: GHC.Int.$w$ctoEnum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lGr: // global
           _s4kRB::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-128))) goto c4lGz; else goto c4lGq;
       c4lGq: // global
           if (%MO_S_Gt_W64(_s4kRB::I64, 127)) goto c4lGz; else goto c4lGA;
       c4lGz: // global
           R2 = _s4kRB::I64;
           call GHC.Int.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c4lGA: // global
           R1 = _s4kRB::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.530347434 UTC

[section ""data" . GHC.Int.$fEnumInt8_$ctoEnum_closure" {
     GHC.Int.$fEnumInt8_$ctoEnum_closure:
         const GHC.Int.$fEnumInt8_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4lGI,
                       label: GHC.Int.$fEnumInt8_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lGI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lGQ; else goto c4lGR;
       c4lGQ: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lGR: // global
           I64[Sp - 8] = block_c4lGF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lGW; else goto c4lGG;
       u4lGW: // global
           call _c4lGF(R1) args: 0, res: 0, upd: 0;
       c4lGG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lGF() //  [R1]
         { info_tbl: [(c4lGF,
                       label: block_c4lGF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lGF: // global
           I64[Sp] = block_c4lGL_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4lGL() //  [R1]
         { info_tbl: [(c4lGL,
                       label: block_c4lGL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lGL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lGV; else goto c4lGU;
       c4lGV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4lGU: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.535208971 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo3_closure" {
     GHC.Int.$w$cenumFromThenTo3_closure:
         const GHC.Int.$w$cenumFromThenTo3_info;
         const 0;
 },
 sat_s4kS1_entry() //  [R1]
         { info_tbl: [(c4lHv,
                       label: sat_s4kS1_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lHv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lHw; else goto c4lHx;
       c4lHw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lHx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kRU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kRZ_entry() //  [R1]
         { info_tbl: [(c4lHH,
                       label: sat_s4kRZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lHH: // global
           _s4kRZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lHI; else goto c4lHJ;
       c4lHJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lHL; else goto c4lHK;
       c4lHL: // global
           HpAlloc = 16;
           goto c4lHI;
       c4lHI: // global
           R1 = _s4kRZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lHK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kRZ::P64;
           _s4kRV::I64 = I64[_s4kRZ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRV::I64, (-128))) goto c4lHR; else goto c4lHG;
       c4lHG: // global
           if (%MO_S_Gt_W64(_s4kRV::I64, 127)) goto c4lHR; else goto c4lHV;
       c4lHR: // global
           Hp = Hp - 16;
           R2 = _s4kRV::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4lHV: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kS4_entry() //  [R1]
         { info_tbl: [(c4lI6,
                       label: sat_s4kS4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lI6: // global
           _s4kS4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lI7; else goto c4lI8;
       c4lI8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lIa; else goto c4lI9;
       c4lIa: // global
           HpAlloc = 16;
           goto c4lI7;
       c4lI7: // global
           R1 = _s4kS4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lI9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS4::P64;
           _s4kRV::I64 = I64[_s4kS4::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRV::I64, (-128))) goto c4lIg; else goto c4lI5;
       c4lI5: // global
           if (%MO_S_Gt_W64(_s4kRV::I64, 127)) goto c4lIg; else goto c4lIk;
       c4lIg: // global
           Hp = Hp - 16;
           R2 = _s4kRV::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4lIk: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kRU_entry() //  [R1, R2]
         { info_tbl: [(c4lIo,
                       label: go_dn_s4kRU_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lIo: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4lIs; else goto c4lIr;
       c4lIs: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lIr: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4lIm; else goto c4lIn;
       c4lIm: // global
           _s4kRS::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kS1_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kRS::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kRZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lIn: // global
           I64[Hp - 80] = sat_s4kS4_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lIu::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lIu::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kS5_entry() //  [R1]
         { info_tbl: [(c4lIv,
                       label: sat_s4kS5_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lIv: // global
           _s4kS5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lIw; else goto c4lIx;
       c4lIx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lIz; else goto c4lIy;
       c4lIz: // global
           HpAlloc = 24;
           goto c4lIw;
       c4lIw: // global
           R1 = _s4kS5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lIy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS5::P64;
           _s4kRL::I64 = I64[_s4kS5::P64 + 24];
           _s4kRS::I64 = _s4kRL::I64 - I64[_s4kS5::P64 + 16];
           _s4kRT::I64 = I64[_s4kS5::P64 + 32] - _s4kRS::I64;
           I64[Hp - 16] = go_dn_s4kRU_info;
           I64[Hp - 8] = _s4kRS::I64;
           I64[Hp] = _s4kRT::I64;
           R2 = _s4kRL::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kRU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kRR_entry() //  [R1]
         { info_tbl: [(c4lIJ,
                       label: sat_s4kRR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lIJ: // global
           _s4kRR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lIK; else goto c4lIL;
       c4lIL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lIN; else goto c4lIM;
       c4lIN: // global
           HpAlloc = 16;
           goto c4lIK;
       c4lIK: // global
           R1 = _s4kRR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lIM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kRR::P64;
           _s4kRK::I64 = I64[_s4kRR::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4lIT; else goto c4lII;
       c4lII: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4lIT; else goto c4lIX;
       c4lIT: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4lIX: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kS9_entry() //  [R1]
         { info_tbl: [(c4lJb,
                       label: sat_s4kS9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lJb: // global
           _s4kS9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lJc; else goto c4lJd;
       c4lJd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lJf; else goto c4lJe;
       c4lJf: // global
           HpAlloc = 16;
           goto c4lJc;
       c4lJc: // global
           R1 = _s4kS9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lJe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS9::P64;
           _s4kRK::I64 = I64[_s4kS9::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4lJl; else goto c4lJa;
       c4lJa: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4lJl; else goto c4lJp;
       c4lJl: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4lJp: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSn_entry() //  [R1]
         { info_tbl: [(c4lJS,
                       label: sat_s4kSn_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lJS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lJT; else goto c4lJU;
       c4lJT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lJU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kSg_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSl_entry() //  [R1]
         { info_tbl: [(c4lK4,
                       label: sat_s4kSl_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lK4: // global
           _s4kSl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lK5; else goto c4lK6;
       c4lK6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lK8; else goto c4lK7;
       c4lK8: // global
           HpAlloc = 16;
           goto c4lK5;
       c4lK5: // global
           R1 = _s4kSl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lK7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSl::P64;
           _s4kSh::I64 = I64[_s4kSl::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSh::I64, (-128))) goto c4lKe; else goto c4lK3;
       c4lK3: // global
           if (%MO_S_Gt_W64(_s4kSh::I64, 127)) goto c4lKe; else goto c4lKi;
       c4lKe: // global
           Hp = Hp - 16;
           R2 = _s4kSh::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4lKi: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSh::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSq_entry() //  [R1]
         { info_tbl: [(c4lKt,
                       label: sat_s4kSq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lKt: // global
           _s4kSq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lKu; else goto c4lKv;
       c4lKv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lKx; else goto c4lKw;
       c4lKx: // global
           HpAlloc = 16;
           goto c4lKu;
       c4lKu: // global
           R1 = _s4kSq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lKw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSq::P64;
           _s4kSh::I64 = I64[_s4kSq::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSh::I64, (-128))) goto c4lKD; else goto c4lKs;
       c4lKs: // global
           if (%MO_S_Gt_W64(_s4kSh::I64, 127)) goto c4lKD; else goto c4lKH;
       c4lKD: // global
           Hp = Hp - 16;
           R2 = _s4kSh::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4lKH: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSh::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kSg_entry() //  [R1, R2]
         { info_tbl: [(c4lKL,
                       label: go_up_s4kSg_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lKL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4lKP; else goto c4lKO;
       c4lKP: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lKO: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4lKJ; else goto c4lKK;
       c4lKJ: // global
           _s4kSe::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kSn_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kSe::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kSl_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lKK: // global
           I64[Hp - 80] = sat_s4kSq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lKR::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lKR::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kSr_entry() //  [R1]
         { info_tbl: [(c4lKS,
                       label: sat_s4kSr_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lKS: // global
           _s4kSr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lKT; else goto c4lKU;
       c4lKU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lKW; else goto c4lKV;
       c4lKW: // global
           HpAlloc = 24;
           goto c4lKT;
       c4lKT: // global
           R1 = _s4kSr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lKV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSr::P64;
           _s4kRL::I64 = I64[_s4kSr::P64 + 24];
           _s4kSe::I64 = _s4kRL::I64 - I64[_s4kSr::P64 + 16];
           _s4kSf::I64 = I64[_s4kSr::P64 + 32] - _s4kSe::I64;
           I64[Hp - 16] = go_up_s4kSg_info;
           I64[Hp - 8] = _s4kSe::I64;
           I64[Hp] = _s4kSf::I64;
           R2 = _s4kRL::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kSg_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSd_entry() //  [R1]
         { info_tbl: [(c4lL6,
                       label: sat_s4kSd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lL6: // global
           _s4kSd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lL7; else goto c4lL8;
       c4lL8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lLa; else goto c4lL9;
       c4lLa: // global
           HpAlloc = 16;
           goto c4lL7;
       c4lL7: // global
           R1 = _s4kSd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lL9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSd::P64;
           _s4kRK::I64 = I64[_s4kSd::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4lLg; else goto c4lL5;
       c4lL5: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4lLg; else goto c4lLk;
       c4lLg: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4lLk: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSv_entry() //  [R1]
         { info_tbl: [(c4lLy,
                       label: sat_s4kSv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lLy: // global
           _s4kSv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lLz; else goto c4lLA;
       c4lLA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lLC; else goto c4lLB;
       c4lLC: // global
           HpAlloc = 16;
           goto c4lLz;
       c4lLz: // global
           R1 = _s4kSv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lLB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSv::P64;
           _s4kRK::I64 = I64[_s4kSv::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4lLI; else goto c4lLx;
       c4lLx: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4lLI; else goto c4lLM;
       c4lLI: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4lLM: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4lLQ,
                       label: GHC.Int.$w$cenumFromThenTo3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lLQ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4lLU; else goto c4lLT;
       c4lLU: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lLT: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4lLO; else goto c4lLP;
       c4lLO: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4lLX; else goto c4lM2;
       c4lLX: // global
           I64[Hp - 80] = sat_s4kS5_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kRR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lM2: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4lM9; else goto c4lM0;
       c4lM0: // global
           I64[Hp - 80] = sat_s4kS9_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lLY::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lLY::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lLP: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4lM5; else goto c4lMa;
       c4lM5: // global
           I64[Hp - 80] = sat_s4kSr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kSd_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lMa: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4lM9; else goto c4lM8;
       c4lM9: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lM8: // global
           I64[Hp - 80] = sat_s4kSv_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lM6::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lM6::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.54316493 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4lMi,
                       label: GHC.Int.$fEnumInt8_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lMi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4lMr; else goto c4lMs;
       c4lMr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lMs: // global
           I64[Sp - 24] = block_c4lMf_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4lMB; else goto c4lMg;
       u4lMB: // global
           call _c4lMf(R1) args: 0, res: 0, upd: 0;
       c4lMg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lMf() //  [R1]
         { info_tbl: [(c4lMf,
                       label: block_c4lMf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lMf: // global
           I64[Sp] = block_c4lMl_info;
           _s4kSA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kSA::I64;
           if (R1 & 7 != 0) goto u4lMA; else goto c4lMm;
       u4lMA: // global
           call _c4lMl(R1) args: 0, res: 0, upd: 0;
       c4lMm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lMl() //  [R1]
         { info_tbl: [(c4lMl,
                       label: block_c4lMl_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lMl: // global
           I64[Sp] = block_c4lMq_info;
           _s4kSC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kSC::I64;
           if (R1 & 7 != 0) goto u4lMC; else goto c4lMv;
       u4lMC: // global
           call _c4lMq(R1) args: 0, res: 0, upd: 0;
       c4lMv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lMq() //  [R1]
         { info_tbl: [(c4lMq,
                       label: block_c4lMq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lMq: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo3_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.545658698 UTC

[section ""data" . GHC.Int.$w$cenumFromTo3_closure" {
     GHC.Int.$w$cenumFromTo3_closure:
         const GHC.Int.$w$cenumFromTo3_info;
         const 0;
 },
 sat_s4kSP_entry() //  [R1]
         { info_tbl: [(c4lMY,
                       label: sat_s4kSP_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lMY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lMZ; else goto c4lN0;
       c4lMZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lN0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kSJ::I64 = I64[R1 + 32];
           if (_s4kSJ::I64 == I64[R1 + 24]) goto c4lMX; else goto c4lMW;
       c4lMX: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4lMW: // global
           R2 = _s4kSJ::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kSI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSM_entry() //  [R1]
         { info_tbl: [(c4lNc,
                       label: sat_s4kSM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lNc: // global
           _s4kSM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lNd; else goto c4lNe;
       c4lNe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lNg; else goto c4lNf;
       c4lNg: // global
           HpAlloc = 16;
           goto c4lNd;
       c4lNd: // global
           R1 = _s4kSM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lNf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSM::P64;
           _s4kSJ::I64 = I64[_s4kSM::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSJ::I64, (-128))) goto c4lNm; else goto c4lNb;
       c4lNb: // global
           if (%MO_S_Gt_W64(_s4kSJ::I64, 127)) goto c4lNm; else goto c4lNq;
       c4lNm: // global
           Hp = Hp - 16;
           R2 = _s4kSJ::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4lNq: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSJ::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kSI_entry() //  [R1, R2]
         { info_tbl: [(c4lNs,
                       label: go_s4kSI_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lNs: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4lNw; else goto c4lNv;
       c4lNw: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lNv: // global
           _s4kSG::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kSP_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kSG::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kSM_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo3_entry() //  [R2, R3]
         { info_tbl: [(c4lNA,
                       label: GHC.Int.$w$cenumFromTo3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lNA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lNE; else goto c4lND;
       c4lNE: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lND: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4lNy; else goto c4lNz;
       c4lNy: // global
           I64[Hp - 8] = go_s4kSI_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kSI_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4lNz: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.548041389 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4lNM,
                       label: GHC.Int.$fEnumInt8_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lNM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lNQ; else goto c4lNR;
       c4lNQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lNR: // global
           I64[Sp - 16] = block_c4lNJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4lNZ; else goto c4lNK;
       u4lNZ: // global
           call _c4lNJ(R1) args: 0, res: 0, upd: 0;
       c4lNK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lNJ() //  [R1]
         { info_tbl: [(c4lNJ,
                       label: block_c4lNJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lNJ: // global
           I64[Sp] = block_c4lNP_info;
           _s4kST::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kST::I64;
           if (R1 & 7 != 0) goto u4lNY; else goto c4lNT;
       u4lNY: // global
           call _c4lNP(R1) args: 0, res: 0, upd: 0;
       c4lNT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lNP() //  [R1]
         { info_tbl: [(c4lNP,
                       label: block_c4lNP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lNP: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo3_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.55116195 UTC

[section ""data" . GHC.Int.$wgo3_closure" {
     GHC.Int.$wgo3_closure:
         const GHC.Int.$wgo3_info;
         const 0;
 },
 sat_s4kT5_entry() //  [R1]
         { info_tbl: [(c4lOc,
                       label: sat_s4kT5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lOc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4lOd; else goto c4lOo;
       c4lOd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lOo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kT0::I64 = I64[R1 + 16];
           if (_s4kT0::I64 != 127) goto c4lOa; else goto c4lOb;
       c4lOa: // global
           I64[Sp - 24] = block_c4lOi_info;
           R2 = _s4kT0::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 24;
       c4lOb: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4lOi() //  [R1, R2]
         { info_tbl: [(c4lOi,
                       label: block_c4lOi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lOi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lOn; else goto c4lOm;
       c4lOn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4lOm: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSZ_entry() //  [R1]
         { info_tbl: [(c4lOy,
                       label: sat_s4kSZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lOy: // global
           _s4kSZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lOz; else goto c4lOA;
       c4lOA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lOC; else goto c4lOB;
       c4lOC: // global
           HpAlloc = 16;
           goto c4lOz;
       c4lOz: // global
           R1 = _s4kSZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lOB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSZ::P64;
           _s4kSW::I64 = I64[_s4kSZ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSW::I64, (-128))) goto c4lOI; else goto c4lOx;
       c4lOx: // global
           if (%MO_S_Gt_W64(_s4kSW::I64, 127)) goto c4lOI; else goto c4lOM;
       c4lOI: // global
           Hp = Hp - 16;
           R2 = _s4kSW::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4lOM: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo3_entry() //  [R2]
         { info_tbl: [(c4lON,
                       label: GHC.Int.$wgo3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lON: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4lOR; else goto c4lOQ;
       c4lOR: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lOQ: // global
           I64[Hp - 40] = sat_s4kT5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kSZ_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.553218704 UTC

[section ""data" . GHC.Int.$fEnumInt8_go_closure" {
     GHC.Int.$fEnumInt8_go_closure:
         const GHC.Int.$fEnumInt8_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_go_entry() //  [R2]
         { info_tbl: [(c4lOZ,
                       label: GHC.Int.$fEnumInt8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lOZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lP0; else goto c4lP1;
       c4lP0: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lP1: // global
           I64[Sp - 8] = block_c4lOW_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4lOW() //  [R1, R2]
         { info_tbl: [(c4lOW,
                       label: block_c4lOW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lOW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lP4; else goto c4lP3;
       c4lP4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4lP3: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.554675428 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFrom_closure" {
     GHC.Int.$fEnumInt8_$cenumFrom_closure:
         const GHC.Int.$fEnumInt8_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4lPc,
                       label: GHC.Int.$fEnumInt8_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lPc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lPd; else goto c4lPe;
       c4lPd: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lPe: // global
           I64[Sp - 8] = block_c4lP9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lPn; else goto c4lPa;
       u4lPn: // global
           call _c4lP9(R1) args: 0, res: 0, upd: 0;
       c4lPa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lP9() //  [R1]
         { info_tbl: [(c4lP9,
                       label: block_c4lP9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lP9: // global
           _s4kTc::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kTc::I64, 127)) goto c4lPl; else goto c4lPm;
       c4lPl: // global
           R2 = _s4kTc::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_go_entry(R2) args: 8, res: 0, upd: 8;
       c4lPm: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.555836725 UTC

[section ""data" . GHC.Int.$fEnumInt8_closure" {
     GHC.Int.$fEnumInt8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt8_$csucc_closure+1;
         const GHC.Int.$fEnumInt8_$cpred_closure+1;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt8_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4lPs,
                       label: GHC.Int.$fEnumInt8_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lPs: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt8_closure+1;
           R2 = GHC.Int.$fEnumInt8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.556651835 UTC

[section ""cstring" . GHC.Int.$tcInt2_bytes" {
     GHC.Int.$tcInt2_bytes:
         I8[] [73,110,116,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.557465753 UTC

[section ""data" . GHC.Int.$fEnumInt1_closure" {
     GHC.Int.$fEnumInt1_closure:
         const GHC.Int.$fEnumInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt1_entry() //  [R1]
         { info_tbl: [(c4lPD,
                       label: GHC.Int.$fEnumInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lPD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4lPE; else goto c4lPF;
       c4lPE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lPF: // global
           (_c4lPy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4lPy::I64 == 0) goto c4lPA; else goto c4lPz;
       c4lPA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4lPz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4lPy::I64;
           I64[Sp - 24] = block_c4lPB_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4lPB() //  [R1]
         { info_tbl: [(c4lPB,
                       label: block_c4lPB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lPB: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.558683536 UTC

[section ""data" . GHC.Int.$fEnumInt2_closure" {
     GHC.Int.$fEnumInt2_closure:
         const GHC.Int.$fEnumInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt2_entry() //  [R1]
         { info_tbl: [(c4lPR,
                       label: GHC.Int.$fEnumInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lPR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4lPS; else goto c4lPT;
       c4lPS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lPT: // global
           (_c4lPM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4lPM::I64 == 0) goto c4lPO; else goto c4lPN;
       c4lPO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4lPN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4lPM::I64;
           I64[Sp - 24] = block_c4lPP_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4lPP() //  [R1]
         { info_tbl: [(c4lPP,
                       label: block_c4lPP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lPP: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.559980539 UTC

[section ""data" . GHC.Int.neInt16_closure" {
     GHC.Int.neInt16_closure:
         const GHC.Int.neInt16_info;
 },
 GHC.Int.neInt16_entry() //  [R2, R3]
         { info_tbl: [(c4lQ4,
                       label: GHC.Int.neInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lQ4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lQ8; else goto c4lQ9;
       c4lQ8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lQ9: // global
           I64[Sp - 16] = block_c4lQ1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4lQi; else goto c4lQ2;
       u4lQi: // global
           call _c4lQ1(R1) args: 0, res: 0, upd: 0;
       c4lQ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lQ1() //  [R1]
         { info_tbl: [(c4lQ1,
                       label: block_c4lQ1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lQ1: // global
           I64[Sp] = block_c4lQ7_info;
           _s4kTj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kTj::I64;
           if (R1 & 7 != 0) goto u4lQh; else goto c4lQb;
       u4lQh: // global
           call _c4lQ7(R1) args: 0, res: 0, upd: 0;
       c4lQb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lQ7() //  [R1]
         { info_tbl: [(c4lQ7,
                       label: block_c4lQ7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lQ7: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.5613472 UTC

[section ""data" . lvl2_r4kPt_closure" {
     lvl2_r4kPt_closure:
         const lvl2_r4kPt_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r4kPt_entry() //  [R1]
         { info_tbl: [(c4lQp,
                       label: lvl2_r4kPt_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lQp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lQq; else goto c4lQr;
       c4lQq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lQr: // global
           (_c4lQm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4lQm::I64 == 0) goto c4lQo; else goto c4lQn;
       c4lQo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4lQn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4lQm::I64;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.562193362 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cminBound_closure" {
     GHC.Int.$fBoundedInt16_$cminBound_closure:
         const GHC.Int.I16#_con_info;
         const (-32768);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.563071461 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cpred_closure" {
     GHC.Int.$fEnumInt16_$cpred_closure:
         const GHC.Int.$fEnumInt16_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cpred_entry() //  [R2]
         { info_tbl: [(c4lQz,
                       label: GHC.Int.$fEnumInt16_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lQz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lQA; else goto c4lQB;
       c4lQA: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lQB: // global
           I64[Sp - 8] = block_c4lQw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lQT; else goto c4lQx;
       u4lQT: // global
           call _c4lQw(R1) args: 0, res: 0, upd: 0;
       c4lQx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lQw() //  [R1]
         { info_tbl: [(c4lQw,
                       label: block_c4lQw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lQw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lQG; else goto c4lQF;
       c4lQG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4lQF: // global
           _s4kTq::I64 = I64[R1 + 7];
           if (_s4kTq::I64 != (-32768)) goto c4lQR; else goto c4lQS;
       c4lQR: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4kTq::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lQS: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.56425049 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt16_$cmaxBound_closure:
         const GHC.Int.I16#_con_info;
         const 32767;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.564777728 UTC

[section ""data" . GHC.Int.$fBoundedInt16_closure" {
     GHC.Int.$fBoundedInt16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt16_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.565811879 UTC

[section ""data" . GHC.Int.$fEnumInt16_$csucc_closure" {
     GHC.Int.$fEnumInt16_$csucc_closure:
         const GHC.Int.$fEnumInt16_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$csucc_entry() //  [R2]
         { info_tbl: [(c4lR1,
                       label: GHC.Int.$fEnumInt16_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lR1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lR2; else goto c4lR3;
       c4lR2: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lR3: // global
           I64[Sp - 8] = block_c4lQY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lRl; else goto c4lQZ;
       u4lRl: // global
           call _c4lQY(R1) args: 0, res: 0, upd: 0;
       c4lQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lQY() //  [R1]
         { info_tbl: [(c4lQY,
                       label: block_c4lQY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lQY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lR8; else goto c4lR7;
       c4lR8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4lR7: // global
           _s4kTw::I64 = I64[R1 + 7];
           if (_s4kTw::I64 != 32767) goto c4lRj; else goto c4lRk;
       c4lRj: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4kTw::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lRk: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.567370355 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowsPrec_closure" {
     GHC.Int.$fShowInt16_$cshowsPrec_closure:
         const GHC.Int.$fShowInt16_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt16_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4lRt,
                       label: GHC.Int.$fShowInt16_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lRt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4lRE; else goto c4lRF;
       c4lRE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lRF: // global
           I64[Sp - 24] = block_c4lRq_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4lRM; else goto c4lRr;
       u4lRM: // global
           call _c4lRq(R1) args: 0, res: 0, upd: 0;
       c4lRr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lRq() //  [R1]
         { info_tbl: [(c4lRq,
                       label: block_c4lRq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lRq: // global
           I64[Sp] = block_c4lRw_info;
           _s4kTD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kTD::I64;
           if (R1 & 7 != 0) goto u4lRL; else goto c4lRx;
       u4lRL: // global
           call _c4lRw(R1) args: 0, res: 0, upd: 0;
       c4lRx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lRw() //  [R1]
         { info_tbl: [(c4lRw,
                       label: block_c4lRw_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lRw: // global
           _s4kTB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4lRB_info;
           R4 = _s4kTB::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4lRB() //  [R1, R2]
         { info_tbl: [(c4lRB,
                       label: block_c4lRB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lRB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lRK; else goto c4lRJ;
       c4lRK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4lRJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.569196432 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshow_closure" {
     GHC.Int.$fShowInt16_$cshow_closure:
         const GHC.Int.$fShowInt16_$cshow_info;
 },
 GHC.Int.$fShowInt16_$cshow_entry() //  [R2]
         { info_tbl: [(c4lRU,
                       label: GHC.Int.$fShowInt16_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lRU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lS0; else goto c4lS1;
       c4lS0: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lS1: // global
           I64[Sp - 8] = block_c4lRR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lS6; else goto c4lRS;
       u4lS6: // global
           call _c4lRR(R1) args: 0, res: 0, upd: 0;
       c4lRS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lRR() //  [R1]
         { info_tbl: [(c4lRR,
                       label: block_c4lRR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lRR: // global
           I64[Sp] = block_c4lRX_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4lRX() //  [R1, R2]
         { info_tbl: [(c4lRX,
                       label: block_c4lRX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lRX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lS5; else goto c4lS4;
       c4lS5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4lS4: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.570732535 UTC

[section ""data" . GHC.Int.$fShowInt1_closure" {
     GHC.Int.$fShowInt1_closure:
         const GHC.Int.$fShowInt1_info;
 },
 GHC.Int.$fShowInt1_entry() //  [R2, R3]
         { info_tbl: [(c4lSe,
                       label: GHC.Int.$fShowInt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lSe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lSk; else goto c4lSl;
       c4lSk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lSl: // global
           I64[Sp - 16] = block_c4lSb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4lSq; else goto c4lSc;
       u4lSq: // global
           call _c4lSb(R1) args: 0, res: 0, upd: 0;
       c4lSc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lSb() //  [R1]
         { info_tbl: [(c4lSb,
                       label: block_c4lSb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lSb: // global
           _s4kTQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4lSh_info;
           R4 = _s4kTQ::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4lSh() //  [R1, R2]
         { info_tbl: [(c4lSh,
                       label: block_c4lSh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lSh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lSp; else goto c4lSo;
       c4lSp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4lSo: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.572127115 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowList_closure" {
     GHC.Int.$fShowInt16_$cshowList_closure:
         const GHC.Int.$fShowInt16_$cshowList_info;
 },
 GHC.Int.$fShowInt16_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4lSv,
                       label: GHC.Int.$fShowInt16_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lSv: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.572874193 UTC

[section ""data" . GHC.Int.$fShowInt16_closure" {
     GHC.Int.$fShowInt16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt16_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt16_$cshow_closure+1;
         const GHC.Int.$fShowInt16_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.573607043 UTC

[section ""data" . GHC.Int.$wlvl_closure" {
     GHC.Int.$wlvl_closure:
         const GHC.Int.$wlvl_info;
         const 0;
 },
 GHC.Int.$wlvl_entry() //  [R2]
         { info_tbl: [(c4lSC,
                       label: GHC.Int.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lSC: // global
           R6 = GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r4kPt_closure;
           R2 = GHC.Int.$fShowInt16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.575537619 UTC

[section ""data" . GHC.Int.$w$ctoEnum_closure" {
     GHC.Int.$w$ctoEnum_closure:
         const GHC.Int.$w$ctoEnum_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4lSO,
                       label: GHC.Int.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lSO: // global
           _s4kTZ::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-32768))) goto c4lSW; else goto c4lSN;
       c4lSN: // global
           if (%MO_S_Gt_W64(_s4kTZ::I64, 32767)) goto c4lSW; else goto c4lSX;
       c4lSW: // global
           R2 = _s4kTZ::I64;
           call GHC.Int.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c4lSX: // global
           R1 = _s4kTZ::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.576630698 UTC

[section ""data" . GHC.Int.$fEnumInt16_$ctoEnum_closure" {
     GHC.Int.$fEnumInt16_$ctoEnum_closure:
         const GHC.Int.$fEnumInt16_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4lT5,
                       label: GHC.Int.$fEnumInt16_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lT5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4lTd; else goto c4lTe;
       c4lTd: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lTe: // global
           I64[Sp - 8] = block_c4lT2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4lTj; else goto c4lT3;
       u4lTj: // global
           call _c4lT2(R1) args: 0, res: 0, upd: 0;
       c4lT3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lT2() //  [R1]
         { info_tbl: [(c4lT2,
                       label: block_c4lT2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lT2: // global
           I64[Sp] = block_c4lT8_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4lT8() //  [R1]
         { info_tbl: [(c4lT8,
                       label: block_c4lT8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lT8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lTi; else goto c4lTh;
       c4lTi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4lTh: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.581741314 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo_closure" {
     GHC.Int.$w$cenumFromThenTo_closure:
         const GHC.Int.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s4kUp_entry() //  [R1]
         { info_tbl: [(c4lTS,
                       label: sat_s4kUp_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lTS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lTT; else goto c4lTU;
       c4lTT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lTU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kUi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUn_entry() //  [R1]
         { info_tbl: [(c4lU4,
                       label: sat_s4kUn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lU4: // global
           _s4kUn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lU5; else goto c4lU6;
       c4lU6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lU8; else goto c4lU7;
       c4lU8: // global
           HpAlloc = 16;
           goto c4lU5;
       c4lU5: // global
           R1 = _s4kUn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lU7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUn::P64;
           _s4kUj::I64 = I64[_s4kUn::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUj::I64,
                            (-32768))) goto c4lUe; else goto c4lU3;
       c4lU3: // global
           if (%MO_S_Gt_W64(_s4kUj::I64, 32767)) goto c4lUe; else goto c4lUi;
       c4lUe: // global
           Hp = Hp - 16;
           R2 = _s4kUj::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4lUi: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUs_entry() //  [R1]
         { info_tbl: [(c4lUt,
                       label: sat_s4kUs_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lUt: // global
           _s4kUs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lUu; else goto c4lUv;
       c4lUv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lUx; else goto c4lUw;
       c4lUx: // global
           HpAlloc = 16;
           goto c4lUu;
       c4lUu: // global
           R1 = _s4kUs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lUw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUs::P64;
           _s4kUj::I64 = I64[_s4kUs::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUj::I64,
                            (-32768))) goto c4lUD; else goto c4lUs;
       c4lUs: // global
           if (%MO_S_Gt_W64(_s4kUj::I64, 32767)) goto c4lUD; else goto c4lUH;
       c4lUD: // global
           Hp = Hp - 16;
           R2 = _s4kUj::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4lUH: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kUi_entry() //  [R1, R2]
         { info_tbl: [(c4lUL,
                       label: go_dn_s4kUi_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lUL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4lUP; else goto c4lUO;
       c4lUP: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lUO: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4lUJ; else goto c4lUK;
       c4lUJ: // global
           _s4kUg::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kUp_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kUg::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kUn_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lUK: // global
           I64[Hp - 80] = sat_s4kUs_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lUR::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lUR::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kUt_entry() //  [R1]
         { info_tbl: [(c4lUS,
                       label: sat_s4kUt_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lUS: // global
           _s4kUt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lUT; else goto c4lUU;
       c4lUU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lUW; else goto c4lUV;
       c4lUW: // global
           HpAlloc = 24;
           goto c4lUT;
       c4lUT: // global
           R1 = _s4kUt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lUV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUt::P64;
           _s4kU9::I64 = I64[_s4kUt::P64 + 24];
           _s4kUg::I64 = _s4kU9::I64 - I64[_s4kUt::P64 + 16];
           _s4kUh::I64 = I64[_s4kUt::P64 + 32] - _s4kUg::I64;
           I64[Hp - 16] = go_dn_s4kUi_info;
           I64[Hp - 8] = _s4kUg::I64;
           I64[Hp] = _s4kUh::I64;
           R2 = _s4kU9::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kUi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUf_entry() //  [R1]
         { info_tbl: [(c4lV6,
                       label: sat_s4kUf_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lV6: // global
           _s4kUf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lV7; else goto c4lV8;
       c4lV8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lVa; else goto c4lV9;
       c4lVa: // global
           HpAlloc = 16;
           goto c4lV7;
       c4lV7: // global
           R1 = _s4kUf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lV9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUf::P64;
           _s4kU8::I64 = I64[_s4kUf::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4lVg; else goto c4lV5;
       c4lV5: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4lVg; else goto c4lVk;
       c4lVg: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4lVk: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUx_entry() //  [R1]
         { info_tbl: [(c4lVy,
                       label: sat_s4kUx_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lVy: // global
           _s4kUx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lVz; else goto c4lVA;
       c4lVA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lVC; else goto c4lVB;
       c4lVC: // global
           HpAlloc = 16;
           goto c4lVz;
       c4lVz: // global
           R1 = _s4kUx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lVB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUx::P64;
           _s4kU8::I64 = I64[_s4kUx::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4lVI; else goto c4lVx;
       c4lVx: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4lVI; else goto c4lVM;
       c4lVI: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4lVM: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUL_entry() //  [R1]
         { info_tbl: [(c4lWf,
                       label: sat_s4kUL_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lWf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lWg; else goto c4lWh;
       c4lWg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lWh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kUE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUJ_entry() //  [R1]
         { info_tbl: [(c4lWr,
                       label: sat_s4kUJ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lWr: // global
           _s4kUJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lWs; else goto c4lWt;
       c4lWt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lWv; else goto c4lWu;
       c4lWv: // global
           HpAlloc = 16;
           goto c4lWs;
       c4lWs: // global
           R1 = _s4kUJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lWu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUJ::P64;
           _s4kUF::I64 = I64[_s4kUJ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUF::I64,
                            (-32768))) goto c4lWB; else goto c4lWq;
       c4lWq: // global
           if (%MO_S_Gt_W64(_s4kUF::I64, 32767)) goto c4lWB; else goto c4lWF;
       c4lWB: // global
           Hp = Hp - 16;
           R2 = _s4kUF::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4lWF: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUF::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUO_entry() //  [R1]
         { info_tbl: [(c4lWQ,
                       label: sat_s4kUO_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lWQ: // global
           _s4kUO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lWR; else goto c4lWS;
       c4lWS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lWU; else goto c4lWT;
       c4lWU: // global
           HpAlloc = 16;
           goto c4lWR;
       c4lWR: // global
           R1 = _s4kUO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lWT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUO::P64;
           _s4kUF::I64 = I64[_s4kUO::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUF::I64,
                            (-32768))) goto c4lX0; else goto c4lWP;
       c4lWP: // global
           if (%MO_S_Gt_W64(_s4kUF::I64, 32767)) goto c4lX0; else goto c4lX4;
       c4lX0: // global
           Hp = Hp - 16;
           R2 = _s4kUF::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4lX4: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUF::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kUE_entry() //  [R1, R2]
         { info_tbl: [(c4lX8,
                       label: go_up_s4kUE_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lX8: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4lXc; else goto c4lXb;
       c4lXc: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lXb: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4lX6; else goto c4lX7;
       c4lX6: // global
           _s4kUC::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kUL_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kUC::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kUJ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lX7: // global
           I64[Hp - 80] = sat_s4kUO_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lXe::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lXe::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kUP_entry() //  [R1]
         { info_tbl: [(c4lXf,
                       label: sat_s4kUP_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lXf: // global
           _s4kUP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lXg; else goto c4lXh;
       c4lXh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4lXj; else goto c4lXi;
       c4lXj: // global
           HpAlloc = 24;
           goto c4lXg;
       c4lXg: // global
           R1 = _s4kUP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lXi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUP::P64;
           _s4kU9::I64 = I64[_s4kUP::P64 + 24];
           _s4kUC::I64 = _s4kU9::I64 - I64[_s4kUP::P64 + 16];
           _s4kUD::I64 = I64[_s4kUP::P64 + 32] - _s4kUC::I64;
           I64[Hp - 16] = go_up_s4kUE_info;
           I64[Hp - 8] = _s4kUC::I64;
           I64[Hp] = _s4kUD::I64;
           R2 = _s4kU9::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kUE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUB_entry() //  [R1]
         { info_tbl: [(c4lXt,
                       label: sat_s4kUB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lXt: // global
           _s4kUB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lXu; else goto c4lXv;
       c4lXv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lXx; else goto c4lXw;
       c4lXx: // global
           HpAlloc = 16;
           goto c4lXu;
       c4lXu: // global
           R1 = _s4kUB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lXw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUB::P64;
           _s4kU8::I64 = I64[_s4kUB::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4lXD; else goto c4lXs;
       c4lXs: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4lXD; else goto c4lXH;
       c4lXD: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4lXH: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUT_entry() //  [R1]
         { info_tbl: [(c4lXV,
                       label: sat_s4kUT_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lXV: // global
           _s4kUT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lXW; else goto c4lXX;
       c4lXX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lXZ; else goto c4lXY;
       c4lXZ: // global
           HpAlloc = 16;
           goto c4lXW;
       c4lXW: // global
           R1 = _s4kUT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lXY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUT::P64;
           _s4kU8::I64 = I64[_s4kUT::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4lY5; else goto c4lXU;
       c4lXU: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4lY5; else goto c4lY9;
       c4lY5: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4lY9: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4lYd,
                       label: GHC.Int.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lYd: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4lYh; else goto c4lYg;
       c4lYh: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lYg: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4lYb; else goto c4lYc;
       c4lYb: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4lYk; else goto c4lYp;
       c4lYk: // global
           I64[Hp - 80] = sat_s4kUt_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kUf_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lYp: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4lYw; else goto c4lYn;
       c4lYn: // global
           I64[Hp - 80] = sat_s4kUx_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lYl::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lYl::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lYc: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4lYs; else goto c4lYx;
       c4lYs: // global
           I64[Hp - 80] = sat_s4kUP_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kUB_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lYx: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4lYw; else goto c4lYv;
       c4lYw: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4lYv: // global
           I64[Hp - 80] = sat_s4kUT_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4lYt::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4lYt::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.589337148 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4lYF,
                       label: GHC.Int.$fEnumInt16_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lYF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4lYO; else goto c4lYP;
       c4lYO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4lYP: // global
           I64[Sp - 24] = block_c4lYC_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4lYY; else goto c4lYD;
       u4lYY: // global
           call _c4lYC(R1) args: 0, res: 0, upd: 0;
       c4lYD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lYC() //  [R1]
         { info_tbl: [(c4lYC,
                       label: block_c4lYC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lYC: // global
           I64[Sp] = block_c4lYI_info;
           _s4kUY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kUY::I64;
           if (R1 & 7 != 0) goto u4lYX; else goto c4lYJ;
       u4lYX: // global
           call _c4lYI(R1) args: 0, res: 0, upd: 0;
       c4lYJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lYI() //  [R1]
         { info_tbl: [(c4lYI,
                       label: block_c4lYI_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lYI: // global
           I64[Sp] = block_c4lYN_info;
           _s4kV0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kV0::I64;
           if (R1 & 7 != 0) goto u4lYZ; else goto c4lYS;
       u4lYZ: // global
           call _c4lYN(R1) args: 0, res: 0, upd: 0;
       c4lYS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4lYN() //  [R1]
         { info_tbl: [(c4lYN,
                       label: block_c4lYN_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lYN: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.591748032 UTC

[section ""data" . GHC.Int.$w$cenumFromTo_closure" {
     GHC.Int.$w$cenumFromTo_closure:
         const GHC.Int.$w$cenumFromTo_info;
         const 0;
 },
 sat_s4kVd_entry() //  [R1]
         { info_tbl: [(c4lZl,
                       label: sat_s4kVd_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lZl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4lZm; else goto c4lZn;
       c4lZm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lZn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kV7::I64 = I64[R1 + 32];
           if (_s4kV7::I64 == I64[R1 + 24]) goto c4lZk; else goto c4lZj;
       c4lZk: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4lZj: // global
           R2 = _s4kV7::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kV6_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kVa_entry() //  [R1]
         { info_tbl: [(c4lZz,
                       label: sat_s4kVa_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lZz: // global
           _s4kVa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4lZA; else goto c4lZB;
       c4lZB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4lZD; else goto c4lZC;
       c4lZD: // global
           HpAlloc = 16;
           goto c4lZA;
       c4lZA: // global
           R1 = _s4kVa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4lZC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kVa::P64;
           _s4kV7::I64 = I64[_s4kVa::P64 + 16];
           if (%MO_S_Lt_W64(_s4kV7::I64,
                            (-32768))) goto c4lZJ; else goto c4lZy;
       c4lZy: // global
           if (%MO_S_Gt_W64(_s4kV7::I64, 32767)) goto c4lZJ; else goto c4lZN;
       c4lZJ: // global
           Hp = Hp - 16;
           R2 = _s4kV7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4lZN: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kV7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kV6_entry() //  [R1, R2]
         { info_tbl: [(c4lZP,
                       label: go_s4kV6_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lZP: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4lZT; else goto c4lZS;
       c4lZT: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4lZS: // global
           _s4kV4::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kVd_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kV4::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kVa_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4lZX,
                       label: GHC.Int.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4lZX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4m01; else goto c4m00;
       c4m01: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4m00: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4lZV; else goto c4lZW;
       c4lZV: // global
           I64[Hp - 8] = go_s4kV6_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kV6_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4lZW: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.594082594 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4m09,
                       label: GHC.Int.$fEnumInt16_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m09: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4m0d; else goto c4m0e;
       c4m0d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4m0e: // global
           I64[Sp - 16] = block_c4m06_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4m0m; else goto c4m07;
       u4m0m: // global
           call _c4m06(R1) args: 0, res: 0, upd: 0;
       c4m07: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m06() //  [R1]
         { info_tbl: [(c4m06,
                       label: block_c4m06_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m06: // global
           I64[Sp] = block_c4m0c_info;
           _s4kVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kVh::I64;
           if (R1 & 7 != 0) goto u4m0l; else goto c4m0g;
       u4m0l: // global
           call _c4m0c(R1) args: 0, res: 0, upd: 0;
       c4m0g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m0c() //  [R1]
         { info_tbl: [(c4m0c,
                       label: block_c4m0c_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m0c: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.596013221 UTC

[section ""data" . GHC.Int.$wgo_closure" {
     GHC.Int.$wgo_closure:
         const GHC.Int.$wgo_info;
         const 0;
 },
 sat_s4kVt_entry() //  [R1]
         { info_tbl: [(c4m0z,
                       label: sat_s4kVt_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m0z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4m0A; else goto c4m0L;
       c4m0A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m0L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kVo::I64 = I64[R1 + 16];
           if (_s4kVo::I64 != 32767) goto c4m0x; else goto c4m0y;
       c4m0x: // global
           I64[Sp - 24] = block_c4m0F_info;
           R2 = _s4kVo::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c4m0y: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4m0F() //  [R1, R2]
         { info_tbl: [(c4m0F,
                       label: block_c4m0F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m0F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4m0K; else goto c4m0J;
       c4m0K: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4m0J: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kVn_entry() //  [R1]
         { info_tbl: [(c4m0V,
                       label: sat_s4kVn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m0V: // global
           _s4kVn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4m0W; else goto c4m0X;
       c4m0X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4m0Z; else goto c4m0Y;
       c4m0Z: // global
           HpAlloc = 16;
           goto c4m0W;
       c4m0W: // global
           R1 = _s4kVn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m0Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kVn::P64;
           _s4kVk::I64 = I64[_s4kVn::P64 + 16];
           if (%MO_S_Lt_W64(_s4kVk::I64,
                            (-32768))) goto c4m15; else goto c4m0U;
       c4m0U: // global
           if (%MO_S_Gt_W64(_s4kVk::I64, 32767)) goto c4m15; else goto c4m19;
       c4m15: // global
           Hp = Hp - 16;
           R2 = _s4kVk::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4m19: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kVk::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo_entry() //  [R2]
         { info_tbl: [(c4m1a,
                       label: GHC.Int.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m1a: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4m1e; else goto c4m1d;
       c4m1e: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m1d: // global
           I64[Hp - 40] = sat_s4kVt_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kVn_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.598225974 UTC

[section ""data" . GHC.Int.$fEnumInt16_go_closure" {
     GHC.Int.$fEnumInt16_go_closure:
         const GHC.Int.$fEnumInt16_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_go_entry() //  [R2]
         { info_tbl: [(c4m1m,
                       label: GHC.Int.$fEnumInt16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m1m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4m1n; else goto c4m1o;
       c4m1n: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m1o: // global
           I64[Sp - 8] = block_c4m1j_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4m1j() //  [R1, R2]
         { info_tbl: [(c4m1j,
                       label: block_c4m1j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m1j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4m1r; else goto c4m1q;
       c4m1r: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4m1q: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.600545998 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFrom_closure" {
     GHC.Int.$fEnumInt16_$cenumFrom_closure:
         const GHC.Int.$fEnumInt16_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4m1z,
                       label: GHC.Int.$fEnumInt16_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m1z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4m1A; else goto c4m1B;
       c4m1A: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m1B: // global
           I64[Sp - 8] = block_c4m1w_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4m1K; else goto c4m1x;
       u4m1K: // global
           call _c4m1w(R1) args: 0, res: 0, upd: 0;
       c4m1x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m1w() //  [R1]
         { info_tbl: [(c4m1w,
                       label: block_c4m1w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m1w: // global
           _s4kVA::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kVA::I64, 32767)) goto c4m1I; else goto c4m1J;
       c4m1I: // global
           R2 = _s4kVA::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_go_entry(R2) args: 8, res: 0, upd: 8;
       c4m1J: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.60176042 UTC

[section ""data" . GHC.Int.$fEnumInt16_closure" {
     GHC.Int.$fEnumInt16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt16_$csucc_closure+1;
         const GHC.Int.$fEnumInt16_$cpred_closure+1;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt16_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4m1P,
                       label: GHC.Int.$fEnumInt16_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m1P: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt16_closure+1;
           R2 = GHC.Int.$fEnumInt16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.602588603 UTC

[section ""cstring" . GHC.Int.$tcInt4_bytes" {
     GHC.Int.$tcInt4_bytes:
         I8[] [73,110,116,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.603393201 UTC

[section ""data" . GHC.Int.$fEnumInt3_closure" {
     GHC.Int.$fEnumInt3_closure:
         const GHC.Int.$fEnumInt3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt3_entry() //  [R1]
         { info_tbl: [(c4m20,
                       label: GHC.Int.$fEnumInt3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m20: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4m21; else goto c4m22;
       c4m21: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m22: // global
           (_c4m1V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4m1V::I64 == 0) goto c4m1X; else goto c4m1W;
       c4m1X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4m1W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4m1V::I64;
           I64[Sp - 24] = block_c4m1Y_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4m1Y() //  [R1]
         { info_tbl: [(c4m1Y,
                       label: block_c4m1Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m1Y: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.604617129 UTC

[section ""data" . GHC.Int.$fEnumInt4_closure" {
     GHC.Int.$fEnumInt4_closure:
         const GHC.Int.$fEnumInt4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt4_entry() //  [R1]
         { info_tbl: [(c4m2e,
                       label: GHC.Int.$fEnumInt4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m2e: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4m2f; else goto c4m2g;
       c4m2f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m2g: // global
           (_c4m29::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4m29::I64 == 0) goto c4m2b; else goto c4m2a;
       c4m2b: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4m2a: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4m29::I64;
           I64[Sp - 24] = block_c4m2c_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4m2c() //  [R1]
         { info_tbl: [(c4m2c,
                       label: block_c4m2c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m2c: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.606157303 UTC

[section ""data" . GHC.Int.neInt32_closure" {
     GHC.Int.neInt32_closure:
         const GHC.Int.neInt32_info;
 },
 GHC.Int.neInt32_entry() //  [R2, R3]
         { info_tbl: [(c4m2r,
                       label: GHC.Int.neInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m2r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4m2v; else goto c4m2w;
       c4m2v: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4m2w: // global
           I64[Sp - 16] = block_c4m2o_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4m2F; else goto c4m2p;
       u4m2F: // global
           call _c4m2o(R1) args: 0, res: 0, upd: 0;
       c4m2p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m2o() //  [R1]
         { info_tbl: [(c4m2o,
                       label: block_c4m2o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m2o: // global
           I64[Sp] = block_c4m2u_info;
           _s4kVH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kVH::I64;
           if (R1 & 7 != 0) goto u4m2E; else goto c4m2y;
       u4m2E: // global
           call _c4m2u(R1) args: 0, res: 0, upd: 0;
       c4m2y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m2u() //  [R1]
         { info_tbl: [(c4m2u,
                       label: block_c4m2u_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m2u: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.607505406 UTC

[section ""data" . lvl4_r4kPv_closure" {
     lvl4_r4kPv_closure:
         const lvl4_r4kPv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r4kPv_entry() //  [R1]
         { info_tbl: [(c4m2M,
                       label: lvl4_r4kPv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m2M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4m2N; else goto c4m2O;
       c4m2N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m2O: // global
           (_c4m2J::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4m2J::I64 == 0) goto c4m2L; else goto c4m2K;
       c4m2L: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4m2K: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4m2J::I64;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.608392032 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cminBound_closure" {
     GHC.Int.$fBoundedInt32_$cminBound_closure:
         const GHC.Int.I32#_con_info;
         const (-2147483648);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.609340871 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cpred_closure" {
     GHC.Int.$fEnumInt32_$cpred_closure:
         const GHC.Int.$fEnumInt32_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cpred_entry() //  [R2]
         { info_tbl: [(c4m2W,
                       label: GHC.Int.$fEnumInt32_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m2W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4m2X; else goto c4m2Y;
       c4m2X: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m2Y: // global
           I64[Sp - 8] = block_c4m2T_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4m3g; else goto c4m2U;
       u4m3g: // global
           call _c4m2T(R1) args: 0, res: 0, upd: 0;
       c4m2U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m2T() //  [R1]
         { info_tbl: [(c4m2T,
                       label: block_c4m2T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m2T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4m33; else goto c4m32;
       c4m33: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4m32: // global
           _s4kVO::I64 = I64[R1 + 7];
           if (_s4kVO::I64 != (-2147483648)) goto c4m3e; else goto c4m3f;
       c4m3e: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4kVO::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4m3f: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.610560777 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt32_$cmaxBound_closure:
         const GHC.Int.I32#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.611128099 UTC

[section ""data" . GHC.Int.$fBoundedInt32_closure" {
     GHC.Int.$fBoundedInt32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt32_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.612016982 UTC

[section ""data" . GHC.Int.$fEnumInt32_$csucc_closure" {
     GHC.Int.$fEnumInt32_$csucc_closure:
         const GHC.Int.$fEnumInt32_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$csucc_entry() //  [R2]
         { info_tbl: [(c4m3o,
                       label: GHC.Int.$fEnumInt32_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m3o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4m3p; else goto c4m3q;
       c4m3p: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m3q: // global
           I64[Sp - 8] = block_c4m3l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4m3I; else goto c4m3m;
       u4m3I: // global
           call _c4m3l(R1) args: 0, res: 0, upd: 0;
       c4m3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m3l() //  [R1]
         { info_tbl: [(c4m3l,
                       label: block_c4m3l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m3l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4m3v; else goto c4m3u;
       c4m3v: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4m3u: // global
           _s4kVU::I64 = I64[R1 + 7];
           if (_s4kVU::I64 != 2147483647) goto c4m3G; else goto c4m3H;
       c4m3G: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4kVU::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4m3H: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.613654475 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowsPrec_closure" {
     GHC.Int.$fShowInt32_$cshowsPrec_closure:
         const GHC.Int.$fShowInt32_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt32_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4m3Q,
                       label: GHC.Int.$fShowInt32_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m3Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4m41; else goto c4m42;
       c4m41: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4m42: // global
           I64[Sp - 24] = block_c4m3N_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4m49; else goto c4m3O;
       u4m49: // global
           call _c4m3N(R1) args: 0, res: 0, upd: 0;
       c4m3O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m3N() //  [R1]
         { info_tbl: [(c4m3N,
                       label: block_c4m3N_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m3N: // global
           I64[Sp] = block_c4m3T_info;
           _s4kW1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kW1::I64;
           if (R1 & 7 != 0) goto u4m48; else goto c4m3U;
       u4m48: // global
           call _c4m3T(R1) args: 0, res: 0, upd: 0;
       c4m3U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m3T() //  [R1]
         { info_tbl: [(c4m3T,
                       label: block_c4m3T_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m3T: // global
           _s4kVZ::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4m3Y_info;
           R4 = _s4kVZ::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4m3Y() //  [R1, R2]
         { info_tbl: [(c4m3Y,
                       label: block_c4m3Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m3Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4m47; else goto c4m46;
       c4m47: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4m46: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.615417833 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshow_closure" {
     GHC.Int.$fShowInt32_$cshow_closure:
         const GHC.Int.$fShowInt32_$cshow_info;
 },
 GHC.Int.$fShowInt32_$cshow_entry() //  [R2]
         { info_tbl: [(c4m4h,
                       label: GHC.Int.$fShowInt32_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m4h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4m4n; else goto c4m4o;
       c4m4n: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m4o: // global
           I64[Sp - 8] = block_c4m4e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4m4t; else goto c4m4f;
       u4m4t: // global
           call _c4m4e(R1) args: 0, res: 0, upd: 0;
       c4m4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m4e() //  [R1]
         { info_tbl: [(c4m4e,
                       label: block_c4m4e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m4e: // global
           I64[Sp] = block_c4m4k_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4m4k() //  [R1, R2]
         { info_tbl: [(c4m4k,
                       label: block_c4m4k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m4k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4m4s; else goto c4m4r;
       c4m4s: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4m4r: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.61697202 UTC

[section ""data" . GHC.Int.$fShowInt2_closure" {
     GHC.Int.$fShowInt2_closure:
         const GHC.Int.$fShowInt2_info;
 },
 GHC.Int.$fShowInt2_entry() //  [R2, R3]
         { info_tbl: [(c4m4B,
                       label: GHC.Int.$fShowInt2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m4B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4m4H; else goto c4m4I;
       c4m4H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4m4I: // global
           I64[Sp - 16] = block_c4m4y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4m4N; else goto c4m4z;
       u4m4N: // global
           call _c4m4y(R1) args: 0, res: 0, upd: 0;
       c4m4z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m4y() //  [R1]
         { info_tbl: [(c4m4y,
                       label: block_c4m4y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m4y: // global
           _s4kWe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4m4E_info;
           R4 = _s4kWe::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4m4E() //  [R1, R2]
         { info_tbl: [(c4m4E,
                       label: block_c4m4E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m4E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4m4M; else goto c4m4L;
       c4m4M: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4m4L: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.618409673 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowList_closure" {
     GHC.Int.$fShowInt32_$cshowList_closure:
         const GHC.Int.$fShowInt32_$cshowList_info;
 },
 GHC.Int.$fShowInt32_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4m4S,
                       label: GHC.Int.$fShowInt32_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m4S: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.61920627 UTC

[section ""data" . GHC.Int.$fShowInt32_closure" {
     GHC.Int.$fShowInt32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt32_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt32_$cshow_closure+1;
         const GHC.Int.$fShowInt32_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.619940526 UTC

[section ""data" . GHC.Int.$wlvl1_closure" {
     GHC.Int.$wlvl1_closure:
         const GHC.Int.$wlvl1_info;
         const 0;
 },
 GHC.Int.$wlvl1_entry() //  [R2]
         { info_tbl: [(c4m4Z,
                       label: GHC.Int.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m4Z: // global
           R6 = GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r4kPv_closure;
           R2 = GHC.Int.$fShowInt32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.621054587 UTC

[section ""data" . GHC.Int.$w$ctoEnum1_closure" {
     GHC.Int.$w$ctoEnum1_closure:
         const GHC.Int.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum1_entry() //  [R2]
         { info_tbl: [(c4m5b,
                       label: GHC.Int.$w$ctoEnum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m5b: // global
           _s4kWn::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-2147483648))) goto c4m5j; else goto c4m5a;
       c4m5a: // global
           if (%MO_S_Gt_W64(_s4kWn::I64,
                            2147483647)) goto c4m5j; else goto c4m5k;
       c4m5j: // global
           R2 = _s4kWn::I64;
           call GHC.Int.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c4m5k: // global
           R1 = _s4kWn::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.622296318 UTC

[section ""data" . GHC.Int.$fEnumInt32_$ctoEnum_closure" {
     GHC.Int.$fEnumInt32_$ctoEnum_closure:
         const GHC.Int.$fEnumInt32_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4m5s,
                       label: GHC.Int.$fEnumInt32_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m5s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4m5A; else goto c4m5B;
       c4m5A: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m5B: // global
           I64[Sp - 8] = block_c4m5p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4m5G; else goto c4m5q;
       u4m5G: // global
           call _c4m5p(R1) args: 0, res: 0, upd: 0;
       c4m5q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m5p() //  [R1]
         { info_tbl: [(c4m5p,
                       label: block_c4m5p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m5p: // global
           I64[Sp] = block_c4m5v_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4m5v() //  [R1]
         { info_tbl: [(c4m5v,
                       label: block_c4m5v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m5v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4m5F; else goto c4m5E;
       c4m5F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4m5E: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.625400565 UTC

[section ""data" . GHC.Int.$w$cenumFromTo1_closure" {
     GHC.Int.$w$cenumFromTo1_closure:
         const GHC.Int.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s4kWG_entry() //  [R1]
         { info_tbl: [(c4m62,
                       label: sat_s4kWG_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m62: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4m63; else goto c4m64;
       c4m63: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m64: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kWA::I64 = I64[R1 + 32];
           if (_s4kWA::I64 == I64[R1 + 24]) goto c4m61; else goto c4m60;
       c4m61: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4m60: // global
           R2 = _s4kWA::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kWz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kWD_entry() //  [R1]
         { info_tbl: [(c4m6g,
                       label: sat_s4kWD_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m6g: // global
           _s4kWD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4m6h; else goto c4m6i;
       c4m6i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4m6k; else goto c4m6j;
       c4m6k: // global
           HpAlloc = 16;
           goto c4m6h;
       c4m6h: // global
           R1 = _s4kWD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m6j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kWD::P64;
           _s4kWA::I64 = I64[_s4kWD::P64 + 16];
           if (%MO_S_Lt_W64(_s4kWA::I64,
                            (-2147483648))) goto c4m6q; else goto c4m6f;
       c4m6f: // global
           if (%MO_S_Gt_W64(_s4kWA::I64,
                            2147483647)) goto c4m6q; else goto c4m6u;
       c4m6q: // global
           Hp = Hp - 16;
           R2 = _s4kWA::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4m6u: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kWA::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kWz_entry() //  [R1, R2]
         { info_tbl: [(c4m6w,
                       label: go_s4kWz_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m6w: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4m6A; else goto c4m6z;
       c4m6A: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m6z: // global
           _s4kWx::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kWG_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kWx::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kWD_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo1_entry() //  [R2, R3]
         { info_tbl: [(c4m6E,
                       label: GHC.Int.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m6E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4m6I; else goto c4m6H;
       c4m6I: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4m6H: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4m6C; else goto c4m6D;
       c4m6C: // global
           I64[Hp - 8] = go_s4kWz_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kWz_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4m6D: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.627689203 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4m6Q,
                       label: GHC.Int.$fEnumInt32_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m6Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4m6U; else goto c4m6V;
       c4m6U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4m6V: // global
           I64[Sp - 16] = block_c4m6N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4m73; else goto c4m6O;
       u4m73: // global
           call _c4m6N(R1) args: 0, res: 0, upd: 0;
       c4m6O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m6N() //  [R1]
         { info_tbl: [(c4m6N,
                       label: block_c4m6N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m6N: // global
           I64[Sp] = block_c4m6T_info;
           _s4kWK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kWK::I64;
           if (R1 & 7 != 0) goto u4m72; else goto c4m6X;
       u4m72: // global
           call _c4m6T(R1) args: 0, res: 0, upd: 0;
       c4m6X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m6T() //  [R1]
         { info_tbl: [(c4m6T,
                       label: block_c4m6T_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m6T: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.629890715 UTC

[section ""data" . GHC.Int.$wgo1_closure" {
     GHC.Int.$wgo1_closure:
         const GHC.Int.$wgo1_info;
         const 0;
 },
 sat_s4kWW_entry() //  [R1]
         { info_tbl: [(c4m7g,
                       label: sat_s4kWW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m7g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4m7h; else goto c4m7s;
       c4m7h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m7s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kWR::I64 = I64[R1 + 16];
           if (_s4kWR::I64 != 2147483647) goto c4m7e; else goto c4m7f;
       c4m7e: // global
           I64[Sp - 24] = block_c4m7m_info;
           R2 = _s4kWR::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c4m7f: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4m7m() //  [R1, R2]
         { info_tbl: [(c4m7m,
                       label: block_c4m7m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m7m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4m7r; else goto c4m7q;
       c4m7r: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4m7q: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kWQ_entry() //  [R1]
         { info_tbl: [(c4m7C,
                       label: sat_s4kWQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m7C: // global
           _s4kWQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4m7D; else goto c4m7E;
       c4m7E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4m7G; else goto c4m7F;
       c4m7G: // global
           HpAlloc = 16;
           goto c4m7D;
       c4m7D: // global
           R1 = _s4kWQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m7F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kWQ::P64;
           _s4kWN::I64 = I64[_s4kWQ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kWN::I64,
                            (-2147483648))) goto c4m7M; else goto c4m7B;
       c4m7B: // global
           if (%MO_S_Gt_W64(_s4kWN::I64,
                            2147483647)) goto c4m7M; else goto c4m7Q;
       c4m7M: // global
           Hp = Hp - 16;
           R2 = _s4kWN::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4m7Q: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kWN::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo1_entry() //  [R2]
         { info_tbl: [(c4m7R,
                       label: GHC.Int.$wgo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m7R: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4m7V; else goto c4m7U;
       c4m7V: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m7U: // global
           I64[Hp - 40] = sat_s4kWW_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kWQ_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.631970403 UTC

[section ""data" . GHC.Int.$fEnumInt32_go_closure" {
     GHC.Int.$fEnumInt32_go_closure:
         const GHC.Int.$fEnumInt32_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_go_entry() //  [R2]
         { info_tbl: [(c4m83,
                       label: GHC.Int.$fEnumInt32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m83: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4m84; else goto c4m85;
       c4m84: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m85: // global
           I64[Sp - 8] = block_c4m80_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4m80() //  [R1, R2]
         { info_tbl: [(c4m80,
                       label: block_c4m80_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m80: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4m88; else goto c4m87;
       c4m88: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4m87: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.633309465 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFrom_closure" {
     GHC.Int.$fEnumInt32_$cenumFrom_closure:
         const GHC.Int.$fEnumInt32_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4m8g,
                       label: GHC.Int.$fEnumInt32_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m8g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4m8h; else goto c4m8i;
       c4m8h: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m8i: // global
           I64[Sp - 8] = block_c4m8d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4m8r; else goto c4m8e;
       u4m8r: // global
           call _c4m8d(R1) args: 0, res: 0, upd: 0;
       c4m8e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4m8d() //  [R1]
         { info_tbl: [(c4m8d,
                       label: block_c4m8d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m8d: // global
           _s4kX3::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kX3::I64,
                            2147483647)) goto c4m8p; else goto c4m8q;
       c4m8p: // global
           R2 = _s4kX3::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_go_entry(R2) args: 8, res: 0, upd: 8;
       c4m8q: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.638067277 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo1_closure" {
     GHC.Int.$w$cenumFromThenTo1_closure:
         const GHC.Int.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s4kXm_entry() //  [R1]
         { info_tbl: [(c4m90,
                       label: sat_s4kXm_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m90: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4m91; else goto c4m92;
       c4m91: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m92: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kXf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXk_entry() //  [R1]
         { info_tbl: [(c4m9c,
                       label: sat_s4kXk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m9c: // global
           _s4kXk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4m9d; else goto c4m9e;
       c4m9e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4m9g; else goto c4m9f;
       c4m9g: // global
           HpAlloc = 16;
           goto c4m9d;
       c4m9d: // global
           R1 = _s4kXk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m9f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXk::P64;
           _s4kXg::I64 = I64[_s4kXk::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXg::I64,
                            (-2147483648))) goto c4m9m; else goto c4m9b;
       c4m9b: // global
           if (%MO_S_Gt_W64(_s4kXg::I64,
                            2147483647)) goto c4m9m; else goto c4m9q;
       c4m9m: // global
           Hp = Hp - 16;
           R2 = _s4kXg::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4m9q: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXg::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXp_entry() //  [R1]
         { info_tbl: [(c4m9B,
                       label: sat_s4kXp_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m9B: // global
           _s4kXp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4m9C; else goto c4m9D;
       c4m9D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4m9F; else goto c4m9E;
       c4m9F: // global
           HpAlloc = 16;
           goto c4m9C;
       c4m9C: // global
           R1 = _s4kXp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4m9E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXp::P64;
           _s4kXg::I64 = I64[_s4kXp::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXg::I64,
                            (-2147483648))) goto c4m9L; else goto c4m9A;
       c4m9A: // global
           if (%MO_S_Gt_W64(_s4kXg::I64,
                            2147483647)) goto c4m9L; else goto c4m9P;
       c4m9L: // global
           Hp = Hp - 16;
           R2 = _s4kXg::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4m9P: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXg::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kXf_entry() //  [R1, R2]
         { info_tbl: [(c4m9T,
                       label: go_dn_s4kXf_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4m9T: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4m9X; else goto c4m9W;
       c4m9X: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4m9W: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4m9R; else goto c4m9S;
       c4m9R: // global
           _s4kXd::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kXm_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kXd::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kXk_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4m9S: // global
           I64[Hp - 80] = sat_s4kXp_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4m9Z::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4m9Z::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kXq_entry() //  [R1]
         { info_tbl: [(c4ma0,
                       label: sat_s4kXq_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ma0: // global
           _s4kXq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ma1; else goto c4ma2;
       c4ma2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ma4; else goto c4ma3;
       c4ma4: // global
           HpAlloc = 24;
           goto c4ma1;
       c4ma1: // global
           R1 = _s4kXq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ma3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXq::P64;
           _s4kX6::I64 = I64[_s4kXq::P64 + 24];
           _s4kXd::I64 = _s4kX6::I64 - I64[_s4kXq::P64 + 16];
           _s4kXe::I64 = I64[_s4kXq::P64 + 32] - _s4kXd::I64;
           I64[Hp - 16] = go_dn_s4kXf_info;
           I64[Hp - 8] = _s4kXd::I64;
           I64[Hp] = _s4kXe::I64;
           R2 = _s4kX6::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kXf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXc_entry() //  [R1]
         { info_tbl: [(c4mae,
                       label: sat_s4kXc_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mae: // global
           _s4kXc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4maf; else goto c4mag;
       c4mag: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mai; else goto c4mah;
       c4mai: // global
           HpAlloc = 16;
           goto c4maf;
       c4maf: // global
           R1 = _s4kXc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4mah: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXc::P64;
           _s4kX5::I64 = I64[_s4kXc::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4mao; else goto c4mad;
       c4mad: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4mao; else goto c4mas;
       c4mao: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4mas: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXu_entry() //  [R1]
         { info_tbl: [(c4maG,
                       label: sat_s4kXu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4maG: // global
           _s4kXu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4maH; else goto c4maI;
       c4maI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4maK; else goto c4maJ;
       c4maK: // global
           HpAlloc = 16;
           goto c4maH;
       c4maH: // global
           R1 = _s4kXu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4maJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXu::P64;
           _s4kX5::I64 = I64[_s4kXu::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4maQ; else goto c4maF;
       c4maF: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4maQ; else goto c4maU;
       c4maQ: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4maU: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXI_entry() //  [R1]
         { info_tbl: [(c4mbn,
                       label: sat_s4kXI_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mbn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mbo; else goto c4mbp;
       c4mbo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4mbp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kXB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXG_entry() //  [R1]
         { info_tbl: [(c4mbz,
                       label: sat_s4kXG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mbz: // global
           _s4kXG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4mbA; else goto c4mbB;
       c4mbB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mbD; else goto c4mbC;
       c4mbD: // global
           HpAlloc = 16;
           goto c4mbA;
       c4mbA: // global
           R1 = _s4kXG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4mbC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXG::P64;
           _s4kXC::I64 = I64[_s4kXG::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXC::I64,
                            (-2147483648))) goto c4mbJ; else goto c4mby;
       c4mby: // global
           if (%MO_S_Gt_W64(_s4kXC::I64,
                            2147483647)) goto c4mbJ; else goto c4mbN;
       c4mbJ: // global
           Hp = Hp - 16;
           R2 = _s4kXC::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4mbN: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXL_entry() //  [R1]
         { info_tbl: [(c4mbY,
                       label: sat_s4kXL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mbY: // global
           _s4kXL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4mbZ; else goto c4mc0;
       c4mc0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mc2; else goto c4mc1;
       c4mc2: // global
           HpAlloc = 16;
           goto c4mbZ;
       c4mbZ: // global
           R1 = _s4kXL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4mc1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXL::P64;
           _s4kXC::I64 = I64[_s4kXL::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXC::I64,
                            (-2147483648))) goto c4mc8; else goto c4mbX;
       c4mbX: // global
           if (%MO_S_Gt_W64(_s4kXC::I64,
                            2147483647)) goto c4mc8; else goto c4mcc;
       c4mc8: // global
           Hp = Hp - 16;
           R2 = _s4kXC::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4mcc: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kXB_entry() //  [R1, R2]
         { info_tbl: [(c4mcg,
                       label: go_up_s4kXB_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mcg: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4mck; else goto c4mcj;
       c4mck: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mcj: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4mce; else goto c4mcf;
       c4mce: // global
           _s4kXz::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kXI_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kXz::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kXG_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mcf: // global
           I64[Hp - 80] = sat_s4kXL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4mcm::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4mcm::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kXM_entry() //  [R1]
         { info_tbl: [(c4mcn,
                       label: sat_s4kXM_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mcn: // global
           _s4kXM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4mco; else goto c4mcp;
       c4mcp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4mcr; else goto c4mcq;
       c4mcr: // global
           HpAlloc = 24;
           goto c4mco;
       c4mco: // global
           R1 = _s4kXM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4mcq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXM::P64;
           _s4kX6::I64 = I64[_s4kXM::P64 + 24];
           _s4kXz::I64 = _s4kX6::I64 - I64[_s4kXM::P64 + 16];
           _s4kXA::I64 = I64[_s4kXM::P64 + 32] - _s4kXz::I64;
           I64[Hp - 16] = go_up_s4kXB_info;
           I64[Hp - 8] = _s4kXz::I64;
           I64[Hp] = _s4kXA::I64;
           R2 = _s4kX6::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kXB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXy_entry() //  [R1]
         { info_tbl: [(c4mcB,
                       label: sat_s4kXy_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mcB: // global
           _s4kXy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4mcC; else goto c4mcD;
       c4mcD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mcF; else goto c4mcE;
       c4mcF: // global
           HpAlloc = 16;
           goto c4mcC;
       c4mcC: // global
           R1 = _s4kXy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4mcE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXy::P64;
           _s4kX5::I64 = I64[_s4kXy::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4mcL; else goto c4mcA;
       c4mcA: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4mcL; else goto c4mcP;
       c4mcL: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4mcP: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXQ_entry() //  [R1]
         { info_tbl: [(c4md3,
                       label: sat_s4kXQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4md3: // global
           _s4kXQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4md4; else goto c4md5;
       c4md5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4md7; else goto c4md6;
       c4md7: // global
           HpAlloc = 16;
           goto c4md4;
       c4md4: // global
           R1 = _s4kXQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4md6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXQ::P64;
           _s4kX5::I64 = I64[_s4kXQ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4mdd; else goto c4md2;
       c4md2: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4mdd; else goto c4mdh;
       c4mdd: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4mdh: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4mdl,
                       label: GHC.Int.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mdl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4mdp; else goto c4mdo;
       c4mdp: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mdo: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4mdj; else goto c4mdk;
       c4mdj: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4mds; else goto c4mdx;
       c4mds: // global
           I64[Hp - 80] = sat_s4kXq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kXc_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mdx: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4mdE; else goto c4mdv;
       c4mdv: // global
           I64[Hp - 80] = sat_s4kXu_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4mdt::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4mdt::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mdk: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4mdA; else goto c4mdF;
       c4mdA: // global
           I64[Hp - 80] = sat_s4kXM_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kXy_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mdF: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4mdE; else goto c4mdD;
       c4mdE: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mdD: // global
           I64[Hp - 80] = sat_s4kXQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4mdB::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4mdB::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.646041975 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4mdN,
                       label: GHC.Int.$fEnumInt32_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mdN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4mdW; else goto c4mdX;
       c4mdW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mdX: // global
           I64[Sp - 24] = block_c4mdK_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4me6; else goto c4mdL;
       u4me6: // global
           call _c4mdK(R1) args: 0, res: 0, upd: 0;
       c4mdL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mdK() //  [R1]
         { info_tbl: [(c4mdK,
                       label: block_c4mdK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mdK: // global
           I64[Sp] = block_c4mdQ_info;
           _s4kXV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kXV::I64;
           if (R1 & 7 != 0) goto u4me5; else goto c4mdR;
       u4me5: // global
           call _c4mdQ(R1) args: 0, res: 0, upd: 0;
       c4mdR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mdQ() //  [R1]
         { info_tbl: [(c4mdQ,
                       label: block_c4mdQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mdQ: // global
           I64[Sp] = block_c4mdV_info;
           _s4kXX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kXX::I64;
           if (R1 & 7 != 0) goto u4me7; else goto c4me0;
       u4me7: // global
           call _c4mdV(R1) args: 0, res: 0, upd: 0;
       c4me0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mdV() //  [R1]
         { info_tbl: [(c4mdV,
                       label: block_c4mdV_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mdV: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.648761157 UTC

[section ""data" . GHC.Int.$fEnumInt32_closure" {
     GHC.Int.$fEnumInt32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt32_$csucc_closure+1;
         const GHC.Int.$fEnumInt32_$cpred_closure+1;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt32_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4mec,
                       label: GHC.Int.$fEnumInt32_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mec: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt32_closure+1;
           R2 = GHC.Int.$fEnumInt32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.650040047 UTC

[section ""cstring" . GHC.Int.$tcInt6_bytes" {
     GHC.Int.$tcInt6_bytes:
         I8[] [73,110,116,54,52]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.650850757 UTC

[section ""data" . GHC.Int.$fEnumInt5_closure" {
     GHC.Int.$fEnumInt5_closure:
         const GHC.Int.$fEnumInt5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt5_entry() //  [R1]
         { info_tbl: [(c4men,
                       label: GHC.Int.$fEnumInt5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4men: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4meo; else goto c4mep;
       c4meo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4mep: // global
           (_c4mei::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4mei::I64 == 0) goto c4mek; else goto c4mej;
       c4mek: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4mej: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4mei::I64;
           I64[Sp - 24] = block_c4mel_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4mel() //  [R1]
         { info_tbl: [(c4mel,
                       label: block_c4mel_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mel: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.652112928 UTC

[section ""data" . GHC.Int.$fEnumInt6_closure" {
     GHC.Int.$fEnumInt6_closure:
         const GHC.Int.$fEnumInt6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt6_entry() //  [R1]
         { info_tbl: [(c4meB,
                       label: GHC.Int.$fEnumInt6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4meB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4meC; else goto c4meD;
       c4meC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4meD: // global
           (_c4mew::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4mew::I64 == 0) goto c4mey; else goto c4mex;
       c4mey: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4mex: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4mew::I64;
           I64[Sp - 24] = block_c4mez_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4mez() //  [R1]
         { info_tbl: [(c4mez,
                       label: block_c4mez_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mez: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.653442069 UTC

[section ""data" . GHC.Int.neInt64_closure" {
     GHC.Int.neInt64_closure:
         const GHC.Int.neInt64_info;
 },
 GHC.Int.neInt64_entry() //  [R2, R3]
         { info_tbl: [(c4meO,
                       label: GHC.Int.neInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4meO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4meS; else goto c4meT;
       c4meS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4meT: // global
           I64[Sp - 16] = block_c4meL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mf2; else goto c4meM;
       u4mf2: // global
           call _c4meL(R1) args: 0, res: 0, upd: 0;
       c4meM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4meL() //  [R1]
         { info_tbl: [(c4meL,
                       label: block_c4meL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4meL: // global
           I64[Sp] = block_c4meR_info;
           _s4kY5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kY5::I64;
           if (R1 & 7 != 0) goto u4mf1; else goto c4meV;
       u4mf1: // global
           call _c4meR(R1) args: 0, res: 0, upd: 0;
       c4meV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4meR() //  [R1]
         { info_tbl: [(c4meR,
                       label: block_c4meR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4meR: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.654655432 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cminBound_closure" {
     GHC.Int.$fBoundedInt64_$cminBound_closure:
         const GHC.Int.I64#_con_info;
         const (-9223372036854775808);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.655561011 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cpred_closure" {
     GHC.Int.$fEnumInt64_$cpred_closure:
         const GHC.Int.$fEnumInt64_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cpred_entry() //  [R2]
         { info_tbl: [(c4mfa,
                       label: GHC.Int.$fEnumInt64_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mfa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mfb; else goto c4mfc;
       c4mfb: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mfc: // global
           I64[Sp - 8] = block_c4mf7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mfr; else goto c4mf8;
       u4mfr: // global
           call _c4mf7(R1) args: 0, res: 0, upd: 0;
       c4mf8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mf7() //  [R1]
         { info_tbl: [(c4mf7,
                       label: block_c4mf7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mf7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mfh; else goto c4mfg;
       c4mfh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mfg: // global
           _s4kYc::I64 = I64[R1 + 7];
           if (_s4kYc::I64 != (-9223372036854775808)) goto c4mfp; else goto c4mfq;
       c4mfp: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kYc::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mfq: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.656741334 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt64_$cmaxBound_closure:
         const GHC.Int.I64#_con_info;
         const 9223372036854775807;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.65734813 UTC

[section ""data" . GHC.Int.$fBoundedInt64_closure" {
     GHC.Int.$fBoundedInt64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt64_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.658278647 UTC

[section ""data" . GHC.Int.$fEnumInt64_$csucc_closure" {
     GHC.Int.$fEnumInt64_$csucc_closure:
         const GHC.Int.$fEnumInt64_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$csucc_entry() //  [R2]
         { info_tbl: [(c4mfz,
                       label: GHC.Int.$fEnumInt64_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mfz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mfA; else goto c4mfB;
       c4mfA: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mfB: // global
           I64[Sp - 8] = block_c4mfw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mfQ; else goto c4mfx;
       u4mfQ: // global
           call _c4mfw(R1) args: 0, res: 0, upd: 0;
       c4mfx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mfw() //  [R1]
         { info_tbl: [(c4mfw,
                       label: block_c4mfw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mfw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mfG; else goto c4mfF;
       c4mfG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mfF: // global
           _s4kYh::I64 = I64[R1 + 7];
           if (_s4kYh::I64 != 9223372036854775807) goto c4mfO; else goto c4mfP;
       c4mfO: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kYh::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mfP: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.660028366 UTC

[section ""data" . GHC.Int.$wgo2_closure" {
     GHC.Int.$wgo2_closure:
         const GHC.Int.$wgo2_info;
 },
 sat_s4kYq_entry() //  [R1]
         { info_tbl: [(c4mg3,
                       label: sat_s4kYq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mg3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4mg4; else goto c4mgf;
       c4mg4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4mgf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kYl::I64 = I64[R1 + 16];
           if (_s4kYl::I64 != 9223372036854775807) goto c4mg1; else goto c4mg2;
       c4mg1: // global
           I64[Sp - 24] = block_c4mg9_info;
           R2 = _s4kYl::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c4mg2: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4mg9() //  [R1, R2]
         { info_tbl: [(c4mg9,
                       label: block_c4mg9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mg9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4mge; else goto c4mgd;
       c4mge: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4mgd: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo2_entry() //  [R2]
         { info_tbl: [(c4mgh,
                       label: GHC.Int.$wgo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mgh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4mgl; else goto c4mgk;
       c4mgl: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Int.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mgk: // global
           I64[Hp - 32] = sat_s4kYq_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R2 = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.661670161 UTC

[section ""data" . GHC.Int.$fEnumInt64_go_closure" {
     GHC.Int.$fEnumInt64_go_closure:
         const GHC.Int.$fEnumInt64_go_info;
 },
 GHC.Int.$fEnumInt64_go_entry() //  [R2]
         { info_tbl: [(c4mgt,
                       label: GHC.Int.$fEnumInt64_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mgt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mgu; else goto c4mgv;
       c4mgu: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mgv: // global
           I64[Sp - 8] = block_c4mgq_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4mgq() //  [R1, R2]
         { info_tbl: [(c4mgq,
                       label: block_c4mgq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mgq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4mgy; else goto c4mgx;
       c4mgy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4mgx: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.662873605 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFrom_closure" {
     GHC.Int.$fEnumInt64_$cenumFrom_closure:
         const GHC.Int.$fEnumInt64_$cenumFrom_info;
 },
 GHC.Int.$fEnumInt64_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4mgG,
                       label: GHC.Int.$fEnumInt64_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mgG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mgH; else goto c4mgI;
       c4mgH: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mgI: // global
           I64[Sp - 8] = block_c4mgD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mgM; else goto c4mgE;
       u4mgM: // global
           call _c4mgD(R1) args: 0, res: 0, upd: 0;
       c4mgE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mgD() //  [R1]
         { info_tbl: [(c4mgD,
                       label: block_c4mgD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mgD: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.66395574 UTC

[section ""data" . GHC.Int.$fEnumInt64_closure" {
     GHC.Int.$fEnumInt64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt64_$csucc_closure+1;
         const GHC.Int.$fEnumInt64_$cpred_closure+1;
         const GHC.Int.$fEnumInt64_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt64_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4mgR,
                       label: GHC.Int.$fEnumInt64_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mgR: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt64_closure+1;
           R2 = GHC.Int.$fEnumInt64_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.665079409 UTC

[section ""data" . GHC.Int.$fNumInt8_$cfromInteger_closure" {
     GHC.Int.$fNumInt8_$cfromInteger_closure:
         const GHC.Int.$fNumInt8_$cfromInteger_info;
 },
 GHC.Int.$fNumInt8_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4mh0,
                       label: GHC.Int.$fNumInt8_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mh0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mh7; else goto c4mh8;
       c4mh7: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mh8: // global
           I64[Sp - 8] = block_c4mgY_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4mgY() //  [R1]
         { info_tbl: [(c4mgY,
                       label: block_c4mgY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mgY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mhb; else goto c4mha;
       c4mhb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4mha: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.666524694 UTC

[section ""data" . GHC.Int.$fNumInt8_$cnegate_closure" {
     GHC.Int.$fNumInt8_$cnegate_closure:
         const GHC.Int.$fNumInt8_$cnegate_info;
 },
 GHC.Int.$fNumInt8_$cnegate_entry() //  [R2]
         { info_tbl: [(c4mhj,
                       label: GHC.Int.$fNumInt8_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mhj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mht; else goto c4mhu;
       c4mht: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mhu: // global
           I64[Sp - 8] = block_c4mhg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mhy; else goto c4mhh;
       u4mhy: // global
           call _c4mhg(R1) args: 0, res: 0, upd: 0;
       c4mhh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mhg() //  [R1]
         { info_tbl: [(c4mhg,
                       label: block_c4mhg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mhg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mhx; else goto c4mhw;
       c4mhx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mhw: // global
           _s4kYF::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYF::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.667990362 UTC

[section ""data" . GHC.Int.$fNumInt8_$c*_closure" {
     GHC.Int.$fNumInt8_$c*_closure:
         const GHC.Int.$fNumInt8_$c*_info;
 },
 GHC.Int.$fNumInt8_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4mhG,
                       label: GHC.Int.$fNumInt8_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mhG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mhV; else goto c4mhW;
       c4mhV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mhW: // global
           I64[Sp - 16] = block_c4mhD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mi2; else goto c4mhE;
       u4mi2: // global
           call _c4mhD(R1) args: 0, res: 0, upd: 0;
       c4mhE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mhD() //  [R1]
         { info_tbl: [(c4mhD,
                       label: block_c4mhD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mhD: // global
           I64[Sp] = block_c4mhJ_info;
           _s4kYJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYJ::I64;
           if (R1 & 7 != 0) goto u4mi1; else goto c4mhK;
       u4mi1: // global
           call _c4mhJ(R1) args: 0, res: 0, upd: 0;
       c4mhK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mhJ() //  [R1]
         { info_tbl: [(c4mhJ,
                       label: block_c4mhJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mhJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mi0; else goto c4mhZ;
       c4mi0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mhZ: // global
           _s4kYN::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYN::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.66973147 UTC

[section ""data" . GHC.Int.$fNumInt8_$c-_closure" {
     GHC.Int.$fNumInt8_$c-_closure:
         const GHC.Int.$fNumInt8_$c-_info;
 },
 GHC.Int.$fNumInt8_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4mia,
                       label: GHC.Int.$fNumInt8_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mia: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mip; else goto c4miq;
       c4mip: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4miq: // global
           I64[Sp - 16] = block_c4mi7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4miw; else goto c4mi8;
       u4miw: // global
           call _c4mi7(R1) args: 0, res: 0, upd: 0;
       c4mi8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mi7() //  [R1]
         { info_tbl: [(c4mi7,
                       label: block_c4mi7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mi7: // global
           I64[Sp] = block_c4mid_info;
           _s4kYR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYR::I64;
           if (R1 & 7 != 0) goto u4miv; else goto c4mie;
       u4miv: // global
           call _c4mid(R1) args: 0, res: 0, upd: 0;
       c4mie: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mid() //  [R1]
         { info_tbl: [(c4mid,
                       label: block_c4mid_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mid: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4miu; else goto c4mit;
       c4miu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mit: // global
           _s4kYV::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.671482403 UTC

[section ""data" . GHC.Int.$fNumInt8_$c+_closure" {
     GHC.Int.$fNumInt8_$c+_closure:
         const GHC.Int.$fNumInt8_$c+_info;
 },
 GHC.Int.$fNumInt8_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4miE,
                       label: GHC.Int.$fNumInt8_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4miE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4miT; else goto c4miU;
       c4miT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4miU: // global
           I64[Sp - 16] = block_c4miB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mj0; else goto c4miC;
       u4mj0: // global
           call _c4miB(R1) args: 0, res: 0, upd: 0;
       c4miC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4miB() //  [R1]
         { info_tbl: [(c4miB,
                       label: block_c4miB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4miB: // global
           I64[Sp] = block_c4miH_info;
           _s4kYZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYZ::I64;
           if (R1 & 7 != 0) goto u4miZ; else goto c4miI;
       u4miZ: // global
           call _c4miH(R1) args: 0, res: 0, upd: 0;
       c4miI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4miH() //  [R1]
         { info_tbl: [(c4miH,
                       label: block_c4miH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4miH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4miY; else goto c4miX;
       c4miY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4miX: // global
           _s4kZ3::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZ3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.67397214 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt8_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt8_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt8_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4mj8,
                       label: GHC.Int.$fIntegralInt8_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mj8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mj9; else goto c4mja;
       c4mj9: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mja: // global
           I64[Sp - 8] = block_c4mj5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mje; else goto c4mj6;
       u4mje: // global
           call _c4mj5(R1) args: 0, res: 0, upd: 0;
       c4mj6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mj5() //  [R1]
         { info_tbl: [(c4mj5,
                       label: block_c4mj5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mj5: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.675200547 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cpopCount_closure" {
     GHC.Int.$fBitsInt8_$cpopCount_closure:
         const GHC.Int.$fBitsInt8_$cpopCount_info;
 },
 GHC.Int.$fBitsInt8_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4mjm,
                       label: GHC.Int.$fBitsInt8_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mjm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mjA; else goto c4mjB;
       c4mjA: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mjB: // global
           I64[Sp - 8] = block_c4mjj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mjF; else goto c4mjk;
       u4mjF: // global
           call _c4mjj(R1) args: 0, res: 0, upd: 0;
       c4mjk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mjj() //  [R1]
         { info_tbl: [(c4mjj,
                       label: block_c4mjj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mjj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mjE; else goto c4mjD;
       c4mjE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mjD: // global
           (_c4mjs::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mjs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.67665959 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4mjN,
                       label: GHC.Int.$fBitsInt8_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mjN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mjZ; else goto c4mk0;
       c4mjZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mk0: // global
           I64[Sp - 16] = block_c4mjK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mk6; else goto c4mjL;
       u4mk6: // global
           call _c4mjK(R1) args: 0, res: 0, upd: 0;
       c4mjL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mjK() //  [R1]
         { info_tbl: [(c4mjK,
                       label: block_c4mjK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mjK: // global
           I64[Sp] = block_c4mjQ_info;
           _s4kZg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZg::I64;
           if (R1 & 7 != 0) goto u4mk5; else goto c4mjR;
       u4mk5: // global
           call _c4mjQ(R1) args: 0, res: 0, upd: 0;
       c4mjR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mjQ() //  [R1]
         { info_tbl: [(c4mjQ,
                       label: block_c4mjQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mjQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mk4; else goto c4mk3;
       c4mk4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mk3: // global
           _s4kZj::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.678041801 UTC

[section ""data" . GHC.Int.$fBitsInt13_closure" {
     GHC.Int.$fBitsInt13_closure:
         const GHC.Int.I8#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.678598822 UTC

[section ""data" . GHC.Int.$fNumInt9_closure" {
     GHC.Int.$fNumInt9_closure:
         const GHC.Int.I8#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.679658971 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftR_closure" {
     GHC.Int.$fBitsInt8_$cshiftR_closure:
         const GHC.Int.$fBitsInt8_$cshiftR_info;
 },
 GHC.Int.$fBitsInt8_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4mke,
                       label: GHC.Int.$fBitsInt8_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mke: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mki; else goto c4mkj;
       c4mki: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mkj: // global
           I64[Sp - 16] = block_c4mkb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mkJ; else goto c4mkc;
       u4mkJ: // global
           call _c4mkb(R1) args: 0, res: 0, upd: 0;
       c4mkc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mkb() //  [R1]
         { info_tbl: [(c4mkb,
                       label: block_c4mkb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mkb: // global
           I64[Sp] = block_c4mkh_info;
           _s4kZn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZn::I64;
           if (R1 & 7 != 0) goto u4mkI; else goto c4mkl;
       u4mkI: // global
           call _c4mkh(R1) args: 0, res: 0, upd: 0;
       c4mkl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mkh() //  [R1]
         { info_tbl: [(c4mkh,
                       label: block_c4mkh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mkh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mkr; else goto c4mkq;
       c4mkr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mkq: // global
           _s4kZn::I64 = I64[Sp + 8];
           _s4kZp::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4kZp::I64, 64)) goto c4mkA; else goto c4mkH;
       c4mkA: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4kZn::I64, _s4kZp::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mkH: // global
           if (%MO_S_Ge_W64(_s4kZn::I64, 0)) goto c4mkF; else goto c4mkG;
       c4mkF: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mkG: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.681518204 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4mkR,
                       label: GHC.Int.$fBitsInt8_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mkR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ml6; else goto c4ml7;
       c4ml6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ml7: // global
           I64[Sp - 16] = block_c4mkO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mld; else goto c4mkP;
       u4mld: // global
           call _c4mkO(R1) args: 0, res: 0, upd: 0;
       c4mkP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mkO() //  [R1]
         { info_tbl: [(c4mkO,
                       label: block_c4mkO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mkO: // global
           I64[Sp] = block_c4mkU_info;
           _s4kZw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZw::I64;
           if (R1 & 7 != 0) goto u4mlc; else goto c4mkV;
       u4mlc: // global
           call _c4mkU(R1) args: 0, res: 0, upd: 0;
       c4mkV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mkU() //  [R1]
         { info_tbl: [(c4mkU,
                       label: block_c4mkU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mkU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mlb; else goto c4mla;
       c4mlb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mla: // global
           _s4kZA::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.683257558 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftL_closure" {
     GHC.Int.$fBitsInt8_$cshiftL_closure:
         const GHC.Int.$fBitsInt8_$cshiftL_info;
 },
 GHC.Int.$fBitsInt8_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4mll,
                       label: GHC.Int.$fBitsInt8_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mll: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mlp; else goto c4mlq;
       c4mlp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mlq: // global
           I64[Sp - 16] = block_c4mli_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mlN; else goto c4mlj;
       u4mlN: // global
           call _c4mli(R1) args: 0, res: 0, upd: 0;
       c4mlj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mli() //  [R1]
         { info_tbl: [(c4mli,
                       label: block_c4mli_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mli: // global
           I64[Sp] = block_c4mlo_info;
           _s4kZE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZE::I64;
           if (R1 & 7 != 0) goto u4mlM; else goto c4mls;
       u4mlM: // global
           call _c4mlo(R1) args: 0, res: 0, upd: 0;
       c4mls: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mlo() //  [R1]
         { info_tbl: [(c4mlo,
                       label: block_c4mlo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mlo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mly; else goto c4mlx;
       c4mly: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mlx: // global
           _s4kZG::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4kZG::I64, 64)) goto c4mlK; else goto c4mlL;
       c4mlK: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << _s4kZG::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mlL: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.684742624 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cisSigned_closure" {
     GHC.Int.$fBitsInt8_$cisSigned_closure:
         const GHC.Int.$fBitsInt8_$cisSigned_info;
 },
 GHC.Int.$fBitsInt8_$cisSigned_entry() //  []
         { info_tbl: [(c4mlS,
                       label: GHC.Int.$fBitsInt8_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mlS: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.686111573 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotate_closure" {
     GHC.Int.$fBitsInt8_$crotate_closure:
         const GHC.Int.$fBitsInt8_$crotate_info;
 },
 GHC.Int.$fBitsInt8_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4mm2,
                       label: GHC.Int.$fBitsInt8_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mm2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4mm6; else goto c4mm7;
       c4mm6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mm7: // global
           I64[Sp - 16] = block_c4mlZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mn3; else goto c4mm0;
       u4mn3: // global
           call _c4mlZ(R1) args: 0, res: 0, upd: 0;
       c4mm0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mlZ() //  [R1]
         { info_tbl: [(c4mlZ,
                       label: block_c4mlZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mlZ: // global
           I64[Sp - 8] = block_c4mm5_info;
           _s4kZN::P64 = R1;
           _s4kZO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4kZO::I64;
           P64[Sp + 8] = _s4kZN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mn2; else goto c4mm9;
       u4mn2: // global
           call _c4mm5(R1) args: 0, res: 0, upd: 0;
       c4mm9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mm5() //  [R1]
         { info_tbl: [(c4mm5,
                       label: block_c4mm5_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mm5: // global
           _s4kZT::I64 = I64[R1 + 7] & 7;
           if (_s4kZT::I64 != 0) goto u4mn0; else goto c4mmW;
       u4mn0: // global
           I64[Sp + 16] = _s4kZT::I64;
           Sp = Sp + 8;
           call _c4mmo() args: 0, res: 0, upd: 0;
       c4mmW: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4mmo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mmo: // global
           Hp = Hp + 16;
           _s4kZT::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4mmT; else goto c4mmS;
       c4mmT: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4mmn_info;
           R1 = _s4kZT::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4mmS: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4kZU::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4kZU::I64 << _s4kZT::I64) | (_s4kZU::I64 >> 8 - _s4kZT::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4mmn() //  [R1]
         { info_tbl: [(c4mmn,
                       label: block_c4mmn_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mmn: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4mmo() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.68844649 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshift_closure" {
     GHC.Int.$fBitsInt8_$cshift_closure:
         const GHC.Int.$fBitsInt8_$cshift_info;
 },
 GHC.Int.$fBitsInt8_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4mnd,
                       label: GHC.Int.$fBitsInt8_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mnd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mnh; else goto c4mni;
       c4mnh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mni: // global
           I64[Sp - 16] = block_c4mna_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mo5; else goto c4mnb;
       u4mo5: // global
           call _c4mna(R1) args: 0, res: 0, upd: 0;
       c4mnb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mna() //  [R1]
         { info_tbl: [(c4mna,
                       label: block_c4mna_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mna: // global
           I64[Sp] = block_c4mng_info;
           _s4l05::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l05::I64;
           if (R1 & 7 != 0) goto u4mo4; else goto c4mnk;
       u4mo4: // global
           call _c4mng(R1) args: 0, res: 0, upd: 0;
       c4mnk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mng() //  [R1]
         { info_tbl: [(c4mng,
                       label: block_c4mng_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mng: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mnq; else goto c4mnp;
       c4mnq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mnp: // global
           _s4l05::I64 = I64[Sp + 8];
           _s4l07::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l07::I64, 0)) goto c4mnO; else goto c4mo3;
       c4mnO: // global
           _s4l09::I64 = -_s4l07::I64;
           if (%MO_S_Lt_W64(_s4l09::I64, 64)) goto c4mnF; else goto c4mnM;
       c4mnF: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l05::I64, _s4l09::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mnM: // global
           if (%MO_S_Ge_W64(_s4l05::I64, 0)) goto c4mo2; else goto c4mnL;
       c4mnL: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mo3: // global
           if (%MO_S_Ge_W64(_s4l07::I64, 64)) goto c4mo2; else goto c4mo1;
       c4mo2: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mo1: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4l05::I64 << _s4l07::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.690770041 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplement_closure" {
     GHC.Int.$fBitsInt8_$ccomplement_closure:
         const GHC.Int.$fBitsInt8_$ccomplement_info;
 },
 GHC.Int.$fBitsInt8_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4mod,
                       label: GHC.Int.$fBitsInt8_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mod: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4moq; else goto c4mor;
       c4moq: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mor: // global
           I64[Sp - 8] = block_c4moa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mov; else goto c4mob;
       u4mov: // global
           call _c4moa(R1) args: 0, res: 0, upd: 0;
       c4mob: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4moa() //  [R1]
         { info_tbl: [(c4moa,
                       label: block_c4moa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4moa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mou; else goto c4mot;
       c4mou: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mot: // global
           _s4l0l::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.692265379 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cxor_closure" {
     GHC.Int.$fBitsInt8_$cxor_closure:
         const GHC.Int.$fBitsInt8_$cxor_info;
 },
 GHC.Int.$fBitsInt8_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4moD,
                       label: GHC.Int.$fBitsInt8_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4moD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4moY; else goto c4moZ;
       c4moY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4moZ: // global
           I64[Sp - 16] = block_c4moA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mp5; else goto c4moB;
       u4mp5: // global
           call _c4moA(R1) args: 0, res: 0, upd: 0;
       c4moB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4moA() //  [R1]
         { info_tbl: [(c4moA,
                       label: block_c4moA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4moA: // global
           I64[Sp] = block_c4moG_info;
           _s4l0p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0p::I64;
           if (R1 & 7 != 0) goto u4mp4; else goto c4moH;
       u4mp4: // global
           call _c4moG(R1) args: 0, res: 0, upd: 0;
       c4moH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4moG() //  [R1]
         { info_tbl: [(c4moG,
                       label: block_c4moG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4moG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mp3; else goto c4mp2;
       c4mp3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mp2: // global
           _s4l0v::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0v::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.694058762 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.|._closure" {
     GHC.Int.$fBitsInt8_$c.|._closure:
         const GHC.Int.$fBitsInt8_$c.|._info;
 },
 GHC.Int.$fBitsInt8_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4mpd,
                       label: GHC.Int.$fBitsInt8_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mpd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mpy; else goto c4mpz;
       c4mpy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mpz: // global
           I64[Sp - 16] = block_c4mpa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mpF; else goto c4mpb;
       u4mpF: // global
           call _c4mpa(R1) args: 0, res: 0, upd: 0;
       c4mpb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mpa() //  [R1]
         { info_tbl: [(c4mpa,
                       label: block_c4mpa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mpa: // global
           I64[Sp] = block_c4mpg_info;
           _s4l0z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0z::I64;
           if (R1 & 7 != 0) goto u4mpE; else goto c4mph;
       u4mpE: // global
           call _c4mpg(R1) args: 0, res: 0, upd: 0;
       c4mph: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mpg() //  [R1]
         { info_tbl: [(c4mpg,
                       label: block_c4mpg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mpg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mpD; else goto c4mpC;
       c4mpD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mpC: // global
           _s4l0F::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0F::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.695815618 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.&._closure" {
     GHC.Int.$fBitsInt8_$c.&._closure:
         const GHC.Int.$fBitsInt8_$c.&._info;
 },
 GHC.Int.$fBitsInt8_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4mpN,
                       label: GHC.Int.$fBitsInt8_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mpN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mq8; else goto c4mq9;
       c4mq8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mq9: // global
           I64[Sp - 16] = block_c4mpK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mqf; else goto c4mpL;
       u4mqf: // global
           call _c4mpK(R1) args: 0, res: 0, upd: 0;
       c4mpL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mpK() //  [R1]
         { info_tbl: [(c4mpK,
                       label: block_c4mpK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mpK: // global
           I64[Sp] = block_c4mpQ_info;
           _s4l0J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0J::I64;
           if (R1 & 7 != 0) goto u4mqe; else goto c4mpR;
       u4mqe: // global
           call _c4mpQ(R1) args: 0, res: 0, upd: 0;
       c4mpR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mpQ() //  [R1]
         { info_tbl: [(c4mpQ,
                       label: block_c4mpQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mpQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mqd; else goto c4mqc;
       c4mqd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mqc: // global
           _s4l0P::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0P::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.698550616 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4mqn,
                       label: GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mqn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mqB; else goto c4mqC;
       c4mqB: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mqC: // global
           I64[Sp - 8] = block_c4mqk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mqG; else goto c4mql;
       u4mqG: // global
           call _c4mqk(R1) args: 0, res: 0, upd: 0;
       c4mql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mqk() //  [R1]
         { info_tbl: [(c4mqk,
                       label: block_c4mqk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mqk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mqF; else goto c4mqE;
       c4mqF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mqE: // global
           (_c4mqt::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mqt::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.699884526 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4mqO,
                       label: GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mqO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mr2; else goto c4mr3;
       c4mr2: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mr3: // global
           I64[Sp - 8] = block_c4mqL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mr7; else goto c4mqM;
       u4mr7: // global
           call _c4mqL(R1) args: 0, res: 0, upd: 0;
       c4mqM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mqL() //  [R1]
         { info_tbl: [(c4mqL,
                       label: block_c4mqL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mqL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mr6; else goto c4mr5;
       c4mr6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mr5: // global
           (_c4mqU::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mqU::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.7009362 UTC

[section ""data" . GHC.Int.$fBitsInt11_closure" {
     GHC.Int.$fBitsInt11_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.701618396 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt8_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt8_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4mrc,
                       label: GHC.Int.$fBitsInt8_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mrc: // global
           R1 = GHC.Int.$fBitsInt11_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.70257019 UTC

[section ""data" . GHC.Int.$fNumInt16_$cfromInteger_closure" {
     GHC.Int.$fNumInt16_$cfromInteger_closure:
         const GHC.Int.$fNumInt16_$cfromInteger_info;
 },
 GHC.Int.$fNumInt16_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4mrl,
                       label: GHC.Int.$fNumInt16_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mrl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mrs; else goto c4mrt;
       c4mrs: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mrt: // global
           I64[Sp - 8] = block_c4mrj_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4mrj() //  [R1]
         { info_tbl: [(c4mrj,
                       label: block_c4mrj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mrj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mrw; else goto c4mrv;
       c4mrw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4mrv: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.703833725 UTC

[section ""data" . GHC.Int.$fNumInt16_$cnegate_closure" {
     GHC.Int.$fNumInt16_$cnegate_closure:
         const GHC.Int.$fNumInt16_$cnegate_info;
 },
 GHC.Int.$fNumInt16_$cnegate_entry() //  [R2]
         { info_tbl: [(c4mrE,
                       label: GHC.Int.$fNumInt16_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mrE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mrO; else goto c4mrP;
       c4mrO: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mrP: // global
           I64[Sp - 8] = block_c4mrB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mrT; else goto c4mrC;
       u4mrT: // global
           call _c4mrB(R1) args: 0, res: 0, upd: 0;
       c4mrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mrB() //  [R1]
         { info_tbl: [(c4mrB,
                       label: block_c4mrB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mrB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mrS; else goto c4mrR;
       c4mrS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mrR: // global
           _s4l1a::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1a::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.705412711 UTC

[section ""data" . GHC.Int.$fNumInt16_$c*_closure" {
     GHC.Int.$fNumInt16_$c*_closure:
         const GHC.Int.$fNumInt16_$c*_info;
 },
 GHC.Int.$fNumInt16_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4ms1,
                       label: GHC.Int.$fNumInt16_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ms1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4msg; else goto c4msh;
       c4msg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4msh: // global
           I64[Sp - 16] = block_c4mrY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4msn; else goto c4mrZ;
       u4msn: // global
           call _c4mrY(R1) args: 0, res: 0, upd: 0;
       c4mrZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mrY() //  [R1]
         { info_tbl: [(c4mrY,
                       label: block_c4mrY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mrY: // global
           I64[Sp] = block_c4ms4_info;
           _s4l1e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1e::I64;
           if (R1 & 7 != 0) goto u4msm; else goto c4ms5;
       u4msm: // global
           call _c4ms4(R1) args: 0, res: 0, upd: 0;
       c4ms5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ms4() //  [R1]
         { info_tbl: [(c4ms4,
                       label: block_c4ms4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ms4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4msl; else goto c4msk;
       c4msl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4msk: // global
           _s4l1i::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1i::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.707157237 UTC

[section ""data" . GHC.Int.$fNumInt16_$c-_closure" {
     GHC.Int.$fNumInt16_$c-_closure:
         const GHC.Int.$fNumInt16_$c-_info;
 },
 GHC.Int.$fNumInt16_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4msv,
                       label: GHC.Int.$fNumInt16_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4msv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4msK; else goto c4msL;
       c4msK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4msL: // global
           I64[Sp - 16] = block_c4mss_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4msR; else goto c4mst;
       u4msR: // global
           call _c4mss(R1) args: 0, res: 0, upd: 0;
       c4mst: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mss() //  [R1]
         { info_tbl: [(c4mss,
                       label: block_c4mss_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mss: // global
           I64[Sp] = block_c4msy_info;
           _s4l1m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1m::I64;
           if (R1 & 7 != 0) goto u4msQ; else goto c4msz;
       u4msQ: // global
           call _c4msy(R1) args: 0, res: 0, upd: 0;
       c4msz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4msy() //  [R1]
         { info_tbl: [(c4msy,
                       label: block_c4msy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4msy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4msP; else goto c4msO;
       c4msP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4msO: // global
           _s4l1q::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.708964416 UTC

[section ""data" . GHC.Int.$fNumInt16_$c+_closure" {
     GHC.Int.$fNumInt16_$c+_closure:
         const GHC.Int.$fNumInt16_$c+_info;
 },
 GHC.Int.$fNumInt16_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4msZ,
                       label: GHC.Int.$fNumInt16_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4msZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mte; else goto c4mtf;
       c4mte: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mtf: // global
           I64[Sp - 16] = block_c4msW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mtl; else goto c4msX;
       u4mtl: // global
           call _c4msW(R1) args: 0, res: 0, upd: 0;
       c4msX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4msW() //  [R1]
         { info_tbl: [(c4msW,
                       label: block_c4msW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4msW: // global
           I64[Sp] = block_c4mt2_info;
           _s4l1u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1u::I64;
           if (R1 & 7 != 0) goto u4mtk; else goto c4mt3;
       u4mtk: // global
           call _c4mt2(R1) args: 0, res: 0, upd: 0;
       c4mt3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mt2() //  [R1]
         { info_tbl: [(c4mt2,
                       label: block_c4mt2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mt2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mtj; else goto c4mti;
       c4mtj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mti: // global
           _s4l1y::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1y::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.710505912 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt16_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt16_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt16_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4mtt,
                       label: GHC.Int.$fIntegralInt16_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mtt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mtu; else goto c4mtv;
       c4mtu: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mtv: // global
           I64[Sp - 8] = block_c4mtq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mtz; else goto c4mtr;
       u4mtz: // global
           call _c4mtq(R1) args: 0, res: 0, upd: 0;
       c4mtr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mtq() //  [R1]
         { info_tbl: [(c4mtq,
                       label: block_c4mtq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mtq: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.711699073 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cpopCount_closure" {
     GHC.Int.$fBitsInt16_$cpopCount_closure:
         const GHC.Int.$fBitsInt16_$cpopCount_info;
 },
 GHC.Int.$fBitsInt16_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4mtH,
                       label: GHC.Int.$fBitsInt16_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mtH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mtV; else goto c4mtW;
       c4mtV: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mtW: // global
           I64[Sp - 8] = block_c4mtE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mu0; else goto c4mtF;
       u4mu0: // global
           call _c4mtE(R1) args: 0, res: 0, upd: 0;
       c4mtF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mtE() //  [R1]
         { info_tbl: [(c4mtE,
                       label: block_c4mtE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mtE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mtZ; else goto c4mtY;
       c4mtZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mtY: // global
           (_c4mtN::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mtN::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.713141002 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4mu8,
                       label: GHC.Int.$fBitsInt16_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mu8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4muk; else goto c4mul;
       c4muk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mul: // global
           I64[Sp - 16] = block_c4mu5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mur; else goto c4mu6;
       u4mur: // global
           call _c4mu5(R1) args: 0, res: 0, upd: 0;
       c4mu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mu5() //  [R1]
         { info_tbl: [(c4mu5,
                       label: block_c4mu5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mu5: // global
           I64[Sp] = block_c4mub_info;
           _s4l1L::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1L::I64;
           if (R1 & 7 != 0) goto u4muq; else goto c4muc;
       u4muq: // global
           call _c4mub(R1) args: 0, res: 0, upd: 0;
       c4muc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mub() //  [R1]
         { info_tbl: [(c4mub,
                       label: block_c4mub_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mub: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mup; else goto c4muo;
       c4mup: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4muo: // global
           _s4l1O::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1O::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.714503877 UTC

[section ""data" . GHC.Int.$fBitsInt3_closure" {
     GHC.Int.$fBitsInt3_closure:
         const GHC.Int.I16#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.715100188 UTC

[section ""data" . GHC.Int.$fNumInt2_closure" {
     GHC.Int.$fNumInt2_closure:
         const GHC.Int.I16#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.716165904 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftR_closure" {
     GHC.Int.$fBitsInt16_$cshiftR_closure:
         const GHC.Int.$fBitsInt16_$cshiftR_info;
 },
 GHC.Int.$fBitsInt16_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4muz,
                       label: GHC.Int.$fBitsInt16_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4muz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4muD; else goto c4muE;
       c4muD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4muE: // global
           I64[Sp - 16] = block_c4muw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mv4; else goto c4mux;
       u4mv4: // global
           call _c4muw(R1) args: 0, res: 0, upd: 0;
       c4mux: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4muw() //  [R1]
         { info_tbl: [(c4muw,
                       label: block_c4muw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4muw: // global
           I64[Sp] = block_c4muC_info;
           _s4l1S::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1S::I64;
           if (R1 & 7 != 0) goto u4mv3; else goto c4muG;
       u4mv3: // global
           call _c4muC(R1) args: 0, res: 0, upd: 0;
       c4muG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4muC() //  [R1]
         { info_tbl: [(c4muC,
                       label: block_c4muC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4muC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4muM; else goto c4muL;
       c4muM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4muL: // global
           _s4l1S::I64 = I64[Sp + 8];
           _s4l1U::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l1U::I64, 64)) goto c4muV; else goto c4mv2;
       c4muV: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l1S::I64, _s4l1U::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mv2: // global
           if (%MO_S_Ge_W64(_s4l1S::I64, 0)) goto c4mv0; else goto c4mv1;
       c4mv0: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mv1: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.7181193 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4mvc,
                       label: GHC.Int.$fBitsInt16_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mvc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mvr; else goto c4mvs;
       c4mvr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mvs: // global
           I64[Sp - 16] = block_c4mv9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mvy; else goto c4mva;
       u4mvy: // global
           call _c4mv9(R1) args: 0, res: 0, upd: 0;
       c4mva: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mv9() //  [R1]
         { info_tbl: [(c4mv9,
                       label: block_c4mv9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mv9: // global
           I64[Sp] = block_c4mvf_info;
           _s4l21::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l21::I64;
           if (R1 & 7 != 0) goto u4mvx; else goto c4mvg;
       u4mvx: // global
           call _c4mvf(R1) args: 0, res: 0, upd: 0;
       c4mvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mvf() //  [R1]
         { info_tbl: [(c4mvf,
                       label: block_c4mvf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mvf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mvw; else goto c4mvv;
       c4mvw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mvv: // global
           _s4l25::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l25::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.720009675 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftL_closure" {
     GHC.Int.$fBitsInt16_$cshiftL_closure:
         const GHC.Int.$fBitsInt16_$cshiftL_info;
 },
 GHC.Int.$fBitsInt16_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4mvG,
                       label: GHC.Int.$fBitsInt16_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mvG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mvK; else goto c4mvL;
       c4mvK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mvL: // global
           I64[Sp - 16] = block_c4mvD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mw8; else goto c4mvE;
       u4mw8: // global
           call _c4mvD(R1) args: 0, res: 0, upd: 0;
       c4mvE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mvD() //  [R1]
         { info_tbl: [(c4mvD,
                       label: block_c4mvD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mvD: // global
           I64[Sp] = block_c4mvJ_info;
           _s4l29::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l29::I64;
           if (R1 & 7 != 0) goto u4mw7; else goto c4mvN;
       u4mw7: // global
           call _c4mvJ(R1) args: 0, res: 0, upd: 0;
       c4mvN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mvJ() //  [R1]
         { info_tbl: [(c4mvJ,
                       label: block_c4mvJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mvJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mvT; else goto c4mvS;
       c4mvT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mvS: // global
           _s4l2b::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l2b::I64, 64)) goto c4mw5; else goto c4mw6;
       c4mw5: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << _s4l2b::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mw6: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.722526312 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cisSigned_closure" {
     GHC.Int.$fBitsInt16_$cisSigned_closure:
         const GHC.Int.$fBitsInt16_$cisSigned_info;
 },
 GHC.Int.$fBitsInt16_$cisSigned_entry() //  []
         { info_tbl: [(c4mwd,
                       label: GHC.Int.$fBitsInt16_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mwd: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.723876931 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotate_closure" {
     GHC.Int.$fBitsInt16_$crotate_closure:
         const GHC.Int.$fBitsInt16_$crotate_info;
 },
 GHC.Int.$fBitsInt16_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4mwn,
                       label: GHC.Int.$fBitsInt16_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mwn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4mwr; else goto c4mws;
       c4mwr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mws: // global
           I64[Sp - 16] = block_c4mwk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mxo; else goto c4mwl;
       u4mxo: // global
           call _c4mwk(R1) args: 0, res: 0, upd: 0;
       c4mwl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mwk() //  [R1]
         { info_tbl: [(c4mwk,
                       label: block_c4mwk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mwk: // global
           I64[Sp - 8] = block_c4mwq_info;
           _s4l2i::P64 = R1;
           _s4l2j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l2j::I64;
           P64[Sp + 8] = _s4l2i::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mxn; else goto c4mwu;
       u4mxn: // global
           call _c4mwq(R1) args: 0, res: 0, upd: 0;
       c4mwu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mwq() //  [R1]
         { info_tbl: [(c4mwq,
                       label: block_c4mwq_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mwq: // global
           _s4l2o::I64 = I64[R1 + 7] & 15;
           if (_s4l2o::I64 != 0) goto u4mxl; else goto c4mxh;
       u4mxl: // global
           I64[Sp + 16] = _s4l2o::I64;
           Sp = Sp + 8;
           call _c4mwJ() args: 0, res: 0, upd: 0;
       c4mxh: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4mwJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mwJ: // global
           Hp = Hp + 16;
           _s4l2o::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4mxe; else goto c4mxd;
       c4mxe: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4mwI_info;
           R1 = _s4l2o::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4mxd: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4l2p::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4l2p::I64 << _s4l2o::I64) | (_s4l2p::I64 >> 16 - _s4l2o::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4mwI() //  [R1]
         { info_tbl: [(c4mwI,
                       label: block_c4mwI_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mwI: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4mwJ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.726380213 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshift_closure" {
     GHC.Int.$fBitsInt16_$cshift_closure:
         const GHC.Int.$fBitsInt16_$cshift_info;
 },
 GHC.Int.$fBitsInt16_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4mxy,
                       label: GHC.Int.$fBitsInt16_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mxy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mxC; else goto c4mxD;
       c4mxC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mxD: // global
           I64[Sp - 16] = block_c4mxv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4myq; else goto c4mxw;
       u4myq: // global
           call _c4mxv(R1) args: 0, res: 0, upd: 0;
       c4mxw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mxv() //  [R1]
         { info_tbl: [(c4mxv,
                       label: block_c4mxv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mxv: // global
           I64[Sp] = block_c4mxB_info;
           _s4l2A::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l2A::I64;
           if (R1 & 7 != 0) goto u4myp; else goto c4mxF;
       u4myp: // global
           call _c4mxB(R1) args: 0, res: 0, upd: 0;
       c4mxF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mxB() //  [R1]
         { info_tbl: [(c4mxB,
                       label: block_c4mxB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mxB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mxL; else goto c4mxK;
       c4mxL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mxK: // global
           _s4l2A::I64 = I64[Sp + 8];
           _s4l2C::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l2C::I64, 0)) goto c4my9; else goto c4myo;
       c4my9: // global
           _s4l2E::I64 = -_s4l2C::I64;
           if (%MO_S_Lt_W64(_s4l2E::I64, 64)) goto c4my0; else goto c4my7;
       c4my0: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l2A::I64, _s4l2E::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4my7: // global
           if (%MO_S_Ge_W64(_s4l2A::I64, 0)) goto c4myn; else goto c4my6;
       c4my6: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4myo: // global
           if (%MO_S_Ge_W64(_s4l2C::I64, 64)) goto c4myn; else goto c4mym;
       c4myn: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mym: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4l2A::I64 << _s4l2C::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.728401352 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplement_closure" {
     GHC.Int.$fBitsInt16_$ccomplement_closure:
         const GHC.Int.$fBitsInt16_$ccomplement_info;
 },
 GHC.Int.$fBitsInt16_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4myy,
                       label: GHC.Int.$fBitsInt16_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4myy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4myL; else goto c4myM;
       c4myL: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4myM: // global
           I64[Sp - 8] = block_c4myv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4myQ; else goto c4myw;
       u4myQ: // global
           call _c4myv(R1) args: 0, res: 0, upd: 0;
       c4myw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4myv() //  [R1]
         { info_tbl: [(c4myv,
                       label: block_c4myv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4myv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4myP; else goto c4myO;
       c4myP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4myO: // global
           _s4l2Q::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l2Q::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.73042417 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cxor_closure" {
     GHC.Int.$fBitsInt16_$cxor_closure:
         const GHC.Int.$fBitsInt16_$cxor_info;
 },
 GHC.Int.$fBitsInt16_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4myY,
                       label: GHC.Int.$fBitsInt16_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4myY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mzj; else goto c4mzk;
       c4mzj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mzk: // global
           I64[Sp - 16] = block_c4myV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mzq; else goto c4myW;
       u4mzq: // global
           call _c4myV(R1) args: 0, res: 0, upd: 0;
       c4myW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4myV() //  [R1]
         { info_tbl: [(c4myV,
                       label: block_c4myV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4myV: // global
           I64[Sp] = block_c4mz1_info;
           _s4l2U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l2U::I64;
           if (R1 & 7 != 0) goto u4mzp; else goto c4mz2;
       u4mzp: // global
           call _c4mz1(R1) args: 0, res: 0, upd: 0;
       c4mz2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mz1() //  [R1]
         { info_tbl: [(c4mz1,
                       label: block_c4mz1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mz1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mzo; else goto c4mzn;
       c4mzo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mzn: // global
           _s4l30::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l30::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.732320045 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.|._closure" {
     GHC.Int.$fBitsInt16_$c.|._closure:
         const GHC.Int.$fBitsInt16_$c.|._info;
 },
 GHC.Int.$fBitsInt16_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4mzy,
                       label: GHC.Int.$fBitsInt16_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mzy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mzT; else goto c4mzU;
       c4mzT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mzU: // global
           I64[Sp - 16] = block_c4mzv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mA0; else goto c4mzw;
       u4mA0: // global
           call _c4mzv(R1) args: 0, res: 0, upd: 0;
       c4mzw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mzv() //  [R1]
         { info_tbl: [(c4mzv,
                       label: block_c4mzv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mzv: // global
           I64[Sp] = block_c4mzB_info;
           _s4l34::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l34::I64;
           if (R1 & 7 != 0) goto u4mzZ; else goto c4mzC;
       u4mzZ: // global
           call _c4mzB(R1) args: 0, res: 0, upd: 0;
       c4mzC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mzB() //  [R1]
         { info_tbl: [(c4mzB,
                       label: block_c4mzB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mzB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mzY; else goto c4mzX;
       c4mzY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mzX: // global
           _s4l3a::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l3a::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.734381393 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.&._closure" {
     GHC.Int.$fBitsInt16_$c.&._closure:
         const GHC.Int.$fBitsInt16_$c.&._info;
 },
 GHC.Int.$fBitsInt16_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4mA8,
                       label: GHC.Int.$fBitsInt16_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mA8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mAt; else goto c4mAu;
       c4mAt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mAu: // global
           I64[Sp - 16] = block_c4mA5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mAA; else goto c4mA6;
       u4mAA: // global
           call _c4mA5(R1) args: 0, res: 0, upd: 0;
       c4mA6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mA5() //  [R1]
         { info_tbl: [(c4mA5,
                       label: block_c4mA5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mA5: // global
           I64[Sp] = block_c4mAb_info;
           _s4l3e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3e::I64;
           if (R1 & 7 != 0) goto u4mAz; else goto c4mAc;
       u4mAz: // global
           call _c4mAb(R1) args: 0, res: 0, upd: 0;
       c4mAc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mAb() //  [R1]
         { info_tbl: [(c4mAb,
                       label: block_c4mAb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mAb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mAy; else goto c4mAx;
       c4mAy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mAx: // global
           _s4l3k::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l3k::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.736054536 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4mAI,
                       label: GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mAI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mAW; else goto c4mAX;
       c4mAW: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mAX: // global
           I64[Sp - 8] = block_c4mAF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mB1; else goto c4mAG;
       u4mB1: // global
           call _c4mAF(R1) args: 0, res: 0, upd: 0;
       c4mAG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mAF() //  [R1]
         { info_tbl: [(c4mAF,
                       label: block_c4mAF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mAF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mB0; else goto c4mAZ;
       c4mB0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mAZ: // global
           (_c4mAO::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mAO::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.737670158 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4mB9,
                       label: GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mB9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mBn; else goto c4mBo;
       c4mBn: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mBo: // global
           I64[Sp - 8] = block_c4mB6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mBs; else goto c4mB7;
       u4mBs: // global
           call _c4mB6(R1) args: 0, res: 0, upd: 0;
       c4mB7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mB6() //  [R1]
         { info_tbl: [(c4mB6,
                       label: block_c4mB6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mB6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mBr; else goto c4mBq;
       c4mBr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mBq: // global
           (_c4mBf::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mBf::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.73878027 UTC

[section ""data" . GHC.Int.$fBitsInt1_closure" {
     GHC.Int.$fBitsInt1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.739525652 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt16_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt16_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4mBx,
                       label: GHC.Int.$fBitsInt16_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mBx: // global
           R1 = GHC.Int.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.74052527 UTC

[section ""data" . GHC.Int.$fNumInt32_$cfromInteger_closure" {
     GHC.Int.$fNumInt32_$cfromInteger_closure:
         const GHC.Int.$fNumInt32_$cfromInteger_info;
 },
 GHC.Int.$fNumInt32_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4mBG,
                       label: GHC.Int.$fNumInt32_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mBG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mBN; else goto c4mBO;
       c4mBN: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mBO: // global
           I64[Sp - 8] = block_c4mBE_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4mBE() //  [R1]
         { info_tbl: [(c4mBE,
                       label: block_c4mBE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mBE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mBR; else goto c4mBQ;
       c4mBR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4mBQ: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.741883343 UTC

[section ""data" . GHC.Int.$fNumInt32_$cnegate_closure" {
     GHC.Int.$fNumInt32_$cnegate_closure:
         const GHC.Int.$fNumInt32_$cnegate_info;
 },
 GHC.Int.$fNumInt32_$cnegate_entry() //  [R2]
         { info_tbl: [(c4mBZ,
                       label: GHC.Int.$fNumInt32_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mBZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mC9; else goto c4mCa;
       c4mC9: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mCa: // global
           I64[Sp - 8] = block_c4mBW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mCe; else goto c4mBX;
       u4mCe: // global
           call _c4mBW(R1) args: 0, res: 0, upd: 0;
       c4mBX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mBW() //  [R1]
         { info_tbl: [(c4mBW,
                       label: block_c4mBW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mBW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mCd; else goto c4mCc;
       c4mCd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mCc: // global
           _s4l3F::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3F::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.743403143 UTC

[section ""data" . GHC.Int.$fNumInt32_$c*_closure" {
     GHC.Int.$fNumInt32_$c*_closure:
         const GHC.Int.$fNumInt32_$c*_info;
 },
 GHC.Int.$fNumInt32_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4mCm,
                       label: GHC.Int.$fNumInt32_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mCm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mCB; else goto c4mCC;
       c4mCB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mCC: // global
           I64[Sp - 16] = block_c4mCj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mCI; else goto c4mCk;
       u4mCI: // global
           call _c4mCj(R1) args: 0, res: 0, upd: 0;
       c4mCk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mCj() //  [R1]
         { info_tbl: [(c4mCj,
                       label: block_c4mCj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mCj: // global
           I64[Sp] = block_c4mCp_info;
           _s4l3J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3J::I64;
           if (R1 & 7 != 0) goto u4mCH; else goto c4mCq;
       u4mCH: // global
           call _c4mCp(R1) args: 0, res: 0, upd: 0;
       c4mCq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mCp() //  [R1]
         { info_tbl: [(c4mCp,
                       label: block_c4mCp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mCp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mCG; else goto c4mCF;
       c4mCG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mCF: // global
           _s4l3N::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3N::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.745218178 UTC

[section ""data" . GHC.Int.$fNumInt32_$c-_closure" {
     GHC.Int.$fNumInt32_$c-_closure:
         const GHC.Int.$fNumInt32_$c-_info;
 },
 GHC.Int.$fNumInt32_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4mCQ,
                       label: GHC.Int.$fNumInt32_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mCQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mD5; else goto c4mD6;
       c4mD5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mD6: // global
           I64[Sp - 16] = block_c4mCN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mDc; else goto c4mCO;
       u4mDc: // global
           call _c4mCN(R1) args: 0, res: 0, upd: 0;
       c4mCO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mCN() //  [R1]
         { info_tbl: [(c4mCN,
                       label: block_c4mCN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mCN: // global
           I64[Sp] = block_c4mCT_info;
           _s4l3R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3R::I64;
           if (R1 & 7 != 0) goto u4mDb; else goto c4mCU;
       u4mDb: // global
           call _c4mCT(R1) args: 0, res: 0, upd: 0;
       c4mCU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mCT() //  [R1]
         { info_tbl: [(c4mCT,
                       label: block_c4mCT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mCT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mDa; else goto c4mD9;
       c4mDa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mD9: // global
           _s4l3V::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3V::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.747936597 UTC

[section ""data" . GHC.Int.$fNumInt32_$c+_closure" {
     GHC.Int.$fNumInt32_$c+_closure:
         const GHC.Int.$fNumInt32_$c+_info;
 },
 GHC.Int.$fNumInt32_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4mDk,
                       label: GHC.Int.$fNumInt32_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mDk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mDz; else goto c4mDA;
       c4mDz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mDA: // global
           I64[Sp - 16] = block_c4mDh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mDG; else goto c4mDi;
       u4mDG: // global
           call _c4mDh(R1) args: 0, res: 0, upd: 0;
       c4mDi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mDh() //  [R1]
         { info_tbl: [(c4mDh,
                       label: block_c4mDh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mDh: // global
           I64[Sp] = block_c4mDn_info;
           _s4l3Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3Z::I64;
           if (R1 & 7 != 0) goto u4mDF; else goto c4mDo;
       u4mDF: // global
           call _c4mDn(R1) args: 0, res: 0, upd: 0;
       c4mDo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mDn() //  [R1]
         { info_tbl: [(c4mDn,
                       label: block_c4mDn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mDn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mDE; else goto c4mDD;
       c4mDE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mDD: // global
           _s4l43::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l43::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.749608675 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt32_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt32_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt32_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4mDO,
                       label: GHC.Int.$fIntegralInt32_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mDO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mDP; else goto c4mDQ;
       c4mDP: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mDQ: // global
           I64[Sp - 8] = block_c4mDL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mDU; else goto c4mDM;
       u4mDU: // global
           call _c4mDL(R1) args: 0, res: 0, upd: 0;
       c4mDM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mDL() //  [R1]
         { info_tbl: [(c4mDL,
                       label: block_c4mDL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mDL: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.750866854 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cpopCount_closure" {
     GHC.Int.$fBitsInt32_$cpopCount_closure:
         const GHC.Int.$fBitsInt32_$cpopCount_info;
 },
 GHC.Int.$fBitsInt32_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4mE2,
                       label: GHC.Int.$fBitsInt32_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mE2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mEg; else goto c4mEh;
       c4mEg: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mEh: // global
           I64[Sp - 8] = block_c4mDZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mEl; else goto c4mE0;
       u4mEl: // global
           call _c4mDZ(R1) args: 0, res: 0, upd: 0;
       c4mE0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mDZ() //  [R1]
         { info_tbl: [(c4mDZ,
                       label: block_c4mDZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mDZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mEk; else goto c4mEj;
       c4mEk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mEj: // global
           (_c4mE8::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mE8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.752311925 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4mEt,
                       label: GHC.Int.$fBitsInt32_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mEt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mEF; else goto c4mEG;
       c4mEF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mEG: // global
           I64[Sp - 16] = block_c4mEq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mEM; else goto c4mEr;
       u4mEM: // global
           call _c4mEq(R1) args: 0, res: 0, upd: 0;
       c4mEr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mEq() //  [R1]
         { info_tbl: [(c4mEq,
                       label: block_c4mEq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mEq: // global
           I64[Sp] = block_c4mEw_info;
           _s4l4g::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4g::I64;
           if (R1 & 7 != 0) goto u4mEL; else goto c4mEx;
       u4mEL: // global
           call _c4mEw(R1) args: 0, res: 0, upd: 0;
       c4mEx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mEw() //  [R1]
         { info_tbl: [(c4mEw,
                       label: block_c4mEw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mEw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mEK; else goto c4mEJ;
       c4mEK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mEJ: // global
           _s4l4j::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l4j::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.75421435 UTC

[section ""data" . GHC.Int.$fBitsInt6_closure" {
     GHC.Int.$fBitsInt6_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.754941175 UTC

[section ""data" . GHC.Int.$fNumInt4_closure" {
     GHC.Int.$fNumInt4_closure:
         const GHC.Int.I32#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.756502347 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftR_closure" {
     GHC.Int.$fBitsInt32_$cshiftR_closure:
         const GHC.Int.$fBitsInt32_$cshiftR_info;
 },
 GHC.Int.$fBitsInt32_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4mEU,
                       label: GHC.Int.$fBitsInt32_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mEU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mEY; else goto c4mEZ;
       c4mEY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mEZ: // global
           I64[Sp - 16] = block_c4mER_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mFp; else goto c4mES;
       u4mFp: // global
           call _c4mER(R1) args: 0, res: 0, upd: 0;
       c4mES: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mER() //  [R1]
         { info_tbl: [(c4mER,
                       label: block_c4mER_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mER: // global
           I64[Sp] = block_c4mEX_info;
           _s4l4n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4n::I64;
           if (R1 & 7 != 0) goto u4mFo; else goto c4mF1;
       u4mFo: // global
           call _c4mEX(R1) args: 0, res: 0, upd: 0;
       c4mF1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mEX() //  [R1]
         { info_tbl: [(c4mEX,
                       label: block_c4mEX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mEX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mF7; else goto c4mF6;
       c4mF7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mF6: // global
           _s4l4n::I64 = I64[Sp + 8];
           _s4l4p::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l4p::I64, 64)) goto c4mFg; else goto c4mFn;
       c4mFg: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l4n::I64, _s4l4p::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mFn: // global
           if (%MO_S_Ge_W64(_s4l4n::I64, 0)) goto c4mFl; else goto c4mFm;
       c4mFl: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mFm: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.759467768 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4mFx,
                       label: GHC.Int.$fBitsInt32_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mFx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mFM; else goto c4mFN;
       c4mFM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mFN: // global
           I64[Sp - 16] = block_c4mFu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mFT; else goto c4mFv;
       u4mFT: // global
           call _c4mFu(R1) args: 0, res: 0, upd: 0;
       c4mFv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mFu() //  [R1]
         { info_tbl: [(c4mFu,
                       label: block_c4mFu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mFu: // global
           I64[Sp] = block_c4mFA_info;
           _s4l4w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4w::I64;
           if (R1 & 7 != 0) goto u4mFS; else goto c4mFB;
       u4mFS: // global
           call _c4mFA(R1) args: 0, res: 0, upd: 0;
       c4mFB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mFA() //  [R1]
         { info_tbl: [(c4mFA,
                       label: block_c4mFA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mFA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mFR; else goto c4mFQ;
       c4mFR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mFQ: // global
           _s4l4A::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l4A::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.76195638 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftL_closure" {
     GHC.Int.$fBitsInt32_$cshiftL_closure:
         const GHC.Int.$fBitsInt32_$cshiftL_info;
 },
 GHC.Int.$fBitsInt32_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4mG1,
                       label: GHC.Int.$fBitsInt32_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mG1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mG5; else goto c4mG6;
       c4mG5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mG6: // global
           I64[Sp - 16] = block_c4mFY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mGt; else goto c4mFZ;
       u4mGt: // global
           call _c4mFY(R1) args: 0, res: 0, upd: 0;
       c4mFZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mFY() //  [R1]
         { info_tbl: [(c4mFY,
                       label: block_c4mFY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mFY: // global
           I64[Sp] = block_c4mG4_info;
           _s4l4E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4E::I64;
           if (R1 & 7 != 0) goto u4mGs; else goto c4mG8;
       u4mGs: // global
           call _c4mG4(R1) args: 0, res: 0, upd: 0;
       c4mG8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mG4() //  [R1]
         { info_tbl: [(c4mG4,
                       label: block_c4mG4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mG4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mGe; else goto c4mGd;
       c4mGe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mGd: // global
           _s4l4G::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l4G::I64, 64)) goto c4mGq; else goto c4mGr;
       c4mGq: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << _s4l4G::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mGr: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.764085925 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cisSigned_closure" {
     GHC.Int.$fBitsInt32_$cisSigned_closure:
         const GHC.Int.$fBitsInt32_$cisSigned_info;
 },
 GHC.Int.$fBitsInt32_$cisSigned_entry() //  []
         { info_tbl: [(c4mGy,
                       label: GHC.Int.$fBitsInt32_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mGy: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.765862166 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotate_closure" {
     GHC.Int.$fBitsInt32_$crotate_closure:
         const GHC.Int.$fBitsInt32_$crotate_info;
 },
 GHC.Int.$fBitsInt32_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4mGI,
                       label: GHC.Int.$fBitsInt32_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mGI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4mGM; else goto c4mGN;
       c4mGM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mGN: // global
           I64[Sp - 16] = block_c4mGF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mHJ; else goto c4mGG;
       u4mHJ: // global
           call _c4mGF(R1) args: 0, res: 0, upd: 0;
       c4mGG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mGF() //  [R1]
         { info_tbl: [(c4mGF,
                       label: block_c4mGF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mGF: // global
           I64[Sp - 8] = block_c4mGL_info;
           _s4l4N::P64 = R1;
           _s4l4O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l4O::I64;
           P64[Sp + 8] = _s4l4N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mHI; else goto c4mGP;
       u4mHI: // global
           call _c4mGL(R1) args: 0, res: 0, upd: 0;
       c4mGP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mGL() //  [R1]
         { info_tbl: [(c4mGL,
                       label: block_c4mGL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mGL: // global
           _s4l4T::I64 = I64[R1 + 7] & 31;
           if (_s4l4T::I64 != 0) goto u4mHG; else goto c4mHC;
       u4mHG: // global
           I64[Sp + 16] = _s4l4T::I64;
           Sp = Sp + 8;
           call _c4mH4() args: 0, res: 0, upd: 0;
       c4mHC: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4mH4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mH4: // global
           Hp = Hp + 16;
           _s4l4T::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4mHz; else goto c4mHy;
       c4mHz: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4mH3_info;
           R1 = _s4l4T::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4mHy: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4l4U::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4l4U::I64 << _s4l4T::I64) | (_s4l4U::I64 >> 32 - _s4l4T::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4mH3() //  [R1]
         { info_tbl: [(c4mH3,
                       label: block_c4mH3_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mH3: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4mH4() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.769204364 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshift_closure" {
     GHC.Int.$fBitsInt32_$cshift_closure:
         const GHC.Int.$fBitsInt32_$cshift_info;
 },
 GHC.Int.$fBitsInt32_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4mHT,
                       label: GHC.Int.$fBitsInt32_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mHT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mHX; else goto c4mHY;
       c4mHX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mHY: // global
           I64[Sp - 16] = block_c4mHQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mIL; else goto c4mHR;
       u4mIL: // global
           call _c4mHQ(R1) args: 0, res: 0, upd: 0;
       c4mHR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mHQ() //  [R1]
         { info_tbl: [(c4mHQ,
                       label: block_c4mHQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mHQ: // global
           I64[Sp] = block_c4mHW_info;
           _s4l55::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l55::I64;
           if (R1 & 7 != 0) goto u4mIK; else goto c4mI0;
       u4mIK: // global
           call _c4mHW(R1) args: 0, res: 0, upd: 0;
       c4mI0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mHW() //  [R1]
         { info_tbl: [(c4mHW,
                       label: block_c4mHW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mHW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mI6; else goto c4mI5;
       c4mI6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mI5: // global
           _s4l55::I64 = I64[Sp + 8];
           _s4l57::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l57::I64, 0)) goto c4mIu; else goto c4mIJ;
       c4mIu: // global
           _s4l59::I64 = -_s4l57::I64;
           if (%MO_S_Lt_W64(_s4l59::I64, 64)) goto c4mIl; else goto c4mIs;
       c4mIl: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l55::I64, _s4l59::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mIs: // global
           if (%MO_S_Ge_W64(_s4l55::I64, 0)) goto c4mII; else goto c4mIr;
       c4mIr: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mIJ: // global
           if (%MO_S_Ge_W64(_s4l57::I64, 64)) goto c4mII; else goto c4mIH;
       c4mII: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mIH: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4l55::I64 << _s4l57::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.772027787 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplement_closure" {
     GHC.Int.$fBitsInt32_$ccomplement_closure:
         const GHC.Int.$fBitsInt32_$ccomplement_info;
 },
 GHC.Int.$fBitsInt32_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4mIT,
                       label: GHC.Int.$fBitsInt32_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mIT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mJ6; else goto c4mJ7;
       c4mJ6: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mJ7: // global
           I64[Sp - 8] = block_c4mIQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mJb; else goto c4mIR;
       u4mJb: // global
           call _c4mIQ(R1) args: 0, res: 0, upd: 0;
       c4mIR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mIQ() //  [R1]
         { info_tbl: [(c4mIQ,
                       label: block_c4mIQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mIQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mJa; else goto c4mJ9;
       c4mJa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mJ9: // global
           _s4l5l::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.774110689 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cxor_closure" {
     GHC.Int.$fBitsInt32_$cxor_closure:
         const GHC.Int.$fBitsInt32_$cxor_info;
 },
 GHC.Int.$fBitsInt32_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4mJj,
                       label: GHC.Int.$fBitsInt32_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mJj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mJE; else goto c4mJF;
       c4mJE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mJF: // global
           I64[Sp - 16] = block_c4mJg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mJL; else goto c4mJh;
       u4mJL: // global
           call _c4mJg(R1) args: 0, res: 0, upd: 0;
       c4mJh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mJg() //  [R1]
         { info_tbl: [(c4mJg,
                       label: block_c4mJg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mJg: // global
           I64[Sp] = block_c4mJm_info;
           _s4l5p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5p::I64;
           if (R1 & 7 != 0) goto u4mJK; else goto c4mJn;
       u4mJK: // global
           call _c4mJm(R1) args: 0, res: 0, upd: 0;
       c4mJn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mJm() //  [R1]
         { info_tbl: [(c4mJm,
                       label: block_c4mJm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mJm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mJJ; else goto c4mJI;
       c4mJJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mJI: // global
           _s4l5v::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5v::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.776479652 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.|._closure" {
     GHC.Int.$fBitsInt32_$c.|._closure:
         const GHC.Int.$fBitsInt32_$c.|._info;
 },
 GHC.Int.$fBitsInt32_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4mJT,
                       label: GHC.Int.$fBitsInt32_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mJT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mKe; else goto c4mKf;
       c4mKe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mKf: // global
           I64[Sp - 16] = block_c4mJQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mKl; else goto c4mJR;
       u4mKl: // global
           call _c4mJQ(R1) args: 0, res: 0, upd: 0;
       c4mJR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mJQ() //  [R1]
         { info_tbl: [(c4mJQ,
                       label: block_c4mJQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mJQ: // global
           I64[Sp] = block_c4mJW_info;
           _s4l5z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5z::I64;
           if (R1 & 7 != 0) goto u4mKk; else goto c4mJX;
       u4mKk: // global
           call _c4mJW(R1) args: 0, res: 0, upd: 0;
       c4mJX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mJW() //  [R1]
         { info_tbl: [(c4mJW,
                       label: block_c4mJW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mJW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mKj; else goto c4mKi;
       c4mKj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mKi: // global
           _s4l5F::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5F::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.78014744 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.&._closure" {
     GHC.Int.$fBitsInt32_$c.&._closure:
         const GHC.Int.$fBitsInt32_$c.&._info;
 },
 GHC.Int.$fBitsInt32_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4mKt,
                       label: GHC.Int.$fBitsInt32_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mKt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mKO; else goto c4mKP;
       c4mKO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mKP: // global
           I64[Sp - 16] = block_c4mKq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mKV; else goto c4mKr;
       u4mKV: // global
           call _c4mKq(R1) args: 0, res: 0, upd: 0;
       c4mKr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mKq() //  [R1]
         { info_tbl: [(c4mKq,
                       label: block_c4mKq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mKq: // global
           I64[Sp] = block_c4mKw_info;
           _s4l5J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5J::I64;
           if (R1 & 7 != 0) goto u4mKU; else goto c4mKx;
       u4mKU: // global
           call _c4mKw(R1) args: 0, res: 0, upd: 0;
       c4mKx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mKw() //  [R1]
         { info_tbl: [(c4mKw,
                       label: block_c4mKw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mKw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mKT; else goto c4mKS;
       c4mKT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mKS: // global
           _s4l5P::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5P::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.782113791 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4mL3,
                       label: GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mL3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mLh; else goto c4mLi;
       c4mLh: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mLi: // global
           I64[Sp - 8] = block_c4mL0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mLm; else goto c4mL1;
       u4mLm: // global
           call _c4mL0(R1) args: 0, res: 0, upd: 0;
       c4mL1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mL0() //  [R1]
         { info_tbl: [(c4mL0,
                       label: block_c4mL0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mL0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mLl; else goto c4mLk;
       c4mLl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mLk: // global
           (_c4mL9::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mL9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.783462824 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4mLu,
                       label: GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mLu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mLI; else goto c4mLJ;
       c4mLI: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mLJ: // global
           I64[Sp - 8] = block_c4mLr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mLN; else goto c4mLs;
       u4mLN: // global
           call _c4mLr(R1) args: 0, res: 0, upd: 0;
       c4mLs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mLr() //  [R1]
         { info_tbl: [(c4mLr,
                       label: block_c4mLr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mLr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mLM; else goto c4mLL;
       c4mLM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mLL: // global
           (_c4mLA::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mLA::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.784881403 UTC

[section ""data" . GHC.Int.$fBitsInt4_closure" {
     GHC.Int.$fBitsInt4_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.785900173 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt32_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt32_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4mLS,
                       label: GHC.Int.$fBitsInt32_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mLS: // global
           R1 = GHC.Int.$fBitsInt4_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.787202435 UTC

[section ""data" . GHC.Int.$fNumInt64_$cfromInteger_closure" {
     GHC.Int.$fNumInt64_$cfromInteger_closure:
         const GHC.Int.$fNumInt64_$cfromInteger_info;
 },
 GHC.Int.$fNumInt64_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4mM1,
                       label: GHC.Int.$fNumInt64_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mM1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mM5; else goto c4mM6;
       c4mM5: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mM6: // global
           I64[Sp - 8] = block_c4mLZ_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4mLZ() //  [R1]
         { info_tbl: [(c4mLZ,
                       label: block_c4mLZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mLZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mM9; else goto c4mM8;
       c4mM9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4mM8: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.789010924 UTC

[section ""data" . GHC.Int.$fNumInt64_$cnegate_closure" {
     GHC.Int.$fNumInt64_$cnegate_closure:
         const GHC.Int.$fNumInt64_$cnegate_info;
 },
 GHC.Int.$fNumInt64_$cnegate_entry() //  [R2]
         { info_tbl: [(c4mMh,
                       label: GHC.Int.$fNumInt64_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mMh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mMo; else goto c4mMp;
       c4mMo: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mMp: // global
           I64[Sp - 8] = block_c4mMe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mMt; else goto c4mMf;
       u4mMt: // global
           call _c4mMe(R1) args: 0, res: 0, upd: 0;
       c4mMf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mMe() //  [R1]
         { info_tbl: [(c4mMe,
                       label: block_c4mMe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mMe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mMs; else goto c4mMr;
       c4mMs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mMr: // global
           _s4l68::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l68::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.791091008 UTC

[section ""data" . GHC.Int.$fNumInt64_$c*_closure" {
     GHC.Int.$fNumInt64_$c*_closure:
         const GHC.Int.$fNumInt64_$c*_info;
 },
 GHC.Int.$fNumInt64_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4mMB,
                       label: GHC.Int.$fNumInt64_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mMB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mMN; else goto c4mMO;
       c4mMN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mMO: // global
           I64[Sp - 16] = block_c4mMy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mMU; else goto c4mMz;
       u4mMU: // global
           call _c4mMy(R1) args: 0, res: 0, upd: 0;
       c4mMz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mMy() //  [R1]
         { info_tbl: [(c4mMy,
                       label: block_c4mMy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mMy: // global
           I64[Sp] = block_c4mME_info;
           _s4l6c::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6c::I64;
           if (R1 & 7 != 0) goto u4mMT; else goto c4mMF;
       u4mMT: // global
           call _c4mME(R1) args: 0, res: 0, upd: 0;
       c4mMF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mME() //  [R1]
         { info_tbl: [(c4mME,
                       label: block_c4mME_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mME: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mMS; else goto c4mMR;
       c4mMS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mMR: // global
           _s4l6f::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6f::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.793839212 UTC

[section ""data" . GHC.Int.$fNumInt64_$c-_closure" {
     GHC.Int.$fNumInt64_$c-_closure:
         const GHC.Int.$fNumInt64_$c-_info;
 },
 GHC.Int.$fNumInt64_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4mN2,
                       label: GHC.Int.$fNumInt64_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mN2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mNe; else goto c4mNf;
       c4mNe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mNf: // global
           I64[Sp - 16] = block_c4mMZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mNl; else goto c4mN0;
       u4mNl: // global
           call _c4mMZ(R1) args: 0, res: 0, upd: 0;
       c4mN0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mMZ() //  [R1]
         { info_tbl: [(c4mMZ,
                       label: block_c4mMZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mMZ: // global
           I64[Sp] = block_c4mN5_info;
           _s4l6j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6j::I64;
           if (R1 & 7 != 0) goto u4mNk; else goto c4mN6;
       u4mNk: // global
           call _c4mN5(R1) args: 0, res: 0, upd: 0;
       c4mN6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mN5() //  [R1]
         { info_tbl: [(c4mN5,
                       label: block_c4mN5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mN5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mNj; else goto c4mNi;
       c4mNj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mNi: // global
           _s4l6m::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6m::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.79616568 UTC

[section ""data" . GHC.Int.$fNumInt64_$c+_closure" {
     GHC.Int.$fNumInt64_$c+_closure:
         const GHC.Int.$fNumInt64_$c+_info;
 },
 GHC.Int.$fNumInt64_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4mNt,
                       label: GHC.Int.$fNumInt64_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mNt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mNF; else goto c4mNG;
       c4mNF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mNG: // global
           I64[Sp - 16] = block_c4mNq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mNM; else goto c4mNr;
       u4mNM: // global
           call _c4mNq(R1) args: 0, res: 0, upd: 0;
       c4mNr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mNq() //  [R1]
         { info_tbl: [(c4mNq,
                       label: block_c4mNq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mNq: // global
           I64[Sp] = block_c4mNw_info;
           _s4l6q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6q::I64;
           if (R1 & 7 != 0) goto u4mNL; else goto c4mNx;
       u4mNL: // global
           call _c4mNw(R1) args: 0, res: 0, upd: 0;
       c4mNx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mNw() //  [R1]
         { info_tbl: [(c4mNw,
                       label: block_c4mNw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mNw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mNK; else goto c4mNJ;
       c4mNK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mNJ: // global
           _s4l6t::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.798373832 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt64_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt64_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt64_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4mNU,
                       label: GHC.Int.$fIntegralInt64_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mNU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mNV; else goto c4mNW;
       c4mNV: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mNW: // global
           I64[Sp - 8] = block_c4mNR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mO0; else goto c4mNS;
       u4mO0: // global
           call _c4mNR(R1) args: 0, res: 0, upd: 0;
       c4mNS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mNR() //  [R1]
         { info_tbl: [(c4mNR,
                       label: block_c4mNR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mNR: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.800083756 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cpopCount_closure" {
     GHC.Int.$fBitsInt64_$cpopCount_closure:
         const GHC.Int.$fBitsInt64_$cpopCount_info;
 },
 GHC.Int.$fBitsInt64_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4mO8,
                       label: GHC.Int.$fBitsInt64_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mO8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mOm; else goto c4mOn;
       c4mOm: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mOn: // global
           I64[Sp - 8] = block_c4mO5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mOr; else goto c4mO6;
       u4mOr: // global
           call _c4mO5(R1) args: 0, res: 0, upd: 0;
       c4mO6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mO5() //  [R1]
         { info_tbl: [(c4mO5,
                       label: block_c4mO5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mO5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mOq; else goto c4mOp;
       c4mOq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mOp: // global
           (_c4mOe::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mOe::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.801989783 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4mOz,
                       label: GHC.Int.$fBitsInt64_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mOz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mOL; else goto c4mOM;
       c4mOL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mOM: // global
           I64[Sp - 16] = block_c4mOw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mOS; else goto c4mOx;
       u4mOS: // global
           call _c4mOw(R1) args: 0, res: 0, upd: 0;
       c4mOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mOw() //  [R1]
         { info_tbl: [(c4mOw,
                       label: block_c4mOw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mOw: // global
           I64[Sp] = block_c4mOC_info;
           _s4l6G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6G::I64;
           if (R1 & 7 != 0) goto u4mOR; else goto c4mOD;
       u4mOR: // global
           call _c4mOC(R1) args: 0, res: 0, upd: 0;
       c4mOD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mOC() //  [R1]
         { info_tbl: [(c4mOC,
                       label: block_c4mOC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mOC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mOQ; else goto c4mOP;
       c4mOQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mOP: // global
           _s4l6J::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6J::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.803537161 UTC

[section ""data" . GHC.Int.$fBitsInt10_closure" {
     GHC.Int.$fBitsInt10_closure:
         const GHC.Int.I64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.804156317 UTC

[section ""data" . GHC.Int.$fNumInt6_closure" {
     GHC.Int.$fNumInt6_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.805620654 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftR_closure" {
     GHC.Int.$fBitsInt64_$cshiftR_closure:
         const GHC.Int.$fBitsInt64_$cshiftR_info;
 },
 GHC.Int.$fBitsInt64_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4mP0,
                       label: GHC.Int.$fBitsInt64_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mP0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mP4; else goto c4mP5;
       c4mP4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mP5: // global
           I64[Sp - 16] = block_c4mOX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mPv; else goto c4mOY;
       u4mPv: // global
           call _c4mOX(R1) args: 0, res: 0, upd: 0;
       c4mOY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mOX() //  [R1]
         { info_tbl: [(c4mOX,
                       label: block_c4mOX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mOX: // global
           I64[Sp] = block_c4mP3_info;
           _s4l6N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6N::I64;
           if (R1 & 7 != 0) goto u4mPu; else goto c4mP7;
       u4mPu: // global
           call _c4mP3(R1) args: 0, res: 0, upd: 0;
       c4mP7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mP3() //  [R1]
         { info_tbl: [(c4mP3,
                       label: block_c4mP3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mP3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mPd; else goto c4mPc;
       c4mPd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mPc: // global
           _s4l6N::I64 = I64[Sp + 8];
           _s4l6P::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l6P::I64, 64)) goto c4mPm; else goto c4mPt;
       c4mPm: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l6N::I64, _s4l6P::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mPt: // global
           if (%MO_S_Ge_W64(_s4l6N::I64, 0)) goto c4mPr; else goto c4mPs;
       c4mPr: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mPs: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.807620945 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4mPD,
                       label: GHC.Int.$fBitsInt64_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mPD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mPP; else goto c4mPQ;
       c4mPP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mPQ: // global
           I64[Sp - 16] = block_c4mPA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mPW; else goto c4mPB;
       u4mPW: // global
           call _c4mPA(R1) args: 0, res: 0, upd: 0;
       c4mPB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mPA() //  [R1]
         { info_tbl: [(c4mPA,
                       label: block_c4mPA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mPA: // global
           I64[Sp] = block_c4mPG_info;
           _s4l6W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6W::I64;
           if (R1 & 7 != 0) goto u4mPV; else goto c4mPH;
       u4mPV: // global
           call _c4mPG(R1) args: 0, res: 0, upd: 0;
       c4mPH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mPG() //  [R1]
         { info_tbl: [(c4mPG,
                       label: block_c4mPG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mPG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mPU; else goto c4mPT;
       c4mPU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mPT: // global
           _s4l6Z::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6Z::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.81040656 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftL_closure" {
     GHC.Int.$fBitsInt64_$cshiftL_closure:
         const GHC.Int.$fBitsInt64_$cshiftL_info;
 },
 GHC.Int.$fBitsInt64_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4mQ4,
                       label: GHC.Int.$fBitsInt64_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mQ4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mQ8; else goto c4mQ9;
       c4mQ8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mQ9: // global
           I64[Sp - 16] = block_c4mQ1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mQt; else goto c4mQ2;
       u4mQt: // global
           call _c4mQ1(R1) args: 0, res: 0, upd: 0;
       c4mQ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mQ1() //  [R1]
         { info_tbl: [(c4mQ1,
                       label: block_c4mQ1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mQ1: // global
           I64[Sp] = block_c4mQ7_info;
           _s4l73::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l73::I64;
           if (R1 & 7 != 0) goto u4mQs; else goto c4mQb;
       u4mQs: // global
           call _c4mQ7(R1) args: 0, res: 0, upd: 0;
       c4mQb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mQ7() //  [R1]
         { info_tbl: [(c4mQ7,
                       label: block_c4mQ7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mQ7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mQh; else goto c4mQg;
       c4mQh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mQg: // global
           _s4l75::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l75::I64, 64)) goto c4mQq; else goto c4mQr;
       c4mQq: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s4l75::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mQr: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.811993613 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cisSigned_closure" {
     GHC.Int.$fBitsInt64_$cisSigned_closure:
         const GHC.Int.$fBitsInt64_$cisSigned_info;
 },
 GHC.Int.$fBitsInt64_$cisSigned_entry() //  []
         { info_tbl: [(c4mQy,
                       label: GHC.Int.$fBitsInt64_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mQy: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.813373721 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotate_closure" {
     GHC.Int.$fBitsInt64_$crotate_closure:
         const GHC.Int.$fBitsInt64_$crotate_info;
 },
 GHC.Int.$fBitsInt64_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4mQI,
                       label: GHC.Int.$fBitsInt64_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mQI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4mQM; else goto c4mQN;
       c4mQM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mQN: // global
           I64[Sp - 16] = block_c4mQF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mRD; else goto c4mQG;
       u4mRD: // global
           call _c4mQF(R1) args: 0, res: 0, upd: 0;
       c4mQG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mQF() //  [R1]
         { info_tbl: [(c4mQF,
                       label: block_c4mQF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mQF: // global
           I64[Sp - 8] = block_c4mQL_info;
           _s4l7b::P64 = R1;
           _s4l7c::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l7c::I64;
           P64[Sp + 8] = _s4l7b::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mRC; else goto c4mQP;
       u4mRC: // global
           call _c4mQL(R1) args: 0, res: 0, upd: 0;
       c4mQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mQL() //  [R1]
         { info_tbl: [(c4mQL,
                       label: block_c4mQL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mQL: // global
           _s4l7h::I64 = I64[R1 + 7] & 63;
           if (_s4l7h::I64 != 0) goto u4mRA; else goto c4mRw;
       u4mRA: // global
           I64[Sp + 16] = _s4l7h::I64;
           Sp = Sp + 8;
           call _c4mR4() args: 0, res: 0, upd: 0;
       c4mRw: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4mR4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mR4: // global
           Hp = Hp + 16;
           _s4l7h::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4mRt; else goto c4mRs;
       c4mRt: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4mR3_info;
           R1 = _s4l7h::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4mRs: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4l7i::I64 = I64[Sp];
           I64[Hp] = (_s4l7i::I64 << _s4l7h::I64) | (_s4l7i::I64 >> 64 - _s4l7h::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4mR3() //  [R1]
         { info_tbl: [(c4mR3,
                       label: block_c4mR3_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mR3: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4mR4() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.815720128 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshift_closure" {
     GHC.Int.$fBitsInt64_$cshift_closure:
         const GHC.Int.$fBitsInt64_$cshift_info;
 },
 GHC.Int.$fBitsInt64_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4mRN,
                       label: GHC.Int.$fBitsInt64_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mRN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mRR; else goto c4mRS;
       c4mRR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mRS: // global
           I64[Sp - 16] = block_c4mRK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mSC; else goto c4mRL;
       u4mSC: // global
           call _c4mRK(R1) args: 0, res: 0, upd: 0;
       c4mRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mRK() //  [R1]
         { info_tbl: [(c4mRK,
                       label: block_c4mRK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mRK: // global
           I64[Sp] = block_c4mRQ_info;
           _s4l7r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7r::I64;
           if (R1 & 7 != 0) goto u4mSB; else goto c4mRU;
       u4mSB: // global
           call _c4mRQ(R1) args: 0, res: 0, upd: 0;
       c4mRU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mRQ() //  [R1]
         { info_tbl: [(c4mRQ,
                       label: block_c4mRQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mRQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mS0; else goto c4mRZ;
       c4mS0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mRZ: // global
           _s4l7r::I64 = I64[Sp + 8];
           _s4l7t::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l7t::I64, 0)) goto c4mSo; else goto c4mSA;
       c4mSo: // global
           _s4l7v::I64 = -_s4l7t::I64;
           if (%MO_S_Lt_W64(_s4l7v::I64, 64)) goto c4mSf; else goto c4mSm;
       c4mSf: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l7r::I64, _s4l7v::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mSm: // global
           if (%MO_S_Ge_W64(_s4l7r::I64, 0)) goto c4mSz; else goto c4mSl;
       c4mSl: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mSA: // global
           if (%MO_S_Ge_W64(_s4l7t::I64, 64)) goto c4mSz; else goto c4mSy;
       c4mSz: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mSy: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7r::I64 << _s4l7t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.817851836 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplement_closure" {
     GHC.Int.$fBitsInt64_$ccomplement_closure:
         const GHC.Int.$fBitsInt64_$ccomplement_info;
 },
 GHC.Int.$fBitsInt64_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4mSK,
                       label: GHC.Int.$fBitsInt64_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mSK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mSX; else goto c4mSY;
       c4mSX: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mSY: // global
           I64[Sp - 8] = block_c4mSH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mT2; else goto c4mSI;
       u4mT2: // global
           call _c4mSH(R1) args: 0, res: 0, upd: 0;
       c4mSI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mSH() //  [R1]
         { info_tbl: [(c4mSH,
                       label: block_c4mSH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mSH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mT1; else goto c4mT0;
       c4mT1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mT0: // global
           _s4l7G::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7G::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.819344206 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cxor_closure" {
     GHC.Int.$fBitsInt64_$cxor_closure:
         const GHC.Int.$fBitsInt64_$cxor_info;
 },
 GHC.Int.$fBitsInt64_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4mTa,
                       label: GHC.Int.$fBitsInt64_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mTa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mTv; else goto c4mTw;
       c4mTv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mTw: // global
           I64[Sp - 16] = block_c4mT7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mTC; else goto c4mT8;
       u4mTC: // global
           call _c4mT7(R1) args: 0, res: 0, upd: 0;
       c4mT8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mT7() //  [R1]
         { info_tbl: [(c4mT7,
                       label: block_c4mT7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mT7: // global
           I64[Sp] = block_c4mTd_info;
           _s4l7K::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7K::I64;
           if (R1 & 7 != 0) goto u4mTB; else goto c4mTe;
       u4mTB: // global
           call _c4mTd(R1) args: 0, res: 0, upd: 0;
       c4mTe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mTd() //  [R1]
         { info_tbl: [(c4mTd,
                       label: block_c4mTd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mTd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mTA; else goto c4mTz;
       c4mTA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mTz: // global
           _s4l7Q::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7Q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.821031784 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.|._closure" {
     GHC.Int.$fBitsInt64_$c.|._closure:
         const GHC.Int.$fBitsInt64_$c.|._info;
 },
 GHC.Int.$fBitsInt64_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4mTK,
                       label: GHC.Int.$fBitsInt64_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mTK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mU5; else goto c4mU6;
       c4mU5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mU6: // global
           I64[Sp - 16] = block_c4mTH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mUc; else goto c4mTI;
       u4mUc: // global
           call _c4mTH(R1) args: 0, res: 0, upd: 0;
       c4mTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mTH() //  [R1]
         { info_tbl: [(c4mTH,
                       label: block_c4mTH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mTH: // global
           I64[Sp] = block_c4mTN_info;
           _s4l7U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7U::I64;
           if (R1 & 7 != 0) goto u4mUb; else goto c4mTO;
       u4mUb: // global
           call _c4mTN(R1) args: 0, res: 0, upd: 0;
       c4mTO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mTN() //  [R1]
         { info_tbl: [(c4mTN,
                       label: block_c4mTN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mTN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mUa; else goto c4mU9;
       c4mUa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mU9: // global
           _s4l80::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l80::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.822782426 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.&._closure" {
     GHC.Int.$fBitsInt64_$c.&._closure:
         const GHC.Int.$fBitsInt64_$c.&._info;
 },
 GHC.Int.$fBitsInt64_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4mUk,
                       label: GHC.Int.$fBitsInt64_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mUk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mUF; else goto c4mUG;
       c4mUF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mUG: // global
           I64[Sp - 16] = block_c4mUh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mUM; else goto c4mUi;
       u4mUM: // global
           call _c4mUh(R1) args: 0, res: 0, upd: 0;
       c4mUi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mUh() //  [R1]
         { info_tbl: [(c4mUh,
                       label: block_c4mUh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mUh: // global
           I64[Sp] = block_c4mUn_info;
           _s4l84::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l84::I64;
           if (R1 & 7 != 0) goto u4mUL; else goto c4mUo;
       u4mUL: // global
           call _c4mUn(R1) args: 0, res: 0, upd: 0;
       c4mUo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mUn() //  [R1]
         { info_tbl: [(c4mUn,
                       label: block_c4mUn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mUn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mUK; else goto c4mUJ;
       c4mUK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mUJ: // global
           _s4l8a::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l8a::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.824397864 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4mUU,
                       label: GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mUU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mV8; else goto c4mV9;
       c4mV8: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mV9: // global
           I64[Sp - 8] = block_c4mUR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mVd; else goto c4mUS;
       u4mVd: // global
           call _c4mUR(R1) args: 0, res: 0, upd: 0;
       c4mUS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mUR() //  [R1]
         { info_tbl: [(c4mUR,
                       label: block_c4mUR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mUR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mVc; else goto c4mVb;
       c4mVc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mVb: // global
           (_c4mV0::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mV0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.825831432 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4mVl,
                       label: GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mVl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mVz; else goto c4mVA;
       c4mVz: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mVA: // global
           I64[Sp - 8] = block_c4mVi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mVE; else goto c4mVj;
       u4mVE: // global
           call _c4mVi(R1) args: 0, res: 0, upd: 0;
       c4mVj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mVi() //  [R1]
         { info_tbl: [(c4mVi,
                       label: block_c4mVi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mVi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4mVD; else goto c4mVC;
       c4mVD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4mVC: // global
           (_c4mVr::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4mVr::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.826937536 UTC

[section ""data" . GHC.Int.$fBitsInt7_closure" {
     GHC.Int.$fBitsInt7_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.827575663 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt64_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt64_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4mVJ,
                       label: GHC.Int.$fBitsInt64_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mVJ: // global
           R1 = GHC.Int.$fBitsInt7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.828601647 UTC

[section ""data" . GHC.Int.eqInt8_closure" {
     GHC.Int.eqInt8_closure:
         const GHC.Int.eqInt8_info;
 },
 GHC.Int.eqInt8_entry() //  [R2, R3]
         { info_tbl: [(c4mVT,
                       label: GHC.Int.eqInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mVT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mVX; else goto c4mVY;
       c4mVX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mVY: // global
           I64[Sp - 16] = block_c4mVQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mW7; else goto c4mVR;
       u4mW7: // global
           call _c4mVQ(R1) args: 0, res: 0, upd: 0;
       c4mVR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mVQ() //  [R1]
         { info_tbl: [(c4mVQ,
                       label: block_c4mVQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mVQ: // global
           I64[Sp] = block_c4mVW_info;
           _s4l8r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8r::I64;
           if (R1 & 7 != 0) goto u4mW6; else goto c4mW0;
       u4mW6: // global
           call _c4mVW(R1) args: 0, res: 0, upd: 0;
       c4mW0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mVW() //  [R1]
         { info_tbl: [(c4mVW,
                       label: block_c4mVW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mVW: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.829946167 UTC

[section ""data" . GHC.Int.$fEqInt8_closure" {
     GHC.Int.$fEqInt8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt8_closure+2;
         const GHC.Int.neInt8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.830917923 UTC

[section ""data" . GHC.Int.gtInt8_closure" {
     GHC.Int.gtInt8_closure:
         const GHC.Int.gtInt8_info;
 },
 GHC.Int.gtInt8_entry() //  [R2, R3]
         { info_tbl: [(c4mWf,
                       label: GHC.Int.gtInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mWf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mWj; else goto c4mWk;
       c4mWj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mWk: // global
           I64[Sp - 16] = block_c4mWc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mWt; else goto c4mWd;
       u4mWt: // global
           call _c4mWc(R1) args: 0, res: 0, upd: 0;
       c4mWd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mWc() //  [R1]
         { info_tbl: [(c4mWc,
                       label: block_c4mWc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mWc: // global
           I64[Sp] = block_c4mWi_info;
           _s4l8y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8y::I64;
           if (R1 & 7 != 0) goto u4mWs; else goto c4mWm;
       u4mWs: // global
           call _c4mWi(R1) args: 0, res: 0, upd: 0;
       c4mWm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mWi() //  [R1]
         { info_tbl: [(c4mWi,
                       label: block_c4mWi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mWi: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.833843989 UTC

[section ""data" . GHC.Int.geInt8_closure" {
     GHC.Int.geInt8_closure:
         const GHC.Int.geInt8_info;
 },
 GHC.Int.geInt8_entry() //  [R2, R3]
         { info_tbl: [(c4mWB,
                       label: GHC.Int.geInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mWB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mWF; else goto c4mWG;
       c4mWF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mWG: // global
           I64[Sp - 16] = block_c4mWy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mWP; else goto c4mWz;
       u4mWP: // global
           call _c4mWy(R1) args: 0, res: 0, upd: 0;
       c4mWz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mWy() //  [R1]
         { info_tbl: [(c4mWy,
                       label: block_c4mWy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mWy: // global
           I64[Sp] = block_c4mWE_info;
           _s4l8F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8F::I64;
           if (R1 & 7 != 0) goto u4mWO; else goto c4mWI;
       u4mWO: // global
           call _c4mWE(R1) args: 0, res: 0, upd: 0;
       c4mWI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mWE() //  [R1]
         { info_tbl: [(c4mWE,
                       label: block_c4mWE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mWE: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.835380558 UTC

[section ""data" . GHC.Int.ltInt8_closure" {
     GHC.Int.ltInt8_closure:
         const GHC.Int.ltInt8_info;
 },
 GHC.Int.ltInt8_entry() //  [R2, R3]
         { info_tbl: [(c4mWX,
                       label: GHC.Int.ltInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mWX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mX1; else goto c4mX2;
       c4mX1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mX2: // global
           I64[Sp - 16] = block_c4mWU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mXb; else goto c4mWV;
       u4mXb: // global
           call _c4mWU(R1) args: 0, res: 0, upd: 0;
       c4mWV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mWU() //  [R1]
         { info_tbl: [(c4mWU,
                       label: block_c4mWU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mWU: // global
           I64[Sp] = block_c4mX0_info;
           _s4l8M::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8M::I64;
           if (R1 & 7 != 0) goto u4mXa; else goto c4mX4;
       u4mXa: // global
           call _c4mX0(R1) args: 0, res: 0, upd: 0;
       c4mX4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mX0() //  [R1]
         { info_tbl: [(c4mX0,
                       label: block_c4mX0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mX0: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.836954553 UTC

[section ""data" . GHC.Int.leInt8_closure" {
     GHC.Int.leInt8_closure:
         const GHC.Int.leInt8_info;
 },
 GHC.Int.leInt8_entry() //  [R2, R3]
         { info_tbl: [(c4mXj,
                       label: GHC.Int.leInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mXj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mXn; else goto c4mXo;
       c4mXn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mXo: // global
           I64[Sp - 16] = block_c4mXg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mXx; else goto c4mXh;
       u4mXx: // global
           call _c4mXg(R1) args: 0, res: 0, upd: 0;
       c4mXh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mXg() //  [R1]
         { info_tbl: [(c4mXg,
                       label: block_c4mXg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mXg: // global
           I64[Sp] = block_c4mXm_info;
           _s4l8T::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8T::I64;
           if (R1 & 7 != 0) goto u4mXw; else goto c4mXq;
       u4mXw: // global
           call _c4mXm(R1) args: 0, res: 0, upd: 0;
       c4mXq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mXm() //  [R1]
         { info_tbl: [(c4mXm,
                       label: block_c4mXm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mXm: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.838697497 UTC

[section ""data" . GHC.Int.$fOrdInt8_$ccompare_closure" {
     GHC.Int.$fOrdInt8_$ccompare_closure:
         const GHC.Int.$fOrdInt8_$ccompare_info;
 },
 GHC.Int.$fOrdInt8_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4mXF,
                       label: GHC.Int.$fOrdInt8_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mXF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4mXJ; else goto c4mXK;
       c4mXJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mXK: // global
           I64[Sp - 16] = block_c4mXC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mY3; else goto c4mXD;
       u4mY3: // global
           call _c4mXC(R1) args: 0, res: 0, upd: 0;
       c4mXD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mXC() //  [R1]
         { info_tbl: [(c4mXC,
                       label: block_c4mXC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mXC: // global
           I64[Sp] = block_c4mXI_info;
           _s4l90::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l90::I64;
           if (R1 & 7 != 0) goto u4mY2; else goto c4mXM;
       u4mY2: // global
           call _c4mXI(R1) args: 0, res: 0, upd: 0;
       c4mXM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mXI() //  [R1]
         { info_tbl: [(c4mXI,
                       label: block_c4mXI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mXI: // global
           _s4l90::I64 = I64[Sp + 8];
           _s4l92::I64 = I64[R1 + 7];
           if (_s4l90::I64 == _s4l92::I64) goto c4mY1; else goto c4mY0;
       c4mY1: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mY0: // global
           if (%MO_S_Gt_W64(_s4l90::I64,
                            _s4l92::I64)) goto c4mXX; else goto c4mXY;
       c4mXX: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mXY: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.840497323 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmax_closure" {
     GHC.Int.$fOrdInt8_$cmax_closure:
         const GHC.Int.$fOrdInt8_$cmax_info;
 },
 GHC.Int.$fOrdInt8_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4mYb,
                       label: GHC.Int.$fOrdInt8_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mYb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4mYf; else goto c4mYg;
       c4mYf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mYg: // global
           I64[Sp - 16] = block_c4mY8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mYt; else goto c4mY9;
       u4mYt: // global
           call _c4mY8(R1) args: 0, res: 0, upd: 0;
       c4mY9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mY8() //  [R1]
         { info_tbl: [(c4mY8,
                       label: block_c4mY8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mY8: // global
           I64[Sp - 8] = block_c4mYe_info;
           _s4l97::P64 = R1;
           _s4l98::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l98::I64;
           P64[Sp + 8] = _s4l97::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mYs; else goto c4mYi;
       u4mYs: // global
           call _c4mYe(R1) args: 0, res: 0, upd: 0;
       c4mYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mYe() //  [R1]
         { info_tbl: [(c4mYe,
                       label: block_c4mYe_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mYe: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4mYq; else goto c4mYr;
       c4mYq: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4mYr: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.842177014 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmin_closure" {
     GHC.Int.$fOrdInt8_$cmin_closure:
         const GHC.Int.$fOrdInt8_$cmin_info;
 },
 GHC.Int.$fOrdInt8_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4mYB,
                       label: GHC.Int.$fOrdInt8_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mYB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4mYF; else goto c4mYG;
       c4mYF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mYG: // global
           I64[Sp - 16] = block_c4mYy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mYT; else goto c4mYz;
       u4mYT: // global
           call _c4mYy(R1) args: 0, res: 0, upd: 0;
       c4mYz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mYy() //  [R1]
         { info_tbl: [(c4mYy,
                       label: block_c4mYy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mYy: // global
           I64[Sp - 8] = block_c4mYE_info;
           _s4l9e::P64 = R1;
           _s4l9f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l9f::I64;
           P64[Sp + 8] = _s4l9e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mYS; else goto c4mYI;
       u4mYS: // global
           call _c4mYE(R1) args: 0, res: 0, upd: 0;
       c4mYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mYE() //  [R1]
         { info_tbl: [(c4mYE,
                       label: block_c4mYE_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mYE: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4mYQ; else goto c4mYR;
       c4mYQ: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4mYR: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.843895796 UTC

[section ""data" . GHC.Int.$fOrdInt8_closure" {
     GHC.Int.$fOrdInt8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fOrdInt8_$ccompare_closure+2;
         const GHC.Int.ltInt8_closure+2;
         const GHC.Int.leInt8_closure+2;
         const GHC.Int.gtInt8_closure+2;
         const GHC.Int.geInt8_closure+2;
         const GHC.Int.$fOrdInt8_$cmax_closure+2;
         const GHC.Int.$fOrdInt8_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.845950204 UTC

[section ""data" . GHC.Int.$fIxInt8_$cinRange_closure" {
     GHC.Int.$fIxInt8_$cinRange_closure:
         const GHC.Int.$fIxInt8_$cinRange_info;
 },
 GHC.Int.$fIxInt8_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4mZ1,
                       label: GHC.Int.$fIxInt8_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mZ1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4mZa; else goto c4mZb;
       c4mZa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4mZb: // global
           I64[Sp - 16] = block_c4mYY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4mZy; else goto c4mYZ;
       u4mZy: // global
           call _c4mYY(R1) args: 0, res: 0, upd: 0;
       c4mYZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mYY() //  [R1]
         { info_tbl: [(c4mYY,
                       label: block_c4mYY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mYY: // global
           I64[Sp - 8] = block_c4mZ4_info;
           _s4l9n::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4l9n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mZx; else goto c4mZ5;
       u4mZx: // global
           call _c4mZ4(R1) args: 0, res: 0, upd: 0;
       c4mZ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mZ4() //  [R1]
         { info_tbl: [(c4mZ4,
                       label: block_c4mZ4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mZ4: // global
           I64[Sp] = block_c4mZ9_info;
           _s4l9p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4l9p::I64;
           if (R1 & 7 != 0) goto u4mZz; else goto c4mZe;
       u4mZz: // global
           call _c4mZ9(R1) args: 0, res: 0, upd: 0;
       c4mZe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mZ9() //  [R1]
         { info_tbl: [(c4mZ9,
                       label: block_c4mZ9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mZ9: // global
           _s4l9r::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4l9r::I64)) goto c4mZm; else goto c4mZq;
       c4mZm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mZq: // global
           _s4l9n::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4mZp_info;
           R1 = _s4l9n::P64;
           I64[Sp + 16] = _s4l9r::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4mZA; else goto c4mZr;
       u4mZA: // global
           call _c4mZp(R1) args: 0, res: 0, upd: 0;
       c4mZr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mZp() //  [R1]
         { info_tbl: [(c4mZp,
                       label: block_c4mZp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mZp: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.848434086 UTC

[section ""data" . GHC.Int.$fNumInt7_closure" {
     GHC.Int.$fNumInt7_closure:
         const GHC.Int.I8#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.849765931 UTC

[section ""data" . GHC.Int.$fNumInt8_$csignum_closure" {
     GHC.Int.$fNumInt8_$csignum_closure:
         const GHC.Int.$fNumInt8_$csignum_info;
 },
 GHC.Int.$fNumInt8_$csignum_entry() //  [R2]
         { info_tbl: [(c4mZI,
                       label: GHC.Int.$fNumInt8_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mZI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4mZJ; else goto c4mZK;
       c4mZJ: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4mZK: // global
           I64[Sp - 8] = block_c4mZF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4mZY; else goto c4mZG;
       u4mZY: // global
           call _c4mZF(R1) args: 0, res: 0, upd: 0;
       c4mZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4mZF() //  [R1]
         { info_tbl: [(c4mZF,
                       label: block_c4mZF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4mZF: // global
           _s4l9y::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4l9y::I64, 0)) goto c4mZW; else goto c4mZX;
       c4mZW: // global
           if (_s4l9y::I64 == 0) goto c4mZU; else goto c4mZT;
       c4mZU: // global
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mZT: // global
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4mZX: // global
           R1 = GHC.Int.$fNumInt7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.85179062 UTC

[section ""data" . GHC.Int.$fNumInt8_$cabs_closure" {
     GHC.Int.$fNumInt8_$cabs_closure:
         const GHC.Int.$fNumInt8_$cabs_info;
 },
 GHC.Int.$fNumInt8_$cabs_entry() //  [R2]
         { info_tbl: [(c4n06,
                       label: GHC.Int.$fNumInt8_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n06: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4n07; else goto c4n08;
       c4n07: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4n08: // global
           I64[Sp - 8] = block_c4n03_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4n0r; else goto c4n04;
       u4n0r: // global
           call _c4n03(R1) args: 0, res: 0, upd: 0;
       c4n04: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n03() //  [R1]
         { info_tbl: [(c4n03,
                       label: block_c4n03_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n03: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n0d; else goto c4n0c;
       c4n0d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4n0c: // global
           _s4l9D::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l9D::I64, 0)) goto c4n0p; else goto c4n0q;
       c4n0p: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-_s4l9D::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4n0q: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.853642571 UTC

[section ""data" . GHC.Int.$fNumInt8_closure" {
     GHC.Int.$fNumInt8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt8_$c+_closure+2;
         const GHC.Int.$fNumInt8_$c-_closure+2;
         const GHC.Int.$fNumInt8_$c*_closure+2;
         const GHC.Int.$fNumInt8_$cnegate_closure+1;
         const GHC.Int.$fNumInt8_$cabs_closure+1;
         const GHC.Int.$fNumInt8_$csignum_closure+1;
         const GHC.Int.$fNumInt8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.854562343 UTC

[section ""data" . GHC.Int.$fBitsInt12_closure" {
     GHC.Int.$fBitsInt12_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt11_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.855513112 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt8_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4n0w,
                       label: GHC.Int.$fBitsInt8_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n0w: // global
           R1 = GHC.Int.$fBitsInt12_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.856938609 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbit_closure" {
     GHC.Int.$fBitsInt8_$cbit_closure:
         const GHC.Int.$fBitsInt8_$cbit_info;
 },
 GHC.Int.$fBitsInt8_$cbit_entry() //  [R2]
         { info_tbl: [(c4n0G,
                       label: GHC.Int.$fBitsInt8_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n0G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4n0H; else goto c4n0I;
       c4n0H: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4n0I: // global
           I64[Sp - 8] = block_c4n0D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4n11; else goto c4n0E;
       u4n11: // global
           call _c4n0D(R1) args: 0, res: 0, upd: 0;
       c4n0E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n0D() //  [R1]
         { info_tbl: [(c4n0D,
                       label: block_c4n0D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n0D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n0N; else goto c4n0M;
       c4n0N: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4n0M: // global
           _s4l9K::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l9K::I64, 64)) goto c4n0Z; else goto c4n10;
       c4n0Z: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4l9K::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4n10: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.859343859 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ctestBit_closure" {
     GHC.Int.$fBitsInt8_$ctestBit_closure:
         const GHC.Int.$fBitsInt8_$ctestBit_info;
 },
 GHC.Int.$fBitsInt8_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4n19,
                       label: GHC.Int.$fBitsInt8_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n19: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4n1d; else goto c4n1e;
       c4n1d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n1e: // global
           I64[Sp - 16] = block_c4n16_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4n1W; else goto c4n17;
       u4n1W: // global
           call _c4n16(R1) args: 0, res: 0, upd: 0;
       c4n17: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n16() //  [R1]
         { info_tbl: [(c4n16,
                       label: block_c4n16_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n16: // global
           I64[Sp] = block_c4n1c_info;
           _s4l9R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l9R::I64;
           if (R1 & 7 != 0) goto u4n1V; else goto c4n1g;
       u4n1V: // global
           call _c4n1c(R1) args: 0, res: 0, upd: 0;
       c4n1g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n1c() //  [R1]
         { info_tbl: [(c4n1c,
                       label: block_c4n1c_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n1c: // global
           _s4l9T::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4l9T::I64, 64)) goto c4n1U; else goto c4n1T;
       c4n1T: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4l9T::I64)) == 0) goto c4n1U; else goto c4n1I;
       c4n1U: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4n1I: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.863684664 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateR_closure" {
     GHC.Int.$fBitsInt8_$crotateR_closure:
         const GHC.Int.$fBitsInt8_$crotateR_info;
 },
 GHC.Int.$fBitsInt8_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4n24,
                       label: GHC.Int.$fBitsInt8_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n24: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4n28; else goto c4n29;
       c4n28: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n29: // global
           I64[Sp - 16] = block_c4n21_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4n38; else goto c4n22;
       u4n38: // global
           call _c4n21(R1) args: 0, res: 0, upd: 0;
       c4n22: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n21() //  [R1]
         { info_tbl: [(c4n21,
                       label: block_c4n21_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n21: // global
           I64[Sp - 8] = block_c4n27_info;
           _s4la3::P64 = R1;
           _s4la4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4la4::I64;
           P64[Sp + 8] = _s4la3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4n37; else goto c4n2b;
       u4n37: // global
           call _c4n27(R1) args: 0, res: 0, upd: 0;
       c4n2b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n27() //  [R1]
         { info_tbl: [(c4n27,
                       label: block_c4n27_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n27: // global
           _s4laa::I64 = -I64[R1 + 7] & 7;
           if (_s4laa::I64 != 0) goto u4n35; else goto c4n31;
       u4n35: // global
           I64[Sp + 16] = _s4laa::I64;
           Sp = Sp + 8;
           call _c4n2t() args: 0, res: 0, upd: 0;
       c4n31: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4n2t() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n2t: // global
           Hp = Hp + 16;
           _s4laa::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4n2Y; else goto c4n2X;
       c4n2Y: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4n2s_info;
           R1 = _s4laa::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4n2X: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4lab::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4lab::I64 << _s4laa::I64) | (_s4lab::I64 >> 8 - _s4laa::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4n2s() //  [R1]
         { info_tbl: [(c4n2s,
                       label: block_c4n2s_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n2s: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4n2t() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.866828567 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt8_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt8_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt8_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4n3i,
                       label: GHC.Int.$fBitsInt8_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n3i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4n3m; else goto c4n3n;
       c4n3m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n3n: // global
           I64[Sp - 16] = block_c4n3f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4n3W; else goto c4n3g;
       u4n3W: // global
           call _c4n3f(R1) args: 0, res: 0, upd: 0;
       c4n3g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n3f() //  [R1]
         { info_tbl: [(c4n3f,
                       label: block_c4n3f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n3f: // global
           I64[Sp - 8] = block_c4n3l_info;
           _s4lal::P64 = R1;
           _s4lam::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lam::I64;
           P64[Sp + 8] = _s4lal::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4n3V; else goto c4n3p;
       u4n3V: // global
           call _c4n3l(R1) args: 0, res: 0, upd: 0;
       c4n3p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n3l() //  [R1]
         { info_tbl: [(c4n3l,
                       label: block_c4n3l_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n3l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n3v; else goto c4n3u;
       c4n3v: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4n3u: // global
           _s4lao::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lao::I64, 64)) goto c4n3T; else goto c4n3U;
       c4n3T: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4lao::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4n3U: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.86980248 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cclearBit_closure" {
     GHC.Int.$fBitsInt8_$cclearBit_closure:
         const GHC.Int.$fBitsInt8_$cclearBit_info;
 },
 GHC.Int.$fBitsInt8_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4n44,
                       label: GHC.Int.$fBitsInt8_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n44: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4n48; else goto c4n49;
       c4n48: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n49: // global
           I64[Sp - 16] = block_c4n41_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4n4W; else goto c4n42;
       u4n4W: // global
           call _c4n41(R1) args: 0, res: 0, upd: 0;
       c4n42: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n41() //  [R1]
         { info_tbl: [(c4n41,
                       label: block_c4n41_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n41: // global
           I64[Sp] = block_c4n47_info;
           _s4laz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4laz::I64;
           if (R1 & 7 != 0) goto u4n4V; else goto c4n4b;
       u4n4V: // global
           call _c4n47(R1) args: 0, res: 0, upd: 0;
       c4n4b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n47() //  [R1]
         { info_tbl: [(c4n47,
                       label: block_c4n47_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n47: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n4h; else goto c4n4g;
       c4n4h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4n4g: // global
           _s4laz::I64 = I64[Sp + 8];
           _s4laB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4laB::I64, 64)) goto c4n4I; else goto c4n4U;
       c4n4I: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4laz::I64 & ~%MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4laB::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4n4U: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4laz::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.872451771 UTC

[section ""data" . GHC.Int.$fBitsInt8_$csetBit_closure" {
     GHC.Int.$fBitsInt8_$csetBit_closure:
         const GHC.Int.$fBitsInt8_$csetBit_info;
 },
 GHC.Int.$fBitsInt8_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4n54,
                       label: GHC.Int.$fBitsInt8_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n54: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4n58; else goto c4n59;
       c4n58: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n59: // global
           I64[Sp - 16] = block_c4n51_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4n5I; else goto c4n52;
       u4n5I: // global
           call _c4n51(R1) args: 0, res: 0, upd: 0;
       c4n52: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n51() //  [R1]
         { info_tbl: [(c4n51,
                       label: block_c4n51_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n51: // global
           I64[Sp - 8] = block_c4n57_info;
           _s4laP::P64 = R1;
           _s4laQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4laQ::I64;
           P64[Sp + 8] = _s4laP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4n5H; else goto c4n5b;
       u4n5H: // global
           call _c4n57(R1) args: 0, res: 0, upd: 0;
       c4n5b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n57() //  [R1]
         { info_tbl: [(c4n57,
                       label: block_c4n57_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n57: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n5h; else goto c4n5g;
       c4n5h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4n5g: // global
           _s4laS::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4laS::I64, 64)) goto c4n5F; else goto c4n5G;
       c4n5F: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4laS::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4n5G: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.874656842 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateL_closure" {
     GHC.Int.$fBitsInt8_$crotateL_closure:
         const GHC.Int.$fBitsInt8_$crotateL_info;
 },
 GHC.Int.$fBitsInt8_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4n5N,
                       label: GHC.Int.$fBitsInt8_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n5N: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt8_$crotate_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.875632066 UTC

[section ""data" . GHC.Int.$fBitsInt8_closure" {
     GHC.Int.$fBitsInt8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fBitsInt8_$c.&._closure+2;
         const GHC.Int.$fBitsInt8_$c.|._closure+2;
         const GHC.Int.$fBitsInt8_$cxor_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt8_$cshift_closure+2;
         const GHC.Int.$fBitsInt8_$crotate_closure+2;
         const GHC.Int.$fBitsInt13_closure+1;
         const GHC.Int.$fBitsInt8_$cbit_closure+1;
         const GHC.Int.$fBitsInt8_$csetBit_closure+2;
         const GHC.Int.$fBitsInt8_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt8_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt8_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt8_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt8_$crotateL_closure+2;
         const GHC.Int.$fBitsInt8_$crotateR_closure+2;
         const GHC.Int.$fBitsInt8_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.876672406 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_closure" {
     GHC.Int.$fFiniteBitsInt8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt8_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.87866404 UTC

[section ""data" . GHC.Int.$fReadInt8_go_closure" {
     GHC.Int.$fReadInt8_go_closure:
         const GHC.Int.$fReadInt8_go_info;
 },
 sat_s4lbc_entry() //  [R1]
         { info_tbl: [(c4n69,
                       label: sat_s4lbc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n69: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4n6a; else goto c4n6b;
       c4n6a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4n6b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lba_entry() //  [R1]
         { info_tbl: [(c4n6j,
                       label: sat_s4lba_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n6j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4n6q; else goto c4n6r;
       c4n6q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4n6r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4n6g_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4n6v; else goto c4n6h;
       u4n6v: // global
           call _c4n6g(R1) args: 0, res: 0, upd: 0;
       c4n6h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4n6g() //  [R1]
         { info_tbl: [(c4n6g,
                       label: block_c4n6g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n6g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n6u; else goto c4n6t;
       c4n6u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4n6t: // global
           _s4lb9::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4lb9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt8_go_entry() //  [R2]
         { info_tbl: [(c4n6A,
                       label: GHC.Int.$fReadInt8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n6A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4n6B; else goto c4n6C;
       c4n6B: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4n6C: // global
           I64[Sp - 8] = block_c4n5U_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4n6M; else goto c4n5V;
       u4n6M: // global
           call _c4n5U(R1) args: 0, res: 0, upd: 0;
       c4n5V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n5U() //  [R1]
         { info_tbl: [(c4n5U,
                       label: block_c4n5U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n5U: // global
           if (R1 & 7 == 1) goto c4n6x; else goto c4n6y;
       c4n6x: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4n6y: // global
           I64[Sp - 8] = block_c4n60_info;
           _s4lb3::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lb3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4n6L; else goto c4n61;
       u4n6L: // global
           call _c4n60(R1) args: 0, res: 0, upd: 0;
       c4n61: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n60() //  [R1]
         { info_tbl: [(c4n60,
                       label: block_c4n60_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n60: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4n6K; else goto c4n6J;
       c4n6K: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4n6J: // global
           _s4lb5::P64 = P64[R1 + 7];
           _s4lb6::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lbc_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lba_info;
           P64[Hp - 48] = _s4lb5::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lb6::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.882319819 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadsPrec_closure" {
     GHC.Int.$fReadInt8_$creadsPrec_closure:
         const GHC.Int.$fReadInt8_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4n6T,
                       label: GHC.Int.$fReadInt8_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n6T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4n6X; else goto c4n6Y;
       c4n6X: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n6Y: // global
           I64[Sp - 16] = block_c4n6R_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lbe::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lbe::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4n6R() //  [R1]
         { info_tbl: [(c4n6R,
                       label: block_c4n6R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n6R: // global
           _s4lbe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4n6W_info;
           R3 = _s4lbe::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4n6W() //  [R1]
         { info_tbl: [(c4n6W,
                       label: block_c4n6W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n6W: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.884453933 UTC

[section ""data" . GHC.Int.$fReadInt13_closure" {
     GHC.Int.$fReadInt13_closure:
         const GHC.Int.$fReadInt13_info;
         const 0;
 },
 sat_s4lbj_entry() //  [R1, R2]
         { info_tbl: [(c4n7d,
                       label: sat_s4lbj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n7d: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt8_$creadsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt13_entry() //  [R2, R3]
         { info_tbl: [(c4n7j,
                       label: GHC.Int.$fReadInt13_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n7j: // global
           _s4lbi::P64 = R3;
           _s4lbh::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4n7k; else goto c4n7l;
       c4n7l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n7n; else goto c4n7m;
       c4n7n: // global
           HpAlloc = 16;
           goto c4n7k;
       c4n7k: // global
           R3 = _s4lbi::P64;
           R2 = _s4lbh::P64;
           R1 = GHC.Int.$fReadInt13_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n7m: // global
           I64[Hp - 8] = sat_s4lbj_info;
           P64[Hp] = _s4lbh::P64;
           I64[Sp - 8] = block_c4n7g_info;
           R3 = _s4lbi::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4n7g() //  [R1]
         { info_tbl: [(c4n7g,
                       label: block_c4n7g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n7g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n7q; else goto c4n7p;
       c4n7q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4n7p: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.886780417 UTC

[section ""data" . GHC.Int.$fIxInt1_closure" {
     GHC.Int.$fIxInt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.887818038 UTC

[section ""data" . GHC.Int.$fReadInt12_closure" {
     GHC.Int.$fReadInt12_closure:
         const GHC.Int.$fReadInt12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt12_entry() //  [R1]
         { info_tbl: [(c4n7x,
                       label: GHC.Int.$fReadInt12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n7x: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4n7y; else goto c4n7z;
       c4n7y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4n7z: // global
           (_c4n7u::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4n7u::I64 == 0) goto c4n7w; else goto c4n7v;
       c4n7w: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4n7v: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4n7u::I64;
           R2 = GHC.Int.$fReadInt13_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.889968562 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadList_closure" {
     GHC.Int.$fReadInt8_$creadList_closure:
         const GHC.Int.$fReadInt8_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadList_entry() //  [R2]
         { info_tbl: [(c4n7E,
                       label: GHC.Int.$fReadInt8_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n7E: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.89124422 UTC

[section ""data" . GHC.Int.$fReadInt11_closure" {
     GHC.Int.$fReadInt11_closure:
         const GHC.Int.$fReadInt11_info;
         const 0;
 },
 GHC.Int.$fReadInt11_entry() //  [R2, R3]
         { info_tbl: [(c4n7O,
                       label: GHC.Int.$fReadInt11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n7O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4n7P; else goto c4n7Q;
       c4n7P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n7Q: // global
           I64[Sp - 8] = block_c4n7L_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt8_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4n7L() //  [R1]
         { info_tbl: [(c4n7L,
                       label: block_c4n7L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n7L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n7T; else goto c4n7S;
       c4n7T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4n7S: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.892741561 UTC

[section ""data" . GHC.Int.$fReadInt8_closure" {
     GHC.Int.$fReadInt8_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt8_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt8_$creadList_closure+1;
         const GHC.Int.$fReadInt13_closure+2;
         const GHC.Int.$fReadInt11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.894735395 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquot_closure" {
     GHC.Int.$fIntegralInt8_$cquot_closure:
         const GHC.Int.$fIntegralInt8_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4n81,
                       label: GHC.Int.$fIntegralInt8_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n81: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4n85; else goto c4n86;
       c4n85: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n86: // global
           I64[Sp - 16] = block_c4n7Y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4n8H; else goto c4n7Z;
       u4n8H: // global
           call _c4n7Y(R1) args: 0, res: 0, upd: 0;
       c4n7Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n7Y() //  [R1]
         { info_tbl: [(c4n7Y,
                       label: block_c4n7Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n7Y: // global
           I64[Sp] = block_c4n84_info;
           _s4lbt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbt::I64;
           if (R1 & 7 != 0) goto u4n8G; else goto c4n88;
       u4n8G: // global
           call _c4n84(R1) args: 0, res: 0, upd: 0;
       c4n88: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n84() //  [R1]
         { info_tbl: [(c4n84,
                       label: block_c4n84_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n84: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n8e; else goto c4n8d;
       c4n8e: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4n8d: // global
           _s4lbt::I64 = I64[Sp + 8];
           _s4lbw::I64 = I64[R1 + 7];
           if (_s4lbw::I64 != (-1)) goto u4n8F; else goto c4n8D;
       u4n8F: // global
           if (_s4lbw::I64 != 0) goto c4n8p; else goto c4n8E;
       c4n8p: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4lbt::I64,
                                                                          _s4lbw::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4n8E: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4n8D: // global
           if (_s4lbt::I64 == (-128)) goto c4n8C; else goto c4n8B;
       c4n8C: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4n8B: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4lbt::I64,
                                                                          (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.899237768 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$crem_closure" {
     GHC.Int.$fIntegralInt8_$crem_closure:
         const GHC.Int.$fIntegralInt8_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4n8P,
                       label: GHC.Int.$fIntegralInt8_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n8P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4n8T; else goto c4n8U;
       c4n8T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n8U: // global
           I64[Sp - 16] = block_c4n8M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4n9g; else goto c4n8N;
       u4n9g: // global
           call _c4n8M(R1) args: 0, res: 0, upd: 0;
       c4n8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n8M() //  [R1]
         { info_tbl: [(c4n8M,
                       label: block_c4n8M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n8M: // global
           I64[Sp] = block_c4n8S_info;
           _s4lbH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbH::I64;
           if (R1 & 7 != 0) goto u4n9f; else goto c4n8W;
       u4n9f: // global
           call _c4n8S(R1) args: 0, res: 0, upd: 0;
       c4n8W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n8S() //  [R1]
         { info_tbl: [(c4n8S,
                       label: block_c4n8S_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n8S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4n92; else goto c4n91;
       c4n92: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4n91: // global
           _s4lbK::I64 = I64[R1 + 7];
           if (_s4lbK::I64 != 0) goto c4n9d; else goto c4n9e;
       c4n9d: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Rem_W64(I64[Sp + 8],
                                                                         _s4lbK::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4n9e: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.902067786 UTC

[section ""data" . GHC.Int.$w$cdiv3_closure" {
     GHC.Int.$w$cdiv3_closure:
         const GHC.Int.$w$cdiv3_info;
         const 0;
 },
 GHC.Int.$w$cdiv3_entry() //  [R2, R3]
         { info_tbl: [(c4n9q,
                       label: GHC.Int.$w$cdiv3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n9q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4n9r; else goto c4n9s;
       c4n9r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4n9s: // global
           if (R3 == (-1)) goto c4n9o; else goto u4n9M;
       c4n9o: // global
           if (R2 == (-128)) goto c4n9L; else goto c4n9J;
       c4n9L: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4n9J: // global
           I64[Sp - 8] = block_c4n9D_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4n9M: // global
           if (R3 == 0) goto c4n9p; else goto c4n9n;
       c4n9p: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4n9n: // global
           I64[Sp - 8] = block_c4n9u_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4n9D() //  [R1]
         { info_tbl: [(c4n9D,
                       label: block_c4n9D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n9D: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4n9u() //  [R1]
         { info_tbl: [(c4n9u,
                       label: block_c4n9u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n9u: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.904331029 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdiv_closure" {
     GHC.Int.$fIntegralInt8_$cdiv_closure:
         const GHC.Int.$fIntegralInt8_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4n9U,
                       label: GHC.Int.$fIntegralInt8_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n9U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4na7; else goto c4na8;
       c4na7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4na8: // global
           I64[Sp - 16] = block_c4n9R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4naf; else goto c4n9S;
       u4naf: // global
           call _c4n9R(R1) args: 0, res: 0, upd: 0;
       c4n9S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n9R() //  [R1]
         { info_tbl: [(c4n9R,
                       label: block_c4n9R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n9R: // global
           I64[Sp] = block_c4n9X_info;
           _s4lbY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbY::I64;
           if (R1 & 7 != 0) goto u4nae; else goto c4n9Y;
       u4nae: // global
           call _c4n9X(R1) args: 0, res: 0, upd: 0;
       c4n9Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4n9X() //  [R1]
         { info_tbl: [(c4n9X,
                       label: block_c4n9X_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4n9X: // global
           _s4lbY::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4na2_info;
           R3 = I64[R1 + 7];
           R2 = _s4lbY::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4na2() //  [R1]
         { info_tbl: [(c4na2,
                       label: block_c4na2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4na2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nad; else goto c4nac;
       c4nad: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4nac: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.907450803 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cmod_closure" {
     GHC.Int.$fIntegralInt8_$cmod_closure:
         const GHC.Int.$fIntegralInt8_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4nan,
                       label: GHC.Int.$fIntegralInt8_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nan: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nar; else goto c4nas;
       c4nar: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nas: // global
           I64[Sp - 16] = block_c4nak_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4naQ; else goto c4nal;
       u4naQ: // global
           call _c4nak(R1) args: 0, res: 0, upd: 0;
       c4nal: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nak() //  [R1]
         { info_tbl: [(c4nak,
                       label: block_c4nak_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nak: // global
           I64[Sp] = block_c4naq_info;
           _s4lc5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lc5::I64;
           if (R1 & 7 != 0) goto u4naP; else goto c4nau;
       u4naP: // global
           call _c4naq(R1) args: 0, res: 0, upd: 0;
       c4nau: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4naq() //  [R1]
         { info_tbl: [(c4naq,
                       label: block_c4naq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4naq: // global
           _s4lc8::I64 = I64[R1 + 7];
           if (_s4lc8::I64 != 0) goto c4naK; else goto c4naO;
       c4naK: // global
           _s4lc5::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4naB_info;
           R3 = _s4lc8::I64;
           R2 = _s4lc5::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4naO: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4naB() //  [R1]
         { info_tbl: [(c4naB,
                       label: block_c4naB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4naB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4naN; else goto c4naM;
       c4naN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4naM: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.91000396 UTC

[section ""data" . lvl6_r4kPx_closure" {
     lvl6_r4kPx_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt13_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.911448901 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquotRem_closure" {
     GHC.Int.$fIntegralInt8_$cquotRem_closure:
         const GHC.Int.$fIntegralInt8_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4naY,
                       label: GHC.Int.$fIntegralInt8_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4naY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nb2; else goto c4nb3;
       c4nb2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nb3: // global
           I64[Sp - 16] = block_c4naV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nbI; else goto c4naW;
       u4nbI: // global
           call _c4naV(R1) args: 0, res: 0, upd: 0;
       c4naW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4naV() //  [R1]
         { info_tbl: [(c4naV,
                       label: block_c4naV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4naV: // global
           I64[Sp] = block_c4nb1_info;
           _s4lcf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lcf::I64;
           if (R1 & 7 != 0) goto u4nbH; else goto c4nb5;
       u4nbH: // global
           call _c4nb1(R1) args: 0, res: 0, upd: 0;
       c4nb5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nb1() //  [R1]
         { info_tbl: [(c4nb1,
                       label: block_c4nb1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nb1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4nbb; else goto c4nba;
       c4nbb: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nba: // global
           _s4lcf::I64 = I64[Sp + 8];
           _s4lci::I64 = I64[R1 + 7];
           if (_s4lci::I64 != (-1)) goto u4nbG; else goto c4nbE;
       u4nbG: // global
           if (_s4lci::I64 != 0) goto c4nbo; else goto c4nbF;
       c4nbo: // global
           (_s4lck::I64, _s4lcl::I64) = call MO_S_QuotRem W64(_s4lcf::I64, _s4lci::I64);
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcl::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lck::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nbF: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nbE: // global
           if (_s4lcf::I64 == (-128)) goto c4nbD; else goto c4nbC;
       c4nbD: // global
           Hp = Hp - 56;
           R1 = lvl6_r4kPx_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nbC: // global
           (_s4lcs::I64, _s4lct::I64) = call MO_S_QuotRem W64(_s4lcf::I64, (-1));
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lct::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcs::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.914832953 UTC

[section ""data" . GHC.Int.$w$cdivMod3_closure" {
     GHC.Int.$w$cdivMod3_closure:
         const GHC.Int.$w$cdivMod3_info;
         const 0;
 },
 GHC.Int.$w$cdivMod3_entry() //  [R2, R3]
         { info_tbl: [(c4nbR,
                       label: GHC.Int.$w$cdivMod3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nbR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nbS; else goto c4nbT;
       c4nbS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nbT: // global
           if (R3 == 0) goto c4nbQ; else goto c4nbP;
       c4nbQ: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nbP: // global
           if (R3 == (-1)) goto c4nem; else goto u4nen;
       c4nem: // global
           if (R2 == (-128)) goto c4nel; else goto u4neo;
       c4nel: // global
           R2 = GHC.Int.$fBitsInt13_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4neo: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4neq;
       u4nen: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4neq;
       u4neq: // global
           call _c4nbY() args: 0, res: 0, upd: 0;
     }
 },
 _c4nbY() //  []
         { info_tbl: [(c4nbY,
                       label: block_c4nbY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nbY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4nc2; else goto c4nc1;
       c4nc2: // global
           HpAlloc = 32;
           I64[Sp] = block_c4nbY_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4nc1: // global
           _s4lcz::I64 = I64[Sp + 8];
           _s4lcB::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lcz::I64, 0)) goto c4ncV; else goto c4nec;
       c4ncV: // global
           if (%MO_S_Ge_W64(_s4lcz::I64, 0)) goto c4nci; else goto c4ncT;
       c4nci: // global
           (_s4lcG::I64, _s4lcH::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcH::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcG::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ncT: // global
           if (%MO_S_Le_W64(_s4lcB::I64, 0)) goto c4ncw; else goto c4ncS;
       c4ncw: // global
           (_s4lcO::I64, _s4lcP::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcP::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcO::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ncS: // global
           (_s4lcW::I64, _s4lcX::I64) = call MO_S_QuotRem W64(_s4lcz::I64 + 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcX::I64 + _s4lcB::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcW::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nec: // global
           if (%MO_S_Ge_W64(_s4lcB::I64, 0)) goto c4ndP; else goto c4neb;
       c4ndP: // global
           if (%MO_S_Ge_W64(_s4lcz::I64, 0)) goto c4ndc; else goto c4ndN;
       c4ndc: // global
           (_s4ld8::I64, _s4ld9::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ld9::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ld8::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ndN: // global
           if (%MO_S_Le_W64(_s4lcB::I64, 0)) goto c4ndq; else goto c4ndM;
       c4ndq: // global
           (_s4ldg::I64, _s4ldh::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldh::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldg::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ndM: // global
           (_s4ldo::I64, _s4ldp::I64) = call MO_S_QuotRem W64(_s4lcz::I64 + 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldp::I64 + _s4lcB::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldo::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4neb: // global
           (_s4ldz::I64, _s4ldA::I64) = call MO_S_QuotRem W64(_s4lcz::I64 - 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldA::I64 + _s4lcB::I64 + 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldz::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.917931127 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdivMod_closure" {
     GHC.Int.$fIntegralInt8_$cdivMod_closure:
         const GHC.Int.$fIntegralInt8_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4ney,
                       label: GHC.Int.$fIntegralInt8_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ney: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4neJ; else goto c4neK;
       c4neJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4neK: // global
           I64[Sp - 16] = block_c4nev_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4neR; else goto c4new;
       u4neR: // global
           call _c4nev(R1) args: 0, res: 0, upd: 0;
       c4new: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nev() //  [R1]
         { info_tbl: [(c4nev,
                       label: block_c4nev_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nev: // global
           I64[Sp] = block_c4neB_info;
           _s4ldO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ldO::I64;
           if (R1 & 7 != 0) goto u4neQ; else goto c4neC;
       u4neQ: // global
           call _c4neB(R1) args: 0, res: 0, upd: 0;
       c4neC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4neB() //  [R1]
         { info_tbl: [(c4neB,
                       label: block_c4neB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4neB: // global
           _s4ldO::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4neG_info;
           R3 = I64[R1 + 7];
           R2 = _s4ldO::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4neG() //  [R1, R2]
         { info_tbl: [(c4neG,
                       label: block_c4neG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4neG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4neP; else goto c4neO;
       c4neP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4neO: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.919476235 UTC

[section ""data" . sat_s4ldU_closure" {
     sat_s4ldU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.920068374 UTC

[section ""data" . sat_s4ldV_closure" {
     sat_s4ldV_closure:
         const :_con_info;
         const sat_s4ldU_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.920980945 UTC

[section ""data" . GHC.Int.$fRealInt1_closure" {
     GHC.Int.$fRealInt1_closure:
         const GHC.Int.$fRealInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fRealInt1_entry() //  [R1]
         { info_tbl: [(c4neY,
                       label: GHC.Int.$fRealInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4neY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4neZ; else goto c4nf0;
       c4neZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4nf0: // global
           (_c4neV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4neV::I64 == 0) goto c4neX; else goto c4neW;
       c4neX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4neW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4neV::I64;
           R3 = sat_s4ldV_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.922458053 UTC

[section ""data" . GHC.Int.$fRealInt8_$ctoRational_closure" {
     GHC.Int.$fRealInt8_$ctoRational_closure:
         const GHC.Int.$fRealInt8_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt8_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4nf8,
                       label: GHC.Int.$fRealInt8_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nf8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nfm; else goto c4nfn;
       c4nfm: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nfn: // global
           I64[Sp - 8] = block_c4nf5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nfu; else goto c4nf6;
       u4nfu: // global
           call _c4nf5(R1) args: 0, res: 0, upd: 0;
       c4nf6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nf5() //  [R1]
         { info_tbl: [(c4nf5,
                       label: block_c4nf5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nf5: // global
           I64[Sp] = block_c4nfb_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nfb() //  [R1]
         { info_tbl: [(c4nfb,
                       label: block_c4nfb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nfb: // global
           I64[Sp] = block_c4nff_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nff() //  [R1]
         { info_tbl: [(c4nff,
                       label: block_c4nff_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nff: // global
           I64[Sp] = block_c4nfj_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nfj() //  [R1, R2]
         { info_tbl: [(c4nfj,
                       label: block_c4nfj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nfj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4nft; else goto c4nfs;
       c4nft: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4nfs: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.92412331 UTC

[section ""data" . GHC.Int.$fRealInt8_closure" {
     GHC.Int.$fRealInt8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt8_closure+1;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fRealInt8_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.924771423 UTC

[section ""data" . GHC.Int.$fIntegralInt8_closure" {
     GHC.Int.$fIntegralInt8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt8_closure+1;
         const GHC.Int.$fEnumInt8_closure+1;
         const GHC.Int.$fIntegralInt8_$cquot_closure+2;
         const GHC.Int.$fIntegralInt8_$crem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt8_$cmod_closure+2;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt8_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.927431689 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt8_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt8_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt8_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4nfC,
                       label: GHC.Int.$fIxInt8_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nfC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nfT; else goto c4nfU;
       c4nfT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nfU: // global
           I64[Sp - 16] = block_c4nfz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ng1; else goto c4nfA;
       u4ng1: // global
           call _c4nfz(R1) args: 0, res: 0, upd: 0;
       c4nfA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nfz() //  [R1]
         { info_tbl: [(c4nfz,
                       label: block_c4nfz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nfz: // global
           I64[Sp] = block_c4nfF_info;
           _s4le7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4le7::P64;
           if (R1 & 7 != 0) goto u4ng0; else goto c4nfG;
       u4ng0: // global
           call _c4nfF(R1) args: 0, res: 0, upd: 0;
       c4nfG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nfF() //  [R1]
         { info_tbl: [(c4nfF,
                       label: block_c4nfF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nfF: // global
           I64[Sp] = block_c4nfK_info;
           _s4lea::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lea::I64;
           if (R1 & 7 != 0) goto u4ng2; else goto c4nfL;
       u4ng2: // global
           call _c4nfK(R1) args: 0, res: 0, upd: 0;
       c4nfL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nfK() //  [R1]
         { info_tbl: [(c4nfK,
                       label: block_c4nfK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nfK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nfZ; else goto c4nfY;
       c4nfZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nfY: // global
           _s4led::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4led::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.929176993 UTC

[section ""data" . GHC.Int.$fIxInt8_$crange_closure" {
     GHC.Int.$fIxInt8_$crange_closure:
         const GHC.Int.$fIxInt8_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$crange_entry() //  [R2]
         { info_tbl: [(c4nga,
                       label: GHC.Int.$fIxInt8_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nga: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ngb; else goto c4ngc;
       c4ngb: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ngc: // global
           I64[Sp - 8] = block_c4ng7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ngg; else goto c4ng8;
       u4ngg: // global
           call _c4ng7(R1) args: 0, res: 0, upd: 0;
       c4ng8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ng7() //  [R1]
         { info_tbl: [(c4ng7,
                       label: block_c4ng7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ng7: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_$cenumFromTo_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.930757092 UTC

[section ""data" . GHC.Int.$fIxInt8_$crangeSize_closure" {
     GHC.Int.$fIxInt8_$crangeSize_closure:
         const GHC.Int.$fIxInt8_$crangeSize_info;
 },
 GHC.Int.$fIxInt8_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4ngo,
                       label: GHC.Int.$fIxInt8_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ngo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ngx; else goto c4ngy;
       c4ngx: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ngy: // global
           I64[Sp - 8] = block_c4ngl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ngX; else goto c4ngm;
       u4ngX: // global
           call _c4ngl(R1) args: 0, res: 0, upd: 0;
       c4ngm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ngl() //  [R1]
         { info_tbl: [(c4ngl,
                       label: block_c4ngl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ngl: // global
           I64[Sp - 8] = block_c4ngr_info;
           _s4lel::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lel::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ngW; else goto c4ngs;
       u4ngW: // global
           call _c4ngr(R1) args: 0, res: 0, upd: 0;
       c4ngs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ngr() //  [R1]
         { info_tbl: [(c4ngr,
                       label: block_c4ngr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ngr: // global
           I64[Sp] = block_c4ngw_info;
           _s4len::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4len::I64;
           if (R1 & 7 != 0) goto u4ngY; else goto c4ngB;
       u4ngY: // global
           call _c4ngw(R1) args: 0, res: 0, upd: 0;
       c4ngB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ngw() //  [R1]
         { info_tbl: [(c4ngw,
                       label: block_c4ngw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ngw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ngH; else goto c4ngG;
       c4ngH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ngG: // global
           _s4len::I64 = I64[Sp + 8];
           _s4lep::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4len::I64,
                            _s4lep::I64)) goto c4ngL; else goto c4ngV;
       c4ngL: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ngV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lep::I64 - _s4len::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.932736245 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt8_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt8_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4nh6,
                       label: GHC.Int.$fIxInt8_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nh6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nhq; else goto c4nhr;
       c4nhq: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nhr: // global
           I64[Sp - 8] = block_c4nh3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nhy; else goto c4nh4;
       u4nhy: // global
           call _c4nh3(R1) args: 0, res: 0, upd: 0;
       c4nh4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nh3() //  [R1]
         { info_tbl: [(c4nh3,
                       label: block_c4nh3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nh3: // global
           I64[Sp - 8] = block_c4nh9_info;
           _s4lev::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lev::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nhx; else goto c4nha;
       u4nhx: // global
           call _c4nh9(R1) args: 0, res: 0, upd: 0;
       c4nha: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nh9() //  [R1]
         { info_tbl: [(c4nh9,
                       label: block_c4nh9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nh9: // global
           I64[Sp] = block_c4nhe_info;
           _s4ley::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ley::I64;
           if (R1 & 7 != 0) goto u4nhz; else goto c4nhf;
       u4nhz: // global
           call _c4nhe(R1) args: 0, res: 0, upd: 0;
       c4nhf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nhe() //  [R1]
         { info_tbl: [(c4nhe,
                       label: block_c4nhe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nhe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nhw; else goto c4nhv;
       c4nhw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nhv: // global
           _s4leC::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4leC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.934860824 UTC

[section ""data" . GHC.Int.$fIxInt8_$cindex_closure" {
     GHC.Int.$fIxInt8_$cindex_closure:
         const GHC.Int.$fIxInt8_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4nhH,
                       label: GHC.Int.$fIxInt8_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nhH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nhQ; else goto c4nhR;
       c4nhQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nhR: // global
           I64[Sp - 16] = block_c4nhE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4niq; else goto c4nhF;
       u4niq: // global
           call _c4nhE(R1) args: 0, res: 0, upd: 0;
       c4nhF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nhE() //  [R1]
         { info_tbl: [(c4nhE,
                       label: block_c4nhE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nhE: // global
           I64[Sp - 8] = block_c4nhK_info;
           _s4leH::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4leH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nip; else goto c4nhL;
       u4nip: // global
           call _c4nhK(R1) args: 0, res: 0, upd: 0;
       c4nhL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nhK() //  [R1]
         { info_tbl: [(c4nhK,
                       label: block_c4nhK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nhK: // global
           I64[Sp] = block_c4nhP_info;
           _s4leJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4leJ::I64;
           if (R1 & 7 != 0) goto u4nir; else goto c4nhU;
       u4nir: // global
           call _c4nhP(R1) args: 0, res: 0, upd: 0;
       c4nhU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nhP() //  [R1]
         { info_tbl: [(c4nhP,
                       label: block_c4nhP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nhP: // global
           _s4leL::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4leL::I64)) goto c4ni2; else goto c4ni6;
       c4ni2: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ni6: // global
           I64[Sp] = block_c4ni5_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4leL::I64;
           if (R1 & 7 != 0) goto u4nis; else goto c4ni7;
       u4nis: // global
           call _c4ni5(R1) args: 0, res: 0, upd: 0;
       c4ni7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ni5() //  [R1]
         { info_tbl: [(c4ni5,
                       label: block_c4ni5_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ni5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nid; else goto c4nic;
       c4nid: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nic: // global
           _s4leL::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4leL::I64,
                            I64[R1 + 7])) goto c4nih; else goto c4nio;
       c4nih: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4nio: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4leL::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.936819952 UTC

[section ""data" . GHC.Int.$fIxInt8_closure" {
     GHC.Int.$fIxInt8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fIxInt8_$crange_closure+1;
         const GHC.Int.$fIxInt8_$cindex_closure+2;
         const GHC.Int.$fIxInt8_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt8_$cinRange_closure+2;
         const GHC.Int.$fIxInt8_$crangeSize_closure+1;
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.937885627 UTC

[section ""data" . GHC.Int.eqInt16_closure" {
     GHC.Int.eqInt16_closure:
         const GHC.Int.eqInt16_info;
 },
 GHC.Int.eqInt16_entry() //  [R2, R3]
         { info_tbl: [(c4niA,
                       label: GHC.Int.eqInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4niA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4niE; else goto c4niF;
       c4niE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4niF: // global
           I64[Sp - 16] = block_c4nix_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4niO; else goto c4niy;
       u4niO: // global
           call _c4nix(R1) args: 0, res: 0, upd: 0;
       c4niy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nix() //  [R1]
         { info_tbl: [(c4nix,
                       label: block_c4nix_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nix: // global
           I64[Sp] = block_c4niD_info;
           _s4leU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4leU::I64;
           if (R1 & 7 != 0) goto u4niN; else goto c4niH;
       u4niN: // global
           call _c4niD(R1) args: 0, res: 0, upd: 0;
       c4niH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4niD() //  [R1]
         { info_tbl: [(c4niD,
                       label: block_c4niD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4niD: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.93913628 UTC

[section ""data" . GHC.Int.$fEqInt16_closure" {
     GHC.Int.$fEqInt16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt16_closure+2;
         const GHC.Int.neInt16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.940089344 UTC

[section ""data" . GHC.Int.gtInt16_closure" {
     GHC.Int.gtInt16_closure:
         const GHC.Int.gtInt16_info;
 },
 GHC.Int.gtInt16_entry() //  [R2, R3]
         { info_tbl: [(c4niW,
                       label: GHC.Int.gtInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4niW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nj0; else goto c4nj1;
       c4nj0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nj1: // global
           I64[Sp - 16] = block_c4niT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nja; else goto c4niU;
       u4nja: // global
           call _c4niT(R1) args: 0, res: 0, upd: 0;
       c4niU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4niT() //  [R1]
         { info_tbl: [(c4niT,
                       label: block_c4niT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4niT: // global
           I64[Sp] = block_c4niZ_info;
           _s4lf1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lf1::I64;
           if (R1 & 7 != 0) goto u4nj9; else goto c4nj3;
       u4nj9: // global
           call _c4niZ(R1) args: 0, res: 0, upd: 0;
       c4nj3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4niZ() //  [R1]
         { info_tbl: [(c4niZ,
                       label: block_c4niZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4niZ: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.941743923 UTC

[section ""data" . GHC.Int.geInt16_closure" {
     GHC.Int.geInt16_closure:
         const GHC.Int.geInt16_info;
 },
 GHC.Int.geInt16_entry() //  [R2, R3]
         { info_tbl: [(c4nji,
                       label: GHC.Int.geInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nji: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4njm; else goto c4njn;
       c4njm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4njn: // global
           I64[Sp - 16] = block_c4njf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4njw; else goto c4njg;
       u4njw: // global
           call _c4njf(R1) args: 0, res: 0, upd: 0;
       c4njg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4njf() //  [R1]
         { info_tbl: [(c4njf,
                       label: block_c4njf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4njf: // global
           I64[Sp] = block_c4njl_info;
           _s4lf8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lf8::I64;
           if (R1 & 7 != 0) goto u4njv; else goto c4njp;
       u4njv: // global
           call _c4njl(R1) args: 0, res: 0, upd: 0;
       c4njp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4njl() //  [R1]
         { info_tbl: [(c4njl,
                       label: block_c4njl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4njl: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.943292646 UTC

[section ""data" . GHC.Int.ltInt16_closure" {
     GHC.Int.ltInt16_closure:
         const GHC.Int.ltInt16_info;
 },
 GHC.Int.ltInt16_entry() //  [R2, R3]
         { info_tbl: [(c4njE,
                       label: GHC.Int.ltInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4njE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4njI; else goto c4njJ;
       c4njI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4njJ: // global
           I64[Sp - 16] = block_c4njB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4njS; else goto c4njC;
       u4njS: // global
           call _c4njB(R1) args: 0, res: 0, upd: 0;
       c4njC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4njB() //  [R1]
         { info_tbl: [(c4njB,
                       label: block_c4njB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4njB: // global
           I64[Sp] = block_c4njH_info;
           _s4lff::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lff::I64;
           if (R1 & 7 != 0) goto u4njR; else goto c4njL;
       u4njR: // global
           call _c4njH(R1) args: 0, res: 0, upd: 0;
       c4njL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4njH() //  [R1]
         { info_tbl: [(c4njH,
                       label: block_c4njH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4njH: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.944946286 UTC

[section ""data" . GHC.Int.leInt16_closure" {
     GHC.Int.leInt16_closure:
         const GHC.Int.leInt16_info;
 },
 GHC.Int.leInt16_entry() //  [R2, R3]
         { info_tbl: [(c4nk0,
                       label: GHC.Int.leInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nk0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nk4; else goto c4nk5;
       c4nk4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nk5: // global
           I64[Sp - 16] = block_c4njX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nke; else goto c4njY;
       u4nke: // global
           call _c4njX(R1) args: 0, res: 0, upd: 0;
       c4njY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4njX() //  [R1]
         { info_tbl: [(c4njX,
                       label: block_c4njX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4njX: // global
           I64[Sp] = block_c4nk3_info;
           _s4lfm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lfm::I64;
           if (R1 & 7 != 0) goto u4nkd; else goto c4nk7;
       u4nkd: // global
           call _c4nk3(R1) args: 0, res: 0, upd: 0;
       c4nk7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nk3() //  [R1]
         { info_tbl: [(c4nk3,
                       label: block_c4nk3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nk3: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.946680672 UTC

[section ""data" . GHC.Int.$fOrdInt16_$ccompare_closure" {
     GHC.Int.$fOrdInt16_$ccompare_closure:
         const GHC.Int.$fOrdInt16_$ccompare_info;
 },
 GHC.Int.$fOrdInt16_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4nkm,
                       label: GHC.Int.$fOrdInt16_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nkm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nkq; else goto c4nkr;
       c4nkq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nkr: // global
           I64[Sp - 16] = block_c4nkj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nkK; else goto c4nkk;
       u4nkK: // global
           call _c4nkj(R1) args: 0, res: 0, upd: 0;
       c4nkk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nkj() //  [R1]
         { info_tbl: [(c4nkj,
                       label: block_c4nkj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nkj: // global
           I64[Sp] = block_c4nkp_info;
           _s4lft::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lft::I64;
           if (R1 & 7 != 0) goto u4nkJ; else goto c4nkt;
       u4nkJ: // global
           call _c4nkp(R1) args: 0, res: 0, upd: 0;
       c4nkt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nkp() //  [R1]
         { info_tbl: [(c4nkp,
                       label: block_c4nkp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nkp: // global
           _s4lft::I64 = I64[Sp + 8];
           _s4lfv::I64 = I64[R1 + 7];
           if (_s4lft::I64 == _s4lfv::I64) goto c4nkI; else goto c4nkH;
       c4nkI: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nkH: // global
           if (%MO_S_Gt_W64(_s4lft::I64,
                            _s4lfv::I64)) goto c4nkE; else goto c4nkF;
       c4nkE: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nkF: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.948482494 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmax_closure" {
     GHC.Int.$fOrdInt16_$cmax_closure:
         const GHC.Int.$fOrdInt16_$cmax_info;
 },
 GHC.Int.$fOrdInt16_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4nkS,
                       label: GHC.Int.$fOrdInt16_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nkS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nkW; else goto c4nkX;
       c4nkW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nkX: // global
           I64[Sp - 16] = block_c4nkP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nla; else goto c4nkQ;
       u4nla: // global
           call _c4nkP(R1) args: 0, res: 0, upd: 0;
       c4nkQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nkP() //  [R1]
         { info_tbl: [(c4nkP,
                       label: block_c4nkP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nkP: // global
           I64[Sp - 8] = block_c4nkV_info;
           _s4lfA::P64 = R1;
           _s4lfB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lfB::I64;
           P64[Sp + 8] = _s4lfA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nl9; else goto c4nkZ;
       u4nl9: // global
           call _c4nkV(R1) args: 0, res: 0, upd: 0;
       c4nkZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nkV() //  [R1]
         { info_tbl: [(c4nkV,
                       label: block_c4nkV_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nkV: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4nl7; else goto c4nl8;
       c4nl7: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4nl8: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.951374858 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmin_closure" {
     GHC.Int.$fOrdInt16_$cmin_closure:
         const GHC.Int.$fOrdInt16_$cmin_info;
 },
 GHC.Int.$fOrdInt16_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4nli,
                       label: GHC.Int.$fOrdInt16_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nli: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nlm; else goto c4nln;
       c4nlm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nln: // global
           I64[Sp - 16] = block_c4nlf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nlA; else goto c4nlg;
       u4nlA: // global
           call _c4nlf(R1) args: 0, res: 0, upd: 0;
       c4nlg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nlf() //  [R1]
         { info_tbl: [(c4nlf,
                       label: block_c4nlf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nlf: // global
           I64[Sp - 8] = block_c4nll_info;
           _s4lfH::P64 = R1;
           _s4lfI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lfI::I64;
           P64[Sp + 8] = _s4lfH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nlz; else goto c4nlp;
       u4nlz: // global
           call _c4nll(R1) args: 0, res: 0, upd: 0;
       c4nlp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nll() //  [R1]
         { info_tbl: [(c4nll,
                       label: block_c4nll_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nll: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4nlx; else goto c4nly;
       c4nlx: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4nly: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.952767696 UTC

[section ""data" . GHC.Int.$fOrdInt16_closure" {
     GHC.Int.$fOrdInt16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fOrdInt16_$ccompare_closure+2;
         const GHC.Int.ltInt16_closure+2;
         const GHC.Int.leInt16_closure+2;
         const GHC.Int.gtInt16_closure+2;
         const GHC.Int.geInt16_closure+2;
         const GHC.Int.$fOrdInt16_$cmax_closure+2;
         const GHC.Int.$fOrdInt16_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.95402975 UTC

[section ""data" . GHC.Int.$fIxInt16_$cinRange_closure" {
     GHC.Int.$fIxInt16_$cinRange_closure:
         const GHC.Int.$fIxInt16_$cinRange_info;
 },
 GHC.Int.$fIxInt16_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4nlI,
                       label: GHC.Int.$fIxInt16_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nlI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nlR; else goto c4nlS;
       c4nlR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nlS: // global
           I64[Sp - 16] = block_c4nlF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nmf; else goto c4nlG;
       u4nmf: // global
           call _c4nlF(R1) args: 0, res: 0, upd: 0;
       c4nlG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nlF() //  [R1]
         { info_tbl: [(c4nlF,
                       label: block_c4nlF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nlF: // global
           I64[Sp - 8] = block_c4nlL_info;
           _s4lfQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lfQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nme; else goto c4nlM;
       u4nme: // global
           call _c4nlL(R1) args: 0, res: 0, upd: 0;
       c4nlM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nlL() //  [R1]
         { info_tbl: [(c4nlL,
                       label: block_c4nlL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nlL: // global
           I64[Sp] = block_c4nlQ_info;
           _s4lfS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lfS::I64;
           if (R1 & 7 != 0) goto u4nmg; else goto c4nlV;
       u4nmg: // global
           call _c4nlQ(R1) args: 0, res: 0, upd: 0;
       c4nlV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nlQ() //  [R1]
         { info_tbl: [(c4nlQ,
                       label: block_c4nlQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nlQ: // global
           _s4lfU::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lfU::I64)) goto c4nm3; else goto c4nm7;
       c4nm3: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nm7: // global
           _s4lfQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4nm6_info;
           R1 = _s4lfQ::P64;
           I64[Sp + 16] = _s4lfU::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4nmh; else goto c4nm8;
       u4nmh: // global
           call _c4nm6(R1) args: 0, res: 0, upd: 0;
       c4nm8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nm6() //  [R1]
         { info_tbl: [(c4nm6,
                       label: block_c4nm6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nm6: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.955761312 UTC

[section ""data" . GHC.Int.$fNumInt1_closure" {
     GHC.Int.$fNumInt1_closure:
         const GHC.Int.I16#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.956716682 UTC

[section ""data" . GHC.Int.$fNumInt16_$csignum_closure" {
     GHC.Int.$fNumInt16_$csignum_closure:
         const GHC.Int.$fNumInt16_$csignum_info;
 },
 GHC.Int.$fNumInt16_$csignum_entry() //  [R2]
         { info_tbl: [(c4nmp,
                       label: GHC.Int.$fNumInt16_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nmp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nmq; else goto c4nmr;
       c4nmq: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nmr: // global
           I64[Sp - 8] = block_c4nmm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nmF; else goto c4nmn;
       u4nmF: // global
           call _c4nmm(R1) args: 0, res: 0, upd: 0;
       c4nmn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nmm() //  [R1]
         { info_tbl: [(c4nmm,
                       label: block_c4nmm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nmm: // global
           _s4lg1::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lg1::I64, 0)) goto c4nmD; else goto c4nmE;
       c4nmD: // global
           if (_s4lg1::I64 == 0) goto c4nmB; else goto c4nmA;
       c4nmB: // global
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nmA: // global
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nmE: // global
           R1 = GHC.Int.$fNumInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.958523739 UTC

[section ""data" . GHC.Int.$fNumInt16_$cabs_closure" {
     GHC.Int.$fNumInt16_$cabs_closure:
         const GHC.Int.$fNumInt16_$cabs_info;
 },
 GHC.Int.$fNumInt16_$cabs_entry() //  [R2]
         { info_tbl: [(c4nmN,
                       label: GHC.Int.$fNumInt16_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nmN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nmO; else goto c4nmP;
       c4nmO: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nmP: // global
           I64[Sp - 8] = block_c4nmK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nn8; else goto c4nmL;
       u4nn8: // global
           call _c4nmK(R1) args: 0, res: 0, upd: 0;
       c4nmL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nmK() //  [R1]
         { info_tbl: [(c4nmK,
                       label: block_c4nmK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nmK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nmU; else goto c4nmT;
       c4nmU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nmT: // global
           _s4lg6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lg6::I64, 0)) goto c4nn6; else goto c4nn7;
       c4nn6: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-_s4lg6::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nn7: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.959704524 UTC

[section ""data" . GHC.Int.$fNumInt16_closure" {
     GHC.Int.$fNumInt16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt16_$c+_closure+2;
         const GHC.Int.$fNumInt16_$c-_closure+2;
         const GHC.Int.$fNumInt16_$c*_closure+2;
         const GHC.Int.$fNumInt16_$cnegate_closure+1;
         const GHC.Int.$fNumInt16_$cabs_closure+1;
         const GHC.Int.$fNumInt16_$csignum_closure+1;
         const GHC.Int.$fNumInt16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.960357283 UTC

[section ""data" . GHC.Int.$fBitsInt2_closure" {
     GHC.Int.$fBitsInt2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.96112002 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt16_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4nnd,
                       label: GHC.Int.$fBitsInt16_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nnd: // global
           R1 = GHC.Int.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.962272511 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbit_closure" {
     GHC.Int.$fBitsInt16_$cbit_closure:
         const GHC.Int.$fBitsInt16_$cbit_info;
 },
 GHC.Int.$fBitsInt16_$cbit_entry() //  [R2]
         { info_tbl: [(c4nnn,
                       label: GHC.Int.$fBitsInt16_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nnn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nno; else goto c4nnp;
       c4nno: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nnp: // global
           I64[Sp - 8] = block_c4nnk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nnI; else goto c4nnl;
       u4nnI: // global
           call _c4nnk(R1) args: 0, res: 0, upd: 0;
       c4nnl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nnk() //  [R1]
         { info_tbl: [(c4nnk,
                       label: block_c4nnk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nnk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nnu; else goto c4nnt;
       c4nnu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nnt: // global
           _s4lgd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lgd::I64, 64)) goto c4nnG; else goto c4nnH;
       c4nnG: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgd::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nnH: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.964003205 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ctestBit_closure" {
     GHC.Int.$fBitsInt16_$ctestBit_closure:
         const GHC.Int.$fBitsInt16_$ctestBit_info;
 },
 GHC.Int.$fBitsInt16_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4nnQ,
                       label: GHC.Int.$fBitsInt16_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nnQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nnU; else goto c4nnV;
       c4nnU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nnV: // global
           I64[Sp - 16] = block_c4nnN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4noD; else goto c4nnO;
       u4noD: // global
           call _c4nnN(R1) args: 0, res: 0, upd: 0;
       c4nnO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nnN() //  [R1]
         { info_tbl: [(c4nnN,
                       label: block_c4nnN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nnN: // global
           I64[Sp] = block_c4nnT_info;
           _s4lgk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lgk::I64;
           if (R1 & 7 != 0) goto u4noC; else goto c4nnX;
       u4noC: // global
           call _c4nnT(R1) args: 0, res: 0, upd: 0;
       c4nnX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nnT() //  [R1]
         { info_tbl: [(c4nnT,
                       label: block_c4nnT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nnT: // global
           _s4lgm::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4lgm::I64, 64)) goto c4noB; else goto c4noA;
       c4noA: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgm::I64)) == 0) goto c4noB; else goto c4nop;
       c4noB: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nop: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.966097291 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateR_closure" {
     GHC.Int.$fBitsInt16_$crotateR_closure:
         const GHC.Int.$fBitsInt16_$crotateR_info;
 },
 GHC.Int.$fBitsInt16_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4noL,
                       label: GHC.Int.$fBitsInt16_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4noL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4noP; else goto c4noQ;
       c4noP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4noQ: // global
           I64[Sp - 16] = block_c4noI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4npP; else goto c4noJ;
       u4npP: // global
           call _c4noI(R1) args: 0, res: 0, upd: 0;
       c4noJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4noI() //  [R1]
         { info_tbl: [(c4noI,
                       label: block_c4noI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4noI: // global
           I64[Sp - 8] = block_c4noO_info;
           _s4lgw::P64 = R1;
           _s4lgx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lgx::I64;
           P64[Sp + 8] = _s4lgw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4npO; else goto c4noS;
       u4npO: // global
           call _c4noO(R1) args: 0, res: 0, upd: 0;
       c4noS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4noO() //  [R1]
         { info_tbl: [(c4noO,
                       label: block_c4noO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4noO: // global
           _s4lgD::I64 = -I64[R1 + 7] & 15;
           if (_s4lgD::I64 != 0) goto u4npM; else goto c4npI;
       u4npM: // global
           I64[Sp + 16] = _s4lgD::I64;
           Sp = Sp + 8;
           call _c4npa() args: 0, res: 0, upd: 0;
       c4npI: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4npa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4npa: // global
           Hp = Hp + 16;
           _s4lgD::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4npF; else goto c4npE;
       c4npF: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4np9_info;
           R1 = _s4lgD::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4npE: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4lgE::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4lgE::I64 << _s4lgD::I64) | (_s4lgE::I64 >> 16 - _s4lgD::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4np9() //  [R1]
         { info_tbl: [(c4np9,
                       label: block_c4np9_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4np9: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4npa() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.968419257 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt16_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt16_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt16_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4npZ,
                       label: GHC.Int.$fBitsInt16_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4npZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nq3; else goto c4nq4;
       c4nq3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nq4: // global
           I64[Sp - 16] = block_c4npW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nqD; else goto c4npX;
       u4nqD: // global
           call _c4npW(R1) args: 0, res: 0, upd: 0;
       c4npX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4npW() //  [R1]
         { info_tbl: [(c4npW,
                       label: block_c4npW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4npW: // global
           I64[Sp - 8] = block_c4nq2_info;
           _s4lgO::P64 = R1;
           _s4lgP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lgP::I64;
           P64[Sp + 8] = _s4lgO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nqC; else goto c4nq6;
       u4nqC: // global
           call _c4nq2(R1) args: 0, res: 0, upd: 0;
       c4nq6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nq2() //  [R1]
         { info_tbl: [(c4nq2,
                       label: block_c4nq2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nq2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nqc; else goto c4nqb;
       c4nqc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nqb: // global
           _s4lgR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lgR::I64, 64)) goto c4nqA; else goto c4nqB;
       c4nqA: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgR::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nqB: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.970736097 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cclearBit_closure" {
     GHC.Int.$fBitsInt16_$cclearBit_closure:
         const GHC.Int.$fBitsInt16_$cclearBit_info;
 },
 GHC.Int.$fBitsInt16_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4nqL,
                       label: GHC.Int.$fBitsInt16_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nqL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nqP; else goto c4nqQ;
       c4nqP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nqQ: // global
           I64[Sp - 16] = block_c4nqI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nrD; else goto c4nqJ;
       u4nrD: // global
           call _c4nqI(R1) args: 0, res: 0, upd: 0;
       c4nqJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nqI() //  [R1]
         { info_tbl: [(c4nqI,
                       label: block_c4nqI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nqI: // global
           I64[Sp] = block_c4nqO_info;
           _s4lh2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lh2::I64;
           if (R1 & 7 != 0) goto u4nrC; else goto c4nqS;
       u4nrC: // global
           call _c4nqO(R1) args: 0, res: 0, upd: 0;
       c4nqS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nqO() //  [R1]
         { info_tbl: [(c4nqO,
                       label: block_c4nqO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nqO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nqY; else goto c4nqX;
       c4nqY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nqX: // global
           _s4lh2::I64 = I64[Sp + 8];
           _s4lh4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lh4::I64, 64)) goto c4nrp; else goto c4nrB;
       c4nrp: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lh2::I64 & ~%MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lh4::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nrB: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lh2::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.972783143 UTC

[section ""data" . GHC.Int.$fBitsInt16_$csetBit_closure" {
     GHC.Int.$fBitsInt16_$csetBit_closure:
         const GHC.Int.$fBitsInt16_$csetBit_info;
 },
 GHC.Int.$fBitsInt16_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4nrL,
                       label: GHC.Int.$fBitsInt16_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nrL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nrP; else goto c4nrQ;
       c4nrP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nrQ: // global
           I64[Sp - 16] = block_c4nrI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nsp; else goto c4nrJ;
       u4nsp: // global
           call _c4nrI(R1) args: 0, res: 0, upd: 0;
       c4nrJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nrI() //  [R1]
         { info_tbl: [(c4nrI,
                       label: block_c4nrI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nrI: // global
           I64[Sp - 8] = block_c4nrO_info;
           _s4lhi::P64 = R1;
           _s4lhj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lhj::I64;
           P64[Sp + 8] = _s4lhi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nso; else goto c4nrS;
       u4nso: // global
           call _c4nrO(R1) args: 0, res: 0, upd: 0;
       c4nrS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nrO() //  [R1]
         { info_tbl: [(c4nrO,
                       label: block_c4nrO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nrO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nrY; else goto c4nrX;
       c4nrY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nrX: // global
           _s4lhl::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lhl::I64, 64)) goto c4nsm; else goto c4nsn;
       c4nsm: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lhl::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nsn: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.975449757 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateL_closure" {
     GHC.Int.$fBitsInt16_$crotateL_closure:
         const GHC.Int.$fBitsInt16_$crotateL_info;
 },
 GHC.Int.$fBitsInt16_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4nsu,
                       label: GHC.Int.$fBitsInt16_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nsu: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt16_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.976241908 UTC

[section ""data" . GHC.Int.$fBitsInt16_closure" {
     GHC.Int.$fBitsInt16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fBitsInt16_$c.&._closure+2;
         const GHC.Int.$fBitsInt16_$c.|._closure+2;
         const GHC.Int.$fBitsInt16_$cxor_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt16_$cshift_closure+2;
         const GHC.Int.$fBitsInt16_$crotate_closure+2;
         const GHC.Int.$fBitsInt3_closure+1;
         const GHC.Int.$fBitsInt16_$cbit_closure+1;
         const GHC.Int.$fBitsInt16_$csetBit_closure+2;
         const GHC.Int.$fBitsInt16_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt16_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt16_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt16_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt16_$crotateL_closure+2;
         const GHC.Int.$fBitsInt16_$crotateR_closure+2;
         const GHC.Int.$fBitsInt16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.976947631 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_closure" {
     GHC.Int.$fFiniteBitsInt16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt16_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.978557506 UTC

[section ""data" . GHC.Int.$fReadInt16_go_closure" {
     GHC.Int.$fReadInt16_go_closure:
         const GHC.Int.$fReadInt16_go_info;
 },
 sat_s4lhF_entry() //  [R1]
         { info_tbl: [(c4nsQ,
                       label: sat_s4lhF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nsQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nsR; else goto c4nsS;
       c4nsR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4nsS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lhD_entry() //  [R1]
         { info_tbl: [(c4nt0,
                       label: sat_s4lhD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nt0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nt7; else goto c4nt8;
       c4nt7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4nt8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4nsX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4ntc; else goto c4nsY;
       u4ntc: // global
           call _c4nsX(R1) args: 0, res: 0, upd: 0;
       c4nsY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4nsX() //  [R1]
         { info_tbl: [(c4nsX,
                       label: block_c4nsX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nsX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ntb; else goto c4nta;
       c4ntb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4nta: // global
           _s4lhC::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lhC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt16_go_entry() //  [R2]
         { info_tbl: [(c4nth,
                       label: GHC.Int.$fReadInt16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nth: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nti; else goto c4ntj;
       c4nti: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ntj: // global
           I64[Sp - 8] = block_c4nsB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ntt; else goto c4nsC;
       u4ntt: // global
           call _c4nsB(R1) args: 0, res: 0, upd: 0;
       c4nsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nsB() //  [R1]
         { info_tbl: [(c4nsB,
                       label: block_c4nsB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nsB: // global
           if (R1 & 7 == 1) goto c4nte; else goto c4ntf;
       c4nte: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ntf: // global
           I64[Sp - 8] = block_c4nsH_info;
           _s4lhw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lhw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nts; else goto c4nsI;
       u4nts: // global
           call _c4nsH(R1) args: 0, res: 0, upd: 0;
       c4nsI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nsH() //  [R1]
         { info_tbl: [(c4nsH,
                       label: block_c4nsH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nsH: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4ntr; else goto c4ntq;
       c4ntr: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ntq: // global
           _s4lhy::P64 = P64[R1 + 7];
           _s4lhz::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lhF_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lhD_info;
           P64[Hp - 48] = _s4lhy::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lhz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.981028091 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadsPrec_closure" {
     GHC.Int.$fReadInt16_$creadsPrec_closure:
         const GHC.Int.$fReadInt16_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4ntA,
                       label: GHC.Int.$fReadInt16_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ntA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ntE; else goto c4ntF;
       c4ntE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ntF: // global
           I64[Sp - 16] = block_c4nty_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lhH::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lhH::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nty() //  [R1]
         { info_tbl: [(c4nty,
                       label: block_c4nty_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nty: // global
           _s4lhH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4ntD_info;
           R3 = _s4lhH::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ntD() //  [R1]
         { info_tbl: [(c4ntD,
                       label: block_c4ntD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ntD: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.982895154 UTC

[section ""data" . GHC.Int.$fReadInt3_closure" {
     GHC.Int.$fReadInt3_closure:
         const GHC.Int.$fReadInt3_info;
         const 0;
 },
 sat_s4lhM_entry() //  [R1, R2]
         { info_tbl: [(c4ntU,
                       label: sat_s4lhM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ntU: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt16_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt3_entry() //  [R2, R3]
         { info_tbl: [(c4nu0,
                       label: GHC.Int.$fReadInt3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nu0: // global
           _s4lhL::P64 = R3;
           _s4lhK::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4nu1; else goto c4nu2;
       c4nu2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nu4; else goto c4nu3;
       c4nu4: // global
           HpAlloc = 16;
           goto c4nu1;
       c4nu1: // global
           R3 = _s4lhL::P64;
           R2 = _s4lhK::P64;
           R1 = GHC.Int.$fReadInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nu3: // global
           I64[Hp - 8] = sat_s4lhM_info;
           P64[Hp] = _s4lhK::P64;
           I64[Sp - 8] = block_c4ntX_info;
           R3 = _s4lhL::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ntX() //  [R1]
         { info_tbl: [(c4ntX,
                       label: block_c4ntX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ntX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nu7; else goto c4nu6;
       c4nu7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nu6: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.984353463 UTC

[section ""data" . GHC.Int.$fReadInt2_closure" {
     GHC.Int.$fReadInt2_closure:
         const GHC.Int.$fReadInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt2_entry() //  [R1]
         { info_tbl: [(c4nue,
                       label: GHC.Int.$fReadInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nue: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4nuf; else goto c4nug;
       c4nuf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4nug: // global
           (_c4nub::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4nub::I64 == 0) goto c4nud; else goto c4nuc;
       c4nud: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4nuc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4nub::I64;
           R2 = GHC.Int.$fReadInt3_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.985473915 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadList_closure" {
     GHC.Int.$fReadInt16_$creadList_closure:
         const GHC.Int.$fReadInt16_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadList_entry() //  [R2]
         { info_tbl: [(c4nul,
                       label: GHC.Int.$fReadInt16_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nul: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt2_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.986429876 UTC

[section ""data" . GHC.Int.$fReadInt1_closure" {
     GHC.Int.$fReadInt1_closure:
         const GHC.Int.$fReadInt1_info;
         const 0;
 },
 GHC.Int.$fReadInt1_entry() //  [R2, R3]
         { info_tbl: [(c4nuv,
                       label: GHC.Int.$fReadInt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nuv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nuw; else goto c4nux;
       c4nuw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nux: // global
           I64[Sp - 8] = block_c4nus_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt16_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nus() //  [R1]
         { info_tbl: [(c4nus,
                       label: block_c4nus_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nus: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nuA; else goto c4nuz;
       c4nuA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nuz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.987499546 UTC

[section ""data" . GHC.Int.$fReadInt16_closure" {
     GHC.Int.$fReadInt16_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt16_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt16_$creadList_closure+1;
         const GHC.Int.$fReadInt3_closure+2;
         const GHC.Int.$fReadInt1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.988740118 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquot_closure" {
     GHC.Int.$fIntegralInt16_$cquot_closure:
         const GHC.Int.$fIntegralInt16_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4nuI,
                       label: GHC.Int.$fIntegralInt16_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nuI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nuM; else goto c4nuN;
       c4nuM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nuN: // global
           I64[Sp - 16] = block_c4nuF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nvo; else goto c4nuG;
       u4nvo: // global
           call _c4nuF(R1) args: 0, res: 0, upd: 0;
       c4nuG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nuF() //  [R1]
         { info_tbl: [(c4nuF,
                       label: block_c4nuF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nuF: // global
           I64[Sp] = block_c4nuL_info;
           _s4lhW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lhW::I64;
           if (R1 & 7 != 0) goto u4nvn; else goto c4nuP;
       u4nvn: // global
           call _c4nuL(R1) args: 0, res: 0, upd: 0;
       c4nuP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nuL() //  [R1]
         { info_tbl: [(c4nuL,
                       label: block_c4nuL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nuL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nuV; else goto c4nuU;
       c4nuV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nuU: // global
           _s4lhW::I64 = I64[Sp + 8];
           _s4lhZ::I64 = I64[R1 + 7];
           if (_s4lhZ::I64 != (-1)) goto u4nvm; else goto c4nvk;
       u4nvm: // global
           if (_s4lhZ::I64 != 0) goto c4nv6; else goto c4nvl;
       c4nv6: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4lhW::I64,
                                                                            _s4lhZ::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nvl: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nvk: // global
           if (_s4lhW::I64 == (-32768)) goto c4nvj; else goto c4nvi;
       c4nvj: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nvi: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4lhW::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.990959016 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$crem_closure" {
     GHC.Int.$fIntegralInt16_$crem_closure:
         const GHC.Int.$fIntegralInt16_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4nvw,
                       label: GHC.Int.$fIntegralInt16_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nvw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nvA; else goto c4nvB;
       c4nvA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nvB: // global
           I64[Sp - 16] = block_c4nvt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nvX; else goto c4nvu;
       u4nvX: // global
           call _c4nvt(R1) args: 0, res: 0, upd: 0;
       c4nvu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nvt() //  [R1]
         { info_tbl: [(c4nvt,
                       label: block_c4nvt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nvt: // global
           I64[Sp] = block_c4nvz_info;
           _s4lia::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lia::I64;
           if (R1 & 7 != 0) goto u4nvW; else goto c4nvD;
       u4nvW: // global
           call _c4nvz(R1) args: 0, res: 0, upd: 0;
       c4nvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nvz() //  [R1]
         { info_tbl: [(c4nvz,
                       label: block_c4nvz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nvz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nvJ; else goto c4nvI;
       c4nvJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nvI: // global
           _s4lid::I64 = I64[R1 + 7];
           if (_s4lid::I64 != 0) goto c4nvU; else goto c4nvV;
       c4nvU: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4lid::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nvV: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.992902322 UTC

[section ""data" . GHC.Int.$w$cdiv_closure" {
     GHC.Int.$w$cdiv_closure:
         const GHC.Int.$w$cdiv_info;
         const 0;
 },
 GHC.Int.$w$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4nw7,
                       label: GHC.Int.$w$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nw7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nw8; else goto c4nw9;
       c4nw8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nw9: // global
           if (R3 == (-1)) goto c4nw5; else goto u4nwt;
       c4nw5: // global
           if (R2 == (-32768)) goto c4nws; else goto c4nwq;
       c4nws: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nwq: // global
           I64[Sp - 8] = block_c4nwk_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4nwt: // global
           if (R3 == 0) goto c4nw6; else goto c4nw4;
       c4nw6: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nw4: // global
           I64[Sp - 8] = block_c4nwb_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nwk() //  [R1]
         { info_tbl: [(c4nwk,
                       label: block_c4nwk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nwk: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4nwb() //  [R1]
         { info_tbl: [(c4nwb,
                       label: block_c4nwb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nwb: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.994720864 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdiv_closure" {
     GHC.Int.$fIntegralInt16_$cdiv_closure:
         const GHC.Int.$fIntegralInt16_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4nwB,
                       label: GHC.Int.$fIntegralInt16_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nwB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nwO; else goto c4nwP;
       c4nwO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nwP: // global
           I64[Sp - 16] = block_c4nwy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nwW; else goto c4nwz;
       u4nwW: // global
           call _c4nwy(R1) args: 0, res: 0, upd: 0;
       c4nwz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nwy() //  [R1]
         { info_tbl: [(c4nwy,
                       label: block_c4nwy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nwy: // global
           I64[Sp] = block_c4nwE_info;
           _s4lir::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lir::I64;
           if (R1 & 7 != 0) goto u4nwV; else goto c4nwF;
       u4nwV: // global
           call _c4nwE(R1) args: 0, res: 0, upd: 0;
       c4nwF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nwE() //  [R1]
         { info_tbl: [(c4nwE,
                       label: block_c4nwE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nwE: // global
           _s4lir::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4nwJ_info;
           R3 = I64[R1 + 7];
           R2 = _s4lir::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nwJ() //  [R1]
         { info_tbl: [(c4nwJ,
                       label: block_c4nwJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nwJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nwU; else goto c4nwT;
       c4nwU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4nwT: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.996708726 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cmod_closure" {
     GHC.Int.$fIntegralInt16_$cmod_closure:
         const GHC.Int.$fIntegralInt16_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4nx4,
                       label: GHC.Int.$fIntegralInt16_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nx4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nx8; else goto c4nx9;
       c4nx8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nx9: // global
           I64[Sp - 16] = block_c4nx1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nxx; else goto c4nx2;
       u4nxx: // global
           call _c4nx1(R1) args: 0, res: 0, upd: 0;
       c4nx2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nx1() //  [R1]
         { info_tbl: [(c4nx1,
                       label: block_c4nx1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nx1: // global
           I64[Sp] = block_c4nx7_info;
           _s4liy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4liy::I64;
           if (R1 & 7 != 0) goto u4nxw; else goto c4nxb;
       u4nxw: // global
           call _c4nx7(R1) args: 0, res: 0, upd: 0;
       c4nxb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nx7() //  [R1]
         { info_tbl: [(c4nx7,
                       label: block_c4nx7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nx7: // global
           _s4liB::I64 = I64[R1 + 7];
           if (_s4liB::I64 != 0) goto c4nxr; else goto c4nxv;
       c4nxr: // global
           _s4liy::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4nxi_info;
           R3 = _s4liB::I64;
           R2 = _s4liy::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4nxv: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4nxi() //  [R1]
         { info_tbl: [(c4nxi,
                       label: block_c4nxi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nxi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nxu; else goto c4nxt;
       c4nxu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4nxt: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:08.998819586 UTC

[section ""data" . lvl7_r4kPy_closure" {
     lvl7_r4kPy_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt3_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.001283886 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquotRem_closure" {
     GHC.Int.$fIntegralInt16_$cquotRem_closure:
         const GHC.Int.$fIntegralInt16_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4nxF,
                       label: GHC.Int.$fIntegralInt16_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nxF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nxJ; else goto c4nxK;
       c4nxJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nxK: // global
           I64[Sp - 16] = block_c4nxC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nyp; else goto c4nxD;
       u4nyp: // global
           call _c4nxC(R1) args: 0, res: 0, upd: 0;
       c4nxD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nxC() //  [R1]
         { info_tbl: [(c4nxC,
                       label: block_c4nxC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nxC: // global
           I64[Sp] = block_c4nxI_info;
           _s4liI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4liI::I64;
           if (R1 & 7 != 0) goto u4nyo; else goto c4nxM;
       u4nyo: // global
           call _c4nxI(R1) args: 0, res: 0, upd: 0;
       c4nxM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nxI() //  [R1]
         { info_tbl: [(c4nxI,
                       label: block_c4nxI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nxI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4nxS; else goto c4nxR;
       c4nxS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nxR: // global
           _s4liI::I64 = I64[Sp + 8];
           _s4liL::I64 = I64[R1 + 7];
           if (_s4liL::I64 != (-1)) goto u4nyn; else goto c4nyl;
       u4nyn: // global
           if (_s4liL::I64 != 0) goto c4ny5; else goto c4nym;
       c4ny5: // global
           (_s4liN::I64, _s4liO::I64) = call MO_S_QuotRem W64(_s4liI::I64, _s4liL::I64);
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liO::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liN::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nym: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nyl: // global
           if (_s4liI::I64 == (-32768)) goto c4nyk; else goto c4nyj;
       c4nyk: // global
           Hp = Hp - 56;
           R1 = lvl7_r4kPy_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nyj: // global
           (_s4liV::I64, _s4liW::I64) = call MO_S_QuotRem W64(_s4liI::I64, (-1));
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liW::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liV::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.004635944 UTC

[section ""data" . GHC.Int.$w$cdivMod_closure" {
     GHC.Int.$w$cdivMod_closure:
         const GHC.Int.$w$cdivMod_info;
         const 0;
 },
 section ""relreadonly" . u4nB8_srtd" {
     u4nB8_srtd:
         const S4lDl_srt+536;
         const 33;
         const 4294967299;
 },
 GHC.Int.$w$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4nyy,
                       label: GHC.Int.$w$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nyy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nyz; else goto c4nyA;
       c4nyz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nyA: // global
           if (R3 == 0) goto c4nyx; else goto c4nyw;
       c4nyx: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nyw: // global
           if (R3 == (-1)) goto c4nB3; else goto u4nB4;
       c4nB3: // global
           if (R2 == (-32768)) goto c4nB2; else goto u4nB5;
       c4nB2: // global
           R2 = GHC.Int.$fBitsInt3_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4nB5: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4nB7;
       u4nB4: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4nB7;
       u4nB7: // global
           call _c4nyF() args: 0, res: 0, upd: 0;
     }
 },
 _c4nyF() //  []
         { info_tbl: [(c4nyF,
                       label: block_c4nyF_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nyF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4nyJ; else goto c4nyI;
       c4nyJ: // global
           HpAlloc = 32;
           I64[Sp] = block_c4nyF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4nyI: // global
           _s4lj2::I64 = I64[Sp + 8];
           _s4lj4::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lj2::I64, 0)) goto c4nzC; else goto c4nAT;
       c4nzC: // global
           if (%MO_S_Ge_W64(_s4lj2::I64, 0)) goto c4nyZ; else goto c4nzA;
       c4nyZ: // global
           (_s4lj9::I64, _s4lja::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lja::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lj9::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nzA: // global
           if (%MO_S_Le_W64(_s4lj4::I64, 0)) goto c4nzd; else goto c4nzz;
       c4nzd: // global
           (_s4ljh::I64, _s4lji::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lji::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljh::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nzz: // global
           (_s4ljp::I64, _s4ljq::I64) = call MO_S_QuotRem W64(_s4lj2::I64 + 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljq::I64 + _s4lj4::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljp::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nAT: // global
           if (%MO_S_Ge_W64(_s4lj4::I64, 0)) goto c4nAw; else goto c4nAS;
       c4nAw: // global
           if (%MO_S_Ge_W64(_s4lj2::I64, 0)) goto c4nzT; else goto c4nAu;
       c4nzT: // global
           (_s4ljB::I64, _s4ljC::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljC::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljB::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nAu: // global
           if (%MO_S_Le_W64(_s4lj4::I64, 0)) goto c4nA7; else goto c4nAt;
       c4nA7: // global
           (_s4ljJ::I64, _s4ljK::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljK::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljJ::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nAt: // global
           (_s4ljR::I64, _s4ljS::I64) = call MO_S_QuotRem W64(_s4lj2::I64 + 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljS::I64 + _s4lj4::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljR::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nAS: // global
           (_s4lk2::I64, _s4lk3::I64) = call MO_S_QuotRem W64(_s4lj2::I64 - 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lk3::I64 + _s4lj4::I64 + 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lk2::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.007725051 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdivMod_closure" {
     GHC.Int.$fIntegralInt16_$cdivMod_closure:
         const GHC.Int.$fIntegralInt16_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4nBg,
                       label: GHC.Int.$fIntegralInt16_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nBg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nBr; else goto c4nBs;
       c4nBr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nBs: // global
           I64[Sp - 16] = block_c4nBd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nBz; else goto c4nBe;
       u4nBz: // global
           call _c4nBd(R1) args: 0, res: 0, upd: 0;
       c4nBe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nBd() //  [R1]
         { info_tbl: [(c4nBd,
                       label: block_c4nBd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nBd: // global
           I64[Sp] = block_c4nBj_info;
           _s4lkh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkh::I64;
           if (R1 & 7 != 0) goto u4nBy; else goto c4nBk;
       u4nBy: // global
           call _c4nBj(R1) args: 0, res: 0, upd: 0;
       c4nBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nBj() //  [R1]
         { info_tbl: [(c4nBj,
                       label: block_c4nBj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nBj: // global
           _s4lkh::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4nBo_info;
           R3 = I64[R1 + 7];
           R2 = _s4lkh::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nBo() //  [R1, R2]
         { info_tbl: [(c4nBo,
                       label: block_c4nBo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nBo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4nBx; else goto c4nBw;
       c4nBx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4nBw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.009616018 UTC

[section ""data" . GHC.Int.$fRealInt16_$ctoRational_closure" {
     GHC.Int.$fRealInt16_$ctoRational_closure:
         const GHC.Int.$fRealInt16_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt16_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4nBH,
                       label: GHC.Int.$fRealInt16_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nBH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nBV; else goto c4nBW;
       c4nBV: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nBW: // global
           I64[Sp - 8] = block_c4nBE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nC3; else goto c4nBF;
       u4nC3: // global
           call _c4nBE(R1) args: 0, res: 0, upd: 0;
       c4nBF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nBE() //  [R1]
         { info_tbl: [(c4nBE,
                       label: block_c4nBE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nBE: // global
           I64[Sp] = block_c4nBK_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nBK() //  [R1]
         { info_tbl: [(c4nBK,
                       label: block_c4nBK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nBK: // global
           I64[Sp] = block_c4nBO_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nBO() //  [R1]
         { info_tbl: [(c4nBO,
                       label: block_c4nBO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nBO: // global
           I64[Sp] = block_c4nBS_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nBS() //  [R1, R2]
         { info_tbl: [(c4nBS,
                       label: block_c4nBS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nBS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4nC2; else goto c4nC1;
       c4nC2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4nC1: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.011077066 UTC

[section ""data" . GHC.Int.$fRealInt16_closure" {
     GHC.Int.$fRealInt16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt16_closure+1;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fRealInt16_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.011683039 UTC

[section ""data" . GHC.Int.$fIntegralInt16_closure" {
     GHC.Int.$fIntegralInt16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt16_closure+1;
         const GHC.Int.$fEnumInt16_closure+1;
         const GHC.Int.$fIntegralInt16_$cquot_closure+2;
         const GHC.Int.$fIntegralInt16_$crem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt16_$cmod_closure+2;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt16_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.012784489 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt16_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt16_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt16_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4nCb,
                       label: GHC.Int.$fIxInt16_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nCb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nCs; else goto c4nCt;
       c4nCs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nCt: // global
           I64[Sp - 16] = block_c4nC8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nCA; else goto c4nC9;
       u4nCA: // global
           call _c4nC8(R1) args: 0, res: 0, upd: 0;
       c4nC9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nC8() //  [R1]
         { info_tbl: [(c4nC8,
                       label: block_c4nC8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nC8: // global
           I64[Sp] = block_c4nCe_info;
           _s4lky::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lky::P64;
           if (R1 & 7 != 0) goto u4nCz; else goto c4nCf;
       u4nCz: // global
           call _c4nCe(R1) args: 0, res: 0, upd: 0;
       c4nCf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nCe() //  [R1]
         { info_tbl: [(c4nCe,
                       label: block_c4nCe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nCe: // global
           I64[Sp] = block_c4nCj_info;
           _s4lkB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkB::I64;
           if (R1 & 7 != 0) goto u4nCB; else goto c4nCk;
       u4nCB: // global
           call _c4nCj(R1) args: 0, res: 0, upd: 0;
       c4nCk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nCj() //  [R1]
         { info_tbl: [(c4nCj,
                       label: block_c4nCj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nCj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nCy; else goto c4nCx;
       c4nCy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nCx: // global
           _s4lkE::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lkE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.014850989 UTC

[section ""data" . GHC.Int.$fIxInt16_$crange_closure" {
     GHC.Int.$fIxInt16_$crange_closure:
         const GHC.Int.$fIxInt16_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$crange_entry() //  [R2]
         { info_tbl: [(c4nCJ,
                       label: GHC.Int.$fIxInt16_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nCJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nCK; else goto c4nCL;
       c4nCK: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nCL: // global
           I64[Sp - 8] = block_c4nCG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nCP; else goto c4nCH;
       u4nCP: // global
           call _c4nCG(R1) args: 0, res: 0, upd: 0;
       c4nCH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nCG() //  [R1]
         { info_tbl: [(c4nCG,
                       label: block_c4nCG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nCG: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.016426661 UTC

[section ""data" . GHC.Int.$fIxInt16_$crangeSize_closure" {
     GHC.Int.$fIxInt16_$crangeSize_closure:
         const GHC.Int.$fIxInt16_$crangeSize_info;
 },
 GHC.Int.$fIxInt16_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4nCX,
                       label: GHC.Int.$fIxInt16_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nCX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nD6; else goto c4nD7;
       c4nD6: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nD7: // global
           I64[Sp - 8] = block_c4nCU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nDw; else goto c4nCV;
       u4nDw: // global
           call _c4nCU(R1) args: 0, res: 0, upd: 0;
       c4nCV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nCU() //  [R1]
         { info_tbl: [(c4nCU,
                       label: block_c4nCU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nCU: // global
           I64[Sp - 8] = block_c4nD0_info;
           _s4lkM::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lkM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nDv; else goto c4nD1;
       u4nDv: // global
           call _c4nD0(R1) args: 0, res: 0, upd: 0;
       c4nD1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nD0() //  [R1]
         { info_tbl: [(c4nD0,
                       label: block_c4nD0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nD0: // global
           I64[Sp] = block_c4nD5_info;
           _s4lkO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkO::I64;
           if (R1 & 7 != 0) goto u4nDx; else goto c4nDa;
       u4nDx: // global
           call _c4nD5(R1) args: 0, res: 0, upd: 0;
       c4nDa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nD5() //  [R1]
         { info_tbl: [(c4nD5,
                       label: block_c4nD5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nD5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nDg; else goto c4nDf;
       c4nDg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nDf: // global
           _s4lkO::I64 = I64[Sp + 8];
           _s4lkQ::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lkO::I64,
                            _s4lkQ::I64)) goto c4nDk; else goto c4nDu;
       c4nDk: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nDu: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lkQ::I64 - _s4lkO::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.018490923 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt16_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt16_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4nDF,
                       label: GHC.Int.$fIxInt16_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nDF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nDZ; else goto c4nE0;
       c4nDZ: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nE0: // global
           I64[Sp - 8] = block_c4nDC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nE7; else goto c4nDD;
       u4nE7: // global
           call _c4nDC(R1) args: 0, res: 0, upd: 0;
       c4nDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nDC() //  [R1]
         { info_tbl: [(c4nDC,
                       label: block_c4nDC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nDC: // global
           I64[Sp - 8] = block_c4nDI_info;
           _s4lkW::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lkW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nE6; else goto c4nDJ;
       u4nE6: // global
           call _c4nDI(R1) args: 0, res: 0, upd: 0;
       c4nDJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nDI() //  [R1]
         { info_tbl: [(c4nDI,
                       label: block_c4nDI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nDI: // global
           I64[Sp] = block_c4nDN_info;
           _s4lkZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkZ::I64;
           if (R1 & 7 != 0) goto u4nE8; else goto c4nDO;
       u4nE8: // global
           call _c4nDN(R1) args: 0, res: 0, upd: 0;
       c4nDO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nDN() //  [R1]
         { info_tbl: [(c4nDN,
                       label: block_c4nDN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nDN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nE5; else goto c4nE4;
       c4nE5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nE4: // global
           _s4ll3::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4ll3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.020733452 UTC

[section ""data" . GHC.Int.$fIxInt16_$cindex_closure" {
     GHC.Int.$fIxInt16_$cindex_closure:
         const GHC.Int.$fIxInt16_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4nEg,
                       label: GHC.Int.$fIxInt16_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nEg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nEp; else goto c4nEq;
       c4nEp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nEq: // global
           I64[Sp - 16] = block_c4nEd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nEZ; else goto c4nEe;
       u4nEZ: // global
           call _c4nEd(R1) args: 0, res: 0, upd: 0;
       c4nEe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nEd() //  [R1]
         { info_tbl: [(c4nEd,
                       label: block_c4nEd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nEd: // global
           I64[Sp - 8] = block_c4nEj_info;
           _s4ll8::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4ll8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nEY; else goto c4nEk;
       u4nEY: // global
           call _c4nEj(R1) args: 0, res: 0, upd: 0;
       c4nEk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nEj() //  [R1]
         { info_tbl: [(c4nEj,
                       label: block_c4nEj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nEj: // global
           I64[Sp] = block_c4nEo_info;
           _s4lla::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lla::I64;
           if (R1 & 7 != 0) goto u4nF0; else goto c4nEt;
       u4nF0: // global
           call _c4nEo(R1) args: 0, res: 0, upd: 0;
       c4nEt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nEo() //  [R1]
         { info_tbl: [(c4nEo,
                       label: block_c4nEo_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nEo: // global
           _s4llc::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4llc::I64)) goto c4nEB; else goto c4nEF;
       c4nEB: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4nEF: // global
           I64[Sp] = block_c4nEE_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llc::I64;
           if (R1 & 7 != 0) goto u4nF1; else goto c4nEG;
       u4nF1: // global
           call _c4nEE(R1) args: 0, res: 0, upd: 0;
       c4nEG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nEE() //  [R1]
         { info_tbl: [(c4nEE,
                       label: block_c4nEE_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nEE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nEM; else goto c4nEL;
       c4nEM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nEL: // global
           _s4llc::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4llc::I64,
                            I64[R1 + 7])) goto c4nEQ; else goto c4nEX;
       c4nEQ: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4nEX: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4llc::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.022840668 UTC

[section ""data" . GHC.Int.$fIxInt16_closure" {
     GHC.Int.$fIxInt16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fIxInt16_$crange_closure+1;
         const GHC.Int.$fIxInt16_$cindex_closure+2;
         const GHC.Int.$fIxInt16_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt16_$cinRange_closure+2;
         const GHC.Int.$fIxInt16_$crangeSize_closure+1;
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.023936949 UTC

[section ""data" . GHC.Int.eqInt32_closure" {
     GHC.Int.eqInt32_closure:
         const GHC.Int.eqInt32_info;
 },
 GHC.Int.eqInt32_entry() //  [R2, R3]
         { info_tbl: [(c4nF9,
                       label: GHC.Int.eqInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nF9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nFd; else goto c4nFe;
       c4nFd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nFe: // global
           I64[Sp - 16] = block_c4nF6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nFn; else goto c4nF7;
       u4nFn: // global
           call _c4nF6(R1) args: 0, res: 0, upd: 0;
       c4nF7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nF6() //  [R1]
         { info_tbl: [(c4nF6,
                       label: block_c4nF6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nF6: // global
           I64[Sp] = block_c4nFc_info;
           _s4lll::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lll::I64;
           if (R1 & 7 != 0) goto u4nFm; else goto c4nFg;
       u4nFm: // global
           call _c4nFc(R1) args: 0, res: 0, upd: 0;
       c4nFg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nFc() //  [R1]
         { info_tbl: [(c4nFc,
                       label: block_c4nFc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nFc: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.026279576 UTC

[section ""data" . GHC.Int.$fEqInt32_closure" {
     GHC.Int.$fEqInt32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt32_closure+2;
         const GHC.Int.neInt32_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.027253236 UTC

[section ""data" . GHC.Int.gtInt32_closure" {
     GHC.Int.gtInt32_closure:
         const GHC.Int.gtInt32_info;
 },
 GHC.Int.gtInt32_entry() //  [R2, R3]
         { info_tbl: [(c4nFv,
                       label: GHC.Int.gtInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nFv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nFz; else goto c4nFA;
       c4nFz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nFA: // global
           I64[Sp - 16] = block_c4nFs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nFJ; else goto c4nFt;
       u4nFJ: // global
           call _c4nFs(R1) args: 0, res: 0, upd: 0;
       c4nFt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nFs() //  [R1]
         { info_tbl: [(c4nFs,
                       label: block_c4nFs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nFs: // global
           I64[Sp] = block_c4nFy_info;
           _s4lls::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lls::I64;
           if (R1 & 7 != 0) goto u4nFI; else goto c4nFC;
       u4nFI: // global
           call _c4nFy(R1) args: 0, res: 0, upd: 0;
       c4nFC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nFy() //  [R1]
         { info_tbl: [(c4nFy,
                       label: block_c4nFy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nFy: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.02876791 UTC

[section ""data" . GHC.Int.geInt32_closure" {
     GHC.Int.geInt32_closure:
         const GHC.Int.geInt32_info;
 },
 GHC.Int.geInt32_entry() //  [R2, R3]
         { info_tbl: [(c4nFR,
                       label: GHC.Int.geInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nFR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nFV; else goto c4nFW;
       c4nFV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nFW: // global
           I64[Sp - 16] = block_c4nFO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nG5; else goto c4nFP;
       u4nG5: // global
           call _c4nFO(R1) args: 0, res: 0, upd: 0;
       c4nFP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nFO() //  [R1]
         { info_tbl: [(c4nFO,
                       label: block_c4nFO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nFO: // global
           I64[Sp] = block_c4nFU_info;
           _s4llz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llz::I64;
           if (R1 & 7 != 0) goto u4nG4; else goto c4nFY;
       u4nG4: // global
           call _c4nFU(R1) args: 0, res: 0, upd: 0;
       c4nFY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nFU() //  [R1]
         { info_tbl: [(c4nFU,
                       label: block_c4nFU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nFU: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.030392917 UTC

[section ""data" . GHC.Int.ltInt32_closure" {
     GHC.Int.ltInt32_closure:
         const GHC.Int.ltInt32_info;
 },
 GHC.Int.ltInt32_entry() //  [R2, R3]
         { info_tbl: [(c4nGd,
                       label: GHC.Int.ltInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nGd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nGh; else goto c4nGi;
       c4nGh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nGi: // global
           I64[Sp - 16] = block_c4nGa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nGr; else goto c4nGb;
       u4nGr: // global
           call _c4nGa(R1) args: 0, res: 0, upd: 0;
       c4nGb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nGa() //  [R1]
         { info_tbl: [(c4nGa,
                       label: block_c4nGa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nGa: // global
           I64[Sp] = block_c4nGg_info;
           _s4llG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llG::I64;
           if (R1 & 7 != 0) goto u4nGq; else goto c4nGk;
       u4nGq: // global
           call _c4nGg(R1) args: 0, res: 0, upd: 0;
       c4nGk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nGg() //  [R1]
         { info_tbl: [(c4nGg,
                       label: block_c4nGg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nGg: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.031902944 UTC

[section ""data" . GHC.Int.leInt32_closure" {
     GHC.Int.leInt32_closure:
         const GHC.Int.leInt32_info;
 },
 GHC.Int.leInt32_entry() //  [R2, R3]
         { info_tbl: [(c4nGz,
                       label: GHC.Int.leInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nGz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nGD; else goto c4nGE;
       c4nGD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nGE: // global
           I64[Sp - 16] = block_c4nGw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nGN; else goto c4nGx;
       u4nGN: // global
           call _c4nGw(R1) args: 0, res: 0, upd: 0;
       c4nGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nGw() //  [R1]
         { info_tbl: [(c4nGw,
                       label: block_c4nGw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nGw: // global
           I64[Sp] = block_c4nGC_info;
           _s4llN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llN::I64;
           if (R1 & 7 != 0) goto u4nGM; else goto c4nGG;
       u4nGM: // global
           call _c4nGC(R1) args: 0, res: 0, upd: 0;
       c4nGG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nGC() //  [R1]
         { info_tbl: [(c4nGC,
                       label: block_c4nGC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nGC: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.033528272 UTC

[section ""data" . GHC.Int.$fOrdInt32_$ccompare_closure" {
     GHC.Int.$fOrdInt32_$ccompare_closure:
         const GHC.Int.$fOrdInt32_$ccompare_info;
 },
 GHC.Int.$fOrdInt32_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4nGV,
                       label: GHC.Int.$fOrdInt32_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nGV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nGZ; else goto c4nH0;
       c4nGZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nH0: // global
           I64[Sp - 16] = block_c4nGS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nHj; else goto c4nGT;
       u4nHj: // global
           call _c4nGS(R1) args: 0, res: 0, upd: 0;
       c4nGT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nGS() //  [R1]
         { info_tbl: [(c4nGS,
                       label: block_c4nGS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nGS: // global
           I64[Sp] = block_c4nGY_info;
           _s4llU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llU::I64;
           if (R1 & 7 != 0) goto u4nHi; else goto c4nH2;
       u4nHi: // global
           call _c4nGY(R1) args: 0, res: 0, upd: 0;
       c4nH2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nGY() //  [R1]
         { info_tbl: [(c4nGY,
                       label: block_c4nGY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nGY: // global
           _s4llU::I64 = I64[Sp + 8];
           _s4llW::I64 = I64[R1 + 7];
           if (_s4llU::I64 == _s4llW::I64) goto c4nHh; else goto c4nHg;
       c4nHh: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nHg: // global
           if (%MO_S_Gt_W64(_s4llU::I64,
                            _s4llW::I64)) goto c4nHd; else goto c4nHe;
       c4nHd: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nHe: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.035314716 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmax_closure" {
     GHC.Int.$fOrdInt32_$cmax_closure:
         const GHC.Int.$fOrdInt32_$cmax_info;
 },
 GHC.Int.$fOrdInt32_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4nHr,
                       label: GHC.Int.$fOrdInt32_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nHr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nHv; else goto c4nHw;
       c4nHv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nHw: // global
           I64[Sp - 16] = block_c4nHo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nHJ; else goto c4nHp;
       u4nHJ: // global
           call _c4nHo(R1) args: 0, res: 0, upd: 0;
       c4nHp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nHo() //  [R1]
         { info_tbl: [(c4nHo,
                       label: block_c4nHo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nHo: // global
           I64[Sp - 8] = block_c4nHu_info;
           _s4lm1::P64 = R1;
           _s4lm2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lm2::I64;
           P64[Sp + 8] = _s4lm1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nHI; else goto c4nHy;
       u4nHI: // global
           call _c4nHu(R1) args: 0, res: 0, upd: 0;
       c4nHy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nHu() //  [R1]
         { info_tbl: [(c4nHu,
                       label: block_c4nHu_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nHu: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4nHG; else goto c4nHH;
       c4nHG: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4nHH: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.03702358 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmin_closure" {
     GHC.Int.$fOrdInt32_$cmin_closure:
         const GHC.Int.$fOrdInt32_$cmin_info;
 },
 GHC.Int.$fOrdInt32_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4nHR,
                       label: GHC.Int.$fOrdInt32_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nHR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nHV; else goto c4nHW;
       c4nHV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nHW: // global
           I64[Sp - 16] = block_c4nHO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nI9; else goto c4nHP;
       u4nI9: // global
           call _c4nHO(R1) args: 0, res: 0, upd: 0;
       c4nHP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nHO() //  [R1]
         { info_tbl: [(c4nHO,
                       label: block_c4nHO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nHO: // global
           I64[Sp - 8] = block_c4nHU_info;
           _s4lm8::P64 = R1;
           _s4lm9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lm9::I64;
           P64[Sp + 8] = _s4lm8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nI8; else goto c4nHY;
       u4nI8: // global
           call _c4nHU(R1) args: 0, res: 0, upd: 0;
       c4nHY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nHU() //  [R1]
         { info_tbl: [(c4nHU,
                       label: block_c4nHU_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nHU: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4nI6; else goto c4nI7;
       c4nI6: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4nI7: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.038400548 UTC

[section ""data" . GHC.Int.$fOrdInt32_closure" {
     GHC.Int.$fOrdInt32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fOrdInt32_$ccompare_closure+2;
         const GHC.Int.ltInt32_closure+2;
         const GHC.Int.leInt32_closure+2;
         const GHC.Int.gtInt32_closure+2;
         const GHC.Int.geInt32_closure+2;
         const GHC.Int.$fOrdInt32_$cmax_closure+2;
         const GHC.Int.$fOrdInt32_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.039520966 UTC

[section ""data" . GHC.Int.$fIxInt32_$cinRange_closure" {
     GHC.Int.$fIxInt32_$cinRange_closure:
         const GHC.Int.$fIxInt32_$cinRange_info;
 },
 GHC.Int.$fIxInt32_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4nIh,
                       label: GHC.Int.$fIxInt32_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nIh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nIq; else goto c4nIr;
       c4nIq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nIr: // global
           I64[Sp - 16] = block_c4nIe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nIO; else goto c4nIf;
       u4nIO: // global
           call _c4nIe(R1) args: 0, res: 0, upd: 0;
       c4nIf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nIe() //  [R1]
         { info_tbl: [(c4nIe,
                       label: block_c4nIe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nIe: // global
           I64[Sp - 8] = block_c4nIk_info;
           _s4lmh::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lmh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nIN; else goto c4nIl;
       u4nIN: // global
           call _c4nIk(R1) args: 0, res: 0, upd: 0;
       c4nIl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nIk() //  [R1]
         { info_tbl: [(c4nIk,
                       label: block_c4nIk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nIk: // global
           I64[Sp] = block_c4nIp_info;
           _s4lmj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lmj::I64;
           if (R1 & 7 != 0) goto u4nIP; else goto c4nIu;
       u4nIP: // global
           call _c4nIp(R1) args: 0, res: 0, upd: 0;
       c4nIu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nIp() //  [R1]
         { info_tbl: [(c4nIp,
                       label: block_c4nIp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nIp: // global
           _s4lml::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lml::I64)) goto c4nIC; else goto c4nIG;
       c4nIC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nIG: // global
           _s4lmh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4nIF_info;
           R1 = _s4lmh::P64;
           I64[Sp + 16] = _s4lml::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4nIQ; else goto c4nIH;
       u4nIQ: // global
           call _c4nIF(R1) args: 0, res: 0, upd: 0;
       c4nIH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nIF() //  [R1]
         { info_tbl: [(c4nIF,
                       label: block_c4nIF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nIF: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.041473573 UTC

[section ""data" . GHC.Int.$fNumInt3_closure" {
     GHC.Int.$fNumInt3_closure:
         const GHC.Int.I32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.042339279 UTC

[section ""data" . GHC.Int.$fNumInt32_$csignum_closure" {
     GHC.Int.$fNumInt32_$csignum_closure:
         const GHC.Int.$fNumInt32_$csignum_info;
 },
 GHC.Int.$fNumInt32_$csignum_entry() //  [R2]
         { info_tbl: [(c4nIY,
                       label: GHC.Int.$fNumInt32_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nIY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nIZ; else goto c4nJ0;
       c4nIZ: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nJ0: // global
           I64[Sp - 8] = block_c4nIV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nJe; else goto c4nIW;
       u4nJe: // global
           call _c4nIV(R1) args: 0, res: 0, upd: 0;
       c4nIW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nIV() //  [R1]
         { info_tbl: [(c4nIV,
                       label: block_c4nIV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nIV: // global
           _s4lms::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lms::I64, 0)) goto c4nJc; else goto c4nJd;
       c4nJc: // global
           if (_s4lms::I64 == 0) goto c4nJa; else goto c4nJ9;
       c4nJa: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nJ9: // global
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nJd: // global
           R1 = GHC.Int.$fNumInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.043900448 UTC

[section ""data" . GHC.Int.$fNumInt32_$cabs_closure" {
     GHC.Int.$fNumInt32_$cabs_closure:
         const GHC.Int.$fNumInt32_$cabs_info;
 },
 GHC.Int.$fNumInt32_$cabs_entry() //  [R2]
         { info_tbl: [(c4nJm,
                       label: GHC.Int.$fNumInt32_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nJm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nJn; else goto c4nJo;
       c4nJn: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nJo: // global
           I64[Sp - 8] = block_c4nJj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nJH; else goto c4nJk;
       u4nJH: // global
           call _c4nJj(R1) args: 0, res: 0, upd: 0;
       c4nJk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nJj() //  [R1]
         { info_tbl: [(c4nJj,
                       label: block_c4nJj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nJj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nJt; else goto c4nJs;
       c4nJt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nJs: // global
           _s4lmx::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lmx::I64, 0)) goto c4nJF; else goto c4nJG;
       c4nJF: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-_s4lmx::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nJG: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.045129855 UTC

[section ""data" . GHC.Int.$fNumInt32_closure" {
     GHC.Int.$fNumInt32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt32_$c+_closure+2;
         const GHC.Int.$fNumInt32_$c-_closure+2;
         const GHC.Int.$fNumInt32_$c*_closure+2;
         const GHC.Int.$fNumInt32_$cnegate_closure+1;
         const GHC.Int.$fNumInt32_$cabs_closure+1;
         const GHC.Int.$fNumInt32_$csignum_closure+1;
         const GHC.Int.$fNumInt32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.047993755 UTC

[section ""data" . GHC.Int.$fBitsInt5_closure" {
     GHC.Int.$fBitsInt5_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.048777634 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt32_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4nJM,
                       label: GHC.Int.$fBitsInt32_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nJM: // global
           R1 = GHC.Int.$fBitsInt5_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.050041163 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbit_closure" {
     GHC.Int.$fBitsInt32_$cbit_closure:
         const GHC.Int.$fBitsInt32_$cbit_info;
 },
 GHC.Int.$fBitsInt32_$cbit_entry() //  [R2]
         { info_tbl: [(c4nJW,
                       label: GHC.Int.$fBitsInt32_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nJW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nJX; else goto c4nJY;
       c4nJX: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nJY: // global
           I64[Sp - 8] = block_c4nJT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nKh; else goto c4nJU;
       u4nKh: // global
           call _c4nJT(R1) args: 0, res: 0, upd: 0;
       c4nJU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nJT() //  [R1]
         { info_tbl: [(c4nJT,
                       label: block_c4nJT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nJT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nK3; else goto c4nK2;
       c4nK3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nK2: // global
           _s4lmE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lmE::I64, 64)) goto c4nKf; else goto c4nKg;
       c4nKf: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lmE::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nKg: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.053094912 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ctestBit_closure" {
     GHC.Int.$fBitsInt32_$ctestBit_closure:
         const GHC.Int.$fBitsInt32_$ctestBit_info;
 },
 GHC.Int.$fBitsInt32_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4nKp,
                       label: GHC.Int.$fBitsInt32_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nKp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nKt; else goto c4nKu;
       c4nKt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nKu: // global
           I64[Sp - 16] = block_c4nKm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nLc; else goto c4nKn;
       u4nLc: // global
           call _c4nKm(R1) args: 0, res: 0, upd: 0;
       c4nKn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nKm() //  [R1]
         { info_tbl: [(c4nKm,
                       label: block_c4nKm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nKm: // global
           I64[Sp] = block_c4nKs_info;
           _s4lmL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lmL::I64;
           if (R1 & 7 != 0) goto u4nLb; else goto c4nKw;
       u4nLb: // global
           call _c4nKs(R1) args: 0, res: 0, upd: 0;
       c4nKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nKs() //  [R1]
         { info_tbl: [(c4nKs,
                       label: block_c4nKs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nKs: // global
           _s4lmN::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4lmN::I64, 64)) goto c4nLa; else goto c4nL9;
       c4nL9: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lmN::I64)) == 0) goto c4nLa; else goto c4nKY;
       c4nLa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nKY: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.055614581 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateR_closure" {
     GHC.Int.$fBitsInt32_$crotateR_closure:
         const GHC.Int.$fBitsInt32_$crotateR_info;
 },
 GHC.Int.$fBitsInt32_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4nLk,
                       label: GHC.Int.$fBitsInt32_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nLk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nLo; else goto c4nLp;
       c4nLo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nLp: // global
           I64[Sp - 16] = block_c4nLh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nMo; else goto c4nLi;
       u4nMo: // global
           call _c4nLh(R1) args: 0, res: 0, upd: 0;
       c4nLi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nLh() //  [R1]
         { info_tbl: [(c4nLh,
                       label: block_c4nLh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nLh: // global
           I64[Sp - 8] = block_c4nLn_info;
           _s4lmX::P64 = R1;
           _s4lmY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lmY::I64;
           P64[Sp + 8] = _s4lmX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nMn; else goto c4nLr;
       u4nMn: // global
           call _c4nLn(R1) args: 0, res: 0, upd: 0;
       c4nLr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nLn() //  [R1]
         { info_tbl: [(c4nLn,
                       label: block_c4nLn_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nLn: // global
           _s4ln4::I64 = -I64[R1 + 7] & 31;
           if (_s4ln4::I64 != 0) goto u4nMl; else goto c4nMh;
       u4nMl: // global
           I64[Sp + 16] = _s4ln4::I64;
           Sp = Sp + 8;
           call _c4nLJ() args: 0, res: 0, upd: 0;
       c4nMh: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4nLJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nLJ: // global
           Hp = Hp + 16;
           _s4ln4::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4nMe; else goto c4nMd;
       c4nMe: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4nLI_info;
           R1 = _s4ln4::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4nMd: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4ln5::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4ln5::I64 << _s4ln4::I64) | (_s4ln5::I64 >> 32 - _s4ln4::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4nLI() //  [R1]
         { info_tbl: [(c4nLI,
                       label: block_c4nLI_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nLI: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4nLJ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.057974045 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt32_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt32_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt32_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4nMy,
                       label: GHC.Int.$fBitsInt32_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nMy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nMC; else goto c4nMD;
       c4nMC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nMD: // global
           I64[Sp - 16] = block_c4nMv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nNc; else goto c4nMw;
       u4nNc: // global
           call _c4nMv(R1) args: 0, res: 0, upd: 0;
       c4nMw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nMv() //  [R1]
         { info_tbl: [(c4nMv,
                       label: block_c4nMv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nMv: // global
           I64[Sp - 8] = block_c4nMB_info;
           _s4lnf::P64 = R1;
           _s4lng::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lng::I64;
           P64[Sp + 8] = _s4lnf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nNb; else goto c4nMF;
       u4nNb: // global
           call _c4nMB(R1) args: 0, res: 0, upd: 0;
       c4nMF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nMB() //  [R1]
         { info_tbl: [(c4nMB,
                       label: block_c4nMB_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nMB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nML; else goto c4nMK;
       c4nML: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nMK: // global
           _s4lni::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lni::I64, 64)) goto c4nN9; else goto c4nNa;
       c4nN9: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lni::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nNa: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.060061553 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cclearBit_closure" {
     GHC.Int.$fBitsInt32_$cclearBit_closure:
         const GHC.Int.$fBitsInt32_$cclearBit_info;
 },
 GHC.Int.$fBitsInt32_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4nNk,
                       label: GHC.Int.$fBitsInt32_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nNk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nNo; else goto c4nNp;
       c4nNo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nNp: // global
           I64[Sp - 16] = block_c4nNh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nOc; else goto c4nNi;
       u4nOc: // global
           call _c4nNh(R1) args: 0, res: 0, upd: 0;
       c4nNi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nNh() //  [R1]
         { info_tbl: [(c4nNh,
                       label: block_c4nNh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nNh: // global
           I64[Sp] = block_c4nNn_info;
           _s4lnt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lnt::I64;
           if (R1 & 7 != 0) goto u4nOb; else goto c4nNr;
       u4nOb: // global
           call _c4nNn(R1) args: 0, res: 0, upd: 0;
       c4nNr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nNn() //  [R1]
         { info_tbl: [(c4nNn,
                       label: block_c4nNn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nNn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nNx; else goto c4nNw;
       c4nNx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nNw: // global
           _s4lnt::I64 = I64[Sp + 8];
           _s4lnv::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lnv::I64, 64)) goto c4nNY; else goto c4nOa;
       c4nNY: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lnt::I64 & ~%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lnv::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nOa: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lnt::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.062201797 UTC

[section ""data" . GHC.Int.$fBitsInt32_$csetBit_closure" {
     GHC.Int.$fBitsInt32_$csetBit_closure:
         const GHC.Int.$fBitsInt32_$csetBit_info;
 },
 GHC.Int.$fBitsInt32_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4nOk,
                       label: GHC.Int.$fBitsInt32_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nOk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nOo; else goto c4nOp;
       c4nOo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nOp: // global
           I64[Sp - 16] = block_c4nOh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nOY; else goto c4nOi;
       u4nOY: // global
           call _c4nOh(R1) args: 0, res: 0, upd: 0;
       c4nOi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nOh() //  [R1]
         { info_tbl: [(c4nOh,
                       label: block_c4nOh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nOh: // global
           I64[Sp - 8] = block_c4nOn_info;
           _s4lnJ::P64 = R1;
           _s4lnK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lnK::I64;
           P64[Sp + 8] = _s4lnJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nOX; else goto c4nOr;
       u4nOX: // global
           call _c4nOn(R1) args: 0, res: 0, upd: 0;
       c4nOr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nOn() //  [R1]
         { info_tbl: [(c4nOn,
                       label: block_c4nOn_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nOn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nOx; else goto c4nOw;
       c4nOx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nOw: // global
           _s4lnM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lnM::I64, 64)) goto c4nOV; else goto c4nOW;
       c4nOV: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lnM::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nOW: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.063884807 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateL_closure" {
     GHC.Int.$fBitsInt32_$crotateL_closure:
         const GHC.Int.$fBitsInt32_$crotateL_info;
 },
 GHC.Int.$fBitsInt32_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4nP3,
                       label: GHC.Int.$fBitsInt32_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nP3: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt32_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.064721424 UTC

[section ""data" . GHC.Int.$fBitsInt32_closure" {
     GHC.Int.$fBitsInt32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fBitsInt32_$c.&._closure+2;
         const GHC.Int.$fBitsInt32_$c.|._closure+2;
         const GHC.Int.$fBitsInt32_$cxor_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt32_$cshift_closure+2;
         const GHC.Int.$fBitsInt32_$crotate_closure+2;
         const GHC.Int.$fBitsInt6_closure+1;
         const GHC.Int.$fBitsInt32_$cbit_closure+1;
         const GHC.Int.$fBitsInt32_$csetBit_closure+2;
         const GHC.Int.$fBitsInt32_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt32_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt32_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt32_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt32_$crotateL_closure+2;
         const GHC.Int.$fBitsInt32_$crotateR_closure+2;
         const GHC.Int.$fBitsInt32_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.065528581 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_closure" {
     GHC.Int.$fFiniteBitsInt32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt32_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.067137069 UTC

[section ""data" . GHC.Int.$fReadInt32_go_closure" {
     GHC.Int.$fReadInt32_go_closure:
         const GHC.Int.$fReadInt32_go_info;
 },
 sat_s4lo6_entry() //  [R1]
         { info_tbl: [(c4nPp,
                       label: sat_s4lo6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nPp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nPq; else goto c4nPr;
       c4nPq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4nPr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lo4_entry() //  [R1]
         { info_tbl: [(c4nPz,
                       label: sat_s4lo4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nPz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nPG; else goto c4nPH;
       c4nPG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4nPH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4nPw_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4nPL; else goto c4nPx;
       u4nPL: // global
           call _c4nPw(R1) args: 0, res: 0, upd: 0;
       c4nPx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4nPw() //  [R1]
         { info_tbl: [(c4nPw,
                       label: block_c4nPw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nPw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nPK; else goto c4nPJ;
       c4nPK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4nPJ: // global
           _s4lo3::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lo3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt32_go_entry() //  [R2]
         { info_tbl: [(c4nPQ,
                       label: GHC.Int.$fReadInt32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nPQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nPR; else goto c4nPS;
       c4nPR: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nPS: // global
           I64[Sp - 8] = block_c4nPa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nQ2; else goto c4nPb;
       u4nQ2: // global
           call _c4nPa(R1) args: 0, res: 0, upd: 0;
       c4nPb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nPa() //  [R1]
         { info_tbl: [(c4nPa,
                       label: block_c4nPa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nPa: // global
           if (R1 & 7 == 1) goto c4nPN; else goto c4nPO;
       c4nPN: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nPO: // global
           I64[Sp - 8] = block_c4nPg_info;
           _s4lnX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lnX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nQ1; else goto c4nPh;
       u4nQ1: // global
           call _c4nPg(R1) args: 0, res: 0, upd: 0;
       c4nPh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nPg() //  [R1]
         { info_tbl: [(c4nPg,
                       label: block_c4nPg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nPg: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4nQ0; else goto c4nPZ;
       c4nQ0: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nPZ: // global
           _s4lnZ::P64 = P64[R1 + 7];
           _s4lo0::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lo6_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lo4_info;
           P64[Hp - 48] = _s4lnZ::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lo0::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.069920702 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadsPrec_closure" {
     GHC.Int.$fReadInt32_$creadsPrec_closure:
         const GHC.Int.$fReadInt32_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4nQ9,
                       label: GHC.Int.$fReadInt32_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nQ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nQd; else goto c4nQe;
       c4nQd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nQe: // global
           I64[Sp - 16] = block_c4nQ7_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lo8::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lo8::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nQ7() //  [R1]
         { info_tbl: [(c4nQ7,
                       label: block_c4nQ7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nQ7: // global
           _s4lo8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4nQc_info;
           R3 = _s4lo8::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nQc() //  [R1]
         { info_tbl: [(c4nQc,
                       label: block_c4nQc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nQc: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.071615305 UTC

[section ""data" . GHC.Int.$fReadInt6_closure" {
     GHC.Int.$fReadInt6_closure:
         const GHC.Int.$fReadInt6_info;
         const 0;
 },
 sat_s4lod_entry() //  [R1, R2]
         { info_tbl: [(c4nQt,
                       label: sat_s4lod_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nQt: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt32_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt6_entry() //  [R2, R3]
         { info_tbl: [(c4nQz,
                       label: GHC.Int.$fReadInt6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nQz: // global
           _s4loc::P64 = R3;
           _s4lob::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4nQA; else goto c4nQB;
       c4nQB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nQD; else goto c4nQC;
       c4nQD: // global
           HpAlloc = 16;
           goto c4nQA;
       c4nQA: // global
           R3 = _s4loc::P64;
           R2 = _s4lob::P64;
           R1 = GHC.Int.$fReadInt6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nQC: // global
           I64[Hp - 8] = sat_s4lod_info;
           P64[Hp] = _s4lob::P64;
           I64[Sp - 8] = block_c4nQw_info;
           R3 = _s4loc::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nQw() //  [R1]
         { info_tbl: [(c4nQw,
                       label: block_c4nQw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nQw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nQG; else goto c4nQF;
       c4nQG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nQF: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.073211605 UTC

[section ""data" . GHC.Int.$fReadInt5_closure" {
     GHC.Int.$fReadInt5_closure:
         const GHC.Int.$fReadInt5_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4nQQ_srtd" {
     u4nQQ_srtd:
         const S4lDl_srt+504;
         const 46;
         const 35184372088833;
 },
 GHC.Int.$fReadInt5_entry() //  [R1]
         { info_tbl: [(c4nQN,
                       label: GHC.Int.$fReadInt5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nQN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4nQO; else goto c4nQP;
       c4nQO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4nQP: // global
           (_c4nQK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4nQK::I64 == 0) goto c4nQM; else goto c4nQL;
       c4nQM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4nQL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4nQK::I64;
           R2 = GHC.Int.$fReadInt6_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.074655117 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadList_closure" {
     GHC.Int.$fReadInt32_$creadList_closure:
         const GHC.Int.$fReadInt32_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadList_entry() //  [R2]
         { info_tbl: [(c4nQV,
                       label: GHC.Int.$fReadInt32_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nQV: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt5_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.07574907 UTC

[section ""data" . GHC.Int.$fReadInt4_closure" {
     GHC.Int.$fReadInt4_closure:
         const GHC.Int.$fReadInt4_info;
         const 0;
 },
 GHC.Int.$fReadInt4_entry() //  [R2, R3]
         { info_tbl: [(c4nR5,
                       label: GHC.Int.$fReadInt4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nR5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nR6; else goto c4nR7;
       c4nR6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nR7: // global
           I64[Sp - 8] = block_c4nR2_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt32_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nR2() //  [R1]
         { info_tbl: [(c4nR2,
                       label: block_c4nR2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nR2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nRa; else goto c4nR9;
       c4nRa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nR9: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.077853824 UTC

[section ""data" . GHC.Int.$fReadInt32_closure" {
     GHC.Int.$fReadInt32_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt32_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt32_$creadList_closure+1;
         const GHC.Int.$fReadInt6_closure+2;
         const GHC.Int.$fReadInt4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.079109073 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquot_closure" {
     GHC.Int.$fIntegralInt32_$cquot_closure:
         const GHC.Int.$fIntegralInt32_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4nRi,
                       label: GHC.Int.$fIntegralInt32_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nRi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nRm; else goto c4nRn;
       c4nRm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nRn: // global
           I64[Sp - 16] = block_c4nRf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nRY; else goto c4nRg;
       u4nRY: // global
           call _c4nRf(R1) args: 0, res: 0, upd: 0;
       c4nRg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nRf() //  [R1]
         { info_tbl: [(c4nRf,
                       label: block_c4nRf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nRf: // global
           I64[Sp] = block_c4nRl_info;
           _s4lon::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lon::I64;
           if (R1 & 7 != 0) goto u4nRX; else goto c4nRp;
       u4nRX: // global
           call _c4nRl(R1) args: 0, res: 0, upd: 0;
       c4nRp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nRl() //  [R1]
         { info_tbl: [(c4nRl,
                       label: block_c4nRl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nRl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nRv; else goto c4nRu;
       c4nRv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nRu: // global
           _s4lon::I64 = I64[Sp + 8];
           _s4loq::I64 = I64[R1 + 7];
           if (_s4loq::I64 != (-1)) goto u4nRW; else goto c4nRU;
       u4nRW: // global
           if (_s4loq::I64 != 0) goto c4nRG; else goto c4nRV;
       c4nRG: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4lon::I64,
                                                                            _s4loq::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nRV: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nRU: // global
           if (_s4lon::I64 == (-2147483648)) goto c4nRT; else goto c4nRS;
       c4nRT: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nRS: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4lon::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.081340538 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$crem_closure" {
     GHC.Int.$fIntegralInt32_$crem_closure:
         const GHC.Int.$fIntegralInt32_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4nS6,
                       label: GHC.Int.$fIntegralInt32_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nS6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nSa; else goto c4nSb;
       c4nSa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nSb: // global
           I64[Sp - 16] = block_c4nS3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nSz; else goto c4nS4;
       u4nSz: // global
           call _c4nS3(R1) args: 0, res: 0, upd: 0;
       c4nS4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nS3() //  [R1]
         { info_tbl: [(c4nS3,
                       label: block_c4nS3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nS3: // global
           I64[Sp] = block_c4nS9_info;
           _s4loB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loB::I64;
           if (R1 & 7 != 0) goto u4nSy; else goto c4nSd;
       u4nSy: // global
           call _c4nS9(R1) args: 0, res: 0, upd: 0;
       c4nSd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nS9() //  [R1]
         { info_tbl: [(c4nS9,
                       label: block_c4nS9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nS9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nSj; else goto c4nSi;
       c4nSj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nSi: // global
           _s4loE::I64 = I64[R1 + 7];
           if (_s4loE::I64 != (-1)) goto u4nSx; else goto c4nSv;
       u4nSx: // global
           if (_s4loE::I64 != 0) goto c4nSu; else goto c4nSw;
       c4nSu: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4loE::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nSw: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nSv: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.083247541 UTC

[section ""data" . GHC.Int.$w$cdiv1_closure" {
     GHC.Int.$w$cdiv1_closure:
         const GHC.Int.$w$cdiv1_info;
         const 0;
 },
 GHC.Int.$w$cdiv1_entry() //  [R2, R3]
         { info_tbl: [(c4nSJ,
                       label: GHC.Int.$w$cdiv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nSJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nSK; else goto c4nSL;
       c4nSK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nSL: // global
           if (R3 == (-1)) goto c4nSH; else goto u4nT5;
       c4nSH: // global
           if (R2 == (-2147483648)) goto c4nT4; else goto c4nT2;
       c4nT4: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nT2: // global
           I64[Sp - 8] = block_c4nSW_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4nT5: // global
           if (R3 == 0) goto c4nSI; else goto c4nSG;
       c4nSI: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nSG: // global
           I64[Sp - 8] = block_c4nSN_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nSW() //  [R1]
         { info_tbl: [(c4nSW,
                       label: block_c4nSW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nSW: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4nSN() //  [R1]
         { info_tbl: [(c4nSN,
                       label: block_c4nSN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nSN: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.08492317 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdiv_closure" {
     GHC.Int.$fIntegralInt32_$cdiv_closure:
         const GHC.Int.$fIntegralInt32_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4nTd,
                       label: GHC.Int.$fIntegralInt32_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nTd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nTq; else goto c4nTr;
       c4nTq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nTr: // global
           I64[Sp - 16] = block_c4nTa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nTy; else goto c4nTb;
       u4nTy: // global
           call _c4nTa(R1) args: 0, res: 0, upd: 0;
       c4nTb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nTa() //  [R1]
         { info_tbl: [(c4nTa,
                       label: block_c4nTa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nTa: // global
           I64[Sp] = block_c4nTg_info;
           _s4loS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loS::I64;
           if (R1 & 7 != 0) goto u4nTx; else goto c4nTh;
       u4nTx: // global
           call _c4nTg(R1) args: 0, res: 0, upd: 0;
       c4nTh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nTg() //  [R1]
         { info_tbl: [(c4nTg,
                       label: block_c4nTg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nTg: // global
           _s4loS::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4nTl_info;
           R3 = I64[R1 + 7];
           R2 = _s4loS::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nTl() //  [R1]
         { info_tbl: [(c4nTl,
                       label: block_c4nTl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nTl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nTw; else goto c4nTv;
       c4nTw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4nTv: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.087014918 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cmod_closure" {
     GHC.Int.$fIntegralInt32_$cmod_closure:
         const GHC.Int.$fIntegralInt32_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4nTG,
                       label: GHC.Int.$fIntegralInt32_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nTG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nTK; else goto c4nTL;
       c4nTK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nTL: // global
           I64[Sp - 16] = block_c4nTD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nUb; else goto c4nTE;
       u4nUb: // global
           call _c4nTD(R1) args: 0, res: 0, upd: 0;
       c4nTE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nTD() //  [R1]
         { info_tbl: [(c4nTD,
                       label: block_c4nTD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nTD: // global
           I64[Sp] = block_c4nTJ_info;
           _s4loZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loZ::I64;
           if (R1 & 7 != 0) goto u4nUa; else goto c4nTN;
       u4nUa: // global
           call _c4nTJ(R1) args: 0, res: 0, upd: 0;
       c4nTN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nTJ() //  [R1]
         { info_tbl: [(c4nTJ,
                       label: block_c4nTJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nTJ: // global
           _s4lp2::I64 = I64[R1 + 7];
           if (_s4lp2::I64 != (-1)) goto u4nU9; else goto c4nU7;
       u4nU9: // global
           if (_s4lp2::I64 != 0) goto c4nU3; else goto c4nU8;
       c4nU3: // global
           _s4loZ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4nTU_info;
           R3 = _s4lp2::I64;
           R2 = _s4loZ::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4nU8: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nU7: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4nTU() //  [R1]
         { info_tbl: [(c4nTU,
                       label: block_c4nTU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nTU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nU6; else goto c4nU5;
       c4nU6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4nU5: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.088671215 UTC

[section ""data" . lvl8_r4kPz_closure" {
     lvl8_r4kPz_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt6_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.090073528 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquotRem_closure" {
     GHC.Int.$fIntegralInt32_$cquotRem_closure:
         const GHC.Int.$fIntegralInt32_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4nUj,
                       label: GHC.Int.$fIntegralInt32_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nUj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nUn; else goto c4nUo;
       c4nUn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nUo: // global
           I64[Sp - 16] = block_c4nUg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nV3; else goto c4nUh;
       u4nV3: // global
           call _c4nUg(R1) args: 0, res: 0, upd: 0;
       c4nUh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nUg() //  [R1]
         { info_tbl: [(c4nUg,
                       label: block_c4nUg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nUg: // global
           I64[Sp] = block_c4nUm_info;
           _s4lp9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lp9::I64;
           if (R1 & 7 != 0) goto u4nV2; else goto c4nUq;
       u4nV2: // global
           call _c4nUm(R1) args: 0, res: 0, upd: 0;
       c4nUq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nUm() //  [R1]
         { info_tbl: [(c4nUm,
                       label: block_c4nUm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nUm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4nUw; else goto c4nUv;
       c4nUw: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nUv: // global
           _s4lp9::I64 = I64[Sp + 8];
           _s4lpc::I64 = I64[R1 + 7];
           if (_s4lpc::I64 != (-1)) goto u4nV1; else goto c4nUZ;
       u4nV1: // global
           if (_s4lpc::I64 != 0) goto c4nUJ; else goto c4nV0;
       c4nUJ: // global
           (_s4lpe::I64, _s4lpf::I64) = call MO_S_QuotRem W64(_s4lp9::I64, _s4lpc::I64);
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpf::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpe::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nV0: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nUZ: // global
           if (_s4lp9::I64 == (-2147483648)) goto c4nUY; else goto c4nUX;
       c4nUY: // global
           Hp = Hp - 56;
           R1 = lvl8_r4kPz_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4nUX: // global
           (_s4lpm::I64, _s4lpn::I64) = call MO_S_QuotRem W64(_s4lp9::I64, (-1));
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpn::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpm::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.093460858 UTC

[section ""data" . GHC.Int.$w$cdivMod1_closure" {
     GHC.Int.$w$cdivMod1_closure:
         const GHC.Int.$w$cdivMod1_info;
         const 0;
 },
 GHC.Int.$w$cdivMod1_entry() //  [R2, R3]
         { info_tbl: [(c4nVc,
                       label: GHC.Int.$w$cdivMod1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nVc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4nVd; else goto c4nVe;
       c4nVd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nVe: // global
           if (R3 == 0) goto c4nVb; else goto c4nVa;
       c4nVb: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4nVa: // global
           if (R3 == (-1)) goto c4nXH; else goto u4nXI;
       c4nXH: // global
           if (R2 == (-2147483648)) goto c4nXG; else goto u4nXJ;
       c4nXG: // global
           R2 = GHC.Int.$fBitsInt6_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4nXJ: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4nXL;
       u4nXI: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4nXL;
       u4nXL: // global
           call _c4nVj() args: 0, res: 0, upd: 0;
     }
 },
 _c4nVj() //  []
         { info_tbl: [(c4nVj,
                       label: block_c4nVj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nVj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4nVn; else goto c4nVm;
       c4nVn: // global
           HpAlloc = 32;
           I64[Sp] = block_c4nVj_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4nVm: // global
           _s4lpt::I64 = I64[Sp + 8];
           _s4lpv::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lpt::I64, 0)) goto c4nWg; else goto c4nXx;
       c4nWg: // global
           if (%MO_S_Ge_W64(_s4lpt::I64, 0)) goto c4nVD; else goto c4nWe;
       c4nVD: // global
           (_s4lpA::I64, _s4lpB::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpB::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpA::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nWe: // global
           if (%MO_S_Le_W64(_s4lpv::I64, 0)) goto c4nVR; else goto c4nWd;
       c4nVR: // global
           (_s4lpI::I64, _s4lpJ::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpJ::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpI::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nWd: // global
           (_s4lpQ::I64, _s4lpR::I64) = call MO_S_QuotRem W64(_s4lpt::I64 + 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpR::I64 + _s4lpv::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpQ::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nXx: // global
           if (%MO_S_Ge_W64(_s4lpv::I64, 0)) goto c4nXa; else goto c4nXw;
       c4nXa: // global
           if (%MO_S_Ge_W64(_s4lpt::I64, 0)) goto c4nWx; else goto c4nX8;
       c4nWx: // global
           (_s4lq2::I64, _s4lq3::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lq3::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lq2::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nX8: // global
           if (%MO_S_Le_W64(_s4lpv::I64, 0)) goto c4nWL; else goto c4nX7;
       c4nWL: // global
           (_s4lqa::I64, _s4lqb::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqb::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqa::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nX7: // global
           (_s4lqi::I64, _s4lqj::I64) = call MO_S_QuotRem W64(_s4lpt::I64 + 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqj::I64 + _s4lpv::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqi::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4nXw: // global
           (_s4lqt::I64, _s4lqu::I64) = call MO_S_QuotRem W64(_s4lpt::I64 - 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqu::I64 + _s4lpv::I64 + 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqt::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.096786325 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdivMod_closure" {
     GHC.Int.$fIntegralInt32_$cdivMod_closure:
         const GHC.Int.$fIntegralInt32_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4nXT,
                       label: GHC.Int.$fIntegralInt32_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nXT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nY4; else goto c4nY5;
       c4nY4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nY5: // global
           I64[Sp - 16] = block_c4nXQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nYc; else goto c4nXR;
       u4nYc: // global
           call _c4nXQ(R1) args: 0, res: 0, upd: 0;
       c4nXR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nXQ() //  [R1]
         { info_tbl: [(c4nXQ,
                       label: block_c4nXQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nXQ: // global
           I64[Sp] = block_c4nXW_info;
           _s4lqI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lqI::I64;
           if (R1 & 7 != 0) goto u4nYb; else goto c4nXX;
       u4nYb: // global
           call _c4nXW(R1) args: 0, res: 0, upd: 0;
       c4nXX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nXW() //  [R1]
         { info_tbl: [(c4nXW,
                       label: block_c4nXW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nXW: // global
           _s4lqI::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4nY1_info;
           R3 = I64[R1 + 7];
           R2 = _s4lqI::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nY1() //  [R1, R2]
         { info_tbl: [(c4nY1,
                       label: block_c4nY1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nY1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4nYa; else goto c4nY9;
       c4nYa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4nY9: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.099185818 UTC

[section ""data" . GHC.Int.$fRealInt32_$ctoRational_closure" {
     GHC.Int.$fRealInt32_$ctoRational_closure:
         const GHC.Int.$fRealInt32_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt32_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4nYk,
                       label: GHC.Int.$fRealInt32_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nYk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nYy; else goto c4nYz;
       c4nYy: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nYz: // global
           I64[Sp - 8] = block_c4nYh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nYG; else goto c4nYi;
       u4nYG: // global
           call _c4nYh(R1) args: 0, res: 0, upd: 0;
       c4nYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nYh() //  [R1]
         { info_tbl: [(c4nYh,
                       label: block_c4nYh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nYh: // global
           I64[Sp] = block_c4nYn_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nYn() //  [R1]
         { info_tbl: [(c4nYn,
                       label: block_c4nYn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nYn: // global
           I64[Sp] = block_c4nYr_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nYr() //  [R1]
         { info_tbl: [(c4nYr,
                       label: block_c4nYr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nYr: // global
           I64[Sp] = block_c4nYv_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4nYv() //  [R1, R2]
         { info_tbl: [(c4nYv,
                       label: block_c4nYv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nYv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4nYF; else goto c4nYE;
       c4nYF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4nYE: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.100862026 UTC

[section ""data" . GHC.Int.$fRealInt32_closure" {
     GHC.Int.$fRealInt32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt32_closure+1;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fRealInt32_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.102678759 UTC

[section ""data" . GHC.Int.$fIntegralInt32_closure" {
     GHC.Int.$fIntegralInt32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt32_closure+1;
         const GHC.Int.$fEnumInt32_closure+1;
         const GHC.Int.$fIntegralInt32_$cquot_closure+2;
         const GHC.Int.$fIntegralInt32_$crem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt32_$cmod_closure+2;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt32_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.103748399 UTC

[section ""data" . GHC.Int.$fIxInt32_$crange_closure" {
     GHC.Int.$fIxInt32_$crange_closure:
         const GHC.Int.$fIxInt32_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$crange_entry() //  [R2]
         { info_tbl: [(c4nYO,
                       label: GHC.Int.$fIxInt32_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nYO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4nYP; else goto c4nYQ;
       c4nYP: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nYQ: // global
           I64[Sp - 8] = block_c4nYL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4nYU; else goto c4nYM;
       u4nYU: // global
           call _c4nYL(R1) args: 0, res: 0, upd: 0;
       c4nYM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nYL() //  [R1]
         { info_tbl: [(c4nYL,
                       label: block_c4nYL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nYL: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.105392431 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt32_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt32_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt32_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4nZ2,
                       label: GHC.Int.$fIxInt32_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nZ2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nZj; else goto c4nZk;
       c4nZj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4nZk: // global
           I64[Sp - 16] = block_c4nYZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4nZr; else goto c4nZ0;
       u4nZr: // global
           call _c4nYZ(R1) args: 0, res: 0, upd: 0;
       c4nZ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nYZ() //  [R1]
         { info_tbl: [(c4nYZ,
                       label: block_c4nYZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nYZ: // global
           I64[Sp] = block_c4nZ5_info;
           _s4lr3::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lr3::P64;
           if (R1 & 7 != 0) goto u4nZq; else goto c4nZ6;
       u4nZq: // global
           call _c4nZ5(R1) args: 0, res: 0, upd: 0;
       c4nZ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nZ5() //  [R1]
         { info_tbl: [(c4nZ5,
                       label: block_c4nZ5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nZ5: // global
           I64[Sp] = block_c4nZa_info;
           _s4lr6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lr6::I64;
           if (R1 & 7 != 0) goto u4nZs; else goto c4nZb;
       u4nZs: // global
           call _c4nZa(R1) args: 0, res: 0, upd: 0;
       c4nZb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nZa() //  [R1]
         { info_tbl: [(c4nZa,
                       label: block_c4nZa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nZa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nZp; else goto c4nZo;
       c4nZp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nZo: // global
           _s4lr9::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lr9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.107498847 UTC

[section ""data" . GHC.Int.$fIxInt32_$crangeSize_closure" {
     GHC.Int.$fIxInt32_$crangeSize_closure:
         const GHC.Int.$fIxInt32_$crangeSize_info;
 },
 GHC.Int.$fIxInt32_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4nZA,
                       label: GHC.Int.$fIxInt32_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nZA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4nZJ; else goto c4nZK;
       c4nZJ: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4nZK: // global
           I64[Sp - 8] = block_c4nZx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o09; else goto c4nZy;
       u4o09: // global
           call _c4nZx(R1) args: 0, res: 0, upd: 0;
       c4nZy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nZx() //  [R1]
         { info_tbl: [(c4nZx,
                       label: block_c4nZx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nZx: // global
           I64[Sp - 8] = block_c4nZD_info;
           _s4lrd::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lrd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o08; else goto c4nZE;
       u4o08: // global
           call _c4nZD(R1) args: 0, res: 0, upd: 0;
       c4nZE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nZD() //  [R1]
         { info_tbl: [(c4nZD,
                       label: block_c4nZD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nZD: // global
           I64[Sp] = block_c4nZI_info;
           _s4lrf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrf::I64;
           if (R1 & 7 != 0) goto u4o0a; else goto c4nZN;
       u4o0a: // global
           call _c4nZI(R1) args: 0, res: 0, upd: 0;
       c4nZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4nZI() //  [R1]
         { info_tbl: [(c4nZI,
                       label: block_c4nZI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4nZI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4nZT; else goto c4nZS;
       c4nZT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4nZS: // global
           _s4lrf::I64 = I64[Sp + 8];
           _s4lrh::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lrf::I64,
                            _s4lrh::I64)) goto c4nZX; else goto c4o07;
       c4nZX: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4o07: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lrh::I64 - _s4lrf::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.109876551 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt32_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt32_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4o0i,
                       label: GHC.Int.$fIxInt32_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o0i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4o0C; else goto c4o0D;
       c4o0C: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4o0D: // global
           I64[Sp - 8] = block_c4o0f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o0K; else goto c4o0g;
       u4o0K: // global
           call _c4o0f(R1) args: 0, res: 0, upd: 0;
       c4o0g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o0f() //  [R1]
         { info_tbl: [(c4o0f,
                       label: block_c4o0f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o0f: // global
           I64[Sp - 8] = block_c4o0l_info;
           _s4lrn::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lrn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o0J; else goto c4o0m;
       u4o0J: // global
           call _c4o0l(R1) args: 0, res: 0, upd: 0;
       c4o0m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o0l() //  [R1]
         { info_tbl: [(c4o0l,
                       label: block_c4o0l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o0l: // global
           I64[Sp] = block_c4o0q_info;
           _s4lrq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrq::I64;
           if (R1 & 7 != 0) goto u4o0L; else goto c4o0r;
       u4o0L: // global
           call _c4o0q(R1) args: 0, res: 0, upd: 0;
       c4o0r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o0q() //  [R1]
         { info_tbl: [(c4o0q,
                       label: block_c4o0q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o0q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4o0I; else goto c4o0H;
       c4o0I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4o0H: // global
           _s4lru::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lru::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.112054872 UTC

[section ""data" . GHC.Int.$fIxInt32_$cindex_closure" {
     GHC.Int.$fIxInt32_$cindex_closure:
         const GHC.Int.$fIxInt32_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4o0T,
                       label: GHC.Int.$fIxInt32_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o0T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4o12; else goto c4o13;
       c4o12: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o13: // global
           I64[Sp - 16] = block_c4o0Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o1C; else goto c4o0R;
       u4o1C: // global
           call _c4o0Q(R1) args: 0, res: 0, upd: 0;
       c4o0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o0Q() //  [R1]
         { info_tbl: [(c4o0Q,
                       label: block_c4o0Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o0Q: // global
           I64[Sp - 8] = block_c4o0W_info;
           _s4lrz::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lrz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o1B; else goto c4o0X;
       u4o1B: // global
           call _c4o0W(R1) args: 0, res: 0, upd: 0;
       c4o0X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o0W() //  [R1]
         { info_tbl: [(c4o0W,
                       label: block_c4o0W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o0W: // global
           I64[Sp] = block_c4o11_info;
           _s4lrB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lrB::I64;
           if (R1 & 7 != 0) goto u4o1D; else goto c4o16;
       u4o1D: // global
           call _c4o11(R1) args: 0, res: 0, upd: 0;
       c4o16: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o11() //  [R1]
         { info_tbl: [(c4o11,
                       label: block_c4o11_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o11: // global
           _s4lrD::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lrD::I64)) goto c4o1e; else goto c4o1i;
       c4o1e: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4o1i: // global
           I64[Sp] = block_c4o1h_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrD::I64;
           if (R1 & 7 != 0) goto u4o1E; else goto c4o1j;
       u4o1E: // global
           call _c4o1h(R1) args: 0, res: 0, upd: 0;
       c4o1j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o1h() //  [R1]
         { info_tbl: [(c4o1h,
                       label: block_c4o1h_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o1h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4o1p; else goto c4o1o;
       c4o1p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4o1o: // global
           _s4lrD::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4lrD::I64,
                            I64[R1 + 7])) goto c4o1t; else goto c4o1A;
       c4o1t: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4o1A: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lrD::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.114116097 UTC

[section ""data" . GHC.Int.$fIxInt32_closure" {
     GHC.Int.$fIxInt32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fIxInt32_$crange_closure+1;
         const GHC.Int.$fIxInt32_$cindex_closure+2;
         const GHC.Int.$fIxInt32_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt32_$cinRange_closure+2;
         const GHC.Int.$fIxInt32_$crangeSize_closure+1;
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.115185006 UTC

[section ""data" . GHC.Int.eqInt64_closure" {
     GHC.Int.eqInt64_closure:
         const GHC.Int.eqInt64_info;
 },
 GHC.Int.eqInt64_entry() //  [R2, R3]
         { info_tbl: [(c4o1M,
                       label: GHC.Int.eqInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o1M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4o1Q; else goto c4o1R;
       c4o1Q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o1R: // global
           I64[Sp - 16] = block_c4o1J_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o20; else goto c4o1K;
       u4o20: // global
           call _c4o1J(R1) args: 0, res: 0, upd: 0;
       c4o1K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o1J() //  [R1]
         { info_tbl: [(c4o1J,
                       label: block_c4o1J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o1J: // global
           I64[Sp] = block_c4o1P_info;
           _s4lrM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrM::I64;
           if (R1 & 7 != 0) goto u4o1Z; else goto c4o1T;
       u4o1Z: // global
           call _c4o1P(R1) args: 0, res: 0, upd: 0;
       c4o1T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o1P() //  [R1]
         { info_tbl: [(c4o1P,
                       label: block_c4o1P_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o1P: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.116430962 UTC

[section ""data" . GHC.Int.$fEqInt64_closure" {
     GHC.Int.$fEqInt64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt64_closure+2;
         const GHC.Int.neInt64_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.117405503 UTC

[section ""data" . GHC.Int.gtInt64_closure" {
     GHC.Int.gtInt64_closure:
         const GHC.Int.gtInt64_info;
 },
 GHC.Int.gtInt64_entry() //  [R2, R3]
         { info_tbl: [(c4o28,
                       label: GHC.Int.gtInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o28: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4o2c; else goto c4o2d;
       c4o2c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o2d: // global
           I64[Sp - 16] = block_c4o25_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o2m; else goto c4o26;
       u4o2m: // global
           call _c4o25(R1) args: 0, res: 0, upd: 0;
       c4o26: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o25() //  [R1]
         { info_tbl: [(c4o25,
                       label: block_c4o25_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o25: // global
           I64[Sp] = block_c4o2b_info;
           _s4lrT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrT::I64;
           if (R1 & 7 != 0) goto u4o2l; else goto c4o2f;
       u4o2l: // global
           call _c4o2b(R1) args: 0, res: 0, upd: 0;
       c4o2f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o2b() //  [R1]
         { info_tbl: [(c4o2b,
                       label: block_c4o2b_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o2b: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.11904515 UTC

[section ""data" . GHC.Int.geInt64_closure" {
     GHC.Int.geInt64_closure:
         const GHC.Int.geInt64_info;
 },
 GHC.Int.geInt64_entry() //  [R2, R3]
         { info_tbl: [(c4o2u,
                       label: GHC.Int.geInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o2u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4o2y; else goto c4o2z;
       c4o2y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o2z: // global
           I64[Sp - 16] = block_c4o2r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o2I; else goto c4o2s;
       u4o2I: // global
           call _c4o2r(R1) args: 0, res: 0, upd: 0;
       c4o2s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o2r() //  [R1]
         { info_tbl: [(c4o2r,
                       label: block_c4o2r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o2r: // global
           I64[Sp] = block_c4o2x_info;
           _s4ls0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ls0::I64;
           if (R1 & 7 != 0) goto u4o2H; else goto c4o2B;
       u4o2H: // global
           call _c4o2x(R1) args: 0, res: 0, upd: 0;
       c4o2B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o2x() //  [R1]
         { info_tbl: [(c4o2x,
                       label: block_c4o2x_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o2x: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.120640271 UTC

[section ""data" . GHC.Int.ltInt64_closure" {
     GHC.Int.ltInt64_closure:
         const GHC.Int.ltInt64_info;
 },
 GHC.Int.ltInt64_entry() //  [R2, R3]
         { info_tbl: [(c4o2Q,
                       label: GHC.Int.ltInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o2Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4o2U; else goto c4o2V;
       c4o2U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o2V: // global
           I64[Sp - 16] = block_c4o2N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o34; else goto c4o2O;
       u4o34: // global
           call _c4o2N(R1) args: 0, res: 0, upd: 0;
       c4o2O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o2N() //  [R1]
         { info_tbl: [(c4o2N,
                       label: block_c4o2N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o2N: // global
           I64[Sp] = block_c4o2T_info;
           _s4ls7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ls7::I64;
           if (R1 & 7 != 0) goto u4o33; else goto c4o2X;
       u4o33: // global
           call _c4o2T(R1) args: 0, res: 0, upd: 0;
       c4o2X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o2T() //  [R1]
         { info_tbl: [(c4o2T,
                       label: block_c4o2T_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o2T: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.122317294 UTC

[section ""data" . GHC.Int.leInt64_closure" {
     GHC.Int.leInt64_closure:
         const GHC.Int.leInt64_info;
 },
 GHC.Int.leInt64_entry() //  [R2, R3]
         { info_tbl: [(c4o3c,
                       label: GHC.Int.leInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o3c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4o3g; else goto c4o3h;
       c4o3g: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o3h: // global
           I64[Sp - 16] = block_c4o39_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o3q; else goto c4o3a;
       u4o3q: // global
           call _c4o39(R1) args: 0, res: 0, upd: 0;
       c4o3a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o39() //  [R1]
         { info_tbl: [(c4o39,
                       label: block_c4o39_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o39: // global
           I64[Sp] = block_c4o3f_info;
           _s4lse::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lse::I64;
           if (R1 & 7 != 0) goto u4o3p; else goto c4o3j;
       u4o3p: // global
           call _c4o3f(R1) args: 0, res: 0, upd: 0;
       c4o3j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o3f() //  [R1]
         { info_tbl: [(c4o3f,
                       label: block_c4o3f_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o3f: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.124026269 UTC

[section ""data" . GHC.Int.$fOrdInt64_$ccompare_closure" {
     GHC.Int.$fOrdInt64_$ccompare_closure:
         const GHC.Int.$fOrdInt64_$ccompare_info;
 },
 GHC.Int.$fOrdInt64_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4o3y,
                       label: GHC.Int.$fOrdInt64_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o3y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4o3C; else goto c4o3D;
       c4o3C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o3D: // global
           I64[Sp - 16] = block_c4o3v_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o3W; else goto c4o3w;
       u4o3W: // global
           call _c4o3v(R1) args: 0, res: 0, upd: 0;
       c4o3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o3v() //  [R1]
         { info_tbl: [(c4o3v,
                       label: block_c4o3v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o3v: // global
           I64[Sp] = block_c4o3B_info;
           _s4lsl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lsl::I64;
           if (R1 & 7 != 0) goto u4o3V; else goto c4o3F;
       u4o3V: // global
           call _c4o3B(R1) args: 0, res: 0, upd: 0;
       c4o3F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o3B() //  [R1]
         { info_tbl: [(c4o3B,
                       label: block_c4o3B_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o3B: // global
           _s4lsl::I64 = I64[Sp + 8];
           _s4lsn::I64 = I64[R1 + 7];
           if (_s4lsl::I64 == _s4lsn::I64) goto c4o3U; else goto c4o3T;
       c4o3U: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4o3T: // global
           if (%MO_S_Gt_W64(_s4lsl::I64,
                            _s4lsn::I64)) goto c4o3Q; else goto c4o3R;
       c4o3Q: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4o3R: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.127171809 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmax_closure" {
     GHC.Int.$fOrdInt64_$cmax_closure:
         const GHC.Int.$fOrdInt64_$cmax_info;
 },
 GHC.Int.$fOrdInt64_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4o44,
                       label: GHC.Int.$fOrdInt64_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o44: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4o48; else goto c4o49;
       c4o48: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o49: // global
           I64[Sp - 16] = block_c4o41_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o4m; else goto c4o42;
       u4o4m: // global
           call _c4o41(R1) args: 0, res: 0, upd: 0;
       c4o42: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o41() //  [R1]
         { info_tbl: [(c4o41,
                       label: block_c4o41_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o41: // global
           I64[Sp - 8] = block_c4o47_info;
           _s4lss::P64 = R1;
           _s4lst::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lst::I64;
           P64[Sp + 8] = _s4lss::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o4l; else goto c4o4b;
       u4o4l: // global
           call _c4o47(R1) args: 0, res: 0, upd: 0;
       c4o4b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o47() //  [R1]
         { info_tbl: [(c4o47,
                       label: block_c4o47_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o47: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4o4j; else goto c4o4k;
       c4o4j: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4o4k: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.128943002 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmin_closure" {
     GHC.Int.$fOrdInt64_$cmin_closure:
         const GHC.Int.$fOrdInt64_$cmin_info;
 },
 GHC.Int.$fOrdInt64_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4o4u,
                       label: GHC.Int.$fOrdInt64_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o4u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4o4y; else goto c4o4z;
       c4o4y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o4z: // global
           I64[Sp - 16] = block_c4o4r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o4M; else goto c4o4s;
       u4o4M: // global
           call _c4o4r(R1) args: 0, res: 0, upd: 0;
       c4o4s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o4r() //  [R1]
         { info_tbl: [(c4o4r,
                       label: block_c4o4r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o4r: // global
           I64[Sp - 8] = block_c4o4x_info;
           _s4lsz::P64 = R1;
           _s4lsA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lsA::I64;
           P64[Sp + 8] = _s4lsz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o4L; else goto c4o4B;
       u4o4L: // global
           call _c4o4x(R1) args: 0, res: 0, upd: 0;
       c4o4B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o4x() //  [R1]
         { info_tbl: [(c4o4x,
                       label: block_c4o4x_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o4x: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4o4J; else goto c4o4K;
       c4o4J: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4o4K: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.130332561 UTC

[section ""data" . GHC.Int.$fOrdInt64_closure" {
     GHC.Int.$fOrdInt64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fOrdInt64_$ccompare_closure+2;
         const GHC.Int.ltInt64_closure+2;
         const GHC.Int.leInt64_closure+2;
         const GHC.Int.gtInt64_closure+2;
         const GHC.Int.geInt64_closure+2;
         const GHC.Int.$fOrdInt64_$cmax_closure+2;
         const GHC.Int.$fOrdInt64_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.13145881 UTC

[section ""data" . GHC.Int.$fIxInt64_$cinRange_closure" {
     GHC.Int.$fIxInt64_$cinRange_closure:
         const GHC.Int.$fIxInt64_$cinRange_info;
 },
 GHC.Int.$fIxInt64_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4o4U,
                       label: GHC.Int.$fIxInt64_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o4U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4o53; else goto c4o54;
       c4o53: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o54: // global
           I64[Sp - 16] = block_c4o4R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o5r; else goto c4o4S;
       u4o5r: // global
           call _c4o4R(R1) args: 0, res: 0, upd: 0;
       c4o4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o4R() //  [R1]
         { info_tbl: [(c4o4R,
                       label: block_c4o4R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o4R: // global
           I64[Sp - 8] = block_c4o4X_info;
           _s4lsI::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lsI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o5q; else goto c4o4Y;
       u4o5q: // global
           call _c4o4X(R1) args: 0, res: 0, upd: 0;
       c4o4Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o4X() //  [R1]
         { info_tbl: [(c4o4X,
                       label: block_c4o4X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o4X: // global
           I64[Sp] = block_c4o52_info;
           _s4lsK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lsK::I64;
           if (R1 & 7 != 0) goto u4o5s; else goto c4o57;
       u4o5s: // global
           call _c4o52(R1) args: 0, res: 0, upd: 0;
       c4o57: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o52() //  [R1]
         { info_tbl: [(c4o52,
                       label: block_c4o52_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o52: // global
           _s4lsM::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lsM::I64)) goto c4o5f; else goto c4o5j;
       c4o5f: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4o5j: // global
           _s4lsI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4o5i_info;
           R1 = _s4lsI::P64;
           I64[Sp + 16] = _s4lsM::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4o5t; else goto c4o5k;
       u4o5t: // global
           call _c4o5i(R1) args: 0, res: 0, upd: 0;
       c4o5k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o5i() //  [R1]
         { info_tbl: [(c4o5i,
                       label: block_c4o5i_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o5i: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.133226615 UTC

[section ""data" . GHC.Int.$fNumInt5_closure" {
     GHC.Int.$fNumInt5_closure:
         const GHC.Int.I64#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.134161819 UTC

[section ""data" . GHC.Int.$fNumInt64_$csignum_closure" {
     GHC.Int.$fNumInt64_$csignum_closure:
         const GHC.Int.$fNumInt64_$csignum_info;
 },
 GHC.Int.$fNumInt64_$csignum_entry() //  [R2]
         { info_tbl: [(c4o5B,
                       label: GHC.Int.$fNumInt64_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o5B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4o5C; else goto c4o5D;
       c4o5C: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4o5D: // global
           I64[Sp - 8] = block_c4o5y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o5R; else goto c4o5z;
       u4o5R: // global
           call _c4o5y(R1) args: 0, res: 0, upd: 0;
       c4o5z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o5y() //  [R1]
         { info_tbl: [(c4o5y,
                       label: block_c4o5y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o5y: // global
           _s4lsT::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lsT::I64, 0)) goto c4o5P; else goto c4o5Q;
       c4o5P: // global
           if (_s4lsT::I64 == 0) goto c4o5N; else goto c4o5M;
       c4o5N: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4o5M: // global
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4o5Q: // global
           R1 = GHC.Int.$fNumInt5_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.135661944 UTC

[section ""data" . GHC.Int.$fNumInt64_$cabs_closure" {
     GHC.Int.$fNumInt64_$cabs_closure:
         const GHC.Int.$fNumInt64_$cabs_info;
 },
 GHC.Int.$fNumInt64_$cabs_entry() //  [R2]
         { info_tbl: [(c4o5Z,
                       label: GHC.Int.$fNumInt64_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o5Z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4o60; else goto c4o61;
       c4o60: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4o61: // global
           I64[Sp - 8] = block_c4o5W_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o6h; else goto c4o5X;
       u4o6h: // global
           call _c4o5W(R1) args: 0, res: 0, upd: 0;
       c4o5X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o5W() //  [R1]
         { info_tbl: [(c4o5W,
                       label: block_c4o5W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o5W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4o66; else goto c4o65;
       c4o66: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4o65: // global
           _s4lsY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lsY::I64, 0)) goto c4o6f; else goto c4o6g;
       c4o6f: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = -_s4lsY::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4o6g: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.136810613 UTC

[section ""data" . GHC.Int.$fNumInt64_closure" {
     GHC.Int.$fNumInt64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt64_$c+_closure+2;
         const GHC.Int.$fNumInt64_$c-_closure+2;
         const GHC.Int.$fNumInt64_$c*_closure+2;
         const GHC.Int.$fNumInt64_$cnegate_closure+1;
         const GHC.Int.$fNumInt64_$cabs_closure+1;
         const GHC.Int.$fNumInt64_$csignum_closure+1;
         const GHC.Int.$fNumInt64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.137684347 UTC

[section ""data" . GHC.Int.$fBitsInt9_closure" {
     GHC.Int.$fBitsInt9_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.138371049 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt64_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4o6m,
                       label: GHC.Int.$fBitsInt64_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o6m: // global
           R1 = GHC.Int.$fBitsInt9_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.139480441 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbit_closure" {
     GHC.Int.$fBitsInt64_$cbit_closure:
         const GHC.Int.$fBitsInt64_$cbit_info;
 },
 GHC.Int.$fBitsInt64_$cbit_entry() //  [R2]
         { info_tbl: [(c4o6w,
                       label: GHC.Int.$fBitsInt64_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o6w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4o6x; else goto c4o6y;
       c4o6x: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4o6y: // global
           I64[Sp - 8] = block_c4o6t_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o6O; else goto c4o6u;
       u4o6O: // global
           call _c4o6t(R1) args: 0, res: 0, upd: 0;
       c4o6u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o6t() //  [R1]
         { info_tbl: [(c4o6t,
                       label: block_c4o6t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o6t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4o6D; else goto c4o6C;
       c4o6D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4o6C: // global
           _s4lt4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lt4::I64, 64)) goto c4o6M; else goto c4o6N;
       c4o6M: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = 1 << _s4lt4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4o6N: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.141162591 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ctestBit_closure" {
     GHC.Int.$fBitsInt64_$ctestBit_closure:
         const GHC.Int.$fBitsInt64_$ctestBit_info;
 },
 GHC.Int.$fBitsInt64_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4o6W,
                       label: GHC.Int.$fBitsInt64_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o6W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4o70; else goto c4o71;
       c4o70: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o71: // global
           I64[Sp - 16] = block_c4o6T_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o7G; else goto c4o6U;
       u4o7G: // global
           call _c4o6T(R1) args: 0, res: 0, upd: 0;
       c4o6U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o6T() //  [R1]
         { info_tbl: [(c4o6T,
                       label: block_c4o6T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o6T: // global
           I64[Sp] = block_c4o6Z_info;
           _s4lta::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lta::I64;
           if (R1 & 7 != 0) goto u4o7F; else goto c4o73;
       u4o7F: // global
           call _c4o6Z(R1) args: 0, res: 0, upd: 0;
       c4o73: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o6Z() //  [R1]
         { info_tbl: [(c4o6Z,
                       label: block_c4o6Z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o6Z: // global
           _s4ltc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4ltc::I64, 64)) goto c4o7E; else goto c4o7D;
       c4o7D: // global
           if (I64[Sp + 8] & (1 << _s4ltc::I64) == 0) goto c4o7E; else goto c4o7s;
       c4o7E: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4o7s: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.143181145 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateR_closure" {
     GHC.Int.$fBitsInt64_$crotateR_closure:
         const GHC.Int.$fBitsInt64_$crotateR_info;
 },
 GHC.Int.$fBitsInt64_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4o7O,
                       label: GHC.Int.$fBitsInt64_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o7O: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4o7S; else goto c4o7T;
       c4o7S: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o7T: // global
           I64[Sp - 16] = block_c4o7L_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o8M; else goto c4o7M;
       u4o8M: // global
           call _c4o7L(R1) args: 0, res: 0, upd: 0;
       c4o7M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o7L() //  [R1]
         { info_tbl: [(c4o7L,
                       label: block_c4o7L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o7L: // global
           I64[Sp - 8] = block_c4o7R_info;
           _s4ltl::P64 = R1;
           _s4ltm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4ltm::I64;
           P64[Sp + 8] = _s4ltl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o8L; else goto c4o7V;
       u4o8L: // global
           call _c4o7R(R1) args: 0, res: 0, upd: 0;
       c4o7V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o7R() //  [R1]
         { info_tbl: [(c4o7R,
                       label: block_c4o7R_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o7R: // global
           _s4lts::I64 = -I64[R1 + 7] & 63;
           if (_s4lts::I64 != 0) goto u4o8J; else goto c4o8F;
       u4o8J: // global
           I64[Sp + 16] = _s4lts::I64;
           Sp = Sp + 8;
           call _c4o8d() args: 0, res: 0, upd: 0;
       c4o8F: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4o8d() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o8d: // global
           Hp = Hp + 16;
           _s4lts::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4o8C; else goto c4o8B;
       c4o8C: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4o8c_info;
           R1 = _s4lts::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4o8B: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4ltt::I64 = I64[Sp];
           I64[Hp] = (_s4ltt::I64 << _s4lts::I64) | (_s4ltt::I64 >> 64 - _s4lts::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4o8c() //  [R1]
         { info_tbl: [(c4o8c,
                       label: block_c4o8c_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o8c: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4o8d() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.145467925 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt64_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt64_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt64_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4o8W,
                       label: GHC.Int.$fBitsInt64_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o8W: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4o90; else goto c4o91;
       c4o90: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o91: // global
           I64[Sp - 16] = block_c4o8T_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4o9x; else goto c4o8U;
       u4o9x: // global
           call _c4o8T(R1) args: 0, res: 0, upd: 0;
       c4o8U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o8T() //  [R1]
         { info_tbl: [(c4o8T,
                       label: block_c4o8T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o8T: // global
           I64[Sp - 8] = block_c4o8Z_info;
           _s4ltB::P64 = R1;
           _s4ltC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4ltC::I64;
           P64[Sp + 8] = _s4ltB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4o9w; else goto c4o93;
       u4o9w: // global
           call _c4o8Z(R1) args: 0, res: 0, upd: 0;
       c4o93: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o8Z() //  [R1]
         { info_tbl: [(c4o8Z,
                       label: block_c4o8Z_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o8Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4o99; else goto c4o98;
       c4o99: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4o98: // global
           _s4ltE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4ltE::I64, 64)) goto c4o9u; else goto c4o9v;
       c4o9u: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s4ltE::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4o9v: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.147440173 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cclearBit_closure" {
     GHC.Int.$fBitsInt64_$cclearBit_closure:
         const GHC.Int.$fBitsInt64_$cclearBit_info;
 },
 GHC.Int.$fBitsInt64_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4o9F,
                       label: GHC.Int.$fBitsInt64_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o9F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4o9J; else goto c4o9K;
       c4o9J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4o9K: // global
           I64[Sp - 16] = block_c4o9C_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oau; else goto c4o9D;
       u4oau: // global
           call _c4o9C(R1) args: 0, res: 0, upd: 0;
       c4o9D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o9C() //  [R1]
         { info_tbl: [(c4o9C,
                       label: block_c4o9C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o9C: // global
           I64[Sp] = block_c4o9I_info;
           _s4ltO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ltO::I64;
           if (R1 & 7 != 0) goto u4oat; else goto c4o9M;
       u4oat: // global
           call _c4o9I(R1) args: 0, res: 0, upd: 0;
       c4o9M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4o9I() //  [R1]
         { info_tbl: [(c4o9I,
                       label: block_c4o9I_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4o9I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4o9S; else goto c4o9R;
       c4o9S: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4o9R: // global
           _s4ltO::I64 = I64[Sp + 8];
           _s4ltQ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4ltQ::I64, 64)) goto c4oag; else goto c4oas;
       c4oag: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4ltO::I64 & (1 << _s4ltQ::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oas: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4ltO::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.149535114 UTC

[section ""data" . GHC.Int.$fBitsInt64_$csetBit_closure" {
     GHC.Int.$fBitsInt64_$csetBit_closure:
         const GHC.Int.$fBitsInt64_$csetBit_info;
 },
 GHC.Int.$fBitsInt64_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4oaC,
                       label: GHC.Int.$fBitsInt64_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oaC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oaG; else goto c4oaH;
       c4oaG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oaH: // global
           I64[Sp - 16] = block_c4oaz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4obd; else goto c4oaA;
       u4obd: // global
           call _c4oaz(R1) args: 0, res: 0, upd: 0;
       c4oaA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oaz() //  [R1]
         { info_tbl: [(c4oaz,
                       label: block_c4oaz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oaz: // global
           I64[Sp - 8] = block_c4oaF_info;
           _s4lu3::P64 = R1;
           _s4lu4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lu4::I64;
           P64[Sp + 8] = _s4lu3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4obc; else goto c4oaJ;
       u4obc: // global
           call _c4oaF(R1) args: 0, res: 0, upd: 0;
       c4oaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oaF() //  [R1]
         { info_tbl: [(c4oaF,
                       label: block_c4oaF_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oaF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oaP; else goto c4oaO;
       c4oaP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4oaO: // global
           _s4lu6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lu6::I64, 64)) goto c4oba; else goto c4obb;
       c4oba: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s4lu6::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4obb: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.152037025 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateL_closure" {
     GHC.Int.$fBitsInt64_$crotateL_closure:
         const GHC.Int.$fBitsInt64_$crotateL_info;
 },
 GHC.Int.$fBitsInt64_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4obi,
                       label: GHC.Int.$fBitsInt64_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4obi: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt64_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.152806104 UTC

[section ""data" . GHC.Int.$fBitsInt64_closure" {
     GHC.Int.$fBitsInt64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fBitsInt64_$c.&._closure+2;
         const GHC.Int.$fBitsInt64_$c.|._closure+2;
         const GHC.Int.$fBitsInt64_$cxor_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt64_$cshift_closure+2;
         const GHC.Int.$fBitsInt64_$crotate_closure+2;
         const GHC.Int.$fBitsInt10_closure+1;
         const GHC.Int.$fBitsInt64_$cbit_closure+1;
         const GHC.Int.$fBitsInt64_$csetBit_closure+2;
         const GHC.Int.$fBitsInt64_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt64_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt64_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt64_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt64_$crotateL_closure+2;
         const GHC.Int.$fBitsInt64_$crotateR_closure+2;
         const GHC.Int.$fBitsInt64_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.153762564 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_closure" {
     GHC.Int.$fFiniteBitsInt64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt64_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.155173185 UTC

[section ""data" . GHC.Int.$fReadInt64_go_closure" {
     GHC.Int.$fReadInt64_go_closure:
         const GHC.Int.$fReadInt64_go_info;
 },
 sat_s4luo_entry() //  [R1]
         { info_tbl: [(c4obE,
                       label: sat_s4luo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4obE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4obF; else goto c4obG;
       c4obF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4obG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lum_entry() //  [R1]
         { info_tbl: [(c4obO,
                       label: sat_s4lum_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4obO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4obS; else goto c4obT;
       c4obS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4obT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4obL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4obX; else goto c4obM;
       u4obX: // global
           call _c4obL(R1) args: 0, res: 0, upd: 0;
       c4obM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4obL() //  [R1]
         { info_tbl: [(c4obL,
                       label: block_c4obL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4obL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4obW; else goto c4obV;
       c4obW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4obV: // global
           _s4lul::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lul::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt64_go_entry() //  [R2]
         { info_tbl: [(c4oc2,
                       label: GHC.Int.$fReadInt64_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oc2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oc3; else goto c4oc4;
       c4oc3: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oc4: // global
           I64[Sp - 8] = block_c4obp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oce; else goto c4obq;
       u4oce: // global
           call _c4obp(R1) args: 0, res: 0, upd: 0;
       c4obq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4obp() //  [R1]
         { info_tbl: [(c4obp,
                       label: block_c4obp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4obp: // global
           if (R1 & 7 == 1) goto c4obZ; else goto c4oc0;
       c4obZ: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oc0: // global
           I64[Sp - 8] = block_c4obv_info;
           _s4lug::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lug::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ocd; else goto c4obw;
       u4ocd: // global
           call _c4obv(R1) args: 0, res: 0, upd: 0;
       c4obw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4obv() //  [R1]
         { info_tbl: [(c4obv,
                       label: block_c4obv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4obv: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4occ; else goto c4ocb;
       c4occ: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ocb: // global
           _s4lui::P64 = P64[R1 + 7];
           _s4luj::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4luo_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lum_info;
           P64[Hp - 48] = _s4lui::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4luj::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.157661382 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadsPrec_closure" {
     GHC.Int.$fReadInt64_$creadsPrec_closure:
         const GHC.Int.$fReadInt64_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4ocl,
                       label: GHC.Int.$fReadInt64_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ocl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ocp; else goto c4ocq;
       c4ocp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ocq: // global
           I64[Sp - 16] = block_c4ocj_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4luq::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4luq::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ocj() //  [R1]
         { info_tbl: [(c4ocj,
                       label: block_c4ocj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ocj: // global
           _s4luq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4oco_info;
           R3 = _s4luq::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oco() //  [R1]
         { info_tbl: [(c4oco,
                       label: block_c4oco_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oco: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.15920926 UTC

[section ""data" . GHC.Int.$fReadInt10_closure" {
     GHC.Int.$fReadInt10_closure:
         const GHC.Int.$fReadInt10_info;
         const 0;
 },
 sat_s4luv_entry() //  [R1, R2]
         { info_tbl: [(c4ocF,
                       label: sat_s4luv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ocF: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt64_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt10_entry() //  [R2, R3]
         { info_tbl: [(c4ocL,
                       label: GHC.Int.$fReadInt10_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ocL: // global
           _s4luu::P64 = R3;
           _s4lut::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4ocM; else goto c4ocN;
       c4ocN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ocP; else goto c4ocO;
       c4ocP: // global
           HpAlloc = 16;
           goto c4ocM;
       c4ocM: // global
           R3 = _s4luu::P64;
           R2 = _s4lut::P64;
           R1 = GHC.Int.$fReadInt10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ocO: // global
           I64[Hp - 8] = sat_s4luv_info;
           P64[Hp] = _s4lut::P64;
           I64[Sp - 8] = block_c4ocI_info;
           R3 = _s4luu::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ocI() //  [R1]
         { info_tbl: [(c4ocI,
                       label: block_c4ocI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ocI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ocS; else goto c4ocR;
       c4ocS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ocR: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.160743259 UTC

[section ""data" . GHC.Int.$fReadInt9_closure" {
     GHC.Int.$fReadInt9_closure:
         const GHC.Int.$fReadInt9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4od2_srtd" {
     u4od2_srtd:
         const S4lDl_srt+504;
         const 70;
         const 1;
         const 32;
 },
 GHC.Int.$fReadInt9_entry() //  [R1]
         { info_tbl: [(c4ocZ,
                       label: GHC.Int.$fReadInt9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ocZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4od0; else goto c4od1;
       c4od0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4od1: // global
           (_c4ocW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4ocW::I64 == 0) goto c4ocY; else goto c4ocX;
       c4ocY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4ocX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4ocW::I64;
           R2 = GHC.Int.$fReadInt10_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.161907367 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadList_closure" {
     GHC.Int.$fReadInt64_$creadList_closure:
         const GHC.Int.$fReadInt64_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadList_entry() //  [R2]
         { info_tbl: [(c4od7,
                       label: GHC.Int.$fReadInt64_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4od7: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt9_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.162917768 UTC

[section ""data" . GHC.Int.$fReadInt7_closure" {
     GHC.Int.$fReadInt7_closure:
         const GHC.Int.$fReadInt7_info;
         const 0;
 },
 GHC.Int.$fReadInt7_entry() //  [R2, R3]
         { info_tbl: [(c4odh,
                       label: GHC.Int.$fReadInt7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4odh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4odi; else goto c4odj;
       c4odi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4odj: // global
           I64[Sp - 8] = block_c4ode_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt64_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ode() //  [R1]
         { info_tbl: [(c4ode,
                       label: block_c4ode_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ode: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4odm; else goto c4odl;
       c4odm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4odl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.163985018 UTC

[section ""data" . GHC.Int.$fReadInt64_closure" {
     GHC.Int.$fReadInt64_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt64_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt64_$creadList_closure+1;
         const GHC.Int.$fReadInt10_closure+2;
         const GHC.Int.$fReadInt7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.165158715 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquot_closure" {
     GHC.Int.$fIntegralInt64_$cquot_closure:
         const GHC.Int.$fIntegralInt64_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4odu,
                       label: GHC.Int.$fIntegralInt64_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4odu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ody; else goto c4odz;
       c4ody: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4odz: // global
           I64[Sp - 16] = block_c4odr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oe4; else goto c4ods;
       u4oe4: // global
           call _c4odr(R1) args: 0, res: 0, upd: 0;
       c4ods: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4odr() //  [R1]
         { info_tbl: [(c4odr,
                       label: block_c4odr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4odr: // global
           I64[Sp] = block_c4odx_info;
           _s4luF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4luF::I64;
           if (R1 & 7 != 0) goto u4oe3; else goto c4odB;
       u4oe3: // global
           call _c4odx(R1) args: 0, res: 0, upd: 0;
       c4odB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4odx() //  [R1]
         { info_tbl: [(c4odx,
                       label: block_c4odx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4odx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4odH; else goto c4odG;
       c4odH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4odG: // global
           _s4luF::I64 = I64[Sp + 8];
           _s4luI::I64 = I64[R1 + 7];
           if (_s4luI::I64 != (-1)) goto u4oe2; else goto c4oe0;
       u4oe2: // global
           if (_s4luI::I64 != 0) goto c4odP; else goto c4oe1;
       c4odP: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4luF::I64, _s4luI::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oe1: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4oe0: // global
           if (_s4luF::I64 == (-9223372036854775808)) goto c4odZ; else goto c4odY;
       c4odZ: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4odY: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4luF::I64, (-1));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.167306176 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$crem_closure" {
     GHC.Int.$fIntegralInt64_$crem_closure:
         const GHC.Int.$fIntegralInt64_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4oec,
                       label: GHC.Int.$fIntegralInt64_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oec: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oeg; else goto c4oeh;
       c4oeg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oeh: // global
           I64[Sp - 16] = block_c4oe9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oeC; else goto c4oea;
       u4oeC: // global
           call _c4oe9(R1) args: 0, res: 0, upd: 0;
       c4oea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oe9() //  [R1]
         { info_tbl: [(c4oe9,
                       label: block_c4oe9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oe9: // global
           I64[Sp] = block_c4oef_info;
           _s4luR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4luR::I64;
           if (R1 & 7 != 0) goto u4oeB; else goto c4oej;
       u4oeB: // global
           call _c4oef(R1) args: 0, res: 0, upd: 0;
       c4oej: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oef() //  [R1]
         { info_tbl: [(c4oef,
                       label: block_c4oef_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oef: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oep; else goto c4oeo;
       c4oep: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4oeo: // global
           _s4luU::I64 = I64[R1 + 7];
           if (_s4luU::I64 != (-1)) goto u4oeA; else goto c4oey;
       u4oeA: // global
           if (_s4luU::I64 != 0) goto c4oex; else goto c4oez;
       c4oex: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Rem_W64(I64[Sp + 8], _s4luU::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oez: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4oey: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.169038138 UTC

[section ""data" . GHC.Int.$w$cdiv2_closure" {
     GHC.Int.$w$cdiv2_closure:
         const GHC.Int.$w$cdiv2_info;
         const 0;
 },
 GHC.Int.$w$cdiv2_entry() //  [R2, R3]
         { info_tbl: [(c4oeM,
                       label: GHC.Int.$w$cdiv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oeM: // global
           if (R3 == (-1)) goto c4oeK; else goto u4oeV;
       c4oeK: // global
           if (R2 == (-9223372036854775808)) goto c4oeU; else goto c4oeT;
       c4oeU: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4oeT: // global
           R3 = (-1);
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
       u4oeV: // global
           if (R3 == 0) goto c4oeL; else goto c4oeJ;
       c4oeL: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4oeJ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.170623139 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdiv_closure" {
     GHC.Int.$fIntegralInt64_$cdiv_closure:
         const GHC.Int.$fIntegralInt64_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4of3,
                       label: GHC.Int.$fIntegralInt64_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4of3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ofg; else goto c4ofh;
       c4ofg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ofh: // global
           I64[Sp - 16] = block_c4of0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ofo; else goto c4of1;
       u4ofo: // global
           call _c4of0(R1) args: 0, res: 0, upd: 0;
       c4of1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4of0() //  [R1]
         { info_tbl: [(c4of0,
                       label: block_c4of0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4of0: // global
           I64[Sp] = block_c4of6_info;
           _s4lv5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lv5::I64;
           if (R1 & 7 != 0) goto u4ofn; else goto c4of7;
       u4ofn: // global
           call _c4of6(R1) args: 0, res: 0, upd: 0;
       c4of7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4of6() //  [R1]
         { info_tbl: [(c4of6,
                       label: block_c4of6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4of6: // global
           _s4lv5::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4ofb_info;
           R3 = I64[R1 + 7];
           R2 = _s4lv5::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ofb() //  [R1]
         { info_tbl: [(c4ofb,
                       label: block_c4ofb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ofb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ofm; else goto c4ofl;
       c4ofm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ofl: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.172653309 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cmod_closure" {
     GHC.Int.$fIntegralInt64_$cmod_closure:
         const GHC.Int.$fIntegralInt64_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4ofw,
                       label: GHC.Int.$fIntegralInt64_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ofw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ofA; else goto c4ofB;
       c4ofA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ofB: // global
           I64[Sp - 16] = block_c4oft_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ofY; else goto c4ofu;
       u4ofY: // global
           call _c4oft(R1) args: 0, res: 0, upd: 0;
       c4ofu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oft() //  [R1]
         { info_tbl: [(c4oft,
                       label: block_c4oft_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oft: // global
           I64[Sp] = block_c4ofz_info;
           _s4lvc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lvc::I64;
           if (R1 & 7 != 0) goto u4ofX; else goto c4ofD;
       u4ofX: // global
           call _c4ofz(R1) args: 0, res: 0, upd: 0;
       c4ofD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ofz() //  [R1]
         { info_tbl: [(c4ofz,
                       label: block_c4ofz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ofz: // global
           _s4lvf::I64 = I64[R1 + 7];
           if (_s4lvf::I64 != (-1)) goto u4ofW; else goto c4ofU;
       u4ofW: // global
           if (_s4lvf::I64 != 0) goto c4ofQ; else goto c4ofV;
       c4ofQ: // global
           _s4lvc::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4ofK_info;
           R3 = _s4lvf::I64;
           R2 = _s4lvc::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4ofV: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4ofU: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4ofK() //  [R1]
         { info_tbl: [(c4ofK,
                       label: block_c4ofK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ofK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ofT; else goto c4ofS;
       c4ofT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ofS: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.175321007 UTC

[section ""data" . lvl9_r4kPA_closure" {
     lvl9_r4kPA_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt10_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.176647997 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquotRem_closure" {
     GHC.Int.$fIntegralInt64_$cquotRem_closure:
         const GHC.Int.$fIntegralInt64_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4og6,
                       label: GHC.Int.$fIntegralInt64_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4og6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oga; else goto c4ogb;
       c4oga: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ogb: // global
           I64[Sp - 16] = block_c4og3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ogE; else goto c4og4;
       u4ogE: // global
           call _c4og3(R1) args: 0, res: 0, upd: 0;
       c4og4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4og3() //  [R1]
         { info_tbl: [(c4og3,
                       label: block_c4og3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4og3: // global
           I64[Sp] = block_c4og9_info;
           _s4lvl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lvl::I64;
           if (R1 & 7 != 0) goto u4ogD; else goto c4ogd;
       u4ogD: // global
           call _c4og9(R1) args: 0, res: 0, upd: 0;
       c4ogd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4og9() //  [R1]
         { info_tbl: [(c4og9,
                       label: block_c4og9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4og9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4ogj; else goto c4ogi;
       c4ogj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ogi: // global
           _s4lvl::I64 = I64[Sp + 8];
           _s4lvo::I64 = I64[R1 + 7];
           if (_s4lvo::I64 != (-1)) goto u4ogC; else goto c4ogA;
       u4ogC: // global
           if (_s4lvo::I64 != 0) goto c4ogq; else goto c4ogB;
       c4ogq: // global
           (_s4lvq::I64, _s4lvr::I64) = call MO_S_QuotRem W64(_s4lvl::I64, _s4lvo::I64);
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4lvr::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4lvq::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ogB: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4ogA: // global
           if (_s4lvl::I64 == (-9223372036854775808)) goto c4ogz; else goto c4ogy;
       c4ogz: // global
           Hp = Hp - 56;
           R1 = lvl9_r4kPA_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ogy: // global
           (_s4lvw::I64, _s4lvx::I64) = call MO_S_QuotRem W64(_s4lvl::I64, (-1));
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4lvx::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4lvw::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.179618861 UTC

[section ""data" . GHC.Int.$w$cdivMod2_closure" {
     GHC.Int.$w$cdivMod2_closure:
         const GHC.Int.$w$cdivMod2_info;
         const 0;
 },
 GHC.Int.$w$cdivMod2_entry() //  [R2, R3]
         { info_tbl: [(c4ogN,
                       label: GHC.Int.$w$cdivMod2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ogN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ogO; else goto c4ogP;
       c4ogO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ogP: // global
           if (R3 == 0) goto c4ogM; else goto c4ogL;
       c4ogM: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4ogL: // global
           if (R3 == (-1)) goto c4oiC; else goto u4oiD;
       c4oiC: // global
           if (R2 == (-9223372036854775808)) goto c4oiB; else goto u4oiE;
       c4oiB: // global
           R2 = GHC.Int.$fBitsInt10_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4oiE: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4oiG;
       u4oiD: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4oiG;
       u4oiG: // global
           call _c4ogU() args: 0, res: 0, upd: 0;
     }
 },
 _c4ogU() //  []
         { info_tbl: [(c4ogU,
                       label: block_c4ogU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ogU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4ogY; else goto c4ogX;
       c4ogY: // global
           HpAlloc = 32;
           I64[Sp] = block_c4ogU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4ogX: // global
           _s4lvB::I64 = I64[Sp + 8];
           _s4lvD::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lvB::I64, 0)) goto c4ohz; else goto c4ois;
       c4ohz: // global
           if (%MO_S_Ge_W64(_s4lvB::I64, 0)) goto c4oh8; else goto c4ohx;
       c4oh8: // global
           (_s4lvI::I64, _s4lvJ::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvJ::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvI::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ohx: // global
           if (%MO_S_Le_W64(_s4lvD::I64, 0)) goto c4ohg; else goto c4ohw;
       c4ohg: // global
           (_s4lvO::I64, _s4lvP::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvP::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvO::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ohw: // global
           (_s4lvU::I64, _s4lvV::I64) = call MO_S_QuotRem W64(_s4lvB::I64 + 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvV::I64 + _s4lvD::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvU::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ois: // global
           if (%MO_S_Ge_W64(_s4lvD::I64, 0)) goto c4oib; else goto c4oir;
       c4oib: // global
           if (%MO_S_Ge_W64(_s4lvB::I64, 0)) goto c4ohK; else goto c4oi9;
       c4ohK: // global
           (_s4lw4::I64, _s4lw5::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lw5::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lw4::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4oi9: // global
           if (%MO_S_Le_W64(_s4lvD::I64, 0)) goto c4ohS; else goto c4oi8;
       c4ohS: // global
           (_s4lwa::I64, _s4lwb::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwb::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwa::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4oi8: // global
           (_s4lwg::I64, _s4lwh::I64) = call MO_S_QuotRem W64(_s4lvB::I64 + 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwh::I64 + _s4lvD::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwg::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4oir: // global
           (_s4lwp::I64, _s4lwq::I64) = call MO_S_QuotRem W64(_s4lvB::I64 - 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwq::I64 + _s4lvD::I64 + 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwp::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.182422992 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdivMod_closure" {
     GHC.Int.$fIntegralInt64_$cdivMod_closure:
         const GHC.Int.$fIntegralInt64_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4oiO,
                       label: GHC.Int.$fIntegralInt64_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oiO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oiZ; else goto c4oj0;
       c4oiZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oj0: // global
           I64[Sp - 16] = block_c4oiL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oj7; else goto c4oiM;
       u4oj7: // global
           call _c4oiL(R1) args: 0, res: 0, upd: 0;
       c4oiM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oiL() //  [R1]
         { info_tbl: [(c4oiL,
                       label: block_c4oiL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oiL: // global
           I64[Sp] = block_c4oiR_info;
           _s4lwC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lwC::I64;
           if (R1 & 7 != 0) goto u4oj6; else goto c4oiS;
       u4oj6: // global
           call _c4oiR(R1) args: 0, res: 0, upd: 0;
       c4oiS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oiR() //  [R1]
         { info_tbl: [(c4oiR,
                       label: block_c4oiR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oiR: // global
           _s4lwC::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4oiW_info;
           R3 = I64[R1 + 7];
           R2 = _s4lwC::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oiW() //  [R1, R2]
         { info_tbl: [(c4oiW,
                       label: block_c4oiW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oiW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oj5; else goto c4oj4;
       c4oj5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oj4: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.184086673 UTC

[section ""data" . GHC.Int.$fIxInt64_$crange_closure" {
     GHC.Int.$fIxInt64_$crange_closure:
         const GHC.Int.$fIxInt64_$crange_info;
 },
 GHC.Int.$fIxInt64_$crange_entry() //  [R2]
         { info_tbl: [(c4ojf,
                       label: GHC.Int.$fIxInt64_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ojf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ojg; else goto c4ojh;
       c4ojg: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ojh: // global
           I64[Sp - 8] = block_c4ojc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ojl; else goto c4ojd;
       u4ojl: // global
           call _c4ojc(R1) args: 0, res: 0, upd: 0;
       c4ojd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ojc() //  [R1]
         { info_tbl: [(c4ojc,
                       label: block_c4ojc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ojc: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.185499102 UTC

[section ""data" . GHC.Int.$fRealInt64_$ctoRational_closure" {
     GHC.Int.$fRealInt64_$ctoRational_closure:
         const GHC.Int.$fRealInt64_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt64_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4ojt,
                       label: GHC.Int.$fRealInt64_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ojt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ojH; else goto c4ojI;
       c4ojH: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ojI: // global
           I64[Sp - 8] = block_c4ojq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ojP; else goto c4ojr;
       u4ojP: // global
           call _c4ojq(R1) args: 0, res: 0, upd: 0;
       c4ojr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ojq() //  [R1]
         { info_tbl: [(c4ojq,
                       label: block_c4ojq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ojq: // global
           I64[Sp] = block_c4ojw_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ojw() //  [R1]
         { info_tbl: [(c4ojw,
                       label: block_c4ojw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ojw: // global
           I64[Sp] = block_c4ojA_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ojA() //  [R1]
         { info_tbl: [(c4ojA,
                       label: block_c4ojA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ojA: // global
           I64[Sp] = block_c4ojE_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ojE() //  [R1, R2]
         { info_tbl: [(c4ojE,
                       label: block_c4ojE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ojE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ojO; else goto c4ojN;
       c4ojO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ojN: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.186986052 UTC

[section ""data" . GHC.Int.$fRealInt64_closure" {
     GHC.Int.$fRealInt64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt64_closure+1;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fRealInt64_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.187594966 UTC

[section ""data" . GHC.Int.$fIntegralInt64_closure" {
     GHC.Int.$fIntegralInt64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt64_closure+1;
         const GHC.Int.$fEnumInt64_closure+1;
         const GHC.Int.$fIntegralInt64_$cquot_closure+2;
         const GHC.Int.$fIntegralInt64_$crem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt64_$cmod_closure+2;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt64_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.188693105 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt64_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt64_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt64_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4ojX,
                       label: GHC.Int.$fIxInt64_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ojX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oke; else goto c4okf;
       c4oke: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4okf: // global
           I64[Sp - 16] = block_c4ojU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4okm; else goto c4ojV;
       u4okm: // global
           call _c4ojU(R1) args: 0, res: 0, upd: 0;
       c4ojV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ojU() //  [R1]
         { info_tbl: [(c4ojU,
                       label: block_c4ojU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ojU: // global
           I64[Sp] = block_c4ok0_info;
           _s4lwX::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lwX::P64;
           if (R1 & 7 != 0) goto u4okl; else goto c4ok1;
       u4okl: // global
           call _c4ok0(R1) args: 0, res: 0, upd: 0;
       c4ok1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ok0() //  [R1]
         { info_tbl: [(c4ok0,
                       label: block_c4ok0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ok0: // global
           I64[Sp] = block_c4ok5_info;
           _s4lx0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lx0::I64;
           if (R1 & 7 != 0) goto u4okn; else goto c4ok6;
       u4okn: // global
           call _c4ok5(R1) args: 0, res: 0, upd: 0;
       c4ok6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ok5() //  [R1]
         { info_tbl: [(c4ok5,
                       label: block_c4ok5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ok5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4okk; else goto c4okj;
       c4okk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4okj: // global
           _s4lx3::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lx3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.190722372 UTC

[section ""data" . GHC.Int.$fIxInt64_$crangeSize_closure" {
     GHC.Int.$fIxInt64_$crangeSize_closure:
         const GHC.Int.$fIxInt64_$crangeSize_info;
 },
 GHC.Int.$fIxInt64_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4okv,
                       label: GHC.Int.$fIxInt64_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4okv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4okE; else goto c4okF;
       c4okE: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4okF: // global
           I64[Sp - 8] = block_c4oks_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ol4; else goto c4okt;
       u4ol4: // global
           call _c4oks(R1) args: 0, res: 0, upd: 0;
       c4okt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oks() //  [R1]
         { info_tbl: [(c4oks,
                       label: block_c4oks_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oks: // global
           I64[Sp - 8] = block_c4oky_info;
           _s4lx7::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lx7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ol3; else goto c4okz;
       u4ol3: // global
           call _c4oky(R1) args: 0, res: 0, upd: 0;
       c4okz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oky() //  [R1]
         { info_tbl: [(c4oky,
                       label: block_c4oky_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oky: // global
           I64[Sp] = block_c4okD_info;
           _s4lx9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lx9::I64;
           if (R1 & 7 != 0) goto u4ol5; else goto c4okI;
       u4ol5: // global
           call _c4okD(R1) args: 0, res: 0, upd: 0;
       c4okI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4okD() //  [R1]
         { info_tbl: [(c4okD,
                       label: block_c4okD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4okD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4okO; else goto c4okN;
       c4okO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4okN: // global
           _s4lx9::I64 = I64[Sp + 8];
           _s4lxb::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lx9::I64,
                            _s4lxb::I64)) goto c4okS; else goto c4ol2;
       c4okS: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ol2: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxb::I64 - _s4lx9::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.192710389 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt64_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt64_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4old,
                       label: GHC.Int.$fIxInt64_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4old: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4olx; else goto c4oly;
       c4olx: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oly: // global
           I64[Sp - 8] = block_c4ola_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4olF; else goto c4olb;
       u4olF: // global
           call _c4ola(R1) args: 0, res: 0, upd: 0;
       c4olb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ola() //  [R1]
         { info_tbl: [(c4ola,
                       label: block_c4ola_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ola: // global
           I64[Sp - 8] = block_c4olg_info;
           _s4lxh::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lxh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4olE; else goto c4olh;
       u4olE: // global
           call _c4olg(R1) args: 0, res: 0, upd: 0;
       c4olh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4olg() //  [R1]
         { info_tbl: [(c4olg,
                       label: block_c4olg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4olg: // global
           I64[Sp] = block_c4oll_info;
           _s4lxk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxk::I64;
           if (R1 & 7 != 0) goto u4olG; else goto c4olm;
       u4olG: // global
           call _c4oll(R1) args: 0, res: 0, upd: 0;
       c4olm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oll() //  [R1]
         { info_tbl: [(c4oll,
                       label: block_c4oll_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oll: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4olD; else goto c4olC;
       c4olD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4olC: // global
           _s4lxo::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.194894711 UTC

[section ""data" . GHC.Int.$fIxInt64_$cindex_closure" {
     GHC.Int.$fIxInt64_$cindex_closure:
         const GHC.Int.$fIxInt64_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt64_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4olO,
                       label: GHC.Int.$fIxInt64_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4olO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4olX; else goto c4olY;
       c4olX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4olY: // global
           I64[Sp - 16] = block_c4olL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4omx; else goto c4olM;
       u4omx: // global
           call _c4olL(R1) args: 0, res: 0, upd: 0;
       c4olM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4olL() //  [R1]
         { info_tbl: [(c4olL,
                       label: block_c4olL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4olL: // global
           I64[Sp - 8] = block_c4olR_info;
           _s4lxt::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lxt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4omw; else goto c4olS;
       u4omw: // global
           call _c4olR(R1) args: 0, res: 0, upd: 0;
       c4olS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4olR() //  [R1]
         { info_tbl: [(c4olR,
                       label: block_c4olR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4olR: // global
           I64[Sp] = block_c4olW_info;
           _s4lxv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lxv::I64;
           if (R1 & 7 != 0) goto u4omy; else goto c4om1;
       u4omy: // global
           call _c4olW(R1) args: 0, res: 0, upd: 0;
       c4om1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4olW() //  [R1]
         { info_tbl: [(c4olW,
                       label: block_c4olW_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4olW: // global
           _s4lxx::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lxx::I64)) goto c4om9; else goto c4omd;
       c4om9: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4omd: // global
           I64[Sp] = block_c4omc_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxx::I64;
           if (R1 & 7 != 0) goto u4omz; else goto c4ome;
       u4omz: // global
           call _c4omc(R1) args: 0, res: 0, upd: 0;
       c4ome: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4omc() //  [R1]
         { info_tbl: [(c4omc,
                       label: block_c4omc_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4omc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4omk; else goto c4omj;
       c4omk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4omj: // global
           _s4lxx::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4lxx::I64,
                            I64[R1 + 7])) goto c4omo; else goto c4omv;
       c4omo: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4omv: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxx::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.198047817 UTC

[section ""data" . GHC.Int.$fIxInt64_closure" {
     GHC.Int.$fIxInt64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fIxInt64_$crange_closure+1;
         const GHC.Int.$fIxInt64_$cindex_closure+2;
         const GHC.Int.$fIxInt64_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt64_$cinRange_closure+2;
         const GHC.Int.$fIxInt64_$crangeSize_closure+1;
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.199194135 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowsPrec_closure" {
     GHC.Int.$fShowInt64_$cshowsPrec_closure:
         const GHC.Int.$fShowInt64_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt64_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4omH,
                       label: GHC.Int.$fShowInt64_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4omH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4omS; else goto c4omT;
       c4omS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4omT: // global
           I64[Sp - 24] = block_c4omE_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4on0; else goto c4omF;
       u4on0: // global
           call _c4omE(R1) args: 0, res: 0, upd: 0;
       c4omF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4omE() //  [R1]
         { info_tbl: [(c4omE,
                       label: block_c4omE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4omE: // global
           I64[Sp] = block_c4omK_info;
           _s4lxH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxH::I64;
           if (R1 & 7 != 0) goto u4omZ; else goto c4omL;
       u4omZ: // global
           call _c4omK(R1) args: 0, res: 0, upd: 0;
       c4omL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4omK() //  [R1]
         { info_tbl: [(c4omK,
                       label: block_c4omK_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4omK: // global
           _s4lxF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4omP_info;
           R4 = _s4lxF::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4omP() //  [R1, R2]
         { info_tbl: [(c4omP,
                       label: block_c4omP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4omP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4omY; else goto c4omX;
       c4omY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4omX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.201031497 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshow_closure" {
     GHC.Int.$fShowInt64_$cshow_closure:
         const GHC.Int.$fShowInt64_$cshow_info;
 },
 GHC.Int.$fShowInt64_$cshow_entry() //  [R2]
         { info_tbl: [(c4on8,
                       label: GHC.Int.$fShowInt64_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4on8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4one; else goto c4onf;
       c4one: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4onf: // global
           I64[Sp - 8] = block_c4on5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4onk; else goto c4on6;
       u4onk: // global
           call _c4on5(R1) args: 0, res: 0, upd: 0;
       c4on6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4on5() //  [R1]
         { info_tbl: [(c4on5,
                       label: block_c4on5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4on5: // global
           I64[Sp] = block_c4onb_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4onb() //  [R1, R2]
         { info_tbl: [(c4onb,
                       label: block_c4onb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4onb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4onj; else goto c4oni;
       c4onj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oni: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.202895817 UTC

[section ""data" . GHC.Int.$fShowInt3_closure" {
     GHC.Int.$fShowInt3_closure:
         const GHC.Int.$fShowInt3_info;
 },
 GHC.Int.$fShowInt3_entry() //  [R2, R3]
         { info_tbl: [(c4ons,
                       label: GHC.Int.$fShowInt3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ons: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ony; else goto c4onz;
       c4ony: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4onz: // global
           I64[Sp - 16] = block_c4onp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4onE; else goto c4onq;
       u4onE: // global
           call _c4onp(R1) args: 0, res: 0, upd: 0;
       c4onq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4onp() //  [R1]
         { info_tbl: [(c4onp,
                       label: block_c4onp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4onp: // global
           _s4lxU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4onv_info;
           R4 = _s4lxU::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4onv() //  [R1, R2]
         { info_tbl: [(c4onv,
                       label: block_c4onv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4onv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4onD; else goto c4onC;
       c4onD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4onC: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.204292145 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowList_closure" {
     GHC.Int.$fShowInt64_$cshowList_closure:
         const GHC.Int.$fShowInt64_$cshowList_info;
 },
 GHC.Int.$fShowInt64_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4onJ,
                       label: GHC.Int.$fShowInt64_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4onJ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt3_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.205058633 UTC

[section ""data" . GHC.Int.$fShowInt64_closure" {
     GHC.Int.$fShowInt64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt64_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt64_$cshow_closure+1;
         const GHC.Int.$fShowInt64_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.205851465 UTC

[section ""data" . GHC.Int.uncheckedIShiftL64#_closure" {
     GHC.Int.uncheckedIShiftL64#_closure:
         const GHC.Int.uncheckedIShiftL64#_info;
 },
 GHC.Int.uncheckedIShiftL64#_entry() //  [R2, R3]
         { info_tbl: [(c4onR,
                       label: GHC.Int.uncheckedIShiftL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4onR: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.206653941 UTC

[section ""data" . GHC.Int.uncheckedIShiftRA64#_closure" {
     GHC.Int.uncheckedIShiftRA64#_closure:
         const GHC.Int.uncheckedIShiftRA64#_info;
 },
 GHC.Int.uncheckedIShiftRA64#_entry() //  [R2, R3]
         { info_tbl: [(c4onZ,
                       label: GHC.Int.uncheckedIShiftRA64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4onZ: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.207341588 UTC

[section ""cstring" . GHC.Int.$trModule4_bytes" {
     GHC.Int.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.207952135 UTC

[section ""data" . GHC.Int.$trModule3_closure" {
     GHC.Int.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.208493638 UTC

[section ""cstring" . GHC.Int.$trModule2_bytes" {
     GHC.Int.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.209043015 UTC

[section ""data" . GHC.Int.$trModule1_closure" {
     GHC.Int.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.20991924 UTC

[section ""data" . GHC.Int.$trModule_closure" {
     GHC.Int.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Int.$trModule3_closure+1;
         const GHC.Int.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.210508065 UTC

[section ""data" . $krep_r4kPB_closure" {
     $krep_r4kPB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.211090091 UTC

[section ""data" . GHC.Int.$tcInt7_closure" {
     GHC.Int.$tcInt7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.211694813 UTC

[section ""data" . GHC.Int.$tcInt8_closure" {
     GHC.Int.$tcInt8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt7_closure+1;
         const GHC.Types.krep$*_closure;
         const 1422706860619545536;
         const 2126344328513082648;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.212336328 UTC

[section ""data" . $krep1_r4kPC_closure" {
     $krep1_r4kPC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.212911539 UTC

[section ""data" . GHC.Int.$tc'I8#1_closure" {
     GHC.Int.$tc'I8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep1_r4kPC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.213597463 UTC

[section ""cstring" . GHC.Int.$tc'I8#3_bytes" {
     GHC.Int.$tc'I8#3_bytes:
         I8[] [39,73,56,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.214150737 UTC

[section ""data" . GHC.Int.$tc'I8#2_closure" {
     GHC.Int.$tc'I8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I8#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.214738976 UTC

[section ""data" . GHC.Int.$tc'I8#_closure" {
     GHC.Int.$tc'I8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I8#2_closure+1;
         const GHC.Int.$tc'I8#1_closure+4;
         const 5349338056284818619;
         const 13298037281129101406;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.215372943 UTC

[section ""data" . GHC.Int.$tcInt1_closure" {
     GHC.Int.$tcInt1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.215958826 UTC

[section ""data" . GHC.Int.$tcInt16_closure" {
     GHC.Int.$tcInt16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16329117591681623238;
         const 13363230803330610095;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.216633011 UTC

[section ""data" . $krep2_r4kPD_closure" {
     $krep2_r4kPD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.217327568 UTC

[section ""data" . GHC.Int.$tc'I16#1_closure" {
     GHC.Int.$tc'I16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep2_r4kPD_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.218740329 UTC

[section ""cstring" . GHC.Int.$tc'I16#3_bytes" {
     GHC.Int.$tc'I16#3_bytes:
         I8[] [39,73,49,54,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.219327445 UTC

[section ""data" . GHC.Int.$tc'I16#2_closure" {
     GHC.Int.$tc'I16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I16#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.219918381 UTC

[section ""data" . GHC.Int.$tc'I16#_closure" {
     GHC.Int.$tc'I16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I16#2_closure+1;
         const GHC.Int.$tc'I16#1_closure+4;
         const 1077432500071562197;
         const 13676251251348512601;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.220551951 UTC

[section ""data" . GHC.Int.$tcInt3_closure" {
     GHC.Int.$tcInt3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.221123956 UTC

[section ""data" . GHC.Int.$tcInt32_closure" {
     GHC.Int.$tcInt32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt3_closure+1;
         const GHC.Types.krep$*_closure;
         const 5115671124548181797;
         const 6203735229629729265;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.221798503 UTC

[section ""data" . $krep3_r4kPE_closure" {
     $krep3_r4kPE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.222369968 UTC

[section ""data" . GHC.Int.$tc'I32#1_closure" {
     GHC.Int.$tc'I32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep3_r4kPE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.222923978 UTC

[section ""cstring" . GHC.Int.$tc'I32#3_bytes" {
     GHC.Int.$tc'I32#3_bytes:
         I8[] [39,73,51,50,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.223445998 UTC

[section ""data" . GHC.Int.$tc'I32#2_closure" {
     GHC.Int.$tc'I32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I32#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.223997477 UTC

[section ""data" . GHC.Int.$tc'I32#_closure" {
     GHC.Int.$tc'I32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I32#2_closure+1;
         const GHC.Int.$tc'I32#1_closure+4;
         const 14037617528454219662;
         const 2752255350980319305;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.224610711 UTC

[section ""data" . GHC.Int.$tcInt5_closure" {
     GHC.Int.$tcInt5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.225202479 UTC

[section ""data" . GHC.Int.$tcInt64_closure" {
     GHC.Int.$tcInt64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt5_closure+1;
         const GHC.Types.krep$*_closure;
         const 15049343324344240059;
         const 14445320765379163718;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.225842275 UTC

[section ""data" . $krep4_r4kPF_closure" {
     $krep4_r4kPF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.226417877 UTC

[section ""data" . GHC.Int.$tc'I64#1_closure" {
     GHC.Int.$tc'I64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep4_r4kPF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.226980813 UTC

[section ""cstring" . GHC.Int.$tc'I64#3_bytes" {
     GHC.Int.$tc'I64#3_bytes:
         I8[] [39,73,54,52,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.227559212 UTC

[section ""data" . GHC.Int.$tc'I64#2_closure" {
     GHC.Int.$tc'I64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I64#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.228109374 UTC

[section ""data" . GHC.Int.$tc'I64#_closure" {
     GHC.Int.$tc'I64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I64#2_closure+1;
         const GHC.Int.$tc'I64#1_closure+4;
         const 7755385358338959724;
         const 8520529638322167079;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.229036044 UTC

[section ""data" . GHC.Int.I8#_closure" {
     GHC.Int.I8#_closure:
         const GHC.Int.I8#_info;
 },
 GHC.Int.I8#_entry() //  [R2]
         { info_tbl: [(c4oo7,
                       label: GHC.Int.I8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oo7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oob; else goto c4ooa;
       c4oob: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ooa: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.230492634 UTC

[section ""data" . GHC.Int.I16#_closure" {
     GHC.Int.I16#_closure:
         const GHC.Int.I16#_info;
 },
 GHC.Int.I16#_entry() //  [R2]
         { info_tbl: [(c4ooh,
                       label: GHC.Int.I16#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ooh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ool; else goto c4ook;
       c4ool: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ook: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.23142706 UTC

[section ""data" . GHC.Int.I32#_closure" {
     GHC.Int.I32#_closure:
         const GHC.Int.I32#_info;
 },
 GHC.Int.I32#_entry() //  [R2]
         { info_tbl: [(c4oor,
                       label: GHC.Int.I32#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oor: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oov; else goto c4oou;
       c4oov: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oou: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.23238979 UTC

[section ""data" . GHC.Int.I64#_closure" {
     GHC.Int.I64#_closure:
         const GHC.Int.I64#_info;
 },
 GHC.Int.I64#_entry() //  [R2]
         { info_tbl: [(c4ooB,
                       label: GHC.Int.I64#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ooB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ooF; else goto c4ooE;
       c4ooF: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ooE: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.233299206 UTC

[GHC.Int.I8#_con_entry() //  [R1]
         { info_tbl: [(c4ooG,
                       label: GHC.Int.I8#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,56,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ooG: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.234033562 UTC

[GHC.Int.I16#_con_entry() //  [R1]
         { info_tbl: [(c4ooH,
                       label: GHC.Int.I16#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,49,54,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ooH: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.234782176 UTC

[GHC.Int.I32#_con_entry() //  [R1]
         { info_tbl: [(c4ooI,
                       label: GHC.Int.I32#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,51,50,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ooI: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.235495271 UTC

[GHC.Int.I64#_con_entry() //  [R1]
         { info_tbl: [(c4ooJ,
                       label: GHC.Int.I64#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,54,52,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ooJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.236171614 UTC

[section ""relreadonly" . S4lDl_srt" {
     S4lDl_srt:
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt8_$cpred_closure;
         const GHC.Int.$fEnumInt7_closure;
         const GHC.Int.$fEnumInt8_$csucc_closure;
         const GHC.Int.$fEnumInt9_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl_r4kPr_closure;
         const GHC.Int.$wlvl2_closure;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum2_closure;
         const GHC.Int.$w$cenumFromThenTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Int.$wgo3_closure;
         const GHC.Int.$fEnumInt8_go_closure;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure;
         const GHC.Int.$fEnumInt8_closure;
         const GHC.Int.$fEnumInt16_$cpred_closure;
         const GHC.Int.$fEnumInt1_closure;
         const GHC.Int.$fEnumInt16_$csucc_closure;
         const GHC.Int.$fEnumInt2_closure;
         const lvl2_r4kPt_closure;
         const GHC.Int.$wlvl_closure;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum_closure;
         const GHC.Int.$w$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$wgo_closure;
         const GHC.Int.$fEnumInt16_go_closure;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure;
         const GHC.Int.$fEnumInt16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt32_$cpred_closure;
         const GHC.Int.$fEnumInt3_closure;
         const GHC.Int.$fEnumInt32_$csucc_closure;
         const GHC.Int.$fEnumInt4_closure;
         const lvl4_r4kPv_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Int.$wlvl1_closure;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum1_closure;
         const GHC.Int.$w$cenumFromTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$wgo1_closure;
         const GHC.Int.$fEnumInt32_go_closure;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure;
         const GHC.Int.$w$cenumFromThenTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt32_closure;
         const GHC.Int.$fEnumInt64_$cpred_closure;
         const GHC.Int.$fEnumInt5_closure;
         const GHC.Int.$fEnumInt64_$csucc_closure;
         const GHC.Int.$fEnumInt6_closure;
         const GHC.Int.$fEnumInt64_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Int.$fReadInt8_$creadsPrec_closure;
         const GHC.Int.$fReadInt13_closure;
         const GHC.Read.list_closure;
         const GHC.Int.$fReadInt12_closure;
         const GHC.Int.$fReadInt11_closure;
         const GHC.Int.$fReadInt8_$creadList_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fIntegralInt8_$cquot_closure;
         const GHC.Int.$fIntegralInt8_$crem_closure;
         const GHC.Int.$w$cdiv3_closure;
         const GHC.Int.$fIntegralInt8_$cdiv_closure;
         const GHC.Int.$fIntegralInt8_$cmod_closure;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure;
         const lvl6_r4kPx_closure;
         const GHC.Int.$w$cdivMod3_closure;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure;
         const sat_s4ldV_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Int.$fRealInt8_$ctoRational_closure;
         const GHC.Int.$fIxInt8_$crange_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fIxInt8_$cindex_closure;
         const GHC.Int.$fReadInt16_$creadsPrec_closure;
         const GHC.Int.$fReadInt3_closure;
         const GHC.Int.$fReadInt2_closure;
         const GHC.Int.$fReadInt1_closure;
         const GHC.Int.$fReadInt16_$creadList_closure;
         const GHC.Int.$fIntegralInt16_$cquot_closure;
         const GHC.Int.$fIntegralInt16_$crem_closure;
         const GHC.Int.$w$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cmod_closure;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure;
         const lvl7_r4kPy_closure;
         const GHC.Int.$w$cdivMod_closure;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure;
         const GHC.Int.$fRealInt16_$ctoRational_closure;
         const GHC.Int.$fIxInt16_$crange_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$fIxInt16_$cindex_closure;
         const GHC.Int.$fReadInt32_$creadsPrec_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Int.$fReadInt6_closure;
         const GHC.Int.$fReadInt5_closure;
         const GHC.Int.$fReadInt4_closure;
         const GHC.Int.$fReadInt32_$creadList_closure;
         const GHC.Int.$fIntegralInt32_$cquot_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Int.$fIntegralInt32_$crem_closure;
         const GHC.Int.$w$cdiv1_closure;
         const GHC.Int.$fIntegralInt32_$cdiv_closure;
         const GHC.Int.$fIntegralInt32_$cmod_closure;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure;
         const lvl8_r4kPz_closure;
         const GHC.Int.$w$cdivMod1_closure;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure;
         const GHC.Int.$fRealInt32_$ctoRational_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Int.$fIxInt32_$crange_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$fIxInt32_$cindex_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fReadInt64_$creadsPrec_closure;
         const GHC.Int.$fReadInt10_closure;
         const GHC.Int.$fReadInt9_closure;
         const GHC.Int.$fReadInt7_closure;
         const GHC.Int.$fReadInt64_$creadList_closure;
         const GHC.Int.$fIntegralInt64_$cquot_closure;
         const GHC.Int.$fIntegralInt64_$crem_closure;
         const GHC.Int.$fIntegralInt64_$cdiv_closure;
         const GHC.Int.$w$cdiv2_closure;
         const GHC.Int.$fIntegralInt64_$cmod_closure;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure;
         const lvl9_r4kPA_closure;
         const GHC.Int.$w$cdivMod2_closure;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure;
         const GHC.Int.$fRealInt64_$ctoRational_closure;
         const GHC.Int.$fIxInt64_$cindex_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.237779028 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:09.239361978 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cfromEnum_closure" {
     GHC.Int.$fEnumInt8_$cfromEnum_closure:
         const GHC.Int.$fEnumInt8_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt8_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4ooR,
                       label: GHC.Int.$fEnumInt8_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ooR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ooV; else goto c4ooW;
       c4ooV: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ooW: // global
           I64[Sp - 8] = block_c4ooO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4op0; else goto c4ooP;
       u4op0: // global
           call _c4ooO(R1) args: 0, res: 0, upd: 0;
       c4ooP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ooO() //  [R1]
         { info_tbl: [(c4ooO,
                       label: block_c4ooO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ooO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ooZ; else goto c4ooY;
       c4ooZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ooY: // global
           _s4kPJ::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.240738425 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cfromEnum_closure" {
     GHC.Int.$fEnumInt16_$cfromEnum_closure:
         const GHC.Int.$fEnumInt16_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt16_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4op8,
                       label: GHC.Int.$fEnumInt16_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4op8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4opc; else goto c4opd;
       c4opc: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4opd: // global
           I64[Sp - 8] = block_c4op5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oph; else goto c4op6;
       u4oph: // global
           call _c4op5(R1) args: 0, res: 0, upd: 0;
       c4op6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4op5() //  [R1]
         { info_tbl: [(c4op5,
                       label: block_c4op5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4op5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4opg; else goto c4opf;
       c4opg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4opf: // global
           _s4kPM::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPM::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.242102414 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cfromEnum_closure" {
     GHC.Int.$fEnumInt32_$cfromEnum_closure:
         const GHC.Int.$fEnumInt32_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt32_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4opp,
                       label: GHC.Int.$fEnumInt32_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4opp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4opt; else goto c4opu;
       c4opt: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4opu: // global
           I64[Sp - 8] = block_c4opm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4opy; else goto c4opn;
       u4opy: // global
           call _c4opm(R1) args: 0, res: 0, upd: 0;
       c4opn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4opm() //  [R1]
         { info_tbl: [(c4opm,
                       label: block_c4opm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4opm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4opx; else goto c4opw;
       c4opx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4opw: // global
           _s4kPP::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.243395118 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cfromEnum_closure" {
     GHC.Int.$fEnumInt64_$cfromEnum_closure:
         const GHC.Int.$fEnumInt64_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt64_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4opG,
                       label: GHC.Int.$fEnumInt64_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4opG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4opK; else goto c4opL;
       c4opK: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4opL: // global
           I64[Sp - 8] = block_c4opD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4opP; else goto c4opE;
       u4opP: // global
           call _c4opD(R1) args: 0, res: 0, upd: 0;
       c4opE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4opD() //  [R1]
         { info_tbl: [(c4opD,
                       label: block_c4opD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4opD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4opO; else goto c4opN;
       c4opO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4opN: // global
           _s4kPS::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.244706459 UTC

[section ""data" . GHC.Int.$fEnumInt64_$ctoEnum_closure" {
     GHC.Int.$fEnumInt64_$ctoEnum_closure:
         const GHC.Int.$fEnumInt64_$ctoEnum_info;
 },
 GHC.Int.$fEnumInt64_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4opX,
                       label: GHC.Int.$fEnumInt64_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4opX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oq1; else goto c4oq2;
       c4oq1: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oq2: // global
           I64[Sp - 8] = block_c4opU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oq6; else goto c4opV;
       u4oq6: // global
           call _c4opU(R1) args: 0, res: 0, upd: 0;
       c4opV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4opU() //  [R1]
         { info_tbl: [(c4opU,
                       label: block_c4opU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4opU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oq5; else goto c4oq4;
       c4oq5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4oq4: // global
           _s4kPV::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kPV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.247660491 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo2_closure" {
     GHC.Int.$w$cenumFromThenTo2_closure:
         const GHC.Int.$w$cenumFromThenTo2_info;
 },
 sat_s4kQ9_entry() //  [R1]
         { info_tbl: [(c4oqF,
                       label: sat_s4kQ9_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oqF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oqG; else goto c4oqH;
       c4oqG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oqH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kQ4_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kQ4_entry() //  [R1, R2]
         { info_tbl: [(c4oqL,
                       label: go_dn_s4kQ4_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oqL: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4oqP; else goto c4oqO;
       c4oqP: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oqO: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4oqJ; else goto c4oqK;
       c4oqJ: // global
           _s4kQ2::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQ9_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQ2::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oqK: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4oqU::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4oqU::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kQb_entry() //  [R1]
         { info_tbl: [(c4oqV,
                       label: sat_s4kQb_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oqV: // global
           _s4kQb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oqW; else goto c4oqX;
       c4oqX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oqZ; else goto c4oqY;
       c4oqZ: // global
           HpAlloc = 24;
           goto c4oqW;
       c4oqW: // global
           R1 = _s4kQb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oqY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kQb::P64;
           _s4kPX::I64 = I64[_s4kQb::P64 + 24];
           _s4kQ2::I64 = _s4kPX::I64 - I64[_s4kQb::P64 + 16];
           _s4kQ3::I64 = I64[_s4kQb::P64 + 32] - _s4kQ2::I64;
           I64[Hp - 16] = go_dn_s4kQ4_info;
           I64[Hp - 8] = _s4kQ2::I64;
           I64[Hp] = _s4kQ3::I64;
           R2 = _s4kPX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kQ4_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kQn_entry() //  [R1]
         { info_tbl: [(c4ors,
                       label: sat_s4kQn_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ors: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ort; else goto c4oru;
       c4ort: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oru: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kQi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kQi_entry() //  [R1, R2]
         { info_tbl: [(c4ory,
                       label: go_up_s4kQi_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ory: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4orC; else goto c4orB;
       c4orC: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4orB: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4orw; else goto c4orx;
       c4orw: // global
           _s4kQg::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQn_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQg::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4orx: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4orH::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4orH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kQp_entry() //  [R1]
         { info_tbl: [(c4orI,
                       label: sat_s4kQp_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4orI: // global
           _s4kQp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4orJ; else goto c4orK;
       c4orK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4orM; else goto c4orL;
       c4orM: // global
           HpAlloc = 24;
           goto c4orJ;
       c4orJ: // global
           R1 = _s4kQp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4orL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kQp::P64;
           _s4kPX::I64 = I64[_s4kQp::P64 + 24];
           _s4kQg::I64 = _s4kPX::I64 - I64[_s4kQp::P64 + 16];
           _s4kQh::I64 = I64[_s4kQp::P64 + 32] - _s4kQg::I64;
           I64[Hp - 16] = go_up_s4kQi_info;
           I64[Hp - 8] = _s4kQg::I64;
           I64[Hp] = _s4kQh::I64;
           R2 = _s4kPX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kQi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { info_tbl: [(c4orQ,
                       label: GHC.Int.$w$cenumFromThenTo2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4orQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4orU; else goto c4orT;
       c4orU: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4orT: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4orO; else goto c4orP;
       c4orO: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4orY; else goto c4os8;
       c4orY: // global
           I64[Hp - 72] = sat_s4kQb_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4os8: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4osl; else goto c4os6;
       c4os6: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4os4::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4os4::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4orP: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4osc; else goto c4osm;
       c4osc: // global
           I64[Hp - 72] = sat_s4kQp_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4osm: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4osl; else goto c4osk;
       c4osl: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4osk: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4osi::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4osi::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.251986467 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4osu,
                       label: GHC.Int.$fEnumInt64_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4osu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4osD; else goto c4osE;
       c4osD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4osE: // global
           I64[Sp - 24] = block_c4osr_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4osN; else goto c4oss;
       u4osN: // global
           call _c4osr(R1) args: 0, res: 0, upd: 0;
       c4oss: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4osr() //  [R1]
         { info_tbl: [(c4osr,
                       label: block_c4osr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4osr: // global
           I64[Sp] = block_c4osx_info;
           _s4kQw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQw::I64;
           if (R1 & 7 != 0) goto u4osM; else goto c4osy;
       u4osM: // global
           call _c4osx(R1) args: 0, res: 0, upd: 0;
       c4osy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4osx() //  [R1]
         { info_tbl: [(c4osx,
                       label: block_c4osx_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4osx: // global
           I64[Sp] = block_c4osC_info;
           _s4kQy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kQy::I64;
           if (R1 & 7 != 0) goto u4osO; else goto c4osH;
       u4osO: // global
           call _c4osC(R1) args: 0, res: 0, upd: 0;
       c4osH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4osC() //  [R1]
         { info_tbl: [(c4osC,
                       label: block_c4osC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4osC: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo2_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.254177261 UTC

[section ""data" . GHC.Int.$w$cenumFromTo2_closure" {
     GHC.Int.$w$cenumFromTo2_closure:
         const GHC.Int.$w$cenumFromTo2_info;
 },
 sat_s4kQJ_entry() //  [R1]
         { info_tbl: [(c4ota,
                       label: sat_s4kQJ_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ota: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4otb; else goto c4otc;
       c4otb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4otc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kQF::I64 = I64[R1 + 32];
           if (_s4kQF::I64 == I64[R1 + 24]) goto c4ot9; else goto c4ot8;
       c4ot9: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4ot8: // global
           R2 = _s4kQF::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kQE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kQE_entry() //  [R1, R2]
         { info_tbl: [(c4oth,
                       label: go_s4kQE_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oth: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4otl; else goto c4otk;
       c4otl: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4otk: // global
           _s4kQC::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQJ_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQC::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo2_entry() //  [R2, R3]
         { info_tbl: [(c4otp,
                       label: GHC.Int.$w$cenumFromTo2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4otp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ott; else goto c4ots;
       c4ott: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ots: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4otn; else goto c4oto;
       c4otn: // global
           I64[Hp - 8] = go_s4kQE_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kQE_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4oto: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.256184651 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4otB,
                       label: GHC.Int.$fEnumInt64_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4otB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4otF; else goto c4otG;
       c4otF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4otG: // global
           I64[Sp - 16] = block_c4oty_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4otO; else goto c4otz;
       u4otO: // global
           call _c4oty(R1) args: 0, res: 0, upd: 0;
       c4otz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oty() //  [R1]
         { info_tbl: [(c4oty,
                       label: block_c4oty_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oty: // global
           I64[Sp] = block_c4otE_info;
           _s4kQN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQN::I64;
           if (R1 & 7 != 0) goto u4otN; else goto c4otI;
       u4otN: // global
           call _c4otE(R1) args: 0, res: 0, upd: 0;
       c4otI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4otE() //  [R1]
         { info_tbl: [(c4otE,
                       label: block_c4otE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4otE: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.258423179 UTC

[section ""cstring" . GHC.Int.$tcInt9_bytes" {
     GHC.Int.$tcInt9_bytes:
         I8[] [73,110,116,56]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.259307441 UTC

[section ""data" . GHC.Int.$fEnumInt7_closure" {
     GHC.Int.$fEnumInt7_closure:
         const GHC.Int.$fEnumInt7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt7_entry() //  [R1]
         { info_tbl: [(c4otX,
                       label: GHC.Int.$fEnumInt7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4otX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4otY; else goto c4otZ;
       c4otY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4otZ: // global
           (_c4otS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4otS::I64 == 0) goto c4otU; else goto c4otT;
       c4otU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4otT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4otS::I64;
           I64[Sp - 24] = block_c4otV_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4otV() //  [R1]
         { info_tbl: [(c4otV,
                       label: block_c4otV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4otV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.260639357 UTC

[section ""data" . GHC.Int.$fEnumInt9_closure" {
     GHC.Int.$fEnumInt9_closure:
         const GHC.Int.$fEnumInt9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt9_entry() //  [R1]
         { info_tbl: [(c4oub,
                       label: GHC.Int.$fEnumInt9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oub: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ouc; else goto c4oud;
       c4ouc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oud: // global
           (_c4ou6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4ou6::I64 == 0) goto c4ou8; else goto c4ou7;
       c4ou8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4ou7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4ou6::I64;
           I64[Sp - 24] = block_c4ou9_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4ou9() //  [R1]
         { info_tbl: [(c4ou9,
                       label: block_c4ou9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ou9: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.262136112 UTC

[section ""data" . GHC.Int.neInt8_closure" {
     GHC.Int.neInt8_closure:
         const GHC.Int.neInt8_info;
 },
 GHC.Int.neInt8_entry() //  [R2, R3]
         { info_tbl: [(c4ouo,
                       label: GHC.Int.neInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ouo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ous; else goto c4out;
       c4ous: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4out: // global
           I64[Sp - 16] = block_c4oul_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ouC; else goto c4oum;
       u4ouC: // global
           call _c4oul(R1) args: 0, res: 0, upd: 0;
       c4oum: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oul() //  [R1]
         { info_tbl: [(c4oul,
                       label: block_c4oul_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oul: // global
           I64[Sp] = block_c4our_info;
           _s4kQV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQV::I64;
           if (R1 & 7 != 0) goto u4ouB; else goto c4ouv;
       u4ouB: // global
           call _c4our(R1) args: 0, res: 0, upd: 0;
       c4ouv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4our() //  [R1]
         { info_tbl: [(c4our,
                       label: block_c4our_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4our: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.264453745 UTC

[section ""data" . lvl_r4kPr_closure" {
     lvl_r4kPr_closure:
         const lvl_r4kPr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r4kPr_entry() //  [R1]
         { info_tbl: [(c4ouJ,
                       label: lvl_r4kPr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ouJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ouK; else goto c4ouL;
       c4ouK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ouL: // global
           (_c4ouG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4ouG::I64 == 0) goto c4ouI; else goto c4ouH;
       c4ouI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4ouH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4ouG::I64;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.265437475 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cminBound_closure" {
     GHC.Int.$fBoundedInt8_$cminBound_closure:
         const GHC.Int.I8#_con_info;
         const (-128);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.266404549 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cpred_closure" {
     GHC.Int.$fEnumInt8_$cpred_closure:
         const GHC.Int.$fEnumInt8_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cpred_entry() //  [R2]
         { info_tbl: [(c4ouT,
                       label: GHC.Int.$fEnumInt8_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ouT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ouU; else goto c4ouV;
       c4ouU: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ouV: // global
           I64[Sp - 8] = block_c4ouQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ovd; else goto c4ouR;
       u4ovd: // global
           call _c4ouQ(R1) args: 0, res: 0, upd: 0;
       c4ouR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ouQ() //  [R1]
         { info_tbl: [(c4ouQ,
                       label: block_c4ouQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ouQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ov0; else goto c4ouZ;
       c4ov0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ouZ: // global
           _s4kR2::I64 = I64[R1 + 7];
           if (_s4kR2::I64 != (-128)) goto c4ovb; else goto c4ovc;
       c4ovb: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4kR2::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ovc: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.267647994 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt8_$cmaxBound_closure:
         const GHC.Int.I8#_con_info;
         const 127;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.268227508 UTC

[section ""data" . GHC.Int.$fBoundedInt8_closure" {
     GHC.Int.$fBoundedInt8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt8_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.269179887 UTC

[section ""data" . GHC.Int.$fEnumInt8_$csucc_closure" {
     GHC.Int.$fEnumInt8_$csucc_closure:
         const GHC.Int.$fEnumInt8_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$csucc_entry() //  [R2]
         { info_tbl: [(c4ovl,
                       label: GHC.Int.$fEnumInt8_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ovl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ovm; else goto c4ovn;
       c4ovm: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ovn: // global
           I64[Sp - 8] = block_c4ovi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ovF; else goto c4ovj;
       u4ovF: // global
           call _c4ovi(R1) args: 0, res: 0, upd: 0;
       c4ovj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ovi() //  [R1]
         { info_tbl: [(c4ovi,
                       label: block_c4ovi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ovi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ovs; else goto c4ovr;
       c4ovs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ovr: // global
           _s4kR8::I64 = I64[R1 + 7];
           if (_s4kR8::I64 != 127) goto c4ovD; else goto c4ovE;
       c4ovD: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4kR8::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ovE: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.270908462 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowsPrec_closure" {
     GHC.Int.$fShowInt8_$cshowsPrec_closure:
         const GHC.Int.$fShowInt8_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt8_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4ovN,
                       label: GHC.Int.$fShowInt8_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ovN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ovY; else goto c4ovZ;
       c4ovY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ovZ: // global
           I64[Sp - 24] = block_c4ovK_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4ow6; else goto c4ovL;
       u4ow6: // global
           call _c4ovK(R1) args: 0, res: 0, upd: 0;
       c4ovL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ovK() //  [R1]
         { info_tbl: [(c4ovK,
                       label: block_c4ovK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ovK: // global
           I64[Sp] = block_c4ovQ_info;
           _s4kRf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kRf::I64;
           if (R1 & 7 != 0) goto u4ow5; else goto c4ovR;
       u4ow5: // global
           call _c4ovQ(R1) args: 0, res: 0, upd: 0;
       c4ovR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ovQ() //  [R1]
         { info_tbl: [(c4ovQ,
                       label: block_c4ovQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ovQ: // global
           _s4kRd::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4ovV_info;
           R4 = _s4kRd::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ovV() //  [R1, R2]
         { info_tbl: [(c4ovV,
                       label: block_c4ovV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ovV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ow4; else goto c4ow3;
       c4ow4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ow3: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.272749307 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshow_closure" {
     GHC.Int.$fShowInt8_$cshow_closure:
         const GHC.Int.$fShowInt8_$cshow_info;
 },
 GHC.Int.$fShowInt8_$cshow_entry() //  [R2]
         { info_tbl: [(c4owe,
                       label: GHC.Int.$fShowInt8_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4owe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4owk; else goto c4owl;
       c4owk: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4owl: // global
           I64[Sp - 8] = block_c4owb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4owq; else goto c4owc;
       u4owq: // global
           call _c4owb(R1) args: 0, res: 0, upd: 0;
       c4owc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4owb() //  [R1]
         { info_tbl: [(c4owb,
                       label: block_c4owb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4owb: // global
           I64[Sp] = block_c4owh_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4owh() //  [R1, R2]
         { info_tbl: [(c4owh,
                       label: block_c4owh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4owh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4owp; else goto c4owo;
       c4owp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4owo: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.274505541 UTC

[section ""data" . GHC.Int.$fShowInt4_closure" {
     GHC.Int.$fShowInt4_closure:
         const GHC.Int.$fShowInt4_info;
 },
 GHC.Int.$fShowInt4_entry() //  [R2, R3]
         { info_tbl: [(c4owy,
                       label: GHC.Int.$fShowInt4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4owy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4owE; else goto c4owF;
       c4owE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4owF: // global
           I64[Sp - 16] = block_c4owv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4owK; else goto c4oww;
       u4owK: // global
           call _c4owv(R1) args: 0, res: 0, upd: 0;
       c4oww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4owv() //  [R1]
         { info_tbl: [(c4owv,
                       label: block_c4owv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4owv: // global
           _s4kRs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4owB_info;
           R4 = _s4kRs::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4owB() //  [R1, R2]
         { info_tbl: [(c4owB,
                       label: block_c4owB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4owB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4owJ; else goto c4owI;
       c4owJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4owI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.275910703 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowList_closure" {
     GHC.Int.$fShowInt8_$cshowList_closure:
         const GHC.Int.$fShowInt8_$cshowList_info;
 },
 GHC.Int.$fShowInt8_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4owP,
                       label: GHC.Int.$fShowInt8_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4owP: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.276673782 UTC

[section ""data" . GHC.Int.$fShowInt8_closure" {
     GHC.Int.$fShowInt8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt8_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt8_$cshow_closure+1;
         const GHC.Int.$fShowInt8_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.277459289 UTC

[section ""data" . GHC.Int.$wlvl2_closure" {
     GHC.Int.$wlvl2_closure:
         const GHC.Int.$wlvl2_info;
         const 0;
 },
 GHC.Int.$wlvl2_entry() //  [R2]
         { info_tbl: [(c4owW,
                       label: GHC.Int.$wlvl2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4owW: // global
           R6 = GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl_r4kPr_closure;
           R2 = GHC.Int.$fShowInt8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.278518519 UTC

[section ""data" . GHC.Int.$w$ctoEnum2_closure" {
     GHC.Int.$w$ctoEnum2_closure:
         const GHC.Int.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum2_entry() //  [R2]
         { info_tbl: [(c4ox8,
                       label: GHC.Int.$w$ctoEnum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ox8: // global
           _s4kRB::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-128))) goto c4oxg; else goto c4ox7;
       c4ox7: // global
           if (%MO_S_Gt_W64(_s4kRB::I64, 127)) goto c4oxg; else goto c4oxh;
       c4oxg: // global
           R2 = _s4kRB::I64;
           call GHC.Int.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c4oxh: // global
           R1 = _s4kRB::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.279641062 UTC

[section ""data" . GHC.Int.$fEnumInt8_$ctoEnum_closure" {
     GHC.Int.$fEnumInt8_$ctoEnum_closure:
         const GHC.Int.$fEnumInt8_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4oxp,
                       label: GHC.Int.$fEnumInt8_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oxp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oxx; else goto c4oxy;
       c4oxx: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oxy: // global
           I64[Sp - 8] = block_c4oxm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oxD; else goto c4oxn;
       u4oxD: // global
           call _c4oxm(R1) args: 0, res: 0, upd: 0;
       c4oxn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oxm() //  [R1]
         { info_tbl: [(c4oxm,
                       label: block_c4oxm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oxm: // global
           I64[Sp] = block_c4oxs_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oxs() //  [R1]
         { info_tbl: [(c4oxs,
                       label: block_c4oxs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oxs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oxC; else goto c4oxB;
       c4oxC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4oxB: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.284805752 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo3_closure" {
     GHC.Int.$w$cenumFromThenTo3_closure:
         const GHC.Int.$w$cenumFromThenTo3_info;
         const 0;
 },
 sat_s4kS1_entry() //  [R1]
         { info_tbl: [(c4oyc,
                       label: sat_s4kS1_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oyc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oyd; else goto c4oye;
       c4oyd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oye: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kRU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kRZ_entry() //  [R1]
         { info_tbl: [(c4oyo,
                       label: sat_s4kRZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oyo: // global
           _s4kRZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oyp; else goto c4oyq;
       c4oyq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oys; else goto c4oyr;
       c4oys: // global
           HpAlloc = 16;
           goto c4oyp;
       c4oyp: // global
           R1 = _s4kRZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oyr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kRZ::P64;
           _s4kRV::I64 = I64[_s4kRZ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRV::I64, (-128))) goto c4oyy; else goto c4oyn;
       c4oyn: // global
           if (%MO_S_Gt_W64(_s4kRV::I64, 127)) goto c4oyy; else goto c4oyC;
       c4oyy: // global
           Hp = Hp - 16;
           R2 = _s4kRV::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4oyC: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kS4_entry() //  [R1]
         { info_tbl: [(c4oyN,
                       label: sat_s4kS4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oyN: // global
           _s4kS4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oyO; else goto c4oyP;
       c4oyP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oyR; else goto c4oyQ;
       c4oyR: // global
           HpAlloc = 16;
           goto c4oyO;
       c4oyO: // global
           R1 = _s4kS4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oyQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS4::P64;
           _s4kRV::I64 = I64[_s4kS4::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRV::I64, (-128))) goto c4oyX; else goto c4oyM;
       c4oyM: // global
           if (%MO_S_Gt_W64(_s4kRV::I64, 127)) goto c4oyX; else goto c4oz1;
       c4oyX: // global
           Hp = Hp - 16;
           R2 = _s4kRV::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4oz1: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kRU_entry() //  [R1, R2]
         { info_tbl: [(c4oz5,
                       label: go_dn_s4kRU_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oz5: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4oz9; else goto c4oz8;
       c4oz9: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oz8: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4oz3; else goto c4oz4;
       c4oz3: // global
           _s4kRS::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kS1_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kRS::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kRZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oz4: // global
           I64[Hp - 80] = sat_s4kS4_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4ozb::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4ozb::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kS5_entry() //  [R1]
         { info_tbl: [(c4ozc,
                       label: sat_s4kS5_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ozc: // global
           _s4kS5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ozd; else goto c4oze;
       c4oze: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ozg; else goto c4ozf;
       c4ozg: // global
           HpAlloc = 24;
           goto c4ozd;
       c4ozd: // global
           R1 = _s4kS5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ozf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS5::P64;
           _s4kRL::I64 = I64[_s4kS5::P64 + 24];
           _s4kRS::I64 = _s4kRL::I64 - I64[_s4kS5::P64 + 16];
           _s4kRT::I64 = I64[_s4kS5::P64 + 32] - _s4kRS::I64;
           I64[Hp - 16] = go_dn_s4kRU_info;
           I64[Hp - 8] = _s4kRS::I64;
           I64[Hp] = _s4kRT::I64;
           R2 = _s4kRL::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kRU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kRR_entry() //  [R1]
         { info_tbl: [(c4ozq,
                       label: sat_s4kRR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ozq: // global
           _s4kRR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ozr; else goto c4ozs;
       c4ozs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ozu; else goto c4ozt;
       c4ozu: // global
           HpAlloc = 16;
           goto c4ozr;
       c4ozr: // global
           R1 = _s4kRR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ozt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kRR::P64;
           _s4kRK::I64 = I64[_s4kRR::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4ozA; else goto c4ozp;
       c4ozp: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4ozA; else goto c4ozE;
       c4ozA: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4ozE: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kS9_entry() //  [R1]
         { info_tbl: [(c4ozS,
                       label: sat_s4kS9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ozS: // global
           _s4kS9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ozT; else goto c4ozU;
       c4ozU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ozW; else goto c4ozV;
       c4ozW: // global
           HpAlloc = 16;
           goto c4ozT;
       c4ozT: // global
           R1 = _s4kS9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ozV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS9::P64;
           _s4kRK::I64 = I64[_s4kS9::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4oA2; else goto c4ozR;
       c4ozR: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4oA2; else goto c4oA6;
       c4oA2: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4oA6: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSn_entry() //  [R1]
         { info_tbl: [(c4oAz,
                       label: sat_s4kSn_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oAz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oAA; else goto c4oAB;
       c4oAA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oAB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kSg_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSl_entry() //  [R1]
         { info_tbl: [(c4oAL,
                       label: sat_s4kSl_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oAL: // global
           _s4kSl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oAM; else goto c4oAN;
       c4oAN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oAP; else goto c4oAO;
       c4oAP: // global
           HpAlloc = 16;
           goto c4oAM;
       c4oAM: // global
           R1 = _s4kSl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oAO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSl::P64;
           _s4kSh::I64 = I64[_s4kSl::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSh::I64, (-128))) goto c4oAV; else goto c4oAK;
       c4oAK: // global
           if (%MO_S_Gt_W64(_s4kSh::I64, 127)) goto c4oAV; else goto c4oAZ;
       c4oAV: // global
           Hp = Hp - 16;
           R2 = _s4kSh::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4oAZ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSh::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSq_entry() //  [R1]
         { info_tbl: [(c4oBa,
                       label: sat_s4kSq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oBa: // global
           _s4kSq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oBb; else goto c4oBc;
       c4oBc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oBe; else goto c4oBd;
       c4oBe: // global
           HpAlloc = 16;
           goto c4oBb;
       c4oBb: // global
           R1 = _s4kSq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oBd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSq::P64;
           _s4kSh::I64 = I64[_s4kSq::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSh::I64, (-128))) goto c4oBk; else goto c4oB9;
       c4oB9: // global
           if (%MO_S_Gt_W64(_s4kSh::I64, 127)) goto c4oBk; else goto c4oBo;
       c4oBk: // global
           Hp = Hp - 16;
           R2 = _s4kSh::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4oBo: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSh::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kSg_entry() //  [R1, R2]
         { info_tbl: [(c4oBs,
                       label: go_up_s4kSg_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oBs: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4oBw; else goto c4oBv;
       c4oBw: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oBv: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4oBq; else goto c4oBr;
       c4oBq: // global
           _s4kSe::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kSn_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kSe::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kSl_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oBr: // global
           I64[Hp - 80] = sat_s4kSq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4oBy::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4oBy::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kSr_entry() //  [R1]
         { info_tbl: [(c4oBz,
                       label: sat_s4kSr_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oBz: // global
           _s4kSr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oBA; else goto c4oBB;
       c4oBB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oBD; else goto c4oBC;
       c4oBD: // global
           HpAlloc = 24;
           goto c4oBA;
       c4oBA: // global
           R1 = _s4kSr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oBC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSr::P64;
           _s4kRL::I64 = I64[_s4kSr::P64 + 24];
           _s4kSe::I64 = _s4kRL::I64 - I64[_s4kSr::P64 + 16];
           _s4kSf::I64 = I64[_s4kSr::P64 + 32] - _s4kSe::I64;
           I64[Hp - 16] = go_up_s4kSg_info;
           I64[Hp - 8] = _s4kSe::I64;
           I64[Hp] = _s4kSf::I64;
           R2 = _s4kRL::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kSg_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSd_entry() //  [R1]
         { info_tbl: [(c4oBN,
                       label: sat_s4kSd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oBN: // global
           _s4kSd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oBO; else goto c4oBP;
       c4oBP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oBR; else goto c4oBQ;
       c4oBR: // global
           HpAlloc = 16;
           goto c4oBO;
       c4oBO: // global
           R1 = _s4kSd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oBQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSd::P64;
           _s4kRK::I64 = I64[_s4kSd::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4oBX; else goto c4oBM;
       c4oBM: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4oBX; else goto c4oC1;
       c4oBX: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4oC1: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSv_entry() //  [R1]
         { info_tbl: [(c4oCf,
                       label: sat_s4kSv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oCf: // global
           _s4kSv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oCg; else goto c4oCh;
       c4oCh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oCj; else goto c4oCi;
       c4oCj: // global
           HpAlloc = 16;
           goto c4oCg;
       c4oCg: // global
           R1 = _s4kSv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oCi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSv::P64;
           _s4kRK::I64 = I64[_s4kSv::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4oCp; else goto c4oCe;
       c4oCe: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4oCp; else goto c4oCt;
       c4oCp: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4oCt: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4oCx,
                       label: GHC.Int.$w$cenumFromThenTo3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oCx: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4oCB; else goto c4oCA;
       c4oCB: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oCA: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4oCv; else goto c4oCw;
       c4oCv: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4oCE; else goto c4oCJ;
       c4oCE: // global
           I64[Hp - 80] = sat_s4kS5_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kRR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oCJ: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4oCQ; else goto c4oCH;
       c4oCH: // global
           I64[Hp - 80] = sat_s4kS9_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4oCF::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4oCF::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oCw: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4oCM; else goto c4oCR;
       c4oCM: // global
           I64[Hp - 80] = sat_s4kSr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kSd_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oCR: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4oCQ; else goto c4oCP;
       c4oCQ: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oCP: // global
           I64[Hp - 80] = sat_s4kSv_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4oCN::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4oCN::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.293967358 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4oCZ,
                       label: GHC.Int.$fEnumInt8_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oCZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oD8; else goto c4oD9;
       c4oD8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oD9: // global
           I64[Sp - 24] = block_c4oCW_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4oDi; else goto c4oCX;
       u4oDi: // global
           call _c4oCW(R1) args: 0, res: 0, upd: 0;
       c4oCX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oCW() //  [R1]
         { info_tbl: [(c4oCW,
                       label: block_c4oCW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oCW: // global
           I64[Sp] = block_c4oD2_info;
           _s4kSA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kSA::I64;
           if (R1 & 7 != 0) goto u4oDh; else goto c4oD3;
       u4oDh: // global
           call _c4oD2(R1) args: 0, res: 0, upd: 0;
       c4oD3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oD2() //  [R1]
         { info_tbl: [(c4oD2,
                       label: block_c4oD2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oD2: // global
           I64[Sp] = block_c4oD7_info;
           _s4kSC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kSC::I64;
           if (R1 & 7 != 0) goto u4oDj; else goto c4oDc;
       u4oDj: // global
           call _c4oD7(R1) args: 0, res: 0, upd: 0;
       c4oDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oD7() //  [R1]
         { info_tbl: [(c4oD7,
                       label: block_c4oD7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oD7: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo3_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.296585106 UTC

[section ""data" . GHC.Int.$w$cenumFromTo3_closure" {
     GHC.Int.$w$cenumFromTo3_closure:
         const GHC.Int.$w$cenumFromTo3_info;
         const 0;
 },
 sat_s4kSP_entry() //  [R1]
         { info_tbl: [(c4oDF,
                       label: sat_s4kSP_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oDF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oDG; else goto c4oDH;
       c4oDG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oDH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kSJ::I64 = I64[R1 + 32];
           if (_s4kSJ::I64 == I64[R1 + 24]) goto c4oDE; else goto c4oDD;
       c4oDE: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4oDD: // global
           R2 = _s4kSJ::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kSI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSM_entry() //  [R1]
         { info_tbl: [(c4oDT,
                       label: sat_s4kSM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oDT: // global
           _s4kSM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oDU; else goto c4oDV;
       c4oDV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oDX; else goto c4oDW;
       c4oDX: // global
           HpAlloc = 16;
           goto c4oDU;
       c4oDU: // global
           R1 = _s4kSM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oDW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSM::P64;
           _s4kSJ::I64 = I64[_s4kSM::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSJ::I64, (-128))) goto c4oE3; else goto c4oDS;
       c4oDS: // global
           if (%MO_S_Gt_W64(_s4kSJ::I64, 127)) goto c4oE3; else goto c4oE7;
       c4oE3: // global
           Hp = Hp - 16;
           R2 = _s4kSJ::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4oE7: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSJ::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kSI_entry() //  [R1, R2]
         { info_tbl: [(c4oE9,
                       label: go_s4kSI_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oE9: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4oEd; else goto c4oEc;
       c4oEd: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oEc: // global
           _s4kSG::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kSP_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kSG::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kSM_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo3_entry() //  [R2, R3]
         { info_tbl: [(c4oEh,
                       label: GHC.Int.$w$cenumFromTo3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oEh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oEl; else goto c4oEk;
       c4oEl: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oEk: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4oEf; else goto c4oEg;
       c4oEf: // global
           I64[Hp - 8] = go_s4kSI_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kSI_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4oEg: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.300730267 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4oEt,
                       label: GHC.Int.$fEnumInt8_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oEt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oEx; else goto c4oEy;
       c4oEx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oEy: // global
           I64[Sp - 16] = block_c4oEq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oEG; else goto c4oEr;
       u4oEG: // global
           call _c4oEq(R1) args: 0, res: 0, upd: 0;
       c4oEr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oEq() //  [R1]
         { info_tbl: [(c4oEq,
                       label: block_c4oEq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oEq: // global
           I64[Sp] = block_c4oEw_info;
           _s4kST::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kST::I64;
           if (R1 & 7 != 0) goto u4oEF; else goto c4oEA;
       u4oEF: // global
           call _c4oEw(R1) args: 0, res: 0, upd: 0;
       c4oEA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oEw() //  [R1]
         { info_tbl: [(c4oEw,
                       label: block_c4oEw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oEw: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo3_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.303975787 UTC

[section ""data" . GHC.Int.$wgo3_closure" {
     GHC.Int.$wgo3_closure:
         const GHC.Int.$wgo3_info;
         const 0;
 },
 sat_s4kT5_entry() //  [R1]
         { info_tbl: [(c4oET,
                       label: sat_s4kT5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oET: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oEU; else goto c4oF5;
       c4oEU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oF5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kT0::I64 = I64[R1 + 16];
           if (_s4kT0::I64 != 127) goto c4oER; else goto c4oES;
       c4oER: // global
           I64[Sp - 24] = block_c4oEZ_info;
           R2 = _s4kT0::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 24;
       c4oES: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4oEZ() //  [R1, R2]
         { info_tbl: [(c4oEZ,
                       label: block_c4oEZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oEZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oF4; else goto c4oF3;
       c4oF4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4oF3: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSZ_entry() //  [R1]
         { info_tbl: [(c4oFf,
                       label: sat_s4kSZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oFf: // global
           _s4kSZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oFg; else goto c4oFh;
       c4oFh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oFj; else goto c4oFi;
       c4oFj: // global
           HpAlloc = 16;
           goto c4oFg;
       c4oFg: // global
           R1 = _s4kSZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oFi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSZ::P64;
           _s4kSW::I64 = I64[_s4kSZ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSW::I64, (-128))) goto c4oFp; else goto c4oFe;
       c4oFe: // global
           if (%MO_S_Gt_W64(_s4kSW::I64, 127)) goto c4oFp; else goto c4oFt;
       c4oFp: // global
           Hp = Hp - 16;
           R2 = _s4kSW::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4oFt: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo3_entry() //  [R2]
         { info_tbl: [(c4oFu,
                       label: GHC.Int.$wgo3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oFu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4oFy; else goto c4oFx;
       c4oFy: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oFx: // global
           I64[Hp - 40] = sat_s4kT5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kSZ_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.307583689 UTC

[section ""data" . GHC.Int.$fEnumInt8_go_closure" {
     GHC.Int.$fEnumInt8_go_closure:
         const GHC.Int.$fEnumInt8_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_go_entry() //  [R2]
         { info_tbl: [(c4oFG,
                       label: GHC.Int.$fEnumInt8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oFG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oFH; else goto c4oFI;
       c4oFH: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oFI: // global
           I64[Sp - 8] = block_c4oFD_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oFD() //  [R1, R2]
         { info_tbl: [(c4oFD,
                       label: block_c4oFD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oFD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oFL; else goto c4oFK;
       c4oFL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oFK: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.309804185 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFrom_closure" {
     GHC.Int.$fEnumInt8_$cenumFrom_closure:
         const GHC.Int.$fEnumInt8_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4oFT,
                       label: GHC.Int.$fEnumInt8_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oFT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oFU; else goto c4oFV;
       c4oFU: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oFV: // global
           I64[Sp - 8] = block_c4oFQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oG4; else goto c4oFR;
       u4oG4: // global
           call _c4oFQ(R1) args: 0, res: 0, upd: 0;
       c4oFR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oFQ() //  [R1]
         { info_tbl: [(c4oFQ,
                       label: block_c4oFQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oFQ: // global
           _s4kTc::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kTc::I64, 127)) goto c4oG2; else goto c4oG3;
       c4oG2: // global
           R2 = _s4kTc::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_go_entry(R2) args: 8, res: 0, upd: 8;
       c4oG3: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.311740667 UTC

[section ""data" . GHC.Int.$fEnumInt8_closure" {
     GHC.Int.$fEnumInt8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt8_$csucc_closure+1;
         const GHC.Int.$fEnumInt8_$cpred_closure+1;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt8_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4oG9,
                       label: GHC.Int.$fEnumInt8_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oG9: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt8_closure+1;
           R2 = GHC.Int.$fEnumInt8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.313010027 UTC

[section ""cstring" . GHC.Int.$tcInt2_bytes" {
     GHC.Int.$tcInt2_bytes:
         I8[] [73,110,116,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.31423663 UTC

[section ""data" . GHC.Int.$fEnumInt1_closure" {
     GHC.Int.$fEnumInt1_closure:
         const GHC.Int.$fEnumInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt1_entry() //  [R1]
         { info_tbl: [(c4oGk,
                       label: GHC.Int.$fEnumInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oGk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oGl; else goto c4oGm;
       c4oGl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oGm: // global
           (_c4oGf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4oGf::I64 == 0) goto c4oGh; else goto c4oGg;
       c4oGh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4oGg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4oGf::I64;
           I64[Sp - 24] = block_c4oGi_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4oGi() //  [R1]
         { info_tbl: [(c4oGi,
                       label: block_c4oGi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oGi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.316267541 UTC

[section ""data" . GHC.Int.$fEnumInt2_closure" {
     GHC.Int.$fEnumInt2_closure:
         const GHC.Int.$fEnumInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt2_entry() //  [R1]
         { info_tbl: [(c4oGy,
                       label: GHC.Int.$fEnumInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oGy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oGz; else goto c4oGA;
       c4oGz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oGA: // global
           (_c4oGt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4oGt::I64 == 0) goto c4oGv; else goto c4oGu;
       c4oGv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4oGu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4oGt::I64;
           I64[Sp - 24] = block_c4oGw_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4oGw() //  [R1]
         { info_tbl: [(c4oGw,
                       label: block_c4oGw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oGw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.318563842 UTC

[section ""data" . GHC.Int.neInt16_closure" {
     GHC.Int.neInt16_closure:
         const GHC.Int.neInt16_info;
 },
 GHC.Int.neInt16_entry() //  [R2, R3]
         { info_tbl: [(c4oGL,
                       label: GHC.Int.neInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oGL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oGP; else goto c4oGQ;
       c4oGP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oGQ: // global
           I64[Sp - 16] = block_c4oGI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oGZ; else goto c4oGJ;
       u4oGZ: // global
           call _c4oGI(R1) args: 0, res: 0, upd: 0;
       c4oGJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oGI() //  [R1]
         { info_tbl: [(c4oGI,
                       label: block_c4oGI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oGI: // global
           I64[Sp] = block_c4oGO_info;
           _s4kTj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kTj::I64;
           if (R1 & 7 != 0) goto u4oGY; else goto c4oGS;
       u4oGY: // global
           call _c4oGO(R1) args: 0, res: 0, upd: 0;
       c4oGS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oGO() //  [R1]
         { info_tbl: [(c4oGO,
                       label: block_c4oGO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oGO: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.322336324 UTC

[section ""data" . lvl2_r4kPt_closure" {
     lvl2_r4kPt_closure:
         const lvl2_r4kPt_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r4kPt_entry() //  [R1]
         { info_tbl: [(c4oH6,
                       label: lvl2_r4kPt_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oH6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oH7; else goto c4oH8;
       c4oH7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oH8: // global
           (_c4oH3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4oH3::I64 == 0) goto c4oH5; else goto c4oH4;
       c4oH5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4oH4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4oH3::I64;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.323774022 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cminBound_closure" {
     GHC.Int.$fBoundedInt16_$cminBound_closure:
         const GHC.Int.I16#_con_info;
         const (-32768);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.325392912 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cpred_closure" {
     GHC.Int.$fEnumInt16_$cpred_closure:
         const GHC.Int.$fEnumInt16_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cpred_entry() //  [R2]
         { info_tbl: [(c4oHg,
                       label: GHC.Int.$fEnumInt16_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oHg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oHh; else goto c4oHi;
       c4oHh: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oHi: // global
           I64[Sp - 8] = block_c4oHd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oHA; else goto c4oHe;
       u4oHA: // global
           call _c4oHd(R1) args: 0, res: 0, upd: 0;
       c4oHe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oHd() //  [R1]
         { info_tbl: [(c4oHd,
                       label: block_c4oHd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oHd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oHn; else goto c4oHm;
       c4oHn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4oHm: // global
           _s4kTq::I64 = I64[R1 + 7];
           if (_s4kTq::I64 != (-32768)) goto c4oHy; else goto c4oHz;
       c4oHy: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4kTq::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oHz: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.327400126 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt16_$cmaxBound_closure:
         const GHC.Int.I16#_con_info;
         const 32767;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.328265978 UTC

[section ""data" . GHC.Int.$fBoundedInt16_closure" {
     GHC.Int.$fBoundedInt16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt16_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.329946784 UTC

[section ""data" . GHC.Int.$fEnumInt16_$csucc_closure" {
     GHC.Int.$fEnumInt16_$csucc_closure:
         const GHC.Int.$fEnumInt16_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$csucc_entry() //  [R2]
         { info_tbl: [(c4oHI,
                       label: GHC.Int.$fEnumInt16_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oHI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oHJ; else goto c4oHK;
       c4oHJ: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oHK: // global
           I64[Sp - 8] = block_c4oHF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oI2; else goto c4oHG;
       u4oI2: // global
           call _c4oHF(R1) args: 0, res: 0, upd: 0;
       c4oHG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oHF() //  [R1]
         { info_tbl: [(c4oHF,
                       label: block_c4oHF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oHF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oHP; else goto c4oHO;
       c4oHP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4oHO: // global
           _s4kTw::I64 = I64[R1 + 7];
           if (_s4kTw::I64 != 32767) goto c4oI0; else goto c4oI1;
       c4oI0: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4kTw::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oI1: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.332612198 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowsPrec_closure" {
     GHC.Int.$fShowInt16_$cshowsPrec_closure:
         const GHC.Int.$fShowInt16_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt16_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4oIa,
                       label: GHC.Int.$fShowInt16_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oIa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oIl; else goto c4oIm;
       c4oIl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oIm: // global
           I64[Sp - 24] = block_c4oI7_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4oIt; else goto c4oI8;
       u4oIt: // global
           call _c4oI7(R1) args: 0, res: 0, upd: 0;
       c4oI8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oI7() //  [R1]
         { info_tbl: [(c4oI7,
                       label: block_c4oI7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oI7: // global
           I64[Sp] = block_c4oId_info;
           _s4kTD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kTD::I64;
           if (R1 & 7 != 0) goto u4oIs; else goto c4oIe;
       u4oIs: // global
           call _c4oId(R1) args: 0, res: 0, upd: 0;
       c4oIe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oId() //  [R1]
         { info_tbl: [(c4oId,
                       label: block_c4oId_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oId: // global
           _s4kTB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4oIi_info;
           R4 = _s4kTB::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oIi() //  [R1, R2]
         { info_tbl: [(c4oIi,
                       label: block_c4oIi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oIi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oIr; else goto c4oIq;
       c4oIr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oIq: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.335771344 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshow_closure" {
     GHC.Int.$fShowInt16_$cshow_closure:
         const GHC.Int.$fShowInt16_$cshow_info;
 },
 GHC.Int.$fShowInt16_$cshow_entry() //  [R2]
         { info_tbl: [(c4oIB,
                       label: GHC.Int.$fShowInt16_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oIB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oIH; else goto c4oII;
       c4oIH: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oII: // global
           I64[Sp - 8] = block_c4oIy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oIN; else goto c4oIz;
       u4oIN: // global
           call _c4oIy(R1) args: 0, res: 0, upd: 0;
       c4oIz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oIy() //  [R1]
         { info_tbl: [(c4oIy,
                       label: block_c4oIy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oIy: // global
           I64[Sp] = block_c4oIE_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oIE() //  [R1, R2]
         { info_tbl: [(c4oIE,
                       label: block_c4oIE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oIE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oIM; else goto c4oIL;
       c4oIM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oIL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.33846037 UTC

[section ""data" . GHC.Int.$fShowInt1_closure" {
     GHC.Int.$fShowInt1_closure:
         const GHC.Int.$fShowInt1_info;
 },
 GHC.Int.$fShowInt1_entry() //  [R2, R3]
         { info_tbl: [(c4oIV,
                       label: GHC.Int.$fShowInt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oIV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oJ1; else goto c4oJ2;
       c4oJ1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oJ2: // global
           I64[Sp - 16] = block_c4oIS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oJ7; else goto c4oIT;
       u4oJ7: // global
           call _c4oIS(R1) args: 0, res: 0, upd: 0;
       c4oIT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oIS() //  [R1]
         { info_tbl: [(c4oIS,
                       label: block_c4oIS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oIS: // global
           _s4kTQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4oIY_info;
           R4 = _s4kTQ::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oIY() //  [R1, R2]
         { info_tbl: [(c4oIY,
                       label: block_c4oIY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oIY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oJ6; else goto c4oJ5;
       c4oJ6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oJ5: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.340780458 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowList_closure" {
     GHC.Int.$fShowInt16_$cshowList_closure:
         const GHC.Int.$fShowInt16_$cshowList_info;
 },
 GHC.Int.$fShowInt16_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4oJc,
                       label: GHC.Int.$fShowInt16_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oJc: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.341958939 UTC

[section ""data" . GHC.Int.$fShowInt16_closure" {
     GHC.Int.$fShowInt16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt16_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt16_$cshow_closure+1;
         const GHC.Int.$fShowInt16_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.343081389 UTC

[section ""data" . GHC.Int.$wlvl_closure" {
     GHC.Int.$wlvl_closure:
         const GHC.Int.$wlvl_info;
         const 0;
 },
 GHC.Int.$wlvl_entry() //  [R2]
         { info_tbl: [(c4oJj,
                       label: GHC.Int.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oJj: // global
           R6 = GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r4kPt_closure;
           R2 = GHC.Int.$fShowInt16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.344690984 UTC

[section ""data" . GHC.Int.$w$ctoEnum_closure" {
     GHC.Int.$w$ctoEnum_closure:
         const GHC.Int.$w$ctoEnum_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4oJv,
                       label: GHC.Int.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oJv: // global
           _s4kTZ::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-32768))) goto c4oJD; else goto c4oJu;
       c4oJu: // global
           if (%MO_S_Gt_W64(_s4kTZ::I64, 32767)) goto c4oJD; else goto c4oJE;
       c4oJD: // global
           R2 = _s4kTZ::I64;
           call GHC.Int.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c4oJE: // global
           R1 = _s4kTZ::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.346568799 UTC

[section ""data" . GHC.Int.$fEnumInt16_$ctoEnum_closure" {
     GHC.Int.$fEnumInt16_$ctoEnum_closure:
         const GHC.Int.$fEnumInt16_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4oJM,
                       label: GHC.Int.$fEnumInt16_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oJM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oJU; else goto c4oJV;
       c4oJU: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oJV: // global
           I64[Sp - 8] = block_c4oJJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oK0; else goto c4oJK;
       u4oK0: // global
           call _c4oJJ(R1) args: 0, res: 0, upd: 0;
       c4oJK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oJJ() //  [R1]
         { info_tbl: [(c4oJJ,
                       label: block_c4oJJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oJJ: // global
           I64[Sp] = block_c4oJP_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oJP() //  [R1]
         { info_tbl: [(c4oJP,
                       label: block_c4oJP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oJP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oJZ; else goto c4oJY;
       c4oJZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4oJY: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.354906729 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo_closure" {
     GHC.Int.$w$cenumFromThenTo_closure:
         const GHC.Int.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s4kUp_entry() //  [R1]
         { info_tbl: [(c4oKz,
                       label: sat_s4kUp_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oKz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oKA; else goto c4oKB;
       c4oKA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oKB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kUi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUn_entry() //  [R1]
         { info_tbl: [(c4oKL,
                       label: sat_s4kUn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oKL: // global
           _s4kUn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oKM; else goto c4oKN;
       c4oKN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oKP; else goto c4oKO;
       c4oKP: // global
           HpAlloc = 16;
           goto c4oKM;
       c4oKM: // global
           R1 = _s4kUn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oKO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUn::P64;
           _s4kUj::I64 = I64[_s4kUn::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUj::I64,
                            (-32768))) goto c4oKV; else goto c4oKK;
       c4oKK: // global
           if (%MO_S_Gt_W64(_s4kUj::I64, 32767)) goto c4oKV; else goto c4oKZ;
       c4oKV: // global
           Hp = Hp - 16;
           R2 = _s4kUj::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4oKZ: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUs_entry() //  [R1]
         { info_tbl: [(c4oLa,
                       label: sat_s4kUs_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oLa: // global
           _s4kUs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oLb; else goto c4oLc;
       c4oLc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oLe; else goto c4oLd;
       c4oLe: // global
           HpAlloc = 16;
           goto c4oLb;
       c4oLb: // global
           R1 = _s4kUs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oLd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUs::P64;
           _s4kUj::I64 = I64[_s4kUs::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUj::I64,
                            (-32768))) goto c4oLk; else goto c4oL9;
       c4oL9: // global
           if (%MO_S_Gt_W64(_s4kUj::I64, 32767)) goto c4oLk; else goto c4oLo;
       c4oLk: // global
           Hp = Hp - 16;
           R2 = _s4kUj::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4oLo: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kUi_entry() //  [R1, R2]
         { info_tbl: [(c4oLs,
                       label: go_dn_s4kUi_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oLs: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4oLw; else goto c4oLv;
       c4oLw: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oLv: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4oLq; else goto c4oLr;
       c4oLq: // global
           _s4kUg::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kUp_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kUg::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kUn_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oLr: // global
           I64[Hp - 80] = sat_s4kUs_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4oLy::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4oLy::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kUt_entry() //  [R1]
         { info_tbl: [(c4oLz,
                       label: sat_s4kUt_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oLz: // global
           _s4kUt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oLA; else goto c4oLB;
       c4oLB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oLD; else goto c4oLC;
       c4oLD: // global
           HpAlloc = 24;
           goto c4oLA;
       c4oLA: // global
           R1 = _s4kUt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oLC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUt::P64;
           _s4kU9::I64 = I64[_s4kUt::P64 + 24];
           _s4kUg::I64 = _s4kU9::I64 - I64[_s4kUt::P64 + 16];
           _s4kUh::I64 = I64[_s4kUt::P64 + 32] - _s4kUg::I64;
           I64[Hp - 16] = go_dn_s4kUi_info;
           I64[Hp - 8] = _s4kUg::I64;
           I64[Hp] = _s4kUh::I64;
           R2 = _s4kU9::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kUi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUf_entry() //  [R1]
         { info_tbl: [(c4oLN,
                       label: sat_s4kUf_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oLN: // global
           _s4kUf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oLO; else goto c4oLP;
       c4oLP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oLR; else goto c4oLQ;
       c4oLR: // global
           HpAlloc = 16;
           goto c4oLO;
       c4oLO: // global
           R1 = _s4kUf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oLQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUf::P64;
           _s4kU8::I64 = I64[_s4kUf::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4oLX; else goto c4oLM;
       c4oLM: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4oLX; else goto c4oM1;
       c4oLX: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4oM1: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUx_entry() //  [R1]
         { info_tbl: [(c4oMf,
                       label: sat_s4kUx_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oMf: // global
           _s4kUx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oMg; else goto c4oMh;
       c4oMh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oMj; else goto c4oMi;
       c4oMj: // global
           HpAlloc = 16;
           goto c4oMg;
       c4oMg: // global
           R1 = _s4kUx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oMi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUx::P64;
           _s4kU8::I64 = I64[_s4kUx::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4oMp; else goto c4oMe;
       c4oMe: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4oMp; else goto c4oMt;
       c4oMp: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4oMt: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUL_entry() //  [R1]
         { info_tbl: [(c4oMW,
                       label: sat_s4kUL_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oMW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oMX; else goto c4oMY;
       c4oMX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oMY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kUE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUJ_entry() //  [R1]
         { info_tbl: [(c4oN8,
                       label: sat_s4kUJ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oN8: // global
           _s4kUJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oN9; else goto c4oNa;
       c4oNa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oNc; else goto c4oNb;
       c4oNc: // global
           HpAlloc = 16;
           goto c4oN9;
       c4oN9: // global
           R1 = _s4kUJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oNb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUJ::P64;
           _s4kUF::I64 = I64[_s4kUJ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUF::I64,
                            (-32768))) goto c4oNi; else goto c4oN7;
       c4oN7: // global
           if (%MO_S_Gt_W64(_s4kUF::I64, 32767)) goto c4oNi; else goto c4oNm;
       c4oNi: // global
           Hp = Hp - 16;
           R2 = _s4kUF::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4oNm: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUF::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUO_entry() //  [R1]
         { info_tbl: [(c4oNx,
                       label: sat_s4kUO_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oNx: // global
           _s4kUO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oNy; else goto c4oNz;
       c4oNz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oNB; else goto c4oNA;
       c4oNB: // global
           HpAlloc = 16;
           goto c4oNy;
       c4oNy: // global
           R1 = _s4kUO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oNA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUO::P64;
           _s4kUF::I64 = I64[_s4kUO::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUF::I64,
                            (-32768))) goto c4oNH; else goto c4oNw;
       c4oNw: // global
           if (%MO_S_Gt_W64(_s4kUF::I64, 32767)) goto c4oNH; else goto c4oNL;
       c4oNH: // global
           Hp = Hp - 16;
           R2 = _s4kUF::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4oNL: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUF::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kUE_entry() //  [R1, R2]
         { info_tbl: [(c4oNP,
                       label: go_up_s4kUE_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oNP: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4oNT; else goto c4oNS;
       c4oNT: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oNS: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4oNN; else goto c4oNO;
       c4oNN: // global
           _s4kUC::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kUL_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kUC::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kUJ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oNO: // global
           I64[Hp - 80] = sat_s4kUO_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4oNV::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4oNV::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kUP_entry() //  [R1]
         { info_tbl: [(c4oNW,
                       label: sat_s4kUP_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oNW: // global
           _s4kUP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oNX; else goto c4oNY;
       c4oNY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oO0; else goto c4oNZ;
       c4oO0: // global
           HpAlloc = 24;
           goto c4oNX;
       c4oNX: // global
           R1 = _s4kUP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oNZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUP::P64;
           _s4kU9::I64 = I64[_s4kUP::P64 + 24];
           _s4kUC::I64 = _s4kU9::I64 - I64[_s4kUP::P64 + 16];
           _s4kUD::I64 = I64[_s4kUP::P64 + 32] - _s4kUC::I64;
           I64[Hp - 16] = go_up_s4kUE_info;
           I64[Hp - 8] = _s4kUC::I64;
           I64[Hp] = _s4kUD::I64;
           R2 = _s4kU9::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kUE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUB_entry() //  [R1]
         { info_tbl: [(c4oOa,
                       label: sat_s4kUB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oOa: // global
           _s4kUB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oOb; else goto c4oOc;
       c4oOc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oOe; else goto c4oOd;
       c4oOe: // global
           HpAlloc = 16;
           goto c4oOb;
       c4oOb: // global
           R1 = _s4kUB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oOd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUB::P64;
           _s4kU8::I64 = I64[_s4kUB::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4oOk; else goto c4oO9;
       c4oO9: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4oOk; else goto c4oOo;
       c4oOk: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4oOo: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUT_entry() //  [R1]
         { info_tbl: [(c4oOC,
                       label: sat_s4kUT_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oOC: // global
           _s4kUT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oOD; else goto c4oOE;
       c4oOE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oOG; else goto c4oOF;
       c4oOG: // global
           HpAlloc = 16;
           goto c4oOD;
       c4oOD: // global
           R1 = _s4kUT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oOF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUT::P64;
           _s4kU8::I64 = I64[_s4kUT::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4oOM; else goto c4oOB;
       c4oOB: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4oOM; else goto c4oOQ;
       c4oOM: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4oOQ: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4oOU,
                       label: GHC.Int.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oOU: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4oOY; else goto c4oOX;
       c4oOY: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oOX: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4oOS; else goto c4oOT;
       c4oOS: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4oP1; else goto c4oP6;
       c4oP1: // global
           I64[Hp - 80] = sat_s4kUt_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kUf_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oP6: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4oPd; else goto c4oP4;
       c4oP4: // global
           I64[Hp - 80] = sat_s4kUx_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4oP2::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4oP2::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oOT: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4oP9; else goto c4oPe;
       c4oP9: // global
           I64[Hp - 80] = sat_s4kUP_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kUB_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oPe: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4oPd; else goto c4oPc;
       c4oPd: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oPc: // global
           I64[Hp - 80] = sat_s4kUT_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4oPa::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4oPa::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.370857308 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4oPm,
                       label: GHC.Int.$fEnumInt16_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oPm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oPv; else goto c4oPw;
       c4oPv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oPw: // global
           I64[Sp - 24] = block_c4oPj_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4oPF; else goto c4oPk;
       u4oPF: // global
           call _c4oPj(R1) args: 0, res: 0, upd: 0;
       c4oPk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oPj() //  [R1]
         { info_tbl: [(c4oPj,
                       label: block_c4oPj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oPj: // global
           I64[Sp] = block_c4oPp_info;
           _s4kUY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kUY::I64;
           if (R1 & 7 != 0) goto u4oPE; else goto c4oPq;
       u4oPE: // global
           call _c4oPp(R1) args: 0, res: 0, upd: 0;
       c4oPq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oPp() //  [R1]
         { info_tbl: [(c4oPp,
                       label: block_c4oPp_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oPp: // global
           I64[Sp] = block_c4oPu_info;
           _s4kV0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kV0::I64;
           if (R1 & 7 != 0) goto u4oPG; else goto c4oPz;
       u4oPG: // global
           call _c4oPu(R1) args: 0, res: 0, upd: 0;
       c4oPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oPu() //  [R1]
         { info_tbl: [(c4oPu,
                       label: block_c4oPu_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oPu: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.374833307 UTC

[section ""data" . GHC.Int.$w$cenumFromTo_closure" {
     GHC.Int.$w$cenumFromTo_closure:
         const GHC.Int.$w$cenumFromTo_info;
         const 0;
 },
 sat_s4kVd_entry() //  [R1]
         { info_tbl: [(c4oQ2,
                       label: sat_s4kVd_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oQ2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oQ3; else goto c4oQ4;
       c4oQ3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oQ4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kV7::I64 = I64[R1 + 32];
           if (_s4kV7::I64 == I64[R1 + 24]) goto c4oQ1; else goto c4oQ0;
       c4oQ1: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4oQ0: // global
           R2 = _s4kV7::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kV6_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kVa_entry() //  [R1]
         { info_tbl: [(c4oQg,
                       label: sat_s4kVa_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oQg: // global
           _s4kVa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oQh; else goto c4oQi;
       c4oQi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oQk; else goto c4oQj;
       c4oQk: // global
           HpAlloc = 16;
           goto c4oQh;
       c4oQh: // global
           R1 = _s4kVa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oQj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kVa::P64;
           _s4kV7::I64 = I64[_s4kVa::P64 + 16];
           if (%MO_S_Lt_W64(_s4kV7::I64,
                            (-32768))) goto c4oQq; else goto c4oQf;
       c4oQf: // global
           if (%MO_S_Gt_W64(_s4kV7::I64, 32767)) goto c4oQq; else goto c4oQu;
       c4oQq: // global
           Hp = Hp - 16;
           R2 = _s4kV7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4oQu: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kV7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kV6_entry() //  [R1, R2]
         { info_tbl: [(c4oQw,
                       label: go_s4kV6_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oQw: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4oQA; else goto c4oQz;
       c4oQA: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oQz: // global
           _s4kV4::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kVd_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kV4::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kVa_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4oQE,
                       label: GHC.Int.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oQE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oQI; else goto c4oQH;
       c4oQI: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oQH: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4oQC; else goto c4oQD;
       c4oQC: // global
           I64[Hp - 8] = go_s4kV6_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kV6_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4oQD: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.378682947 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4oQQ,
                       label: GHC.Int.$fEnumInt16_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oQQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oQU; else goto c4oQV;
       c4oQU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oQV: // global
           I64[Sp - 16] = block_c4oQN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oR3; else goto c4oQO;
       u4oR3: // global
           call _c4oQN(R1) args: 0, res: 0, upd: 0;
       c4oQO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oQN() //  [R1]
         { info_tbl: [(c4oQN,
                       label: block_c4oQN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oQN: // global
           I64[Sp] = block_c4oQT_info;
           _s4kVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kVh::I64;
           if (R1 & 7 != 0) goto u4oR2; else goto c4oQX;
       u4oR2: // global
           call _c4oQT(R1) args: 0, res: 0, upd: 0;
       c4oQX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oQT() //  [R1]
         { info_tbl: [(c4oQT,
                       label: block_c4oQT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oQT: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.381783686 UTC

[section ""data" . GHC.Int.$wgo_closure" {
     GHC.Int.$wgo_closure:
         const GHC.Int.$wgo_info;
         const 0;
 },
 sat_s4kVt_entry() //  [R1]
         { info_tbl: [(c4oRg,
                       label: sat_s4kVt_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oRg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oRh; else goto c4oRs;
       c4oRh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oRs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kVo::I64 = I64[R1 + 16];
           if (_s4kVo::I64 != 32767) goto c4oRe; else goto c4oRf;
       c4oRe: // global
           I64[Sp - 24] = block_c4oRm_info;
           R2 = _s4kVo::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c4oRf: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4oRm() //  [R1, R2]
         { info_tbl: [(c4oRm,
                       label: block_c4oRm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oRm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oRr; else goto c4oRq;
       c4oRr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4oRq: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kVn_entry() //  [R1]
         { info_tbl: [(c4oRC,
                       label: sat_s4kVn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oRC: // global
           _s4kVn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oRD; else goto c4oRE;
       c4oRE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oRG; else goto c4oRF;
       c4oRG: // global
           HpAlloc = 16;
           goto c4oRD;
       c4oRD: // global
           R1 = _s4kVn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oRF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kVn::P64;
           _s4kVk::I64 = I64[_s4kVn::P64 + 16];
           if (%MO_S_Lt_W64(_s4kVk::I64,
                            (-32768))) goto c4oRM; else goto c4oRB;
       c4oRB: // global
           if (%MO_S_Gt_W64(_s4kVk::I64, 32767)) goto c4oRM; else goto c4oRQ;
       c4oRM: // global
           Hp = Hp - 16;
           R2 = _s4kVk::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4oRQ: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kVk::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo_entry() //  [R2]
         { info_tbl: [(c4oRR,
                       label: GHC.Int.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oRR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4oRV; else goto c4oRU;
       c4oRV: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oRU: // global
           I64[Hp - 40] = sat_s4kVt_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kVn_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.384011068 UTC

[section ""data" . GHC.Int.$fEnumInt16_go_closure" {
     GHC.Int.$fEnumInt16_go_closure:
         const GHC.Int.$fEnumInt16_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_go_entry() //  [R2]
         { info_tbl: [(c4oS3,
                       label: GHC.Int.$fEnumInt16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oS3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oS4; else goto c4oS5;
       c4oS4: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oS5: // global
           I64[Sp - 8] = block_c4oS0_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oS0() //  [R1, R2]
         { info_tbl: [(c4oS0,
                       label: block_c4oS0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oS0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oS8; else goto c4oS7;
       c4oS8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oS7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.38552163 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFrom_closure" {
     GHC.Int.$fEnumInt16_$cenumFrom_closure:
         const GHC.Int.$fEnumInt16_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4oSg,
                       label: GHC.Int.$fEnumInt16_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oSg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oSh; else goto c4oSi;
       c4oSh: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oSi: // global
           I64[Sp - 8] = block_c4oSd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oSr; else goto c4oSe;
       u4oSr: // global
           call _c4oSd(R1) args: 0, res: 0, upd: 0;
       c4oSe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oSd() //  [R1]
         { info_tbl: [(c4oSd,
                       label: block_c4oSd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oSd: // global
           _s4kVA::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kVA::I64, 32767)) goto c4oSp; else goto c4oSq;
       c4oSp: // global
           R2 = _s4kVA::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_go_entry(R2) args: 8, res: 0, upd: 8;
       c4oSq: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.386785721 UTC

[section ""data" . GHC.Int.$fEnumInt16_closure" {
     GHC.Int.$fEnumInt16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt16_$csucc_closure+1;
         const GHC.Int.$fEnumInt16_$cpred_closure+1;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt16_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4oSw,
                       label: GHC.Int.$fEnumInt16_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oSw: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt16_closure+1;
           R2 = GHC.Int.$fEnumInt16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.387738717 UTC

[section ""cstring" . GHC.Int.$tcInt4_bytes" {
     GHC.Int.$tcInt4_bytes:
         I8[] [73,110,116,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.388641534 UTC

[section ""data" . GHC.Int.$fEnumInt3_closure" {
     GHC.Int.$fEnumInt3_closure:
         const GHC.Int.$fEnumInt3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt3_entry() //  [R1]
         { info_tbl: [(c4oSH,
                       label: GHC.Int.$fEnumInt3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oSH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oSI; else goto c4oSJ;
       c4oSI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oSJ: // global
           (_c4oSC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4oSC::I64 == 0) goto c4oSE; else goto c4oSD;
       c4oSE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4oSD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4oSC::I64;
           I64[Sp - 24] = block_c4oSF_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4oSF() //  [R1]
         { info_tbl: [(c4oSF,
                       label: block_c4oSF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oSF: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.390049361 UTC

[section ""data" . GHC.Int.$fEnumInt4_closure" {
     GHC.Int.$fEnumInt4_closure:
         const GHC.Int.$fEnumInt4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt4_entry() //  [R1]
         { info_tbl: [(c4oSV,
                       label: GHC.Int.$fEnumInt4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oSV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oSW; else goto c4oSX;
       c4oSW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oSX: // global
           (_c4oSQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4oSQ::I64 == 0) goto c4oSS; else goto c4oSR;
       c4oSS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4oSR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4oSQ::I64;
           I64[Sp - 24] = block_c4oST_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4oST() //  [R1]
         { info_tbl: [(c4oST,
                       label: block_c4oST_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oST: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.392480418 UTC

[section ""data" . GHC.Int.neInt32_closure" {
     GHC.Int.neInt32_closure:
         const GHC.Int.neInt32_info;
 },
 GHC.Int.neInt32_entry() //  [R2, R3]
         { info_tbl: [(c4oT8,
                       label: GHC.Int.neInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oT8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oTc; else goto c4oTd;
       c4oTc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oTd: // global
           I64[Sp - 16] = block_c4oT5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oTm; else goto c4oT6;
       u4oTm: // global
           call _c4oT5(R1) args: 0, res: 0, upd: 0;
       c4oT6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oT5() //  [R1]
         { info_tbl: [(c4oT5,
                       label: block_c4oT5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oT5: // global
           I64[Sp] = block_c4oTb_info;
           _s4kVH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kVH::I64;
           if (R1 & 7 != 0) goto u4oTl; else goto c4oTf;
       u4oTl: // global
           call _c4oTb(R1) args: 0, res: 0, upd: 0;
       c4oTf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oTb() //  [R1]
         { info_tbl: [(c4oTb,
                       label: block_c4oTb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oTb: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.394058574 UTC

[section ""data" . lvl4_r4kPv_closure" {
     lvl4_r4kPv_closure:
         const lvl4_r4kPv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r4kPv_entry() //  [R1]
         { info_tbl: [(c4oTt,
                       label: lvl4_r4kPv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oTt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oTu; else goto c4oTv;
       c4oTu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oTv: // global
           (_c4oTq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4oTq::I64 == 0) goto c4oTs; else goto c4oTr;
       c4oTs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4oTr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4oTq::I64;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.394964399 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cminBound_closure" {
     GHC.Int.$fBoundedInt32_$cminBound_closure:
         const GHC.Int.I32#_con_info;
         const (-2147483648);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.395945824 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cpred_closure" {
     GHC.Int.$fEnumInt32_$cpred_closure:
         const GHC.Int.$fEnumInt32_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cpred_entry() //  [R2]
         { info_tbl: [(c4oTD,
                       label: GHC.Int.$fEnumInt32_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oTD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oTE; else goto c4oTF;
       c4oTE: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oTF: // global
           I64[Sp - 8] = block_c4oTA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oTX; else goto c4oTB;
       u4oTX: // global
           call _c4oTA(R1) args: 0, res: 0, upd: 0;
       c4oTB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oTA() //  [R1]
         { info_tbl: [(c4oTA,
                       label: block_c4oTA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oTA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oTK; else goto c4oTJ;
       c4oTK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4oTJ: // global
           _s4kVO::I64 = I64[R1 + 7];
           if (_s4kVO::I64 != (-2147483648)) goto c4oTV; else goto c4oTW;
       c4oTV: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4kVO::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oTW: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.397157901 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt32_$cmaxBound_closure:
         const GHC.Int.I32#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.397794881 UTC

[section ""data" . GHC.Int.$fBoundedInt32_closure" {
     GHC.Int.$fBoundedInt32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt32_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.398827302 UTC

[section ""data" . GHC.Int.$fEnumInt32_$csucc_closure" {
     GHC.Int.$fEnumInt32_$csucc_closure:
         const GHC.Int.$fEnumInt32_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$csucc_entry() //  [R2]
         { info_tbl: [(c4oU5,
                       label: GHC.Int.$fEnumInt32_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oU5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oU6; else goto c4oU7;
       c4oU6: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oU7: // global
           I64[Sp - 8] = block_c4oU2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oUp; else goto c4oU3;
       u4oUp: // global
           call _c4oU2(R1) args: 0, res: 0, upd: 0;
       c4oU3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oU2() //  [R1]
         { info_tbl: [(c4oU2,
                       label: block_c4oU2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oU2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oUc; else goto c4oUb;
       c4oUc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4oUb: // global
           _s4kVU::I64 = I64[R1 + 7];
           if (_s4kVU::I64 != 2147483647) goto c4oUn; else goto c4oUo;
       c4oUn: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4kVU::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4oUo: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.400500835 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowsPrec_closure" {
     GHC.Int.$fShowInt32_$cshowsPrec_closure:
         const GHC.Int.$fShowInt32_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt32_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4oUx,
                       label: GHC.Int.$fShowInt32_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oUx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oUI; else goto c4oUJ;
       c4oUI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oUJ: // global
           I64[Sp - 24] = block_c4oUu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4oUQ; else goto c4oUv;
       u4oUQ: // global
           call _c4oUu(R1) args: 0, res: 0, upd: 0;
       c4oUv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oUu() //  [R1]
         { info_tbl: [(c4oUu,
                       label: block_c4oUu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oUu: // global
           I64[Sp] = block_c4oUA_info;
           _s4kW1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kW1::I64;
           if (R1 & 7 != 0) goto u4oUP; else goto c4oUB;
       u4oUP: // global
           call _c4oUA(R1) args: 0, res: 0, upd: 0;
       c4oUB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oUA() //  [R1]
         { info_tbl: [(c4oUA,
                       label: block_c4oUA_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oUA: // global
           _s4kVZ::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4oUF_info;
           R4 = _s4kVZ::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oUF() //  [R1, R2]
         { info_tbl: [(c4oUF,
                       label: block_c4oUF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oUF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oUO; else goto c4oUN;
       c4oUO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oUN: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.402451509 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshow_closure" {
     GHC.Int.$fShowInt32_$cshow_closure:
         const GHC.Int.$fShowInt32_$cshow_info;
 },
 GHC.Int.$fShowInt32_$cshow_entry() //  [R2]
         { info_tbl: [(c4oUY,
                       label: GHC.Int.$fShowInt32_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oUY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oV4; else goto c4oV5;
       c4oV4: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oV5: // global
           I64[Sp - 8] = block_c4oUV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oVa; else goto c4oUW;
       u4oVa: // global
           call _c4oUV(R1) args: 0, res: 0, upd: 0;
       c4oUW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oUV() //  [R1]
         { info_tbl: [(c4oUV,
                       label: block_c4oUV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oUV: // global
           I64[Sp] = block_c4oV1_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oV1() //  [R1, R2]
         { info_tbl: [(c4oV1,
                       label: block_c4oV1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oV1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oV9; else goto c4oV8;
       c4oV9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oV8: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.404073115 UTC

[section ""data" . GHC.Int.$fShowInt2_closure" {
     GHC.Int.$fShowInt2_closure:
         const GHC.Int.$fShowInt2_info;
 },
 GHC.Int.$fShowInt2_entry() //  [R2, R3]
         { info_tbl: [(c4oVi,
                       label: GHC.Int.$fShowInt2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oVi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oVo; else goto c4oVp;
       c4oVo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oVp: // global
           I64[Sp - 16] = block_c4oVf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oVu; else goto c4oVg;
       u4oVu: // global
           call _c4oVf(R1) args: 0, res: 0, upd: 0;
       c4oVg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oVf() //  [R1]
         { info_tbl: [(c4oVf,
                       label: block_c4oVf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oVf: // global
           _s4kWe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4oVl_info;
           R4 = _s4kWe::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oVl() //  [R1, R2]
         { info_tbl: [(c4oVl,
                       label: block_c4oVl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oVl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oVt; else goto c4oVs;
       c4oVt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oVs: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.405600075 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowList_closure" {
     GHC.Int.$fShowInt32_$cshowList_closure:
         const GHC.Int.$fShowInt32_$cshowList_info;
 },
 GHC.Int.$fShowInt32_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4oVz,
                       label: GHC.Int.$fShowInt32_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oVz: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.406324546 UTC

[section ""data" . GHC.Int.$fShowInt32_closure" {
     GHC.Int.$fShowInt32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt32_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt32_$cshow_closure+1;
         const GHC.Int.$fShowInt32_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.407076419 UTC

[section ""data" . GHC.Int.$wlvl1_closure" {
     GHC.Int.$wlvl1_closure:
         const GHC.Int.$wlvl1_info;
         const 0;
 },
 GHC.Int.$wlvl1_entry() //  [R2]
         { info_tbl: [(c4oVG,
                       label: GHC.Int.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oVG: // global
           R6 = GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r4kPv_closure;
           R2 = GHC.Int.$fShowInt32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.408175081 UTC

[section ""data" . GHC.Int.$w$ctoEnum1_closure" {
     GHC.Int.$w$ctoEnum1_closure:
         const GHC.Int.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum1_entry() //  [R2]
         { info_tbl: [(c4oVS,
                       label: GHC.Int.$w$ctoEnum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oVS: // global
           _s4kWn::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-2147483648))) goto c4oW0; else goto c4oVR;
       c4oVR: // global
           if (%MO_S_Gt_W64(_s4kWn::I64,
                            2147483647)) goto c4oW0; else goto c4oW1;
       c4oW0: // global
           R2 = _s4kWn::I64;
           call GHC.Int.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c4oW1: // global
           R1 = _s4kWn::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.409349293 UTC

[section ""data" . GHC.Int.$fEnumInt32_$ctoEnum_closure" {
     GHC.Int.$fEnumInt32_$ctoEnum_closure:
         const GHC.Int.$fEnumInt32_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4oW9,
                       label: GHC.Int.$fEnumInt32_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oW9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oWh; else goto c4oWi;
       c4oWh: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oWi: // global
           I64[Sp - 8] = block_c4oW6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oWn; else goto c4oW7;
       u4oWn: // global
           call _c4oW6(R1) args: 0, res: 0, upd: 0;
       c4oW7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oW6() //  [R1]
         { info_tbl: [(c4oW6,
                       label: block_c4oW6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oW6: // global
           I64[Sp] = block_c4oWc_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oWc() //  [R1]
         { info_tbl: [(c4oWc,
                       label: block_c4oWc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oWc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oWm; else goto c4oWl;
       c4oWm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4oWl: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.411547898 UTC

[section ""data" . GHC.Int.$w$cenumFromTo1_closure" {
     GHC.Int.$w$cenumFromTo1_closure:
         const GHC.Int.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s4kWG_entry() //  [R1]
         { info_tbl: [(c4oWJ,
                       label: sat_s4kWG_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oWJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oWK; else goto c4oWL;
       c4oWK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oWL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kWA::I64 = I64[R1 + 32];
           if (_s4kWA::I64 == I64[R1 + 24]) goto c4oWI; else goto c4oWH;
       c4oWI: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4oWH: // global
           R2 = _s4kWA::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kWz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kWD_entry() //  [R1]
         { info_tbl: [(c4oWX,
                       label: sat_s4kWD_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oWX: // global
           _s4kWD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oWY; else goto c4oWZ;
       c4oWZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oX1; else goto c4oX0;
       c4oX1: // global
           HpAlloc = 16;
           goto c4oWY;
       c4oWY: // global
           R1 = _s4kWD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oX0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kWD::P64;
           _s4kWA::I64 = I64[_s4kWD::P64 + 16];
           if (%MO_S_Lt_W64(_s4kWA::I64,
                            (-2147483648))) goto c4oX7; else goto c4oWW;
       c4oWW: // global
           if (%MO_S_Gt_W64(_s4kWA::I64,
                            2147483647)) goto c4oX7; else goto c4oXb;
       c4oX7: // global
           Hp = Hp - 16;
           R2 = _s4kWA::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4oXb: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kWA::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kWz_entry() //  [R1, R2]
         { info_tbl: [(c4oXd,
                       label: go_s4kWz_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oXd: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4oXh; else goto c4oXg;
       c4oXh: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oXg: // global
           _s4kWx::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kWG_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kWx::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kWD_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo1_entry() //  [R2, R3]
         { info_tbl: [(c4oXl,
                       label: GHC.Int.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oXl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oXp; else goto c4oXo;
       c4oXp: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oXo: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4oXj; else goto c4oXk;
       c4oXj: // global
           I64[Hp - 8] = go_s4kWz_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kWz_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4oXk: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.41503225 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4oXx,
                       label: GHC.Int.$fEnumInt32_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oXx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oXB; else goto c4oXC;
       c4oXB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4oXC: // global
           I64[Sp - 16] = block_c4oXu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4oXK; else goto c4oXv;
       u4oXK: // global
           call _c4oXu(R1) args: 0, res: 0, upd: 0;
       c4oXv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oXu() //  [R1]
         { info_tbl: [(c4oXu,
                       label: block_c4oXu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oXu: // global
           I64[Sp] = block_c4oXA_info;
           _s4kWK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kWK::I64;
           if (R1 & 7 != 0) goto u4oXJ; else goto c4oXE;
       u4oXJ: // global
           call _c4oXA(R1) args: 0, res: 0, upd: 0;
       c4oXE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oXA() //  [R1]
         { info_tbl: [(c4oXA,
                       label: block_c4oXA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oXA: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.41699004 UTC

[section ""data" . GHC.Int.$wgo1_closure" {
     GHC.Int.$wgo1_closure:
         const GHC.Int.$wgo1_info;
         const 0;
 },
 sat_s4kWW_entry() //  [R1]
         { info_tbl: [(c4oXX,
                       label: sat_s4kWW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oXX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4oXY; else goto c4oY9;
       c4oXY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oY9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kWR::I64 = I64[R1 + 16];
           if (_s4kWR::I64 != 2147483647) goto c4oXV; else goto c4oXW;
       c4oXV: // global
           I64[Sp - 24] = block_c4oY3_info;
           R2 = _s4kWR::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c4oXW: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4oY3() //  [R1, R2]
         { info_tbl: [(c4oY3,
                       label: block_c4oY3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oY3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oY8; else goto c4oY7;
       c4oY8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4oY7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kWQ_entry() //  [R1]
         { info_tbl: [(c4oYj,
                       label: sat_s4kWQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oYj: // global
           _s4kWQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oYk; else goto c4oYl;
       c4oYl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oYn; else goto c4oYm;
       c4oYn: // global
           HpAlloc = 16;
           goto c4oYk;
       c4oYk: // global
           R1 = _s4kWQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oYm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kWQ::P64;
           _s4kWN::I64 = I64[_s4kWQ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kWN::I64,
                            (-2147483648))) goto c4oYt; else goto c4oYi;
       c4oYi: // global
           if (%MO_S_Gt_W64(_s4kWN::I64,
                            2147483647)) goto c4oYt; else goto c4oYx;
       c4oYt: // global
           Hp = Hp - 16;
           R2 = _s4kWN::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4oYx: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kWN::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo1_entry() //  [R2]
         { info_tbl: [(c4oYy,
                       label: GHC.Int.$wgo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oYy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4oYC; else goto c4oYB;
       c4oYC: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oYB: // global
           I64[Hp - 40] = sat_s4kWW_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kWQ_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.419117458 UTC

[section ""data" . GHC.Int.$fEnumInt32_go_closure" {
     GHC.Int.$fEnumInt32_go_closure:
         const GHC.Int.$fEnumInt32_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_go_entry() //  [R2]
         { info_tbl: [(c4oYK,
                       label: GHC.Int.$fEnumInt32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oYK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oYL; else goto c4oYM;
       c4oYL: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oYM: // global
           I64[Sp - 8] = block_c4oYH_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4oYH() //  [R1, R2]
         { info_tbl: [(c4oYH,
                       label: block_c4oYH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oYH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4oYP; else goto c4oYO;
       c4oYP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4oYO: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.420427725 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFrom_closure" {
     GHC.Int.$fEnumInt32_$cenumFrom_closure:
         const GHC.Int.$fEnumInt32_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4oYX,
                       label: GHC.Int.$fEnumInt32_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oYX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4oYY; else goto c4oYZ;
       c4oYY: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4oYZ: // global
           I64[Sp - 8] = block_c4oYU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4oZ8; else goto c4oYV;
       u4oZ8: // global
           call _c4oYU(R1) args: 0, res: 0, upd: 0;
       c4oYV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4oYU() //  [R1]
         { info_tbl: [(c4oYU,
                       label: block_c4oYU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oYU: // global
           _s4kX3::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kX3::I64,
                            2147483647)) goto c4oZ6; else goto c4oZ7;
       c4oZ6: // global
           R2 = _s4kX3::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_go_entry(R2) args: 8, res: 0, upd: 8;
       c4oZ7: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.425524068 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo1_closure" {
     GHC.Int.$w$cenumFromThenTo1_closure:
         const GHC.Int.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s4kXm_entry() //  [R1]
         { info_tbl: [(c4oZH,
                       label: sat_s4kXm_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oZH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4oZI; else goto c4oZJ;
       c4oZI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oZJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kXf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXk_entry() //  [R1]
         { info_tbl: [(c4oZT,
                       label: sat_s4kXk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4oZT: // global
           _s4kXk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4oZU; else goto c4oZV;
       c4oZV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4oZX; else goto c4oZW;
       c4oZX: // global
           HpAlloc = 16;
           goto c4oZU;
       c4oZU: // global
           R1 = _s4kXk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4oZW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXk::P64;
           _s4kXg::I64 = I64[_s4kXk::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXg::I64,
                            (-2147483648))) goto c4p03; else goto c4oZS;
       c4oZS: // global
           if (%MO_S_Gt_W64(_s4kXg::I64,
                            2147483647)) goto c4p03; else goto c4p07;
       c4p03: // global
           Hp = Hp - 16;
           R2 = _s4kXg::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4p07: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXg::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXp_entry() //  [R1]
         { info_tbl: [(c4p0i,
                       label: sat_s4kXp_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p0i: // global
           _s4kXp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4p0j; else goto c4p0k;
       c4p0k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p0m; else goto c4p0l;
       c4p0m: // global
           HpAlloc = 16;
           goto c4p0j;
       c4p0j: // global
           R1 = _s4kXp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p0l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXp::P64;
           _s4kXg::I64 = I64[_s4kXp::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXg::I64,
                            (-2147483648))) goto c4p0s; else goto c4p0h;
       c4p0h: // global
           if (%MO_S_Gt_W64(_s4kXg::I64,
                            2147483647)) goto c4p0s; else goto c4p0w;
       c4p0s: // global
           Hp = Hp - 16;
           R2 = _s4kXg::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4p0w: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXg::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kXf_entry() //  [R1, R2]
         { info_tbl: [(c4p0A,
                       label: go_dn_s4kXf_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p0A: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4p0E; else goto c4p0D;
       c4p0E: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4p0D: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4p0y; else goto c4p0z;
       c4p0y: // global
           _s4kXd::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kXm_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kXd::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kXk_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4p0z: // global
           I64[Hp - 80] = sat_s4kXp_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4p0G::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4p0G::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kXq_entry() //  [R1]
         { info_tbl: [(c4p0H,
                       label: sat_s4kXq_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p0H: // global
           _s4kXq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4p0I; else goto c4p0J;
       c4p0J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4p0L; else goto c4p0K;
       c4p0L: // global
           HpAlloc = 24;
           goto c4p0I;
       c4p0I: // global
           R1 = _s4kXq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p0K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXq::P64;
           _s4kX6::I64 = I64[_s4kXq::P64 + 24];
           _s4kXd::I64 = _s4kX6::I64 - I64[_s4kXq::P64 + 16];
           _s4kXe::I64 = I64[_s4kXq::P64 + 32] - _s4kXd::I64;
           I64[Hp - 16] = go_dn_s4kXf_info;
           I64[Hp - 8] = _s4kXd::I64;
           I64[Hp] = _s4kXe::I64;
           R2 = _s4kX6::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kXf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXc_entry() //  [R1]
         { info_tbl: [(c4p0V,
                       label: sat_s4kXc_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p0V: // global
           _s4kXc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4p0W; else goto c4p0X;
       c4p0X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p0Z; else goto c4p0Y;
       c4p0Z: // global
           HpAlloc = 16;
           goto c4p0W;
       c4p0W: // global
           R1 = _s4kXc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p0Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXc::P64;
           _s4kX5::I64 = I64[_s4kXc::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4p15; else goto c4p0U;
       c4p0U: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4p15; else goto c4p19;
       c4p15: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4p19: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXu_entry() //  [R1]
         { info_tbl: [(c4p1n,
                       label: sat_s4kXu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p1n: // global
           _s4kXu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4p1o; else goto c4p1p;
       c4p1p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p1r; else goto c4p1q;
       c4p1r: // global
           HpAlloc = 16;
           goto c4p1o;
       c4p1o: // global
           R1 = _s4kXu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p1q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXu::P64;
           _s4kX5::I64 = I64[_s4kXu::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4p1x; else goto c4p1m;
       c4p1m: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4p1x; else goto c4p1B;
       c4p1x: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4p1B: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXI_entry() //  [R1]
         { info_tbl: [(c4p24,
                       label: sat_s4kXI_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p24: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4p25; else goto c4p26;
       c4p25: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p26: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kXB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXG_entry() //  [R1]
         { info_tbl: [(c4p2g,
                       label: sat_s4kXG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p2g: // global
           _s4kXG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4p2h; else goto c4p2i;
       c4p2i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p2k; else goto c4p2j;
       c4p2k: // global
           HpAlloc = 16;
           goto c4p2h;
       c4p2h: // global
           R1 = _s4kXG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p2j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXG::P64;
           _s4kXC::I64 = I64[_s4kXG::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXC::I64,
                            (-2147483648))) goto c4p2q; else goto c4p2f;
       c4p2f: // global
           if (%MO_S_Gt_W64(_s4kXC::I64,
                            2147483647)) goto c4p2q; else goto c4p2u;
       c4p2q: // global
           Hp = Hp - 16;
           R2 = _s4kXC::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4p2u: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXL_entry() //  [R1]
         { info_tbl: [(c4p2F,
                       label: sat_s4kXL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p2F: // global
           _s4kXL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4p2G; else goto c4p2H;
       c4p2H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p2J; else goto c4p2I;
       c4p2J: // global
           HpAlloc = 16;
           goto c4p2G;
       c4p2G: // global
           R1 = _s4kXL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p2I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXL::P64;
           _s4kXC::I64 = I64[_s4kXL::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXC::I64,
                            (-2147483648))) goto c4p2P; else goto c4p2E;
       c4p2E: // global
           if (%MO_S_Gt_W64(_s4kXC::I64,
                            2147483647)) goto c4p2P; else goto c4p2T;
       c4p2P: // global
           Hp = Hp - 16;
           R2 = _s4kXC::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4p2T: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kXB_entry() //  [R1, R2]
         { info_tbl: [(c4p2X,
                       label: go_up_s4kXB_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p2X: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4p31; else goto c4p30;
       c4p31: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4p30: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4p2V; else goto c4p2W;
       c4p2V: // global
           _s4kXz::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kXI_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kXz::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kXG_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4p2W: // global
           I64[Hp - 80] = sat_s4kXL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4p33::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4p33::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kXM_entry() //  [R1]
         { info_tbl: [(c4p34,
                       label: sat_s4kXM_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p34: // global
           _s4kXM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4p35; else goto c4p36;
       c4p36: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4p38; else goto c4p37;
       c4p38: // global
           HpAlloc = 24;
           goto c4p35;
       c4p35: // global
           R1 = _s4kXM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p37: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXM::P64;
           _s4kX6::I64 = I64[_s4kXM::P64 + 24];
           _s4kXz::I64 = _s4kX6::I64 - I64[_s4kXM::P64 + 16];
           _s4kXA::I64 = I64[_s4kXM::P64 + 32] - _s4kXz::I64;
           I64[Hp - 16] = go_up_s4kXB_info;
           I64[Hp - 8] = _s4kXz::I64;
           I64[Hp] = _s4kXA::I64;
           R2 = _s4kX6::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kXB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXy_entry() //  [R1]
         { info_tbl: [(c4p3i,
                       label: sat_s4kXy_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p3i: // global
           _s4kXy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4p3j; else goto c4p3k;
       c4p3k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p3m; else goto c4p3l;
       c4p3m: // global
           HpAlloc = 16;
           goto c4p3j;
       c4p3j: // global
           R1 = _s4kXy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p3l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXy::P64;
           _s4kX5::I64 = I64[_s4kXy::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4p3s; else goto c4p3h;
       c4p3h: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4p3s; else goto c4p3w;
       c4p3s: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4p3w: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXQ_entry() //  [R1]
         { info_tbl: [(c4p3K,
                       label: sat_s4kXQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p3K: // global
           _s4kXQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4p3L; else goto c4p3M;
       c4p3M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p3O; else goto c4p3N;
       c4p3O: // global
           HpAlloc = 16;
           goto c4p3L;
       c4p3L: // global
           R1 = _s4kXQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p3N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXQ::P64;
           _s4kX5::I64 = I64[_s4kXQ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4p3U; else goto c4p3J;
       c4p3J: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4p3U; else goto c4p3Y;
       c4p3U: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4p3Y: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4p42,
                       label: GHC.Int.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p42: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4p46; else goto c4p45;
       c4p46: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4p45: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4p40; else goto c4p41;
       c4p40: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4p49; else goto c4p4e;
       c4p49: // global
           I64[Hp - 80] = sat_s4kXq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kXc_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4p4e: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4p4l; else goto c4p4c;
       c4p4c: // global
           I64[Hp - 80] = sat_s4kXu_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4p4a::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4p4a::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4p41: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4p4h; else goto c4p4m;
       c4p4h: // global
           I64[Hp - 80] = sat_s4kXM_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kXy_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4p4m: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4p4l; else goto c4p4k;
       c4p4l: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4p4k: // global
           I64[Hp - 80] = sat_s4kXQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4p4i::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4p4i::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.433769114 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4p4u,
                       label: GHC.Int.$fEnumInt32_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p4u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4p4D; else goto c4p4E;
       c4p4D: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4p4E: // global
           I64[Sp - 24] = block_c4p4r_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4p4N; else goto c4p4s;
       u4p4N: // global
           call _c4p4r(R1) args: 0, res: 0, upd: 0;
       c4p4s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p4r() //  [R1]
         { info_tbl: [(c4p4r,
                       label: block_c4p4r_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p4r: // global
           I64[Sp] = block_c4p4x_info;
           _s4kXV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kXV::I64;
           if (R1 & 7 != 0) goto u4p4M; else goto c4p4y;
       u4p4M: // global
           call _c4p4x(R1) args: 0, res: 0, upd: 0;
       c4p4y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p4x() //  [R1]
         { info_tbl: [(c4p4x,
                       label: block_c4p4x_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p4x: // global
           I64[Sp] = block_c4p4C_info;
           _s4kXX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kXX::I64;
           if (R1 & 7 != 0) goto u4p4O; else goto c4p4H;
       u4p4O: // global
           call _c4p4C(R1) args: 0, res: 0, upd: 0;
       c4p4H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p4C() //  [R1]
         { info_tbl: [(c4p4C,
                       label: block_c4p4C_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p4C: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.435621968 UTC

[section ""data" . GHC.Int.$fEnumInt32_closure" {
     GHC.Int.$fEnumInt32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt32_$csucc_closure+1;
         const GHC.Int.$fEnumInt32_$cpred_closure+1;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt32_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4p4T,
                       label: GHC.Int.$fEnumInt32_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p4T: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt32_closure+1;
           R2 = GHC.Int.$fEnumInt32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.436569371 UTC

[section ""cstring" . GHC.Int.$tcInt6_bytes" {
     GHC.Int.$tcInt6_bytes:
         I8[] [73,110,116,54,52]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.438844464 UTC

[section ""data" . GHC.Int.$fEnumInt5_closure" {
     GHC.Int.$fEnumInt5_closure:
         const GHC.Int.$fEnumInt5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt5_entry() //  [R1]
         { info_tbl: [(c4p54,
                       label: GHC.Int.$fEnumInt5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p54: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4p55; else goto c4p56;
       c4p55: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p56: // global
           (_c4p4Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4p4Z::I64 == 0) goto c4p51; else goto c4p50;
       c4p51: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4p50: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4p4Z::I64;
           I64[Sp - 24] = block_c4p52_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4p52() //  [R1]
         { info_tbl: [(c4p52,
                       label: block_c4p52_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p52: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.440147371 UTC

[section ""data" . GHC.Int.$fEnumInt6_closure" {
     GHC.Int.$fEnumInt6_closure:
         const GHC.Int.$fEnumInt6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt6_entry() //  [R1]
         { info_tbl: [(c4p5i,
                       label: GHC.Int.$fEnumInt6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p5i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4p5j; else goto c4p5k;
       c4p5j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p5k: // global
           (_c4p5d::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4p5d::I64 == 0) goto c4p5f; else goto c4p5e;
       c4p5f: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4p5e: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4p5d::I64;
           I64[Sp - 24] = block_c4p5g_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4p5g() //  [R1]
         { info_tbl: [(c4p5g,
                       label: block_c4p5g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p5g: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.441538804 UTC

[section ""data" . GHC.Int.neInt64_closure" {
     GHC.Int.neInt64_closure:
         const GHC.Int.neInt64_info;
 },
 GHC.Int.neInt64_entry() //  [R2, R3]
         { info_tbl: [(c4p5v,
                       label: GHC.Int.neInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p5v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4p5z; else goto c4p5A;
       c4p5z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4p5A: // global
           I64[Sp - 16] = block_c4p5s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4p5J; else goto c4p5t;
       u4p5J: // global
           call _c4p5s(R1) args: 0, res: 0, upd: 0;
       c4p5t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p5s() //  [R1]
         { info_tbl: [(c4p5s,
                       label: block_c4p5s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p5s: // global
           I64[Sp] = block_c4p5y_info;
           _s4kY5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kY5::I64;
           if (R1 & 7 != 0) goto u4p5I; else goto c4p5C;
       u4p5I: // global
           call _c4p5y(R1) args: 0, res: 0, upd: 0;
       c4p5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p5y() //  [R1]
         { info_tbl: [(c4p5y,
                       label: block_c4p5y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p5y: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.44273941 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cminBound_closure" {
     GHC.Int.$fBoundedInt64_$cminBound_closure:
         const GHC.Int.I64#_con_info;
         const (-9223372036854775808);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.443641999 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cpred_closure" {
     GHC.Int.$fEnumInt64_$cpred_closure:
         const GHC.Int.$fEnumInt64_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cpred_entry() //  [R2]
         { info_tbl: [(c4p5R,
                       label: GHC.Int.$fEnumInt64_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p5R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4p5S; else goto c4p5T;
       c4p5S: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4p5T: // global
           I64[Sp - 8] = block_c4p5O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4p68; else goto c4p5P;
       u4p68: // global
           call _c4p5O(R1) args: 0, res: 0, upd: 0;
       c4p5P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p5O() //  [R1]
         { info_tbl: [(c4p5O,
                       label: block_c4p5O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p5O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p5Y; else goto c4p5X;
       c4p5Y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4p5X: // global
           _s4kYc::I64 = I64[R1 + 7];
           if (_s4kYc::I64 != (-9223372036854775808)) goto c4p66; else goto c4p67;
       c4p66: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kYc::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4p67: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.445290956 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt64_$cmaxBound_closure:
         const GHC.Int.I64#_con_info;
         const 9223372036854775807;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.445918813 UTC

[section ""data" . GHC.Int.$fBoundedInt64_closure" {
     GHC.Int.$fBoundedInt64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt64_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.446874228 UTC

[section ""data" . GHC.Int.$fEnumInt64_$csucc_closure" {
     GHC.Int.$fEnumInt64_$csucc_closure:
         const GHC.Int.$fEnumInt64_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$csucc_entry() //  [R2]
         { info_tbl: [(c4p6g,
                       label: GHC.Int.$fEnumInt64_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p6g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4p6h; else goto c4p6i;
       c4p6h: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4p6i: // global
           I64[Sp - 8] = block_c4p6d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4p6x; else goto c4p6e;
       u4p6x: // global
           call _c4p6d(R1) args: 0, res: 0, upd: 0;
       c4p6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p6d() //  [R1]
         { info_tbl: [(c4p6d,
                       label: block_c4p6d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p6d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p6n; else goto c4p6m;
       c4p6n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4p6m: // global
           _s4kYh::I64 = I64[R1 + 7];
           if (_s4kYh::I64 != 9223372036854775807) goto c4p6v; else goto c4p6w;
       c4p6v: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kYh::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4p6w: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.44856546 UTC

[section ""data" . GHC.Int.$wgo2_closure" {
     GHC.Int.$wgo2_closure:
         const GHC.Int.$wgo2_info;
 },
 sat_s4kYq_entry() //  [R1]
         { info_tbl: [(c4p6K,
                       label: sat_s4kYq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p6K: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4p6L; else goto c4p6W;
       c4p6L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4p6W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kYl::I64 = I64[R1 + 16];
           if (_s4kYl::I64 != 9223372036854775807) goto c4p6I; else goto c4p6J;
       c4p6I: // global
           I64[Sp - 24] = block_c4p6Q_info;
           R2 = _s4kYl::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c4p6J: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4p6Q() //  [R1, R2]
         { info_tbl: [(c4p6Q,
                       label: block_c4p6Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p6Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4p6V; else goto c4p6U;
       c4p6V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4p6U: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo2_entry() //  [R2]
         { info_tbl: [(c4p6Y,
                       label: GHC.Int.$wgo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p6Y: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4p72; else goto c4p71;
       c4p72: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Int.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4p71: // global
           I64[Hp - 32] = sat_s4kYq_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R2 = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.450375752 UTC

[section ""data" . GHC.Int.$fEnumInt64_go_closure" {
     GHC.Int.$fEnumInt64_go_closure:
         const GHC.Int.$fEnumInt64_go_info;
 },
 GHC.Int.$fEnumInt64_go_entry() //  [R2]
         { info_tbl: [(c4p7a,
                       label: GHC.Int.$fEnumInt64_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p7a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4p7b; else goto c4p7c;
       c4p7b: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4p7c: // global
           I64[Sp - 8] = block_c4p77_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4p77() //  [R1, R2]
         { info_tbl: [(c4p77,
                       label: block_c4p77_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p77: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4p7f; else goto c4p7e;
       c4p7f: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4p7e: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.451610689 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFrom_closure" {
     GHC.Int.$fEnumInt64_$cenumFrom_closure:
         const GHC.Int.$fEnumInt64_$cenumFrom_info;
 },
 GHC.Int.$fEnumInt64_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4p7n,
                       label: GHC.Int.$fEnumInt64_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p7n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4p7o; else goto c4p7p;
       c4p7o: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4p7p: // global
           I64[Sp - 8] = block_c4p7k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4p7t; else goto c4p7l;
       u4p7t: // global
           call _c4p7k(R1) args: 0, res: 0, upd: 0;
       c4p7l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p7k() //  [R1]
         { info_tbl: [(c4p7k,
                       label: block_c4p7k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p7k: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.452697154 UTC

[section ""data" . GHC.Int.$fEnumInt64_closure" {
     GHC.Int.$fEnumInt64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt64_$csucc_closure+1;
         const GHC.Int.$fEnumInt64_$cpred_closure+1;
         const GHC.Int.$fEnumInt64_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt64_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4p7y,
                       label: GHC.Int.$fEnumInt64_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p7y: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt64_closure+1;
           R2 = GHC.Int.$fEnumInt64_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.45431071 UTC

[section ""data" . GHC.Int.$fNumInt8_$cfromInteger_closure" {
     GHC.Int.$fNumInt8_$cfromInteger_closure:
         const GHC.Int.$fNumInt8_$cfromInteger_info;
 },
 GHC.Int.$fNumInt8_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4p7H,
                       label: GHC.Int.$fNumInt8_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p7H: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4p7O; else goto c4p7P;
       c4p7O: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4p7P: // global
           I64[Sp - 8] = block_c4p7F_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4p7F() //  [R1]
         { info_tbl: [(c4p7F,
                       label: block_c4p7F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p7F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p7S; else goto c4p7R;
       c4p7S: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4p7R: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.455639706 UTC

[section ""data" . GHC.Int.$fNumInt8_$cnegate_closure" {
     GHC.Int.$fNumInt8_$cnegate_closure:
         const GHC.Int.$fNumInt8_$cnegate_info;
 },
 GHC.Int.$fNumInt8_$cnegate_entry() //  [R2]
         { info_tbl: [(c4p80,
                       label: GHC.Int.$fNumInt8_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p80: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4p8a; else goto c4p8b;
       c4p8a: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4p8b: // global
           I64[Sp - 8] = block_c4p7X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4p8f; else goto c4p7Y;
       u4p8f: // global
           call _c4p7X(R1) args: 0, res: 0, upd: 0;
       c4p7Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p7X() //  [R1]
         { info_tbl: [(c4p7X,
                       label: block_c4p7X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p7X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p8e; else goto c4p8d;
       c4p8e: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4p8d: // global
           _s4kYF::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYF::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.457177277 UTC

[section ""data" . GHC.Int.$fNumInt8_$c*_closure" {
     GHC.Int.$fNumInt8_$c*_closure:
         const GHC.Int.$fNumInt8_$c*_info;
 },
 GHC.Int.$fNumInt8_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4p8n,
                       label: GHC.Int.$fNumInt8_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p8n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4p8C; else goto c4p8D;
       c4p8C: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4p8D: // global
           I64[Sp - 16] = block_c4p8k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4p8J; else goto c4p8l;
       u4p8J: // global
           call _c4p8k(R1) args: 0, res: 0, upd: 0;
       c4p8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p8k() //  [R1]
         { info_tbl: [(c4p8k,
                       label: block_c4p8k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p8k: // global
           I64[Sp] = block_c4p8q_info;
           _s4kYJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYJ::I64;
           if (R1 & 7 != 0) goto u4p8I; else goto c4p8r;
       u4p8I: // global
           call _c4p8q(R1) args: 0, res: 0, upd: 0;
       c4p8r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p8q() //  [R1]
         { info_tbl: [(c4p8q,
                       label: block_c4p8q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p8q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p8H; else goto c4p8G;
       c4p8H: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4p8G: // global
           _s4kYN::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYN::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.45899435 UTC

[section ""data" . GHC.Int.$fNumInt8_$c-_closure" {
     GHC.Int.$fNumInt8_$c-_closure:
         const GHC.Int.$fNumInt8_$c-_info;
 },
 GHC.Int.$fNumInt8_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4p8R,
                       label: GHC.Int.$fNumInt8_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p8R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4p96; else goto c4p97;
       c4p96: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4p97: // global
           I64[Sp - 16] = block_c4p8O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4p9d; else goto c4p8P;
       u4p9d: // global
           call _c4p8O(R1) args: 0, res: 0, upd: 0;
       c4p8P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p8O() //  [R1]
         { info_tbl: [(c4p8O,
                       label: block_c4p8O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p8O: // global
           I64[Sp] = block_c4p8U_info;
           _s4kYR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYR::I64;
           if (R1 & 7 != 0) goto u4p9c; else goto c4p8V;
       u4p9c: // global
           call _c4p8U(R1) args: 0, res: 0, upd: 0;
       c4p8V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p8U() //  [R1]
         { info_tbl: [(c4p8U,
                       label: block_c4p8U_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p8U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p9b; else goto c4p9a;
       c4p9b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4p9a: // global
           _s4kYV::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.460755171 UTC

[section ""data" . GHC.Int.$fNumInt8_$c+_closure" {
     GHC.Int.$fNumInt8_$c+_closure:
         const GHC.Int.$fNumInt8_$c+_info;
 },
 GHC.Int.$fNumInt8_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4p9l,
                       label: GHC.Int.$fNumInt8_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p9l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4p9A; else goto c4p9B;
       c4p9A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4p9B: // global
           I64[Sp - 16] = block_c4p9i_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4p9H; else goto c4p9j;
       u4p9H: // global
           call _c4p9i(R1) args: 0, res: 0, upd: 0;
       c4p9j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p9i() //  [R1]
         { info_tbl: [(c4p9i,
                       label: block_c4p9i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p9i: // global
           I64[Sp] = block_c4p9o_info;
           _s4kYZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYZ::I64;
           if (R1 & 7 != 0) goto u4p9G; else goto c4p9p;
       u4p9G: // global
           call _c4p9o(R1) args: 0, res: 0, upd: 0;
       c4p9p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p9o() //  [R1]
         { info_tbl: [(c4p9o,
                       label: block_c4p9o_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p9o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4p9F; else goto c4p9E;
       c4p9F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4p9E: // global
           _s4kZ3::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZ3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.463695339 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt8_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt8_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt8_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4p9P,
                       label: GHC.Int.$fIntegralInt8_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p9P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4p9Q; else goto c4p9R;
       c4p9Q: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4p9R: // global
           I64[Sp - 8] = block_c4p9M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4p9V; else goto c4p9N;
       u4p9V: // global
           call _c4p9M(R1) args: 0, res: 0, upd: 0;
       c4p9N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4p9M() //  [R1]
         { info_tbl: [(c4p9M,
                       label: block_c4p9M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4p9M: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.465459212 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cpopCount_closure" {
     GHC.Int.$fBitsInt8_$cpopCount_closure:
         const GHC.Int.$fBitsInt8_$cpopCount_info;
 },
 GHC.Int.$fBitsInt8_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4pa3,
                       label: GHC.Int.$fBitsInt8_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pa3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pah; else goto c4pai;
       c4pah: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pai: // global
           I64[Sp - 8] = block_c4pa0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pam; else goto c4pa1;
       u4pam: // global
           call _c4pa0(R1) args: 0, res: 0, upd: 0;
       c4pa1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pa0() //  [R1]
         { info_tbl: [(c4pa0,
                       label: block_c4pa0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pa0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pal; else goto c4pak;
       c4pal: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pak: // global
           (_c4pa9::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4pa9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.467371377 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4pau,
                       label: GHC.Int.$fBitsInt8_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pau: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4paG; else goto c4paH;
       c4paG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4paH: // global
           I64[Sp - 16] = block_c4par_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4paN; else goto c4pas;
       u4paN: // global
           call _c4par(R1) args: 0, res: 0, upd: 0;
       c4pas: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4par() //  [R1]
         { info_tbl: [(c4par,
                       label: block_c4par_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4par: // global
           I64[Sp] = block_c4pax_info;
           _s4kZg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZg::I64;
           if (R1 & 7 != 0) goto u4paM; else goto c4pay;
       u4paM: // global
           call _c4pax(R1) args: 0, res: 0, upd: 0;
       c4pay: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pax() //  [R1]
         { info_tbl: [(c4pax,
                       label: block_c4pax_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pax: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4paL; else goto c4paK;
       c4paL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4paK: // global
           _s4kZj::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.46919859 UTC

[section ""data" . GHC.Int.$fBitsInt13_closure" {
     GHC.Int.$fBitsInt13_closure:
         const GHC.Int.I8#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.47039747 UTC

[section ""data" . GHC.Int.$fNumInt9_closure" {
     GHC.Int.$fNumInt9_closure:
         const GHC.Int.I8#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.471786005 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftR_closure" {
     GHC.Int.$fBitsInt8_$cshiftR_closure:
         const GHC.Int.$fBitsInt8_$cshiftR_info;
 },
 GHC.Int.$fBitsInt8_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4paV,
                       label: GHC.Int.$fBitsInt8_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4paV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4paZ; else goto c4pb0;
       c4paZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pb0: // global
           I64[Sp - 16] = block_c4paS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pbq; else goto c4paT;
       u4pbq: // global
           call _c4paS(R1) args: 0, res: 0, upd: 0;
       c4paT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4paS() //  [R1]
         { info_tbl: [(c4paS,
                       label: block_c4paS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4paS: // global
           I64[Sp] = block_c4paY_info;
           _s4kZn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZn::I64;
           if (R1 & 7 != 0) goto u4pbp; else goto c4pb2;
       u4pbp: // global
           call _c4paY(R1) args: 0, res: 0, upd: 0;
       c4pb2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4paY() //  [R1]
         { info_tbl: [(c4paY,
                       label: block_c4paY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4paY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pb8; else goto c4pb7;
       c4pb8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pb7: // global
           _s4kZn::I64 = I64[Sp + 8];
           _s4kZp::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4kZp::I64, 64)) goto c4pbh; else goto c4pbo;
       c4pbh: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4kZn::I64, _s4kZp::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pbo: // global
           if (%MO_S_Ge_W64(_s4kZn::I64, 0)) goto c4pbm; else goto c4pbn;
       c4pbm: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pbn: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.474154718 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4pby,
                       label: GHC.Int.$fBitsInt8_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pby: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pbN; else goto c4pbO;
       c4pbN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pbO: // global
           I64[Sp - 16] = block_c4pbv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pbU; else goto c4pbw;
       u4pbU: // global
           call _c4pbv(R1) args: 0, res: 0, upd: 0;
       c4pbw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pbv() //  [R1]
         { info_tbl: [(c4pbv,
                       label: block_c4pbv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pbv: // global
           I64[Sp] = block_c4pbB_info;
           _s4kZw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZw::I64;
           if (R1 & 7 != 0) goto u4pbT; else goto c4pbC;
       u4pbT: // global
           call _c4pbB(R1) args: 0, res: 0, upd: 0;
       c4pbC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pbB() //  [R1]
         { info_tbl: [(c4pbB,
                       label: block_c4pbB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pbB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pbS; else goto c4pbR;
       c4pbS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pbR: // global
           _s4kZA::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.475908308 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftL_closure" {
     GHC.Int.$fBitsInt8_$cshiftL_closure:
         const GHC.Int.$fBitsInt8_$cshiftL_info;
 },
 GHC.Int.$fBitsInt8_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4pc2,
                       label: GHC.Int.$fBitsInt8_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pc2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pc6; else goto c4pc7;
       c4pc6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pc7: // global
           I64[Sp - 16] = block_c4pbZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pcu; else goto c4pc0;
       u4pcu: // global
           call _c4pbZ(R1) args: 0, res: 0, upd: 0;
       c4pc0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pbZ() //  [R1]
         { info_tbl: [(c4pbZ,
                       label: block_c4pbZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pbZ: // global
           I64[Sp] = block_c4pc5_info;
           _s4kZE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZE::I64;
           if (R1 & 7 != 0) goto u4pct; else goto c4pc9;
       u4pct: // global
           call _c4pc5(R1) args: 0, res: 0, upd: 0;
       c4pc9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pc5() //  [R1]
         { info_tbl: [(c4pc5,
                       label: block_c4pc5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pc5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pcf; else goto c4pce;
       c4pcf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pce: // global
           _s4kZG::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4kZG::I64, 64)) goto c4pcr; else goto c4pcs;
       c4pcr: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << _s4kZG::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pcs: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.477576062 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cisSigned_closure" {
     GHC.Int.$fBitsInt8_$cisSigned_closure:
         const GHC.Int.$fBitsInt8_$cisSigned_info;
 },
 GHC.Int.$fBitsInt8_$cisSigned_entry() //  []
         { info_tbl: [(c4pcz,
                       label: GHC.Int.$fBitsInt8_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pcz: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.478941909 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotate_closure" {
     GHC.Int.$fBitsInt8_$crotate_closure:
         const GHC.Int.$fBitsInt8_$crotate_info;
 },
 GHC.Int.$fBitsInt8_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4pcJ,
                       label: GHC.Int.$fBitsInt8_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pcJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pcN; else goto c4pcO;
       c4pcN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pcO: // global
           I64[Sp - 16] = block_c4pcG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pdK; else goto c4pcH;
       u4pdK: // global
           call _c4pcG(R1) args: 0, res: 0, upd: 0;
       c4pcH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pcG() //  [R1]
         { info_tbl: [(c4pcG,
                       label: block_c4pcG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pcG: // global
           I64[Sp - 8] = block_c4pcM_info;
           _s4kZN::P64 = R1;
           _s4kZO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4kZO::I64;
           P64[Sp + 8] = _s4kZN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pdJ; else goto c4pcQ;
       u4pdJ: // global
           call _c4pcM(R1) args: 0, res: 0, upd: 0;
       c4pcQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pcM() //  [R1]
         { info_tbl: [(c4pcM,
                       label: block_c4pcM_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pcM: // global
           _s4kZT::I64 = I64[R1 + 7] & 7;
           if (_s4kZT::I64 != 0) goto u4pdH; else goto c4pdD;
       u4pdH: // global
           I64[Sp + 16] = _s4kZT::I64;
           Sp = Sp + 8;
           call _c4pd5() args: 0, res: 0, upd: 0;
       c4pdD: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pd5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pd5: // global
           Hp = Hp + 16;
           _s4kZT::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4pdA; else goto c4pdz;
       c4pdA: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4pd4_info;
           R1 = _s4kZT::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4pdz: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4kZU::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4kZU::I64 << _s4kZT::I64) | (_s4kZU::I64 >> 8 - _s4kZT::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pd4() //  [R1]
         { info_tbl: [(c4pd4,
                       label: block_c4pd4_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pd4: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4pd5() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.481549066 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshift_closure" {
     GHC.Int.$fBitsInt8_$cshift_closure:
         const GHC.Int.$fBitsInt8_$cshift_info;
 },
 GHC.Int.$fBitsInt8_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4pdU,
                       label: GHC.Int.$fBitsInt8_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pdU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pdY; else goto c4pdZ;
       c4pdY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pdZ: // global
           I64[Sp - 16] = block_c4pdR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4peM; else goto c4pdS;
       u4peM: // global
           call _c4pdR(R1) args: 0, res: 0, upd: 0;
       c4pdS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pdR() //  [R1]
         { info_tbl: [(c4pdR,
                       label: block_c4pdR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pdR: // global
           I64[Sp] = block_c4pdX_info;
           _s4l05::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l05::I64;
           if (R1 & 7 != 0) goto u4peL; else goto c4pe1;
       u4peL: // global
           call _c4pdX(R1) args: 0, res: 0, upd: 0;
       c4pe1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pdX() //  [R1]
         { info_tbl: [(c4pdX,
                       label: block_c4pdX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pdX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pe7; else goto c4pe6;
       c4pe7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pe6: // global
           _s4l05::I64 = I64[Sp + 8];
           _s4l07::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l07::I64, 0)) goto c4pev; else goto c4peK;
       c4pev: // global
           _s4l09::I64 = -_s4l07::I64;
           if (%MO_S_Lt_W64(_s4l09::I64, 64)) goto c4pem; else goto c4pet;
       c4pem: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l05::I64, _s4l09::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pet: // global
           if (%MO_S_Ge_W64(_s4l05::I64, 0)) goto c4peJ; else goto c4pes;
       c4pes: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4peK: // global
           if (%MO_S_Ge_W64(_s4l07::I64, 64)) goto c4peJ; else goto c4peI;
       c4peJ: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4peI: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4l05::I64 << _s4l07::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.483653044 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplement_closure" {
     GHC.Int.$fBitsInt8_$ccomplement_closure:
         const GHC.Int.$fBitsInt8_$ccomplement_info;
 },
 GHC.Int.$fBitsInt8_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4peU,
                       label: GHC.Int.$fBitsInt8_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4peU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pf7; else goto c4pf8;
       c4pf7: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pf8: // global
           I64[Sp - 8] = block_c4peR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pfc; else goto c4peS;
       u4pfc: // global
           call _c4peR(R1) args: 0, res: 0, upd: 0;
       c4peS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4peR() //  [R1]
         { info_tbl: [(c4peR,
                       label: block_c4peR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4peR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pfb; else goto c4pfa;
       c4pfb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pfa: // global
           _s4l0l::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.485166897 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cxor_closure" {
     GHC.Int.$fBitsInt8_$cxor_closure:
         const GHC.Int.$fBitsInt8_$cxor_info;
 },
 GHC.Int.$fBitsInt8_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4pfk,
                       label: GHC.Int.$fBitsInt8_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pfk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pfF; else goto c4pfG;
       c4pfF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pfG: // global
           I64[Sp - 16] = block_c4pfh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pfM; else goto c4pfi;
       u4pfM: // global
           call _c4pfh(R1) args: 0, res: 0, upd: 0;
       c4pfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pfh() //  [R1]
         { info_tbl: [(c4pfh,
                       label: block_c4pfh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pfh: // global
           I64[Sp] = block_c4pfn_info;
           _s4l0p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0p::I64;
           if (R1 & 7 != 0) goto u4pfL; else goto c4pfo;
       u4pfL: // global
           call _c4pfn(R1) args: 0, res: 0, upd: 0;
       c4pfo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pfn() //  [R1]
         { info_tbl: [(c4pfn,
                       label: block_c4pfn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pfn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pfK; else goto c4pfJ;
       c4pfK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pfJ: // global
           _s4l0v::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0v::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.487004177 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.|._closure" {
     GHC.Int.$fBitsInt8_$c.|._closure:
         const GHC.Int.$fBitsInt8_$c.|._info;
 },
 GHC.Int.$fBitsInt8_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4pfU,
                       label: GHC.Int.$fBitsInt8_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pfU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pgf; else goto c4pgg;
       c4pgf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pgg: // global
           I64[Sp - 16] = block_c4pfR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pgm; else goto c4pfS;
       u4pgm: // global
           call _c4pfR(R1) args: 0, res: 0, upd: 0;
       c4pfS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pfR() //  [R1]
         { info_tbl: [(c4pfR,
                       label: block_c4pfR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pfR: // global
           I64[Sp] = block_c4pfX_info;
           _s4l0z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0z::I64;
           if (R1 & 7 != 0) goto u4pgl; else goto c4pfY;
       u4pgl: // global
           call _c4pfX(R1) args: 0, res: 0, upd: 0;
       c4pfY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pfX() //  [R1]
         { info_tbl: [(c4pfX,
                       label: block_c4pfX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pfX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pgk; else goto c4pgj;
       c4pgk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pgj: // global
           _s4l0F::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0F::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.489942115 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.&._closure" {
     GHC.Int.$fBitsInt8_$c.&._closure:
         const GHC.Int.$fBitsInt8_$c.&._info;
 },
 GHC.Int.$fBitsInt8_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4pgu,
                       label: GHC.Int.$fBitsInt8_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pgu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pgP; else goto c4pgQ;
       c4pgP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pgQ: // global
           I64[Sp - 16] = block_c4pgr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pgW; else goto c4pgs;
       u4pgW: // global
           call _c4pgr(R1) args: 0, res: 0, upd: 0;
       c4pgs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pgr() //  [R1]
         { info_tbl: [(c4pgr,
                       label: block_c4pgr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pgr: // global
           I64[Sp] = block_c4pgx_info;
           _s4l0J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0J::I64;
           if (R1 & 7 != 0) goto u4pgV; else goto c4pgy;
       u4pgV: // global
           call _c4pgx(R1) args: 0, res: 0, upd: 0;
       c4pgy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pgx() //  [R1]
         { info_tbl: [(c4pgx,
                       label: block_c4pgx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pgx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pgU; else goto c4pgT;
       c4pgU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pgT: // global
           _s4l0P::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0P::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.491535705 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4ph4,
                       label: GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ph4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4phi; else goto c4phj;
       c4phi: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4phj: // global
           I64[Sp - 8] = block_c4ph1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4phn; else goto c4ph2;
       u4phn: // global
           call _c4ph1(R1) args: 0, res: 0, upd: 0;
       c4ph2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ph1() //  [R1]
         { info_tbl: [(c4ph1,
                       label: block_c4ph1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ph1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4phm; else goto c4phl;
       c4phm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4phl: // global
           (_c4pha::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4pha::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.492855541 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4phv,
                       label: GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4phv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4phJ; else goto c4phK;
       c4phJ: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4phK: // global
           I64[Sp - 8] = block_c4phs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4phO; else goto c4pht;
       u4phO: // global
           call _c4phs(R1) args: 0, res: 0, upd: 0;
       c4pht: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4phs() //  [R1]
         { info_tbl: [(c4phs,
                       label: block_c4phs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4phs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4phN; else goto c4phM;
       c4phN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4phM: // global
           (_c4phB::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4phB::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.493984591 UTC

[section ""data" . GHC.Int.$fBitsInt11_closure" {
     GHC.Int.$fBitsInt11_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.494651075 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt8_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt8_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4phT,
                       label: GHC.Int.$fBitsInt8_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4phT: // global
           R1 = GHC.Int.$fBitsInt11_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.495563658 UTC

[section ""data" . GHC.Int.$fNumInt16_$cfromInteger_closure" {
     GHC.Int.$fNumInt16_$cfromInteger_closure:
         const GHC.Int.$fNumInt16_$cfromInteger_info;
 },
 GHC.Int.$fNumInt16_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4pi2,
                       label: GHC.Int.$fNumInt16_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pi2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pi9; else goto c4pia;
       c4pi9: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pia: // global
           I64[Sp - 8] = block_c4pi0_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4pi0() //  [R1]
         { info_tbl: [(c4pi0,
                       label: block_c4pi0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pi0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pid; else goto c4pic;
       c4pid: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4pic: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.496857584 UTC

[section ""data" . GHC.Int.$fNumInt16_$cnegate_closure" {
     GHC.Int.$fNumInt16_$cnegate_closure:
         const GHC.Int.$fNumInt16_$cnegate_info;
 },
 GHC.Int.$fNumInt16_$cnegate_entry() //  [R2]
         { info_tbl: [(c4pil,
                       label: GHC.Int.$fNumInt16_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pil: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4piv; else goto c4piw;
       c4piv: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4piw: // global
           I64[Sp - 8] = block_c4pii_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4piA; else goto c4pij;
       u4piA: // global
           call _c4pii(R1) args: 0, res: 0, upd: 0;
       c4pij: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pii() //  [R1]
         { info_tbl: [(c4pii,
                       label: block_c4pii_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pii: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4piz; else goto c4piy;
       c4piz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4piy: // global
           _s4l1a::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1a::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.498446813 UTC

[section ""data" . GHC.Int.$fNumInt16_$c*_closure" {
     GHC.Int.$fNumInt16_$c*_closure:
         const GHC.Int.$fNumInt16_$c*_info;
 },
 GHC.Int.$fNumInt16_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4piI,
                       label: GHC.Int.$fNumInt16_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4piI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4piX; else goto c4piY;
       c4piX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4piY: // global
           I64[Sp - 16] = block_c4piF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pj4; else goto c4piG;
       u4pj4: // global
           call _c4piF(R1) args: 0, res: 0, upd: 0;
       c4piG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4piF() //  [R1]
         { info_tbl: [(c4piF,
                       label: block_c4piF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4piF: // global
           I64[Sp] = block_c4piL_info;
           _s4l1e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1e::I64;
           if (R1 & 7 != 0) goto u4pj3; else goto c4piM;
       u4pj3: // global
           call _c4piL(R1) args: 0, res: 0, upd: 0;
       c4piM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4piL() //  [R1]
         { info_tbl: [(c4piL,
                       label: block_c4piL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4piL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pj2; else goto c4pj1;
       c4pj2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pj1: // global
           _s4l1i::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1i::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.500136404 UTC

[section ""data" . GHC.Int.$fNumInt16_$c-_closure" {
     GHC.Int.$fNumInt16_$c-_closure:
         const GHC.Int.$fNumInt16_$c-_info;
 },
 GHC.Int.$fNumInt16_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4pjc,
                       label: GHC.Int.$fNumInt16_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pjc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pjr; else goto c4pjs;
       c4pjr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pjs: // global
           I64[Sp - 16] = block_c4pj9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pjy; else goto c4pja;
       u4pjy: // global
           call _c4pj9(R1) args: 0, res: 0, upd: 0;
       c4pja: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pj9() //  [R1]
         { info_tbl: [(c4pj9,
                       label: block_c4pj9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pj9: // global
           I64[Sp] = block_c4pjf_info;
           _s4l1m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1m::I64;
           if (R1 & 7 != 0) goto u4pjx; else goto c4pjg;
       u4pjx: // global
           call _c4pjf(R1) args: 0, res: 0, upd: 0;
       c4pjg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pjf() //  [R1]
         { info_tbl: [(c4pjf,
                       label: block_c4pjf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pjf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pjw; else goto c4pjv;
       c4pjw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pjv: // global
           _s4l1q::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.501918805 UTC

[section ""data" . GHC.Int.$fNumInt16_$c+_closure" {
     GHC.Int.$fNumInt16_$c+_closure:
         const GHC.Int.$fNumInt16_$c+_info;
 },
 GHC.Int.$fNumInt16_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4pjG,
                       label: GHC.Int.$fNumInt16_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pjG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pjV; else goto c4pjW;
       c4pjV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pjW: // global
           I64[Sp - 16] = block_c4pjD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pk2; else goto c4pjE;
       u4pk2: // global
           call _c4pjD(R1) args: 0, res: 0, upd: 0;
       c4pjE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pjD() //  [R1]
         { info_tbl: [(c4pjD,
                       label: block_c4pjD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pjD: // global
           I64[Sp] = block_c4pjJ_info;
           _s4l1u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1u::I64;
           if (R1 & 7 != 0) goto u4pk1; else goto c4pjK;
       u4pk1: // global
           call _c4pjJ(R1) args: 0, res: 0, upd: 0;
       c4pjK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pjJ() //  [R1]
         { info_tbl: [(c4pjJ,
                       label: block_c4pjJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pjJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pk0; else goto c4pjZ;
       c4pk0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pjZ: // global
           _s4l1y::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1y::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.503429547 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt16_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt16_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt16_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4pka,
                       label: GHC.Int.$fIntegralInt16_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pka: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pkb; else goto c4pkc;
       c4pkb: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pkc: // global
           I64[Sp - 8] = block_c4pk7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pkg; else goto c4pk8;
       u4pkg: // global
           call _c4pk7(R1) args: 0, res: 0, upd: 0;
       c4pk8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pk7() //  [R1]
         { info_tbl: [(c4pk7,
                       label: block_c4pk7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pk7: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.504745498 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cpopCount_closure" {
     GHC.Int.$fBitsInt16_$cpopCount_closure:
         const GHC.Int.$fBitsInt16_$cpopCount_info;
 },
 GHC.Int.$fBitsInt16_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4pko,
                       label: GHC.Int.$fBitsInt16_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pko: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pkC; else goto c4pkD;
       c4pkC: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pkD: // global
           I64[Sp - 8] = block_c4pkl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pkH; else goto c4pkm;
       u4pkH: // global
           call _c4pkl(R1) args: 0, res: 0, upd: 0;
       c4pkm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pkl() //  [R1]
         { info_tbl: [(c4pkl,
                       label: block_c4pkl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pkl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pkG; else goto c4pkF;
       c4pkG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pkF: // global
           (_c4pku::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4pku::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.506284894 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4pkP,
                       label: GHC.Int.$fBitsInt16_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pkP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pl1; else goto c4pl2;
       c4pl1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pl2: // global
           I64[Sp - 16] = block_c4pkM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pl8; else goto c4pkN;
       u4pl8: // global
           call _c4pkM(R1) args: 0, res: 0, upd: 0;
       c4pkN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pkM() //  [R1]
         { info_tbl: [(c4pkM,
                       label: block_c4pkM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pkM: // global
           I64[Sp] = block_c4pkS_info;
           _s4l1L::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1L::I64;
           if (R1 & 7 != 0) goto u4pl7; else goto c4pkT;
       u4pl7: // global
           call _c4pkS(R1) args: 0, res: 0, upd: 0;
       c4pkT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pkS() //  [R1]
         { info_tbl: [(c4pkS,
                       label: block_c4pkS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pkS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pl6; else goto c4pl5;
       c4pl6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pl5: // global
           _s4l1O::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1O::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.507666545 UTC

[section ""data" . GHC.Int.$fBitsInt3_closure" {
     GHC.Int.$fBitsInt3_closure:
         const GHC.Int.I16#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.508280801 UTC

[section ""data" . GHC.Int.$fNumInt2_closure" {
     GHC.Int.$fNumInt2_closure:
         const GHC.Int.I16#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.509538127 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftR_closure" {
     GHC.Int.$fBitsInt16_$cshiftR_closure:
         const GHC.Int.$fBitsInt16_$cshiftR_info;
 },
 GHC.Int.$fBitsInt16_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4plg,
                       label: GHC.Int.$fBitsInt16_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4plg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4plk; else goto c4pll;
       c4plk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pll: // global
           I64[Sp - 16] = block_c4pld_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4plL; else goto c4ple;
       u4plL: // global
           call _c4pld(R1) args: 0, res: 0, upd: 0;
       c4ple: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pld() //  [R1]
         { info_tbl: [(c4pld,
                       label: block_c4pld_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pld: // global
           I64[Sp] = block_c4plj_info;
           _s4l1S::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1S::I64;
           if (R1 & 7 != 0) goto u4plK; else goto c4pln;
       u4plK: // global
           call _c4plj(R1) args: 0, res: 0, upd: 0;
       c4pln: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4plj() //  [R1]
         { info_tbl: [(c4plj,
                       label: block_c4plj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4plj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4plt; else goto c4pls;
       c4plt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pls: // global
           _s4l1S::I64 = I64[Sp + 8];
           _s4l1U::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l1U::I64, 64)) goto c4plC; else goto c4plJ;
       c4plC: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l1S::I64, _s4l1U::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4plJ: // global
           if (%MO_S_Ge_W64(_s4l1S::I64, 0)) goto c4plH; else goto c4plI;
       c4plH: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4plI: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.512605448 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4plT,
                       label: GHC.Int.$fBitsInt16_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4plT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pm8; else goto c4pm9;
       c4pm8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pm9: // global
           I64[Sp - 16] = block_c4plQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pmf; else goto c4plR;
       u4pmf: // global
           call _c4plQ(R1) args: 0, res: 0, upd: 0;
       c4plR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4plQ() //  [R1]
         { info_tbl: [(c4plQ,
                       label: block_c4plQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4plQ: // global
           I64[Sp] = block_c4plW_info;
           _s4l21::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l21::I64;
           if (R1 & 7 != 0) goto u4pme; else goto c4plX;
       u4pme: // global
           call _c4plW(R1) args: 0, res: 0, upd: 0;
       c4plX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4plW() //  [R1]
         { info_tbl: [(c4plW,
                       label: block_c4plW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4plW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pmd; else goto c4pmc;
       c4pmd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pmc: // global
           _s4l25::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l25::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.514553547 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftL_closure" {
     GHC.Int.$fBitsInt16_$cshiftL_closure:
         const GHC.Int.$fBitsInt16_$cshiftL_info;
 },
 GHC.Int.$fBitsInt16_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4pmn,
                       label: GHC.Int.$fBitsInt16_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pmn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pmr; else goto c4pms;
       c4pmr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pms: // global
           I64[Sp - 16] = block_c4pmk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pmP; else goto c4pml;
       u4pmP: // global
           call _c4pmk(R1) args: 0, res: 0, upd: 0;
       c4pml: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pmk() //  [R1]
         { info_tbl: [(c4pmk,
                       label: block_c4pmk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pmk: // global
           I64[Sp] = block_c4pmq_info;
           _s4l29::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l29::I64;
           if (R1 & 7 != 0) goto u4pmO; else goto c4pmu;
       u4pmO: // global
           call _c4pmq(R1) args: 0, res: 0, upd: 0;
       c4pmu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pmq() //  [R1]
         { info_tbl: [(c4pmq,
                       label: block_c4pmq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pmq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pmA; else goto c4pmz;
       c4pmA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pmz: // global
           _s4l2b::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l2b::I64, 64)) goto c4pmM; else goto c4pmN;
       c4pmM: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << _s4l2b::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pmN: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.516103286 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cisSigned_closure" {
     GHC.Int.$fBitsInt16_$cisSigned_closure:
         const GHC.Int.$fBitsInt16_$cisSigned_info;
 },
 GHC.Int.$fBitsInt16_$cisSigned_entry() //  []
         { info_tbl: [(c4pmU,
                       label: GHC.Int.$fBitsInt16_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pmU: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.517558101 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotate_closure" {
     GHC.Int.$fBitsInt16_$crotate_closure:
         const GHC.Int.$fBitsInt16_$crotate_info;
 },
 GHC.Int.$fBitsInt16_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4pn4,
                       label: GHC.Int.$fBitsInt16_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pn4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pn8; else goto c4pn9;
       c4pn8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pn9: // global
           I64[Sp - 16] = block_c4pn1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4po5; else goto c4pn2;
       u4po5: // global
           call _c4pn1(R1) args: 0, res: 0, upd: 0;
       c4pn2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pn1() //  [R1]
         { info_tbl: [(c4pn1,
                       label: block_c4pn1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pn1: // global
           I64[Sp - 8] = block_c4pn7_info;
           _s4l2i::P64 = R1;
           _s4l2j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l2j::I64;
           P64[Sp + 8] = _s4l2i::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4po4; else goto c4pnb;
       u4po4: // global
           call _c4pn7(R1) args: 0, res: 0, upd: 0;
       c4pnb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pn7() //  [R1]
         { info_tbl: [(c4pn7,
                       label: block_c4pn7_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pn7: // global
           _s4l2o::I64 = I64[R1 + 7] & 15;
           if (_s4l2o::I64 != 0) goto u4po2; else goto c4pnY;
       u4po2: // global
           I64[Sp + 16] = _s4l2o::I64;
           Sp = Sp + 8;
           call _c4pnq() args: 0, res: 0, upd: 0;
       c4pnY: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pnq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pnq: // global
           Hp = Hp + 16;
           _s4l2o::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4pnV; else goto c4pnU;
       c4pnV: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4pnp_info;
           R1 = _s4l2o::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4pnU: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4l2p::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4l2p::I64 << _s4l2o::I64) | (_s4l2p::I64 >> 16 - _s4l2o::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pnp() //  [R1]
         { info_tbl: [(c4pnp,
                       label: block_c4pnp_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pnp: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4pnq() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.520004471 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshift_closure" {
     GHC.Int.$fBitsInt16_$cshift_closure:
         const GHC.Int.$fBitsInt16_$cshift_info;
 },
 GHC.Int.$fBitsInt16_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4pof,
                       label: GHC.Int.$fBitsInt16_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pof: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4poj; else goto c4pok;
       c4poj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pok: // global
           I64[Sp - 16] = block_c4poc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pp7; else goto c4pod;
       u4pp7: // global
           call _c4poc(R1) args: 0, res: 0, upd: 0;
       c4pod: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4poc() //  [R1]
         { info_tbl: [(c4poc,
                       label: block_c4poc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4poc: // global
           I64[Sp] = block_c4poi_info;
           _s4l2A::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l2A::I64;
           if (R1 & 7 != 0) goto u4pp6; else goto c4pom;
       u4pp6: // global
           call _c4poi(R1) args: 0, res: 0, upd: 0;
       c4pom: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4poi() //  [R1]
         { info_tbl: [(c4poi,
                       label: block_c4poi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4poi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pos; else goto c4por;
       c4pos: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4por: // global
           _s4l2A::I64 = I64[Sp + 8];
           _s4l2C::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l2C::I64, 0)) goto c4poQ; else goto c4pp5;
       c4poQ: // global
           _s4l2E::I64 = -_s4l2C::I64;
           if (%MO_S_Lt_W64(_s4l2E::I64, 64)) goto c4poH; else goto c4poO;
       c4poH: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l2A::I64, _s4l2E::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4poO: // global
           if (%MO_S_Ge_W64(_s4l2A::I64, 0)) goto c4pp4; else goto c4poN;
       c4poN: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pp5: // global
           if (%MO_S_Ge_W64(_s4l2C::I64, 64)) goto c4pp4; else goto c4pp3;
       c4pp4: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pp3: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4l2A::I64 << _s4l2C::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.522600689 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplement_closure" {
     GHC.Int.$fBitsInt16_$ccomplement_closure:
         const GHC.Int.$fBitsInt16_$ccomplement_info;
 },
 GHC.Int.$fBitsInt16_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4ppf,
                       label: GHC.Int.$fBitsInt16_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ppf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pps; else goto c4ppt;
       c4pps: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ppt: // global
           I64[Sp - 8] = block_c4ppc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ppx; else goto c4ppd;
       u4ppx: // global
           call _c4ppc(R1) args: 0, res: 0, upd: 0;
       c4ppd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ppc() //  [R1]
         { info_tbl: [(c4ppc,
                       label: block_c4ppc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ppc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ppw; else goto c4ppv;
       c4ppw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ppv: // global
           _s4l2Q::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l2Q::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.524168316 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cxor_closure" {
     GHC.Int.$fBitsInt16_$cxor_closure:
         const GHC.Int.$fBitsInt16_$cxor_info;
 },
 GHC.Int.$fBitsInt16_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4ppF,
                       label: GHC.Int.$fBitsInt16_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ppF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pq0; else goto c4pq1;
       c4pq0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pq1: // global
           I64[Sp - 16] = block_c4ppC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pq7; else goto c4ppD;
       u4pq7: // global
           call _c4ppC(R1) args: 0, res: 0, upd: 0;
       c4ppD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ppC() //  [R1]
         { info_tbl: [(c4ppC,
                       label: block_c4ppC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ppC: // global
           I64[Sp] = block_c4ppI_info;
           _s4l2U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l2U::I64;
           if (R1 & 7 != 0) goto u4pq6; else goto c4ppJ;
       u4pq6: // global
           call _c4ppI(R1) args: 0, res: 0, upd: 0;
       c4ppJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ppI() //  [R1]
         { info_tbl: [(c4ppI,
                       label: block_c4ppI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ppI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pq5; else goto c4pq4;
       c4pq5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pq4: // global
           _s4l30::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l30::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.525895014 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.|._closure" {
     GHC.Int.$fBitsInt16_$c.|._closure:
         const GHC.Int.$fBitsInt16_$c.|._info;
 },
 GHC.Int.$fBitsInt16_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4pqf,
                       label: GHC.Int.$fBitsInt16_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pqf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pqA; else goto c4pqB;
       c4pqA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pqB: // global
           I64[Sp - 16] = block_c4pqc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pqH; else goto c4pqd;
       u4pqH: // global
           call _c4pqc(R1) args: 0, res: 0, upd: 0;
       c4pqd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pqc() //  [R1]
         { info_tbl: [(c4pqc,
                       label: block_c4pqc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pqc: // global
           I64[Sp] = block_c4pqi_info;
           _s4l34::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l34::I64;
           if (R1 & 7 != 0) goto u4pqG; else goto c4pqj;
       u4pqG: // global
           call _c4pqi(R1) args: 0, res: 0, upd: 0;
       c4pqj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pqi() //  [R1]
         { info_tbl: [(c4pqi,
                       label: block_c4pqi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pqi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pqF; else goto c4pqE;
       c4pqF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pqE: // global
           _s4l3a::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l3a::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.527643892 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.&._closure" {
     GHC.Int.$fBitsInt16_$c.&._closure:
         const GHC.Int.$fBitsInt16_$c.&._info;
 },
 GHC.Int.$fBitsInt16_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4pqP,
                       label: GHC.Int.$fBitsInt16_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pqP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pra; else goto c4prb;
       c4pra: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4prb: // global
           I64[Sp - 16] = block_c4pqM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4prh; else goto c4pqN;
       u4prh: // global
           call _c4pqM(R1) args: 0, res: 0, upd: 0;
       c4pqN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pqM() //  [R1]
         { info_tbl: [(c4pqM,
                       label: block_c4pqM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pqM: // global
           I64[Sp] = block_c4pqS_info;
           _s4l3e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3e::I64;
           if (R1 & 7 != 0) goto u4prg; else goto c4pqT;
       u4prg: // global
           call _c4pqS(R1) args: 0, res: 0, upd: 0;
       c4pqT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pqS() //  [R1]
         { info_tbl: [(c4pqS,
                       label: block_c4pqS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pqS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4prf; else goto c4pre;
       c4prf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pre: // global
           _s4l3k::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l3k::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.529421024 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4prp,
                       label: GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4prp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4prD; else goto c4prE;
       c4prD: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4prE: // global
           I64[Sp - 8] = block_c4prm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4prI; else goto c4prn;
       u4prI: // global
           call _c4prm(R1) args: 0, res: 0, upd: 0;
       c4prn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4prm() //  [R1]
         { info_tbl: [(c4prm,
                       label: block_c4prm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4prm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4prH; else goto c4prG;
       c4prH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4prG: // global
           (_c4prv::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4prv::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.530942286 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4prQ,
                       label: GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4prQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ps4; else goto c4ps5;
       c4ps4: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ps5: // global
           I64[Sp - 8] = block_c4prN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ps9; else goto c4prO;
       u4ps9: // global
           call _c4prN(R1) args: 0, res: 0, upd: 0;
       c4prO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4prN() //  [R1]
         { info_tbl: [(c4prN,
                       label: block_c4prN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4prN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ps8; else goto c4ps7;
       c4ps8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ps7: // global
           (_c4prW::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4prW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.53213755 UTC

[section ""data" . GHC.Int.$fBitsInt1_closure" {
     GHC.Int.$fBitsInt1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.532848475 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt16_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt16_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4pse,
                       label: GHC.Int.$fBitsInt16_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pse: // global
           R1 = GHC.Int.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.533902024 UTC

[section ""data" . GHC.Int.$fNumInt32_$cfromInteger_closure" {
     GHC.Int.$fNumInt32_$cfromInteger_closure:
         const GHC.Int.$fNumInt32_$cfromInteger_info;
 },
 GHC.Int.$fNumInt32_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4psn,
                       label: GHC.Int.$fNumInt32_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4psn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4psu; else goto c4psv;
       c4psu: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4psv: // global
           I64[Sp - 8] = block_c4psl_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4psl() //  [R1]
         { info_tbl: [(c4psl,
                       label: block_c4psl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4psl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4psy; else goto c4psx;
       c4psy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4psx: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.536288825 UTC

[section ""data" . GHC.Int.$fNumInt32_$cnegate_closure" {
     GHC.Int.$fNumInt32_$cnegate_closure:
         const GHC.Int.$fNumInt32_$cnegate_info;
 },
 GHC.Int.$fNumInt32_$cnegate_entry() //  [R2]
         { info_tbl: [(c4psG,
                       label: GHC.Int.$fNumInt32_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4psG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4psQ; else goto c4psR;
       c4psQ: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4psR: // global
           I64[Sp - 8] = block_c4psD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4psV; else goto c4psE;
       u4psV: // global
           call _c4psD(R1) args: 0, res: 0, upd: 0;
       c4psE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4psD() //  [R1]
         { info_tbl: [(c4psD,
                       label: block_c4psD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4psD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4psU; else goto c4psT;
       c4psU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4psT: // global
           _s4l3F::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3F::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.538026085 UTC

[section ""data" . GHC.Int.$fNumInt32_$c*_closure" {
     GHC.Int.$fNumInt32_$c*_closure:
         const GHC.Int.$fNumInt32_$c*_info;
 },
 GHC.Int.$fNumInt32_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4pt3,
                       label: GHC.Int.$fNumInt32_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pt3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pti; else goto c4ptj;
       c4pti: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ptj: // global
           I64[Sp - 16] = block_c4pt0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ptp; else goto c4pt1;
       u4ptp: // global
           call _c4pt0(R1) args: 0, res: 0, upd: 0;
       c4pt1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pt0() //  [R1]
         { info_tbl: [(c4pt0,
                       label: block_c4pt0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pt0: // global
           I64[Sp] = block_c4pt6_info;
           _s4l3J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3J::I64;
           if (R1 & 7 != 0) goto u4pto; else goto c4pt7;
       u4pto: // global
           call _c4pt6(R1) args: 0, res: 0, upd: 0;
       c4pt7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pt6() //  [R1]
         { info_tbl: [(c4pt6,
                       label: block_c4pt6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pt6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ptn; else goto c4ptm;
       c4ptn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ptm: // global
           _s4l3N::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3N::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.539791821 UTC

[section ""data" . GHC.Int.$fNumInt32_$c-_closure" {
     GHC.Int.$fNumInt32_$c-_closure:
         const GHC.Int.$fNumInt32_$c-_info;
 },
 GHC.Int.$fNumInt32_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4ptx,
                       label: GHC.Int.$fNumInt32_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ptx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ptM; else goto c4ptN;
       c4ptM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ptN: // global
           I64[Sp - 16] = block_c4ptu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ptT; else goto c4ptv;
       u4ptT: // global
           call _c4ptu(R1) args: 0, res: 0, upd: 0;
       c4ptv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ptu() //  [R1]
         { info_tbl: [(c4ptu,
                       label: block_c4ptu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ptu: // global
           I64[Sp] = block_c4ptA_info;
           _s4l3R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3R::I64;
           if (R1 & 7 != 0) goto u4ptS; else goto c4ptB;
       u4ptS: // global
           call _c4ptA(R1) args: 0, res: 0, upd: 0;
       c4ptB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ptA() //  [R1]
         { info_tbl: [(c4ptA,
                       label: block_c4ptA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ptA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ptR; else goto c4ptQ;
       c4ptR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ptQ: // global
           _s4l3V::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3V::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.541670562 UTC

[section ""data" . GHC.Int.$fNumInt32_$c+_closure" {
     GHC.Int.$fNumInt32_$c+_closure:
         const GHC.Int.$fNumInt32_$c+_info;
 },
 GHC.Int.$fNumInt32_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4pu1,
                       label: GHC.Int.$fNumInt32_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pu1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pug; else goto c4puh;
       c4pug: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4puh: // global
           I64[Sp - 16] = block_c4ptY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pun; else goto c4ptZ;
       u4pun: // global
           call _c4ptY(R1) args: 0, res: 0, upd: 0;
       c4ptZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ptY() //  [R1]
         { info_tbl: [(c4ptY,
                       label: block_c4ptY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ptY: // global
           I64[Sp] = block_c4pu4_info;
           _s4l3Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3Z::I64;
           if (R1 & 7 != 0) goto u4pum; else goto c4pu5;
       u4pum: // global
           call _c4pu4(R1) args: 0, res: 0, upd: 0;
       c4pu5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pu4() //  [R1]
         { info_tbl: [(c4pu4,
                       label: block_c4pu4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pu4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pul; else goto c4puk;
       c4pul: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4puk: // global
           _s4l43::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l43::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.543246471 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt32_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt32_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt32_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4puv,
                       label: GHC.Int.$fIntegralInt32_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4puv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4puw; else goto c4pux;
       c4puw: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pux: // global
           I64[Sp - 8] = block_c4pus_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4puB; else goto c4put;
       u4puB: // global
           call _c4pus(R1) args: 0, res: 0, upd: 0;
       c4put: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pus() //  [R1]
         { info_tbl: [(c4pus,
                       label: block_c4pus_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pus: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.544560843 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cpopCount_closure" {
     GHC.Int.$fBitsInt32_$cpopCount_closure:
         const GHC.Int.$fBitsInt32_$cpopCount_info;
 },
 GHC.Int.$fBitsInt32_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4puJ,
                       label: GHC.Int.$fBitsInt32_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4puJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4puX; else goto c4puY;
       c4puX: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4puY: // global
           I64[Sp - 8] = block_c4puG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pv2; else goto c4puH;
       u4pv2: // global
           call _c4puG(R1) args: 0, res: 0, upd: 0;
       c4puH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4puG() //  [R1]
         { info_tbl: [(c4puG,
                       label: block_c4puG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4puG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pv1; else goto c4pv0;
       c4pv1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pv0: // global
           (_c4puP::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4puP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.546194758 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4pva,
                       label: GHC.Int.$fBitsInt32_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pva: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pvm; else goto c4pvn;
       c4pvm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pvn: // global
           I64[Sp - 16] = block_c4pv7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pvt; else goto c4pv8;
       u4pvt: // global
           call _c4pv7(R1) args: 0, res: 0, upd: 0;
       c4pv8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pv7() //  [R1]
         { info_tbl: [(c4pv7,
                       label: block_c4pv7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pv7: // global
           I64[Sp] = block_c4pvd_info;
           _s4l4g::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4g::I64;
           if (R1 & 7 != 0) goto u4pvs; else goto c4pve;
       u4pvs: // global
           call _c4pvd(R1) args: 0, res: 0, upd: 0;
       c4pve: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pvd() //  [R1]
         { info_tbl: [(c4pvd,
                       label: block_c4pvd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pvd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pvr; else goto c4pvq;
       c4pvr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pvq: // global
           _s4l4j::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l4j::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.547566693 UTC

[section ""data" . GHC.Int.$fBitsInt6_closure" {
     GHC.Int.$fBitsInt6_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.548146127 UTC

[section ""data" . GHC.Int.$fNumInt4_closure" {
     GHC.Int.$fNumInt4_closure:
         const GHC.Int.I32#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.549432981 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftR_closure" {
     GHC.Int.$fBitsInt32_$cshiftR_closure:
         const GHC.Int.$fBitsInt32_$cshiftR_info;
 },
 GHC.Int.$fBitsInt32_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4pvB,
                       label: GHC.Int.$fBitsInt32_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pvB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pvF; else goto c4pvG;
       c4pvF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pvG: // global
           I64[Sp - 16] = block_c4pvy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pw6; else goto c4pvz;
       u4pw6: // global
           call _c4pvy(R1) args: 0, res: 0, upd: 0;
       c4pvz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pvy() //  [R1]
         { info_tbl: [(c4pvy,
                       label: block_c4pvy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pvy: // global
           I64[Sp] = block_c4pvE_info;
           _s4l4n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4n::I64;
           if (R1 & 7 != 0) goto u4pw5; else goto c4pvI;
       u4pw5: // global
           call _c4pvE(R1) args: 0, res: 0, upd: 0;
       c4pvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pvE() //  [R1]
         { info_tbl: [(c4pvE,
                       label: block_c4pvE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pvE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pvO; else goto c4pvN;
       c4pvO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pvN: // global
           _s4l4n::I64 = I64[Sp + 8];
           _s4l4p::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l4p::I64, 64)) goto c4pvX; else goto c4pw4;
       c4pvX: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l4n::I64, _s4l4p::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pw4: // global
           if (%MO_S_Ge_W64(_s4l4n::I64, 0)) goto c4pw2; else goto c4pw3;
       c4pw2: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pw3: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.551606802 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4pwe,
                       label: GHC.Int.$fBitsInt32_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pwe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pwt; else goto c4pwu;
       c4pwt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pwu: // global
           I64[Sp - 16] = block_c4pwb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pwA; else goto c4pwc;
       u4pwA: // global
           call _c4pwb(R1) args: 0, res: 0, upd: 0;
       c4pwc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pwb() //  [R1]
         { info_tbl: [(c4pwb,
                       label: block_c4pwb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pwb: // global
           I64[Sp] = block_c4pwh_info;
           _s4l4w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4w::I64;
           if (R1 & 7 != 0) goto u4pwz; else goto c4pwi;
       u4pwz: // global
           call _c4pwh(R1) args: 0, res: 0, upd: 0;
       c4pwi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pwh() //  [R1]
         { info_tbl: [(c4pwh,
                       label: block_c4pwh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pwh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pwy; else goto c4pwx;
       c4pwy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pwx: // global
           _s4l4A::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l4A::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.553621896 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftL_closure" {
     GHC.Int.$fBitsInt32_$cshiftL_closure:
         const GHC.Int.$fBitsInt32_$cshiftL_info;
 },
 GHC.Int.$fBitsInt32_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4pwI,
                       label: GHC.Int.$fBitsInt32_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pwI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pwM; else goto c4pwN;
       c4pwM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pwN: // global
           I64[Sp - 16] = block_c4pwF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pxa; else goto c4pwG;
       u4pxa: // global
           call _c4pwF(R1) args: 0, res: 0, upd: 0;
       c4pwG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pwF() //  [R1]
         { info_tbl: [(c4pwF,
                       label: block_c4pwF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pwF: // global
           I64[Sp] = block_c4pwL_info;
           _s4l4E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4E::I64;
           if (R1 & 7 != 0) goto u4px9; else goto c4pwP;
       u4px9: // global
           call _c4pwL(R1) args: 0, res: 0, upd: 0;
       c4pwP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pwL() //  [R1]
         { info_tbl: [(c4pwL,
                       label: block_c4pwL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pwL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pwV; else goto c4pwU;
       c4pwV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pwU: // global
           _s4l4G::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l4G::I64, 64)) goto c4px7; else goto c4px8;
       c4px7: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << _s4l4G::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4px8: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.555216345 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cisSigned_closure" {
     GHC.Int.$fBitsInt32_$cisSigned_closure:
         const GHC.Int.$fBitsInt32_$cisSigned_info;
 },
 GHC.Int.$fBitsInt32_$cisSigned_entry() //  []
         { info_tbl: [(c4pxf,
                       label: GHC.Int.$fBitsInt32_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pxf: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.556721306 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotate_closure" {
     GHC.Int.$fBitsInt32_$crotate_closure:
         const GHC.Int.$fBitsInt32_$crotate_info;
 },
 GHC.Int.$fBitsInt32_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4pxp,
                       label: GHC.Int.$fBitsInt32_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pxp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pxt; else goto c4pxu;
       c4pxt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pxu: // global
           I64[Sp - 16] = block_c4pxm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pyq; else goto c4pxn;
       u4pyq: // global
           call _c4pxm(R1) args: 0, res: 0, upd: 0;
       c4pxn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pxm() //  [R1]
         { info_tbl: [(c4pxm,
                       label: block_c4pxm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pxm: // global
           I64[Sp - 8] = block_c4pxs_info;
           _s4l4N::P64 = R1;
           _s4l4O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l4O::I64;
           P64[Sp + 8] = _s4l4N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pyp; else goto c4pxw;
       u4pyp: // global
           call _c4pxs(R1) args: 0, res: 0, upd: 0;
       c4pxw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pxs() //  [R1]
         { info_tbl: [(c4pxs,
                       label: block_c4pxs_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pxs: // global
           _s4l4T::I64 = I64[R1 + 7] & 31;
           if (_s4l4T::I64 != 0) goto u4pyn; else goto c4pyj;
       u4pyn: // global
           I64[Sp + 16] = _s4l4T::I64;
           Sp = Sp + 8;
           call _c4pxL() args: 0, res: 0, upd: 0;
       c4pyj: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pxL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pxL: // global
           Hp = Hp + 16;
           _s4l4T::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4pyg; else goto c4pyf;
       c4pyg: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4pxK_info;
           R1 = _s4l4T::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4pyf: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4l4U::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4l4U::I64 << _s4l4T::I64) | (_s4l4U::I64 >> 32 - _s4l4T::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pxK() //  [R1]
         { info_tbl: [(c4pxK,
                       label: block_c4pxK_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pxK: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4pxL() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.560677112 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshift_closure" {
     GHC.Int.$fBitsInt32_$cshift_closure:
         const GHC.Int.$fBitsInt32_$cshift_info;
 },
 GHC.Int.$fBitsInt32_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4pyA,
                       label: GHC.Int.$fBitsInt32_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pyA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pyE; else goto c4pyF;
       c4pyE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pyF: // global
           I64[Sp - 16] = block_c4pyx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pzs; else goto c4pyy;
       u4pzs: // global
           call _c4pyx(R1) args: 0, res: 0, upd: 0;
       c4pyy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pyx() //  [R1]
         { info_tbl: [(c4pyx,
                       label: block_c4pyx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pyx: // global
           I64[Sp] = block_c4pyD_info;
           _s4l55::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l55::I64;
           if (R1 & 7 != 0) goto u4pzr; else goto c4pyH;
       u4pzr: // global
           call _c4pyD(R1) args: 0, res: 0, upd: 0;
       c4pyH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pyD() //  [R1]
         { info_tbl: [(c4pyD,
                       label: block_c4pyD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pyD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pyN; else goto c4pyM;
       c4pyN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pyM: // global
           _s4l55::I64 = I64[Sp + 8];
           _s4l57::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l57::I64, 0)) goto c4pzb; else goto c4pzq;
       c4pzb: // global
           _s4l59::I64 = -_s4l57::I64;
           if (%MO_S_Lt_W64(_s4l59::I64, 64)) goto c4pz2; else goto c4pz9;
       c4pz2: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l55::I64, _s4l59::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pz9: // global
           if (%MO_S_Ge_W64(_s4l55::I64, 0)) goto c4pzp; else goto c4pz8;
       c4pz8: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pzq: // global
           if (%MO_S_Ge_W64(_s4l57::I64, 64)) goto c4pzp; else goto c4pzo;
       c4pzp: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pzo: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4l55::I64 << _s4l57::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.562883193 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplement_closure" {
     GHC.Int.$fBitsInt32_$ccomplement_closure:
         const GHC.Int.$fBitsInt32_$ccomplement_info;
 },
 GHC.Int.$fBitsInt32_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4pzA,
                       label: GHC.Int.$fBitsInt32_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pzA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pzN; else goto c4pzO;
       c4pzN: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pzO: // global
           I64[Sp - 8] = block_c4pzx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pzS; else goto c4pzy;
       u4pzS: // global
           call _c4pzx(R1) args: 0, res: 0, upd: 0;
       c4pzy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pzx() //  [R1]
         { info_tbl: [(c4pzx,
                       label: block_c4pzx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pzx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pzR; else goto c4pzQ;
       c4pzR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pzQ: // global
           _s4l5l::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.564443943 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cxor_closure" {
     GHC.Int.$fBitsInt32_$cxor_closure:
         const GHC.Int.$fBitsInt32_$cxor_info;
 },
 GHC.Int.$fBitsInt32_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4pA0,
                       label: GHC.Int.$fBitsInt32_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pA0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pAl; else goto c4pAm;
       c4pAl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pAm: // global
           I64[Sp - 16] = block_c4pzX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pAs; else goto c4pzY;
       u4pAs: // global
           call _c4pzX(R1) args: 0, res: 0, upd: 0;
       c4pzY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pzX() //  [R1]
         { info_tbl: [(c4pzX,
                       label: block_c4pzX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pzX: // global
           I64[Sp] = block_c4pA3_info;
           _s4l5p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5p::I64;
           if (R1 & 7 != 0) goto u4pAr; else goto c4pA4;
       u4pAr: // global
           call _c4pA3(R1) args: 0, res: 0, upd: 0;
       c4pA4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pA3() //  [R1]
         { info_tbl: [(c4pA3,
                       label: block_c4pA3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pA3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pAq; else goto c4pAp;
       c4pAq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pAp: // global
           _s4l5v::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5v::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.566307175 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.|._closure" {
     GHC.Int.$fBitsInt32_$c.|._closure:
         const GHC.Int.$fBitsInt32_$c.|._info;
 },
 GHC.Int.$fBitsInt32_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4pAA,
                       label: GHC.Int.$fBitsInt32_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pAA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pAV; else goto c4pAW;
       c4pAV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pAW: // global
           I64[Sp - 16] = block_c4pAx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pB2; else goto c4pAy;
       u4pB2: // global
           call _c4pAx(R1) args: 0, res: 0, upd: 0;
       c4pAy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pAx() //  [R1]
         { info_tbl: [(c4pAx,
                       label: block_c4pAx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pAx: // global
           I64[Sp] = block_c4pAD_info;
           _s4l5z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5z::I64;
           if (R1 & 7 != 0) goto u4pB1; else goto c4pAE;
       u4pB1: // global
           call _c4pAD(R1) args: 0, res: 0, upd: 0;
       c4pAE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pAD() //  [R1]
         { info_tbl: [(c4pAD,
                       label: block_c4pAD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pAD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pB0; else goto c4pAZ;
       c4pB0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pAZ: // global
           _s4l5F::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5F::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.568097152 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.&._closure" {
     GHC.Int.$fBitsInt32_$c.&._closure:
         const GHC.Int.$fBitsInt32_$c.&._info;
 },
 GHC.Int.$fBitsInt32_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4pBa,
                       label: GHC.Int.$fBitsInt32_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pBa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pBv; else goto c4pBw;
       c4pBv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pBw: // global
           I64[Sp - 16] = block_c4pB7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pBC; else goto c4pB8;
       u4pBC: // global
           call _c4pB7(R1) args: 0, res: 0, upd: 0;
       c4pB8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pB7() //  [R1]
         { info_tbl: [(c4pB7,
                       label: block_c4pB7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pB7: // global
           I64[Sp] = block_c4pBd_info;
           _s4l5J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5J::I64;
           if (R1 & 7 != 0) goto u4pBB; else goto c4pBe;
       u4pBB: // global
           call _c4pBd(R1) args: 0, res: 0, upd: 0;
       c4pBe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pBd() //  [R1]
         { info_tbl: [(c4pBd,
                       label: block_c4pBd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pBd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pBA; else goto c4pBz;
       c4pBA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pBz: // global
           _s4l5P::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5P::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.569869733 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4pBK,
                       label: GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pBK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pBY; else goto c4pBZ;
       c4pBY: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pBZ: // global
           I64[Sp - 8] = block_c4pBH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pC3; else goto c4pBI;
       u4pC3: // global
           call _c4pBH(R1) args: 0, res: 0, upd: 0;
       c4pBI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pBH() //  [R1]
         { info_tbl: [(c4pBH,
                       label: block_c4pBH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pBH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pC2; else goto c4pC1;
       c4pC2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pC1: // global
           (_c4pBQ::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4pBQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.571303344 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4pCb,
                       label: GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pCb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pCp; else goto c4pCq;
       c4pCp: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pCq: // global
           I64[Sp - 8] = block_c4pC8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pCu; else goto c4pC9;
       u4pCu: // global
           call _c4pC8(R1) args: 0, res: 0, upd: 0;
       c4pC9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pC8() //  [R1]
         { info_tbl: [(c4pC8,
                       label: block_c4pC8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pC8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pCt; else goto c4pCs;
       c4pCt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pCs: // global
           (_c4pCh::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4pCh::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.572405924 UTC

[section ""data" . GHC.Int.$fBitsInt4_closure" {
     GHC.Int.$fBitsInt4_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.573111365 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt32_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt32_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4pCz,
                       label: GHC.Int.$fBitsInt32_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pCz: // global
           R1 = GHC.Int.$fBitsInt4_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.574510389 UTC

[section ""data" . GHC.Int.$fNumInt64_$cfromInteger_closure" {
     GHC.Int.$fNumInt64_$cfromInteger_closure:
         const GHC.Int.$fNumInt64_$cfromInteger_info;
 },
 GHC.Int.$fNumInt64_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4pCI,
                       label: GHC.Int.$fNumInt64_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pCI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pCM; else goto c4pCN;
       c4pCM: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pCN: // global
           I64[Sp - 8] = block_c4pCG_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4pCG() //  [R1]
         { info_tbl: [(c4pCG,
                       label: block_c4pCG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pCG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pCQ; else goto c4pCP;
       c4pCQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4pCP: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.575826343 UTC

[section ""data" . GHC.Int.$fNumInt64_$cnegate_closure" {
     GHC.Int.$fNumInt64_$cnegate_closure:
         const GHC.Int.$fNumInt64_$cnegate_info;
 },
 GHC.Int.$fNumInt64_$cnegate_entry() //  [R2]
         { info_tbl: [(c4pCY,
                       label: GHC.Int.$fNumInt64_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pCY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pD5; else goto c4pD6;
       c4pD5: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pD6: // global
           I64[Sp - 8] = block_c4pCV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pDa; else goto c4pCW;
       u4pDa: // global
           call _c4pCV(R1) args: 0, res: 0, upd: 0;
       c4pCW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pCV() //  [R1]
         { info_tbl: [(c4pCV,
                       label: block_c4pCV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pCV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pD9; else goto c4pD8;
       c4pD9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pD8: // global
           _s4l68::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l68::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.577395585 UTC

[section ""data" . GHC.Int.$fNumInt64_$c*_closure" {
     GHC.Int.$fNumInt64_$c*_closure:
         const GHC.Int.$fNumInt64_$c*_info;
 },
 GHC.Int.$fNumInt64_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4pDi,
                       label: GHC.Int.$fNumInt64_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pDi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pDu; else goto c4pDv;
       c4pDu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pDv: // global
           I64[Sp - 16] = block_c4pDf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pDB; else goto c4pDg;
       u4pDB: // global
           call _c4pDf(R1) args: 0, res: 0, upd: 0;
       c4pDg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pDf() //  [R1]
         { info_tbl: [(c4pDf,
                       label: block_c4pDf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pDf: // global
           I64[Sp] = block_c4pDl_info;
           _s4l6c::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6c::I64;
           if (R1 & 7 != 0) goto u4pDA; else goto c4pDm;
       u4pDA: // global
           call _c4pDl(R1) args: 0, res: 0, upd: 0;
       c4pDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pDl() //  [R1]
         { info_tbl: [(c4pDl,
                       label: block_c4pDl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pDl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pDz; else goto c4pDy;
       c4pDz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pDy: // global
           _s4l6f::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6f::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.579201373 UTC

[section ""data" . GHC.Int.$fNumInt64_$c-_closure" {
     GHC.Int.$fNumInt64_$c-_closure:
         const GHC.Int.$fNumInt64_$c-_info;
 },
 GHC.Int.$fNumInt64_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4pDJ,
                       label: GHC.Int.$fNumInt64_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pDJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pDV; else goto c4pDW;
       c4pDV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pDW: // global
           I64[Sp - 16] = block_c4pDG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pE2; else goto c4pDH;
       u4pE2: // global
           call _c4pDG(R1) args: 0, res: 0, upd: 0;
       c4pDH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pDG() //  [R1]
         { info_tbl: [(c4pDG,
                       label: block_c4pDG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pDG: // global
           I64[Sp] = block_c4pDM_info;
           _s4l6j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6j::I64;
           if (R1 & 7 != 0) goto u4pE1; else goto c4pDN;
       u4pE1: // global
           call _c4pDM(R1) args: 0, res: 0, upd: 0;
       c4pDN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pDM() //  [R1]
         { info_tbl: [(c4pDM,
                       label: block_c4pDM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pDM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pE0; else goto c4pDZ;
       c4pE0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pDZ: // global
           _s4l6m::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6m::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.581064183 UTC

[section ""data" . GHC.Int.$fNumInt64_$c+_closure" {
     GHC.Int.$fNumInt64_$c+_closure:
         const GHC.Int.$fNumInt64_$c+_info;
 },
 GHC.Int.$fNumInt64_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4pEa,
                       label: GHC.Int.$fNumInt64_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pEa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pEm; else goto c4pEn;
       c4pEm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pEn: // global
           I64[Sp - 16] = block_c4pE7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pEt; else goto c4pE8;
       u4pEt: // global
           call _c4pE7(R1) args: 0, res: 0, upd: 0;
       c4pE8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pE7() //  [R1]
         { info_tbl: [(c4pE7,
                       label: block_c4pE7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pE7: // global
           I64[Sp] = block_c4pEd_info;
           _s4l6q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6q::I64;
           if (R1 & 7 != 0) goto u4pEs; else goto c4pEe;
       u4pEs: // global
           call _c4pEd(R1) args: 0, res: 0, upd: 0;
       c4pEe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pEd() //  [R1]
         { info_tbl: [(c4pEd,
                       label: block_c4pEd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pEd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pEr; else goto c4pEq;
       c4pEr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pEq: // global
           _s4l6t::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.583953994 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt64_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt64_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt64_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4pEB,
                       label: GHC.Int.$fIntegralInt64_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pEB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pEC; else goto c4pED;
       c4pEC: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pED: // global
           I64[Sp - 8] = block_c4pEy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pEH; else goto c4pEz;
       u4pEH: // global
           call _c4pEy(R1) args: 0, res: 0, upd: 0;
       c4pEz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pEy() //  [R1]
         { info_tbl: [(c4pEy,
                       label: block_c4pEy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pEy: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.585348107 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cpopCount_closure" {
     GHC.Int.$fBitsInt64_$cpopCount_closure:
         const GHC.Int.$fBitsInt64_$cpopCount_info;
 },
 GHC.Int.$fBitsInt64_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4pEP,
                       label: GHC.Int.$fBitsInt64_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pEP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pF3; else goto c4pF4;
       c4pF3: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pF4: // global
           I64[Sp - 8] = block_c4pEM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pF8; else goto c4pEN;
       u4pF8: // global
           call _c4pEM(R1) args: 0, res: 0, upd: 0;
       c4pEN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pEM() //  [R1]
         { info_tbl: [(c4pEM,
                       label: block_c4pEM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pEM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pF7; else goto c4pF6;
       c4pF7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pF6: // global
           (_c4pEV::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4pEV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.586888285 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4pFg,
                       label: GHC.Int.$fBitsInt64_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pFg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pFs; else goto c4pFt;
       c4pFs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pFt: // global
           I64[Sp - 16] = block_c4pFd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pFz; else goto c4pFe;
       u4pFz: // global
           call _c4pFd(R1) args: 0, res: 0, upd: 0;
       c4pFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pFd() //  [R1]
         { info_tbl: [(c4pFd,
                       label: block_c4pFd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pFd: // global
           I64[Sp] = block_c4pFj_info;
           _s4l6G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6G::I64;
           if (R1 & 7 != 0) goto u4pFy; else goto c4pFk;
       u4pFy: // global
           call _c4pFj(R1) args: 0, res: 0, upd: 0;
       c4pFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pFj() //  [R1]
         { info_tbl: [(c4pFj,
                       label: block_c4pFj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pFj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pFx; else goto c4pFw;
       c4pFx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pFw: // global
           _s4l6J::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6J::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.588220779 UTC

[section ""data" . GHC.Int.$fBitsInt10_closure" {
     GHC.Int.$fBitsInt10_closure:
         const GHC.Int.I64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.588778194 UTC

[section ""data" . GHC.Int.$fNumInt6_closure" {
     GHC.Int.$fNumInt6_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.589975594 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftR_closure" {
     GHC.Int.$fBitsInt64_$cshiftR_closure:
         const GHC.Int.$fBitsInt64_$cshiftR_info;
 },
 GHC.Int.$fBitsInt64_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4pFH,
                       label: GHC.Int.$fBitsInt64_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pFH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pFL; else goto c4pFM;
       c4pFL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pFM: // global
           I64[Sp - 16] = block_c4pFE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pGc; else goto c4pFF;
       u4pGc: // global
           call _c4pFE(R1) args: 0, res: 0, upd: 0;
       c4pFF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pFE() //  [R1]
         { info_tbl: [(c4pFE,
                       label: block_c4pFE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pFE: // global
           I64[Sp] = block_c4pFK_info;
           _s4l6N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6N::I64;
           if (R1 & 7 != 0) goto u4pGb; else goto c4pFO;
       u4pGb: // global
           call _c4pFK(R1) args: 0, res: 0, upd: 0;
       c4pFO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pFK() //  [R1]
         { info_tbl: [(c4pFK,
                       label: block_c4pFK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pFK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pFU; else goto c4pFT;
       c4pFU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pFT: // global
           _s4l6N::I64 = I64[Sp + 8];
           _s4l6P::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l6P::I64, 64)) goto c4pG3; else goto c4pGa;
       c4pG3: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l6N::I64, _s4l6P::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pGa: // global
           if (%MO_S_Ge_W64(_s4l6N::I64, 0)) goto c4pG8; else goto c4pG9;
       c4pG8: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pG9: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.591914309 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4pGk,
                       label: GHC.Int.$fBitsInt64_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pGk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pGw; else goto c4pGx;
       c4pGw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pGx: // global
           I64[Sp - 16] = block_c4pGh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pGD; else goto c4pGi;
       u4pGD: // global
           call _c4pGh(R1) args: 0, res: 0, upd: 0;
       c4pGi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pGh() //  [R1]
         { info_tbl: [(c4pGh,
                       label: block_c4pGh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pGh: // global
           I64[Sp] = block_c4pGn_info;
           _s4l6W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6W::I64;
           if (R1 & 7 != 0) goto u4pGC; else goto c4pGo;
       u4pGC: // global
           call _c4pGn(R1) args: 0, res: 0, upd: 0;
       c4pGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pGn() //  [R1]
         { info_tbl: [(c4pGn,
                       label: block_c4pGn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pGn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pGB; else goto c4pGA;
       c4pGB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pGA: // global
           _s4l6Z::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6Z::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.594088968 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftL_closure" {
     GHC.Int.$fBitsInt64_$cshiftL_closure:
         const GHC.Int.$fBitsInt64_$cshiftL_info;
 },
 GHC.Int.$fBitsInt64_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4pGL,
                       label: GHC.Int.$fBitsInt64_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pGL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pGP; else goto c4pGQ;
       c4pGP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pGQ: // global
           I64[Sp - 16] = block_c4pGI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pHa; else goto c4pGJ;
       u4pHa: // global
           call _c4pGI(R1) args: 0, res: 0, upd: 0;
       c4pGJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pGI() //  [R1]
         { info_tbl: [(c4pGI,
                       label: block_c4pGI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pGI: // global
           I64[Sp] = block_c4pGO_info;
           _s4l73::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l73::I64;
           if (R1 & 7 != 0) goto u4pH9; else goto c4pGS;
       u4pH9: // global
           call _c4pGO(R1) args: 0, res: 0, upd: 0;
       c4pGS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pGO() //  [R1]
         { info_tbl: [(c4pGO,
                       label: block_c4pGO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pGO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pGY; else goto c4pGX;
       c4pGY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pGX: // global
           _s4l75::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l75::I64, 64)) goto c4pH7; else goto c4pH8;
       c4pH7: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s4l75::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pH8: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.596930172 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cisSigned_closure" {
     GHC.Int.$fBitsInt64_$cisSigned_closure:
         const GHC.Int.$fBitsInt64_$cisSigned_info;
 },
 GHC.Int.$fBitsInt64_$cisSigned_entry() //  []
         { info_tbl: [(c4pHf,
                       label: GHC.Int.$fBitsInt64_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pHf: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.599293766 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotate_closure" {
     GHC.Int.$fBitsInt64_$crotate_closure:
         const GHC.Int.$fBitsInt64_$crotate_info;
 },
 GHC.Int.$fBitsInt64_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4pHp,
                       label: GHC.Int.$fBitsInt64_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pHp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pHt; else goto c4pHu;
       c4pHt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pHu: // global
           I64[Sp - 16] = block_c4pHm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pIk; else goto c4pHn;
       u4pIk: // global
           call _c4pHm(R1) args: 0, res: 0, upd: 0;
       c4pHn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pHm() //  [R1]
         { info_tbl: [(c4pHm,
                       label: block_c4pHm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pHm: // global
           I64[Sp - 8] = block_c4pHs_info;
           _s4l7b::P64 = R1;
           _s4l7c::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l7c::I64;
           P64[Sp + 8] = _s4l7b::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pIj; else goto c4pHw;
       u4pIj: // global
           call _c4pHs(R1) args: 0, res: 0, upd: 0;
       c4pHw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pHs() //  [R1]
         { info_tbl: [(c4pHs,
                       label: block_c4pHs_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pHs: // global
           _s4l7h::I64 = I64[R1 + 7] & 63;
           if (_s4l7h::I64 != 0) goto u4pIh; else goto c4pId;
       u4pIh: // global
           I64[Sp + 16] = _s4l7h::I64;
           Sp = Sp + 8;
           call _c4pHL() args: 0, res: 0, upd: 0;
       c4pId: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pHL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pHL: // global
           Hp = Hp + 16;
           _s4l7h::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4pIa; else goto c4pI9;
       c4pIa: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4pHK_info;
           R1 = _s4l7h::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4pI9: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4l7i::I64 = I64[Sp];
           I64[Hp] = (_s4l7i::I64 << _s4l7h::I64) | (_s4l7i::I64 >> 64 - _s4l7h::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pHK() //  [R1]
         { info_tbl: [(c4pHK,
                       label: block_c4pHK_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pHK: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4pHL() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.60321921 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshift_closure" {
     GHC.Int.$fBitsInt64_$cshift_closure:
         const GHC.Int.$fBitsInt64_$cshift_info;
 },
 GHC.Int.$fBitsInt64_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4pIu,
                       label: GHC.Int.$fBitsInt64_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pIu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pIy; else goto c4pIz;
       c4pIy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pIz: // global
           I64[Sp - 16] = block_c4pIr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pJj; else goto c4pIs;
       u4pJj: // global
           call _c4pIr(R1) args: 0, res: 0, upd: 0;
       c4pIs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pIr() //  [R1]
         { info_tbl: [(c4pIr,
                       label: block_c4pIr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pIr: // global
           I64[Sp] = block_c4pIx_info;
           _s4l7r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7r::I64;
           if (R1 & 7 != 0) goto u4pJi; else goto c4pIB;
       u4pJi: // global
           call _c4pIx(R1) args: 0, res: 0, upd: 0;
       c4pIB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pIx() //  [R1]
         { info_tbl: [(c4pIx,
                       label: block_c4pIx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pIx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pIH; else goto c4pIG;
       c4pIH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pIG: // global
           _s4l7r::I64 = I64[Sp + 8];
           _s4l7t::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l7t::I64, 0)) goto c4pJ5; else goto c4pJh;
       c4pJ5: // global
           _s4l7v::I64 = -_s4l7t::I64;
           if (%MO_S_Lt_W64(_s4l7v::I64, 64)) goto c4pIW; else goto c4pJ3;
       c4pIW: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l7r::I64, _s4l7v::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pJ3: // global
           if (%MO_S_Ge_W64(_s4l7r::I64, 0)) goto c4pJg; else goto c4pJ2;
       c4pJ2: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pJh: // global
           if (%MO_S_Ge_W64(_s4l7t::I64, 64)) goto c4pJg; else goto c4pJf;
       c4pJg: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pJf: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7r::I64 << _s4l7t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.606970706 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplement_closure" {
     GHC.Int.$fBitsInt64_$ccomplement_closure:
         const GHC.Int.$fBitsInt64_$ccomplement_info;
 },
 GHC.Int.$fBitsInt64_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4pJr,
                       label: GHC.Int.$fBitsInt64_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pJr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pJE; else goto c4pJF;
       c4pJE: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pJF: // global
           I64[Sp - 8] = block_c4pJo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pJJ; else goto c4pJp;
       u4pJJ: // global
           call _c4pJo(R1) args: 0, res: 0, upd: 0;
       c4pJp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pJo() //  [R1]
         { info_tbl: [(c4pJo,
                       label: block_c4pJo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pJo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pJI; else goto c4pJH;
       c4pJI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pJH: // global
           _s4l7G::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7G::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.609520053 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cxor_closure" {
     GHC.Int.$fBitsInt64_$cxor_closure:
         const GHC.Int.$fBitsInt64_$cxor_info;
 },
 GHC.Int.$fBitsInt64_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4pJR,
                       label: GHC.Int.$fBitsInt64_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pJR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pKc; else goto c4pKd;
       c4pKc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pKd: // global
           I64[Sp - 16] = block_c4pJO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pKj; else goto c4pJP;
       u4pKj: // global
           call _c4pJO(R1) args: 0, res: 0, upd: 0;
       c4pJP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pJO() //  [R1]
         { info_tbl: [(c4pJO,
                       label: block_c4pJO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pJO: // global
           I64[Sp] = block_c4pJU_info;
           _s4l7K::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7K::I64;
           if (R1 & 7 != 0) goto u4pKi; else goto c4pJV;
       u4pKi: // global
           call _c4pJU(R1) args: 0, res: 0, upd: 0;
       c4pJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pJU() //  [R1]
         { info_tbl: [(c4pJU,
                       label: block_c4pJU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pJU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pKh; else goto c4pKg;
       c4pKh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pKg: // global
           _s4l7Q::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7Q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.612706737 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.|._closure" {
     GHC.Int.$fBitsInt64_$c.|._closure:
         const GHC.Int.$fBitsInt64_$c.|._info;
 },
 GHC.Int.$fBitsInt64_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4pKr,
                       label: GHC.Int.$fBitsInt64_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pKr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pKM; else goto c4pKN;
       c4pKM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pKN: // global
           I64[Sp - 16] = block_c4pKo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pKT; else goto c4pKp;
       u4pKT: // global
           call _c4pKo(R1) args: 0, res: 0, upd: 0;
       c4pKp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pKo() //  [R1]
         { info_tbl: [(c4pKo,
                       label: block_c4pKo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pKo: // global
           I64[Sp] = block_c4pKu_info;
           _s4l7U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7U::I64;
           if (R1 & 7 != 0) goto u4pKS; else goto c4pKv;
       u4pKS: // global
           call _c4pKu(R1) args: 0, res: 0, upd: 0;
       c4pKv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pKu() //  [R1]
         { info_tbl: [(c4pKu,
                       label: block_c4pKu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pKu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pKR; else goto c4pKQ;
       c4pKR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pKQ: // global
           _s4l80::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l80::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.617472452 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.&._closure" {
     GHC.Int.$fBitsInt64_$c.&._closure:
         const GHC.Int.$fBitsInt64_$c.&._info;
 },
 GHC.Int.$fBitsInt64_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4pL1,
                       label: GHC.Int.$fBitsInt64_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pL1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pLm; else goto c4pLn;
       c4pLm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pLn: // global
           I64[Sp - 16] = block_c4pKY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pLt; else goto c4pKZ;
       u4pLt: // global
           call _c4pKY(R1) args: 0, res: 0, upd: 0;
       c4pKZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pKY() //  [R1]
         { info_tbl: [(c4pKY,
                       label: block_c4pKY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pKY: // global
           I64[Sp] = block_c4pL4_info;
           _s4l84::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l84::I64;
           if (R1 & 7 != 0) goto u4pLs; else goto c4pL5;
       u4pLs: // global
           call _c4pL4(R1) args: 0, res: 0, upd: 0;
       c4pL5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pL4() //  [R1]
         { info_tbl: [(c4pL4,
                       label: block_c4pL4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pL4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pLr; else goto c4pLq;
       c4pLr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pLq: // global
           _s4l8a::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l8a::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.619977779 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4pLB,
                       label: GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pLB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pLP; else goto c4pLQ;
       c4pLP: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pLQ: // global
           I64[Sp - 8] = block_c4pLy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pLU; else goto c4pLz;
       u4pLU: // global
           call _c4pLy(R1) args: 0, res: 0, upd: 0;
       c4pLz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pLy() //  [R1]
         { info_tbl: [(c4pLy,
                       label: block_c4pLy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pLy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pLT; else goto c4pLS;
       c4pLT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pLS: // global
           (_c4pLH::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4pLH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.622517859 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4pM2,
                       label: GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pM2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pMg; else goto c4pMh;
       c4pMg: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pMh: // global
           I64[Sp - 8] = block_c4pLZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pMl; else goto c4pM0;
       u4pMl: // global
           call _c4pLZ(R1) args: 0, res: 0, upd: 0;
       c4pM0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pLZ() //  [R1]
         { info_tbl: [(c4pLZ,
                       label: block_c4pLZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pLZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pMk; else goto c4pMj;
       c4pMk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pMj: // global
           (_c4pM8::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4pM8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.624440614 UTC

[section ""data" . GHC.Int.$fBitsInt7_closure" {
     GHC.Int.$fBitsInt7_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.625534458 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt64_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt64_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4pMq,
                       label: GHC.Int.$fBitsInt64_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pMq: // global
           R1 = GHC.Int.$fBitsInt7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.627271155 UTC

[section ""data" . GHC.Int.eqInt8_closure" {
     GHC.Int.eqInt8_closure:
         const GHC.Int.eqInt8_info;
 },
 GHC.Int.eqInt8_entry() //  [R2, R3]
         { info_tbl: [(c4pMA,
                       label: GHC.Int.eqInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pMA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pME; else goto c4pMF;
       c4pME: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pMF: // global
           I64[Sp - 16] = block_c4pMx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pMO; else goto c4pMy;
       u4pMO: // global
           call _c4pMx(R1) args: 0, res: 0, upd: 0;
       c4pMy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pMx() //  [R1]
         { info_tbl: [(c4pMx,
                       label: block_c4pMx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pMx: // global
           I64[Sp] = block_c4pMD_info;
           _s4l8r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8r::I64;
           if (R1 & 7 != 0) goto u4pMN; else goto c4pMH;
       u4pMN: // global
           call _c4pMD(R1) args: 0, res: 0, upd: 0;
       c4pMH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pMD() //  [R1]
         { info_tbl: [(c4pMD,
                       label: block_c4pMD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pMD: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.628985067 UTC

[section ""data" . GHC.Int.$fEqInt8_closure" {
     GHC.Int.$fEqInt8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt8_closure+2;
         const GHC.Int.neInt8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.630499542 UTC

[section ""data" . GHC.Int.gtInt8_closure" {
     GHC.Int.gtInt8_closure:
         const GHC.Int.gtInt8_info;
 },
 GHC.Int.gtInt8_entry() //  [R2, R3]
         { info_tbl: [(c4pMW,
                       label: GHC.Int.gtInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pMW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pN0; else goto c4pN1;
       c4pN0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pN1: // global
           I64[Sp - 16] = block_c4pMT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pNa; else goto c4pMU;
       u4pNa: // global
           call _c4pMT(R1) args: 0, res: 0, upd: 0;
       c4pMU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pMT() //  [R1]
         { info_tbl: [(c4pMT,
                       label: block_c4pMT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pMT: // global
           I64[Sp] = block_c4pMZ_info;
           _s4l8y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8y::I64;
           if (R1 & 7 != 0) goto u4pN9; else goto c4pN3;
       u4pN9: // global
           call _c4pMZ(R1) args: 0, res: 0, upd: 0;
       c4pN3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pMZ() //  [R1]
         { info_tbl: [(c4pMZ,
                       label: block_c4pMZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pMZ: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.633512011 UTC

[section ""data" . GHC.Int.geInt8_closure" {
     GHC.Int.geInt8_closure:
         const GHC.Int.geInt8_info;
 },
 GHC.Int.geInt8_entry() //  [R2, R3]
         { info_tbl: [(c4pNi,
                       label: GHC.Int.geInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pNi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pNm; else goto c4pNn;
       c4pNm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pNn: // global
           I64[Sp - 16] = block_c4pNf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pNw; else goto c4pNg;
       u4pNw: // global
           call _c4pNf(R1) args: 0, res: 0, upd: 0;
       c4pNg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pNf() //  [R1]
         { info_tbl: [(c4pNf,
                       label: block_c4pNf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pNf: // global
           I64[Sp] = block_c4pNl_info;
           _s4l8F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8F::I64;
           if (R1 & 7 != 0) goto u4pNv; else goto c4pNp;
       u4pNv: // global
           call _c4pNl(R1) args: 0, res: 0, upd: 0;
       c4pNp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pNl() //  [R1]
         { info_tbl: [(c4pNl,
                       label: block_c4pNl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pNl: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.63621562 UTC

[section ""data" . GHC.Int.ltInt8_closure" {
     GHC.Int.ltInt8_closure:
         const GHC.Int.ltInt8_info;
 },
 GHC.Int.ltInt8_entry() //  [R2, R3]
         { info_tbl: [(c4pNE,
                       label: GHC.Int.ltInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pNE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pNI; else goto c4pNJ;
       c4pNI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pNJ: // global
           I64[Sp - 16] = block_c4pNB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pNS; else goto c4pNC;
       u4pNS: // global
           call _c4pNB(R1) args: 0, res: 0, upd: 0;
       c4pNC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pNB() //  [R1]
         { info_tbl: [(c4pNB,
                       label: block_c4pNB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pNB: // global
           I64[Sp] = block_c4pNH_info;
           _s4l8M::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8M::I64;
           if (R1 & 7 != 0) goto u4pNR; else goto c4pNL;
       u4pNR: // global
           call _c4pNH(R1) args: 0, res: 0, upd: 0;
       c4pNL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pNH() //  [R1]
         { info_tbl: [(c4pNH,
                       label: block_c4pNH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pNH: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.63866436 UTC

[section ""data" . GHC.Int.leInt8_closure" {
     GHC.Int.leInt8_closure:
         const GHC.Int.leInt8_info;
 },
 GHC.Int.leInt8_entry() //  [R2, R3]
         { info_tbl: [(c4pO0,
                       label: GHC.Int.leInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pO0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pO4; else goto c4pO5;
       c4pO4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pO5: // global
           I64[Sp - 16] = block_c4pNX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pOe; else goto c4pNY;
       u4pOe: // global
           call _c4pNX(R1) args: 0, res: 0, upd: 0;
       c4pNY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pNX() //  [R1]
         { info_tbl: [(c4pNX,
                       label: block_c4pNX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pNX: // global
           I64[Sp] = block_c4pO3_info;
           _s4l8T::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8T::I64;
           if (R1 & 7 != 0) goto u4pOd; else goto c4pO7;
       u4pOd: // global
           call _c4pO3(R1) args: 0, res: 0, upd: 0;
       c4pO7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pO3() //  [R1]
         { info_tbl: [(c4pO3,
                       label: block_c4pO3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pO3: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.641812552 UTC

[section ""data" . GHC.Int.$fOrdInt8_$ccompare_closure" {
     GHC.Int.$fOrdInt8_$ccompare_closure:
         const GHC.Int.$fOrdInt8_$ccompare_info;
 },
 GHC.Int.$fOrdInt8_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4pOm,
                       label: GHC.Int.$fOrdInt8_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pOm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pOq; else goto c4pOr;
       c4pOq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pOr: // global
           I64[Sp - 16] = block_c4pOj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pOK; else goto c4pOk;
       u4pOK: // global
           call _c4pOj(R1) args: 0, res: 0, upd: 0;
       c4pOk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pOj() //  [R1]
         { info_tbl: [(c4pOj,
                       label: block_c4pOj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pOj: // global
           I64[Sp] = block_c4pOp_info;
           _s4l90::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l90::I64;
           if (R1 & 7 != 0) goto u4pOJ; else goto c4pOt;
       u4pOJ: // global
           call _c4pOp(R1) args: 0, res: 0, upd: 0;
       c4pOt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pOp() //  [R1]
         { info_tbl: [(c4pOp,
                       label: block_c4pOp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pOp: // global
           _s4l90::I64 = I64[Sp + 8];
           _s4l92::I64 = I64[R1 + 7];
           if (_s4l90::I64 == _s4l92::I64) goto c4pOI; else goto c4pOH;
       c4pOI: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pOH: // global
           if (%MO_S_Gt_W64(_s4l90::I64,
                            _s4l92::I64)) goto c4pOE; else goto c4pOF;
       c4pOE: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pOF: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.644947153 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmax_closure" {
     GHC.Int.$fOrdInt8_$cmax_closure:
         const GHC.Int.$fOrdInt8_$cmax_info;
 },
 GHC.Int.$fOrdInt8_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4pOS,
                       label: GHC.Int.$fOrdInt8_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pOS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pOW; else goto c4pOX;
       c4pOW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pOX: // global
           I64[Sp - 16] = block_c4pOP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pPa; else goto c4pOQ;
       u4pPa: // global
           call _c4pOP(R1) args: 0, res: 0, upd: 0;
       c4pOQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pOP() //  [R1]
         { info_tbl: [(c4pOP,
                       label: block_c4pOP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pOP: // global
           I64[Sp - 8] = block_c4pOV_info;
           _s4l97::P64 = R1;
           _s4l98::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l98::I64;
           P64[Sp + 8] = _s4l97::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pP9; else goto c4pOZ;
       u4pP9: // global
           call _c4pOV(R1) args: 0, res: 0, upd: 0;
       c4pOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pOV() //  [R1]
         { info_tbl: [(c4pOV,
                       label: block_c4pOV_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pOV: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4pP7; else goto c4pP8;
       c4pP7: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4pP8: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.652456807 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmin_closure" {
     GHC.Int.$fOrdInt8_$cmin_closure:
         const GHC.Int.$fOrdInt8_$cmin_info;
 },
 GHC.Int.$fOrdInt8_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4pPi,
                       label: GHC.Int.$fOrdInt8_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pPi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pPm; else goto c4pPn;
       c4pPm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pPn: // global
           I64[Sp - 16] = block_c4pPf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pPA; else goto c4pPg;
       u4pPA: // global
           call _c4pPf(R1) args: 0, res: 0, upd: 0;
       c4pPg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pPf() //  [R1]
         { info_tbl: [(c4pPf,
                       label: block_c4pPf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pPf: // global
           I64[Sp - 8] = block_c4pPl_info;
           _s4l9e::P64 = R1;
           _s4l9f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l9f::I64;
           P64[Sp + 8] = _s4l9e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pPz; else goto c4pPp;
       u4pPz: // global
           call _c4pPl(R1) args: 0, res: 0, upd: 0;
       c4pPp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pPl() //  [R1]
         { info_tbl: [(c4pPl,
                       label: block_c4pPl_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pPl: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4pPx; else goto c4pPy;
       c4pPx: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4pPy: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.656362985 UTC

[section ""data" . GHC.Int.$fOrdInt8_closure" {
     GHC.Int.$fOrdInt8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fOrdInt8_$ccompare_closure+2;
         const GHC.Int.ltInt8_closure+2;
         const GHC.Int.leInt8_closure+2;
         const GHC.Int.gtInt8_closure+2;
         const GHC.Int.geInt8_closure+2;
         const GHC.Int.$fOrdInt8_$cmax_closure+2;
         const GHC.Int.$fOrdInt8_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.658306414 UTC

[section ""data" . GHC.Int.$fIxInt8_$cinRange_closure" {
     GHC.Int.$fIxInt8_$cinRange_closure:
         const GHC.Int.$fIxInt8_$cinRange_info;
 },
 GHC.Int.$fIxInt8_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4pPI,
                       label: GHC.Int.$fIxInt8_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pPI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pPR; else goto c4pPS;
       c4pPR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pPS: // global
           I64[Sp - 16] = block_c4pPF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pQf; else goto c4pPG;
       u4pQf: // global
           call _c4pPF(R1) args: 0, res: 0, upd: 0;
       c4pPG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pPF() //  [R1]
         { info_tbl: [(c4pPF,
                       label: block_c4pPF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pPF: // global
           I64[Sp - 8] = block_c4pPL_info;
           _s4l9n::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4l9n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pQe; else goto c4pPM;
       u4pQe: // global
           call _c4pPL(R1) args: 0, res: 0, upd: 0;
       c4pPM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pPL() //  [R1]
         { info_tbl: [(c4pPL,
                       label: block_c4pPL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pPL: // global
           I64[Sp] = block_c4pPQ_info;
           _s4l9p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4l9p::I64;
           if (R1 & 7 != 0) goto u4pQg; else goto c4pPV;
       u4pQg: // global
           call _c4pPQ(R1) args: 0, res: 0, upd: 0;
       c4pPV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pPQ() //  [R1]
         { info_tbl: [(c4pPQ,
                       label: block_c4pPQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pPQ: // global
           _s4l9r::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4l9r::I64)) goto c4pQ3; else goto c4pQ7;
       c4pQ3: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pQ7: // global
           _s4l9n::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4pQ6_info;
           R1 = _s4l9n::P64;
           I64[Sp + 16] = _s4l9r::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4pQh; else goto c4pQ8;
       u4pQh: // global
           call _c4pQ6(R1) args: 0, res: 0, upd: 0;
       c4pQ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pQ6() //  [R1]
         { info_tbl: [(c4pQ6,
                       label: block_c4pQ6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pQ6: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.661556417 UTC

[section ""data" . GHC.Int.$fNumInt7_closure" {
     GHC.Int.$fNumInt7_closure:
         const GHC.Int.I8#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.662536663 UTC

[section ""data" . GHC.Int.$fNumInt8_$csignum_closure" {
     GHC.Int.$fNumInt8_$csignum_closure:
         const GHC.Int.$fNumInt8_$csignum_info;
 },
 GHC.Int.$fNumInt8_$csignum_entry() //  [R2]
         { info_tbl: [(c4pQp,
                       label: GHC.Int.$fNumInt8_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pQp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pQq; else goto c4pQr;
       c4pQq: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pQr: // global
           I64[Sp - 8] = block_c4pQm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pQF; else goto c4pQn;
       u4pQF: // global
           call _c4pQm(R1) args: 0, res: 0, upd: 0;
       c4pQn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pQm() //  [R1]
         { info_tbl: [(c4pQm,
                       label: block_c4pQm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pQm: // global
           _s4l9y::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4l9y::I64, 0)) goto c4pQD; else goto c4pQE;
       c4pQD: // global
           if (_s4l9y::I64 == 0) goto c4pQB; else goto c4pQA;
       c4pQB: // global
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pQA: // global
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pQE: // global
           R1 = GHC.Int.$fNumInt7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.664074267 UTC

[section ""data" . GHC.Int.$fNumInt8_$cabs_closure" {
     GHC.Int.$fNumInt8_$cabs_closure:
         const GHC.Int.$fNumInt8_$cabs_info;
 },
 GHC.Int.$fNumInt8_$cabs_entry() //  [R2]
         { info_tbl: [(c4pQN,
                       label: GHC.Int.$fNumInt8_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pQN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pQO; else goto c4pQP;
       c4pQO: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pQP: // global
           I64[Sp - 8] = block_c4pQK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pR8; else goto c4pQL;
       u4pR8: // global
           call _c4pQK(R1) args: 0, res: 0, upd: 0;
       c4pQL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pQK() //  [R1]
         { info_tbl: [(c4pQK,
                       label: block_c4pQK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pQK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pQU; else goto c4pQT;
       c4pQU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pQT: // global
           _s4l9D::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l9D::I64, 0)) goto c4pR6; else goto c4pR7;
       c4pR6: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-_s4l9D::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pR7: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.665396978 UTC

[section ""data" . GHC.Int.$fNumInt8_closure" {
     GHC.Int.$fNumInt8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt8_$c+_closure+2;
         const GHC.Int.$fNumInt8_$c-_closure+2;
         const GHC.Int.$fNumInt8_$c*_closure+2;
         const GHC.Int.$fNumInt8_$cnegate_closure+1;
         const GHC.Int.$fNumInt8_$cabs_closure+1;
         const GHC.Int.$fNumInt8_$csignum_closure+1;
         const GHC.Int.$fNumInt8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.666151111 UTC

[section ""data" . GHC.Int.$fBitsInt12_closure" {
     GHC.Int.$fBitsInt12_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt11_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.667026459 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt8_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4pRd,
                       label: GHC.Int.$fBitsInt8_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pRd: // global
           R1 = GHC.Int.$fBitsInt12_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.668181877 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbit_closure" {
     GHC.Int.$fBitsInt8_$cbit_closure:
         const GHC.Int.$fBitsInt8_$cbit_info;
 },
 GHC.Int.$fBitsInt8_$cbit_entry() //  [R2]
         { info_tbl: [(c4pRn,
                       label: GHC.Int.$fBitsInt8_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pRn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pRo; else goto c4pRp;
       c4pRo: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pRp: // global
           I64[Sp - 8] = block_c4pRk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pRI; else goto c4pRl;
       u4pRI: // global
           call _c4pRk(R1) args: 0, res: 0, upd: 0;
       c4pRl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pRk() //  [R1]
         { info_tbl: [(c4pRk,
                       label: block_c4pRk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pRk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pRu; else goto c4pRt;
       c4pRu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pRt: // global
           _s4l9K::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l9K::I64, 64)) goto c4pRG; else goto c4pRH;
       c4pRG: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4l9K::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pRH: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.670005434 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ctestBit_closure" {
     GHC.Int.$fBitsInt8_$ctestBit_closure:
         const GHC.Int.$fBitsInt8_$ctestBit_info;
 },
 GHC.Int.$fBitsInt8_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4pRQ,
                       label: GHC.Int.$fBitsInt8_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pRQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pRU; else goto c4pRV;
       c4pRU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pRV: // global
           I64[Sp - 16] = block_c4pRN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pSD; else goto c4pRO;
       u4pSD: // global
           call _c4pRN(R1) args: 0, res: 0, upd: 0;
       c4pRO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pRN() //  [R1]
         { info_tbl: [(c4pRN,
                       label: block_c4pRN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pRN: // global
           I64[Sp] = block_c4pRT_info;
           _s4l9R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l9R::I64;
           if (R1 & 7 != 0) goto u4pSC; else goto c4pRX;
       u4pSC: // global
           call _c4pRT(R1) args: 0, res: 0, upd: 0;
       c4pRX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pRT() //  [R1]
         { info_tbl: [(c4pRT,
                       label: block_c4pRT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pRT: // global
           _s4l9T::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4l9T::I64, 64)) goto c4pSB; else goto c4pSA;
       c4pSA: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4l9T::I64)) == 0) goto c4pSB; else goto c4pSp;
       c4pSB: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pSp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.672158912 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateR_closure" {
     GHC.Int.$fBitsInt8_$crotateR_closure:
         const GHC.Int.$fBitsInt8_$crotateR_info;
 },
 GHC.Int.$fBitsInt8_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4pSL,
                       label: GHC.Int.$fBitsInt8_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pSL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pSP; else goto c4pSQ;
       c4pSP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pSQ: // global
           I64[Sp - 16] = block_c4pSI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pTP; else goto c4pSJ;
       u4pTP: // global
           call _c4pSI(R1) args: 0, res: 0, upd: 0;
       c4pSJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pSI() //  [R1]
         { info_tbl: [(c4pSI,
                       label: block_c4pSI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pSI: // global
           I64[Sp - 8] = block_c4pSO_info;
           _s4la3::P64 = R1;
           _s4la4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4la4::I64;
           P64[Sp + 8] = _s4la3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pTO; else goto c4pSS;
       u4pTO: // global
           call _c4pSO(R1) args: 0, res: 0, upd: 0;
       c4pSS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pSO() //  [R1]
         { info_tbl: [(c4pSO,
                       label: block_c4pSO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pSO: // global
           _s4laa::I64 = -I64[R1 + 7] & 7;
           if (_s4laa::I64 != 0) goto u4pTM; else goto c4pTI;
       u4pTM: // global
           I64[Sp + 16] = _s4laa::I64;
           Sp = Sp + 8;
           call _c4pTa() args: 0, res: 0, upd: 0;
       c4pTI: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pTa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pTa: // global
           Hp = Hp + 16;
           _s4laa::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4pTF; else goto c4pTE;
       c4pTF: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4pT9_info;
           R1 = _s4laa::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4pTE: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4lab::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4lab::I64 << _s4laa::I64) | (_s4lab::I64 >> 8 - _s4laa::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4pT9() //  [R1]
         { info_tbl: [(c4pT9,
                       label: block_c4pT9_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pT9: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4pTa() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.674593954 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt8_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt8_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt8_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4pTZ,
                       label: GHC.Int.$fBitsInt8_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pTZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pU3; else goto c4pU4;
       c4pU3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pU4: // global
           I64[Sp - 16] = block_c4pTW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pUD; else goto c4pTX;
       u4pUD: // global
           call _c4pTW(R1) args: 0, res: 0, upd: 0;
       c4pTX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pTW() //  [R1]
         { info_tbl: [(c4pTW,
                       label: block_c4pTW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pTW: // global
           I64[Sp - 8] = block_c4pU2_info;
           _s4lal::P64 = R1;
           _s4lam::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lam::I64;
           P64[Sp + 8] = _s4lal::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pUC; else goto c4pU6;
       u4pUC: // global
           call _c4pU2(R1) args: 0, res: 0, upd: 0;
       c4pU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pU2() //  [R1]
         { info_tbl: [(c4pU2,
                       label: block_c4pU2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pU2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pUc; else goto c4pUb;
       c4pUc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pUb: // global
           _s4lao::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lao::I64, 64)) goto c4pUA; else goto c4pUB;
       c4pUA: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4lao::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pUB: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.676641574 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cclearBit_closure" {
     GHC.Int.$fBitsInt8_$cclearBit_closure:
         const GHC.Int.$fBitsInt8_$cclearBit_info;
 },
 GHC.Int.$fBitsInt8_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4pUL,
                       label: GHC.Int.$fBitsInt8_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pUL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pUP; else goto c4pUQ;
       c4pUP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pUQ: // global
           I64[Sp - 16] = block_c4pUI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pVD; else goto c4pUJ;
       u4pVD: // global
           call _c4pUI(R1) args: 0, res: 0, upd: 0;
       c4pUJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pUI() //  [R1]
         { info_tbl: [(c4pUI,
                       label: block_c4pUI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pUI: // global
           I64[Sp] = block_c4pUO_info;
           _s4laz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4laz::I64;
           if (R1 & 7 != 0) goto u4pVC; else goto c4pUS;
       u4pVC: // global
           call _c4pUO(R1) args: 0, res: 0, upd: 0;
       c4pUS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pUO() //  [R1]
         { info_tbl: [(c4pUO,
                       label: block_c4pUO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pUO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pUY; else goto c4pUX;
       c4pUY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pUX: // global
           _s4laz::I64 = I64[Sp + 8];
           _s4laB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4laB::I64, 64)) goto c4pVp; else goto c4pVB;
       c4pVp: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4laz::I64 & ~%MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4laB::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pVB: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4laz::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.678908332 UTC

[section ""data" . GHC.Int.$fBitsInt8_$csetBit_closure" {
     GHC.Int.$fBitsInt8_$csetBit_closure:
         const GHC.Int.$fBitsInt8_$csetBit_info;
 },
 GHC.Int.$fBitsInt8_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4pVL,
                       label: GHC.Int.$fBitsInt8_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pVL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pVP; else goto c4pVQ;
       c4pVP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pVQ: // global
           I64[Sp - 16] = block_c4pVI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pWp; else goto c4pVJ;
       u4pWp: // global
           call _c4pVI(R1) args: 0, res: 0, upd: 0;
       c4pVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pVI() //  [R1]
         { info_tbl: [(c4pVI,
                       label: block_c4pVI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pVI: // global
           I64[Sp - 8] = block_c4pVO_info;
           _s4laP::P64 = R1;
           _s4laQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4laQ::I64;
           P64[Sp + 8] = _s4laP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pWo; else goto c4pVS;
       u4pWo: // global
           call _c4pVO(R1) args: 0, res: 0, upd: 0;
       c4pVS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pVO() //  [R1]
         { info_tbl: [(c4pVO,
                       label: block_c4pVO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pVO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pVY; else goto c4pVX;
       c4pVY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pVX: // global
           _s4laS::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4laS::I64, 64)) goto c4pWm; else goto c4pWn;
       c4pWm: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4laS::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pWn: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.68069825 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateL_closure" {
     GHC.Int.$fBitsInt8_$crotateL_closure:
         const GHC.Int.$fBitsInt8_$crotateL_info;
 },
 GHC.Int.$fBitsInt8_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4pWu,
                       label: GHC.Int.$fBitsInt8_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pWu: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt8_$crotate_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.682563725 UTC

[section ""data" . GHC.Int.$fBitsInt8_closure" {
     GHC.Int.$fBitsInt8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fBitsInt8_$c.&._closure+2;
         const GHC.Int.$fBitsInt8_$c.|._closure+2;
         const GHC.Int.$fBitsInt8_$cxor_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt8_$cshift_closure+2;
         const GHC.Int.$fBitsInt8_$crotate_closure+2;
         const GHC.Int.$fBitsInt13_closure+1;
         const GHC.Int.$fBitsInt8_$cbit_closure+1;
         const GHC.Int.$fBitsInt8_$csetBit_closure+2;
         const GHC.Int.$fBitsInt8_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt8_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt8_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt8_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt8_$crotateL_closure+2;
         const GHC.Int.$fBitsInt8_$crotateR_closure+2;
         const GHC.Int.$fBitsInt8_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.683716383 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_closure" {
     GHC.Int.$fFiniteBitsInt8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt8_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.686040937 UTC

[section ""data" . GHC.Int.$fReadInt8_go_closure" {
     GHC.Int.$fReadInt8_go_closure:
         const GHC.Int.$fReadInt8_go_info;
 },
 sat_s4lbc_entry() //  [R1]
         { info_tbl: [(c4pWQ,
                       label: sat_s4lbc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pWQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pWR; else goto c4pWS;
       c4pWR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4pWS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lba_entry() //  [R1]
         { info_tbl: [(c4pX0,
                       label: sat_s4lba_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pX0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4pX7; else goto c4pX8;
       c4pX7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4pX8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4pWX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4pXc; else goto c4pWY;
       u4pXc: // global
           call _c4pWX(R1) args: 0, res: 0, upd: 0;
       c4pWY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4pWX() //  [R1]
         { info_tbl: [(c4pWX,
                       label: block_c4pWX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pWX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pXb; else goto c4pXa;
       c4pXb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4pXa: // global
           _s4lb9::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4lb9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt8_go_entry() //  [R2]
         { info_tbl: [(c4pXh,
                       label: GHC.Int.$fReadInt8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pXh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pXi; else goto c4pXj;
       c4pXi: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4pXj: // global
           I64[Sp - 8] = block_c4pWB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pXt; else goto c4pWC;
       u4pXt: // global
           call _c4pWB(R1) args: 0, res: 0, upd: 0;
       c4pWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pWB() //  [R1]
         { info_tbl: [(c4pWB,
                       label: block_c4pWB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pWB: // global
           if (R1 & 7 == 1) goto c4pXe; else goto c4pXf;
       c4pXe: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pXf: // global
           I64[Sp - 8] = block_c4pWH_info;
           _s4lb3::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lb3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4pXs; else goto c4pWI;
       u4pXs: // global
           call _c4pWH(R1) args: 0, res: 0, upd: 0;
       c4pWI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pWH() //  [R1]
         { info_tbl: [(c4pWH,
                       label: block_c4pWH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pWH: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4pXr; else goto c4pXq;
       c4pXr: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pXq: // global
           _s4lb5::P64 = P64[R1 + 7];
           _s4lb6::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lbc_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lba_info;
           P64[Hp - 48] = _s4lb5::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lb6::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.688746264 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadsPrec_closure" {
     GHC.Int.$fReadInt8_$creadsPrec_closure:
         const GHC.Int.$fReadInt8_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4pXA,
                       label: GHC.Int.$fReadInt8_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pXA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pXE; else goto c4pXF;
       c4pXE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pXF: // global
           I64[Sp - 16] = block_c4pXy_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lbe::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lbe::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4pXy() //  [R1]
         { info_tbl: [(c4pXy,
                       label: block_c4pXy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pXy: // global
           _s4lbe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4pXD_info;
           R3 = _s4lbe::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4pXD() //  [R1]
         { info_tbl: [(c4pXD,
                       label: block_c4pXD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pXD: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.690517487 UTC

[section ""data" . GHC.Int.$fReadInt13_closure" {
     GHC.Int.$fReadInt13_closure:
         const GHC.Int.$fReadInt13_info;
         const 0;
 },
 sat_s4lbj_entry() //  [R1, R2]
         { info_tbl: [(c4pXU,
                       label: sat_s4lbj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pXU: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt8_$creadsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt13_entry() //  [R2, R3]
         { info_tbl: [(c4pY0,
                       label: GHC.Int.$fReadInt13_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pY0: // global
           _s4lbi::P64 = R3;
           _s4lbh::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4pY1; else goto c4pY2;
       c4pY2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pY4; else goto c4pY3;
       c4pY4: // global
           HpAlloc = 16;
           goto c4pY1;
       c4pY1: // global
           R3 = _s4lbi::P64;
           R2 = _s4lbh::P64;
           R1 = GHC.Int.$fReadInt13_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pY3: // global
           I64[Hp - 8] = sat_s4lbj_info;
           P64[Hp] = _s4lbh::P64;
           I64[Sp - 8] = block_c4pXX_info;
           R3 = _s4lbi::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4pXX() //  [R1]
         { info_tbl: [(c4pXX,
                       label: block_c4pXX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pXX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pY7; else goto c4pY6;
       c4pY7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pY6: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.691851649 UTC

[section ""data" . GHC.Int.$fIxInt1_closure" {
     GHC.Int.$fIxInt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.692617582 UTC

[section ""data" . GHC.Int.$fReadInt12_closure" {
     GHC.Int.$fReadInt12_closure:
         const GHC.Int.$fReadInt12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt12_entry() //  [R1]
         { info_tbl: [(c4pYe,
                       label: GHC.Int.$fReadInt12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pYe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4pYf; else goto c4pYg;
       c4pYf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4pYg: // global
           (_c4pYb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4pYb::I64 == 0) goto c4pYd; else goto c4pYc;
       c4pYd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4pYc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4pYb::I64;
           R2 = GHC.Int.$fReadInt13_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.694243284 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadList_closure" {
     GHC.Int.$fReadInt8_$creadList_closure:
         const GHC.Int.$fReadInt8_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadList_entry() //  [R2]
         { info_tbl: [(c4pYl,
                       label: GHC.Int.$fReadInt8_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pYl: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.695302121 UTC

[section ""data" . GHC.Int.$fReadInt11_closure" {
     GHC.Int.$fReadInt11_closure:
         const GHC.Int.$fReadInt11_info;
         const 0;
 },
 GHC.Int.$fReadInt11_entry() //  [R2, R3]
         { info_tbl: [(c4pYv,
                       label: GHC.Int.$fReadInt11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pYv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4pYw; else goto c4pYx;
       c4pYw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pYx: // global
           I64[Sp - 8] = block_c4pYs_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt8_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4pYs() //  [R1]
         { info_tbl: [(c4pYs,
                       label: block_c4pYs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pYs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pYA; else goto c4pYz;
       c4pYA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pYz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.696402701 UTC

[section ""data" . GHC.Int.$fReadInt8_closure" {
     GHC.Int.$fReadInt8_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt8_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt8_$creadList_closure+1;
         const GHC.Int.$fReadInt13_closure+2;
         const GHC.Int.$fReadInt11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.697798797 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquot_closure" {
     GHC.Int.$fIntegralInt8_$cquot_closure:
         const GHC.Int.$fIntegralInt8_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4pYI,
                       label: GHC.Int.$fIntegralInt8_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pYI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pYM; else goto c4pYN;
       c4pYM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pYN: // global
           I64[Sp - 16] = block_c4pYF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pZo; else goto c4pYG;
       u4pZo: // global
           call _c4pYF(R1) args: 0, res: 0, upd: 0;
       c4pYG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pYF() //  [R1]
         { info_tbl: [(c4pYF,
                       label: block_c4pYF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pYF: // global
           I64[Sp] = block_c4pYL_info;
           _s4lbt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbt::I64;
           if (R1 & 7 != 0) goto u4pZn; else goto c4pYP;
       u4pZn: // global
           call _c4pYL(R1) args: 0, res: 0, upd: 0;
       c4pYP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pYL() //  [R1]
         { info_tbl: [(c4pYL,
                       label: block_c4pYL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pYL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pYV; else goto c4pYU;
       c4pYV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pYU: // global
           _s4lbt::I64 = I64[Sp + 8];
           _s4lbw::I64 = I64[R1 + 7];
           if (_s4lbw::I64 != (-1)) goto u4pZm; else goto c4pZk;
       u4pZm: // global
           if (_s4lbw::I64 != 0) goto c4pZ6; else goto c4pZl;
       c4pZ6: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4lbt::I64,
                                                                          _s4lbw::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pZl: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4pZk: // global
           if (_s4lbt::I64 == (-128)) goto c4pZj; else goto c4pZi;
       c4pZj: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4pZi: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4lbt::I64,
                                                                          (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.699951556 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$crem_closure" {
     GHC.Int.$fIntegralInt8_$crem_closure:
         const GHC.Int.$fIntegralInt8_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4pZw,
                       label: GHC.Int.$fIntegralInt8_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pZw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4pZA; else goto c4pZB;
       c4pZA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4pZB: // global
           I64[Sp - 16] = block_c4pZt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4pZX; else goto c4pZu;
       u4pZX: // global
           call _c4pZt(R1) args: 0, res: 0, upd: 0;
       c4pZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pZt() //  [R1]
         { info_tbl: [(c4pZt,
                       label: block_c4pZt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pZt: // global
           I64[Sp] = block_c4pZz_info;
           _s4lbH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbH::I64;
           if (R1 & 7 != 0) goto u4pZW; else goto c4pZD;
       u4pZW: // global
           call _c4pZz(R1) args: 0, res: 0, upd: 0;
       c4pZD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4pZz() //  [R1]
         { info_tbl: [(c4pZz,
                       label: block_c4pZz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4pZz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4pZJ; else goto c4pZI;
       c4pZJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4pZI: // global
           _s4lbK::I64 = I64[R1 + 7];
           if (_s4lbK::I64 != 0) goto c4pZU; else goto c4pZV;
       c4pZU: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Rem_W64(I64[Sp + 8],
                                                                         _s4lbK::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4pZV: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.701883022 UTC

[section ""data" . GHC.Int.$w$cdiv3_closure" {
     GHC.Int.$w$cdiv3_closure:
         const GHC.Int.$w$cdiv3_info;
         const 0;
 },
 GHC.Int.$w$cdiv3_entry() //  [R2, R3]
         { info_tbl: [(c4q07,
                       label: GHC.Int.$w$cdiv3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q07: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4q08; else goto c4q09;
       c4q08: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4q09: // global
           if (R3 == (-1)) goto c4q05; else goto u4q0t;
       c4q05: // global
           if (R2 == (-128)) goto c4q0s; else goto c4q0q;
       c4q0s: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4q0q: // global
           I64[Sp - 8] = block_c4q0k_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4q0t: // global
           if (R3 == 0) goto c4q06; else goto c4q04;
       c4q06: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4q04: // global
           I64[Sp - 8] = block_c4q0b_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4q0k() //  [R1]
         { info_tbl: [(c4q0k,
                       label: block_c4q0k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q0k: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4q0b() //  [R1]
         { info_tbl: [(c4q0b,
                       label: block_c4q0b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q0b: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.703602621 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdiv_closure" {
     GHC.Int.$fIntegralInt8_$cdiv_closure:
         const GHC.Int.$fIntegralInt8_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4q0B,
                       label: GHC.Int.$fIntegralInt8_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q0B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4q0O; else goto c4q0P;
       c4q0O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4q0P: // global
           I64[Sp - 16] = block_c4q0y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4q0W; else goto c4q0z;
       u4q0W: // global
           call _c4q0y(R1) args: 0, res: 0, upd: 0;
       c4q0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q0y() //  [R1]
         { info_tbl: [(c4q0y,
                       label: block_c4q0y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q0y: // global
           I64[Sp] = block_c4q0E_info;
           _s4lbY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbY::I64;
           if (R1 & 7 != 0) goto u4q0V; else goto c4q0F;
       u4q0V: // global
           call _c4q0E(R1) args: 0, res: 0, upd: 0;
       c4q0F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q0E() //  [R1]
         { info_tbl: [(c4q0E,
                       label: block_c4q0E_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q0E: // global
           _s4lbY::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4q0J_info;
           R3 = I64[R1 + 7];
           R2 = _s4lbY::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4q0J() //  [R1]
         { info_tbl: [(c4q0J,
                       label: block_c4q0J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q0J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4q0U; else goto c4q0T;
       c4q0U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4q0T: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.705726333 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cmod_closure" {
     GHC.Int.$fIntegralInt8_$cmod_closure:
         const GHC.Int.$fIntegralInt8_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4q14,
                       label: GHC.Int.$fIntegralInt8_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q14: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4q18; else goto c4q19;
       c4q18: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4q19: // global
           I64[Sp - 16] = block_c4q11_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4q1x; else goto c4q12;
       u4q1x: // global
           call _c4q11(R1) args: 0, res: 0, upd: 0;
       c4q12: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q11() //  [R1]
         { info_tbl: [(c4q11,
                       label: block_c4q11_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q11: // global
           I64[Sp] = block_c4q17_info;
           _s4lc5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lc5::I64;
           if (R1 & 7 != 0) goto u4q1w; else goto c4q1b;
       u4q1w: // global
           call _c4q17(R1) args: 0, res: 0, upd: 0;
       c4q1b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q17() //  [R1]
         { info_tbl: [(c4q17,
                       label: block_c4q17_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q17: // global
           _s4lc8::I64 = I64[R1 + 7];
           if (_s4lc8::I64 != 0) goto c4q1r; else goto c4q1v;
       c4q1r: // global
           _s4lc5::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4q1i_info;
           R3 = _s4lc8::I64;
           R2 = _s4lc5::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4q1v: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4q1i() //  [R1]
         { info_tbl: [(c4q1i,
                       label: block_c4q1i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q1i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4q1u; else goto c4q1t;
       c4q1u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4q1t: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.708495595 UTC

[section ""data" . lvl6_r4kPx_closure" {
     lvl6_r4kPx_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt13_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.709894317 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquotRem_closure" {
     GHC.Int.$fIntegralInt8_$cquotRem_closure:
         const GHC.Int.$fIntegralInt8_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4q1F,
                       label: GHC.Int.$fIntegralInt8_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q1F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4q1J; else goto c4q1K;
       c4q1J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4q1K: // global
           I64[Sp - 16] = block_c4q1C_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4q2p; else goto c4q1D;
       u4q2p: // global
           call _c4q1C(R1) args: 0, res: 0, upd: 0;
       c4q1D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q1C() //  [R1]
         { info_tbl: [(c4q1C,
                       label: block_c4q1C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q1C: // global
           I64[Sp] = block_c4q1I_info;
           _s4lcf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lcf::I64;
           if (R1 & 7 != 0) goto u4q2o; else goto c4q1M;
       u4q2o: // global
           call _c4q1I(R1) args: 0, res: 0, upd: 0;
       c4q1M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q1I() //  [R1]
         { info_tbl: [(c4q1I,
                       label: block_c4q1I_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q1I: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4q1S; else goto c4q1R;
       c4q1S: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4q1R: // global
           _s4lcf::I64 = I64[Sp + 8];
           _s4lci::I64 = I64[R1 + 7];
           if (_s4lci::I64 != (-1)) goto u4q2n; else goto c4q2l;
       u4q2n: // global
           if (_s4lci::I64 != 0) goto c4q25; else goto c4q2m;
       c4q25: // global
           (_s4lck::I64, _s4lcl::I64) = call MO_S_QuotRem W64(_s4lcf::I64, _s4lci::I64);
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcl::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lck::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4q2m: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4q2l: // global
           if (_s4lcf::I64 == (-128)) goto c4q2k; else goto c4q2j;
       c4q2k: // global
           Hp = Hp - 56;
           R1 = lvl6_r4kPx_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4q2j: // global
           (_s4lcs::I64, _s4lct::I64) = call MO_S_QuotRem W64(_s4lcf::I64, (-1));
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lct::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcs::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.713071294 UTC

[section ""data" . GHC.Int.$w$cdivMod3_closure" {
     GHC.Int.$w$cdivMod3_closure:
         const GHC.Int.$w$cdivMod3_info;
         const 0;
 },
 GHC.Int.$w$cdivMod3_entry() //  [R2, R3]
         { info_tbl: [(c4q2y,
                       label: GHC.Int.$w$cdivMod3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q2y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4q2z; else goto c4q2A;
       c4q2z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4q2A: // global
           if (R3 == 0) goto c4q2x; else goto c4q2w;
       c4q2x: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4q2w: // global
           if (R3 == (-1)) goto c4q53; else goto u4q54;
       c4q53: // global
           if (R2 == (-128)) goto c4q52; else goto u4q55;
       c4q52: // global
           R2 = GHC.Int.$fBitsInt13_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4q55: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4q57;
       u4q54: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4q57;
       u4q57: // global
           call _c4q2F() args: 0, res: 0, upd: 0;
     }
 },
 _c4q2F() //  []
         { info_tbl: [(c4q2F,
                       label: block_c4q2F_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q2F: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4q2J; else goto c4q2I;
       c4q2J: // global
           HpAlloc = 32;
           I64[Sp] = block_c4q2F_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4q2I: // global
           _s4lcz::I64 = I64[Sp + 8];
           _s4lcB::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lcz::I64, 0)) goto c4q3C; else goto c4q4T;
       c4q3C: // global
           if (%MO_S_Ge_W64(_s4lcz::I64, 0)) goto c4q2Z; else goto c4q3A;
       c4q2Z: // global
           (_s4lcG::I64, _s4lcH::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcH::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcG::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4q3A: // global
           if (%MO_S_Le_W64(_s4lcB::I64, 0)) goto c4q3d; else goto c4q3z;
       c4q3d: // global
           (_s4lcO::I64, _s4lcP::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcP::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcO::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4q3z: // global
           (_s4lcW::I64, _s4lcX::I64) = call MO_S_QuotRem W64(_s4lcz::I64 + 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcX::I64 + _s4lcB::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcW::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4q4T: // global
           if (%MO_S_Ge_W64(_s4lcB::I64, 0)) goto c4q4w; else goto c4q4S;
       c4q4w: // global
           if (%MO_S_Ge_W64(_s4lcz::I64, 0)) goto c4q3T; else goto c4q4u;
       c4q3T: // global
           (_s4ld8::I64, _s4ld9::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ld9::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ld8::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4q4u: // global
           if (%MO_S_Le_W64(_s4lcB::I64, 0)) goto c4q47; else goto c4q4t;
       c4q47: // global
           (_s4ldg::I64, _s4ldh::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldh::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldg::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4q4t: // global
           (_s4ldo::I64, _s4ldp::I64) = call MO_S_QuotRem W64(_s4lcz::I64 + 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldp::I64 + _s4lcB::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldo::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4q4S: // global
           (_s4ldz::I64, _s4ldA::I64) = call MO_S_QuotRem W64(_s4lcz::I64 - 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldA::I64 + _s4lcB::I64 + 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldz::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.716102929 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdivMod_closure" {
     GHC.Int.$fIntegralInt8_$cdivMod_closure:
         const GHC.Int.$fIntegralInt8_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4q5f,
                       label: GHC.Int.$fIntegralInt8_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q5f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4q5q; else goto c4q5r;
       c4q5q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4q5r: // global
           I64[Sp - 16] = block_c4q5c_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4q5y; else goto c4q5d;
       u4q5y: // global
           call _c4q5c(R1) args: 0, res: 0, upd: 0;
       c4q5d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q5c() //  [R1]
         { info_tbl: [(c4q5c,
                       label: block_c4q5c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q5c: // global
           I64[Sp] = block_c4q5i_info;
           _s4ldO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ldO::I64;
           if (R1 & 7 != 0) goto u4q5x; else goto c4q5j;
       u4q5x: // global
           call _c4q5i(R1) args: 0, res: 0, upd: 0;
       c4q5j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q5i() //  [R1]
         { info_tbl: [(c4q5i,
                       label: block_c4q5i_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q5i: // global
           _s4ldO::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4q5n_info;
           R3 = I64[R1 + 7];
           R2 = _s4ldO::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4q5n() //  [R1, R2]
         { info_tbl: [(c4q5n,
                       label: block_c4q5n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q5n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4q5w; else goto c4q5v;
       c4q5w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4q5v: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.717783022 UTC

[section ""data" . sat_s4ldU_closure" {
     sat_s4ldU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.718369757 UTC

[section ""data" . sat_s4ldV_closure" {
     sat_s4ldV_closure:
         const :_con_info;
         const sat_s4ldU_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.719159858 UTC

[section ""data" . GHC.Int.$fRealInt1_closure" {
     GHC.Int.$fRealInt1_closure:
         const GHC.Int.$fRealInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fRealInt1_entry() //  [R1]
         { info_tbl: [(c4q5F,
                       label: GHC.Int.$fRealInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q5F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4q5G; else goto c4q5H;
       c4q5G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4q5H: // global
           (_c4q5C::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4q5C::I64 == 0) goto c4q5E; else goto c4q5D;
       c4q5E: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4q5D: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4q5C::I64;
           R3 = sat_s4ldV_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.720516958 UTC

[section ""data" . GHC.Int.$fRealInt8_$ctoRational_closure" {
     GHC.Int.$fRealInt8_$ctoRational_closure:
         const GHC.Int.$fRealInt8_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt8_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4q5P,
                       label: GHC.Int.$fRealInt8_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q5P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4q63; else goto c4q64;
       c4q63: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4q64: // global
           I64[Sp - 8] = block_c4q5M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4q6b; else goto c4q5N;
       u4q6b: // global
           call _c4q5M(R1) args: 0, res: 0, upd: 0;
       c4q5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q5M() //  [R1]
         { info_tbl: [(c4q5M,
                       label: block_c4q5M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q5M: // global
           I64[Sp] = block_c4q5S_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4q5S() //  [R1]
         { info_tbl: [(c4q5S,
                       label: block_c4q5S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q5S: // global
           I64[Sp] = block_c4q5W_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4q5W() //  [R1]
         { info_tbl: [(c4q5W,
                       label: block_c4q5W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q5W: // global
           I64[Sp] = block_c4q60_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4q60() //  [R1, R2]
         { info_tbl: [(c4q60,
                       label: block_c4q60_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q60: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4q6a; else goto c4q69;
       c4q6a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4q69: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.722369249 UTC

[section ""data" . GHC.Int.$fRealInt8_closure" {
     GHC.Int.$fRealInt8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt8_closure+1;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fRealInt8_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.723014102 UTC

[section ""data" . GHC.Int.$fIntegralInt8_closure" {
     GHC.Int.$fIntegralInt8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt8_closure+1;
         const GHC.Int.$fEnumInt8_closure+1;
         const GHC.Int.$fIntegralInt8_$cquot_closure+2;
         const GHC.Int.$fIntegralInt8_$crem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt8_$cmod_closure+2;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt8_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.724151095 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt8_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt8_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt8_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4q6j,
                       label: GHC.Int.$fIxInt8_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q6j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4q6A; else goto c4q6B;
       c4q6A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4q6B: // global
           I64[Sp - 16] = block_c4q6g_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4q6I; else goto c4q6h;
       u4q6I: // global
           call _c4q6g(R1) args: 0, res: 0, upd: 0;
       c4q6h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q6g() //  [R1]
         { info_tbl: [(c4q6g,
                       label: block_c4q6g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q6g: // global
           I64[Sp] = block_c4q6m_info;
           _s4le7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4le7::P64;
           if (R1 & 7 != 0) goto u4q6H; else goto c4q6n;
       u4q6H: // global
           call _c4q6m(R1) args: 0, res: 0, upd: 0;
       c4q6n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q6m() //  [R1]
         { info_tbl: [(c4q6m,
                       label: block_c4q6m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q6m: // global
           I64[Sp] = block_c4q6r_info;
           _s4lea::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lea::I64;
           if (R1 & 7 != 0) goto u4q6J; else goto c4q6s;
       u4q6J: // global
           call _c4q6r(R1) args: 0, res: 0, upd: 0;
       c4q6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q6r() //  [R1]
         { info_tbl: [(c4q6r,
                       label: block_c4q6r_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q6r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4q6G; else goto c4q6F;
       c4q6G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4q6F: // global
           _s4led::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4led::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.726088732 UTC

[section ""data" . GHC.Int.$fIxInt8_$crange_closure" {
     GHC.Int.$fIxInt8_$crange_closure:
         const GHC.Int.$fIxInt8_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$crange_entry() //  [R2]
         { info_tbl: [(c4q6R,
                       label: GHC.Int.$fIxInt8_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q6R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4q6S; else goto c4q6T;
       c4q6S: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4q6T: // global
           I64[Sp - 8] = block_c4q6O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4q6X; else goto c4q6P;
       u4q6X: // global
           call _c4q6O(R1) args: 0, res: 0, upd: 0;
       c4q6P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q6O() //  [R1]
         { info_tbl: [(c4q6O,
                       label: block_c4q6O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q6O: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_$cenumFromTo_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.727734643 UTC

[section ""data" . GHC.Int.$fIxInt8_$crangeSize_closure" {
     GHC.Int.$fIxInt8_$crangeSize_closure:
         const GHC.Int.$fIxInt8_$crangeSize_info;
 },
 GHC.Int.$fIxInt8_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4q75,
                       label: GHC.Int.$fIxInt8_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q75: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4q7e; else goto c4q7f;
       c4q7e: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4q7f: // global
           I64[Sp - 8] = block_c4q72_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4q7E; else goto c4q73;
       u4q7E: // global
           call _c4q72(R1) args: 0, res: 0, upd: 0;
       c4q73: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q72() //  [R1]
         { info_tbl: [(c4q72,
                       label: block_c4q72_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q72: // global
           I64[Sp - 8] = block_c4q78_info;
           _s4lel::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lel::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4q7D; else goto c4q79;
       u4q7D: // global
           call _c4q78(R1) args: 0, res: 0, upd: 0;
       c4q79: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q78() //  [R1]
         { info_tbl: [(c4q78,
                       label: block_c4q78_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q78: // global
           I64[Sp] = block_c4q7d_info;
           _s4len::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4len::I64;
           if (R1 & 7 != 0) goto u4q7F; else goto c4q7i;
       u4q7F: // global
           call _c4q7d(R1) args: 0, res: 0, upd: 0;
       c4q7i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q7d() //  [R1]
         { info_tbl: [(c4q7d,
                       label: block_c4q7d_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q7d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4q7o; else goto c4q7n;
       c4q7o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4q7n: // global
           _s4len::I64 = I64[Sp + 8];
           _s4lep::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4len::I64,
                            _s4lep::I64)) goto c4q7s; else goto c4q7C;
       c4q7s: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4q7C: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lep::I64 - _s4len::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.730963498 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt8_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt8_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4q7N,
                       label: GHC.Int.$fIxInt8_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q7N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4q87; else goto c4q88;
       c4q87: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4q88: // global
           I64[Sp - 8] = block_c4q7K_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4q8f; else goto c4q7L;
       u4q8f: // global
           call _c4q7K(R1) args: 0, res: 0, upd: 0;
       c4q7L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q7K() //  [R1]
         { info_tbl: [(c4q7K,
                       label: block_c4q7K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q7K: // global
           I64[Sp - 8] = block_c4q7Q_info;
           _s4lev::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lev::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4q8e; else goto c4q7R;
       u4q8e: // global
           call _c4q7Q(R1) args: 0, res: 0, upd: 0;
       c4q7R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q7Q() //  [R1]
         { info_tbl: [(c4q7Q,
                       label: block_c4q7Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q7Q: // global
           I64[Sp] = block_c4q7V_info;
           _s4ley::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ley::I64;
           if (R1 & 7 != 0) goto u4q8g; else goto c4q7W;
       u4q8g: // global
           call _c4q7V(R1) args: 0, res: 0, upd: 0;
       c4q7W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q7V() //  [R1]
         { info_tbl: [(c4q7V,
                       label: block_c4q7V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q7V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4q8d; else goto c4q8c;
       c4q8d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4q8c: // global
           _s4leC::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4leC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.733150805 UTC

[section ""data" . GHC.Int.$fIxInt8_$cindex_closure" {
     GHC.Int.$fIxInt8_$cindex_closure:
         const GHC.Int.$fIxInt8_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4q8o,
                       label: GHC.Int.$fIxInt8_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q8o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4q8x; else goto c4q8y;
       c4q8x: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4q8y: // global
           I64[Sp - 16] = block_c4q8l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4q97; else goto c4q8m;
       u4q97: // global
           call _c4q8l(R1) args: 0, res: 0, upd: 0;
       c4q8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q8l() //  [R1]
         { info_tbl: [(c4q8l,
                       label: block_c4q8l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q8l: // global
           I64[Sp - 8] = block_c4q8r_info;
           _s4leH::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4leH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4q96; else goto c4q8s;
       u4q96: // global
           call _c4q8r(R1) args: 0, res: 0, upd: 0;
       c4q8s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q8r() //  [R1]
         { info_tbl: [(c4q8r,
                       label: block_c4q8r_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q8r: // global
           I64[Sp] = block_c4q8w_info;
           _s4leJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4leJ::I64;
           if (R1 & 7 != 0) goto u4q98; else goto c4q8B;
       u4q98: // global
           call _c4q8w(R1) args: 0, res: 0, upd: 0;
       c4q8B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q8w() //  [R1]
         { info_tbl: [(c4q8w,
                       label: block_c4q8w_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q8w: // global
           _s4leL::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4leL::I64)) goto c4q8J; else goto c4q8N;
       c4q8J: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4q8N: // global
           I64[Sp] = block_c4q8M_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4leL::I64;
           if (R1 & 7 != 0) goto u4q99; else goto c4q8O;
       u4q99: // global
           call _c4q8M(R1) args: 0, res: 0, upd: 0;
       c4q8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q8M() //  [R1]
         { info_tbl: [(c4q8M,
                       label: block_c4q8M_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q8M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4q8U; else goto c4q8T;
       c4q8U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4q8T: // global
           _s4leL::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4leL::I64,
                            I64[R1 + 7])) goto c4q8Y; else goto c4q95;
       c4q8Y: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4q95: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4leL::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.735498186 UTC

[section ""data" . GHC.Int.$fIxInt8_closure" {
     GHC.Int.$fIxInt8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fIxInt8_$crange_closure+1;
         const GHC.Int.$fIxInt8_$cindex_closure+2;
         const GHC.Int.$fIxInt8_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt8_$cinRange_closure+2;
         const GHC.Int.$fIxInt8_$crangeSize_closure+1;
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.736483988 UTC

[section ""data" . GHC.Int.eqInt16_closure" {
     GHC.Int.eqInt16_closure:
         const GHC.Int.eqInt16_info;
 },
 GHC.Int.eqInt16_entry() //  [R2, R3]
         { info_tbl: [(c4q9h,
                       label: GHC.Int.eqInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q9h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4q9l; else goto c4q9m;
       c4q9l: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4q9m: // global
           I64[Sp - 16] = block_c4q9e_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4q9v; else goto c4q9f;
       u4q9v: // global
           call _c4q9e(R1) args: 0, res: 0, upd: 0;
       c4q9f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q9e() //  [R1]
         { info_tbl: [(c4q9e,
                       label: block_c4q9e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q9e: // global
           I64[Sp] = block_c4q9k_info;
           _s4leU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4leU::I64;
           if (R1 & 7 != 0) goto u4q9u; else goto c4q9o;
       u4q9u: // global
           call _c4q9k(R1) args: 0, res: 0, upd: 0;
       c4q9o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q9k() //  [R1]
         { info_tbl: [(c4q9k,
                       label: block_c4q9k_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q9k: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.737708578 UTC

[section ""data" . GHC.Int.$fEqInt16_closure" {
     GHC.Int.$fEqInt16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt16_closure+2;
         const GHC.Int.neInt16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.738613191 UTC

[section ""data" . GHC.Int.gtInt16_closure" {
     GHC.Int.gtInt16_closure:
         const GHC.Int.gtInt16_info;
 },
 GHC.Int.gtInt16_entry() //  [R2, R3]
         { info_tbl: [(c4q9D,
                       label: GHC.Int.gtInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q9D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4q9H; else goto c4q9I;
       c4q9H: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4q9I: // global
           I64[Sp - 16] = block_c4q9A_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4q9R; else goto c4q9B;
       u4q9R: // global
           call _c4q9A(R1) args: 0, res: 0, upd: 0;
       c4q9B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q9A() //  [R1]
         { info_tbl: [(c4q9A,
                       label: block_c4q9A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q9A: // global
           I64[Sp] = block_c4q9G_info;
           _s4lf1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lf1::I64;
           if (R1 & 7 != 0) goto u4q9Q; else goto c4q9K;
       u4q9Q: // global
           call _c4q9G(R1) args: 0, res: 0, upd: 0;
       c4q9K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q9G() //  [R1]
         { info_tbl: [(c4q9G,
                       label: block_c4q9G_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q9G: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.740238379 UTC

[section ""data" . GHC.Int.geInt16_closure" {
     GHC.Int.geInt16_closure:
         const GHC.Int.geInt16_info;
 },
 GHC.Int.geInt16_entry() //  [R2, R3]
         { info_tbl: [(c4q9Z,
                       label: GHC.Int.geInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q9Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qa3; else goto c4qa4;
       c4qa3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qa4: // global
           I64[Sp - 16] = block_c4q9W_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qad; else goto c4q9X;
       u4qad: // global
           call _c4q9W(R1) args: 0, res: 0, upd: 0;
       c4q9X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4q9W() //  [R1]
         { info_tbl: [(c4q9W,
                       label: block_c4q9W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4q9W: // global
           I64[Sp] = block_c4qa2_info;
           _s4lf8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lf8::I64;
           if (R1 & 7 != 0) goto u4qac; else goto c4qa6;
       u4qac: // global
           call _c4qa2(R1) args: 0, res: 0, upd: 0;
       c4qa6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qa2() //  [R1]
         { info_tbl: [(c4qa2,
                       label: block_c4qa2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qa2: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.741917861 UTC

[section ""data" . GHC.Int.ltInt16_closure" {
     GHC.Int.ltInt16_closure:
         const GHC.Int.ltInt16_info;
 },
 GHC.Int.ltInt16_entry() //  [R2, R3]
         { info_tbl: [(c4qal,
                       label: GHC.Int.ltInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qal: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qap; else goto c4qaq;
       c4qap: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qaq: // global
           I64[Sp - 16] = block_c4qai_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qaz; else goto c4qaj;
       u4qaz: // global
           call _c4qai(R1) args: 0, res: 0, upd: 0;
       c4qaj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qai() //  [R1]
         { info_tbl: [(c4qai,
                       label: block_c4qai_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qai: // global
           I64[Sp] = block_c4qao_info;
           _s4lff::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lff::I64;
           if (R1 & 7 != 0) goto u4qay; else goto c4qas;
       u4qay: // global
           call _c4qao(R1) args: 0, res: 0, upd: 0;
       c4qas: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qao() //  [R1]
         { info_tbl: [(c4qao,
                       label: block_c4qao_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qao: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.743446982 UTC

[section ""data" . GHC.Int.leInt16_closure" {
     GHC.Int.leInt16_closure:
         const GHC.Int.leInt16_info;
 },
 GHC.Int.leInt16_entry() //  [R2, R3]
         { info_tbl: [(c4qaH,
                       label: GHC.Int.leInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qaH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qaL; else goto c4qaM;
       c4qaL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qaM: // global
           I64[Sp - 16] = block_c4qaE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qaV; else goto c4qaF;
       u4qaV: // global
           call _c4qaE(R1) args: 0, res: 0, upd: 0;
       c4qaF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qaE() //  [R1]
         { info_tbl: [(c4qaE,
                       label: block_c4qaE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qaE: // global
           I64[Sp] = block_c4qaK_info;
           _s4lfm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lfm::I64;
           if (R1 & 7 != 0) goto u4qaU; else goto c4qaO;
       u4qaU: // global
           call _c4qaK(R1) args: 0, res: 0, upd: 0;
       c4qaO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qaK() //  [R1]
         { info_tbl: [(c4qaK,
                       label: block_c4qaK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qaK: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.745100613 UTC

[section ""data" . GHC.Int.$fOrdInt16_$ccompare_closure" {
     GHC.Int.$fOrdInt16_$ccompare_closure:
         const GHC.Int.$fOrdInt16_$ccompare_info;
 },
 GHC.Int.$fOrdInt16_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4qb3,
                       label: GHC.Int.$fOrdInt16_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qb3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qb7; else goto c4qb8;
       c4qb7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qb8: // global
           I64[Sp - 16] = block_c4qb0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qbr; else goto c4qb1;
       u4qbr: // global
           call _c4qb0(R1) args: 0, res: 0, upd: 0;
       c4qb1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qb0() //  [R1]
         { info_tbl: [(c4qb0,
                       label: block_c4qb0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qb0: // global
           I64[Sp] = block_c4qb6_info;
           _s4lft::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lft::I64;
           if (R1 & 7 != 0) goto u4qbq; else goto c4qba;
       u4qbq: // global
           call _c4qb6(R1) args: 0, res: 0, upd: 0;
       c4qba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qb6() //  [R1]
         { info_tbl: [(c4qb6,
                       label: block_c4qb6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qb6: // global
           _s4lft::I64 = I64[Sp + 8];
           _s4lfv::I64 = I64[R1 + 7];
           if (_s4lft::I64 == _s4lfv::I64) goto c4qbp; else goto c4qbo;
       c4qbp: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qbo: // global
           if (%MO_S_Gt_W64(_s4lft::I64,
                            _s4lfv::I64)) goto c4qbl; else goto c4qbm;
       c4qbl: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qbm: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.747057287 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmax_closure" {
     GHC.Int.$fOrdInt16_$cmax_closure:
         const GHC.Int.$fOrdInt16_$cmax_info;
 },
 GHC.Int.$fOrdInt16_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4qbz,
                       label: GHC.Int.$fOrdInt16_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qbz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qbD; else goto c4qbE;
       c4qbD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qbE: // global
           I64[Sp - 16] = block_c4qbw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qbR; else goto c4qbx;
       u4qbR: // global
           call _c4qbw(R1) args: 0, res: 0, upd: 0;
       c4qbx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qbw() //  [R1]
         { info_tbl: [(c4qbw,
                       label: block_c4qbw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qbw: // global
           I64[Sp - 8] = block_c4qbC_info;
           _s4lfA::P64 = R1;
           _s4lfB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lfB::I64;
           P64[Sp + 8] = _s4lfA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qbQ; else goto c4qbG;
       u4qbQ: // global
           call _c4qbC(R1) args: 0, res: 0, upd: 0;
       c4qbG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qbC() //  [R1]
         { info_tbl: [(c4qbC,
                       label: block_c4qbC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qbC: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4qbO; else goto c4qbP;
       c4qbO: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4qbP: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.7488119 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmin_closure" {
     GHC.Int.$fOrdInt16_$cmin_closure:
         const GHC.Int.$fOrdInt16_$cmin_info;
 },
 GHC.Int.$fOrdInt16_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4qbZ,
                       label: GHC.Int.$fOrdInt16_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qbZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qc3; else goto c4qc4;
       c4qc3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qc4: // global
           I64[Sp - 16] = block_c4qbW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qch; else goto c4qbX;
       u4qch: // global
           call _c4qbW(R1) args: 0, res: 0, upd: 0;
       c4qbX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qbW() //  [R1]
         { info_tbl: [(c4qbW,
                       label: block_c4qbW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qbW: // global
           I64[Sp - 8] = block_c4qc2_info;
           _s4lfH::P64 = R1;
           _s4lfI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lfI::I64;
           P64[Sp + 8] = _s4lfH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qcg; else goto c4qc6;
       u4qcg: // global
           call _c4qc2(R1) args: 0, res: 0, upd: 0;
       c4qc6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qc2() //  [R1]
         { info_tbl: [(c4qc2,
                       label: block_c4qc2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qc2: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4qce; else goto c4qcf;
       c4qce: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4qcf: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.750420056 UTC

[section ""data" . GHC.Int.$fOrdInt16_closure" {
     GHC.Int.$fOrdInt16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fOrdInt16_$ccompare_closure+2;
         const GHC.Int.ltInt16_closure+2;
         const GHC.Int.leInt16_closure+2;
         const GHC.Int.gtInt16_closure+2;
         const GHC.Int.geInt16_closure+2;
         const GHC.Int.$fOrdInt16_$cmax_closure+2;
         const GHC.Int.$fOrdInt16_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.752585805 UTC

[section ""data" . GHC.Int.$fIxInt16_$cinRange_closure" {
     GHC.Int.$fIxInt16_$cinRange_closure:
         const GHC.Int.$fIxInt16_$cinRange_info;
 },
 GHC.Int.$fIxInt16_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4qcp,
                       label: GHC.Int.$fIxInt16_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qcp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qcy; else goto c4qcz;
       c4qcy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qcz: // global
           I64[Sp - 16] = block_c4qcm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qcW; else goto c4qcn;
       u4qcW: // global
           call _c4qcm(R1) args: 0, res: 0, upd: 0;
       c4qcn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qcm() //  [R1]
         { info_tbl: [(c4qcm,
                       label: block_c4qcm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qcm: // global
           I64[Sp - 8] = block_c4qcs_info;
           _s4lfQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lfQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qcV; else goto c4qct;
       u4qcV: // global
           call _c4qcs(R1) args: 0, res: 0, upd: 0;
       c4qct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qcs() //  [R1]
         { info_tbl: [(c4qcs,
                       label: block_c4qcs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qcs: // global
           I64[Sp] = block_c4qcx_info;
           _s4lfS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lfS::I64;
           if (R1 & 7 != 0) goto u4qcX; else goto c4qcC;
       u4qcX: // global
           call _c4qcx(R1) args: 0, res: 0, upd: 0;
       c4qcC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qcx() //  [R1]
         { info_tbl: [(c4qcx,
                       label: block_c4qcx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qcx: // global
           _s4lfU::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lfU::I64)) goto c4qcK; else goto c4qcO;
       c4qcK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qcO: // global
           _s4lfQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4qcN_info;
           R1 = _s4lfQ::P64;
           I64[Sp + 16] = _s4lfU::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4qcY; else goto c4qcP;
       u4qcY: // global
           call _c4qcN(R1) args: 0, res: 0, upd: 0;
       c4qcP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qcN() //  [R1]
         { info_tbl: [(c4qcN,
                       label: block_c4qcN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qcN: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.754402488 UTC

[section ""data" . GHC.Int.$fNumInt1_closure" {
     GHC.Int.$fNumInt1_closure:
         const GHC.Int.I16#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.755378296 UTC

[section ""data" . GHC.Int.$fNumInt16_$csignum_closure" {
     GHC.Int.$fNumInt16_$csignum_closure:
         const GHC.Int.$fNumInt16_$csignum_info;
 },
 GHC.Int.$fNumInt16_$csignum_entry() //  [R2]
         { info_tbl: [(c4qd6,
                       label: GHC.Int.$fNumInt16_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qd6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qd7; else goto c4qd8;
       c4qd7: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qd8: // global
           I64[Sp - 8] = block_c4qd3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qdm; else goto c4qd4;
       u4qdm: // global
           call _c4qd3(R1) args: 0, res: 0, upd: 0;
       c4qd4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qd3() //  [R1]
         { info_tbl: [(c4qd3,
                       label: block_c4qd3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qd3: // global
           _s4lg1::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lg1::I64, 0)) goto c4qdk; else goto c4qdl;
       c4qdk: // global
           if (_s4lg1::I64 == 0) goto c4qdi; else goto c4qdh;
       c4qdi: // global
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qdh: // global
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qdl: // global
           R1 = GHC.Int.$fNumInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.756891216 UTC

[section ""data" . GHC.Int.$fNumInt16_$cabs_closure" {
     GHC.Int.$fNumInt16_$cabs_closure:
         const GHC.Int.$fNumInt16_$cabs_info;
 },
 GHC.Int.$fNumInt16_$cabs_entry() //  [R2]
         { info_tbl: [(c4qdu,
                       label: GHC.Int.$fNumInt16_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qdu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qdv; else goto c4qdw;
       c4qdv: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qdw: // global
           I64[Sp - 8] = block_c4qdr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qdP; else goto c4qds;
       u4qdP: // global
           call _c4qdr(R1) args: 0, res: 0, upd: 0;
       c4qds: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qdr() //  [R1]
         { info_tbl: [(c4qdr,
                       label: block_c4qdr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qdr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qdB; else goto c4qdA;
       c4qdB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qdA: // global
           _s4lg6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lg6::I64, 0)) goto c4qdN; else goto c4qdO;
       c4qdN: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-_s4lg6::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qdO: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.758127965 UTC

[section ""data" . GHC.Int.$fNumInt16_closure" {
     GHC.Int.$fNumInt16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt16_$c+_closure+2;
         const GHC.Int.$fNumInt16_$c-_closure+2;
         const GHC.Int.$fNumInt16_$c*_closure+2;
         const GHC.Int.$fNumInt16_$cnegate_closure+1;
         const GHC.Int.$fNumInt16_$cabs_closure+1;
         const GHC.Int.$fNumInt16_$csignum_closure+1;
         const GHC.Int.$fNumInt16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.758747289 UTC

[section ""data" . GHC.Int.$fBitsInt2_closure" {
     GHC.Int.$fBitsInt2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.759476215 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt16_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4qdU,
                       label: GHC.Int.$fBitsInt16_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qdU: // global
           R1 = GHC.Int.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.760551084 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbit_closure" {
     GHC.Int.$fBitsInt16_$cbit_closure:
         const GHC.Int.$fBitsInt16_$cbit_info;
 },
 GHC.Int.$fBitsInt16_$cbit_entry() //  [R2]
         { info_tbl: [(c4qe4,
                       label: GHC.Int.$fBitsInt16_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qe4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qe5; else goto c4qe6;
       c4qe5: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qe6: // global
           I64[Sp - 8] = block_c4qe1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qep; else goto c4qe2;
       u4qep: // global
           call _c4qe1(R1) args: 0, res: 0, upd: 0;
       c4qe2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qe1() //  [R1]
         { info_tbl: [(c4qe1,
                       label: block_c4qe1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qe1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qeb; else goto c4qea;
       c4qeb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qea: // global
           _s4lgd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lgd::I64, 64)) goto c4qen; else goto c4qeo;
       c4qen: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgd::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qeo: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.762331278 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ctestBit_closure" {
     GHC.Int.$fBitsInt16_$ctestBit_closure:
         const GHC.Int.$fBitsInt16_$ctestBit_info;
 },
 GHC.Int.$fBitsInt16_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4qex,
                       label: GHC.Int.$fBitsInt16_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qex: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qeB; else goto c4qeC;
       c4qeB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qeC: // global
           I64[Sp - 16] = block_c4qeu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qfk; else goto c4qev;
       u4qfk: // global
           call _c4qeu(R1) args: 0, res: 0, upd: 0;
       c4qev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qeu() //  [R1]
         { info_tbl: [(c4qeu,
                       label: block_c4qeu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qeu: // global
           I64[Sp] = block_c4qeA_info;
           _s4lgk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lgk::I64;
           if (R1 & 7 != 0) goto u4qfj; else goto c4qeE;
       u4qfj: // global
           call _c4qeA(R1) args: 0, res: 0, upd: 0;
       c4qeE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qeA() //  [R1]
         { info_tbl: [(c4qeA,
                       label: block_c4qeA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qeA: // global
           _s4lgm::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4lgm::I64, 64)) goto c4qfi; else goto c4qfh;
       c4qfh: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgm::I64)) == 0) goto c4qfi; else goto c4qf6;
       c4qfi: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qf6: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.764324979 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateR_closure" {
     GHC.Int.$fBitsInt16_$crotateR_closure:
         const GHC.Int.$fBitsInt16_$crotateR_info;
 },
 GHC.Int.$fBitsInt16_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4qfs,
                       label: GHC.Int.$fBitsInt16_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qfs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qfw; else goto c4qfx;
       c4qfw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qfx: // global
           I64[Sp - 16] = block_c4qfp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qgw; else goto c4qfq;
       u4qgw: // global
           call _c4qfp(R1) args: 0, res: 0, upd: 0;
       c4qfq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qfp() //  [R1]
         { info_tbl: [(c4qfp,
                       label: block_c4qfp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qfp: // global
           I64[Sp - 8] = block_c4qfv_info;
           _s4lgw::P64 = R1;
           _s4lgx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lgx::I64;
           P64[Sp + 8] = _s4lgw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qgv; else goto c4qfz;
       u4qgv: // global
           call _c4qfv(R1) args: 0, res: 0, upd: 0;
       c4qfz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qfv() //  [R1]
         { info_tbl: [(c4qfv,
                       label: block_c4qfv_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qfv: // global
           _s4lgD::I64 = -I64[R1 + 7] & 15;
           if (_s4lgD::I64 != 0) goto u4qgt; else goto c4qgp;
       u4qgt: // global
           I64[Sp + 16] = _s4lgD::I64;
           Sp = Sp + 8;
           call _c4qfR() args: 0, res: 0, upd: 0;
       c4qgp: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qfR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qfR: // global
           Hp = Hp + 16;
           _s4lgD::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4qgm; else goto c4qgl;
       c4qgm: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4qfQ_info;
           R1 = _s4lgD::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4qgl: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4lgE::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4lgE::I64 << _s4lgD::I64) | (_s4lgE::I64 >> 16 - _s4lgD::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qfQ() //  [R1]
         { info_tbl: [(c4qfQ,
                       label: block_c4qfQ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qfQ: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4qfR() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.767631116 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt16_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt16_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt16_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4qgG,
                       label: GHC.Int.$fBitsInt16_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qgG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qgK; else goto c4qgL;
       c4qgK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qgL: // global
           I64[Sp - 16] = block_c4qgD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qhk; else goto c4qgE;
       u4qhk: // global
           call _c4qgD(R1) args: 0, res: 0, upd: 0;
       c4qgE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qgD() //  [R1]
         { info_tbl: [(c4qgD,
                       label: block_c4qgD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qgD: // global
           I64[Sp - 8] = block_c4qgJ_info;
           _s4lgO::P64 = R1;
           _s4lgP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lgP::I64;
           P64[Sp + 8] = _s4lgO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qhj; else goto c4qgN;
       u4qhj: // global
           call _c4qgJ(R1) args: 0, res: 0, upd: 0;
       c4qgN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qgJ() //  [R1]
         { info_tbl: [(c4qgJ,
                       label: block_c4qgJ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qgJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qgT; else goto c4qgS;
       c4qgT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qgS: // global
           _s4lgR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lgR::I64, 64)) goto c4qhh; else goto c4qhi;
       c4qhh: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgR::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qhi: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.770648681 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cclearBit_closure" {
     GHC.Int.$fBitsInt16_$cclearBit_closure:
         const GHC.Int.$fBitsInt16_$cclearBit_info;
 },
 GHC.Int.$fBitsInt16_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4qhs,
                       label: GHC.Int.$fBitsInt16_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qhs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qhw; else goto c4qhx;
       c4qhw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qhx: // global
           I64[Sp - 16] = block_c4qhp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qik; else goto c4qhq;
       u4qik: // global
           call _c4qhp(R1) args: 0, res: 0, upd: 0;
       c4qhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qhp() //  [R1]
         { info_tbl: [(c4qhp,
                       label: block_c4qhp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qhp: // global
           I64[Sp] = block_c4qhv_info;
           _s4lh2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lh2::I64;
           if (R1 & 7 != 0) goto u4qij; else goto c4qhz;
       u4qij: // global
           call _c4qhv(R1) args: 0, res: 0, upd: 0;
       c4qhz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qhv() //  [R1]
         { info_tbl: [(c4qhv,
                       label: block_c4qhv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qhv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qhF; else goto c4qhE;
       c4qhF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qhE: // global
           _s4lh2::I64 = I64[Sp + 8];
           _s4lh4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lh4::I64, 64)) goto c4qi6; else goto c4qii;
       c4qi6: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lh2::I64 & ~%MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lh4::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qii: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lh2::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.77374167 UTC

[section ""data" . GHC.Int.$fBitsInt16_$csetBit_closure" {
     GHC.Int.$fBitsInt16_$csetBit_closure:
         const GHC.Int.$fBitsInt16_$csetBit_info;
 },
 GHC.Int.$fBitsInt16_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4qis,
                       label: GHC.Int.$fBitsInt16_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qis: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qiw; else goto c4qix;
       c4qiw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qix: // global
           I64[Sp - 16] = block_c4qip_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qj6; else goto c4qiq;
       u4qj6: // global
           call _c4qip(R1) args: 0, res: 0, upd: 0;
       c4qiq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qip() //  [R1]
         { info_tbl: [(c4qip,
                       label: block_c4qip_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qip: // global
           I64[Sp - 8] = block_c4qiv_info;
           _s4lhi::P64 = R1;
           _s4lhj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lhj::I64;
           P64[Sp + 8] = _s4lhi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qj5; else goto c4qiz;
       u4qj5: // global
           call _c4qiv(R1) args: 0, res: 0, upd: 0;
       c4qiz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qiv() //  [R1]
         { info_tbl: [(c4qiv,
                       label: block_c4qiv_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qiv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qiF; else goto c4qiE;
       c4qiF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qiE: // global
           _s4lhl::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lhl::I64, 64)) goto c4qj3; else goto c4qj4;
       c4qj3: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lhl::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qj4: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.776185836 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateL_closure" {
     GHC.Int.$fBitsInt16_$crotateL_closure:
         const GHC.Int.$fBitsInt16_$crotateL_info;
 },
 GHC.Int.$fBitsInt16_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4qjb,
                       label: GHC.Int.$fBitsInt16_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qjb: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt16_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.777329568 UTC

[section ""data" . GHC.Int.$fBitsInt16_closure" {
     GHC.Int.$fBitsInt16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fBitsInt16_$c.&._closure+2;
         const GHC.Int.$fBitsInt16_$c.|._closure+2;
         const GHC.Int.$fBitsInt16_$cxor_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt16_$cshift_closure+2;
         const GHC.Int.$fBitsInt16_$crotate_closure+2;
         const GHC.Int.$fBitsInt3_closure+1;
         const GHC.Int.$fBitsInt16_$cbit_closure+1;
         const GHC.Int.$fBitsInt16_$csetBit_closure+2;
         const GHC.Int.$fBitsInt16_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt16_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt16_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt16_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt16_$crotateL_closure+2;
         const GHC.Int.$fBitsInt16_$crotateR_closure+2;
         const GHC.Int.$fBitsInt16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.779454498 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_closure" {
     GHC.Int.$fFiniteBitsInt16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt16_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.781604264 UTC

[section ""data" . GHC.Int.$fReadInt16_go_closure" {
     GHC.Int.$fReadInt16_go_closure:
         const GHC.Int.$fReadInt16_go_info;
 },
 sat_s4lhF_entry() //  [R1]
         { info_tbl: [(c4qjx,
                       label: sat_s4lhF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qjx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qjy; else goto c4qjz;
       c4qjy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4qjz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lhD_entry() //  [R1]
         { info_tbl: [(c4qjH,
                       label: sat_s4lhD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qjH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qjO; else goto c4qjP;
       c4qjO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4qjP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4qjE_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4qjT; else goto c4qjF;
       u4qjT: // global
           call _c4qjE(R1) args: 0, res: 0, upd: 0;
       c4qjF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4qjE() //  [R1]
         { info_tbl: [(c4qjE,
                       label: block_c4qjE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qjE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qjS; else goto c4qjR;
       c4qjS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4qjR: // global
           _s4lhC::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lhC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt16_go_entry() //  [R2]
         { info_tbl: [(c4qjY,
                       label: GHC.Int.$fReadInt16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qjY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qjZ; else goto c4qk0;
       c4qjZ: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qk0: // global
           I64[Sp - 8] = block_c4qji_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qka; else goto c4qjj;
       u4qka: // global
           call _c4qji(R1) args: 0, res: 0, upd: 0;
       c4qjj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qji() //  [R1]
         { info_tbl: [(c4qji,
                       label: block_c4qji_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qji: // global
           if (R1 & 7 == 1) goto c4qjV; else goto c4qjW;
       c4qjV: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qjW: // global
           I64[Sp - 8] = block_c4qjo_info;
           _s4lhw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lhw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qk9; else goto c4qjp;
       u4qk9: // global
           call _c4qjo(R1) args: 0, res: 0, upd: 0;
       c4qjp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qjo() //  [R1]
         { info_tbl: [(c4qjo,
                       label: block_c4qjo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qjo: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4qk8; else goto c4qk7;
       c4qk8: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qk7: // global
           _s4lhy::P64 = P64[R1 + 7];
           _s4lhz::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lhF_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lhD_info;
           P64[Hp - 48] = _s4lhy::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lhz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.785422416 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadsPrec_closure" {
     GHC.Int.$fReadInt16_$creadsPrec_closure:
         const GHC.Int.$fReadInt16_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4qkh,
                       label: GHC.Int.$fReadInt16_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qkh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qkl; else goto c4qkm;
       c4qkl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qkm: // global
           I64[Sp - 16] = block_c4qkf_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lhH::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lhH::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qkf() //  [R1]
         { info_tbl: [(c4qkf,
                       label: block_c4qkf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qkf: // global
           _s4lhH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4qkk_info;
           R3 = _s4lhH::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qkk() //  [R1]
         { info_tbl: [(c4qkk,
                       label: block_c4qkk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qkk: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.78764545 UTC

[section ""data" . GHC.Int.$fReadInt3_closure" {
     GHC.Int.$fReadInt3_closure:
         const GHC.Int.$fReadInt3_info;
         const 0;
 },
 sat_s4lhM_entry() //  [R1, R2]
         { info_tbl: [(c4qkB,
                       label: sat_s4lhM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qkB: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt16_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt3_entry() //  [R2, R3]
         { info_tbl: [(c4qkH,
                       label: GHC.Int.$fReadInt3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qkH: // global
           _s4lhL::P64 = R3;
           _s4lhK::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4qkI; else goto c4qkJ;
       c4qkJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qkL; else goto c4qkK;
       c4qkL: // global
           HpAlloc = 16;
           goto c4qkI;
       c4qkI: // global
           R3 = _s4lhL::P64;
           R2 = _s4lhK::P64;
           R1 = GHC.Int.$fReadInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qkK: // global
           I64[Hp - 8] = sat_s4lhM_info;
           P64[Hp] = _s4lhK::P64;
           I64[Sp - 8] = block_c4qkE_info;
           R3 = _s4lhL::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qkE() //  [R1]
         { info_tbl: [(c4qkE,
                       label: block_c4qkE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qkE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qkO; else goto c4qkN;
       c4qkO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qkN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.789828804 UTC

[section ""data" . GHC.Int.$fReadInt2_closure" {
     GHC.Int.$fReadInt2_closure:
         const GHC.Int.$fReadInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt2_entry() //  [R1]
         { info_tbl: [(c4qkV,
                       label: GHC.Int.$fReadInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qkV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4qkW; else goto c4qkX;
       c4qkW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4qkX: // global
           (_c4qkS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4qkS::I64 == 0) goto c4qkU; else goto c4qkT;
       c4qkU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4qkT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4qkS::I64;
           R2 = GHC.Int.$fReadInt3_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.791345466 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadList_closure" {
     GHC.Int.$fReadInt16_$creadList_closure:
         const GHC.Int.$fReadInt16_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadList_entry() //  [R2]
         { info_tbl: [(c4ql2,
                       label: GHC.Int.$fReadInt16_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ql2: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt2_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.792726577 UTC

[section ""data" . GHC.Int.$fReadInt1_closure" {
     GHC.Int.$fReadInt1_closure:
         const GHC.Int.$fReadInt1_info;
         const 0;
 },
 GHC.Int.$fReadInt1_entry() //  [R2, R3]
         { info_tbl: [(c4qlc,
                       label: GHC.Int.$fReadInt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qlc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qld; else goto c4qle;
       c4qld: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qle: // global
           I64[Sp - 8] = block_c4ql9_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt16_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ql9() //  [R1]
         { info_tbl: [(c4ql9,
                       label: block_c4ql9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ql9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qlh; else goto c4qlg;
       c4qlh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qlg: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.794089986 UTC

[section ""data" . GHC.Int.$fReadInt16_closure" {
     GHC.Int.$fReadInt16_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt16_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt16_$creadList_closure+1;
         const GHC.Int.$fReadInt3_closure+2;
         const GHC.Int.$fReadInt1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.795323316 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquot_closure" {
     GHC.Int.$fIntegralInt16_$cquot_closure:
         const GHC.Int.$fIntegralInt16_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4qlp,
                       label: GHC.Int.$fIntegralInt16_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qlp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qlt; else goto c4qlu;
       c4qlt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qlu: // global
           I64[Sp - 16] = block_c4qlm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qm5; else goto c4qln;
       u4qm5: // global
           call _c4qlm(R1) args: 0, res: 0, upd: 0;
       c4qln: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qlm() //  [R1]
         { info_tbl: [(c4qlm,
                       label: block_c4qlm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qlm: // global
           I64[Sp] = block_c4qls_info;
           _s4lhW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lhW::I64;
           if (R1 & 7 != 0) goto u4qm4; else goto c4qlw;
       u4qm4: // global
           call _c4qls(R1) args: 0, res: 0, upd: 0;
       c4qlw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qls() //  [R1]
         { info_tbl: [(c4qls,
                       label: block_c4qls_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qls: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qlC; else goto c4qlB;
       c4qlC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qlB: // global
           _s4lhW::I64 = I64[Sp + 8];
           _s4lhZ::I64 = I64[R1 + 7];
           if (_s4lhZ::I64 != (-1)) goto u4qm3; else goto c4qm1;
       u4qm3: // global
           if (_s4lhZ::I64 != 0) goto c4qlN; else goto c4qm2;
       c4qlN: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4lhW::I64,
                                                                            _s4lhZ::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qm2: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qm1: // global
           if (_s4lhW::I64 == (-32768)) goto c4qm0; else goto c4qlZ;
       c4qm0: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qlZ: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4lhW::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.797460698 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$crem_closure" {
     GHC.Int.$fIntegralInt16_$crem_closure:
         const GHC.Int.$fIntegralInt16_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4qmd,
                       label: GHC.Int.$fIntegralInt16_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qmd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qmh; else goto c4qmi;
       c4qmh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qmi: // global
           I64[Sp - 16] = block_c4qma_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qmE; else goto c4qmb;
       u4qmE: // global
           call _c4qma(R1) args: 0, res: 0, upd: 0;
       c4qmb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qma() //  [R1]
         { info_tbl: [(c4qma,
                       label: block_c4qma_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qma: // global
           I64[Sp] = block_c4qmg_info;
           _s4lia::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lia::I64;
           if (R1 & 7 != 0) goto u4qmD; else goto c4qmk;
       u4qmD: // global
           call _c4qmg(R1) args: 0, res: 0, upd: 0;
       c4qmk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qmg() //  [R1]
         { info_tbl: [(c4qmg,
                       label: block_c4qmg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qmg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qmq; else goto c4qmp;
       c4qmq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qmp: // global
           _s4lid::I64 = I64[R1 + 7];
           if (_s4lid::I64 != 0) goto c4qmB; else goto c4qmC;
       c4qmB: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4lid::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qmC: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.799279944 UTC

[section ""data" . GHC.Int.$w$cdiv_closure" {
     GHC.Int.$w$cdiv_closure:
         const GHC.Int.$w$cdiv_info;
         const 0;
 },
 GHC.Int.$w$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4qmO,
                       label: GHC.Int.$w$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qmO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qmP; else goto c4qmQ;
       c4qmP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qmQ: // global
           if (R3 == (-1)) goto c4qmM; else goto u4qna;
       c4qmM: // global
           if (R2 == (-32768)) goto c4qn9; else goto c4qn7;
       c4qn9: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qn7: // global
           I64[Sp - 8] = block_c4qn1_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4qna: // global
           if (R3 == 0) goto c4qmN; else goto c4qmL;
       c4qmN: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qmL: // global
           I64[Sp - 8] = block_c4qmS_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qn1() //  [R1]
         { info_tbl: [(c4qn1,
                       label: block_c4qn1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qn1: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qmS() //  [R1]
         { info_tbl: [(c4qmS,
                       label: block_c4qmS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qmS: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.800937811 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdiv_closure" {
     GHC.Int.$fIntegralInt16_$cdiv_closure:
         const GHC.Int.$fIntegralInt16_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4qni,
                       label: GHC.Int.$fIntegralInt16_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qni: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qnv; else goto c4qnw;
       c4qnv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qnw: // global
           I64[Sp - 16] = block_c4qnf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qnD; else goto c4qng;
       u4qnD: // global
           call _c4qnf(R1) args: 0, res: 0, upd: 0;
       c4qng: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qnf() //  [R1]
         { info_tbl: [(c4qnf,
                       label: block_c4qnf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qnf: // global
           I64[Sp] = block_c4qnl_info;
           _s4lir::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lir::I64;
           if (R1 & 7 != 0) goto u4qnC; else goto c4qnm;
       u4qnC: // global
           call _c4qnl(R1) args: 0, res: 0, upd: 0;
       c4qnm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qnl() //  [R1]
         { info_tbl: [(c4qnl,
                       label: block_c4qnl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qnl: // global
           _s4lir::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4qnq_info;
           R3 = I64[R1 + 7];
           R2 = _s4lir::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qnq() //  [R1]
         { info_tbl: [(c4qnq,
                       label: block_c4qnq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qnq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qnB; else goto c4qnA;
       c4qnB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4qnA: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.803032912 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cmod_closure" {
     GHC.Int.$fIntegralInt16_$cmod_closure:
         const GHC.Int.$fIntegralInt16_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4qnL,
                       label: GHC.Int.$fIntegralInt16_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qnL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qnP; else goto c4qnQ;
       c4qnP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qnQ: // global
           I64[Sp - 16] = block_c4qnI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qoe; else goto c4qnJ;
       u4qoe: // global
           call _c4qnI(R1) args: 0, res: 0, upd: 0;
       c4qnJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qnI() //  [R1]
         { info_tbl: [(c4qnI,
                       label: block_c4qnI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qnI: // global
           I64[Sp] = block_c4qnO_info;
           _s4liy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4liy::I64;
           if (R1 & 7 != 0) goto u4qod; else goto c4qnS;
       u4qod: // global
           call _c4qnO(R1) args: 0, res: 0, upd: 0;
       c4qnS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qnO() //  [R1]
         { info_tbl: [(c4qnO,
                       label: block_c4qnO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qnO: // global
           _s4liB::I64 = I64[R1 + 7];
           if (_s4liB::I64 != 0) goto c4qo8; else goto c4qoc;
       c4qo8: // global
           _s4liy::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4qnZ_info;
           R3 = _s4liB::I64;
           R2 = _s4liy::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4qoc: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qnZ() //  [R1]
         { info_tbl: [(c4qnZ,
                       label: block_c4qnZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qnZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qob; else goto c4qoa;
       c4qob: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4qoa: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.80569881 UTC

[section ""data" . lvl7_r4kPy_closure" {
     lvl7_r4kPy_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt3_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.807053387 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquotRem_closure" {
     GHC.Int.$fIntegralInt16_$cquotRem_closure:
         const GHC.Int.$fIntegralInt16_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4qom,
                       label: GHC.Int.$fIntegralInt16_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qom: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qoq; else goto c4qor;
       c4qoq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qor: // global
           I64[Sp - 16] = block_c4qoj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qp6; else goto c4qok;
       u4qp6: // global
           call _c4qoj(R1) args: 0, res: 0, upd: 0;
       c4qok: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qoj() //  [R1]
         { info_tbl: [(c4qoj,
                       label: block_c4qoj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qoj: // global
           I64[Sp] = block_c4qop_info;
           _s4liI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4liI::I64;
           if (R1 & 7 != 0) goto u4qp5; else goto c4qot;
       u4qp5: // global
           call _c4qop(R1) args: 0, res: 0, upd: 0;
       c4qot: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qop() //  [R1]
         { info_tbl: [(c4qop,
                       label: block_c4qop_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qop: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4qoz; else goto c4qoy;
       c4qoz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qoy: // global
           _s4liI::I64 = I64[Sp + 8];
           _s4liL::I64 = I64[R1 + 7];
           if (_s4liL::I64 != (-1)) goto u4qp4; else goto c4qp2;
       u4qp4: // global
           if (_s4liL::I64 != 0) goto c4qoM; else goto c4qp3;
       c4qoM: // global
           (_s4liN::I64, _s4liO::I64) = call MO_S_QuotRem W64(_s4liI::I64, _s4liL::I64);
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liO::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liN::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qp3: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qp2: // global
           if (_s4liI::I64 == (-32768)) goto c4qp1; else goto c4qp0;
       c4qp1: // global
           Hp = Hp - 56;
           R1 = lvl7_r4kPy_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qp0: // global
           (_s4liV::I64, _s4liW::I64) = call MO_S_QuotRem W64(_s4liI::I64, (-1));
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liW::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liV::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.810278894 UTC

[section ""data" . GHC.Int.$w$cdivMod_closure" {
     GHC.Int.$w$cdivMod_closure:
         const GHC.Int.$w$cdivMod_info;
         const 0;
 },
 section ""relreadonly" . u4qrP_srtd" {
     u4qrP_srtd:
         const S4lDl_srt+536;
         const 33;
         const 4294967299;
 },
 GHC.Int.$w$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4qpf,
                       label: GHC.Int.$w$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qpf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qpg; else goto c4qph;
       c4qpg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qph: // global
           if (R3 == 0) goto c4qpe; else goto c4qpd;
       c4qpe: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qpd: // global
           if (R3 == (-1)) goto c4qrK; else goto u4qrL;
       c4qrK: // global
           if (R2 == (-32768)) goto c4qrJ; else goto u4qrM;
       c4qrJ: // global
           R2 = GHC.Int.$fBitsInt3_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4qrM: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4qrO;
       u4qrL: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4qrO;
       u4qrO: // global
           call _c4qpm() args: 0, res: 0, upd: 0;
     }
 },
 _c4qpm() //  []
         { info_tbl: [(c4qpm,
                       label: block_c4qpm_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qpm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4qpq; else goto c4qpp;
       c4qpq: // global
           HpAlloc = 32;
           I64[Sp] = block_c4qpm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4qpp: // global
           _s4lj2::I64 = I64[Sp + 8];
           _s4lj4::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lj2::I64, 0)) goto c4qqj; else goto c4qrA;
       c4qqj: // global
           if (%MO_S_Ge_W64(_s4lj2::I64, 0)) goto c4qpG; else goto c4qqh;
       c4qpG: // global
           (_s4lj9::I64, _s4lja::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lja::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lj9::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qqh: // global
           if (%MO_S_Le_W64(_s4lj4::I64, 0)) goto c4qpU; else goto c4qqg;
       c4qpU: // global
           (_s4ljh::I64, _s4lji::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lji::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljh::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qqg: // global
           (_s4ljp::I64, _s4ljq::I64) = call MO_S_QuotRem W64(_s4lj2::I64 + 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljq::I64 + _s4lj4::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljp::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qrA: // global
           if (%MO_S_Ge_W64(_s4lj4::I64, 0)) goto c4qrd; else goto c4qrz;
       c4qrd: // global
           if (%MO_S_Ge_W64(_s4lj2::I64, 0)) goto c4qqA; else goto c4qrb;
       c4qqA: // global
           (_s4ljB::I64, _s4ljC::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljC::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljB::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qrb: // global
           if (%MO_S_Le_W64(_s4lj4::I64, 0)) goto c4qqO; else goto c4qra;
       c4qqO: // global
           (_s4ljJ::I64, _s4ljK::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljK::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljJ::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qra: // global
           (_s4ljR::I64, _s4ljS::I64) = call MO_S_QuotRem W64(_s4lj2::I64 + 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljS::I64 + _s4lj4::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljR::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qrz: // global
           (_s4lk2::I64, _s4lk3::I64) = call MO_S_QuotRem W64(_s4lj2::I64 - 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lk3::I64 + _s4lj4::I64 + 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lk2::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.813786951 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdivMod_closure" {
     GHC.Int.$fIntegralInt16_$cdivMod_closure:
         const GHC.Int.$fIntegralInt16_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4qrX,
                       label: GHC.Int.$fIntegralInt16_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qrX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qs8; else goto c4qs9;
       c4qs8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qs9: // global
           I64[Sp - 16] = block_c4qrU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qsg; else goto c4qrV;
       u4qsg: // global
           call _c4qrU(R1) args: 0, res: 0, upd: 0;
       c4qrV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qrU() //  [R1]
         { info_tbl: [(c4qrU,
                       label: block_c4qrU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qrU: // global
           I64[Sp] = block_c4qs0_info;
           _s4lkh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkh::I64;
           if (R1 & 7 != 0) goto u4qsf; else goto c4qs1;
       u4qsf: // global
           call _c4qs0(R1) args: 0, res: 0, upd: 0;
       c4qs1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qs0() //  [R1]
         { info_tbl: [(c4qs0,
                       label: block_c4qs0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qs0: // global
           _s4lkh::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4qs5_info;
           R3 = I64[R1 + 7];
           R2 = _s4lkh::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qs5() //  [R1, R2]
         { info_tbl: [(c4qs5,
                       label: block_c4qs5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qs5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4qse; else goto c4qsd;
       c4qse: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4qsd: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.815863352 UTC

[section ""data" . GHC.Int.$fRealInt16_$ctoRational_closure" {
     GHC.Int.$fRealInt16_$ctoRational_closure:
         const GHC.Int.$fRealInt16_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt16_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4qso,
                       label: GHC.Int.$fRealInt16_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qso: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qsC; else goto c4qsD;
       c4qsC: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qsD: // global
           I64[Sp - 8] = block_c4qsl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qsK; else goto c4qsm;
       u4qsK: // global
           call _c4qsl(R1) args: 0, res: 0, upd: 0;
       c4qsm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qsl() //  [R1]
         { info_tbl: [(c4qsl,
                       label: block_c4qsl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qsl: // global
           I64[Sp] = block_c4qsr_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qsr() //  [R1]
         { info_tbl: [(c4qsr,
                       label: block_c4qsr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qsr: // global
           I64[Sp] = block_c4qsv_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qsv() //  [R1]
         { info_tbl: [(c4qsv,
                       label: block_c4qsv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qsv: // global
           I64[Sp] = block_c4qsz_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qsz() //  [R1, R2]
         { info_tbl: [(c4qsz,
                       label: block_c4qsz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qsz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4qsJ; else goto c4qsI;
       c4qsJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4qsI: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.81748423 UTC

[section ""data" . GHC.Int.$fRealInt16_closure" {
     GHC.Int.$fRealInt16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt16_closure+1;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fRealInt16_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.818197573 UTC

[section ""data" . GHC.Int.$fIntegralInt16_closure" {
     GHC.Int.$fIntegralInt16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt16_closure+1;
         const GHC.Int.$fEnumInt16_closure+1;
         const GHC.Int.$fIntegralInt16_$cquot_closure+2;
         const GHC.Int.$fIntegralInt16_$crem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt16_$cmod_closure+2;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt16_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.819395241 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt16_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt16_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt16_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4qsS,
                       label: GHC.Int.$fIxInt16_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qsS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qt9; else goto c4qta;
       c4qt9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qta: // global
           I64[Sp - 16] = block_c4qsP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qth; else goto c4qsQ;
       u4qth: // global
           call _c4qsP(R1) args: 0, res: 0, upd: 0;
       c4qsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qsP() //  [R1]
         { info_tbl: [(c4qsP,
                       label: block_c4qsP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qsP: // global
           I64[Sp] = block_c4qsV_info;
           _s4lky::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lky::P64;
           if (R1 & 7 != 0) goto u4qtg; else goto c4qsW;
       u4qtg: // global
           call _c4qsV(R1) args: 0, res: 0, upd: 0;
       c4qsW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qsV() //  [R1]
         { info_tbl: [(c4qsV,
                       label: block_c4qsV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qsV: // global
           I64[Sp] = block_c4qt0_info;
           _s4lkB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkB::I64;
           if (R1 & 7 != 0) goto u4qti; else goto c4qt1;
       u4qti: // global
           call _c4qt0(R1) args: 0, res: 0, upd: 0;
       c4qt1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qt0() //  [R1]
         { info_tbl: [(c4qt0,
                       label: block_c4qt0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qt0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qtf; else goto c4qte;
       c4qtf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qte: // global
           _s4lkE::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lkE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.82120795 UTC

[section ""data" . GHC.Int.$fIxInt16_$crange_closure" {
     GHC.Int.$fIxInt16_$crange_closure:
         const GHC.Int.$fIxInt16_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$crange_entry() //  [R2]
         { info_tbl: [(c4qtq,
                       label: GHC.Int.$fIxInt16_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qtq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qtr; else goto c4qts;
       c4qtr: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qts: // global
           I64[Sp - 8] = block_c4qtn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qtw; else goto c4qto;
       u4qtw: // global
           call _c4qtn(R1) args: 0, res: 0, upd: 0;
       c4qto: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qtn() //  [R1]
         { info_tbl: [(c4qtn,
                       label: block_c4qtn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qtn: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.823090251 UTC

[section ""data" . GHC.Int.$fIxInt16_$crangeSize_closure" {
     GHC.Int.$fIxInt16_$crangeSize_closure:
         const GHC.Int.$fIxInt16_$crangeSize_info;
 },
 GHC.Int.$fIxInt16_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4qtE,
                       label: GHC.Int.$fIxInt16_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qtE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qtN; else goto c4qtO;
       c4qtN: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qtO: // global
           I64[Sp - 8] = block_c4qtB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qud; else goto c4qtC;
       u4qud: // global
           call _c4qtB(R1) args: 0, res: 0, upd: 0;
       c4qtC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qtB() //  [R1]
         { info_tbl: [(c4qtB,
                       label: block_c4qtB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qtB: // global
           I64[Sp - 8] = block_c4qtH_info;
           _s4lkM::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lkM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4quc; else goto c4qtI;
       u4quc: // global
           call _c4qtH(R1) args: 0, res: 0, upd: 0;
       c4qtI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qtH() //  [R1]
         { info_tbl: [(c4qtH,
                       label: block_c4qtH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qtH: // global
           I64[Sp] = block_c4qtM_info;
           _s4lkO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkO::I64;
           if (R1 & 7 != 0) goto u4que; else goto c4qtR;
       u4que: // global
           call _c4qtM(R1) args: 0, res: 0, upd: 0;
       c4qtR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qtM() //  [R1]
         { info_tbl: [(c4qtM,
                       label: block_c4qtM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qtM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qtX; else goto c4qtW;
       c4qtX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qtW: // global
           _s4lkO::I64 = I64[Sp + 8];
           _s4lkQ::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lkO::I64,
                            _s4lkQ::I64)) goto c4qu1; else goto c4qub;
       c4qu1: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qub: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lkQ::I64 - _s4lkO::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.825565465 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt16_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt16_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4qum,
                       label: GHC.Int.$fIxInt16_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qum: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4quG; else goto c4quH;
       c4quG: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4quH: // global
           I64[Sp - 8] = block_c4quj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4quO; else goto c4quk;
       u4quO: // global
           call _c4quj(R1) args: 0, res: 0, upd: 0;
       c4quk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4quj() //  [R1]
         { info_tbl: [(c4quj,
                       label: block_c4quj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4quj: // global
           I64[Sp - 8] = block_c4qup_info;
           _s4lkW::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lkW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4quN; else goto c4quq;
       u4quN: // global
           call _c4qup(R1) args: 0, res: 0, upd: 0;
       c4quq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qup() //  [R1]
         { info_tbl: [(c4qup,
                       label: block_c4qup_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qup: // global
           I64[Sp] = block_c4quu_info;
           _s4lkZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkZ::I64;
           if (R1 & 7 != 0) goto u4quP; else goto c4quv;
       u4quP: // global
           call _c4quu(R1) args: 0, res: 0, upd: 0;
       c4quv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4quu() //  [R1]
         { info_tbl: [(c4quu,
                       label: block_c4quu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4quu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4quM; else goto c4quL;
       c4quM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4quL: // global
           _s4ll3::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4ll3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.827931899 UTC

[section ""data" . GHC.Int.$fIxInt16_$cindex_closure" {
     GHC.Int.$fIxInt16_$cindex_closure:
         const GHC.Int.$fIxInt16_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4quX,
                       label: GHC.Int.$fIxInt16_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4quX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qv6; else goto c4qv7;
       c4qv6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qv7: // global
           I64[Sp - 16] = block_c4quU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qvG; else goto c4quV;
       u4qvG: // global
           call _c4quU(R1) args: 0, res: 0, upd: 0;
       c4quV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4quU() //  [R1]
         { info_tbl: [(c4quU,
                       label: block_c4quU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4quU: // global
           I64[Sp - 8] = block_c4qv0_info;
           _s4ll8::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4ll8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qvF; else goto c4qv1;
       u4qvF: // global
           call _c4qv0(R1) args: 0, res: 0, upd: 0;
       c4qv1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qv0() //  [R1]
         { info_tbl: [(c4qv0,
                       label: block_c4qv0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qv0: // global
           I64[Sp] = block_c4qv5_info;
           _s4lla::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lla::I64;
           if (R1 & 7 != 0) goto u4qvH; else goto c4qva;
       u4qvH: // global
           call _c4qv5(R1) args: 0, res: 0, upd: 0;
       c4qva: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qv5() //  [R1]
         { info_tbl: [(c4qv5,
                       label: block_c4qv5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qv5: // global
           _s4llc::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4llc::I64)) goto c4qvi; else goto c4qvm;
       c4qvi: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4qvm: // global
           I64[Sp] = block_c4qvl_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llc::I64;
           if (R1 & 7 != 0) goto u4qvI; else goto c4qvn;
       u4qvI: // global
           call _c4qvl(R1) args: 0, res: 0, upd: 0;
       c4qvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qvl() //  [R1]
         { info_tbl: [(c4qvl,
                       label: block_c4qvl_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qvl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qvt; else goto c4qvs;
       c4qvt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qvs: // global
           _s4llc::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4llc::I64,
                            I64[R1 + 7])) goto c4qvx; else goto c4qvE;
       c4qvx: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4qvE: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4llc::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.831183053 UTC

[section ""data" . GHC.Int.$fIxInt16_closure" {
     GHC.Int.$fIxInt16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fIxInt16_$crange_closure+1;
         const GHC.Int.$fIxInt16_$cindex_closure+2;
         const GHC.Int.$fIxInt16_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt16_$cinRange_closure+2;
         const GHC.Int.$fIxInt16_$crangeSize_closure+1;
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.832315124 UTC

[section ""data" . GHC.Int.eqInt32_closure" {
     GHC.Int.eqInt32_closure:
         const GHC.Int.eqInt32_info;
 },
 GHC.Int.eqInt32_entry() //  [R2, R3]
         { info_tbl: [(c4qvQ,
                       label: GHC.Int.eqInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qvQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qvU; else goto c4qvV;
       c4qvU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qvV: // global
           I64[Sp - 16] = block_c4qvN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qw4; else goto c4qvO;
       u4qw4: // global
           call _c4qvN(R1) args: 0, res: 0, upd: 0;
       c4qvO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qvN() //  [R1]
         { info_tbl: [(c4qvN,
                       label: block_c4qvN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qvN: // global
           I64[Sp] = block_c4qvT_info;
           _s4lll::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lll::I64;
           if (R1 & 7 != 0) goto u4qw3; else goto c4qvX;
       u4qw3: // global
           call _c4qvT(R1) args: 0, res: 0, upd: 0;
       c4qvX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qvT() //  [R1]
         { info_tbl: [(c4qvT,
                       label: block_c4qvT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qvT: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.833619448 UTC

[section ""data" . GHC.Int.$fEqInt32_closure" {
     GHC.Int.$fEqInt32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt32_closure+2;
         const GHC.Int.neInt32_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.834597957 UTC

[section ""data" . GHC.Int.gtInt32_closure" {
     GHC.Int.gtInt32_closure:
         const GHC.Int.gtInt32_info;
 },
 GHC.Int.gtInt32_entry() //  [R2, R3]
         { info_tbl: [(c4qwc,
                       label: GHC.Int.gtInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qwc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qwg; else goto c4qwh;
       c4qwg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qwh: // global
           I64[Sp - 16] = block_c4qw9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qwq; else goto c4qwa;
       u4qwq: // global
           call _c4qw9(R1) args: 0, res: 0, upd: 0;
       c4qwa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qw9() //  [R1]
         { info_tbl: [(c4qw9,
                       label: block_c4qw9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qw9: // global
           I64[Sp] = block_c4qwf_info;
           _s4lls::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lls::I64;
           if (R1 & 7 != 0) goto u4qwp; else goto c4qwj;
       u4qwp: // global
           call _c4qwf(R1) args: 0, res: 0, upd: 0;
       c4qwj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qwf() //  [R1]
         { info_tbl: [(c4qwf,
                       label: block_c4qwf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qwf: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.836169386 UTC

[section ""data" . GHC.Int.geInt32_closure" {
     GHC.Int.geInt32_closure:
         const GHC.Int.geInt32_info;
 },
 GHC.Int.geInt32_entry() //  [R2, R3]
         { info_tbl: [(c4qwy,
                       label: GHC.Int.geInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qwy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qwC; else goto c4qwD;
       c4qwC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qwD: // global
           I64[Sp - 16] = block_c4qwv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qwM; else goto c4qww;
       u4qwM: // global
           call _c4qwv(R1) args: 0, res: 0, upd: 0;
       c4qww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qwv() //  [R1]
         { info_tbl: [(c4qwv,
                       label: block_c4qwv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qwv: // global
           I64[Sp] = block_c4qwB_info;
           _s4llz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llz::I64;
           if (R1 & 7 != 0) goto u4qwL; else goto c4qwF;
       u4qwL: // global
           call _c4qwB(R1) args: 0, res: 0, upd: 0;
       c4qwF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qwB() //  [R1]
         { info_tbl: [(c4qwB,
                       label: block_c4qwB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qwB: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.83827273 UTC

[section ""data" . GHC.Int.ltInt32_closure" {
     GHC.Int.ltInt32_closure:
         const GHC.Int.ltInt32_info;
 },
 GHC.Int.ltInt32_entry() //  [R2, R3]
         { info_tbl: [(c4qwU,
                       label: GHC.Int.ltInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qwU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qwY; else goto c4qwZ;
       c4qwY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qwZ: // global
           I64[Sp - 16] = block_c4qwR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qx8; else goto c4qwS;
       u4qx8: // global
           call _c4qwR(R1) args: 0, res: 0, upd: 0;
       c4qwS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qwR() //  [R1]
         { info_tbl: [(c4qwR,
                       label: block_c4qwR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qwR: // global
           I64[Sp] = block_c4qwX_info;
           _s4llG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llG::I64;
           if (R1 & 7 != 0) goto u4qx7; else goto c4qx1;
       u4qx7: // global
           call _c4qwX(R1) args: 0, res: 0, upd: 0;
       c4qx1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qwX() //  [R1]
         { info_tbl: [(c4qwX,
                       label: block_c4qwX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qwX: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.84005891 UTC

[section ""data" . GHC.Int.leInt32_closure" {
     GHC.Int.leInt32_closure:
         const GHC.Int.leInt32_info;
 },
 GHC.Int.leInt32_entry() //  [R2, R3]
         { info_tbl: [(c4qxg,
                       label: GHC.Int.leInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qxg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qxk; else goto c4qxl;
       c4qxk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qxl: // global
           I64[Sp - 16] = block_c4qxd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qxu; else goto c4qxe;
       u4qxu: // global
           call _c4qxd(R1) args: 0, res: 0, upd: 0;
       c4qxe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qxd() //  [R1]
         { info_tbl: [(c4qxd,
                       label: block_c4qxd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qxd: // global
           I64[Sp] = block_c4qxj_info;
           _s4llN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llN::I64;
           if (R1 & 7 != 0) goto u4qxt; else goto c4qxn;
       u4qxt: // global
           call _c4qxj(R1) args: 0, res: 0, upd: 0;
       c4qxn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qxj() //  [R1]
         { info_tbl: [(c4qxj,
                       label: block_c4qxj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qxj: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.841746604 UTC

[section ""data" . GHC.Int.$fOrdInt32_$ccompare_closure" {
     GHC.Int.$fOrdInt32_$ccompare_closure:
         const GHC.Int.$fOrdInt32_$ccompare_info;
 },
 GHC.Int.$fOrdInt32_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4qxC,
                       label: GHC.Int.$fOrdInt32_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qxC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qxG; else goto c4qxH;
       c4qxG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qxH: // global
           I64[Sp - 16] = block_c4qxz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qy0; else goto c4qxA;
       u4qy0: // global
           call _c4qxz(R1) args: 0, res: 0, upd: 0;
       c4qxA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qxz() //  [R1]
         { info_tbl: [(c4qxz,
                       label: block_c4qxz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qxz: // global
           I64[Sp] = block_c4qxF_info;
           _s4llU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llU::I64;
           if (R1 & 7 != 0) goto u4qxZ; else goto c4qxJ;
       u4qxZ: // global
           call _c4qxF(R1) args: 0, res: 0, upd: 0;
       c4qxJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qxF() //  [R1]
         { info_tbl: [(c4qxF,
                       label: block_c4qxF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qxF: // global
           _s4llU::I64 = I64[Sp + 8];
           _s4llW::I64 = I64[R1 + 7];
           if (_s4llU::I64 == _s4llW::I64) goto c4qxY; else goto c4qxX;
       c4qxY: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qxX: // global
           if (%MO_S_Gt_W64(_s4llU::I64,
                            _s4llW::I64)) goto c4qxU; else goto c4qxV;
       c4qxU: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qxV: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.843516833 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmax_closure" {
     GHC.Int.$fOrdInt32_$cmax_closure:
         const GHC.Int.$fOrdInt32_$cmax_info;
 },
 GHC.Int.$fOrdInt32_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4qy8,
                       label: GHC.Int.$fOrdInt32_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qy8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qyc; else goto c4qyd;
       c4qyc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qyd: // global
           I64[Sp - 16] = block_c4qy5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qyq; else goto c4qy6;
       u4qyq: // global
           call _c4qy5(R1) args: 0, res: 0, upd: 0;
       c4qy6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qy5() //  [R1]
         { info_tbl: [(c4qy5,
                       label: block_c4qy5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qy5: // global
           I64[Sp - 8] = block_c4qyb_info;
           _s4lm1::P64 = R1;
           _s4lm2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lm2::I64;
           P64[Sp + 8] = _s4lm1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qyp; else goto c4qyf;
       u4qyp: // global
           call _c4qyb(R1) args: 0, res: 0, upd: 0;
       c4qyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qyb() //  [R1]
         { info_tbl: [(c4qyb,
                       label: block_c4qyb_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qyb: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4qyn; else goto c4qyo;
       c4qyn: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4qyo: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.84538779 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmin_closure" {
     GHC.Int.$fOrdInt32_$cmin_closure:
         const GHC.Int.$fOrdInt32_$cmin_info;
 },
 GHC.Int.$fOrdInt32_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4qyy,
                       label: GHC.Int.$fOrdInt32_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qyy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qyC; else goto c4qyD;
       c4qyC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qyD: // global
           I64[Sp - 16] = block_c4qyv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qyQ; else goto c4qyw;
       u4qyQ: // global
           call _c4qyv(R1) args: 0, res: 0, upd: 0;
       c4qyw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qyv() //  [R1]
         { info_tbl: [(c4qyv,
                       label: block_c4qyv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qyv: // global
           I64[Sp - 8] = block_c4qyB_info;
           _s4lm8::P64 = R1;
           _s4lm9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lm9::I64;
           P64[Sp + 8] = _s4lm8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qyP; else goto c4qyF;
       u4qyP: // global
           call _c4qyB(R1) args: 0, res: 0, upd: 0;
       c4qyF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qyB() //  [R1]
         { info_tbl: [(c4qyB,
                       label: block_c4qyB_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qyB: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4qyN; else goto c4qyO;
       c4qyN: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4qyO: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.846815114 UTC

[section ""data" . GHC.Int.$fOrdInt32_closure" {
     GHC.Int.$fOrdInt32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fOrdInt32_$ccompare_closure+2;
         const GHC.Int.ltInt32_closure+2;
         const GHC.Int.leInt32_closure+2;
         const GHC.Int.gtInt32_closure+2;
         const GHC.Int.geInt32_closure+2;
         const GHC.Int.$fOrdInt32_$cmax_closure+2;
         const GHC.Int.$fOrdInt32_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.848071504 UTC

[section ""data" . GHC.Int.$fIxInt32_$cinRange_closure" {
     GHC.Int.$fIxInt32_$cinRange_closure:
         const GHC.Int.$fIxInt32_$cinRange_info;
 },
 GHC.Int.$fIxInt32_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4qyY,
                       label: GHC.Int.$fIxInt32_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qyY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qz7; else goto c4qz8;
       c4qz7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qz8: // global
           I64[Sp - 16] = block_c4qyV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qzv; else goto c4qyW;
       u4qzv: // global
           call _c4qyV(R1) args: 0, res: 0, upd: 0;
       c4qyW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qyV() //  [R1]
         { info_tbl: [(c4qyV,
                       label: block_c4qyV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qyV: // global
           I64[Sp - 8] = block_c4qz1_info;
           _s4lmh::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lmh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qzu; else goto c4qz2;
       u4qzu: // global
           call _c4qz1(R1) args: 0, res: 0, upd: 0;
       c4qz2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qz1() //  [R1]
         { info_tbl: [(c4qz1,
                       label: block_c4qz1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qz1: // global
           I64[Sp] = block_c4qz6_info;
           _s4lmj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lmj::I64;
           if (R1 & 7 != 0) goto u4qzw; else goto c4qzb;
       u4qzw: // global
           call _c4qz6(R1) args: 0, res: 0, upd: 0;
       c4qzb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qz6() //  [R1]
         { info_tbl: [(c4qz6,
                       label: block_c4qz6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qz6: // global
           _s4lml::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lml::I64)) goto c4qzj; else goto c4qzn;
       c4qzj: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qzn: // global
           _s4lmh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4qzm_info;
           R1 = _s4lmh::P64;
           I64[Sp + 16] = _s4lml::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4qzx; else goto c4qzo;
       u4qzx: // global
           call _c4qzm(R1) args: 0, res: 0, upd: 0;
       c4qzo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qzm() //  [R1]
         { info_tbl: [(c4qzm,
                       label: block_c4qzm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qzm: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.850140005 UTC

[section ""data" . GHC.Int.$fNumInt3_closure" {
     GHC.Int.$fNumInt3_closure:
         const GHC.Int.I32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.851150103 UTC

[section ""data" . GHC.Int.$fNumInt32_$csignum_closure" {
     GHC.Int.$fNumInt32_$csignum_closure:
         const GHC.Int.$fNumInt32_$csignum_info;
 },
 GHC.Int.$fNumInt32_$csignum_entry() //  [R2]
         { info_tbl: [(c4qzF,
                       label: GHC.Int.$fNumInt32_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qzF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qzG; else goto c4qzH;
       c4qzG: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qzH: // global
           I64[Sp - 8] = block_c4qzC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qzV; else goto c4qzD;
       u4qzV: // global
           call _c4qzC(R1) args: 0, res: 0, upd: 0;
       c4qzD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qzC() //  [R1]
         { info_tbl: [(c4qzC,
                       label: block_c4qzC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qzC: // global
           _s4lms::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lms::I64, 0)) goto c4qzT; else goto c4qzU;
       c4qzT: // global
           if (_s4lms::I64 == 0) goto c4qzR; else goto c4qzQ;
       c4qzR: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qzQ: // global
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qzU: // global
           R1 = GHC.Int.$fNumInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.853841361 UTC

[section ""data" . GHC.Int.$fNumInt32_$cabs_closure" {
     GHC.Int.$fNumInt32_$cabs_closure:
         const GHC.Int.$fNumInt32_$cabs_info;
 },
 GHC.Int.$fNumInt32_$cabs_entry() //  [R2]
         { info_tbl: [(c4qA3,
                       label: GHC.Int.$fNumInt32_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qA3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qA4; else goto c4qA5;
       c4qA4: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qA5: // global
           I64[Sp - 8] = block_c4qA0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qAo; else goto c4qA1;
       u4qAo: // global
           call _c4qA0(R1) args: 0, res: 0, upd: 0;
       c4qA1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qA0() //  [R1]
         { info_tbl: [(c4qA0,
                       label: block_c4qA0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qA0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qAa; else goto c4qA9;
       c4qAa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qA9: // global
           _s4lmx::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lmx::I64, 0)) goto c4qAm; else goto c4qAn;
       c4qAm: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-_s4lmx::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qAn: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.855034419 UTC

[section ""data" . GHC.Int.$fNumInt32_closure" {
     GHC.Int.$fNumInt32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt32_$c+_closure+2;
         const GHC.Int.$fNumInt32_$c-_closure+2;
         const GHC.Int.$fNumInt32_$c*_closure+2;
         const GHC.Int.$fNumInt32_$cnegate_closure+1;
         const GHC.Int.$fNumInt32_$cabs_closure+1;
         const GHC.Int.$fNumInt32_$csignum_closure+1;
         const GHC.Int.$fNumInt32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.855653436 UTC

[section ""data" . GHC.Int.$fBitsInt5_closure" {
     GHC.Int.$fBitsInt5_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.856396291 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt32_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4qAt,
                       label: GHC.Int.$fBitsInt32_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qAt: // global
           R1 = GHC.Int.$fBitsInt5_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.857622679 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbit_closure" {
     GHC.Int.$fBitsInt32_$cbit_closure:
         const GHC.Int.$fBitsInt32_$cbit_info;
 },
 GHC.Int.$fBitsInt32_$cbit_entry() //  [R2]
         { info_tbl: [(c4qAD,
                       label: GHC.Int.$fBitsInt32_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qAD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qAE; else goto c4qAF;
       c4qAE: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qAF: // global
           I64[Sp - 8] = block_c4qAA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qAY; else goto c4qAB;
       u4qAY: // global
           call _c4qAA(R1) args: 0, res: 0, upd: 0;
       c4qAB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qAA() //  [R1]
         { info_tbl: [(c4qAA,
                       label: block_c4qAA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qAA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qAK; else goto c4qAJ;
       c4qAK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qAJ: // global
           _s4lmE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lmE::I64, 64)) goto c4qAW; else goto c4qAX;
       c4qAW: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lmE::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qAX: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.859302421 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ctestBit_closure" {
     GHC.Int.$fBitsInt32_$ctestBit_closure:
         const GHC.Int.$fBitsInt32_$ctestBit_info;
 },
 GHC.Int.$fBitsInt32_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4qB6,
                       label: GHC.Int.$fBitsInt32_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qB6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qBa; else goto c4qBb;
       c4qBa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qBb: // global
           I64[Sp - 16] = block_c4qB3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qBT; else goto c4qB4;
       u4qBT: // global
           call _c4qB3(R1) args: 0, res: 0, upd: 0;
       c4qB4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qB3() //  [R1]
         { info_tbl: [(c4qB3,
                       label: block_c4qB3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qB3: // global
           I64[Sp] = block_c4qB9_info;
           _s4lmL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lmL::I64;
           if (R1 & 7 != 0) goto u4qBS; else goto c4qBd;
       u4qBS: // global
           call _c4qB9(R1) args: 0, res: 0, upd: 0;
       c4qBd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qB9() //  [R1]
         { info_tbl: [(c4qB9,
                       label: block_c4qB9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qB9: // global
           _s4lmN::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4lmN::I64, 64)) goto c4qBR; else goto c4qBQ;
       c4qBQ: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lmN::I64)) == 0) goto c4qBR; else goto c4qBF;
       c4qBR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qBF: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.861348773 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateR_closure" {
     GHC.Int.$fBitsInt32_$crotateR_closure:
         const GHC.Int.$fBitsInt32_$crotateR_info;
 },
 GHC.Int.$fBitsInt32_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4qC1,
                       label: GHC.Int.$fBitsInt32_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qC1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qC5; else goto c4qC6;
       c4qC5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qC6: // global
           I64[Sp - 16] = block_c4qBY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qD5; else goto c4qBZ;
       u4qD5: // global
           call _c4qBY(R1) args: 0, res: 0, upd: 0;
       c4qBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qBY() //  [R1]
         { info_tbl: [(c4qBY,
                       label: block_c4qBY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qBY: // global
           I64[Sp - 8] = block_c4qC4_info;
           _s4lmX::P64 = R1;
           _s4lmY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lmY::I64;
           P64[Sp + 8] = _s4lmX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qD4; else goto c4qC8;
       u4qD4: // global
           call _c4qC4(R1) args: 0, res: 0, upd: 0;
       c4qC8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qC4() //  [R1]
         { info_tbl: [(c4qC4,
                       label: block_c4qC4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qC4: // global
           _s4ln4::I64 = -I64[R1 + 7] & 31;
           if (_s4ln4::I64 != 0) goto u4qD2; else goto c4qCY;
       u4qD2: // global
           I64[Sp + 16] = _s4ln4::I64;
           Sp = Sp + 8;
           call _c4qCq() args: 0, res: 0, upd: 0;
       c4qCY: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qCq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qCq: // global
           Hp = Hp + 16;
           _s4ln4::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4qCV; else goto c4qCU;
       c4qCV: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4qCp_info;
           R1 = _s4ln4::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4qCU: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4ln5::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4ln5::I64 << _s4ln4::I64) | (_s4ln5::I64 >> 32 - _s4ln4::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qCp() //  [R1]
         { info_tbl: [(c4qCp,
                       label: block_c4qCp_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qCp: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4qCq() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.863672242 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt32_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt32_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt32_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4qDf,
                       label: GHC.Int.$fBitsInt32_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qDf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qDj; else goto c4qDk;
       c4qDj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qDk: // global
           I64[Sp - 16] = block_c4qDc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qDT; else goto c4qDd;
       u4qDT: // global
           call _c4qDc(R1) args: 0, res: 0, upd: 0;
       c4qDd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qDc() //  [R1]
         { info_tbl: [(c4qDc,
                       label: block_c4qDc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qDc: // global
           I64[Sp - 8] = block_c4qDi_info;
           _s4lnf::P64 = R1;
           _s4lng::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lng::I64;
           P64[Sp + 8] = _s4lnf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qDS; else goto c4qDm;
       u4qDS: // global
           call _c4qDi(R1) args: 0, res: 0, upd: 0;
       c4qDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qDi() //  [R1]
         { info_tbl: [(c4qDi,
                       label: block_c4qDi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qDi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qDs; else goto c4qDr;
       c4qDs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qDr: // global
           _s4lni::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lni::I64, 64)) goto c4qDQ; else goto c4qDR;
       c4qDQ: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lni::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qDR: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.865815313 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cclearBit_closure" {
     GHC.Int.$fBitsInt32_$cclearBit_closure:
         const GHC.Int.$fBitsInt32_$cclearBit_info;
 },
 GHC.Int.$fBitsInt32_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4qE1,
                       label: GHC.Int.$fBitsInt32_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qE1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qE5; else goto c4qE6;
       c4qE5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qE6: // global
           I64[Sp - 16] = block_c4qDY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qET; else goto c4qDZ;
       u4qET: // global
           call _c4qDY(R1) args: 0, res: 0, upd: 0;
       c4qDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qDY() //  [R1]
         { info_tbl: [(c4qDY,
                       label: block_c4qDY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qDY: // global
           I64[Sp] = block_c4qE4_info;
           _s4lnt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lnt::I64;
           if (R1 & 7 != 0) goto u4qES; else goto c4qE8;
       u4qES: // global
           call _c4qE4(R1) args: 0, res: 0, upd: 0;
       c4qE8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qE4() //  [R1]
         { info_tbl: [(c4qE4,
                       label: block_c4qE4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qE4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qEe; else goto c4qEd;
       c4qEe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qEd: // global
           _s4lnt::I64 = I64[Sp + 8];
           _s4lnv::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lnv::I64, 64)) goto c4qEF; else goto c4qER;
       c4qEF: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lnt::I64 & ~%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lnv::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qER: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lnt::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.867802494 UTC

[section ""data" . GHC.Int.$fBitsInt32_$csetBit_closure" {
     GHC.Int.$fBitsInt32_$csetBit_closure:
         const GHC.Int.$fBitsInt32_$csetBit_info;
 },
 GHC.Int.$fBitsInt32_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4qF1,
                       label: GHC.Int.$fBitsInt32_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qF1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qF5; else goto c4qF6;
       c4qF5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qF6: // global
           I64[Sp - 16] = block_c4qEY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qFF; else goto c4qEZ;
       u4qFF: // global
           call _c4qEY(R1) args: 0, res: 0, upd: 0;
       c4qEZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qEY() //  [R1]
         { info_tbl: [(c4qEY,
                       label: block_c4qEY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qEY: // global
           I64[Sp - 8] = block_c4qF4_info;
           _s4lnJ::P64 = R1;
           _s4lnK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lnK::I64;
           P64[Sp + 8] = _s4lnJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qFE; else goto c4qF8;
       u4qFE: // global
           call _c4qF4(R1) args: 0, res: 0, upd: 0;
       c4qF8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qF4() //  [R1]
         { info_tbl: [(c4qF4,
                       label: block_c4qF4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qF4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qFe; else goto c4qFd;
       c4qFe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qFd: // global
           _s4lnM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lnM::I64, 64)) goto c4qFC; else goto c4qFD;
       c4qFC: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lnM::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qFD: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.86988945 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateL_closure" {
     GHC.Int.$fBitsInt32_$crotateL_closure:
         const GHC.Int.$fBitsInt32_$crotateL_info;
 },
 GHC.Int.$fBitsInt32_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4qFK,
                       label: GHC.Int.$fBitsInt32_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qFK: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt32_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.870646672 UTC

[section ""data" . GHC.Int.$fBitsInt32_closure" {
     GHC.Int.$fBitsInt32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fBitsInt32_$c.&._closure+2;
         const GHC.Int.$fBitsInt32_$c.|._closure+2;
         const GHC.Int.$fBitsInt32_$cxor_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt32_$cshift_closure+2;
         const GHC.Int.$fBitsInt32_$crotate_closure+2;
         const GHC.Int.$fBitsInt6_closure+1;
         const GHC.Int.$fBitsInt32_$cbit_closure+1;
         const GHC.Int.$fBitsInt32_$csetBit_closure+2;
         const GHC.Int.$fBitsInt32_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt32_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt32_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt32_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt32_$crotateL_closure+2;
         const GHC.Int.$fBitsInt32_$crotateR_closure+2;
         const GHC.Int.$fBitsInt32_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.871390872 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_closure" {
     GHC.Int.$fFiniteBitsInt32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt32_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.87295283 UTC

[section ""data" . GHC.Int.$fReadInt32_go_closure" {
     GHC.Int.$fReadInt32_go_closure:
         const GHC.Int.$fReadInt32_go_info;
 },
 sat_s4lo6_entry() //  [R1]
         { info_tbl: [(c4qG6,
                       label: sat_s4lo6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qG6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qG7; else goto c4qG8;
       c4qG7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4qG8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lo4_entry() //  [R1]
         { info_tbl: [(c4qGg,
                       label: sat_s4lo4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qGg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qGn; else goto c4qGo;
       c4qGn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4qGo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4qGd_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4qGs; else goto c4qGe;
       u4qGs: // global
           call _c4qGd(R1) args: 0, res: 0, upd: 0;
       c4qGe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4qGd() //  [R1]
         { info_tbl: [(c4qGd,
                       label: block_c4qGd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qGd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qGr; else goto c4qGq;
       c4qGr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4qGq: // global
           _s4lo3::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lo3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt32_go_entry() //  [R2]
         { info_tbl: [(c4qGx,
                       label: GHC.Int.$fReadInt32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qGx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qGy; else goto c4qGz;
       c4qGy: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qGz: // global
           I64[Sp - 8] = block_c4qFR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qGJ; else goto c4qFS;
       u4qGJ: // global
           call _c4qFR(R1) args: 0, res: 0, upd: 0;
       c4qFS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qFR() //  [R1]
         { info_tbl: [(c4qFR,
                       label: block_c4qFR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qFR: // global
           if (R1 & 7 == 1) goto c4qGu; else goto c4qGv;
       c4qGu: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qGv: // global
           I64[Sp - 8] = block_c4qFX_info;
           _s4lnX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lnX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qGI; else goto c4qFY;
       u4qGI: // global
           call _c4qFX(R1) args: 0, res: 0, upd: 0;
       c4qFY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qFX() //  [R1]
         { info_tbl: [(c4qFX,
                       label: block_c4qFX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qFX: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4qGH; else goto c4qGG;
       c4qGH: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qGG: // global
           _s4lnZ::P64 = P64[R1 + 7];
           _s4lo0::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lo6_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lo4_info;
           P64[Hp - 48] = _s4lnZ::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lo0::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.876721924 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadsPrec_closure" {
     GHC.Int.$fReadInt32_$creadsPrec_closure:
         const GHC.Int.$fReadInt32_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4qGQ,
                       label: GHC.Int.$fReadInt32_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qGQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qGU; else goto c4qGV;
       c4qGU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qGV: // global
           I64[Sp - 16] = block_c4qGO_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lo8::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lo8::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qGO() //  [R1]
         { info_tbl: [(c4qGO,
                       label: block_c4qGO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qGO: // global
           _s4lo8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4qGT_info;
           R3 = _s4lo8::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qGT() //  [R1]
         { info_tbl: [(c4qGT,
                       label: block_c4qGT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qGT: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.878368453 UTC

[section ""data" . GHC.Int.$fReadInt6_closure" {
     GHC.Int.$fReadInt6_closure:
         const GHC.Int.$fReadInt6_info;
         const 0;
 },
 sat_s4lod_entry() //  [R1, R2]
         { info_tbl: [(c4qHa,
                       label: sat_s4lod_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qHa: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt32_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt6_entry() //  [R2, R3]
         { info_tbl: [(c4qHg,
                       label: GHC.Int.$fReadInt6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qHg: // global
           _s4loc::P64 = R3;
           _s4lob::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4qHh; else goto c4qHi;
       c4qHi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qHk; else goto c4qHj;
       c4qHk: // global
           HpAlloc = 16;
           goto c4qHh;
       c4qHh: // global
           R3 = _s4loc::P64;
           R2 = _s4lob::P64;
           R1 = GHC.Int.$fReadInt6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qHj: // global
           I64[Hp - 8] = sat_s4lod_info;
           P64[Hp] = _s4lob::P64;
           I64[Sp - 8] = block_c4qHd_info;
           R3 = _s4loc::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qHd() //  [R1]
         { info_tbl: [(c4qHd,
                       label: block_c4qHd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qHd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qHn; else goto c4qHm;
       c4qHn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qHm: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.879913504 UTC

[section ""data" . GHC.Int.$fReadInt5_closure" {
     GHC.Int.$fReadInt5_closure:
         const GHC.Int.$fReadInt5_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4qHx_srtd" {
     u4qHx_srtd:
         const S4lDl_srt+504;
         const 46;
         const 35184372088833;
 },
 GHC.Int.$fReadInt5_entry() //  [R1]
         { info_tbl: [(c4qHu,
                       label: GHC.Int.$fReadInt5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qHu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4qHv; else goto c4qHw;
       c4qHv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4qHw: // global
           (_c4qHr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4qHr::I64 == 0) goto c4qHt; else goto c4qHs;
       c4qHt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4qHs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4qHr::I64;
           R2 = GHC.Int.$fReadInt6_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.881225231 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadList_closure" {
     GHC.Int.$fReadInt32_$creadList_closure:
         const GHC.Int.$fReadInt32_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadList_entry() //  [R2]
         { info_tbl: [(c4qHC,
                       label: GHC.Int.$fReadInt32_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qHC: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt5_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.882459574 UTC

[section ""data" . GHC.Int.$fReadInt4_closure" {
     GHC.Int.$fReadInt4_closure:
         const GHC.Int.$fReadInt4_info;
         const 0;
 },
 GHC.Int.$fReadInt4_entry() //  [R2, R3]
         { info_tbl: [(c4qHM,
                       label: GHC.Int.$fReadInt4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qHM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qHN; else goto c4qHO;
       c4qHN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qHO: // global
           I64[Sp - 8] = block_c4qHJ_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt32_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qHJ() //  [R1]
         { info_tbl: [(c4qHJ,
                       label: block_c4qHJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qHJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qHR; else goto c4qHQ;
       c4qHR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qHQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.883503699 UTC

[section ""data" . GHC.Int.$fReadInt32_closure" {
     GHC.Int.$fReadInt32_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt32_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt32_$creadList_closure+1;
         const GHC.Int.$fReadInt6_closure+2;
         const GHC.Int.$fReadInt4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.884702729 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquot_closure" {
     GHC.Int.$fIntegralInt32_$cquot_closure:
         const GHC.Int.$fIntegralInt32_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4qHZ,
                       label: GHC.Int.$fIntegralInt32_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qHZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qI3; else goto c4qI4;
       c4qI3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qI4: // global
           I64[Sp - 16] = block_c4qHW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qIF; else goto c4qHX;
       u4qIF: // global
           call _c4qHW(R1) args: 0, res: 0, upd: 0;
       c4qHX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qHW() //  [R1]
         { info_tbl: [(c4qHW,
                       label: block_c4qHW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qHW: // global
           I64[Sp] = block_c4qI2_info;
           _s4lon::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lon::I64;
           if (R1 & 7 != 0) goto u4qIE; else goto c4qI6;
       u4qIE: // global
           call _c4qI2(R1) args: 0, res: 0, upd: 0;
       c4qI6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qI2() //  [R1]
         { info_tbl: [(c4qI2,
                       label: block_c4qI2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qI2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qIc; else goto c4qIb;
       c4qIc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qIb: // global
           _s4lon::I64 = I64[Sp + 8];
           _s4loq::I64 = I64[R1 + 7];
           if (_s4loq::I64 != (-1)) goto u4qID; else goto c4qIB;
       u4qID: // global
           if (_s4loq::I64 != 0) goto c4qIn; else goto c4qIC;
       c4qIn: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4lon::I64,
                                                                            _s4loq::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qIC: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qIB: // global
           if (_s4lon::I64 == (-2147483648)) goto c4qIA; else goto c4qIz;
       c4qIA: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qIz: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4lon::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.886944299 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$crem_closure" {
     GHC.Int.$fIntegralInt32_$crem_closure:
         const GHC.Int.$fIntegralInt32_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4qIN,
                       label: GHC.Int.$fIntegralInt32_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qIN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qIR; else goto c4qIS;
       c4qIR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qIS: // global
           I64[Sp - 16] = block_c4qIK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qJg; else goto c4qIL;
       u4qJg: // global
           call _c4qIK(R1) args: 0, res: 0, upd: 0;
       c4qIL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qIK() //  [R1]
         { info_tbl: [(c4qIK,
                       label: block_c4qIK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qIK: // global
           I64[Sp] = block_c4qIQ_info;
           _s4loB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loB::I64;
           if (R1 & 7 != 0) goto u4qJf; else goto c4qIU;
       u4qJf: // global
           call _c4qIQ(R1) args: 0, res: 0, upd: 0;
       c4qIU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qIQ() //  [R1]
         { info_tbl: [(c4qIQ,
                       label: block_c4qIQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qIQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qJ0; else goto c4qIZ;
       c4qJ0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qIZ: // global
           _s4loE::I64 = I64[R1 + 7];
           if (_s4loE::I64 != (-1)) goto u4qJe; else goto c4qJc;
       u4qJe: // global
           if (_s4loE::I64 != 0) goto c4qJb; else goto c4qJd;
       c4qJb: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4loE::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qJd: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qJc: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.888848494 UTC

[section ""data" . GHC.Int.$w$cdiv1_closure" {
     GHC.Int.$w$cdiv1_closure:
         const GHC.Int.$w$cdiv1_info;
         const 0;
 },
 GHC.Int.$w$cdiv1_entry() //  [R2, R3]
         { info_tbl: [(c4qJq,
                       label: GHC.Int.$w$cdiv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qJq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qJr; else goto c4qJs;
       c4qJr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qJs: // global
           if (R3 == (-1)) goto c4qJo; else goto u4qJM;
       c4qJo: // global
           if (R2 == (-2147483648)) goto c4qJL; else goto c4qJJ;
       c4qJL: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qJJ: // global
           I64[Sp - 8] = block_c4qJD_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4qJM: // global
           if (R3 == 0) goto c4qJp; else goto c4qJn;
       c4qJp: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qJn: // global
           I64[Sp - 8] = block_c4qJu_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qJD() //  [R1]
         { info_tbl: [(c4qJD,
                       label: block_c4qJD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qJD: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qJu() //  [R1]
         { info_tbl: [(c4qJu,
                       label: block_c4qJu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qJu: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.890803592 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdiv_closure" {
     GHC.Int.$fIntegralInt32_$cdiv_closure:
         const GHC.Int.$fIntegralInt32_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4qJU,
                       label: GHC.Int.$fIntegralInt32_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qJU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qK7; else goto c4qK8;
       c4qK7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qK8: // global
           I64[Sp - 16] = block_c4qJR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qKf; else goto c4qJS;
       u4qKf: // global
           call _c4qJR(R1) args: 0, res: 0, upd: 0;
       c4qJS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qJR() //  [R1]
         { info_tbl: [(c4qJR,
                       label: block_c4qJR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qJR: // global
           I64[Sp] = block_c4qJX_info;
           _s4loS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loS::I64;
           if (R1 & 7 != 0) goto u4qKe; else goto c4qJY;
       u4qKe: // global
           call _c4qJX(R1) args: 0, res: 0, upd: 0;
       c4qJY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qJX() //  [R1]
         { info_tbl: [(c4qJX,
                       label: block_c4qJX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qJX: // global
           _s4loS::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4qK2_info;
           R3 = I64[R1 + 7];
           R2 = _s4loS::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qK2() //  [R1]
         { info_tbl: [(c4qK2,
                       label: block_c4qK2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qK2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qKd; else goto c4qKc;
       c4qKd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4qKc: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.892930834 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cmod_closure" {
     GHC.Int.$fIntegralInt32_$cmod_closure:
         const GHC.Int.$fIntegralInt32_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4qKn,
                       label: GHC.Int.$fIntegralInt32_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qKr; else goto c4qKs;
       c4qKr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qKs: // global
           I64[Sp - 16] = block_c4qKk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qKS; else goto c4qKl;
       u4qKS: // global
           call _c4qKk(R1) args: 0, res: 0, upd: 0;
       c4qKl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qKk() //  [R1]
         { info_tbl: [(c4qKk,
                       label: block_c4qKk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qKk: // global
           I64[Sp] = block_c4qKq_info;
           _s4loZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loZ::I64;
           if (R1 & 7 != 0) goto u4qKR; else goto c4qKu;
       u4qKR: // global
           call _c4qKq(R1) args: 0, res: 0, upd: 0;
       c4qKu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qKq() //  [R1]
         { info_tbl: [(c4qKq,
                       label: block_c4qKq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qKq: // global
           _s4lp2::I64 = I64[R1 + 7];
           if (_s4lp2::I64 != (-1)) goto u4qKQ; else goto c4qKO;
       u4qKQ: // global
           if (_s4lp2::I64 != 0) goto c4qKK; else goto c4qKP;
       c4qKK: // global
           _s4loZ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4qKB_info;
           R3 = _s4lp2::I64;
           R2 = _s4loZ::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4qKP: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qKO: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qKB() //  [R1]
         { info_tbl: [(c4qKB,
                       label: block_c4qKB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qKB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qKN; else goto c4qKM;
       c4qKN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4qKM: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.894760433 UTC

[section ""data" . lvl8_r4kPz_closure" {
     lvl8_r4kPz_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt6_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.89606373 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquotRem_closure" {
     GHC.Int.$fIntegralInt32_$cquotRem_closure:
         const GHC.Int.$fIntegralInt32_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4qL0,
                       label: GHC.Int.$fIntegralInt32_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qL0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qL4; else goto c4qL5;
       c4qL4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qL5: // global
           I64[Sp - 16] = block_c4qKX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qLK; else goto c4qKY;
       u4qLK: // global
           call _c4qKX(R1) args: 0, res: 0, upd: 0;
       c4qKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qKX() //  [R1]
         { info_tbl: [(c4qKX,
                       label: block_c4qKX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qKX: // global
           I64[Sp] = block_c4qL3_info;
           _s4lp9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lp9::I64;
           if (R1 & 7 != 0) goto u4qLJ; else goto c4qL7;
       u4qLJ: // global
           call _c4qL3(R1) args: 0, res: 0, upd: 0;
       c4qL7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qL3() //  [R1]
         { info_tbl: [(c4qL3,
                       label: block_c4qL3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qL3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4qLd; else goto c4qLc;
       c4qLd: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qLc: // global
           _s4lp9::I64 = I64[Sp + 8];
           _s4lpc::I64 = I64[R1 + 7];
           if (_s4lpc::I64 != (-1)) goto u4qLI; else goto c4qLG;
       u4qLI: // global
           if (_s4lpc::I64 != 0) goto c4qLq; else goto c4qLH;
       c4qLq: // global
           (_s4lpe::I64, _s4lpf::I64) = call MO_S_QuotRem W64(_s4lp9::I64, _s4lpc::I64);
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpf::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpe::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qLH: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qLG: // global
           if (_s4lp9::I64 == (-2147483648)) goto c4qLF; else goto c4qLE;
       c4qLF: // global
           Hp = Hp - 56;
           R1 = lvl8_r4kPz_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qLE: // global
           (_s4lpm::I64, _s4lpn::I64) = call MO_S_QuotRem W64(_s4lp9::I64, (-1));
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpn::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpm::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.900249359 UTC

[section ""data" . GHC.Int.$w$cdivMod1_closure" {
     GHC.Int.$w$cdivMod1_closure:
         const GHC.Int.$w$cdivMod1_info;
         const 0;
 },
 GHC.Int.$w$cdivMod1_entry() //  [R2, R3]
         { info_tbl: [(c4qLT,
                       label: GHC.Int.$w$cdivMod1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qLT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qLU; else goto c4qLV;
       c4qLU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qLV: // global
           if (R3 == 0) goto c4qLS; else goto c4qLR;
       c4qLS: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4qLR: // global
           if (R3 == (-1)) goto c4qOo; else goto u4qOp;
       c4qOo: // global
           if (R2 == (-2147483648)) goto c4qOn; else goto u4qOq;
       c4qOn: // global
           R2 = GHC.Int.$fBitsInt6_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4qOq: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4qOs;
       u4qOp: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4qOs;
       u4qOs: // global
           call _c4qM0() args: 0, res: 0, upd: 0;
     }
 },
 _c4qM0() //  []
         { info_tbl: [(c4qM0,
                       label: block_c4qM0_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qM0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4qM4; else goto c4qM3;
       c4qM4: // global
           HpAlloc = 32;
           I64[Sp] = block_c4qM0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4qM3: // global
           _s4lpt::I64 = I64[Sp + 8];
           _s4lpv::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lpt::I64, 0)) goto c4qMX; else goto c4qOe;
       c4qMX: // global
           if (%MO_S_Ge_W64(_s4lpt::I64, 0)) goto c4qMk; else goto c4qMV;
       c4qMk: // global
           (_s4lpA::I64, _s4lpB::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpB::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpA::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qMV: // global
           if (%MO_S_Le_W64(_s4lpv::I64, 0)) goto c4qMy; else goto c4qMU;
       c4qMy: // global
           (_s4lpI::I64, _s4lpJ::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpJ::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpI::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qMU: // global
           (_s4lpQ::I64, _s4lpR::I64) = call MO_S_QuotRem W64(_s4lpt::I64 + 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpR::I64 + _s4lpv::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpQ::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qOe: // global
           if (%MO_S_Ge_W64(_s4lpv::I64, 0)) goto c4qNR; else goto c4qOd;
       c4qNR: // global
           if (%MO_S_Ge_W64(_s4lpt::I64, 0)) goto c4qNe; else goto c4qNP;
       c4qNe: // global
           (_s4lq2::I64, _s4lq3::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lq3::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lq2::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qNP: // global
           if (%MO_S_Le_W64(_s4lpv::I64, 0)) goto c4qNs; else goto c4qNO;
       c4qNs: // global
           (_s4lqa::I64, _s4lqb::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqb::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqa::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qNO: // global
           (_s4lqi::I64, _s4lqj::I64) = call MO_S_QuotRem W64(_s4lpt::I64 + 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqj::I64 + _s4lpv::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqi::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4qOd: // global
           (_s4lqt::I64, _s4lqu::I64) = call MO_S_QuotRem W64(_s4lpt::I64 - 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqu::I64 + _s4lpv::I64 + 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqt::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.903464414 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdivMod_closure" {
     GHC.Int.$fIntegralInt32_$cdivMod_closure:
         const GHC.Int.$fIntegralInt32_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4qOA,
                       label: GHC.Int.$fIntegralInt32_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qOA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qOL; else goto c4qOM;
       c4qOL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qOM: // global
           I64[Sp - 16] = block_c4qOx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qOT; else goto c4qOy;
       u4qOT: // global
           call _c4qOx(R1) args: 0, res: 0, upd: 0;
       c4qOy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qOx() //  [R1]
         { info_tbl: [(c4qOx,
                       label: block_c4qOx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qOx: // global
           I64[Sp] = block_c4qOD_info;
           _s4lqI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lqI::I64;
           if (R1 & 7 != 0) goto u4qOS; else goto c4qOE;
       u4qOS: // global
           call _c4qOD(R1) args: 0, res: 0, upd: 0;
       c4qOE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qOD() //  [R1]
         { info_tbl: [(c4qOD,
                       label: block_c4qOD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qOD: // global
           _s4lqI::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4qOI_info;
           R3 = I64[R1 + 7];
           R2 = _s4lqI::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qOI() //  [R1, R2]
         { info_tbl: [(c4qOI,
                       label: block_c4qOI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qOI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4qOR; else goto c4qOQ;
       c4qOR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4qOQ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.90606146 UTC

[section ""data" . GHC.Int.$fRealInt32_$ctoRational_closure" {
     GHC.Int.$fRealInt32_$ctoRational_closure:
         const GHC.Int.$fRealInt32_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt32_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4qP1,
                       label: GHC.Int.$fRealInt32_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qP1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qPf; else goto c4qPg;
       c4qPf: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qPg: // global
           I64[Sp - 8] = block_c4qOY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qPn; else goto c4qOZ;
       u4qPn: // global
           call _c4qOY(R1) args: 0, res: 0, upd: 0;
       c4qOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qOY() //  [R1]
         { info_tbl: [(c4qOY,
                       label: block_c4qOY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qOY: // global
           I64[Sp] = block_c4qP4_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qP4() //  [R1]
         { info_tbl: [(c4qP4,
                       label: block_c4qP4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qP4: // global
           I64[Sp] = block_c4qP8_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qP8() //  [R1]
         { info_tbl: [(c4qP8,
                       label: block_c4qP8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qP8: // global
           I64[Sp] = block_c4qPc_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4qPc() //  [R1, R2]
         { info_tbl: [(c4qPc,
                       label: block_c4qPc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qPc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4qPm; else goto c4qPl;
       c4qPm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4qPl: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.908541513 UTC

[section ""data" . GHC.Int.$fRealInt32_closure" {
     GHC.Int.$fRealInt32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt32_closure+1;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fRealInt32_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.909476986 UTC

[section ""data" . GHC.Int.$fIntegralInt32_closure" {
     GHC.Int.$fIntegralInt32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt32_closure+1;
         const GHC.Int.$fEnumInt32_closure+1;
         const GHC.Int.$fIntegralInt32_$cquot_closure+2;
         const GHC.Int.$fIntegralInt32_$crem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt32_$cmod_closure+2;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt32_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.910773804 UTC

[section ""data" . GHC.Int.$fIxInt32_$crange_closure" {
     GHC.Int.$fIxInt32_$crange_closure:
         const GHC.Int.$fIxInt32_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$crange_entry() //  [R2]
         { info_tbl: [(c4qPv,
                       label: GHC.Int.$fIxInt32_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qPv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qPw; else goto c4qPx;
       c4qPw: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qPx: // global
           I64[Sp - 8] = block_c4qPs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qPB; else goto c4qPt;
       u4qPB: // global
           call _c4qPs(R1) args: 0, res: 0, upd: 0;
       c4qPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qPs() //  [R1]
         { info_tbl: [(c4qPs,
                       label: block_c4qPs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qPs: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.912929109 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt32_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt32_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt32_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4qPJ,
                       label: GHC.Int.$fIxInt32_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qPJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qQ0; else goto c4qQ1;
       c4qQ0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qQ1: // global
           I64[Sp - 16] = block_c4qPG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qQ8; else goto c4qPH;
       u4qQ8: // global
           call _c4qPG(R1) args: 0, res: 0, upd: 0;
       c4qPH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qPG() //  [R1]
         { info_tbl: [(c4qPG,
                       label: block_c4qPG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qPG: // global
           I64[Sp] = block_c4qPM_info;
           _s4lr3::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lr3::P64;
           if (R1 & 7 != 0) goto u4qQ7; else goto c4qPN;
       u4qQ7: // global
           call _c4qPM(R1) args: 0, res: 0, upd: 0;
       c4qPN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qPM() //  [R1]
         { info_tbl: [(c4qPM,
                       label: block_c4qPM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qPM: // global
           I64[Sp] = block_c4qPR_info;
           _s4lr6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lr6::I64;
           if (R1 & 7 != 0) goto u4qQ9; else goto c4qPS;
       u4qQ9: // global
           call _c4qPR(R1) args: 0, res: 0, upd: 0;
       c4qPS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qPR() //  [R1]
         { info_tbl: [(c4qPR,
                       label: block_c4qPR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qPR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qQ6; else goto c4qQ5;
       c4qQ6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qQ5: // global
           _s4lr9::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lr9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.915952334 UTC

[section ""data" . GHC.Int.$fIxInt32_$crangeSize_closure" {
     GHC.Int.$fIxInt32_$crangeSize_closure:
         const GHC.Int.$fIxInt32_$crangeSize_info;
 },
 GHC.Int.$fIxInt32_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4qQh,
                       label: GHC.Int.$fIxInt32_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qQh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qQq; else goto c4qQr;
       c4qQq: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qQr: // global
           I64[Sp - 8] = block_c4qQe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qQQ; else goto c4qQf;
       u4qQQ: // global
           call _c4qQe(R1) args: 0, res: 0, upd: 0;
       c4qQf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qQe() //  [R1]
         { info_tbl: [(c4qQe,
                       label: block_c4qQe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qQe: // global
           I64[Sp - 8] = block_c4qQk_info;
           _s4lrd::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lrd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qQP; else goto c4qQl;
       u4qQP: // global
           call _c4qQk(R1) args: 0, res: 0, upd: 0;
       c4qQl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qQk() //  [R1]
         { info_tbl: [(c4qQk,
                       label: block_c4qQk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qQk: // global
           I64[Sp] = block_c4qQp_info;
           _s4lrf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrf::I64;
           if (R1 & 7 != 0) goto u4qQR; else goto c4qQu;
       u4qQR: // global
           call _c4qQp(R1) args: 0, res: 0, upd: 0;
       c4qQu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qQp() //  [R1]
         { info_tbl: [(c4qQp,
                       label: block_c4qQp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qQp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qQA; else goto c4qQz;
       c4qQA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qQz: // global
           _s4lrf::I64 = I64[Sp + 8];
           _s4lrh::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lrf::I64,
                            _s4lrh::I64)) goto c4qQE; else goto c4qQO;
       c4qQE: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qQO: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lrh::I64 - _s4lrf::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.918311088 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt32_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt32_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4qQZ,
                       label: GHC.Int.$fIxInt32_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qQZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qRj; else goto c4qRk;
       c4qRj: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qRk: // global
           I64[Sp - 8] = block_c4qQW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qRr; else goto c4qQX;
       u4qRr: // global
           call _c4qQW(R1) args: 0, res: 0, upd: 0;
       c4qQX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qQW() //  [R1]
         { info_tbl: [(c4qQW,
                       label: block_c4qQW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qQW: // global
           I64[Sp - 8] = block_c4qR2_info;
           _s4lrn::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lrn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qRq; else goto c4qR3;
       u4qRq: // global
           call _c4qR2(R1) args: 0, res: 0, upd: 0;
       c4qR3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qR2() //  [R1]
         { info_tbl: [(c4qR2,
                       label: block_c4qR2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qR2: // global
           I64[Sp] = block_c4qR7_info;
           _s4lrq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrq::I64;
           if (R1 & 7 != 0) goto u4qRs; else goto c4qR8;
       u4qRs: // global
           call _c4qR7(R1) args: 0, res: 0, upd: 0;
       c4qR8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qR7() //  [R1]
         { info_tbl: [(c4qR7,
                       label: block_c4qR7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qR7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qRp; else goto c4qRo;
       c4qRp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qRo: // global
           _s4lru::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lru::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.920425894 UTC

[section ""data" . GHC.Int.$fIxInt32_$cindex_closure" {
     GHC.Int.$fIxInt32_$cindex_closure:
         const GHC.Int.$fIxInt32_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4qRA,
                       label: GHC.Int.$fIxInt32_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qRA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qRJ; else goto c4qRK;
       c4qRJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qRK: // global
           I64[Sp - 16] = block_c4qRx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qSj; else goto c4qRy;
       u4qSj: // global
           call _c4qRx(R1) args: 0, res: 0, upd: 0;
       c4qRy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qRx() //  [R1]
         { info_tbl: [(c4qRx,
                       label: block_c4qRx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qRx: // global
           I64[Sp - 8] = block_c4qRD_info;
           _s4lrz::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lrz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qSi; else goto c4qRE;
       u4qSi: // global
           call _c4qRD(R1) args: 0, res: 0, upd: 0;
       c4qRE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qRD() //  [R1]
         { info_tbl: [(c4qRD,
                       label: block_c4qRD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qRD: // global
           I64[Sp] = block_c4qRI_info;
           _s4lrB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lrB::I64;
           if (R1 & 7 != 0) goto u4qSk; else goto c4qRN;
       u4qSk: // global
           call _c4qRI(R1) args: 0, res: 0, upd: 0;
       c4qRN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qRI() //  [R1]
         { info_tbl: [(c4qRI,
                       label: block_c4qRI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qRI: // global
           _s4lrD::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lrD::I64)) goto c4qRV; else goto c4qRZ;
       c4qRV: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4qRZ: // global
           I64[Sp] = block_c4qRY_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrD::I64;
           if (R1 & 7 != 0) goto u4qSl; else goto c4qS0;
       u4qSl: // global
           call _c4qRY(R1) args: 0, res: 0, upd: 0;
       c4qS0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qRY() //  [R1]
         { info_tbl: [(c4qRY,
                       label: block_c4qRY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qRY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qS6; else goto c4qS5;
       c4qS6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qS5: // global
           _s4lrD::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4lrD::I64,
                            I64[R1 + 7])) goto c4qSa; else goto c4qSh;
       c4qSa: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4qSh: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lrD::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.922632992 UTC

[section ""data" . GHC.Int.$fIxInt32_closure" {
     GHC.Int.$fIxInt32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fIxInt32_$crange_closure+1;
         const GHC.Int.$fIxInt32_$cindex_closure+2;
         const GHC.Int.$fIxInt32_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt32_$cinRange_closure+2;
         const GHC.Int.$fIxInt32_$crangeSize_closure+1;
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.923648679 UTC

[section ""data" . GHC.Int.eqInt64_closure" {
     GHC.Int.eqInt64_closure:
         const GHC.Int.eqInt64_info;
 },
 GHC.Int.eqInt64_entry() //  [R2, R3]
         { info_tbl: [(c4qSt,
                       label: GHC.Int.eqInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qSt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qSx; else goto c4qSy;
       c4qSx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qSy: // global
           I64[Sp - 16] = block_c4qSq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qSH; else goto c4qSr;
       u4qSH: // global
           call _c4qSq(R1) args: 0, res: 0, upd: 0;
       c4qSr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qSq() //  [R1]
         { info_tbl: [(c4qSq,
                       label: block_c4qSq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qSq: // global
           I64[Sp] = block_c4qSw_info;
           _s4lrM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrM::I64;
           if (R1 & 7 != 0) goto u4qSG; else goto c4qSA;
       u4qSG: // global
           call _c4qSw(R1) args: 0, res: 0, upd: 0;
       c4qSA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qSw() //  [R1]
         { info_tbl: [(c4qSw,
                       label: block_c4qSw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qSw: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.926077501 UTC

[section ""data" . GHC.Int.$fEqInt64_closure" {
     GHC.Int.$fEqInt64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt64_closure+2;
         const GHC.Int.neInt64_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.927014712 UTC

[section ""data" . GHC.Int.gtInt64_closure" {
     GHC.Int.gtInt64_closure:
         const GHC.Int.gtInt64_info;
 },
 GHC.Int.gtInt64_entry() //  [R2, R3]
         { info_tbl: [(c4qSP,
                       label: GHC.Int.gtInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qSP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qST; else goto c4qSU;
       c4qST: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qSU: // global
           I64[Sp - 16] = block_c4qSM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qT3; else goto c4qSN;
       u4qT3: // global
           call _c4qSM(R1) args: 0, res: 0, upd: 0;
       c4qSN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qSM() //  [R1]
         { info_tbl: [(c4qSM,
                       label: block_c4qSM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qSM: // global
           I64[Sp] = block_c4qSS_info;
           _s4lrT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrT::I64;
           if (R1 & 7 != 0) goto u4qT2; else goto c4qSW;
       u4qT2: // global
           call _c4qSS(R1) args: 0, res: 0, upd: 0;
       c4qSW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qSS() //  [R1]
         { info_tbl: [(c4qSS,
                       label: block_c4qSS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qSS: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.928520994 UTC

[section ""data" . GHC.Int.geInt64_closure" {
     GHC.Int.geInt64_closure:
         const GHC.Int.geInt64_info;
 },
 GHC.Int.geInt64_entry() //  [R2, R3]
         { info_tbl: [(c4qTb,
                       label: GHC.Int.geInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qTb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qTf; else goto c4qTg;
       c4qTf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qTg: // global
           I64[Sp - 16] = block_c4qT8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qTp; else goto c4qT9;
       u4qTp: // global
           call _c4qT8(R1) args: 0, res: 0, upd: 0;
       c4qT9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qT8() //  [R1]
         { info_tbl: [(c4qT8,
                       label: block_c4qT8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qT8: // global
           I64[Sp] = block_c4qTe_info;
           _s4ls0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ls0::I64;
           if (R1 & 7 != 0) goto u4qTo; else goto c4qTi;
       u4qTo: // global
           call _c4qTe(R1) args: 0, res: 0, upd: 0;
       c4qTi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qTe() //  [R1]
         { info_tbl: [(c4qTe,
                       label: block_c4qTe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qTe: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.930055327 UTC

[section ""data" . GHC.Int.ltInt64_closure" {
     GHC.Int.ltInt64_closure:
         const GHC.Int.ltInt64_info;
 },
 GHC.Int.ltInt64_entry() //  [R2, R3]
         { info_tbl: [(c4qTx,
                       label: GHC.Int.ltInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qTx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qTB; else goto c4qTC;
       c4qTB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qTC: // global
           I64[Sp - 16] = block_c4qTu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qTL; else goto c4qTv;
       u4qTL: // global
           call _c4qTu(R1) args: 0, res: 0, upd: 0;
       c4qTv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qTu() //  [R1]
         { info_tbl: [(c4qTu,
                       label: block_c4qTu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qTu: // global
           I64[Sp] = block_c4qTA_info;
           _s4ls7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ls7::I64;
           if (R1 & 7 != 0) goto u4qTK; else goto c4qTE;
       u4qTK: // global
           call _c4qTA(R1) args: 0, res: 0, upd: 0;
       c4qTE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qTA() //  [R1]
         { info_tbl: [(c4qTA,
                       label: block_c4qTA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qTA: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.931572885 UTC

[section ""data" . GHC.Int.leInt64_closure" {
     GHC.Int.leInt64_closure:
         const GHC.Int.leInt64_info;
 },
 GHC.Int.leInt64_entry() //  [R2, R3]
         { info_tbl: [(c4qTT,
                       label: GHC.Int.leInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qTT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qTX; else goto c4qTY;
       c4qTX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qTY: // global
           I64[Sp - 16] = block_c4qTQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qU7; else goto c4qTR;
       u4qU7: // global
           call _c4qTQ(R1) args: 0, res: 0, upd: 0;
       c4qTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qTQ() //  [R1]
         { info_tbl: [(c4qTQ,
                       label: block_c4qTQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qTQ: // global
           I64[Sp] = block_c4qTW_info;
           _s4lse::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lse::I64;
           if (R1 & 7 != 0) goto u4qU6; else goto c4qU0;
       u4qU6: // global
           call _c4qTW(R1) args: 0, res: 0, upd: 0;
       c4qU0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qTW() //  [R1]
         { info_tbl: [(c4qTW,
                       label: block_c4qTW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qTW: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.93318436 UTC

[section ""data" . GHC.Int.$fOrdInt64_$ccompare_closure" {
     GHC.Int.$fOrdInt64_$ccompare_closure:
         const GHC.Int.$fOrdInt64_$ccompare_info;
 },
 GHC.Int.$fOrdInt64_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4qUf,
                       label: GHC.Int.$fOrdInt64_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qUf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qUj; else goto c4qUk;
       c4qUj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qUk: // global
           I64[Sp - 16] = block_c4qUc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qUD; else goto c4qUd;
       u4qUD: // global
           call _c4qUc(R1) args: 0, res: 0, upd: 0;
       c4qUd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qUc() //  [R1]
         { info_tbl: [(c4qUc,
                       label: block_c4qUc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qUc: // global
           I64[Sp] = block_c4qUi_info;
           _s4lsl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lsl::I64;
           if (R1 & 7 != 0) goto u4qUC; else goto c4qUm;
       u4qUC: // global
           call _c4qUi(R1) args: 0, res: 0, upd: 0;
       c4qUm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qUi() //  [R1]
         { info_tbl: [(c4qUi,
                       label: block_c4qUi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qUi: // global
           _s4lsl::I64 = I64[Sp + 8];
           _s4lsn::I64 = I64[R1 + 7];
           if (_s4lsl::I64 == _s4lsn::I64) goto c4qUB; else goto c4qUA;
       c4qUB: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qUA: // global
           if (%MO_S_Gt_W64(_s4lsl::I64,
                            _s4lsn::I64)) goto c4qUx; else goto c4qUy;
       c4qUx: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qUy: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.934924105 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmax_closure" {
     GHC.Int.$fOrdInt64_$cmax_closure:
         const GHC.Int.$fOrdInt64_$cmax_info;
 },
 GHC.Int.$fOrdInt64_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4qUL,
                       label: GHC.Int.$fOrdInt64_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qUL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qUP; else goto c4qUQ;
       c4qUP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qUQ: // global
           I64[Sp - 16] = block_c4qUI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qV3; else goto c4qUJ;
       u4qV3: // global
           call _c4qUI(R1) args: 0, res: 0, upd: 0;
       c4qUJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qUI() //  [R1]
         { info_tbl: [(c4qUI,
                       label: block_c4qUI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qUI: // global
           I64[Sp - 8] = block_c4qUO_info;
           _s4lss::P64 = R1;
           _s4lst::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lst::I64;
           P64[Sp + 8] = _s4lss::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qV2; else goto c4qUS;
       u4qV2: // global
           call _c4qUO(R1) args: 0, res: 0, upd: 0;
       c4qUS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qUO() //  [R1]
         { info_tbl: [(c4qUO,
                       label: block_c4qUO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qUO: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4qV0; else goto c4qV1;
       c4qV0: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4qV1: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.936571773 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmin_closure" {
     GHC.Int.$fOrdInt64_$cmin_closure:
         const GHC.Int.$fOrdInt64_$cmin_info;
 },
 GHC.Int.$fOrdInt64_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4qVb,
                       label: GHC.Int.$fOrdInt64_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qVb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qVf; else goto c4qVg;
       c4qVf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qVg: // global
           I64[Sp - 16] = block_c4qV8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qVt; else goto c4qV9;
       u4qVt: // global
           call _c4qV8(R1) args: 0, res: 0, upd: 0;
       c4qV9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qV8() //  [R1]
         { info_tbl: [(c4qV8,
                       label: block_c4qV8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qV8: // global
           I64[Sp - 8] = block_c4qVe_info;
           _s4lsz::P64 = R1;
           _s4lsA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lsA::I64;
           P64[Sp + 8] = _s4lsz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qVs; else goto c4qVi;
       u4qVs: // global
           call _c4qVe(R1) args: 0, res: 0, upd: 0;
       c4qVi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qVe() //  [R1]
         { info_tbl: [(c4qVe,
                       label: block_c4qVe_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qVe: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4qVq; else goto c4qVr;
       c4qVq: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4qVr: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.938252701 UTC

[section ""data" . GHC.Int.$fOrdInt64_closure" {
     GHC.Int.$fOrdInt64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fOrdInt64_$ccompare_closure+2;
         const GHC.Int.ltInt64_closure+2;
         const GHC.Int.leInt64_closure+2;
         const GHC.Int.gtInt64_closure+2;
         const GHC.Int.geInt64_closure+2;
         const GHC.Int.$fOrdInt64_$cmax_closure+2;
         const GHC.Int.$fOrdInt64_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.939390338 UTC

[section ""data" . GHC.Int.$fIxInt64_$cinRange_closure" {
     GHC.Int.$fIxInt64_$cinRange_closure:
         const GHC.Int.$fIxInt64_$cinRange_info;
 },
 GHC.Int.$fIxInt64_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4qVB,
                       label: GHC.Int.$fIxInt64_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qVB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qVK; else goto c4qVL;
       c4qVK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qVL: // global
           I64[Sp - 16] = block_c4qVy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qW8; else goto c4qVz;
       u4qW8: // global
           call _c4qVy(R1) args: 0, res: 0, upd: 0;
       c4qVz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qVy() //  [R1]
         { info_tbl: [(c4qVy,
                       label: block_c4qVy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qVy: // global
           I64[Sp - 8] = block_c4qVE_info;
           _s4lsI::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lsI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qW7; else goto c4qVF;
       u4qW7: // global
           call _c4qVE(R1) args: 0, res: 0, upd: 0;
       c4qVF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qVE() //  [R1]
         { info_tbl: [(c4qVE,
                       label: block_c4qVE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qVE: // global
           I64[Sp] = block_c4qVJ_info;
           _s4lsK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lsK::I64;
           if (R1 & 7 != 0) goto u4qW9; else goto c4qVO;
       u4qW9: // global
           call _c4qVJ(R1) args: 0, res: 0, upd: 0;
       c4qVO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qVJ() //  [R1]
         { info_tbl: [(c4qVJ,
                       label: block_c4qVJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qVJ: // global
           _s4lsM::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lsM::I64)) goto c4qVW; else goto c4qW0;
       c4qVW: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qW0: // global
           _s4lsI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4qVZ_info;
           R1 = _s4lsI::P64;
           I64[Sp + 16] = _s4lsM::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4qWa; else goto c4qW1;
       u4qWa: // global
           call _c4qVZ(R1) args: 0, res: 0, upd: 0;
       c4qW1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qVZ() //  [R1]
         { info_tbl: [(c4qVZ,
                       label: block_c4qVZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qVZ: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.94113251 UTC

[section ""data" . GHC.Int.$fNumInt5_closure" {
     GHC.Int.$fNumInt5_closure:
         const GHC.Int.I64#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.94211391 UTC

[section ""data" . GHC.Int.$fNumInt64_$csignum_closure" {
     GHC.Int.$fNumInt64_$csignum_closure:
         const GHC.Int.$fNumInt64_$csignum_info;
 },
 GHC.Int.$fNumInt64_$csignum_entry() //  [R2]
         { info_tbl: [(c4qWi,
                       label: GHC.Int.$fNumInt64_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qWi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qWj; else goto c4qWk;
       c4qWj: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qWk: // global
           I64[Sp - 8] = block_c4qWf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qWy; else goto c4qWg;
       u4qWy: // global
           call _c4qWf(R1) args: 0, res: 0, upd: 0;
       c4qWg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qWf() //  [R1]
         { info_tbl: [(c4qWf,
                       label: block_c4qWf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qWf: // global
           _s4lsT::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lsT::I64, 0)) goto c4qWw; else goto c4qWx;
       c4qWw: // global
           if (_s4lsT::I64 == 0) goto c4qWu; else goto c4qWt;
       c4qWu: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qWt: // global
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qWx: // global
           R1 = GHC.Int.$fNumInt5_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.943737265 UTC

[section ""data" . GHC.Int.$fNumInt64_$cabs_closure" {
     GHC.Int.$fNumInt64_$cabs_closure:
         const GHC.Int.$fNumInt64_$cabs_info;
 },
 GHC.Int.$fNumInt64_$cabs_entry() //  [R2]
         { info_tbl: [(c4qWG,
                       label: GHC.Int.$fNumInt64_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qWG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qWH; else goto c4qWI;
       c4qWH: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qWI: // global
           I64[Sp - 8] = block_c4qWD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qWY; else goto c4qWE;
       u4qWY: // global
           call _c4qWD(R1) args: 0, res: 0, upd: 0;
       c4qWE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qWD() //  [R1]
         { info_tbl: [(c4qWD,
                       label: block_c4qWD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qWD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qWN; else goto c4qWM;
       c4qWN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qWM: // global
           _s4lsY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lsY::I64, 0)) goto c4qWW; else goto c4qWX;
       c4qWW: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = -_s4lsY::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qWX: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.945144578 UTC

[section ""data" . GHC.Int.$fNumInt64_closure" {
     GHC.Int.$fNumInt64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt64_$c+_closure+2;
         const GHC.Int.$fNumInt64_$c-_closure+2;
         const GHC.Int.$fNumInt64_$c*_closure+2;
         const GHC.Int.$fNumInt64_$cnegate_closure+1;
         const GHC.Int.$fNumInt64_$cabs_closure+1;
         const GHC.Int.$fNumInt64_$csignum_closure+1;
         const GHC.Int.$fNumInt64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.945891739 UTC

[section ""data" . GHC.Int.$fBitsInt9_closure" {
     GHC.Int.$fBitsInt9_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.94790591 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt64_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4qX3,
                       label: GHC.Int.$fBitsInt64_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qX3: // global
           R1 = GHC.Int.$fBitsInt9_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.94900264 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbit_closure" {
     GHC.Int.$fBitsInt64_$cbit_closure:
         const GHC.Int.$fBitsInt64_$cbit_info;
 },
 GHC.Int.$fBitsInt64_$cbit_entry() //  [R2]
         { info_tbl: [(c4qXd,
                       label: GHC.Int.$fBitsInt64_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qXd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4qXe; else goto c4qXf;
       c4qXe: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4qXf: // global
           I64[Sp - 8] = block_c4qXa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qXv; else goto c4qXb;
       u4qXv: // global
           call _c4qXa(R1) args: 0, res: 0, upd: 0;
       c4qXb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qXa() //  [R1]
         { info_tbl: [(c4qXa,
                       label: block_c4qXa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qXa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qXk; else goto c4qXj;
       c4qXk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qXj: // global
           _s4lt4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lt4::I64, 64)) goto c4qXt; else goto c4qXu;
       c4qXt: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = 1 << _s4lt4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qXu: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.95074543 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ctestBit_closure" {
     GHC.Int.$fBitsInt64_$ctestBit_closure:
         const GHC.Int.$fBitsInt64_$ctestBit_info;
 },
 GHC.Int.$fBitsInt64_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4qXD,
                       label: GHC.Int.$fBitsInt64_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qXD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4qXH; else goto c4qXI;
       c4qXH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qXI: // global
           I64[Sp - 16] = block_c4qXA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qYn; else goto c4qXB;
       u4qYn: // global
           call _c4qXA(R1) args: 0, res: 0, upd: 0;
       c4qXB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qXA() //  [R1]
         { info_tbl: [(c4qXA,
                       label: block_c4qXA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qXA: // global
           I64[Sp] = block_c4qXG_info;
           _s4lta::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lta::I64;
           if (R1 & 7 != 0) goto u4qYm; else goto c4qXK;
       u4qYm: // global
           call _c4qXG(R1) args: 0, res: 0, upd: 0;
       c4qXK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qXG() //  [R1]
         { info_tbl: [(c4qXG,
                       label: block_c4qXG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qXG: // global
           _s4ltc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4ltc::I64, 64)) goto c4qYl; else goto c4qYk;
       c4qYk: // global
           if (I64[Sp + 8] & (1 << _s4ltc::I64) == 0) goto c4qYl; else goto c4qY9;
       c4qYl: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4qY9: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.952921585 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateR_closure" {
     GHC.Int.$fBitsInt64_$crotateR_closure:
         const GHC.Int.$fBitsInt64_$crotateR_info;
 },
 GHC.Int.$fBitsInt64_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4qYv,
                       label: GHC.Int.$fBitsInt64_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qYv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qYz; else goto c4qYA;
       c4qYz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qYA: // global
           I64[Sp - 16] = block_c4qYs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4qZt; else goto c4qYt;
       u4qZt: // global
           call _c4qYs(R1) args: 0, res: 0, upd: 0;
       c4qYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qYs() //  [R1]
         { info_tbl: [(c4qYs,
                       label: block_c4qYs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qYs: // global
           I64[Sp - 8] = block_c4qYy_info;
           _s4ltl::P64 = R1;
           _s4ltm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4ltm::I64;
           P64[Sp + 8] = _s4ltl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4qZs; else goto c4qYC;
       u4qZs: // global
           call _c4qYy(R1) args: 0, res: 0, upd: 0;
       c4qYC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qYy() //  [R1]
         { info_tbl: [(c4qYy,
                       label: block_c4qYy_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qYy: // global
           _s4lts::I64 = -I64[R1 + 7] & 63;
           if (_s4lts::I64 != 0) goto u4qZq; else goto c4qZm;
       u4qZq: // global
           I64[Sp + 16] = _s4lts::I64;
           Sp = Sp + 8;
           call _c4qYU() args: 0, res: 0, upd: 0;
       c4qZm: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qYU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qYU: // global
           Hp = Hp + 16;
           _s4lts::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4qZj; else goto c4qZi;
       c4qZj: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4qYT_info;
           R1 = _s4lts::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4qZi: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4ltt::I64 = I64[Sp];
           I64[Hp] = (_s4ltt::I64 << _s4lts::I64) | (_s4ltt::I64 >> 64 - _s4lts::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4qYT() //  [R1]
         { info_tbl: [(c4qYT,
                       label: block_c4qYT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qYT: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4qYU() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.955556804 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt64_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt64_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt64_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4qZD,
                       label: GHC.Int.$fBitsInt64_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qZD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4qZH; else goto c4qZI;
       c4qZH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4qZI: // global
           I64[Sp - 16] = block_c4qZA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4r0e; else goto c4qZB;
       u4r0e: // global
           call _c4qZA(R1) args: 0, res: 0, upd: 0;
       c4qZB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qZA() //  [R1]
         { info_tbl: [(c4qZA,
                       label: block_c4qZA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qZA: // global
           I64[Sp - 8] = block_c4qZG_info;
           _s4ltB::P64 = R1;
           _s4ltC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4ltC::I64;
           P64[Sp + 8] = _s4ltB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4r0d; else goto c4qZK;
       u4r0d: // global
           call _c4qZG(R1) args: 0, res: 0, upd: 0;
       c4qZK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4qZG() //  [R1]
         { info_tbl: [(c4qZG,
                       label: block_c4qZG_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4qZG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4qZQ; else goto c4qZP;
       c4qZQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4qZP: // global
           _s4ltE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4ltE::I64, 64)) goto c4r0b; else goto c4r0c;
       c4r0b: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s4ltE::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4r0c: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.958736281 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cclearBit_closure" {
     GHC.Int.$fBitsInt64_$cclearBit_closure:
         const GHC.Int.$fBitsInt64_$cclearBit_info;
 },
 GHC.Int.$fBitsInt64_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4r0m,
                       label: GHC.Int.$fBitsInt64_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r0m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r0q; else goto c4r0r;
       c4r0q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r0r: // global
           I64[Sp - 16] = block_c4r0j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4r1b; else goto c4r0k;
       u4r1b: // global
           call _c4r0j(R1) args: 0, res: 0, upd: 0;
       c4r0k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r0j() //  [R1]
         { info_tbl: [(c4r0j,
                       label: block_c4r0j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r0j: // global
           I64[Sp] = block_c4r0p_info;
           _s4ltO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ltO::I64;
           if (R1 & 7 != 0) goto u4r1a; else goto c4r0t;
       u4r1a: // global
           call _c4r0p(R1) args: 0, res: 0, upd: 0;
       c4r0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r0p() //  [R1]
         { info_tbl: [(c4r0p,
                       label: block_c4r0p_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r0p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4r0z; else goto c4r0y;
       c4r0z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4r0y: // global
           _s4ltO::I64 = I64[Sp + 8];
           _s4ltQ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4ltQ::I64, 64)) goto c4r0X; else goto c4r19;
       c4r0X: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4ltO::I64 & (1 << _s4ltQ::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4r19: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4ltO::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.962130829 UTC

[section ""data" . GHC.Int.$fBitsInt64_$csetBit_closure" {
     GHC.Int.$fBitsInt64_$csetBit_closure:
         const GHC.Int.$fBitsInt64_$csetBit_info;
 },
 GHC.Int.$fBitsInt64_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4r1j,
                       label: GHC.Int.$fBitsInt64_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r1j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4r1n; else goto c4r1o;
       c4r1n: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r1o: // global
           I64[Sp - 16] = block_c4r1g_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4r1U; else goto c4r1h;
       u4r1U: // global
           call _c4r1g(R1) args: 0, res: 0, upd: 0;
       c4r1h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r1g() //  [R1]
         { info_tbl: [(c4r1g,
                       label: block_c4r1g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r1g: // global
           I64[Sp - 8] = block_c4r1m_info;
           _s4lu3::P64 = R1;
           _s4lu4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lu4::I64;
           P64[Sp + 8] = _s4lu3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4r1T; else goto c4r1q;
       u4r1T: // global
           call _c4r1m(R1) args: 0, res: 0, upd: 0;
       c4r1q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r1m() //  [R1]
         { info_tbl: [(c4r1m,
                       label: block_c4r1m_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r1m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4r1w; else goto c4r1v;
       c4r1w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4r1v: // global
           _s4lu6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lu6::I64, 64)) goto c4r1R; else goto c4r1S;
       c4r1R: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s4lu6::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4r1S: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.964706771 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateL_closure" {
     GHC.Int.$fBitsInt64_$crotateL_closure:
         const GHC.Int.$fBitsInt64_$crotateL_info;
 },
 GHC.Int.$fBitsInt64_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4r1Z,
                       label: GHC.Int.$fBitsInt64_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r1Z: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt64_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.965862058 UTC

[section ""data" . GHC.Int.$fBitsInt64_closure" {
     GHC.Int.$fBitsInt64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fBitsInt64_$c.&._closure+2;
         const GHC.Int.$fBitsInt64_$c.|._closure+2;
         const GHC.Int.$fBitsInt64_$cxor_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt64_$cshift_closure+2;
         const GHC.Int.$fBitsInt64_$crotate_closure+2;
         const GHC.Int.$fBitsInt10_closure+1;
         const GHC.Int.$fBitsInt64_$cbit_closure+1;
         const GHC.Int.$fBitsInt64_$csetBit_closure+2;
         const GHC.Int.$fBitsInt64_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt64_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt64_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt64_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt64_$crotateL_closure+2;
         const GHC.Int.$fBitsInt64_$crotateR_closure+2;
         const GHC.Int.$fBitsInt64_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.966967189 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_closure" {
     GHC.Int.$fFiniteBitsInt64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt64_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.968486412 UTC

[section ""data" . GHC.Int.$fReadInt64_go_closure" {
     GHC.Int.$fReadInt64_go_closure:
         const GHC.Int.$fReadInt64_go_info;
 },
 sat_s4luo_entry() //  [R1]
         { info_tbl: [(c4r2l,
                       label: sat_s4luo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r2l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r2m; else goto c4r2n;
       c4r2m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4r2n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lum_entry() //  [R1]
         { info_tbl: [(c4r2v,
                       label: sat_s4lum_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r2v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4r2z; else goto c4r2A;
       c4r2z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4r2A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4r2s_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4r2E; else goto c4r2t;
       u4r2E: // global
           call _c4r2s(R1) args: 0, res: 0, upd: 0;
       c4r2t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4r2s() //  [R1]
         { info_tbl: [(c4r2s,
                       label: block_c4r2s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r2s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4r2D; else goto c4r2C;
       c4r2D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4r2C: // global
           _s4lul::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lul::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt64_go_entry() //  [R2]
         { info_tbl: [(c4r2J,
                       label: GHC.Int.$fReadInt64_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r2J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r2K; else goto c4r2L;
       c4r2K: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4r2L: // global
           I64[Sp - 8] = block_c4r26_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4r2V; else goto c4r27;
       u4r2V: // global
           call _c4r26(R1) args: 0, res: 0, upd: 0;
       c4r27: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r26() //  [R1]
         { info_tbl: [(c4r26,
                       label: block_c4r26_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r26: // global
           if (R1 & 7 == 1) goto c4r2G; else goto c4r2H;
       c4r2G: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4r2H: // global
           I64[Sp - 8] = block_c4r2c_info;
           _s4lug::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lug::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4r2U; else goto c4r2d;
       u4r2U: // global
           call _c4r2c(R1) args: 0, res: 0, upd: 0;
       c4r2d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r2c() //  [R1]
         { info_tbl: [(c4r2c,
                       label: block_c4r2c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r2c: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4r2T; else goto c4r2S;
       c4r2T: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4r2S: // global
           _s4lui::P64 = P64[R1 + 7];
           _s4luj::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4luo_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lum_info;
           P64[Hp - 48] = _s4lui::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4luj::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.971151205 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadsPrec_closure" {
     GHC.Int.$fReadInt64_$creadsPrec_closure:
         const GHC.Int.$fReadInt64_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4r32,
                       label: GHC.Int.$fReadInt64_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r32: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r36; else goto c4r37;
       c4r36: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r37: // global
           I64[Sp - 16] = block_c4r30_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4luq::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4luq::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4r30() //  [R1]
         { info_tbl: [(c4r30,
                       label: block_c4r30_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r30: // global
           _s4luq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4r35_info;
           R3 = _s4luq::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4r35() //  [R1]
         { info_tbl: [(c4r35,
                       label: block_c4r35_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r35: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.972851824 UTC

[section ""data" . GHC.Int.$fReadInt10_closure" {
     GHC.Int.$fReadInt10_closure:
         const GHC.Int.$fReadInt10_info;
         const 0;
 },
 sat_s4luv_entry() //  [R1, R2]
         { info_tbl: [(c4r3m,
                       label: sat_s4luv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r3m: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt64_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt10_entry() //  [R2, R3]
         { info_tbl: [(c4r3s,
                       label: GHC.Int.$fReadInt10_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r3s: // global
           _s4luu::P64 = R3;
           _s4lut::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4r3t; else goto c4r3u;
       c4r3u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4r3w; else goto c4r3v;
       c4r3w: // global
           HpAlloc = 16;
           goto c4r3t;
       c4r3t: // global
           R3 = _s4luu::P64;
           R2 = _s4lut::P64;
           R1 = GHC.Int.$fReadInt10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r3v: // global
           I64[Hp - 8] = sat_s4luv_info;
           P64[Hp] = _s4lut::P64;
           I64[Sp - 8] = block_c4r3p_info;
           R3 = _s4luu::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4r3p() //  [R1]
         { info_tbl: [(c4r3p,
                       label: block_c4r3p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r3p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4r3z; else goto c4r3y;
       c4r3z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4r3y: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.97547349 UTC

[section ""data" . GHC.Int.$fReadInt9_closure" {
     GHC.Int.$fReadInt9_closure:
         const GHC.Int.$fReadInt9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4r3J_srtd" {
     u4r3J_srtd:
         const S4lDl_srt+504;
         const 70;
         const 1;
         const 32;
 },
 GHC.Int.$fReadInt9_entry() //  [R1]
         { info_tbl: [(c4r3G,
                       label: GHC.Int.$fReadInt9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r3G: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4r3H; else goto c4r3I;
       c4r3H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4r3I: // global
           (_c4r3D::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4r3D::I64 == 0) goto c4r3F; else goto c4r3E;
       c4r3F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4r3E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4r3D::I64;
           R2 = GHC.Int.$fReadInt10_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.976648778 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadList_closure" {
     GHC.Int.$fReadInt64_$creadList_closure:
         const GHC.Int.$fReadInt64_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadList_entry() //  [R2]
         { info_tbl: [(c4r3O,
                       label: GHC.Int.$fReadInt64_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r3O: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt9_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.97772149 UTC

[section ""data" . GHC.Int.$fReadInt7_closure" {
     GHC.Int.$fReadInt7_closure:
         const GHC.Int.$fReadInt7_info;
         const 0;
 },
 GHC.Int.$fReadInt7_entry() //  [R2, R3]
         { info_tbl: [(c4r3Y,
                       label: GHC.Int.$fReadInt7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r3Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4r3Z; else goto c4r40;
       c4r3Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r40: // global
           I64[Sp - 8] = block_c4r3V_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt64_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4r3V() //  [R1]
         { info_tbl: [(c4r3V,
                       label: block_c4r3V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r3V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4r43; else goto c4r42;
       c4r43: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4r42: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.978763013 UTC

[section ""data" . GHC.Int.$fReadInt64_closure" {
     GHC.Int.$fReadInt64_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt64_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt64_$creadList_closure+1;
         const GHC.Int.$fReadInt10_closure+2;
         const GHC.Int.$fReadInt7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.979883176 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquot_closure" {
     GHC.Int.$fIntegralInt64_$cquot_closure:
         const GHC.Int.$fIntegralInt64_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4r4b,
                       label: GHC.Int.$fIntegralInt64_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r4b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r4f; else goto c4r4g;
       c4r4f: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r4g: // global
           I64[Sp - 16] = block_c4r48_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4r4L; else goto c4r49;
       u4r4L: // global
           call _c4r48(R1) args: 0, res: 0, upd: 0;
       c4r49: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r48() //  [R1]
         { info_tbl: [(c4r48,
                       label: block_c4r48_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r48: // global
           I64[Sp] = block_c4r4e_info;
           _s4luF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4luF::I64;
           if (R1 & 7 != 0) goto u4r4K; else goto c4r4i;
       u4r4K: // global
           call _c4r4e(R1) args: 0, res: 0, upd: 0;
       c4r4i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r4e() //  [R1]
         { info_tbl: [(c4r4e,
                       label: block_c4r4e_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r4e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4r4o; else goto c4r4n;
       c4r4o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4r4n: // global
           _s4luF::I64 = I64[Sp + 8];
           _s4luI::I64 = I64[R1 + 7];
           if (_s4luI::I64 != (-1)) goto u4r4J; else goto c4r4H;
       u4r4J: // global
           if (_s4luI::I64 != 0) goto c4r4w; else goto c4r4I;
       c4r4w: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4luF::I64, _s4luI::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4r4I: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4r4H: // global
           if (_s4luF::I64 == (-9223372036854775808)) goto c4r4G; else goto c4r4F;
       c4r4G: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4r4F: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4luF::I64, (-1));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.982236657 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$crem_closure" {
     GHC.Int.$fIntegralInt64_$crem_closure:
         const GHC.Int.$fIntegralInt64_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4r4T,
                       label: GHC.Int.$fIntegralInt64_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r4T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r4X; else goto c4r4Y;
       c4r4X: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r4Y: // global
           I64[Sp - 16] = block_c4r4Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4r5j; else goto c4r4R;
       u4r5j: // global
           call _c4r4Q(R1) args: 0, res: 0, upd: 0;
       c4r4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r4Q() //  [R1]
         { info_tbl: [(c4r4Q,
                       label: block_c4r4Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r4Q: // global
           I64[Sp] = block_c4r4W_info;
           _s4luR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4luR::I64;
           if (R1 & 7 != 0) goto u4r5i; else goto c4r50;
       u4r5i: // global
           call _c4r4W(R1) args: 0, res: 0, upd: 0;
       c4r50: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r4W() //  [R1]
         { info_tbl: [(c4r4W,
                       label: block_c4r4W_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r4W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4r56; else goto c4r55;
       c4r56: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4r55: // global
           _s4luU::I64 = I64[R1 + 7];
           if (_s4luU::I64 != (-1)) goto u4r5h; else goto c4r5f;
       u4r5h: // global
           if (_s4luU::I64 != 0) goto c4r5e; else goto c4r5g;
       c4r5e: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Rem_W64(I64[Sp + 8], _s4luU::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4r5g: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4r5f: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.983965099 UTC

[section ""data" . GHC.Int.$w$cdiv2_closure" {
     GHC.Int.$w$cdiv2_closure:
         const GHC.Int.$w$cdiv2_info;
         const 0;
 },
 GHC.Int.$w$cdiv2_entry() //  [R2, R3]
         { info_tbl: [(c4r5t,
                       label: GHC.Int.$w$cdiv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r5t: // global
           if (R3 == (-1)) goto c4r5r; else goto u4r5C;
       c4r5r: // global
           if (R2 == (-9223372036854775808)) goto c4r5B; else goto c4r5A;
       c4r5B: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4r5A: // global
           R3 = (-1);
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
       u4r5C: // global
           if (R3 == 0) goto c4r5s; else goto c4r5q;
       c4r5s: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4r5q: // global
           R3 = R3;
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.985358336 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdiv_closure" {
     GHC.Int.$fIntegralInt64_$cdiv_closure:
         const GHC.Int.$fIntegralInt64_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4r5K,
                       label: GHC.Int.$fIntegralInt64_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r5K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r5X; else goto c4r5Y;
       c4r5X: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r5Y: // global
           I64[Sp - 16] = block_c4r5H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4r65; else goto c4r5I;
       u4r65: // global
           call _c4r5H(R1) args: 0, res: 0, upd: 0;
       c4r5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r5H() //  [R1]
         { info_tbl: [(c4r5H,
                       label: block_c4r5H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r5H: // global
           I64[Sp] = block_c4r5N_info;
           _s4lv5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lv5::I64;
           if (R1 & 7 != 0) goto u4r64; else goto c4r5O;
       u4r64: // global
           call _c4r5N(R1) args: 0, res: 0, upd: 0;
       c4r5O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r5N() //  [R1]
         { info_tbl: [(c4r5N,
                       label: block_c4r5N_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r5N: // global
           _s4lv5::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4r5S_info;
           R3 = I64[R1 + 7];
           R2 = _s4lv5::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4r5S() //  [R1]
         { info_tbl: [(c4r5S,
                       label: block_c4r5S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r5S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4r63; else goto c4r62;
       c4r63: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4r62: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.987272588 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cmod_closure" {
     GHC.Int.$fIntegralInt64_$cmod_closure:
         const GHC.Int.$fIntegralInt64_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4r6d,
                       label: GHC.Int.$fIntegralInt64_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r6d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r6h; else goto c4r6i;
       c4r6h: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r6i: // global
           I64[Sp - 16] = block_c4r6a_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4r6F; else goto c4r6b;
       u4r6F: // global
           call _c4r6a(R1) args: 0, res: 0, upd: 0;
       c4r6b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r6a() //  [R1]
         { info_tbl: [(c4r6a,
                       label: block_c4r6a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r6a: // global
           I64[Sp] = block_c4r6g_info;
           _s4lvc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lvc::I64;
           if (R1 & 7 != 0) goto u4r6E; else goto c4r6k;
       u4r6E: // global
           call _c4r6g(R1) args: 0, res: 0, upd: 0;
       c4r6k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r6g() //  [R1]
         { info_tbl: [(c4r6g,
                       label: block_c4r6g_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r6g: // global
           _s4lvf::I64 = I64[R1 + 7];
           if (_s4lvf::I64 != (-1)) goto u4r6D; else goto c4r6B;
       u4r6D: // global
           if (_s4lvf::I64 != 0) goto c4r6x; else goto c4r6C;
       c4r6x: // global
           _s4lvc::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4r6r_info;
           R3 = _s4lvf::I64;
           R2 = _s4lvc::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4r6C: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4r6B: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4r6r() //  [R1]
         { info_tbl: [(c4r6r,
                       label: block_c4r6r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r6r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4r6A; else goto c4r6z;
       c4r6A: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4r6z: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.98889247 UTC

[section ""data" . lvl9_r4kPA_closure" {
     lvl9_r4kPA_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt10_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.990145888 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquotRem_closure" {
     GHC.Int.$fIntegralInt64_$cquotRem_closure:
         const GHC.Int.$fIntegralInt64_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4r6N,
                       label: GHC.Int.$fIntegralInt64_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r6N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r6R; else goto c4r6S;
       c4r6R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r6S: // global
           I64[Sp - 16] = block_c4r6K_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4r7l; else goto c4r6L;
       u4r7l: // global
           call _c4r6K(R1) args: 0, res: 0, upd: 0;
       c4r6L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r6K() //  [R1]
         { info_tbl: [(c4r6K,
                       label: block_c4r6K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r6K: // global
           I64[Sp] = block_c4r6Q_info;
           _s4lvl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lvl::I64;
           if (R1 & 7 != 0) goto u4r7k; else goto c4r6U;
       u4r7k: // global
           call _c4r6Q(R1) args: 0, res: 0, upd: 0;
       c4r6U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r6Q() //  [R1]
         { info_tbl: [(c4r6Q,
                       label: block_c4r6Q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r6Q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4r70; else goto c4r6Z;
       c4r70: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4r6Z: // global
           _s4lvl::I64 = I64[Sp + 8];
           _s4lvo::I64 = I64[R1 + 7];
           if (_s4lvo::I64 != (-1)) goto u4r7j; else goto c4r7h;
       u4r7j: // global
           if (_s4lvo::I64 != 0) goto c4r77; else goto c4r7i;
       c4r77: // global
           (_s4lvq::I64, _s4lvr::I64) = call MO_S_QuotRem W64(_s4lvl::I64, _s4lvo::I64);
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4lvr::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4lvq::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4r7i: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4r7h: // global
           if (_s4lvl::I64 == (-9223372036854775808)) goto c4r7g; else goto c4r7f;
       c4r7g: // global
           Hp = Hp - 56;
           R1 = lvl9_r4kPA_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4r7f: // global
           (_s4lvw::I64, _s4lvx::I64) = call MO_S_QuotRem W64(_s4lvl::I64, (-1));
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4lvx::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4lvw::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.993171933 UTC

[section ""data" . GHC.Int.$w$cdivMod2_closure" {
     GHC.Int.$w$cdivMod2_closure:
         const GHC.Int.$w$cdivMod2_info;
         const 0;
 },
 GHC.Int.$w$cdivMod2_entry() //  [R2, R3]
         { info_tbl: [(c4r7u,
                       label: GHC.Int.$w$cdivMod2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r7u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4r7v; else goto c4r7w;
       c4r7v: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r7w: // global
           if (R3 == 0) goto c4r7t; else goto c4r7s;
       c4r7t: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4r7s: // global
           if (R3 == (-1)) goto c4r9j; else goto u4r9k;
       c4r9j: // global
           if (R2 == (-9223372036854775808)) goto c4r9i; else goto u4r9l;
       c4r9i: // global
           R2 = GHC.Int.$fBitsInt10_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4r9l: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4r9n;
       u4r9k: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4r9n;
       u4r9n: // global
           call _c4r7B() args: 0, res: 0, upd: 0;
     }
 },
 _c4r7B() //  []
         { info_tbl: [(c4r7B,
                       label: block_c4r7B_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r7B: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4r7F; else goto c4r7E;
       c4r7F: // global
           HpAlloc = 32;
           I64[Sp] = block_c4r7B_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4r7E: // global
           _s4lvB::I64 = I64[Sp + 8];
           _s4lvD::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lvB::I64, 0)) goto c4r8g; else goto c4r99;
       c4r8g: // global
           if (%MO_S_Ge_W64(_s4lvB::I64, 0)) goto c4r7P; else goto c4r8e;
       c4r7P: // global
           (_s4lvI::I64, _s4lvJ::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvJ::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvI::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4r8e: // global
           if (%MO_S_Le_W64(_s4lvD::I64, 0)) goto c4r7X; else goto c4r8d;
       c4r7X: // global
           (_s4lvO::I64, _s4lvP::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvP::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvO::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4r8d: // global
           (_s4lvU::I64, _s4lvV::I64) = call MO_S_QuotRem W64(_s4lvB::I64 + 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvV::I64 + _s4lvD::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvU::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4r99: // global
           if (%MO_S_Ge_W64(_s4lvD::I64, 0)) goto c4r8S; else goto c4r98;
       c4r8S: // global
           if (%MO_S_Ge_W64(_s4lvB::I64, 0)) goto c4r8r; else goto c4r8Q;
       c4r8r: // global
           (_s4lw4::I64, _s4lw5::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lw5::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lw4::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4r8Q: // global
           if (%MO_S_Le_W64(_s4lvD::I64, 0)) goto c4r8z; else goto c4r8P;
       c4r8z: // global
           (_s4lwa::I64, _s4lwb::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwb::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwa::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4r8P: // global
           (_s4lwg::I64, _s4lwh::I64) = call MO_S_QuotRem W64(_s4lvB::I64 + 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwh::I64 + _s4lvD::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwg::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4r98: // global
           (_s4lwp::I64, _s4lwq::I64) = call MO_S_QuotRem W64(_s4lvB::I64 - 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwq::I64 + _s4lvD::I64 + 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwp::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.996241111 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdivMod_closure" {
     GHC.Int.$fIntegralInt64_$cdivMod_closure:
         const GHC.Int.$fIntegralInt64_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4r9v,
                       label: GHC.Int.$fIntegralInt64_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r9v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4r9G; else goto c4r9H;
       c4r9G: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4r9H: // global
           I64[Sp - 16] = block_c4r9s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4r9O; else goto c4r9t;
       u4r9O: // global
           call _c4r9s(R1) args: 0, res: 0, upd: 0;
       c4r9t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r9s() //  [R1]
         { info_tbl: [(c4r9s,
                       label: block_c4r9s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r9s: // global
           I64[Sp] = block_c4r9y_info;
           _s4lwC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lwC::I64;
           if (R1 & 7 != 0) goto u4r9N; else goto c4r9z;
       u4r9N: // global
           call _c4r9y(R1) args: 0, res: 0, upd: 0;
       c4r9z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r9y() //  [R1]
         { info_tbl: [(c4r9y,
                       label: block_c4r9y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r9y: // global
           _s4lwC::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4r9D_info;
           R3 = I64[R1 + 7];
           R2 = _s4lwC::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4r9D() //  [R1, R2]
         { info_tbl: [(c4r9D,
                       label: block_c4r9D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r9D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4r9M; else goto c4r9L;
       c4r9M: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4r9L: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:09.999360892 UTC

[section ""data" . GHC.Int.$fIxInt64_$crange_closure" {
     GHC.Int.$fIxInt64_$crange_closure:
         const GHC.Int.$fIxInt64_$crange_info;
 },
 GHC.Int.$fIxInt64_$crange_entry() //  [R2]
         { info_tbl: [(c4r9W,
                       label: GHC.Int.$fIxInt64_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r9W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4r9X; else goto c4r9Y;
       c4r9X: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4r9Y: // global
           I64[Sp - 8] = block_c4r9T_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ra2; else goto c4r9U;
       u4ra2: // global
           call _c4r9T(R1) args: 0, res: 0, upd: 0;
       c4r9U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4r9T() //  [R1]
         { info_tbl: [(c4r9T,
                       label: block_c4r9T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4r9T: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.000669348 UTC

[section ""data" . GHC.Int.$fRealInt64_$ctoRational_closure" {
     GHC.Int.$fRealInt64_$ctoRational_closure:
         const GHC.Int.$fRealInt64_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt64_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4raa,
                       label: GHC.Int.$fRealInt64_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4raa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rao; else goto c4rap;
       c4rao: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rap: // global
           I64[Sp - 8] = block_c4ra7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4raw; else goto c4ra8;
       u4raw: // global
           call _c4ra7(R1) args: 0, res: 0, upd: 0;
       c4ra8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ra7() //  [R1]
         { info_tbl: [(c4ra7,
                       label: block_c4ra7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ra7: // global
           I64[Sp] = block_c4rad_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rad() //  [R1]
         { info_tbl: [(c4rad,
                       label: block_c4rad_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rad: // global
           I64[Sp] = block_c4rah_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rah() //  [R1]
         { info_tbl: [(c4rah,
                       label: block_c4rah_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rah: // global
           I64[Sp] = block_c4ral_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ral() //  [R1, R2]
         { info_tbl: [(c4ral,
                       label: block_c4ral_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ral: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rav; else goto c4rau;
       c4rav: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rau: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.002185411 UTC

[section ""data" . GHC.Int.$fRealInt64_closure" {
     GHC.Int.$fRealInt64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt64_closure+1;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fRealInt64_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.002746383 UTC

[section ""data" . GHC.Int.$fIntegralInt64_closure" {
     GHC.Int.$fIntegralInt64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt64_closure+1;
         const GHC.Int.$fEnumInt64_closure+1;
         const GHC.Int.$fIntegralInt64_$cquot_closure+2;
         const GHC.Int.$fIntegralInt64_$crem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt64_$cmod_closure+2;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt64_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.003826091 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt64_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt64_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt64_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4raE,
                       label: GHC.Int.$fIxInt64_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4raE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4raV; else goto c4raW;
       c4raV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4raW: // global
           I64[Sp - 16] = block_c4raB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rb3; else goto c4raC;
       u4rb3: // global
           call _c4raB(R1) args: 0, res: 0, upd: 0;
       c4raC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4raB() //  [R1]
         { info_tbl: [(c4raB,
                       label: block_c4raB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4raB: // global
           I64[Sp] = block_c4raH_info;
           _s4lwX::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lwX::P64;
           if (R1 & 7 != 0) goto u4rb2; else goto c4raI;
       u4rb2: // global
           call _c4raH(R1) args: 0, res: 0, upd: 0;
       c4raI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4raH() //  [R1]
         { info_tbl: [(c4raH,
                       label: block_c4raH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4raH: // global
           I64[Sp] = block_c4raM_info;
           _s4lx0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lx0::I64;
           if (R1 & 7 != 0) goto u4rb4; else goto c4raN;
       u4rb4: // global
           call _c4raM(R1) args: 0, res: 0, upd: 0;
       c4raN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4raM() //  [R1]
         { info_tbl: [(c4raM,
                       label: block_c4raM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4raM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rb1; else goto c4rb0;
       c4rb1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rb0: // global
           _s4lx3::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lx3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.005893828 UTC

[section ""data" . GHC.Int.$fIxInt64_$crangeSize_closure" {
     GHC.Int.$fIxInt64_$crangeSize_closure:
         const GHC.Int.$fIxInt64_$crangeSize_info;
 },
 GHC.Int.$fIxInt64_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4rbc,
                       label: GHC.Int.$fIxInt64_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rbc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rbl; else goto c4rbm;
       c4rbl: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rbm: // global
           I64[Sp - 8] = block_c4rb9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rbL; else goto c4rba;
       u4rbL: // global
           call _c4rb9(R1) args: 0, res: 0, upd: 0;
       c4rba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rb9() //  [R1]
         { info_tbl: [(c4rb9,
                       label: block_c4rb9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rb9: // global
           I64[Sp - 8] = block_c4rbf_info;
           _s4lx7::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lx7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rbK; else goto c4rbg;
       u4rbK: // global
           call _c4rbf(R1) args: 0, res: 0, upd: 0;
       c4rbg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rbf() //  [R1]
         { info_tbl: [(c4rbf,
                       label: block_c4rbf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rbf: // global
           I64[Sp] = block_c4rbk_info;
           _s4lx9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lx9::I64;
           if (R1 & 7 != 0) goto u4rbM; else goto c4rbp;
       u4rbM: // global
           call _c4rbk(R1) args: 0, res: 0, upd: 0;
       c4rbp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rbk() //  [R1]
         { info_tbl: [(c4rbk,
                       label: block_c4rbk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rbk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rbv; else goto c4rbu;
       c4rbv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rbu: // global
           _s4lx9::I64 = I64[Sp + 8];
           _s4lxb::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lx9::I64,
                            _s4lxb::I64)) goto c4rbz; else goto c4rbJ;
       c4rbz: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rbJ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxb::I64 - _s4lx9::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.007955259 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt64_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt64_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4rbU,
                       label: GHC.Int.$fIxInt64_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rbU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rce; else goto c4rcf;
       c4rce: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rcf: // global
           I64[Sp - 8] = block_c4rbR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rcm; else goto c4rbS;
       u4rcm: // global
           call _c4rbR(R1) args: 0, res: 0, upd: 0;
       c4rbS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rbR() //  [R1]
         { info_tbl: [(c4rbR,
                       label: block_c4rbR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rbR: // global
           I64[Sp - 8] = block_c4rbX_info;
           _s4lxh::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lxh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rcl; else goto c4rbY;
       u4rcl: // global
           call _c4rbX(R1) args: 0, res: 0, upd: 0;
       c4rbY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rbX() //  [R1]
         { info_tbl: [(c4rbX,
                       label: block_c4rbX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rbX: // global
           I64[Sp] = block_c4rc2_info;
           _s4lxk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxk::I64;
           if (R1 & 7 != 0) goto u4rcn; else goto c4rc3;
       u4rcn: // global
           call _c4rc2(R1) args: 0, res: 0, upd: 0;
       c4rc3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rc2() //  [R1]
         { info_tbl: [(c4rc2,
                       label: block_c4rc2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rc2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rck; else goto c4rcj;
       c4rck: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rcj: // global
           _s4lxo::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.010195878 UTC

[section ""data" . GHC.Int.$fIxInt64_$cindex_closure" {
     GHC.Int.$fIxInt64_$cindex_closure:
         const GHC.Int.$fIxInt64_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt64_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4rcv,
                       label: GHC.Int.$fIxInt64_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rcv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rcE; else goto c4rcF;
       c4rcE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rcF: // global
           I64[Sp - 16] = block_c4rcs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rde; else goto c4rct;
       u4rde: // global
           call _c4rcs(R1) args: 0, res: 0, upd: 0;
       c4rct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rcs() //  [R1]
         { info_tbl: [(c4rcs,
                       label: block_c4rcs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rcs: // global
           I64[Sp - 8] = block_c4rcy_info;
           _s4lxt::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lxt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rdd; else goto c4rcz;
       u4rdd: // global
           call _c4rcy(R1) args: 0, res: 0, upd: 0;
       c4rcz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rcy() //  [R1]
         { info_tbl: [(c4rcy,
                       label: block_c4rcy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rcy: // global
           I64[Sp] = block_c4rcD_info;
           _s4lxv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lxv::I64;
           if (R1 & 7 != 0) goto u4rdf; else goto c4rcI;
       u4rdf: // global
           call _c4rcD(R1) args: 0, res: 0, upd: 0;
       c4rcI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rcD() //  [R1]
         { info_tbl: [(c4rcD,
                       label: block_c4rcD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rcD: // global
           _s4lxx::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lxx::I64)) goto c4rcQ; else goto c4rcU;
       c4rcQ: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4rcU: // global
           I64[Sp] = block_c4rcT_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxx::I64;
           if (R1 & 7 != 0) goto u4rdg; else goto c4rcV;
       u4rdg: // global
           call _c4rcT(R1) args: 0, res: 0, upd: 0;
       c4rcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rcT() //  [R1]
         { info_tbl: [(c4rcT,
                       label: block_c4rcT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rcT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rd1; else goto c4rd0;
       c4rd1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rd0: // global
           _s4lxx::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4lxx::I64,
                            I64[R1 + 7])) goto c4rd5; else goto c4rdc;
       c4rd5: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4rdc: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxx::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.012229718 UTC

[section ""data" . GHC.Int.$fIxInt64_closure" {
     GHC.Int.$fIxInt64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fIxInt64_$crange_closure+1;
         const GHC.Int.$fIxInt64_$cindex_closure+2;
         const GHC.Int.$fIxInt64_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt64_$cinRange_closure+2;
         const GHC.Int.$fIxInt64_$crangeSize_closure+1;
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.013558149 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowsPrec_closure" {
     GHC.Int.$fShowInt64_$cshowsPrec_closure:
         const GHC.Int.$fShowInt64_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt64_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4rdo,
                       label: GHC.Int.$fShowInt64_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rdo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rdz; else goto c4rdA;
       c4rdz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rdA: // global
           I64[Sp - 24] = block_c4rdl_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rdH; else goto c4rdm;
       u4rdH: // global
           call _c4rdl(R1) args: 0, res: 0, upd: 0;
       c4rdm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rdl() //  [R1]
         { info_tbl: [(c4rdl,
                       label: block_c4rdl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rdl: // global
           I64[Sp] = block_c4rdr_info;
           _s4lxH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxH::I64;
           if (R1 & 7 != 0) goto u4rdG; else goto c4rds;
       u4rdG: // global
           call _c4rdr(R1) args: 0, res: 0, upd: 0;
       c4rds: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rdr() //  [R1]
         { info_tbl: [(c4rdr,
                       label: block_c4rdr_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rdr: // global
           _s4lxF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4rdw_info;
           R4 = _s4lxF::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rdw() //  [R1, R2]
         { info_tbl: [(c4rdw,
                       label: block_c4rdw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rdw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rdF; else goto c4rdE;
       c4rdF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rdE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.016697366 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshow_closure" {
     GHC.Int.$fShowInt64_$cshow_closure:
         const GHC.Int.$fShowInt64_$cshow_info;
 },
 GHC.Int.$fShowInt64_$cshow_entry() //  [R2]
         { info_tbl: [(c4rdP,
                       label: GHC.Int.$fShowInt64_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rdP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rdV; else goto c4rdW;
       c4rdV: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rdW: // global
           I64[Sp - 8] = block_c4rdM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4re1; else goto c4rdN;
       u4re1: // global
           call _c4rdM(R1) args: 0, res: 0, upd: 0;
       c4rdN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rdM() //  [R1]
         { info_tbl: [(c4rdM,
                       label: block_c4rdM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rdM: // global
           I64[Sp] = block_c4rdS_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rdS() //  [R1, R2]
         { info_tbl: [(c4rdS,
                       label: block_c4rdS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rdS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4re0; else goto c4rdZ;
       c4re0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rdZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.0191382 UTC

[section ""data" . GHC.Int.$fShowInt3_closure" {
     GHC.Int.$fShowInt3_closure:
         const GHC.Int.$fShowInt3_info;
 },
 GHC.Int.$fShowInt3_entry() //  [R2, R3]
         { info_tbl: [(c4re9,
                       label: GHC.Int.$fShowInt3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4re9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ref; else goto c4reg;
       c4ref: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4reg: // global
           I64[Sp - 16] = block_c4re6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rel; else goto c4re7;
       u4rel: // global
           call _c4re6(R1) args: 0, res: 0, upd: 0;
       c4re7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4re6() //  [R1]
         { info_tbl: [(c4re6,
                       label: block_c4re6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4re6: // global
           _s4lxU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4rec_info;
           R4 = _s4lxU::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rec() //  [R1, R2]
         { info_tbl: [(c4rec,
                       label: block_c4rec_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rec: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rek; else goto c4rej;
       c4rek: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rej: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.021414697 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowList_closure" {
     GHC.Int.$fShowInt64_$cshowList_closure:
         const GHC.Int.$fShowInt64_$cshowList_info;
 },
 GHC.Int.$fShowInt64_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4req,
                       label: GHC.Int.$fShowInt64_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4req: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt3_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.023838076 UTC

[section ""data" . GHC.Int.$fShowInt64_closure" {
     GHC.Int.$fShowInt64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt64_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt64_$cshow_closure+1;
         const GHC.Int.$fShowInt64_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.024868493 UTC

[section ""data" . GHC.Int.uncheckedIShiftL64#_closure" {
     GHC.Int.uncheckedIShiftL64#_closure:
         const GHC.Int.uncheckedIShiftL64#_info;
 },
 GHC.Int.uncheckedIShiftL64#_entry() //  [R2, R3]
         { info_tbl: [(c4rey,
                       label: GHC.Int.uncheckedIShiftL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rey: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.026132921 UTC

[section ""data" . GHC.Int.uncheckedIShiftRA64#_closure" {
     GHC.Int.uncheckedIShiftRA64#_closure:
         const GHC.Int.uncheckedIShiftRA64#_info;
 },
 GHC.Int.uncheckedIShiftRA64#_entry() //  [R2, R3]
         { info_tbl: [(c4reG,
                       label: GHC.Int.uncheckedIShiftRA64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4reG: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.027190304 UTC

[section ""cstring" . GHC.Int.$trModule4_bytes" {
     GHC.Int.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.027966642 UTC

[section ""data" . GHC.Int.$trModule3_closure" {
     GHC.Int.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.028832712 UTC

[section ""cstring" . GHC.Int.$trModule2_bytes" {
     GHC.Int.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.029627209 UTC

[section ""data" . GHC.Int.$trModule1_closure" {
     GHC.Int.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.030426031 UTC

[section ""data" . GHC.Int.$trModule_closure" {
     GHC.Int.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Int.$trModule3_closure+1;
         const GHC.Int.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.031257034 UTC

[section ""data" . $krep_r4kPB_closure" {
     $krep_r4kPB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.032051353 UTC

[section ""data" . GHC.Int.$tcInt7_closure" {
     GHC.Int.$tcInt7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.032819734 UTC

[section ""data" . GHC.Int.$tcInt8_closure" {
     GHC.Int.$tcInt8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt7_closure+1;
         const GHC.Types.krep$*_closure;
         const 1422706860619545536;
         const 2126344328513082648;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.03382889 UTC

[section ""data" . $krep1_r4kPC_closure" {
     $krep1_r4kPC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.034658924 UTC

[section ""data" . GHC.Int.$tc'I8#1_closure" {
     GHC.Int.$tc'I8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep1_r4kPC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.035515316 UTC

[section ""cstring" . GHC.Int.$tc'I8#3_bytes" {
     GHC.Int.$tc'I8#3_bytes:
         I8[] [39,73,56,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.03634502 UTC

[section ""data" . GHC.Int.$tc'I8#2_closure" {
     GHC.Int.$tc'I8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I8#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.03715297 UTC

[section ""data" . GHC.Int.$tc'I8#_closure" {
     GHC.Int.$tc'I8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I8#2_closure+1;
         const GHC.Int.$tc'I8#1_closure+4;
         const 5349338056284818619;
         const 13298037281129101406;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.038053067 UTC

[section ""data" . GHC.Int.$tcInt1_closure" {
     GHC.Int.$tcInt1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.038917001 UTC

[section ""data" . GHC.Int.$tcInt16_closure" {
     GHC.Int.$tcInt16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16329117591681623238;
         const 13363230803330610095;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.039875451 UTC

[section ""data" . $krep2_r4kPD_closure" {
     $krep2_r4kPD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.040731095 UTC

[section ""data" . GHC.Int.$tc'I16#1_closure" {
     GHC.Int.$tc'I16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep2_r4kPD_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.041582329 UTC

[section ""cstring" . GHC.Int.$tc'I16#3_bytes" {
     GHC.Int.$tc'I16#3_bytes:
         I8[] [39,73,49,54,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.042459031 UTC

[section ""data" . GHC.Int.$tc'I16#2_closure" {
     GHC.Int.$tc'I16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I16#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.043401039 UTC

[section ""data" . GHC.Int.$tc'I16#_closure" {
     GHC.Int.$tc'I16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I16#2_closure+1;
         const GHC.Int.$tc'I16#1_closure+4;
         const 1077432500071562197;
         const 13676251251348512601;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.044287788 UTC

[section ""data" . GHC.Int.$tcInt3_closure" {
     GHC.Int.$tcInt3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.045145676 UTC

[section ""data" . GHC.Int.$tcInt32_closure" {
     GHC.Int.$tcInt32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt3_closure+1;
         const GHC.Types.krep$*_closure;
         const 5115671124548181797;
         const 6203735229629729265;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.046214766 UTC

[section ""data" . $krep3_r4kPE_closure" {
     $krep3_r4kPE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.047101846 UTC

[section ""data" . GHC.Int.$tc'I32#1_closure" {
     GHC.Int.$tc'I32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep3_r4kPE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.04796969 UTC

[section ""cstring" . GHC.Int.$tc'I32#3_bytes" {
     GHC.Int.$tc'I32#3_bytes:
         I8[] [39,73,51,50,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.04883149 UTC

[section ""data" . GHC.Int.$tc'I32#2_closure" {
     GHC.Int.$tc'I32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I32#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.049836734 UTC

[section ""data" . GHC.Int.$tc'I32#_closure" {
     GHC.Int.$tc'I32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I32#2_closure+1;
         const GHC.Int.$tc'I32#1_closure+4;
         const 14037617528454219662;
         const 2752255350980319305;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.051914698 UTC

[section ""data" . GHC.Int.$tcInt5_closure" {
     GHC.Int.$tcInt5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.052799586 UTC

[section ""data" . GHC.Int.$tcInt64_closure" {
     GHC.Int.$tcInt64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt5_closure+1;
         const GHC.Types.krep$*_closure;
         const 15049343324344240059;
         const 14445320765379163718;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.053799225 UTC

[section ""data" . $krep4_r4kPF_closure" {
     $krep4_r4kPF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.054626778 UTC

[section ""data" . GHC.Int.$tc'I64#1_closure" {
     GHC.Int.$tc'I64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep4_r4kPF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.055508919 UTC

[section ""cstring" . GHC.Int.$tc'I64#3_bytes" {
     GHC.Int.$tc'I64#3_bytes:
         I8[] [39,73,54,52,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.056343101 UTC

[section ""data" . GHC.Int.$tc'I64#2_closure" {
     GHC.Int.$tc'I64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I64#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.057741548 UTC

[section ""data" . GHC.Int.$tc'I64#_closure" {
     GHC.Int.$tc'I64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I64#2_closure+1;
         const GHC.Int.$tc'I64#1_closure+4;
         const 7755385358338959724;
         const 8520529638322167079;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.058997911 UTC

[section ""data" . GHC.Int.I8#_closure" {
     GHC.Int.I8#_closure:
         const GHC.Int.I8#_info;
 },
 GHC.Int.I8#_entry() //  [R2]
         { info_tbl: [(c4reO,
                       label: GHC.Int.I8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4reO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4reS; else goto c4reR;
       c4reS: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4reR: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.060508935 UTC

[section ""data" . GHC.Int.I16#_closure" {
     GHC.Int.I16#_closure:
         const GHC.Int.I16#_info;
 },
 GHC.Int.I16#_entry() //  [R2]
         { info_tbl: [(c4reY,
                       label: GHC.Int.I16#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4reY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rf2; else goto c4rf1;
       c4rf2: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rf1: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.062028939 UTC

[section ""data" . GHC.Int.I32#_closure" {
     GHC.Int.I32#_closure:
         const GHC.Int.I32#_info;
 },
 GHC.Int.I32#_entry() //  [R2]
         { info_tbl: [(c4rf8,
                       label: GHC.Int.I32#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rf8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rfc; else goto c4rfb;
       c4rfc: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rfb: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.063546663 UTC

[section ""data" . GHC.Int.I64#_closure" {
     GHC.Int.I64#_closure:
         const GHC.Int.I64#_info;
 },
 GHC.Int.I64#_entry() //  [R2]
         { info_tbl: [(c4rfi,
                       label: GHC.Int.I64#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rfi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rfm; else goto c4rfl;
       c4rfm: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rfl: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.06492179 UTC

[GHC.Int.I8#_con_entry() //  [R1]
         { info_tbl: [(c4rfn,
                       label: GHC.Int.I8#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,56,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rfn: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.065804767 UTC

[GHC.Int.I16#_con_entry() //  [R1]
         { info_tbl: [(c4rfp,
                       label: GHC.Int.I16#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,49,54,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rfp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.066523953 UTC

[GHC.Int.I32#_con_entry() //  [R1]
         { info_tbl: [(c4rfr,
                       label: GHC.Int.I32#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,51,50,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rfr: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.067230556 UTC

[GHC.Int.I64#_con_entry() //  [R1]
         { info_tbl: [(c4rft,
                       label: GHC.Int.I64#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,54,52,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rft: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.067899735 UTC

[section ""relreadonly" . S4lDl_srt" {
     S4lDl_srt:
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt8_$cpred_closure;
         const GHC.Int.$fEnumInt7_closure;
         const GHC.Int.$fEnumInt8_$csucc_closure;
         const GHC.Int.$fEnumInt9_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl_r4kPr_closure;
         const GHC.Int.$wlvl2_closure;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum2_closure;
         const GHC.Int.$w$cenumFromThenTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Int.$wgo3_closure;
         const GHC.Int.$fEnumInt8_go_closure;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure;
         const GHC.Int.$fEnumInt8_closure;
         const GHC.Int.$fEnumInt16_$cpred_closure;
         const GHC.Int.$fEnumInt1_closure;
         const GHC.Int.$fEnumInt16_$csucc_closure;
         const GHC.Int.$fEnumInt2_closure;
         const lvl2_r4kPt_closure;
         const GHC.Int.$wlvl_closure;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum_closure;
         const GHC.Int.$w$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$wgo_closure;
         const GHC.Int.$fEnumInt16_go_closure;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure;
         const GHC.Int.$fEnumInt16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt32_$cpred_closure;
         const GHC.Int.$fEnumInt3_closure;
         const GHC.Int.$fEnumInt32_$csucc_closure;
         const GHC.Int.$fEnumInt4_closure;
         const lvl4_r4kPv_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Int.$wlvl1_closure;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum1_closure;
         const GHC.Int.$w$cenumFromTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$wgo1_closure;
         const GHC.Int.$fEnumInt32_go_closure;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure;
         const GHC.Int.$w$cenumFromThenTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt32_closure;
         const GHC.Int.$fEnumInt64_$cpred_closure;
         const GHC.Int.$fEnumInt5_closure;
         const GHC.Int.$fEnumInt64_$csucc_closure;
         const GHC.Int.$fEnumInt6_closure;
         const GHC.Int.$fEnumInt64_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Int.$fReadInt8_$creadsPrec_closure;
         const GHC.Int.$fReadInt13_closure;
         const GHC.Read.list_closure;
         const GHC.Int.$fReadInt12_closure;
         const GHC.Int.$fReadInt11_closure;
         const GHC.Int.$fReadInt8_$creadList_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fIntegralInt8_$cquot_closure;
         const GHC.Int.$fIntegralInt8_$crem_closure;
         const GHC.Int.$w$cdiv3_closure;
         const GHC.Int.$fIntegralInt8_$cdiv_closure;
         const GHC.Int.$fIntegralInt8_$cmod_closure;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure;
         const lvl6_r4kPx_closure;
         const GHC.Int.$w$cdivMod3_closure;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure;
         const sat_s4ldV_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Int.$fRealInt8_$ctoRational_closure;
         const GHC.Int.$fIxInt8_$crange_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fIxInt8_$cindex_closure;
         const GHC.Int.$fReadInt16_$creadsPrec_closure;
         const GHC.Int.$fReadInt3_closure;
         const GHC.Int.$fReadInt2_closure;
         const GHC.Int.$fReadInt1_closure;
         const GHC.Int.$fReadInt16_$creadList_closure;
         const GHC.Int.$fIntegralInt16_$cquot_closure;
         const GHC.Int.$fIntegralInt16_$crem_closure;
         const GHC.Int.$w$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cmod_closure;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure;
         const lvl7_r4kPy_closure;
         const GHC.Int.$w$cdivMod_closure;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure;
         const GHC.Int.$fRealInt16_$ctoRational_closure;
         const GHC.Int.$fIxInt16_$crange_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$fIxInt16_$cindex_closure;
         const GHC.Int.$fReadInt32_$creadsPrec_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Int.$fReadInt6_closure;
         const GHC.Int.$fReadInt5_closure;
         const GHC.Int.$fReadInt4_closure;
         const GHC.Int.$fReadInt32_$creadList_closure;
         const GHC.Int.$fIntegralInt32_$cquot_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Int.$fIntegralInt32_$crem_closure;
         const GHC.Int.$w$cdiv1_closure;
         const GHC.Int.$fIntegralInt32_$cdiv_closure;
         const GHC.Int.$fIntegralInt32_$cmod_closure;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure;
         const lvl8_r4kPz_closure;
         const GHC.Int.$w$cdivMod1_closure;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure;
         const GHC.Int.$fRealInt32_$ctoRational_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Int.$fIxInt32_$crange_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$fIxInt32_$cindex_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fReadInt64_$creadsPrec_closure;
         const GHC.Int.$fReadInt10_closure;
         const GHC.Int.$fReadInt9_closure;
         const GHC.Int.$fReadInt7_closure;
         const GHC.Int.$fReadInt64_$creadList_closure;
         const GHC.Int.$fIntegralInt64_$cquot_closure;
         const GHC.Int.$fIntegralInt64_$crem_closure;
         const GHC.Int.$fIntegralInt64_$cdiv_closure;
         const GHC.Int.$w$cdiv2_closure;
         const GHC.Int.$fIntegralInt64_$cmod_closure;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure;
         const lvl9_r4kPA_closure;
         const GHC.Int.$w$cdivMod2_closure;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure;
         const GHC.Int.$fRealInt64_$ctoRational_closure;
         const GHC.Int.$fIxInt64_$cindex_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.06990233 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:10.072075308 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cfromEnum_closure" {
     GHC.Int.$fEnumInt8_$cfromEnum_closure:
         const GHC.Int.$fEnumInt8_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt8_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4rfC,
                       label: GHC.Int.$fEnumInt8_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rfC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rfG; else goto c4rfH;
       c4rfG: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rfH: // global
           I64[Sp - 8] = block_c4rfz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rfL; else goto c4rfA;
       u4rfL: // global
           call _c4rfz(R1) args: 0, res: 0, upd: 0;
       c4rfA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rfz() //  [R1]
         { info_tbl: [(c4rfz,
                       label: block_c4rfz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rfz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rfK; else goto c4rfJ;
       c4rfK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rfJ: // global
           _s4kPJ::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.079369767 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cfromEnum_closure" {
     GHC.Int.$fEnumInt16_$cfromEnum_closure:
         const GHC.Int.$fEnumInt16_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt16_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4rg3,
                       label: GHC.Int.$fEnumInt16_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rg3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rg7; else goto c4rg8;
       c4rg7: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rg8: // global
           I64[Sp - 8] = block_c4rg0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rgc; else goto c4rg1;
       u4rgc: // global
           call _c4rg0(R1) args: 0, res: 0, upd: 0;
       c4rg1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rg0() //  [R1]
         { info_tbl: [(c4rg0,
                       label: block_c4rg0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rg0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rgb; else goto c4rga;
       c4rgb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rga: // global
           _s4kPM::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPM::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.085506852 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cfromEnum_closure" {
     GHC.Int.$fEnumInt32_$cfromEnum_closure:
         const GHC.Int.$fEnumInt32_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt32_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4rgu,
                       label: GHC.Int.$fEnumInt32_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rgu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rgy; else goto c4rgz;
       c4rgy: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rgz: // global
           I64[Sp - 8] = block_c4rgr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rgD; else goto c4rgs;
       u4rgD: // global
           call _c4rgr(R1) args: 0, res: 0, upd: 0;
       c4rgs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rgr() //  [R1]
         { info_tbl: [(c4rgr,
                       label: block_c4rgr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rgr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rgC; else goto c4rgB;
       c4rgC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rgB: // global
           _s4kPP::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.091901986 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cfromEnum_closure" {
     GHC.Int.$fEnumInt64_$cfromEnum_closure:
         const GHC.Int.$fEnumInt64_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt64_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4rgV,
                       label: GHC.Int.$fEnumInt64_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rgV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rgZ; else goto c4rh0;
       c4rgZ: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rh0: // global
           I64[Sp - 8] = block_c4rgS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rh4; else goto c4rgT;
       u4rh4: // global
           call _c4rgS(R1) args: 0, res: 0, upd: 0;
       c4rgT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rgS() //  [R1]
         { info_tbl: [(c4rgS,
                       label: block_c4rgS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rgS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rh3; else goto c4rh2;
       c4rh3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rh2: // global
           _s4kPS::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.098649276 UTC

[section ""data" . GHC.Int.$fEnumInt64_$ctoEnum_closure" {
     GHC.Int.$fEnumInt64_$ctoEnum_closure:
         const GHC.Int.$fEnumInt64_$ctoEnum_info;
 },
 GHC.Int.$fEnumInt64_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4rhm,
                       label: GHC.Int.$fEnumInt64_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rhm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rhq; else goto c4rhr;
       c4rhq: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rhr: // global
           I64[Sp - 8] = block_c4rhj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rhv; else goto c4rhk;
       u4rhv: // global
           call _c4rhj(R1) args: 0, res: 0, upd: 0;
       c4rhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rhj() //  [R1]
         { info_tbl: [(c4rhj,
                       label: block_c4rhj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rhj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rhu; else goto c4rht;
       c4rhu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rht: // global
           _s4kPV::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kPV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.106204617 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo2_closure" {
     GHC.Int.$w$cenumFromThenTo2_closure:
         const GHC.Int.$w$cenumFromThenTo2_info;
 },
 sat_s4kQ9_entry() //  [R1]
         { info_tbl: [(c4rie,
                       label: sat_s4kQ9_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rie: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rif; else goto c4rig;
       c4rif: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rig: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kQ4_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kQ4_entry() //  [R1, R2]
         { info_tbl: [(c4rik,
                       label: go_dn_s4kQ4_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rik: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4rio; else goto c4rin;
       c4rio: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rin: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4rii; else goto c4rij;
       c4rii: // global
           _s4kQ2::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQ9_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQ2::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rij: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rit::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rit::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kQb_entry() //  [R1]
         { info_tbl: [(c4riu,
                       label: sat_s4kQb_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4riu: // global
           _s4kQb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4riv; else goto c4riw;
       c4riw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4riy; else goto c4rix;
       c4riy: // global
           HpAlloc = 24;
           goto c4riv;
       c4riv: // global
           R1 = _s4kQb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rix: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kQb::P64;
           _s4kPX::I64 = I64[_s4kQb::P64 + 24];
           _s4kQ2::I64 = _s4kPX::I64 - I64[_s4kQb::P64 + 16];
           _s4kQ3::I64 = I64[_s4kQb::P64 + 32] - _s4kQ2::I64;
           I64[Hp - 16] = go_dn_s4kQ4_info;
           I64[Hp - 8] = _s4kQ2::I64;
           I64[Hp] = _s4kQ3::I64;
           R2 = _s4kPX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kQ4_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kQn_entry() //  [R1]
         { info_tbl: [(c4rj1,
                       label: sat_s4kQn_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rj1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rj2; else goto c4rj3;
       c4rj2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rj3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kQi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kQi_entry() //  [R1, R2]
         { info_tbl: [(c4rj7,
                       label: go_up_s4kQi_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rj7: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4rjb; else goto c4rja;
       c4rjb: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rja: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4rj5; else goto c4rj6;
       c4rj5: // global
           _s4kQg::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQn_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQg::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rj6: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rjg::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rjg::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kQp_entry() //  [R1]
         { info_tbl: [(c4rjh,
                       label: sat_s4kQp_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rjh: // global
           _s4kQp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rji; else goto c4rjj;
       c4rjj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rjl; else goto c4rjk;
       c4rjl: // global
           HpAlloc = 24;
           goto c4rji;
       c4rji: // global
           R1 = _s4kQp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rjk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kQp::P64;
           _s4kPX::I64 = I64[_s4kQp::P64 + 24];
           _s4kQg::I64 = _s4kPX::I64 - I64[_s4kQp::P64 + 16];
           _s4kQh::I64 = I64[_s4kQp::P64 + 32] - _s4kQg::I64;
           I64[Hp - 16] = go_up_s4kQi_info;
           I64[Hp - 8] = _s4kQg::I64;
           I64[Hp] = _s4kQh::I64;
           R2 = _s4kPX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kQi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { info_tbl: [(c4rjp,
                       label: GHC.Int.$w$cenumFromThenTo2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rjp: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4rjt; else goto c4rjs;
       c4rjt: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rjs: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4rjn; else goto c4rjo;
       c4rjn: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4rjx; else goto c4rjH;
       c4rjx: // global
           I64[Hp - 72] = sat_s4kQb_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rjH: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4rjU; else goto c4rjF;
       c4rjF: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rjD::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rjD::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rjo: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4rjL; else goto c4rjV;
       c4rjL: // global
           I64[Hp - 72] = sat_s4kQp_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rjV: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4rjU; else goto c4rjT;
       c4rjU: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rjT: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rjR::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rjR::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.128670812 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4rkW,
                       label: GHC.Int.$fEnumInt64_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rkW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rl5; else goto c4rl6;
       c4rl5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rl6: // global
           I64[Sp - 24] = block_c4rkT_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rlf; else goto c4rkU;
       u4rlf: // global
           call _c4rkT(R1) args: 0, res: 0, upd: 0;
       c4rkU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rkT() //  [R1]
         { info_tbl: [(c4rkT,
                       label: block_c4rkT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rkT: // global
           I64[Sp] = block_c4rkZ_info;
           _s4kQw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQw::I64;
           if (R1 & 7 != 0) goto u4rle; else goto c4rl0;
       u4rle: // global
           call _c4rkZ(R1) args: 0, res: 0, upd: 0;
       c4rl0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rkZ() //  [R1]
         { info_tbl: [(c4rkZ,
                       label: block_c4rkZ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rkZ: // global
           I64[Sp] = block_c4rl4_info;
           _s4kQy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kQy::I64;
           if (R1 & 7 != 0) goto u4rlg; else goto c4rl9;
       u4rlg: // global
           call _c4rl4(R1) args: 0, res: 0, upd: 0;
       c4rl9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rl4() //  [R1]
         { info_tbl: [(c4rl4,
                       label: block_c4rl4_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rl4: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo2_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.138645036 UTC

[section ""data" . GHC.Int.$w$cenumFromTo2_closure" {
     GHC.Int.$w$cenumFromTo2_closure:
         const GHC.Int.$w$cenumFromTo2_info;
 },
 sat_s4kQJ_entry() //  [R1]
         { info_tbl: [(c4rlT,
                       label: sat_s4kQJ_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rlT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rlU; else goto c4rlV;
       c4rlU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rlV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kQF::I64 = I64[R1 + 32];
           if (_s4kQF::I64 == I64[R1 + 24]) goto c4rlS; else goto c4rlR;
       c4rlS: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4rlR: // global
           R2 = _s4kQF::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kQE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kQE_entry() //  [R1, R2]
         { info_tbl: [(c4rm0,
                       label: go_s4kQE_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rm0: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4rm4; else goto c4rm3;
       c4rm4: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rm3: // global
           _s4kQC::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQJ_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQC::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo2_entry() //  [R2, R3]
         { info_tbl: [(c4rm8,
                       label: GHC.Int.$w$cenumFromTo2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rm8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rmc; else goto c4rmb;
       c4rmc: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rmb: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4rm6; else goto c4rm7;
       c4rm6: // global
           I64[Hp - 8] = go_s4kQE_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kQE_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4rm7: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.147832349 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4rmA,
                       label: GHC.Int.$fEnumInt64_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rmA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rmE; else goto c4rmF;
       c4rmE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rmF: // global
           I64[Sp - 16] = block_c4rmx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rmN; else goto c4rmy;
       u4rmN: // global
           call _c4rmx(R1) args: 0, res: 0, upd: 0;
       c4rmy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rmx() //  [R1]
         { info_tbl: [(c4rmx,
                       label: block_c4rmx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rmx: // global
           I64[Sp] = block_c4rmD_info;
           _s4kQN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQN::I64;
           if (R1 & 7 != 0) goto u4rmM; else goto c4rmH;
       u4rmM: // global
           call _c4rmD(R1) args: 0, res: 0, upd: 0;
       c4rmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rmD() //  [R1]
         { info_tbl: [(c4rmD,
                       label: block_c4rmD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rmD: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.155468254 UTC

[section ""cstring" . GHC.Int.$tcInt9_bytes" {
     GHC.Int.$tcInt9_bytes:
         I8[] [73,110,116,56]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.158006089 UTC

[section ""data" . GHC.Int.$fEnumInt7_closure" {
     GHC.Int.$fEnumInt7_closure:
         const GHC.Int.$fEnumInt7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt7_entry() //  [R1]
         { info_tbl: [(c4rna,
                       label: GHC.Int.$fEnumInt7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rna: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rnb; else goto c4rnc;
       c4rnb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rnc: // global
           (_c4rn5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rn5::I64 == 0) goto c4rn7; else goto c4rn6;
       c4rn7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rn6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rn5::I64;
           I64[Sp - 24] = block_c4rn8_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4rn8() //  [R1]
         { info_tbl: [(c4rn8,
                       label: block_c4rn8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rn8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.16507179 UTC

[section ""data" . GHC.Int.$fEnumInt9_closure" {
     GHC.Int.$fEnumInt9_closure:
         const GHC.Int.$fEnumInt9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt9_entry() //  [R1]
         { info_tbl: [(c4rny,
                       label: GHC.Int.$fEnumInt9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rny: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rnz; else goto c4rnA;
       c4rnz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rnA: // global
           (_c4rnt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rnt::I64 == 0) goto c4rnv; else goto c4rnu;
       c4rnv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rnu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rnt::I64;
           I64[Sp - 24] = block_c4rnw_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4rnw() //  [R1]
         { info_tbl: [(c4rnw,
                       label: block_c4rnw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rnw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.172082454 UTC

[section ""data" . GHC.Int.neInt8_closure" {
     GHC.Int.neInt8_closure:
         const GHC.Int.neInt8_info;
 },
 GHC.Int.neInt8_entry() //  [R2, R3]
         { info_tbl: [(c4rnV,
                       label: GHC.Int.neInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rnV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rnZ; else goto c4ro0;
       c4rnZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ro0: // global
           I64[Sp - 16] = block_c4rnS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ro9; else goto c4rnT;
       u4ro9: // global
           call _c4rnS(R1) args: 0, res: 0, upd: 0;
       c4rnT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rnS() //  [R1]
         { info_tbl: [(c4rnS,
                       label: block_c4rnS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rnS: // global
           I64[Sp] = block_c4rnY_info;
           _s4kQV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQV::I64;
           if (R1 & 7 != 0) goto u4ro8; else goto c4ro2;
       u4ro8: // global
           call _c4rnY(R1) args: 0, res: 0, upd: 0;
       c4ro2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rnY() //  [R1]
         { info_tbl: [(c4rnY,
                       label: block_c4rnY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rnY: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.18191358 UTC

[section ""data" . lvl_r4kPr_closure" {
     lvl_r4kPr_closure:
         const lvl_r4kPr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r4kPr_entry() //  [R1]
         { info_tbl: [(c4rox,
                       label: lvl_r4kPr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rox: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4roy; else goto c4roz;
       c4roy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4roz: // global
           (_c4rou::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rou::I64 == 0) goto c4row; else goto c4rov;
       c4row: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rov: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rou::I64;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.186302374 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cminBound_closure" {
     GHC.Int.$fBoundedInt8_$cminBound_closure:
         const GHC.Int.I8#_con_info;
         const (-128);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.18846913 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cpred_closure" {
     GHC.Int.$fEnumInt8_$cpred_closure:
         const GHC.Int.$fEnumInt8_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cpred_entry() //  [R2]
         { info_tbl: [(c4roP,
                       label: GHC.Int.$fEnumInt8_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4roP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4roQ; else goto c4roR;
       c4roQ: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4roR: // global
           I64[Sp - 8] = block_c4roM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rp9; else goto c4roN;
       u4rp9: // global
           call _c4roM(R1) args: 0, res: 0, upd: 0;
       c4roN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4roM() //  [R1]
         { info_tbl: [(c4roM,
                       label: block_c4roM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4roM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4roW; else goto c4roV;
       c4roW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4roV: // global
           _s4kR2::I64 = I64[R1 + 7];
           if (_s4kR2::I64 != (-128)) goto c4rp7; else goto c4rp8;
       c4rp7: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4kR2::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rp8: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.19450669 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt8_$cmaxBound_closure:
         const GHC.Int.I8#_con_info;
         const 127;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.196214219 UTC

[section ""data" . GHC.Int.$fBoundedInt8_closure" {
     GHC.Int.$fBoundedInt8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt8_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.198625623 UTC

[section ""data" . GHC.Int.$fEnumInt8_$csucc_closure" {
     GHC.Int.$fEnumInt8_$csucc_closure:
         const GHC.Int.$fEnumInt8_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$csucc_entry() //  [R2]
         { info_tbl: [(c4rpw,
                       label: GHC.Int.$fEnumInt8_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rpw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rpx; else goto c4rpy;
       c4rpx: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rpy: // global
           I64[Sp - 8] = block_c4rpt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rpQ; else goto c4rpu;
       u4rpQ: // global
           call _c4rpt(R1) args: 0, res: 0, upd: 0;
       c4rpu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rpt() //  [R1]
         { info_tbl: [(c4rpt,
                       label: block_c4rpt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rpt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rpD; else goto c4rpC;
       c4rpD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rpC: // global
           _s4kR8::I64 = I64[R1 + 7];
           if (_s4kR8::I64 != 127) goto c4rpO; else goto c4rpP;
       c4rpO: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4kR8::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rpP: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.206039216 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowsPrec_closure" {
     GHC.Int.$fShowInt8_$cshowsPrec_closure:
         const GHC.Int.$fShowInt8_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt8_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4rqb,
                       label: GHC.Int.$fShowInt8_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rqb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rqm; else goto c4rqn;
       c4rqm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rqn: // global
           I64[Sp - 24] = block_c4rq8_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rqu; else goto c4rq9;
       u4rqu: // global
           call _c4rq8(R1) args: 0, res: 0, upd: 0;
       c4rq9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rq8() //  [R1]
         { info_tbl: [(c4rq8,
                       label: block_c4rq8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rq8: // global
           I64[Sp] = block_c4rqe_info;
           _s4kRf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kRf::I64;
           if (R1 & 7 != 0) goto u4rqt; else goto c4rqf;
       u4rqt: // global
           call _c4rqe(R1) args: 0, res: 0, upd: 0;
       c4rqf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rqe() //  [R1]
         { info_tbl: [(c4rqe,
                       label: block_c4rqe_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rqe: // global
           _s4kRd::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4rqj_info;
           R4 = _s4kRd::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rqj() //  [R1, R2]
         { info_tbl: [(c4rqj,
                       label: block_c4rqj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rqj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rqs; else goto c4rqr;
       c4rqs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rqr: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.215560275 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshow_closure" {
     GHC.Int.$fShowInt8_$cshow_closure:
         const GHC.Int.$fShowInt8_$cshow_info;
 },
 GHC.Int.$fShowInt8_$cshow_entry() //  [R2]
         { info_tbl: [(c4rqT,
                       label: GHC.Int.$fShowInt8_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rqT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rqZ; else goto c4rr0;
       c4rqZ: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rr0: // global
           I64[Sp - 8] = block_c4rqQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rr5; else goto c4rqR;
       u4rr5: // global
           call _c4rqQ(R1) args: 0, res: 0, upd: 0;
       c4rqR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rqQ() //  [R1]
         { info_tbl: [(c4rqQ,
                       label: block_c4rqQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rqQ: // global
           I64[Sp] = block_c4rqW_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rqW() //  [R1, R2]
         { info_tbl: [(c4rqW,
                       label: block_c4rqW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rqW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rr4; else goto c4rr3;
       c4rr4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rr3: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.224152242 UTC

[section ""data" . GHC.Int.$fShowInt4_closure" {
     GHC.Int.$fShowInt4_closure:
         const GHC.Int.$fShowInt4_info;
 },
 GHC.Int.$fShowInt4_entry() //  [R2, R3]
         { info_tbl: [(c4rrq,
                       label: GHC.Int.$fShowInt4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rrq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rrw; else goto c4rrx;
       c4rrw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rrx: // global
           I64[Sp - 16] = block_c4rrn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rrC; else goto c4rro;
       u4rrC: // global
           call _c4rrn(R1) args: 0, res: 0, upd: 0;
       c4rro: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rrn() //  [R1]
         { info_tbl: [(c4rrn,
                       label: block_c4rrn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rrn: // global
           _s4kRs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4rrt_info;
           R4 = _s4kRs::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rrt() //  [R1, R2]
         { info_tbl: [(c4rrt,
                       label: block_c4rrt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rrt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rrB; else goto c4rrA;
       c4rrB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rrA: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.231988667 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowList_closure" {
     GHC.Int.$fShowInt8_$cshowList_closure:
         const GHC.Int.$fShowInt8_$cshowList_info;
 },
 GHC.Int.$fShowInt8_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4rrU,
                       label: GHC.Int.$fShowInt8_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rrU: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.235460144 UTC

[section ""data" . GHC.Int.$fShowInt8_closure" {
     GHC.Int.$fShowInt8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt8_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt8_$cshow_closure+1;
         const GHC.Int.$fShowInt8_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.237547841 UTC

[section ""data" . GHC.Int.$wlvl2_closure" {
     GHC.Int.$wlvl2_closure:
         const GHC.Int.$wlvl2_info;
         const 0;
 },
 GHC.Int.$wlvl2_entry() //  [R2]
         { info_tbl: [(c4rs6,
                       label: GHC.Int.$wlvl2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rs6: // global
           R6 = GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl_r4kPr_closure;
           R2 = GHC.Int.$fShowInt8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.241656322 UTC

[section ""data" . GHC.Int.$w$ctoEnum2_closure" {
     GHC.Int.$w$ctoEnum2_closure:
         const GHC.Int.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum2_entry() //  [R2]
         { info_tbl: [(c4rsm,
                       label: GHC.Int.$w$ctoEnum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rsm: // global
           _s4kRB::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-128))) goto c4rsu; else goto c4rsl;
       c4rsl: // global
           if (%MO_S_Gt_W64(_s4kRB::I64, 127)) goto c4rsu; else goto c4rsv;
       c4rsu: // global
           R2 = _s4kRB::I64;
           call GHC.Int.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c4rsv: // global
           R1 = _s4kRB::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.246152875 UTC

[section ""data" . GHC.Int.$fEnumInt8_$ctoEnum_closure" {
     GHC.Int.$fEnumInt8_$ctoEnum_closure:
         const GHC.Int.$fEnumInt8_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4rsI,
                       label: GHC.Int.$fEnumInt8_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rsI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rsQ; else goto c4rsR;
       c4rsQ: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rsR: // global
           I64[Sp - 8] = block_c4rsF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rsW; else goto c4rsG;
       u4rsW: // global
           call _c4rsF(R1) args: 0, res: 0, upd: 0;
       c4rsG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rsF() //  [R1]
         { info_tbl: [(c4rsF,
                       label: block_c4rsF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rsF: // global
           I64[Sp] = block_c4rsL_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rsL() //  [R1]
         { info_tbl: [(c4rsL,
                       label: block_c4rsL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rsL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rsV; else goto c4rsU;
       c4rsV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4rsU: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.257371752 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo3_closure" {
     GHC.Int.$w$cenumFromThenTo3_closure:
         const GHC.Int.$w$cenumFromThenTo3_info;
         const 0;
 },
 sat_s4kS1_entry() //  [R1]
         { info_tbl: [(c4rtI,
                       label: sat_s4kS1_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rtI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rtJ; else goto c4rtK;
       c4rtJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rtK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kRU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kRZ_entry() //  [R1]
         { info_tbl: [(c4rtU,
                       label: sat_s4kRZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rtU: // global
           _s4kRZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rtV; else goto c4rtW;
       c4rtW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rtY; else goto c4rtX;
       c4rtY: // global
           HpAlloc = 16;
           goto c4rtV;
       c4rtV: // global
           R1 = _s4kRZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rtX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kRZ::P64;
           _s4kRV::I64 = I64[_s4kRZ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRV::I64, (-128))) goto c4ru4; else goto c4rtT;
       c4rtT: // global
           if (%MO_S_Gt_W64(_s4kRV::I64, 127)) goto c4ru4; else goto c4ru8;
       c4ru4: // global
           Hp = Hp - 16;
           R2 = _s4kRV::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4ru8: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kS4_entry() //  [R1]
         { info_tbl: [(c4ruj,
                       label: sat_s4kS4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ruj: // global
           _s4kS4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ruk; else goto c4rul;
       c4rul: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4run; else goto c4rum;
       c4run: // global
           HpAlloc = 16;
           goto c4ruk;
       c4ruk: // global
           R1 = _s4kS4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rum: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS4::P64;
           _s4kRV::I64 = I64[_s4kS4::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRV::I64, (-128))) goto c4rut; else goto c4rui;
       c4rui: // global
           if (%MO_S_Gt_W64(_s4kRV::I64, 127)) goto c4rut; else goto c4rux;
       c4rut: // global
           Hp = Hp - 16;
           R2 = _s4kRV::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rux: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kRU_entry() //  [R1, R2]
         { info_tbl: [(c4ruB,
                       label: go_dn_s4kRU_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ruB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4ruF; else goto c4ruE;
       c4ruF: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ruE: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4ruz; else goto c4ruA;
       c4ruz: // global
           _s4kRS::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kS1_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kRS::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kRZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ruA: // global
           I64[Hp - 80] = sat_s4kS4_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4ruH::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4ruH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kS5_entry() //  [R1]
         { info_tbl: [(c4ruI,
                       label: sat_s4kS5_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ruI: // global
           _s4kS5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ruJ; else goto c4ruK;
       c4ruK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ruM; else goto c4ruL;
       c4ruM: // global
           HpAlloc = 24;
           goto c4ruJ;
       c4ruJ: // global
           R1 = _s4kS5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ruL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS5::P64;
           _s4kRL::I64 = I64[_s4kS5::P64 + 24];
           _s4kRS::I64 = _s4kRL::I64 - I64[_s4kS5::P64 + 16];
           _s4kRT::I64 = I64[_s4kS5::P64 + 32] - _s4kRS::I64;
           I64[Hp - 16] = go_dn_s4kRU_info;
           I64[Hp - 8] = _s4kRS::I64;
           I64[Hp] = _s4kRT::I64;
           R2 = _s4kRL::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kRU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kRR_entry() //  [R1]
         { info_tbl: [(c4ruW,
                       label: sat_s4kRR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ruW: // global
           _s4kRR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ruX; else goto c4ruY;
       c4ruY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rv0; else goto c4ruZ;
       c4rv0: // global
           HpAlloc = 16;
           goto c4ruX;
       c4ruX: // global
           R1 = _s4kRR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ruZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kRR::P64;
           _s4kRK::I64 = I64[_s4kRR::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4rv6; else goto c4ruV;
       c4ruV: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4rv6; else goto c4rva;
       c4rv6: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rva: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kS9_entry() //  [R1]
         { info_tbl: [(c4rvo,
                       label: sat_s4kS9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rvo: // global
           _s4kS9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rvp; else goto c4rvq;
       c4rvq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rvs; else goto c4rvr;
       c4rvs: // global
           HpAlloc = 16;
           goto c4rvp;
       c4rvp: // global
           R1 = _s4kS9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rvr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS9::P64;
           _s4kRK::I64 = I64[_s4kS9::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4rvy; else goto c4rvn;
       c4rvn: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4rvy; else goto c4rvC;
       c4rvy: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rvC: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSn_entry() //  [R1]
         { info_tbl: [(c4rw5,
                       label: sat_s4kSn_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rw5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rw6; else goto c4rw7;
       c4rw6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rw7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kSg_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSl_entry() //  [R1]
         { info_tbl: [(c4rwh,
                       label: sat_s4kSl_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rwh: // global
           _s4kSl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rwi; else goto c4rwj;
       c4rwj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rwl; else goto c4rwk;
       c4rwl: // global
           HpAlloc = 16;
           goto c4rwi;
       c4rwi: // global
           R1 = _s4kSl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rwk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSl::P64;
           _s4kSh::I64 = I64[_s4kSl::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSh::I64, (-128))) goto c4rwr; else goto c4rwg;
       c4rwg: // global
           if (%MO_S_Gt_W64(_s4kSh::I64, 127)) goto c4rwr; else goto c4rwv;
       c4rwr: // global
           Hp = Hp - 16;
           R2 = _s4kSh::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rwv: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSh::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSq_entry() //  [R1]
         { info_tbl: [(c4rwG,
                       label: sat_s4kSq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rwG: // global
           _s4kSq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rwH; else goto c4rwI;
       c4rwI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rwK; else goto c4rwJ;
       c4rwK: // global
           HpAlloc = 16;
           goto c4rwH;
       c4rwH: // global
           R1 = _s4kSq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rwJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSq::P64;
           _s4kSh::I64 = I64[_s4kSq::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSh::I64, (-128))) goto c4rwQ; else goto c4rwF;
       c4rwF: // global
           if (%MO_S_Gt_W64(_s4kSh::I64, 127)) goto c4rwQ; else goto c4rwU;
       c4rwQ: // global
           Hp = Hp - 16;
           R2 = _s4kSh::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rwU: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSh::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kSg_entry() //  [R1, R2]
         { info_tbl: [(c4rwY,
                       label: go_up_s4kSg_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rwY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rx2; else goto c4rx1;
       c4rx2: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rx1: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4rwW; else goto c4rwX;
       c4rwW: // global
           _s4kSe::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kSn_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kSe::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kSl_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rwX: // global
           I64[Hp - 80] = sat_s4kSq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rx4::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rx4::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kSr_entry() //  [R1]
         { info_tbl: [(c4rx5,
                       label: sat_s4kSr_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rx5: // global
           _s4kSr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rx6; else goto c4rx7;
       c4rx7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rx9; else goto c4rx8;
       c4rx9: // global
           HpAlloc = 24;
           goto c4rx6;
       c4rx6: // global
           R1 = _s4kSr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rx8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSr::P64;
           _s4kRL::I64 = I64[_s4kSr::P64 + 24];
           _s4kSe::I64 = _s4kRL::I64 - I64[_s4kSr::P64 + 16];
           _s4kSf::I64 = I64[_s4kSr::P64 + 32] - _s4kSe::I64;
           I64[Hp - 16] = go_up_s4kSg_info;
           I64[Hp - 8] = _s4kSe::I64;
           I64[Hp] = _s4kSf::I64;
           R2 = _s4kRL::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kSg_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSd_entry() //  [R1]
         { info_tbl: [(c4rxj,
                       label: sat_s4kSd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rxj: // global
           _s4kSd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rxk; else goto c4rxl;
       c4rxl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rxn; else goto c4rxm;
       c4rxn: // global
           HpAlloc = 16;
           goto c4rxk;
       c4rxk: // global
           R1 = _s4kSd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rxm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSd::P64;
           _s4kRK::I64 = I64[_s4kSd::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4rxt; else goto c4rxi;
       c4rxi: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4rxt; else goto c4rxx;
       c4rxt: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rxx: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSv_entry() //  [R1]
         { info_tbl: [(c4rxL,
                       label: sat_s4kSv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rxL: // global
           _s4kSv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rxM; else goto c4rxN;
       c4rxN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rxP; else goto c4rxO;
       c4rxP: // global
           HpAlloc = 16;
           goto c4rxM;
       c4rxM: // global
           R1 = _s4kSv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rxO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSv::P64;
           _s4kRK::I64 = I64[_s4kSv::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4rxV; else goto c4rxK;
       c4rxK: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4rxV; else goto c4rxZ;
       c4rxV: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rxZ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4ry3,
                       label: GHC.Int.$w$cenumFromThenTo3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ry3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4ry7; else goto c4ry6;
       c4ry7: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ry6: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4ry1; else goto c4ry2;
       c4ry1: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4rya; else goto c4ryf;
       c4rya: // global
           I64[Hp - 80] = sat_s4kS5_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kRR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ryf: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4rym; else goto c4ryd;
       c4ryd: // global
           I64[Hp - 80] = sat_s4kS9_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4ryb::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4ryb::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ry2: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4ryi; else goto c4ryn;
       c4ryi: // global
           I64[Hp - 80] = sat_s4kSr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kSd_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ryn: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4rym; else goto c4ryl;
       c4rym: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ryl: // global
           I64[Hp - 80] = sat_s4kSv_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4ryj::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4ryj::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.305375428 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4rA2,
                       label: GHC.Int.$fEnumInt8_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rA2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rAb; else goto c4rAc;
       c4rAb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rAc: // global
           I64[Sp - 24] = block_c4rzZ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rAl; else goto c4rA0;
       u4rAl: // global
           call _c4rzZ(R1) args: 0, res: 0, upd: 0;
       c4rA0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rzZ() //  [R1]
         { info_tbl: [(c4rzZ,
                       label: block_c4rzZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rzZ: // global
           I64[Sp] = block_c4rA5_info;
           _s4kSA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kSA::I64;
           if (R1 & 7 != 0) goto u4rAk; else goto c4rA6;
       u4rAk: // global
           call _c4rA5(R1) args: 0, res: 0, upd: 0;
       c4rA6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rA5() //  [R1]
         { info_tbl: [(c4rA5,
                       label: block_c4rA5_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rA5: // global
           I64[Sp] = block_c4rAa_info;
           _s4kSC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kSC::I64;
           if (R1 & 7 != 0) goto u4rAm; else goto c4rAf;
       u4rAm: // global
           call _c4rAa(R1) args: 0, res: 0, upd: 0;
       c4rAf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rAa() //  [R1]
         { info_tbl: [(c4rAa,
                       label: block_c4rAa_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rAa: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo3_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.316085836 UTC

[section ""data" . GHC.Int.$w$cenumFromTo3_closure" {
     GHC.Int.$w$cenumFromTo3_closure:
         const GHC.Int.$w$cenumFromTo3_info;
         const 0;
 },
 sat_s4kSP_entry() //  [R1]
         { info_tbl: [(c4rAZ,
                       label: sat_s4kSP_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rAZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rB0; else goto c4rB1;
       c4rB0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rB1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kSJ::I64 = I64[R1 + 32];
           if (_s4kSJ::I64 == I64[R1 + 24]) goto c4rAY; else goto c4rAX;
       c4rAY: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4rAX: // global
           R2 = _s4kSJ::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kSI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSM_entry() //  [R1]
         { info_tbl: [(c4rBd,
                       label: sat_s4kSM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rBd: // global
           _s4kSM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rBe; else goto c4rBf;
       c4rBf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rBh; else goto c4rBg;
       c4rBh: // global
           HpAlloc = 16;
           goto c4rBe;
       c4rBe: // global
           R1 = _s4kSM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rBg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSM::P64;
           _s4kSJ::I64 = I64[_s4kSM::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSJ::I64, (-128))) goto c4rBn; else goto c4rBc;
       c4rBc: // global
           if (%MO_S_Gt_W64(_s4kSJ::I64, 127)) goto c4rBn; else goto c4rBr;
       c4rBn: // global
           Hp = Hp - 16;
           R2 = _s4kSJ::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rBr: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSJ::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kSI_entry() //  [R1, R2]
         { info_tbl: [(c4rBt,
                       label: go_s4kSI_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rBt: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rBx; else goto c4rBw;
       c4rBx: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rBw: // global
           _s4kSG::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kSP_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kSG::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kSM_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo3_entry() //  [R2, R3]
         { info_tbl: [(c4rBB,
                       label: GHC.Int.$w$cenumFromTo3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rBB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rBF; else goto c4rBE;
       c4rBF: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rBE: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4rBz; else goto c4rBA;
       c4rBz: // global
           I64[Hp - 8] = go_s4kSI_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kSI_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4rBA: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.32794852 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4rC8,
                       label: GHC.Int.$fEnumInt8_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rC8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rCc; else goto c4rCd;
       c4rCc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rCd: // global
           I64[Sp - 16] = block_c4rC5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rCl; else goto c4rC6;
       u4rCl: // global
           call _c4rC5(R1) args: 0, res: 0, upd: 0;
       c4rC6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rC5() //  [R1]
         { info_tbl: [(c4rC5,
                       label: block_c4rC5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rC5: // global
           I64[Sp] = block_c4rCb_info;
           _s4kST::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kST::I64;
           if (R1 & 7 != 0) goto u4rCk; else goto c4rCf;
       u4rCk: // global
           call _c4rCb(R1) args: 0, res: 0, upd: 0;
       c4rCf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rCb() //  [R1]
         { info_tbl: [(c4rCb,
                       label: block_c4rCb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rCb: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo3_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.337776152 UTC

[section ""data" . GHC.Int.$wgo3_closure" {
     GHC.Int.$wgo3_closure:
         const GHC.Int.$wgo3_info;
         const 0;
 },
 sat_s4kT5_entry() //  [R1]
         { info_tbl: [(c4rCL,
                       label: sat_s4kT5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rCL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rCM; else goto c4rCX;
       c4rCM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rCX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kT0::I64 = I64[R1 + 16];
           if (_s4kT0::I64 != 127) goto c4rCJ; else goto c4rCK;
       c4rCJ: // global
           I64[Sp - 24] = block_c4rCR_info;
           R2 = _s4kT0::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 24;
       c4rCK: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4rCR() //  [R1, R2]
         { info_tbl: [(c4rCR,
                       label: block_c4rCR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rCR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rCW; else goto c4rCV;
       c4rCW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4rCV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kSZ_entry() //  [R1]
         { info_tbl: [(c4rD7,
                       label: sat_s4kSZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rD7: // global
           _s4kSZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rD8; else goto c4rD9;
       c4rD9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rDb; else goto c4rDa;
       c4rDb: // global
           HpAlloc = 16;
           goto c4rD8;
       c4rD8: // global
           R1 = _s4kSZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rDa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSZ::P64;
           _s4kSW::I64 = I64[_s4kSZ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSW::I64, (-128))) goto c4rDh; else goto c4rD6;
       c4rD6: // global
           if (%MO_S_Gt_W64(_s4kSW::I64, 127)) goto c4rDh; else goto c4rDl;
       c4rDh: // global
           Hp = Hp - 16;
           R2 = _s4kSW::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rDl: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo3_entry() //  [R2]
         { info_tbl: [(c4rDm,
                       label: GHC.Int.$wgo3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rDm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4rDq; else goto c4rDp;
       c4rDq: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rDp: // global
           I64[Hp - 40] = sat_s4kT5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kSZ_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.348901613 UTC

[section ""data" . GHC.Int.$fEnumInt8_go_closure" {
     GHC.Int.$fEnumInt8_go_closure:
         const GHC.Int.$fEnumInt8_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_go_entry() //  [R2]
         { info_tbl: [(c4rDR,
                       label: GHC.Int.$fEnumInt8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rDR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rDS; else goto c4rDT;
       c4rDS: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rDT: // global
           I64[Sp - 8] = block_c4rDO_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rDO() //  [R1, R2]
         { info_tbl: [(c4rDO,
                       label: block_c4rDO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rDO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rDW; else goto c4rDV;
       c4rDW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rDV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.356225165 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFrom_closure" {
     GHC.Int.$fEnumInt8_$cenumFrom_closure:
         const GHC.Int.$fEnumInt8_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4rEd,
                       label: GHC.Int.$fEnumInt8_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rEd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rEe; else goto c4rEf;
       c4rEe: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rEf: // global
           I64[Sp - 8] = block_c4rEa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rEo; else goto c4rEb;
       u4rEo: // global
           call _c4rEa(R1) args: 0, res: 0, upd: 0;
       c4rEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rEa() //  [R1]
         { info_tbl: [(c4rEa,
                       label: block_c4rEa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rEa: // global
           _s4kTc::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kTc::I64, 127)) goto c4rEm; else goto c4rEn;
       c4rEm: // global
           R2 = _s4kTc::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_go_entry(R2) args: 8, res: 0, upd: 8;
       c4rEn: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.363397698 UTC

[section ""data" . GHC.Int.$fEnumInt8_closure" {
     GHC.Int.$fEnumInt8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt8_$csucc_closure+1;
         const GHC.Int.$fEnumInt8_$cpred_closure+1;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt8_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4rED,
                       label: GHC.Int.$fEnumInt8_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rED: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt8_closure+1;
           R2 = GHC.Int.$fEnumInt8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.368540875 UTC

[section ""cstring" . GHC.Int.$tcInt2_bytes" {
     GHC.Int.$tcInt2_bytes:
         I8[] [73,110,116,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.370753755 UTC

[section ""data" . GHC.Int.$fEnumInt1_closure" {
     GHC.Int.$fEnumInt1_closure:
         const GHC.Int.$fEnumInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt1_entry() //  [R1]
         { info_tbl: [(c4rEU,
                       label: GHC.Int.$fEnumInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rEU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rEV; else goto c4rEW;
       c4rEV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rEW: // global
           (_c4rEP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rEP::I64 == 0) goto c4rER; else goto c4rEQ;
       c4rER: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rEQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rEP::I64;
           I64[Sp - 24] = block_c4rES_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4rES() //  [R1]
         { info_tbl: [(c4rES,
                       label: block_c4rES_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rES: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.377209504 UTC

[section ""data" . GHC.Int.$fEnumInt2_closure" {
     GHC.Int.$fEnumInt2_closure:
         const GHC.Int.$fEnumInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt2_entry() //  [R1]
         { info_tbl: [(c4rFi,
                       label: GHC.Int.$fEnumInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rFi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rFj; else goto c4rFk;
       c4rFj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rFk: // global
           (_c4rFd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rFd::I64 == 0) goto c4rFf; else goto c4rFe;
       c4rFf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rFe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rFd::I64;
           I64[Sp - 24] = block_c4rFg_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4rFg() //  [R1]
         { info_tbl: [(c4rFg,
                       label: block_c4rFg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rFg: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.38377358 UTC

[section ""data" . GHC.Int.neInt16_closure" {
     GHC.Int.neInt16_closure:
         const GHC.Int.neInt16_info;
 },
 GHC.Int.neInt16_entry() //  [R2, R3]
         { info_tbl: [(c4rFF,
                       label: GHC.Int.neInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rFF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rFJ; else goto c4rFK;
       c4rFJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rFK: // global
           I64[Sp - 16] = block_c4rFC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rFT; else goto c4rFD;
       u4rFT: // global
           call _c4rFC(R1) args: 0, res: 0, upd: 0;
       c4rFD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rFC() //  [R1]
         { info_tbl: [(c4rFC,
                       label: block_c4rFC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rFC: // global
           I64[Sp] = block_c4rFI_info;
           _s4kTj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kTj::I64;
           if (R1 & 7 != 0) goto u4rFS; else goto c4rFM;
       u4rFS: // global
           call _c4rFI(R1) args: 0, res: 0, upd: 0;
       c4rFM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rFI() //  [R1]
         { info_tbl: [(c4rFI,
                       label: block_c4rFI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rFI: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.392012652 UTC

[section ""data" . lvl2_r4kPt_closure" {
     lvl2_r4kPt_closure:
         const lvl2_r4kPt_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r4kPt_entry() //  [R1]
         { info_tbl: [(c4rGh,
                       label: lvl2_r4kPt_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rGh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rGi; else goto c4rGj;
       c4rGi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rGj: // global
           (_c4rGe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rGe::I64 == 0) goto c4rGg; else goto c4rGf;
       c4rGg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rGf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rGe::I64;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.3960063 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cminBound_closure" {
     GHC.Int.$fBoundedInt16_$cminBound_closure:
         const GHC.Int.I16#_con_info;
         const (-32768);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.398273356 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cpred_closure" {
     GHC.Int.$fEnumInt16_$cpred_closure:
         const GHC.Int.$fEnumInt16_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cpred_entry() //  [R2]
         { info_tbl: [(c4rGz,
                       label: GHC.Int.$fEnumInt16_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rGz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rGA; else goto c4rGB;
       c4rGA: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rGB: // global
           I64[Sp - 8] = block_c4rGw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rGT; else goto c4rGx;
       u4rGT: // global
           call _c4rGw(R1) args: 0, res: 0, upd: 0;
       c4rGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rGw() //  [R1]
         { info_tbl: [(c4rGw,
                       label: block_c4rGw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rGw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rGG; else goto c4rGF;
       c4rGG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rGF: // global
           _s4kTq::I64 = I64[R1 + 7];
           if (_s4kTq::I64 != (-32768)) goto c4rGR; else goto c4rGS;
       c4rGR: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4kTq::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rGS: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.40438148 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt16_$cmaxBound_closure:
         const GHC.Int.I16#_con_info;
         const 32767;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.406659077 UTC

[section ""data" . GHC.Int.$fBoundedInt16_closure" {
     GHC.Int.$fBoundedInt16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt16_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.409075389 UTC

[section ""data" . GHC.Int.$fEnumInt16_$csucc_closure" {
     GHC.Int.$fEnumInt16_$csucc_closure:
         const GHC.Int.$fEnumInt16_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$csucc_entry() //  [R2]
         { info_tbl: [(c4rHg,
                       label: GHC.Int.$fEnumInt16_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rHg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rHh; else goto c4rHi;
       c4rHh: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rHi: // global
           I64[Sp - 8] = block_c4rHd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rHA; else goto c4rHe;
       u4rHA: // global
           call _c4rHd(R1) args: 0, res: 0, upd: 0;
       c4rHe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rHd() //  [R1]
         { info_tbl: [(c4rHd,
                       label: block_c4rHd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rHd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rHn; else goto c4rHm;
       c4rHn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rHm: // global
           _s4kTw::I64 = I64[R1 + 7];
           if (_s4kTw::I64 != 32767) goto c4rHy; else goto c4rHz;
       c4rHy: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4kTw::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rHz: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.416517623 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowsPrec_closure" {
     GHC.Int.$fShowInt16_$cshowsPrec_closure:
         const GHC.Int.$fShowInt16_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt16_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4rHV,
                       label: GHC.Int.$fShowInt16_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rHV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rI6; else goto c4rI7;
       c4rI6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rI7: // global
           I64[Sp - 24] = block_c4rHS_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rIe; else goto c4rHT;
       u4rIe: // global
           call _c4rHS(R1) args: 0, res: 0, upd: 0;
       c4rHT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rHS() //  [R1]
         { info_tbl: [(c4rHS,
                       label: block_c4rHS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rHS: // global
           I64[Sp] = block_c4rHY_info;
           _s4kTD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kTD::I64;
           if (R1 & 7 != 0) goto u4rId; else goto c4rHZ;
       u4rId: // global
           call _c4rHY(R1) args: 0, res: 0, upd: 0;
       c4rHZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rHY() //  [R1]
         { info_tbl: [(c4rHY,
                       label: block_c4rHY_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rHY: // global
           _s4kTB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4rI3_info;
           R4 = _s4kTB::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rI3() //  [R1, R2]
         { info_tbl: [(c4rI3,
                       label: block_c4rI3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rI3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rIc; else goto c4rIb;
       c4rIc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rIb: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.426756165 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshow_closure" {
     GHC.Int.$fShowInt16_$cshow_closure:
         const GHC.Int.$fShowInt16_$cshow_info;
 },
 GHC.Int.$fShowInt16_$cshow_entry() //  [R2]
         { info_tbl: [(c4rID,
                       label: GHC.Int.$fShowInt16_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rID: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rIJ; else goto c4rIK;
       c4rIJ: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rIK: // global
           I64[Sp - 8] = block_c4rIA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rIP; else goto c4rIB;
       u4rIP: // global
           call _c4rIA(R1) args: 0, res: 0, upd: 0;
       c4rIB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rIA() //  [R1]
         { info_tbl: [(c4rIA,
                       label: block_c4rIA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rIA: // global
           I64[Sp] = block_c4rIG_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rIG() //  [R1, R2]
         { info_tbl: [(c4rIG,
                       label: block_c4rIG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rIG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rIO; else goto c4rIN;
       c4rIO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rIN: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.435044459 UTC

[section ""data" . GHC.Int.$fShowInt1_closure" {
     GHC.Int.$fShowInt1_closure:
         const GHC.Int.$fShowInt1_info;
 },
 GHC.Int.$fShowInt1_entry() //  [R2, R3]
         { info_tbl: [(c4rJa,
                       label: GHC.Int.$fShowInt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rJa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rJg; else goto c4rJh;
       c4rJg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rJh: // global
           I64[Sp - 16] = block_c4rJ7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rJm; else goto c4rJ8;
       u4rJm: // global
           call _c4rJ7(R1) args: 0, res: 0, upd: 0;
       c4rJ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rJ7() //  [R1]
         { info_tbl: [(c4rJ7,
                       label: block_c4rJ7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rJ7: // global
           _s4kTQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4rJd_info;
           R4 = _s4kTQ::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rJd() //  [R1, R2]
         { info_tbl: [(c4rJd,
                       label: block_c4rJd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rJd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rJl; else goto c4rJk;
       c4rJl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rJk: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.442723531 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowList_closure" {
     GHC.Int.$fShowInt16_$cshowList_closure:
         const GHC.Int.$fShowInt16_$cshowList_info;
 },
 GHC.Int.$fShowInt16_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4rJE,
                       label: GHC.Int.$fShowInt16_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rJE: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.446755164 UTC

[section ""data" . GHC.Int.$fShowInt16_closure" {
     GHC.Int.$fShowInt16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt16_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt16_$cshow_closure+1;
         const GHC.Int.$fShowInt16_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.448789885 UTC

[section ""data" . GHC.Int.$wlvl_closure" {
     GHC.Int.$wlvl_closure:
         const GHC.Int.$wlvl_info;
         const 0;
 },
 GHC.Int.$wlvl_entry() //  [R2]
         { info_tbl: [(c4rJQ,
                       label: GHC.Int.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rJQ: // global
           R6 = GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r4kPt_closure;
           R2 = GHC.Int.$fShowInt16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.454068719 UTC

[section ""data" . GHC.Int.$w$ctoEnum_closure" {
     GHC.Int.$w$ctoEnum_closure:
         const GHC.Int.$w$ctoEnum_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4rK6,
                       label: GHC.Int.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rK6: // global
           _s4kTZ::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-32768))) goto c4rKe; else goto c4rK5;
       c4rK5: // global
           if (%MO_S_Gt_W64(_s4kTZ::I64, 32767)) goto c4rKe; else goto c4rKf;
       c4rKe: // global
           R2 = _s4kTZ::I64;
           call GHC.Int.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c4rKf: // global
           R1 = _s4kTZ::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.4584304 UTC

[section ""data" . GHC.Int.$fEnumInt16_$ctoEnum_closure" {
     GHC.Int.$fEnumInt16_$ctoEnum_closure:
         const GHC.Int.$fEnumInt16_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4rKs,
                       label: GHC.Int.$fEnumInt16_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rKs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rKA; else goto c4rKB;
       c4rKA: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rKB: // global
           I64[Sp - 8] = block_c4rKp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rKG; else goto c4rKq;
       u4rKG: // global
           call _c4rKp(R1) args: 0, res: 0, upd: 0;
       c4rKq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rKp() //  [R1]
         { info_tbl: [(c4rKp,
                       label: block_c4rKp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rKp: // global
           I64[Sp] = block_c4rKv_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rKv() //  [R1]
         { info_tbl: [(c4rKv,
                       label: block_c4rKv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rKv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rKF; else goto c4rKE;
       c4rKF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4rKE: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.47267228 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo_closure" {
     GHC.Int.$w$cenumFromThenTo_closure:
         const GHC.Int.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s4kUp_entry() //  [R1]
         { info_tbl: [(c4rLs,
                       label: sat_s4kUp_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rLs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rLt; else goto c4rLu;
       c4rLt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rLu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kUi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUn_entry() //  [R1]
         { info_tbl: [(c4rLE,
                       label: sat_s4kUn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rLE: // global
           _s4kUn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rLF; else goto c4rLG;
       c4rLG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rLI; else goto c4rLH;
       c4rLI: // global
           HpAlloc = 16;
           goto c4rLF;
       c4rLF: // global
           R1 = _s4kUn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rLH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUn::P64;
           _s4kUj::I64 = I64[_s4kUn::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUj::I64,
                            (-32768))) goto c4rLO; else goto c4rLD;
       c4rLD: // global
           if (%MO_S_Gt_W64(_s4kUj::I64, 32767)) goto c4rLO; else goto c4rLS;
       c4rLO: // global
           Hp = Hp - 16;
           R2 = _s4kUj::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rLS: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUs_entry() //  [R1]
         { info_tbl: [(c4rM3,
                       label: sat_s4kUs_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rM3: // global
           _s4kUs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rM4; else goto c4rM5;
       c4rM5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rM7; else goto c4rM6;
       c4rM7: // global
           HpAlloc = 16;
           goto c4rM4;
       c4rM4: // global
           R1 = _s4kUs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rM6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUs::P64;
           _s4kUj::I64 = I64[_s4kUs::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUj::I64,
                            (-32768))) goto c4rMd; else goto c4rM2;
       c4rM2: // global
           if (%MO_S_Gt_W64(_s4kUj::I64, 32767)) goto c4rMd; else goto c4rMh;
       c4rMd: // global
           Hp = Hp - 16;
           R2 = _s4kUj::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rMh: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kUi_entry() //  [R1, R2]
         { info_tbl: [(c4rMl,
                       label: go_dn_s4kUi_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rMl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rMp; else goto c4rMo;
       c4rMp: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rMo: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4rMj; else goto c4rMk;
       c4rMj: // global
           _s4kUg::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kUp_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kUg::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kUn_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rMk: // global
           I64[Hp - 80] = sat_s4kUs_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rMr::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rMr::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kUt_entry() //  [R1]
         { info_tbl: [(c4rMs,
                       label: sat_s4kUt_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rMs: // global
           _s4kUt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rMt; else goto c4rMu;
       c4rMu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rMw; else goto c4rMv;
       c4rMw: // global
           HpAlloc = 24;
           goto c4rMt;
       c4rMt: // global
           R1 = _s4kUt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rMv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUt::P64;
           _s4kU9::I64 = I64[_s4kUt::P64 + 24];
           _s4kUg::I64 = _s4kU9::I64 - I64[_s4kUt::P64 + 16];
           _s4kUh::I64 = I64[_s4kUt::P64 + 32] - _s4kUg::I64;
           I64[Hp - 16] = go_dn_s4kUi_info;
           I64[Hp - 8] = _s4kUg::I64;
           I64[Hp] = _s4kUh::I64;
           R2 = _s4kU9::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kUi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUf_entry() //  [R1]
         { info_tbl: [(c4rMG,
                       label: sat_s4kUf_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rMG: // global
           _s4kUf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rMH; else goto c4rMI;
       c4rMI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rMK; else goto c4rMJ;
       c4rMK: // global
           HpAlloc = 16;
           goto c4rMH;
       c4rMH: // global
           R1 = _s4kUf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rMJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUf::P64;
           _s4kU8::I64 = I64[_s4kUf::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4rMQ; else goto c4rMF;
       c4rMF: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4rMQ; else goto c4rMU;
       c4rMQ: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rMU: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUx_entry() //  [R1]
         { info_tbl: [(c4rN8,
                       label: sat_s4kUx_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rN8: // global
           _s4kUx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rN9; else goto c4rNa;
       c4rNa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rNc; else goto c4rNb;
       c4rNc: // global
           HpAlloc = 16;
           goto c4rN9;
       c4rN9: // global
           R1 = _s4kUx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rNb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUx::P64;
           _s4kU8::I64 = I64[_s4kUx::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4rNi; else goto c4rN7;
       c4rN7: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4rNi; else goto c4rNm;
       c4rNi: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rNm: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUL_entry() //  [R1]
         { info_tbl: [(c4rNP,
                       label: sat_s4kUL_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rNP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rNQ; else goto c4rNR;
       c4rNQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rNR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kUE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUJ_entry() //  [R1]
         { info_tbl: [(c4rO1,
                       label: sat_s4kUJ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rO1: // global
           _s4kUJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rO2; else goto c4rO3;
       c4rO3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rO5; else goto c4rO4;
       c4rO5: // global
           HpAlloc = 16;
           goto c4rO2;
       c4rO2: // global
           R1 = _s4kUJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rO4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUJ::P64;
           _s4kUF::I64 = I64[_s4kUJ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUF::I64,
                            (-32768))) goto c4rOb; else goto c4rO0;
       c4rO0: // global
           if (%MO_S_Gt_W64(_s4kUF::I64, 32767)) goto c4rOb; else goto c4rOf;
       c4rOb: // global
           Hp = Hp - 16;
           R2 = _s4kUF::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rOf: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUF::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUO_entry() //  [R1]
         { info_tbl: [(c4rOq,
                       label: sat_s4kUO_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rOq: // global
           _s4kUO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rOr; else goto c4rOs;
       c4rOs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rOu; else goto c4rOt;
       c4rOu: // global
           HpAlloc = 16;
           goto c4rOr;
       c4rOr: // global
           R1 = _s4kUO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rOt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUO::P64;
           _s4kUF::I64 = I64[_s4kUO::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUF::I64,
                            (-32768))) goto c4rOA; else goto c4rOp;
       c4rOp: // global
           if (%MO_S_Gt_W64(_s4kUF::I64, 32767)) goto c4rOA; else goto c4rOE;
       c4rOA: // global
           Hp = Hp - 16;
           R2 = _s4kUF::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rOE: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUF::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kUE_entry() //  [R1, R2]
         { info_tbl: [(c4rOI,
                       label: go_up_s4kUE_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rOI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rOM; else goto c4rOL;
       c4rOM: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rOL: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4rOG; else goto c4rOH;
       c4rOG: // global
           _s4kUC::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kUL_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kUC::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kUJ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rOH: // global
           I64[Hp - 80] = sat_s4kUO_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rOO::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rOO::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kUP_entry() //  [R1]
         { info_tbl: [(c4rOP,
                       label: sat_s4kUP_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rOP: // global
           _s4kUP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rOQ; else goto c4rOR;
       c4rOR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rOT; else goto c4rOS;
       c4rOT: // global
           HpAlloc = 24;
           goto c4rOQ;
       c4rOQ: // global
           R1 = _s4kUP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rOS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUP::P64;
           _s4kU9::I64 = I64[_s4kUP::P64 + 24];
           _s4kUC::I64 = _s4kU9::I64 - I64[_s4kUP::P64 + 16];
           _s4kUD::I64 = I64[_s4kUP::P64 + 32] - _s4kUC::I64;
           I64[Hp - 16] = go_up_s4kUE_info;
           I64[Hp - 8] = _s4kUC::I64;
           I64[Hp] = _s4kUD::I64;
           R2 = _s4kU9::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kUE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUB_entry() //  [R1]
         { info_tbl: [(c4rP3,
                       label: sat_s4kUB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rP3: // global
           _s4kUB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rP4; else goto c4rP5;
       c4rP5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rP7; else goto c4rP6;
       c4rP7: // global
           HpAlloc = 16;
           goto c4rP4;
       c4rP4: // global
           R1 = _s4kUB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rP6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUB::P64;
           _s4kU8::I64 = I64[_s4kUB::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4rPd; else goto c4rP2;
       c4rP2: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4rPd; else goto c4rPh;
       c4rPd: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rPh: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kUT_entry() //  [R1]
         { info_tbl: [(c4rPv,
                       label: sat_s4kUT_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rPv: // global
           _s4kUT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rPw; else goto c4rPx;
       c4rPx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rPz; else goto c4rPy;
       c4rPz: // global
           HpAlloc = 16;
           goto c4rPw;
       c4rPw: // global
           R1 = _s4kUT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rPy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUT::P64;
           _s4kU8::I64 = I64[_s4kUT::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4rPF; else goto c4rPu;
       c4rPu: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4rPF; else goto c4rPJ;
       c4rPF: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rPJ: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4rPN,
                       label: GHC.Int.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rPN: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rPR; else goto c4rPQ;
       c4rPR: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rPQ: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4rPL; else goto c4rPM;
       c4rPL: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4rPU; else goto c4rPZ;
       c4rPU: // global
           I64[Hp - 80] = sat_s4kUt_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kUf_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rPZ: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4rQ6; else goto c4rPX;
       c4rPX: // global
           I64[Hp - 80] = sat_s4kUx_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rPV::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rPV::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rPM: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4rQ2; else goto c4rQ7;
       c4rQ2: // global
           I64[Hp - 80] = sat_s4kUP_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kUB_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rQ7: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4rQ6; else goto c4rQ5;
       c4rQ6: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rQ5: // global
           I64[Hp - 80] = sat_s4kUT_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rQ3::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rQ3::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.522206171 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4rRM,
                       label: GHC.Int.$fEnumInt16_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rRM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rRV; else goto c4rRW;
       c4rRV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rRW: // global
           I64[Sp - 24] = block_c4rRJ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rS5; else goto c4rRK;
       u4rS5: // global
           call _c4rRJ(R1) args: 0, res: 0, upd: 0;
       c4rRK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rRJ() //  [R1]
         { info_tbl: [(c4rRJ,
                       label: block_c4rRJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rRJ: // global
           I64[Sp] = block_c4rRP_info;
           _s4kUY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kUY::I64;
           if (R1 & 7 != 0) goto u4rS4; else goto c4rRQ;
       u4rS4: // global
           call _c4rRP(R1) args: 0, res: 0, upd: 0;
       c4rRQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rRP() //  [R1]
         { info_tbl: [(c4rRP,
                       label: block_c4rRP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rRP: // global
           I64[Sp] = block_c4rRU_info;
           _s4kV0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kV0::I64;
           if (R1 & 7 != 0) goto u4rS6; else goto c4rRZ;
       u4rS6: // global
           call _c4rRU(R1) args: 0, res: 0, upd: 0;
       c4rRZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rRU() //  [R1]
         { info_tbl: [(c4rRU,
                       label: block_c4rRU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rRU: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.532620791 UTC

[section ""data" . GHC.Int.$w$cenumFromTo_closure" {
     GHC.Int.$w$cenumFromTo_closure:
         const GHC.Int.$w$cenumFromTo_info;
         const 0;
 },
 sat_s4kVd_entry() //  [R1]
         { info_tbl: [(c4rSJ,
                       label: sat_s4kVd_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rSJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rSK; else goto c4rSL;
       c4rSK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rSL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kV7::I64 = I64[R1 + 32];
           if (_s4kV7::I64 == I64[R1 + 24]) goto c4rSI; else goto c4rSH;
       c4rSI: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4rSH: // global
           R2 = _s4kV7::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kV6_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kVa_entry() //  [R1]
         { info_tbl: [(c4rSX,
                       label: sat_s4kVa_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rSX: // global
           _s4kVa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rSY; else goto c4rSZ;
       c4rSZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rT1; else goto c4rT0;
       c4rT1: // global
           HpAlloc = 16;
           goto c4rSY;
       c4rSY: // global
           R1 = _s4kVa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rT0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kVa::P64;
           _s4kV7::I64 = I64[_s4kVa::P64 + 16];
           if (%MO_S_Lt_W64(_s4kV7::I64,
                            (-32768))) goto c4rT7; else goto c4rSW;
       c4rSW: // global
           if (%MO_S_Gt_W64(_s4kV7::I64, 32767)) goto c4rT7; else goto c4rTb;
       c4rT7: // global
           Hp = Hp - 16;
           R2 = _s4kV7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rTb: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kV7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kV6_entry() //  [R1, R2]
         { info_tbl: [(c4rTd,
                       label: go_s4kV6_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rTd: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rTh; else goto c4rTg;
       c4rTh: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rTg: // global
           _s4kV4::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kVd_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kV4::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kVa_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4rTl,
                       label: GHC.Int.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rTl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rTp; else goto c4rTo;
       c4rTp: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rTo: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4rTj; else goto c4rTk;
       c4rTj: // global
           I64[Hp - 8] = go_s4kV6_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kV6_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4rTk: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.544940805 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4rTS,
                       label: GHC.Int.$fEnumInt16_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rTS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rTW; else goto c4rTX;
       c4rTW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rTX: // global
           I64[Sp - 16] = block_c4rTP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rU5; else goto c4rTQ;
       u4rU5: // global
           call _c4rTP(R1) args: 0, res: 0, upd: 0;
       c4rTQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rTP() //  [R1]
         { info_tbl: [(c4rTP,
                       label: block_c4rTP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rTP: // global
           I64[Sp] = block_c4rTV_info;
           _s4kVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kVh::I64;
           if (R1 & 7 != 0) goto u4rU4; else goto c4rTZ;
       u4rU4: // global
           call _c4rTV(R1) args: 0, res: 0, upd: 0;
       c4rTZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rTV() //  [R1]
         { info_tbl: [(c4rTV,
                       label: block_c4rTV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rTV: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.553695557 UTC

[section ""data" . GHC.Int.$wgo_closure" {
     GHC.Int.$wgo_closure:
         const GHC.Int.$wgo_info;
         const 0;
 },
 sat_s4kVt_entry() //  [R1]
         { info_tbl: [(c4rUv,
                       label: sat_s4kVt_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rUv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rUw; else goto c4rUH;
       c4rUw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rUH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kVo::I64 = I64[R1 + 16];
           if (_s4kVo::I64 != 32767) goto c4rUt; else goto c4rUu;
       c4rUt: // global
           I64[Sp - 24] = block_c4rUB_info;
           R2 = _s4kVo::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c4rUu: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4rUB() //  [R1, R2]
         { info_tbl: [(c4rUB,
                       label: block_c4rUB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rUB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rUG; else goto c4rUF;
       c4rUG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4rUF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kVn_entry() //  [R1]
         { info_tbl: [(c4rUR,
                       label: sat_s4kVn_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rUR: // global
           _s4kVn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rUS; else goto c4rUT;
       c4rUT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rUV; else goto c4rUU;
       c4rUV: // global
           HpAlloc = 16;
           goto c4rUS;
       c4rUS: // global
           R1 = _s4kVn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rUU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kVn::P64;
           _s4kVk::I64 = I64[_s4kVn::P64 + 16];
           if (%MO_S_Lt_W64(_s4kVk::I64,
                            (-32768))) goto c4rV1; else goto c4rUQ;
       c4rUQ: // global
           if (%MO_S_Gt_W64(_s4kVk::I64, 32767)) goto c4rV1; else goto c4rV5;
       c4rV1: // global
           Hp = Hp - 16;
           R2 = _s4kVk::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rV5: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kVk::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo_entry() //  [R2]
         { info_tbl: [(c4rV6,
                       label: GHC.Int.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rV6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4rVa; else goto c4rV9;
       c4rVa: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rV9: // global
           I64[Hp - 40] = sat_s4kVt_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kVn_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.565737267 UTC

[section ""data" . GHC.Int.$fEnumInt16_go_closure" {
     GHC.Int.$fEnumInt16_go_closure:
         const GHC.Int.$fEnumInt16_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_go_entry() //  [R2]
         { info_tbl: [(c4rVB,
                       label: GHC.Int.$fEnumInt16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rVB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rVC; else goto c4rVD;
       c4rVC: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rVD: // global
           I64[Sp - 8] = block_c4rVy_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rVy() //  [R1, R2]
         { info_tbl: [(c4rVy,
                       label: block_c4rVy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rVy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rVG; else goto c4rVF;
       c4rVG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rVF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.571893316 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFrom_closure" {
     GHC.Int.$fEnumInt16_$cenumFrom_closure:
         const GHC.Int.$fEnumInt16_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4rVX,
                       label: GHC.Int.$fEnumInt16_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rVX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rVY; else goto c4rVZ;
       c4rVY: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rVZ: // global
           I64[Sp - 8] = block_c4rVU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rW8; else goto c4rVV;
       u4rW8: // global
           call _c4rVU(R1) args: 0, res: 0, upd: 0;
       c4rVV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rVU() //  [R1]
         { info_tbl: [(c4rVU,
                       label: block_c4rVU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rVU: // global
           _s4kVA::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kVA::I64, 32767)) goto c4rW6; else goto c4rW7;
       c4rW6: // global
           R2 = _s4kVA::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_go_entry(R2) args: 8, res: 0, upd: 8;
       c4rW7: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.577928722 UTC

[section ""data" . GHC.Int.$fEnumInt16_closure" {
     GHC.Int.$fEnumInt16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt16_$csucc_closure+1;
         const GHC.Int.$fEnumInt16_$cpred_closure+1;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt16_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4rWn,
                       label: GHC.Int.$fEnumInt16_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rWn: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt16_closure+1;
           R2 = GHC.Int.$fEnumInt16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.582903048 UTC

[section ""cstring" . GHC.Int.$tcInt4_bytes" {
     GHC.Int.$tcInt4_bytes:
         I8[] [73,110,116,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.584937791 UTC

[section ""data" . GHC.Int.$fEnumInt3_closure" {
     GHC.Int.$fEnumInt3_closure:
         const GHC.Int.$fEnumInt3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt3_entry() //  [R1]
         { info_tbl: [(c4rWE,
                       label: GHC.Int.$fEnumInt3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rWE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rWF; else goto c4rWG;
       c4rWF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rWG: // global
           (_c4rWz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rWz::I64 == 0) goto c4rWB; else goto c4rWA;
       c4rWB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rWA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rWz::I64;
           I64[Sp - 24] = block_c4rWC_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4rWC() //  [R1]
         { info_tbl: [(c4rWC,
                       label: block_c4rWC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rWC: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.591073759 UTC

[section ""data" . GHC.Int.$fEnumInt4_closure" {
     GHC.Int.$fEnumInt4_closure:
         const GHC.Int.$fEnumInt4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt4_entry() //  [R1]
         { info_tbl: [(c4rX2,
                       label: GHC.Int.$fEnumInt4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rX2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rX3; else goto c4rX4;
       c4rX3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rX4: // global
           (_c4rWX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rWX::I64 == 0) goto c4rWZ; else goto c4rWY;
       c4rWZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rWY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rWX::I64;
           I64[Sp - 24] = block_c4rX0_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4rX0() //  [R1]
         { info_tbl: [(c4rX0,
                       label: block_c4rX0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rX0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.597169163 UTC

[section ""data" . GHC.Int.neInt32_closure" {
     GHC.Int.neInt32_closure:
         const GHC.Int.neInt32_info;
 },
 GHC.Int.neInt32_entry() //  [R2, R3]
         { info_tbl: [(c4rXp,
                       label: GHC.Int.neInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rXp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rXt; else goto c4rXu;
       c4rXt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rXu: // global
           I64[Sp - 16] = block_c4rXm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rXD; else goto c4rXn;
       u4rXD: // global
           call _c4rXm(R1) args: 0, res: 0, upd: 0;
       c4rXn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rXm() //  [R1]
         { info_tbl: [(c4rXm,
                       label: block_c4rXm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rXm: // global
           I64[Sp] = block_c4rXs_info;
           _s4kVH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kVH::I64;
           if (R1 & 7 != 0) goto u4rXC; else goto c4rXw;
       u4rXC: // global
           call _c4rXs(R1) args: 0, res: 0, upd: 0;
       c4rXw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rXs() //  [R1]
         { info_tbl: [(c4rXs,
                       label: block_c4rXs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rXs: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.607106788 UTC

[section ""data" . lvl4_r4kPv_closure" {
     lvl4_r4kPv_closure:
         const lvl4_r4kPv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r4kPv_entry() //  [R1]
         { info_tbl: [(c4rY1,
                       label: lvl4_r4kPv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rY1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rY2; else goto c4rY3;
       c4rY2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rY3: // global
           (_c4rXY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rXY::I64 == 0) goto c4rY0; else goto c4rXZ;
       c4rY0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rXZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rXY::I64;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.613296488 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cminBound_closure" {
     GHC.Int.$fBoundedInt32_$cminBound_closure:
         const GHC.Int.I32#_con_info;
         const (-2147483648);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.616677704 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cpred_closure" {
     GHC.Int.$fEnumInt32_$cpred_closure:
         const GHC.Int.$fEnumInt32_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cpred_entry() //  [R2]
         { info_tbl: [(c4rYj,
                       label: GHC.Int.$fEnumInt32_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rYj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rYk; else goto c4rYl;
       c4rYk: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rYl: // global
           I64[Sp - 8] = block_c4rYg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rYD; else goto c4rYh;
       u4rYD: // global
           call _c4rYg(R1) args: 0, res: 0, upd: 0;
       c4rYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rYg() //  [R1]
         { info_tbl: [(c4rYg,
                       label: block_c4rYg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rYg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rYq; else goto c4rYp;
       c4rYq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rYp: // global
           _s4kVO::I64 = I64[R1 + 7];
           if (_s4kVO::I64 != (-2147483648)) goto c4rYB; else goto c4rYC;
       c4rYB: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4kVO::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rYC: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.626596978 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt32_$cmaxBound_closure:
         const GHC.Int.I32#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.63039238 UTC

[section ""data" . GHC.Int.$fBoundedInt32_closure" {
     GHC.Int.$fBoundedInt32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt32_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.633967066 UTC

[section ""data" . GHC.Int.$fEnumInt32_$csucc_closure" {
     GHC.Int.$fEnumInt32_$csucc_closure:
         const GHC.Int.$fEnumInt32_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$csucc_entry() //  [R2]
         { info_tbl: [(c4rZ0,
                       label: GHC.Int.$fEnumInt32_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rZ0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rZ1; else goto c4rZ2;
       c4rZ1: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rZ2: // global
           I64[Sp - 8] = block_c4rYX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rZk; else goto c4rYY;
       u4rZk: // global
           call _c4rYX(R1) args: 0, res: 0, upd: 0;
       c4rYY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rYX() //  [R1]
         { info_tbl: [(c4rYX,
                       label: block_c4rYX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rYX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rZ7; else goto c4rZ6;
       c4rZ7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rZ6: // global
           _s4kVU::I64 = I64[R1 + 7];
           if (_s4kVU::I64 != 2147483647) goto c4rZi; else goto c4rZj;
       c4rZi: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4kVU::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rZj: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.644616426 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowsPrec_closure" {
     GHC.Int.$fShowInt32_$cshowsPrec_closure:
         const GHC.Int.$fShowInt32_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt32_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4rZF,
                       label: GHC.Int.$fShowInt32_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rZF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rZQ; else goto c4rZR;
       c4rZQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rZR: // global
           I64[Sp - 24] = block_c4rZC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rZY; else goto c4rZD;
       u4rZY: // global
           call _c4rZC(R1) args: 0, res: 0, upd: 0;
       c4rZD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rZC() //  [R1]
         { info_tbl: [(c4rZC,
                       label: block_c4rZC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rZC: // global
           I64[Sp] = block_c4rZI_info;
           _s4kW1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kW1::I64;
           if (R1 & 7 != 0) goto u4rZX; else goto c4rZJ;
       u4rZX: // global
           call _c4rZI(R1) args: 0, res: 0, upd: 0;
       c4rZJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4rZI() //  [R1]
         { info_tbl: [(c4rZI,
                       label: block_c4rZI_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rZI: // global
           _s4kVZ::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4rZN_info;
           R4 = _s4kVZ::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4rZN() //  [R1, R2]
         { info_tbl: [(c4rZN,
                       label: block_c4rZN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4rZN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rZW; else goto c4rZV;
       c4rZW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rZV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.655258047 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshow_closure" {
     GHC.Int.$fShowInt32_$cshow_closure:
         const GHC.Int.$fShowInt32_$cshow_info;
 },
 GHC.Int.$fShowInt32_$cshow_entry() //  [R2]
         { info_tbl: [(c4s0n,
                       label: GHC.Int.$fShowInt32_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s0n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4s0t; else goto c4s0u;
       c4s0t: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s0u: // global
           I64[Sp - 8] = block_c4s0k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4s0z; else goto c4s0l;
       u4s0z: // global
           call _c4s0k(R1) args: 0, res: 0, upd: 0;
       c4s0l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4s0k() //  [R1]
         { info_tbl: [(c4s0k,
                       label: block_c4s0k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s0k: // global
           I64[Sp] = block_c4s0q_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4s0q() //  [R1, R2]
         { info_tbl: [(c4s0q,
                       label: block_c4s0q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s0q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4s0y; else goto c4s0x;
       c4s0y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4s0x: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.663125656 UTC

[section ""data" . GHC.Int.$fShowInt2_closure" {
     GHC.Int.$fShowInt2_closure:
         const GHC.Int.$fShowInt2_info;
 },
 GHC.Int.$fShowInt2_entry() //  [R2, R3]
         { info_tbl: [(c4s0U,
                       label: GHC.Int.$fShowInt2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s0U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4s10; else goto c4s11;
       c4s10: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4s11: // global
           I64[Sp - 16] = block_c4s0R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4s16; else goto c4s0S;
       u4s16: // global
           call _c4s0R(R1) args: 0, res: 0, upd: 0;
       c4s0S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4s0R() //  [R1]
         { info_tbl: [(c4s0R,
                       label: block_c4s0R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s0R: // global
           _s4kWe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4s0X_info;
           R4 = _s4kWe::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4s0X() //  [R1, R2]
         { info_tbl: [(c4s0X,
                       label: block_c4s0X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s0X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4s15; else goto c4s14;
       c4s15: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4s14: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.671044836 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowList_closure" {
     GHC.Int.$fShowInt32_$cshowList_closure:
         const GHC.Int.$fShowInt32_$cshowList_info;
 },
 GHC.Int.$fShowInt32_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4s1o,
                       label: GHC.Int.$fShowInt32_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s1o: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.675027242 UTC

[section ""data" . GHC.Int.$fShowInt32_closure" {
     GHC.Int.$fShowInt32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt32_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt32_$cshow_closure+1;
         const GHC.Int.$fShowInt32_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.677882455 UTC

[section ""data" . GHC.Int.$wlvl1_closure" {
     GHC.Int.$wlvl1_closure:
         const GHC.Int.$wlvl1_info;
         const 0;
 },
 GHC.Int.$wlvl1_entry() //  [R2]
         { info_tbl: [(c4s1A,
                       label: GHC.Int.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s1A: // global
           R6 = GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r4kPv_closure;
           R2 = GHC.Int.$fShowInt32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.682126282 UTC

[section ""data" . GHC.Int.$w$ctoEnum1_closure" {
     GHC.Int.$w$ctoEnum1_closure:
         const GHC.Int.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum1_entry() //  [R2]
         { info_tbl: [(c4s1Q,
                       label: GHC.Int.$w$ctoEnum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s1Q: // global
           _s4kWn::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-2147483648))) goto c4s1Y; else goto c4s1P;
       c4s1P: // global
           if (%MO_S_Gt_W64(_s4kWn::I64,
                            2147483647)) goto c4s1Y; else goto c4s1Z;
       c4s1Y: // global
           R2 = _s4kWn::I64;
           call GHC.Int.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c4s1Z: // global
           R1 = _s4kWn::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.686501072 UTC

[section ""data" . GHC.Int.$fEnumInt32_$ctoEnum_closure" {
     GHC.Int.$fEnumInt32_$ctoEnum_closure:
         const GHC.Int.$fEnumInt32_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4s2c,
                       label: GHC.Int.$fEnumInt32_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s2c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4s2k; else goto c4s2l;
       c4s2k: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s2l: // global
           I64[Sp - 8] = block_c4s29_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4s2q; else goto c4s2a;
       u4s2q: // global
           call _c4s29(R1) args: 0, res: 0, upd: 0;
       c4s2a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4s29() //  [R1]
         { info_tbl: [(c4s29,
                       label: block_c4s29_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s29: // global
           I64[Sp] = block_c4s2f_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4s2f() //  [R1]
         { info_tbl: [(c4s2f,
                       label: block_c4s2f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s2f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s2p; else goto c4s2o;
       c4s2p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4s2o: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.696524965 UTC

[section ""data" . GHC.Int.$w$cenumFromTo1_closure" {
     GHC.Int.$w$cenumFromTo1_closure:
         const GHC.Int.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s4kWG_entry() //  [R1]
         { info_tbl: [(c4s2Z,
                       label: sat_s4kWG_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s2Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4s30; else goto c4s31;
       c4s30: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s31: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kWA::I64 = I64[R1 + 32];
           if (_s4kWA::I64 == I64[R1 + 24]) goto c4s2Y; else goto c4s2X;
       c4s2Y: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4s2X: // global
           R2 = _s4kWA::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kWz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kWD_entry() //  [R1]
         { info_tbl: [(c4s3d,
                       label: sat_s4kWD_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s3d: // global
           _s4kWD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s3e; else goto c4s3f;
       c4s3f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s3h; else goto c4s3g;
       c4s3h: // global
           HpAlloc = 16;
           goto c4s3e;
       c4s3e: // global
           R1 = _s4kWD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s3g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kWD::P64;
           _s4kWA::I64 = I64[_s4kWD::P64 + 16];
           if (%MO_S_Lt_W64(_s4kWA::I64,
                            (-2147483648))) goto c4s3n; else goto c4s3c;
       c4s3c: // global
           if (%MO_S_Gt_W64(_s4kWA::I64,
                            2147483647)) goto c4s3n; else goto c4s3r;
       c4s3n: // global
           Hp = Hp - 16;
           R2 = _s4kWA::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s3r: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kWA::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4kWz_entry() //  [R1, R2]
         { info_tbl: [(c4s3t,
                       label: go_s4kWz_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s3t: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4s3x; else goto c4s3w;
       c4s3x: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s3w: // global
           _s4kWx::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kWG_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kWx::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kWD_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo1_entry() //  [R2, R3]
         { info_tbl: [(c4s3B,
                       label: GHC.Int.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s3B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s3F; else goto c4s3E;
       c4s3F: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4s3E: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4s3z; else goto c4s3A;
       c4s3z: // global
           I64[Hp - 8] = go_s4kWz_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kWz_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4s3A: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.708210583 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4s48,
                       label: GHC.Int.$fEnumInt32_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s48: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4s4c; else goto c4s4d;
       c4s4c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4s4d: // global
           I64[Sp - 16] = block_c4s45_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4s4l; else goto c4s46;
       u4s4l: // global
           call _c4s45(R1) args: 0, res: 0, upd: 0;
       c4s46: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4s45() //  [R1]
         { info_tbl: [(c4s45,
                       label: block_c4s45_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s45: // global
           I64[Sp] = block_c4s4b_info;
           _s4kWK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kWK::I64;
           if (R1 & 7 != 0) goto u4s4k; else goto c4s4f;
       u4s4k: // global
           call _c4s4b(R1) args: 0, res: 0, upd: 0;
       c4s4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4s4b() //  [R1]
         { info_tbl: [(c4s4b,
                       label: block_c4s4b_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s4b: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.717972881 UTC

[section ""data" . GHC.Int.$wgo1_closure" {
     GHC.Int.$wgo1_closure:
         const GHC.Int.$wgo1_info;
         const 0;
 },
 sat_s4kWW_entry() //  [R1]
         { info_tbl: [(c4s4L,
                       label: sat_s4kWW_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s4L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4s4M; else goto c4s4X;
       c4s4M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s4X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kWR::I64 = I64[R1 + 16];
           if (_s4kWR::I64 != 2147483647) goto c4s4J; else goto c4s4K;
       c4s4J: // global
           I64[Sp - 24] = block_c4s4R_info;
           R2 = _s4kWR::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c4s4K: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4s4R() //  [R1, R2]
         { info_tbl: [(c4s4R,
                       label: block_c4s4R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s4R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4s4W; else goto c4s4V;
       c4s4W: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4s4V: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kWQ_entry() //  [R1]
         { info_tbl: [(c4s57,
                       label: sat_s4kWQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s57: // global
           _s4kWQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s58; else goto c4s59;
       c4s59: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s5b; else goto c4s5a;
       c4s5b: // global
           HpAlloc = 16;
           goto c4s58;
       c4s58: // global
           R1 = _s4kWQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s5a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kWQ::P64;
           _s4kWN::I64 = I64[_s4kWQ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kWN::I64,
                            (-2147483648))) goto c4s5h; else goto c4s56;
       c4s56: // global
           if (%MO_S_Gt_W64(_s4kWN::I64,
                            2147483647)) goto c4s5h; else goto c4s5l;
       c4s5h: // global
           Hp = Hp - 16;
           R2 = _s4kWN::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s5l: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kWN::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo1_entry() //  [R2]
         { info_tbl: [(c4s5m,
                       label: GHC.Int.$wgo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s5m: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4s5q; else goto c4s5p;
       c4s5q: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s5p: // global
           I64[Hp - 40] = sat_s4kWW_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kWQ_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.729718931 UTC

[section ""data" . GHC.Int.$fEnumInt32_go_closure" {
     GHC.Int.$fEnumInt32_go_closure:
         const GHC.Int.$fEnumInt32_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_go_entry() //  [R2]
         { info_tbl: [(c4s5R,
                       label: GHC.Int.$fEnumInt32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s5R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4s5S; else goto c4s5T;
       c4s5S: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s5T: // global
           I64[Sp - 8] = block_c4s5O_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4s5O() //  [R1, R2]
         { info_tbl: [(c4s5O,
                       label: block_c4s5O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s5O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4s5W; else goto c4s5V;
       c4s5W: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4s5V: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.73839348 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFrom_closure" {
     GHC.Int.$fEnumInt32_$cenumFrom_closure:
         const GHC.Int.$fEnumInt32_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4s6d,
                       label: GHC.Int.$fEnumInt32_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s6d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4s6e; else goto c4s6f;
       c4s6e: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s6f: // global
           I64[Sp - 8] = block_c4s6a_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4s6o; else goto c4s6b;
       u4s6o: // global
           call _c4s6a(R1) args: 0, res: 0, upd: 0;
       c4s6b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4s6a() //  [R1]
         { info_tbl: [(c4s6a,
                       label: block_c4s6a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s6a: // global
           _s4kX3::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kX3::I64,
                            2147483647)) goto c4s6m; else goto c4s6n;
       c4s6m: // global
           R2 = _s4kX3::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_go_entry(R2) args: 8, res: 0, upd: 8;
       c4s6n: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.74817614 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo1_closure" {
     GHC.Int.$w$cenumFromThenTo1_closure:
         const GHC.Int.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s4kXm_entry() //  [R1]
         { info_tbl: [(c4s77,
                       label: sat_s4kXm_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4s78; else goto c4s79;
       c4s78: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s79: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kXf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXk_entry() //  [R1]
         { info_tbl: [(c4s7j,
                       label: sat_s4kXk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s7j: // global
           _s4kXk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s7k; else goto c4s7l;
       c4s7l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s7n; else goto c4s7m;
       c4s7n: // global
           HpAlloc = 16;
           goto c4s7k;
       c4s7k: // global
           R1 = _s4kXk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s7m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXk::P64;
           _s4kXg::I64 = I64[_s4kXk::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXg::I64,
                            (-2147483648))) goto c4s7t; else goto c4s7i;
       c4s7i: // global
           if (%MO_S_Gt_W64(_s4kXg::I64,
                            2147483647)) goto c4s7t; else goto c4s7x;
       c4s7t: // global
           Hp = Hp - 16;
           R2 = _s4kXg::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s7x: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXg::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXp_entry() //  [R1]
         { info_tbl: [(c4s7I,
                       label: sat_s4kXp_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s7I: // global
           _s4kXp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s7J; else goto c4s7K;
       c4s7K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s7M; else goto c4s7L;
       c4s7M: // global
           HpAlloc = 16;
           goto c4s7J;
       c4s7J: // global
           R1 = _s4kXp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s7L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXp::P64;
           _s4kXg::I64 = I64[_s4kXp::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXg::I64,
                            (-2147483648))) goto c4s7S; else goto c4s7H;
       c4s7H: // global
           if (%MO_S_Gt_W64(_s4kXg::I64,
                            2147483647)) goto c4s7S; else goto c4s7W;
       c4s7S: // global
           Hp = Hp - 16;
           R2 = _s4kXg::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s7W: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXg::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4kXf_entry() //  [R1, R2]
         { info_tbl: [(c4s80,
                       label: go_dn_s4kXf_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s80: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4s84; else goto c4s83;
       c4s84: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s83: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4s7Y; else goto c4s7Z;
       c4s7Y: // global
           _s4kXd::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kXm_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kXd::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kXk_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4s7Z: // global
           I64[Hp - 80] = sat_s4kXp_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4s86::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4s86::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kXq_entry() //  [R1]
         { info_tbl: [(c4s87,
                       label: sat_s4kXq_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s87: // global
           _s4kXq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s88; else goto c4s89;
       c4s89: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4s8b; else goto c4s8a;
       c4s8b: // global
           HpAlloc = 24;
           goto c4s88;
       c4s88: // global
           R1 = _s4kXq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s8a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXq::P64;
           _s4kX6::I64 = I64[_s4kXq::P64 + 24];
           _s4kXd::I64 = _s4kX6::I64 - I64[_s4kXq::P64 + 16];
           _s4kXe::I64 = I64[_s4kXq::P64 + 32] - _s4kXd::I64;
           I64[Hp - 16] = go_dn_s4kXf_info;
           I64[Hp - 8] = _s4kXd::I64;
           I64[Hp] = _s4kXe::I64;
           R2 = _s4kX6::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kXf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXc_entry() //  [R1]
         { info_tbl: [(c4s8l,
                       label: sat_s4kXc_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s8l: // global
           _s4kXc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s8m; else goto c4s8n;
       c4s8n: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s8p; else goto c4s8o;
       c4s8p: // global
           HpAlloc = 16;
           goto c4s8m;
       c4s8m: // global
           R1 = _s4kXc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s8o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXc::P64;
           _s4kX5::I64 = I64[_s4kXc::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4s8v; else goto c4s8k;
       c4s8k: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4s8v; else goto c4s8z;
       c4s8v: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s8z: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXu_entry() //  [R1]
         { info_tbl: [(c4s8N,
                       label: sat_s4kXu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s8N: // global
           _s4kXu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s8O; else goto c4s8P;
       c4s8P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s8R; else goto c4s8Q;
       c4s8R: // global
           HpAlloc = 16;
           goto c4s8O;
       c4s8O: // global
           R1 = _s4kXu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s8Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXu::P64;
           _s4kX5::I64 = I64[_s4kXu::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4s8X; else goto c4s8M;
       c4s8M: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4s8X; else goto c4s91;
       c4s8X: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s91: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXI_entry() //  [R1]
         { info_tbl: [(c4s9u,
                       label: sat_s4kXI_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s9u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4s9v; else goto c4s9w;
       c4s9v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s9w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kXB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXG_entry() //  [R1]
         { info_tbl: [(c4s9G,
                       label: sat_s4kXG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4s9G: // global
           _s4kXG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s9H; else goto c4s9I;
       c4s9I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s9K; else goto c4s9J;
       c4s9K: // global
           HpAlloc = 16;
           goto c4s9H;
       c4s9H: // global
           R1 = _s4kXG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s9J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXG::P64;
           _s4kXC::I64 = I64[_s4kXG::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXC::I64,
                            (-2147483648))) goto c4s9Q; else goto c4s9F;
       c4s9F: // global
           if (%MO_S_Gt_W64(_s4kXC::I64,
                            2147483647)) goto c4s9Q; else goto c4s9U;
       c4s9Q: // global
           Hp = Hp - 16;
           R2 = _s4kXC::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s9U: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXL_entry() //  [R1]
         { info_tbl: [(c4sa5,
                       label: sat_s4kXL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sa5: // global
           _s4kXL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4sa6; else goto c4sa7;
       c4sa7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sa9; else goto c4sa8;
       c4sa9: // global
           HpAlloc = 16;
           goto c4sa6;
       c4sa6: // global
           R1 = _s4kXL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4sa8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXL::P64;
           _s4kXC::I64 = I64[_s4kXL::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXC::I64,
                            (-2147483648))) goto c4saf; else goto c4sa4;
       c4sa4: // global
           if (%MO_S_Gt_W64(_s4kXC::I64,
                            2147483647)) goto c4saf; else goto c4saj;
       c4saf: // global
           Hp = Hp - 16;
           R2 = _s4kXC::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4saj: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4kXB_entry() //  [R1, R2]
         { info_tbl: [(c4san,
                       label: go_up_s4kXB_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4san: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4sar; else goto c4saq;
       c4sar: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4saq: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4sal; else goto c4sam;
       c4sal: // global
           _s4kXz::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kXI_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kXz::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kXG_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sam: // global
           I64[Hp - 80] = sat_s4kXL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4sat::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4sat::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4kXM_entry() //  [R1]
         { info_tbl: [(c4sau,
                       label: sat_s4kXM_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sau: // global
           _s4kXM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4sav; else goto c4saw;
       c4saw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4say; else goto c4sax;
       c4say: // global
           HpAlloc = 24;
           goto c4sav;
       c4sav: // global
           R1 = _s4kXM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4sax: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXM::P64;
           _s4kX6::I64 = I64[_s4kXM::P64 + 24];
           _s4kXz::I64 = _s4kX6::I64 - I64[_s4kXM::P64 + 16];
           _s4kXA::I64 = I64[_s4kXM::P64 + 32] - _s4kXz::I64;
           I64[Hp - 16] = go_up_s4kXB_info;
           I64[Hp - 8] = _s4kXz::I64;
           I64[Hp] = _s4kXA::I64;
           R2 = _s4kX6::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kXB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXy_entry() //  [R1]
         { info_tbl: [(c4saI,
                       label: sat_s4kXy_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4saI: // global
           _s4kXy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4saJ; else goto c4saK;
       c4saK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4saM; else goto c4saL;
       c4saM: // global
           HpAlloc = 16;
           goto c4saJ;
       c4saJ: // global
           R1 = _s4kXy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4saL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXy::P64;
           _s4kX5::I64 = I64[_s4kXy::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4saS; else goto c4saH;
       c4saH: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4saS; else goto c4saW;
       c4saS: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4saW: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4kXQ_entry() //  [R1]
         { info_tbl: [(c4sba,
                       label: sat_s4kXQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sba: // global
           _s4kXQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4sbb; else goto c4sbc;
       c4sbc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sbe; else goto c4sbd;
       c4sbe: // global
           HpAlloc = 16;
           goto c4sbb;
       c4sbb: // global
           R1 = _s4kXQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4sbd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXQ::P64;
           _s4kX5::I64 = I64[_s4kXQ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4sbk; else goto c4sb9;
       c4sb9: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4sbk; else goto c4sbo;
       c4sbk: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4sbo: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4sbs,
                       label: GHC.Int.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sbs: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4sbw; else goto c4sbv;
       c4sbw: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sbv: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4sbq; else goto c4sbr;
       c4sbq: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4sbz; else goto c4sbE;
       c4sbz: // global
           I64[Hp - 80] = sat_s4kXq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kXc_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sbE: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4sbL; else goto c4sbC;
       c4sbC: // global
           I64[Hp - 80] = sat_s4kXu_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4sbA::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4sbA::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sbr: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4sbH; else goto c4sbM;
       c4sbH: // global
           I64[Hp - 80] = sat_s4kXM_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kXy_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sbM: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4sbL; else goto c4sbK;
       c4sbL: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sbK: // global
           I64[Hp - 80] = sat_s4kXQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4sbI::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4sbI::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.794772281 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4sdr,
                       label: GHC.Int.$fEnumInt32_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sdr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sdA; else goto c4sdB;
       c4sdA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sdB: // global
           I64[Sp - 24] = block_c4sdo_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4sdK; else goto c4sdp;
       u4sdK: // global
           call _c4sdo(R1) args: 0, res: 0, upd: 0;
       c4sdp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sdo() //  [R1]
         { info_tbl: [(c4sdo,
                       label: block_c4sdo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sdo: // global
           I64[Sp] = block_c4sdu_info;
           _s4kXV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kXV::I64;
           if (R1 & 7 != 0) goto u4sdJ; else goto c4sdv;
       u4sdJ: // global
           call _c4sdu(R1) args: 0, res: 0, upd: 0;
       c4sdv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sdu() //  [R1]
         { info_tbl: [(c4sdu,
                       label: block_c4sdu_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sdu: // global
           I64[Sp] = block_c4sdz_info;
           _s4kXX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kXX::I64;
           if (R1 & 7 != 0) goto u4sdL; else goto c4sdE;
       u4sdL: // global
           call _c4sdz(R1) args: 0, res: 0, upd: 0;
       c4sdE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sdz() //  [R1]
         { info_tbl: [(c4sdz,
                       label: block_c4sdz_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sdz: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.80481077 UTC

[section ""data" . GHC.Int.$fEnumInt32_closure" {
     GHC.Int.$fEnumInt32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt32_$csucc_closure+1;
         const GHC.Int.$fEnumInt32_$cpred_closure+1;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt32_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4se7,
                       label: GHC.Int.$fEnumInt32_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4se7: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt32_closure+1;
           R2 = GHC.Int.$fEnumInt32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.809316192 UTC

[section ""cstring" . GHC.Int.$tcInt6_bytes" {
     GHC.Int.$tcInt6_bytes:
         I8[] [73,110,116,54,52]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.811414562 UTC

[section ""data" . GHC.Int.$fEnumInt5_closure" {
     GHC.Int.$fEnumInt5_closure:
         const GHC.Int.$fEnumInt5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt5_entry() //  [R1]
         { info_tbl: [(c4seo,
                       label: GHC.Int.$fEnumInt5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4seo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sep; else goto c4seq;
       c4sep: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4seq: // global
           (_c4sej::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4sej::I64 == 0) goto c4sel; else goto c4sek;
       c4sel: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4sek: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4sej::I64;
           I64[Sp - 24] = block_c4sem_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4sem() //  [R1]
         { info_tbl: [(c4sem,
                       label: block_c4sem_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sem: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.818220447 UTC

[section ""data" . GHC.Int.$fEnumInt6_closure" {
     GHC.Int.$fEnumInt6_closure:
         const GHC.Int.$fEnumInt6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt6_entry() //  [R1]
         { info_tbl: [(c4seM,
                       label: GHC.Int.$fEnumInt6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4seM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4seN; else goto c4seO;
       c4seN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4seO: // global
           (_c4seH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4seH::I64 == 0) goto c4seJ; else goto c4seI;
       c4seJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4seI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4seH::I64;
           I64[Sp - 24] = block_c4seK_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4seK() //  [R1]
         { info_tbl: [(c4seK,
                       label: block_c4seK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4seK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.824841917 UTC

[section ""data" . GHC.Int.neInt64_closure" {
     GHC.Int.neInt64_closure:
         const GHC.Int.neInt64_info;
 },
 GHC.Int.neInt64_entry() //  [R2, R3]
         { info_tbl: [(c4sf9,
                       label: GHC.Int.neInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sf9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sfd; else goto c4sfe;
       c4sfd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sfe: // global
           I64[Sp - 16] = block_c4sf6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sfn; else goto c4sf7;
       u4sfn: // global
           call _c4sf6(R1) args: 0, res: 0, upd: 0;
       c4sf7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sf6() //  [R1]
         { info_tbl: [(c4sf6,
                       label: block_c4sf6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sf6: // global
           I64[Sp] = block_c4sfc_info;
           _s4kY5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kY5::I64;
           if (R1 & 7 != 0) goto u4sfm; else goto c4sfg;
       u4sfm: // global
           call _c4sfc(R1) args: 0, res: 0, upd: 0;
       c4sfg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sfc() //  [R1]
         { info_tbl: [(c4sfc,
                       label: block_c4sfc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sfc: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.832196029 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cminBound_closure" {
     GHC.Int.$fBoundedInt64_$cminBound_closure:
         const GHC.Int.I64#_con_info;
         const (-9223372036854775808);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.835032943 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cpred_closure" {
     GHC.Int.$fEnumInt64_$cpred_closure:
         const GHC.Int.$fEnumInt64_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cpred_entry() //  [R2]
         { info_tbl: [(c4sfN,
                       label: GHC.Int.$fEnumInt64_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sfN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sfO; else goto c4sfP;
       c4sfO: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sfP: // global
           I64[Sp - 8] = block_c4sfK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sg4; else goto c4sfL;
       u4sg4: // global
           call _c4sfK(R1) args: 0, res: 0, upd: 0;
       c4sfL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sfK() //  [R1]
         { info_tbl: [(c4sfK,
                       label: block_c4sfK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sfK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sfU; else goto c4sfT;
       c4sfU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sfT: // global
           _s4kYc::I64 = I64[R1 + 7];
           if (_s4kYc::I64 != (-9223372036854775808)) goto c4sg2; else goto c4sg3;
       c4sg2: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kYc::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sg3: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.841726173 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt64_$cmaxBound_closure:
         const GHC.Int.I64#_con_info;
         const 9223372036854775807;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.843467966 UTC

[section ""data" . GHC.Int.$fBoundedInt64_closure" {
     GHC.Int.$fBoundedInt64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt64_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.845835753 UTC

[section ""data" . GHC.Int.$fEnumInt64_$csucc_closure" {
     GHC.Int.$fEnumInt64_$csucc_closure:
         const GHC.Int.$fEnumInt64_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$csucc_entry() //  [R2]
         { info_tbl: [(c4sgr,
                       label: GHC.Int.$fEnumInt64_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sgr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sgs; else goto c4sgt;
       c4sgs: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sgt: // global
           I64[Sp - 8] = block_c4sgo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sgI; else goto c4sgp;
       u4sgI: // global
           call _c4sgo(R1) args: 0, res: 0, upd: 0;
       c4sgp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sgo() //  [R1]
         { info_tbl: [(c4sgo,
                       label: block_c4sgo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sgo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sgy; else goto c4sgx;
       c4sgy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sgx: // global
           _s4kYh::I64 = I64[R1 + 7];
           if (_s4kYh::I64 != 9223372036854775807) goto c4sgG; else goto c4sgH;
       c4sgG: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kYh::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sgH: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.852858038 UTC

[section ""data" . GHC.Int.$wgo2_closure" {
     GHC.Int.$wgo2_closure:
         const GHC.Int.$wgo2_info;
 },
 sat_s4kYq_entry() //  [R1]
         { info_tbl: [(c4sh8,
                       label: sat_s4kYq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sh8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sh9; else goto c4shk;
       c4sh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4shk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kYl::I64 = I64[R1 + 16];
           if (_s4kYl::I64 != 9223372036854775807) goto c4sh6; else goto c4sh7;
       c4sh6: // global
           I64[Sp - 24] = block_c4she_info;
           R2 = _s4kYl::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c4sh7: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4she() //  [R1, R2]
         { info_tbl: [(c4she,
                       label: block_c4she_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4she: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4shj; else goto c4shi;
       c4shj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4shi: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo2_entry() //  [R2]
         { info_tbl: [(c4shm,
                       label: GHC.Int.$wgo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4shm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4shq; else goto c4shp;
       c4shq: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Int.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4shp: // global
           I64[Hp - 32] = sat_s4kYq_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R2 = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.862787666 UTC

[section ""data" . GHC.Int.$fEnumInt64_go_closure" {
     GHC.Int.$fEnumInt64_go_closure:
         const GHC.Int.$fEnumInt64_go_info;
 },
 GHC.Int.$fEnumInt64_go_entry() //  [R2]
         { info_tbl: [(c4shN,
                       label: GHC.Int.$fEnumInt64_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4shN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4shO; else goto c4shP;
       c4shO: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4shP: // global
           I64[Sp - 8] = block_c4shK_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4shK() //  [R1, R2]
         { info_tbl: [(c4shK,
                       label: block_c4shK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4shK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4shS; else goto c4shR;
       c4shS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4shR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.868573539 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFrom_closure" {
     GHC.Int.$fEnumInt64_$cenumFrom_closure:
         const GHC.Int.$fEnumInt64_$cenumFrom_info;
 },
 GHC.Int.$fEnumInt64_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4si9,
                       label: GHC.Int.$fEnumInt64_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4si9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sia; else goto c4sib;
       c4sia: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sib: // global
           I64[Sp - 8] = block_c4si6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sif; else goto c4si7;
       u4sif: // global
           call _c4si6(R1) args: 0, res: 0, upd: 0;
       c4si7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4si6() //  [R1]
         { info_tbl: [(c4si6,
                       label: block_c4si6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4si6: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.874590231 UTC

[section ""data" . GHC.Int.$fEnumInt64_closure" {
     GHC.Int.$fEnumInt64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt64_$csucc_closure+1;
         const GHC.Int.$fEnumInt64_$cpred_closure+1;
         const GHC.Int.$fEnumInt64_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt64_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4sit,
                       label: GHC.Int.$fEnumInt64_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sit: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt64_closure+1;
           R2 = GHC.Int.$fEnumInt64_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.879875095 UTC

[section ""data" . GHC.Int.$fNumInt8_$cfromInteger_closure" {
     GHC.Int.$fNumInt8_$cfromInteger_closure:
         const GHC.Int.$fNumInt8_$cfromInteger_info;
 },
 GHC.Int.$fNumInt8_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4siH,
                       label: GHC.Int.$fNumInt8_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4siH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4siO; else goto c4siP;
       c4siO: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4siP: // global
           I64[Sp - 8] = block_c4siF_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4siF() //  [R1]
         { info_tbl: [(c4siF,
                       label: block_c4siF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4siF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4siS; else goto c4siR;
       c4siS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4siR: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.886003189 UTC

[section ""data" . GHC.Int.$fNumInt8_$cnegate_closure" {
     GHC.Int.$fNumInt8_$cnegate_closure:
         const GHC.Int.$fNumInt8_$cnegate_info;
 },
 GHC.Int.$fNumInt8_$cnegate_entry() //  [R2]
         { info_tbl: [(c4sjb,
                       label: GHC.Int.$fNumInt8_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sjb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sjl; else goto c4sjm;
       c4sjl: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sjm: // global
           I64[Sp - 8] = block_c4sj8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sjq; else goto c4sj9;
       u4sjq: // global
           call _c4sj8(R1) args: 0, res: 0, upd: 0;
       c4sj9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sj8() //  [R1]
         { info_tbl: [(c4sj8,
                       label: block_c4sj8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sj8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sjp; else goto c4sjo;
       c4sjp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sjo: // global
           _s4kYF::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYF::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.89207815 UTC

[section ""data" . GHC.Int.$fNumInt8_$c*_closure" {
     GHC.Int.$fNumInt8_$c*_closure:
         const GHC.Int.$fNumInt8_$c*_info;
 },
 GHC.Int.$fNumInt8_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4sjJ,
                       label: GHC.Int.$fNumInt8_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sjJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sjY; else goto c4sjZ;
       c4sjY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sjZ: // global
           I64[Sp - 16] = block_c4sjG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sk5; else goto c4sjH;
       u4sk5: // global
           call _c4sjG(R1) args: 0, res: 0, upd: 0;
       c4sjH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sjG() //  [R1]
         { info_tbl: [(c4sjG,
                       label: block_c4sjG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sjG: // global
           I64[Sp] = block_c4sjM_info;
           _s4kYJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYJ::I64;
           if (R1 & 7 != 0) goto u4sk4; else goto c4sjN;
       u4sk4: // global
           call _c4sjM(R1) args: 0, res: 0, upd: 0;
       c4sjN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sjM() //  [R1]
         { info_tbl: [(c4sjM,
                       label: block_c4sjM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sjM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sk3; else goto c4sk2;
       c4sk3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sk2: // global
           _s4kYN::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYN::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.904368686 UTC

[section ""data" . GHC.Int.$fNumInt8_$c-_closure" {
     GHC.Int.$fNumInt8_$c-_closure:
         const GHC.Int.$fNumInt8_$c-_info;
 },
 GHC.Int.$fNumInt8_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4sku,
                       label: GHC.Int.$fNumInt8_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4skJ; else goto c4skK;
       c4skJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4skK: // global
           I64[Sp - 16] = block_c4skr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4skQ; else goto c4sks;
       u4skQ: // global
           call _c4skr(R1) args: 0, res: 0, upd: 0;
       c4sks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4skr() //  [R1]
         { info_tbl: [(c4skr,
                       label: block_c4skr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4skr: // global
           I64[Sp] = block_c4skx_info;
           _s4kYR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYR::I64;
           if (R1 & 7 != 0) goto u4skP; else goto c4sky;
       u4skP: // global
           call _c4skx(R1) args: 0, res: 0, upd: 0;
       c4sky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4skx() //  [R1]
         { info_tbl: [(c4skx,
                       label: block_c4skx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4skx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4skO; else goto c4skN;
       c4skO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4skN: // global
           _s4kYV::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.916175866 UTC

[section ""data" . GHC.Int.$fNumInt8_$c+_closure" {
     GHC.Int.$fNumInt8_$c+_closure:
         const GHC.Int.$fNumInt8_$c+_info;
 },
 GHC.Int.$fNumInt8_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4slf,
                       label: GHC.Int.$fNumInt8_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4slf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4slu; else goto c4slv;
       c4slu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4slv: // global
           I64[Sp - 16] = block_c4slc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4slB; else goto c4sld;
       u4slB: // global
           call _c4slc(R1) args: 0, res: 0, upd: 0;
       c4sld: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4slc() //  [R1]
         { info_tbl: [(c4slc,
                       label: block_c4slc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4slc: // global
           I64[Sp] = block_c4sli_info;
           _s4kYZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYZ::I64;
           if (R1 & 7 != 0) goto u4slA; else goto c4slj;
       u4slA: // global
           call _c4sli(R1) args: 0, res: 0, upd: 0;
       c4slj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sli() //  [R1]
         { info_tbl: [(c4sli,
                       label: block_c4sli_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sli: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4slz; else goto c4sly;
       c4slz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sly: // global
           _s4kZ3::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZ3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.928859478 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt8_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt8_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt8_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4sm0,
                       label: GHC.Int.$fIntegralInt8_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sm0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sm1; else goto c4sm2;
       c4sm1: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sm2: // global
           I64[Sp - 8] = block_c4slX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sm6; else goto c4slY;
       u4sm6: // global
           call _c4slX(R1) args: 0, res: 0, upd: 0;
       c4slY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4slX() //  [R1]
         { info_tbl: [(c4slX,
                       label: block_c4slX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4slX: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.93453441 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cpopCount_closure" {
     GHC.Int.$fBitsInt8_$cpopCount_closure:
         const GHC.Int.$fBitsInt8_$cpopCount_info;
 },
 GHC.Int.$fBitsInt8_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4smn,
                       label: GHC.Int.$fBitsInt8_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4smn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4smB; else goto c4smC;
       c4smB: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4smC: // global
           I64[Sp - 8] = block_c4smk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4smG; else goto c4sml;
       u4smG: // global
           call _c4smk(R1) args: 0, res: 0, upd: 0;
       c4sml: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4smk() //  [R1]
         { info_tbl: [(c4smk,
                       label: block_c4smk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4smk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4smF; else goto c4smE;
       c4smF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4smE: // global
           (_c4smt::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4smt::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.940652544 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4smY,
                       label: GHC.Int.$fBitsInt8_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4smY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sna; else goto c4snb;
       c4sna: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4snb: // global
           I64[Sp - 16] = block_c4smV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4snh; else goto c4smW;
       u4snh: // global
           call _c4smV(R1) args: 0, res: 0, upd: 0;
       c4smW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4smV() //  [R1]
         { info_tbl: [(c4smV,
                       label: block_c4smV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4smV: // global
           I64[Sp] = block_c4sn1_info;
           _s4kZg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZg::I64;
           if (R1 & 7 != 0) goto u4sng; else goto c4sn2;
       u4sng: // global
           call _c4sn1(R1) args: 0, res: 0, upd: 0;
       c4sn2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sn1() //  [R1]
         { info_tbl: [(c4sn1,
                       label: block_c4sn1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sn1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4snf; else goto c4sne;
       c4snf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sne: // global
           _s4kZj::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.948488323 UTC

[section ""data" . GHC.Int.$fBitsInt13_closure" {
     GHC.Int.$fBitsInt13_closure:
         const GHC.Int.I8#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.950131131 UTC

[section ""data" . GHC.Int.$fNumInt9_closure" {
     GHC.Int.$fNumInt9_closure:
         const GHC.Int.I8#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.952474513 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftR_closure" {
     GHC.Int.$fBitsInt8_$cshiftR_closure:
         const GHC.Int.$fBitsInt8_$cshiftR_info;
 },
 GHC.Int.$fBitsInt8_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4snG,
                       label: GHC.Int.$fBitsInt8_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4snG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4snK; else goto c4snL;
       c4snK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4snL: // global
           I64[Sp - 16] = block_c4snD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sob; else goto c4snE;
       u4sob: // global
           call _c4snD(R1) args: 0, res: 0, upd: 0;
       c4snE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4snD() //  [R1]
         { info_tbl: [(c4snD,
                       label: block_c4snD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4snD: // global
           I64[Sp] = block_c4snJ_info;
           _s4kZn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZn::I64;
           if (R1 & 7 != 0) goto u4soa; else goto c4snN;
       u4soa: // global
           call _c4snJ(R1) args: 0, res: 0, upd: 0;
       c4snN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4snJ() //  [R1]
         { info_tbl: [(c4snJ,
                       label: block_c4snJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4snJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4snT; else goto c4snS;
       c4snT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4snS: // global
           _s4kZn::I64 = I64[Sp + 8];
           _s4kZp::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4kZp::I64, 64)) goto c4so2; else goto c4so9;
       c4so2: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4kZn::I64, _s4kZp::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4so9: // global
           if (%MO_S_Ge_W64(_s4kZn::I64, 0)) goto c4so7; else goto c4so8;
       c4so7: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4so8: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.961093095 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4soA,
                       label: GHC.Int.$fBitsInt8_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4soA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4soP; else goto c4soQ;
       c4soP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4soQ: // global
           I64[Sp - 16] = block_c4sox_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4soW; else goto c4soy;
       u4soW: // global
           call _c4sox(R1) args: 0, res: 0, upd: 0;
       c4soy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sox() //  [R1]
         { info_tbl: [(c4sox,
                       label: block_c4sox_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sox: // global
           I64[Sp] = block_c4soD_info;
           _s4kZw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZw::I64;
           if (R1 & 7 != 0) goto u4soV; else goto c4soE;
       u4soV: // global
           call _c4soD(R1) args: 0, res: 0, upd: 0;
       c4soE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4soD() //  [R1]
         { info_tbl: [(c4soD,
                       label: block_c4soD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4soD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4soU; else goto c4soT;
       c4soU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4soT: // global
           _s4kZA::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.970347613 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftL_closure" {
     GHC.Int.$fBitsInt8_$cshiftL_closure:
         const GHC.Int.$fBitsInt8_$cshiftL_info;
 },
 GHC.Int.$fBitsInt8_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4spk,
                       label: GHC.Int.$fBitsInt8_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4spk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4spo; else goto c4spp;
       c4spo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4spp: // global
           I64[Sp - 16] = block_c4sph_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4spM; else goto c4spi;
       u4spM: // global
           call _c4sph(R1) args: 0, res: 0, upd: 0;
       c4spi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sph() //  [R1]
         { info_tbl: [(c4sph,
                       label: block_c4sph_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sph: // global
           I64[Sp] = block_c4spn_info;
           _s4kZE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZE::I64;
           if (R1 & 7 != 0) goto u4spL; else goto c4spr;
       u4spL: // global
           call _c4spn(R1) args: 0, res: 0, upd: 0;
       c4spr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4spn() //  [R1]
         { info_tbl: [(c4spn,
                       label: block_c4spn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4spn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4spx; else goto c4spw;
       c4spx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4spw: // global
           _s4kZG::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4kZG::I64, 64)) goto c4spJ; else goto c4spK;
       c4spJ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << _s4kZG::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4spK: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.978472428 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cisSigned_closure" {
     GHC.Int.$fBitsInt8_$cisSigned_closure:
         const GHC.Int.$fBitsInt8_$cisSigned_info;
 },
 GHC.Int.$fBitsInt8_$cisSigned_entry() //  []
         { info_tbl: [(c4sq9,
                       label: GHC.Int.$fBitsInt8_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sq9: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.982452761 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotate_closure" {
     GHC.Int.$fBitsInt8_$crotate_closure:
         const GHC.Int.$fBitsInt8_$crotate_info;
 },
 GHC.Int.$fBitsInt8_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4sqo,
                       label: GHC.Int.$fBitsInt8_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sqo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sqs; else goto c4sqt;
       c4sqs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sqt: // global
           I64[Sp - 16] = block_c4sql_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4srp; else goto c4sqm;
       u4srp: // global
           call _c4sql(R1) args: 0, res: 0, upd: 0;
       c4sqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sql() //  [R1]
         { info_tbl: [(c4sql,
                       label: block_c4sql_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sql: // global
           I64[Sp - 8] = block_c4sqr_info;
           _s4kZN::P64 = R1;
           _s4kZO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4kZO::I64;
           P64[Sp + 8] = _s4kZN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sro; else goto c4sqv;
       u4sro: // global
           call _c4sqr(R1) args: 0, res: 0, upd: 0;
       c4sqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sqr() //  [R1]
         { info_tbl: [(c4sqr,
                       label: block_c4sqr_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sqr: // global
           _s4kZT::I64 = I64[R1 + 7] & 7;
           if (_s4kZT::I64 != 0) goto u4srm; else goto c4sri;
       u4srm: // global
           I64[Sp + 16] = _s4kZT::I64;
           Sp = Sp + 8;
           call _c4sqK() args: 0, res: 0, upd: 0;
       c4sri: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4sqK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sqK: // global
           Hp = Hp + 16;
           _s4kZT::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4srf; else goto c4sre;
       c4srf: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4sqJ_info;
           R1 = _s4kZT::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4sre: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4kZU::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4kZU::I64 << _s4kZT::I64) | (_s4kZU::I64 >> 8 - _s4kZT::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4sqJ() //  [R1]
         { info_tbl: [(c4sqJ,
                       label: block_c4sqJ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sqJ: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4sqK() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:10.994036762 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshift_closure" {
     GHC.Int.$fBitsInt8_$cshift_closure:
         const GHC.Int.$fBitsInt8_$cshift_info;
 },
 GHC.Int.$fBitsInt8_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4ss2,
                       label: GHC.Int.$fBitsInt8_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ss2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ss6; else goto c4ss7;
       c4ss6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ss7: // global
           I64[Sp - 16] = block_c4srZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ssU; else goto c4ss0;
       u4ssU: // global
           call _c4srZ(R1) args: 0, res: 0, upd: 0;
       c4ss0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4srZ() //  [R1]
         { info_tbl: [(c4srZ,
                       label: block_c4srZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4srZ: // global
           I64[Sp] = block_c4ss5_info;
           _s4l05::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l05::I64;
           if (R1 & 7 != 0) goto u4ssT; else goto c4ss9;
       u4ssT: // global
           call _c4ss5(R1) args: 0, res: 0, upd: 0;
       c4ss9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ss5() //  [R1]
         { info_tbl: [(c4ss5,
                       label: block_c4ss5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ss5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ssf; else goto c4sse;
       c4ssf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sse: // global
           _s4l05::I64 = I64[Sp + 8];
           _s4l07::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l07::I64, 0)) goto c4ssD; else goto c4ssS;
       c4ssD: // global
           _s4l09::I64 = -_s4l07::I64;
           if (%MO_S_Lt_W64(_s4l09::I64, 64)) goto c4ssu; else goto c4ssB;
       c4ssu: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l05::I64, _s4l09::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ssB: // global
           if (%MO_S_Ge_W64(_s4l05::I64, 0)) goto c4ssR; else goto c4ssA;
       c4ssA: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ssS: // global
           if (%MO_S_Ge_W64(_s4l07::I64, 64)) goto c4ssR; else goto c4ssQ;
       c4ssR: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ssQ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4l05::I64 << _s4l07::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.003027508 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplement_closure" {
     GHC.Int.$fBitsInt8_$ccomplement_closure:
         const GHC.Int.$fBitsInt8_$ccomplement_info;
 },
 GHC.Int.$fBitsInt8_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4stn,
                       label: GHC.Int.$fBitsInt8_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4stn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4stA; else goto c4stB;
       c4stA: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4stB: // global
           I64[Sp - 8] = block_c4stk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4stF; else goto c4stl;
       u4stF: // global
           call _c4stk(R1) args: 0, res: 0, upd: 0;
       c4stl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4stk() //  [R1]
         { info_tbl: [(c4stk,
                       label: block_c4stk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4stk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4stE; else goto c4stD;
       c4stE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4stD: // global
           _s4l0l::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.009447032 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cxor_closure" {
     GHC.Int.$fBitsInt8_$cxor_closure:
         const GHC.Int.$fBitsInt8_$cxor_info;
 },
 GHC.Int.$fBitsInt8_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4stX,
                       label: GHC.Int.$fBitsInt8_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4stX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sui; else goto c4suj;
       c4sui: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4suj: // global
           I64[Sp - 16] = block_c4stU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sup; else goto c4stV;
       u4sup: // global
           call _c4stU(R1) args: 0, res: 0, upd: 0;
       c4stV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4stU() //  [R1]
         { info_tbl: [(c4stU,
                       label: block_c4stU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4stU: // global
           I64[Sp] = block_c4su0_info;
           _s4l0p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0p::I64;
           if (R1 & 7 != 0) goto u4suo; else goto c4su1;
       u4suo: // global
           call _c4su0(R1) args: 0, res: 0, upd: 0;
       c4su1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4su0() //  [R1]
         { info_tbl: [(c4su0,
                       label: block_c4su0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4su0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sun; else goto c4sum;
       c4sun: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sum: // global
           _s4l0v::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0v::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.017335931 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.|._closure" {
     GHC.Int.$fBitsInt8_$c.|._closure:
         const GHC.Int.$fBitsInt8_$c.|._info;
 },
 GHC.Int.$fBitsInt8_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4suN,
                       label: GHC.Int.$fBitsInt8_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4suN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sv8; else goto c4sv9;
       c4sv8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sv9: // global
           I64[Sp - 16] = block_c4suK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4svf; else goto c4suL;
       u4svf: // global
           call _c4suK(R1) args: 0, res: 0, upd: 0;
       c4suL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4suK() //  [R1]
         { info_tbl: [(c4suK,
                       label: block_c4suK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4suK: // global
           I64[Sp] = block_c4suQ_info;
           _s4l0z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0z::I64;
           if (R1 & 7 != 0) goto u4sve; else goto c4suR;
       u4sve: // global
           call _c4suQ(R1) args: 0, res: 0, upd: 0;
       c4suR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4suQ() //  [R1]
         { info_tbl: [(c4suQ,
                       label: block_c4suQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4suQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4svd; else goto c4svc;
       c4svd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4svc: // global
           _s4l0F::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0F::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.026197171 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.&._closure" {
     GHC.Int.$fBitsInt8_$c.&._closure:
         const GHC.Int.$fBitsInt8_$c.&._info;
 },
 GHC.Int.$fBitsInt8_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4svD,
                       label: GHC.Int.$fBitsInt8_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4svD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4svY; else goto c4svZ;
       c4svY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4svZ: // global
           I64[Sp - 16] = block_c4svA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sw5; else goto c4svB;
       u4sw5: // global
           call _c4svA(R1) args: 0, res: 0, upd: 0;
       c4svB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4svA() //  [R1]
         { info_tbl: [(c4svA,
                       label: block_c4svA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4svA: // global
           I64[Sp] = block_c4svG_info;
           _s4l0J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0J::I64;
           if (R1 & 7 != 0) goto u4sw4; else goto c4svH;
       u4sw4: // global
           call _c4svG(R1) args: 0, res: 0, upd: 0;
       c4svH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4svG() //  [R1]
         { info_tbl: [(c4svG,
                       label: block_c4svG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4svG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sw3; else goto c4sw2;
       c4sw3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sw2: // global
           _s4l0P::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0P::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.034010413 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4swt,
                       label: GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4swt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4swH; else goto c4swI;
       c4swH: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4swI: // global
           I64[Sp - 8] = block_c4swq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4swM; else goto c4swr;
       u4swM: // global
           call _c4swq(R1) args: 0, res: 0, upd: 0;
       c4swr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4swq() //  [R1]
         { info_tbl: [(c4swq,
                       label: block_c4swq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4swq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4swL; else goto c4swK;
       c4swL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4swK: // global
           (_c4swz::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4swz::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.040104518 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4sx6,
                       label: GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sx6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sxk; else goto c4sxl;
       c4sxk: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sxl: // global
           I64[Sp - 8] = block_c4sx3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sxp; else goto c4sx4;
       u4sxp: // global
           call _c4sx3(R1) args: 0, res: 0, upd: 0;
       c4sx4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sx3() //  [R1]
         { info_tbl: [(c4sx3,
                       label: block_c4sx3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sx3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sxo; else goto c4sxn;
       c4sxo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sxn: // global
           (_c4sxc::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4sxc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.047023052 UTC

[section ""data" . GHC.Int.$fBitsInt11_closure" {
     GHC.Int.$fBitsInt11_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.048898533 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt8_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt8_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4sxH,
                       label: GHC.Int.$fBitsInt8_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sxH: // global
           R1 = GHC.Int.$fBitsInt11_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.052587531 UTC

[section ""data" . GHC.Int.$fNumInt16_$cfromInteger_closure" {
     GHC.Int.$fNumInt16_$cfromInteger_closure:
         const GHC.Int.$fNumInt16_$cfromInteger_info;
 },
 GHC.Int.$fNumInt16_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4sxV,
                       label: GHC.Int.$fNumInt16_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sxV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sy2; else goto c4sy3;
       c4sy2: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sy3: // global
           I64[Sp - 8] = block_c4sxT_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4sxT() //  [R1]
         { info_tbl: [(c4sxT,
                       label: block_c4sxT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sxT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sy6; else goto c4sy5;
       c4sy6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4sy5: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.058599875 UTC

[section ""data" . GHC.Int.$fNumInt16_$cnegate_closure" {
     GHC.Int.$fNumInt16_$cnegate_closure:
         const GHC.Int.$fNumInt16_$cnegate_info;
 },
 GHC.Int.$fNumInt16_$cnegate_entry() //  [R2]
         { info_tbl: [(c4syp,
                       label: GHC.Int.$fNumInt16_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4syp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4syz; else goto c4syA;
       c4syz: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4syA: // global
           I64[Sp - 8] = block_c4sym_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4syE; else goto c4syn;
       u4syE: // global
           call _c4sym(R1) args: 0, res: 0, upd: 0;
       c4syn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sym() //  [R1]
         { info_tbl: [(c4sym,
                       label: block_c4sym_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sym: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4syD; else goto c4syC;
       c4syD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4syC: // global
           _s4l1a::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1a::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.065881199 UTC

[section ""data" . GHC.Int.$fNumInt16_$c*_closure" {
     GHC.Int.$fNumInt16_$c*_closure:
         const GHC.Int.$fNumInt16_$c*_info;
 },
 GHC.Int.$fNumInt16_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4syX,
                       label: GHC.Int.$fNumInt16_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4syX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4szc; else goto c4szd;
       c4szc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4szd: // global
           I64[Sp - 16] = block_c4syU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4szj; else goto c4syV;
       u4szj: // global
           call _c4syU(R1) args: 0, res: 0, upd: 0;
       c4syV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4syU() //  [R1]
         { info_tbl: [(c4syU,
                       label: block_c4syU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4syU: // global
           I64[Sp] = block_c4sz0_info;
           _s4l1e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1e::I64;
           if (R1 & 7 != 0) goto u4szi; else goto c4sz1;
       u4szi: // global
           call _c4sz0(R1) args: 0, res: 0, upd: 0;
       c4sz1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sz0() //  [R1]
         { info_tbl: [(c4sz0,
                       label: block_c4sz0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sz0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4szh; else goto c4szg;
       c4szh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4szg: // global
           _s4l1i::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1i::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.07389033 UTC

[section ""data" . GHC.Int.$fNumInt16_$c-_closure" {
     GHC.Int.$fNumInt16_$c-_closure:
         const GHC.Int.$fNumInt16_$c-_info;
 },
 GHC.Int.$fNumInt16_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4szI,
                       label: GHC.Int.$fNumInt16_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4szI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4szX; else goto c4szY;
       c4szX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4szY: // global
           I64[Sp - 16] = block_c4szF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sA4; else goto c4szG;
       u4sA4: // global
           call _c4szF(R1) args: 0, res: 0, upd: 0;
       c4szG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4szF() //  [R1]
         { info_tbl: [(c4szF,
                       label: block_c4szF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4szF: // global
           I64[Sp] = block_c4szL_info;
           _s4l1m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1m::I64;
           if (R1 & 7 != 0) goto u4sA3; else goto c4szM;
       u4sA3: // global
           call _c4szL(R1) args: 0, res: 0, upd: 0;
       c4szM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4szL() //  [R1]
         { info_tbl: [(c4szL,
                       label: block_c4szL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4szL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sA2; else goto c4sA1;
       c4sA2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sA1: // global
           _s4l1q::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.082461071 UTC

[section ""data" . GHC.Int.$fNumInt16_$c+_closure" {
     GHC.Int.$fNumInt16_$c+_closure:
         const GHC.Int.$fNumInt16_$c+_info;
 },
 GHC.Int.$fNumInt16_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4sAt,
                       label: GHC.Int.$fNumInt16_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sAt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sAI; else goto c4sAJ;
       c4sAI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sAJ: // global
           I64[Sp - 16] = block_c4sAq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sAP; else goto c4sAr;
       u4sAP: // global
           call _c4sAq(R1) args: 0, res: 0, upd: 0;
       c4sAr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sAq() //  [R1]
         { info_tbl: [(c4sAq,
                       label: block_c4sAq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sAq: // global
           I64[Sp] = block_c4sAw_info;
           _s4l1u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1u::I64;
           if (R1 & 7 != 0) goto u4sAO; else goto c4sAx;
       u4sAO: // global
           call _c4sAw(R1) args: 0, res: 0, upd: 0;
       c4sAx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sAw() //  [R1]
         { info_tbl: [(c4sAw,
                       label: block_c4sAw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sAw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sAN; else goto c4sAM;
       c4sAN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sAM: // global
           _s4l1y::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1y::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.090767257 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt16_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt16_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt16_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4sBe,
                       label: GHC.Int.$fIntegralInt16_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sBe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sBf; else goto c4sBg;
       c4sBf: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sBg: // global
           I64[Sp - 8] = block_c4sBb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sBk; else goto c4sBc;
       u4sBk: // global
           call _c4sBb(R1) args: 0, res: 0, upd: 0;
       c4sBc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sBb() //  [R1]
         { info_tbl: [(c4sBb,
                       label: block_c4sBb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sBb: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.096490409 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cpopCount_closure" {
     GHC.Int.$fBitsInt16_$cpopCount_closure:
         const GHC.Int.$fBitsInt16_$cpopCount_info;
 },
 GHC.Int.$fBitsInt16_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4sBB,
                       label: GHC.Int.$fBitsInt16_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sBB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sBP; else goto c4sBQ;
       c4sBP: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sBQ: // global
           I64[Sp - 8] = block_c4sBy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sBU; else goto c4sBz;
       u4sBU: // global
           call _c4sBy(R1) args: 0, res: 0, upd: 0;
       c4sBz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sBy() //  [R1]
         { info_tbl: [(c4sBy,
                       label: block_c4sBy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sBy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sBT; else goto c4sBS;
       c4sBT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sBS: // global
           (_c4sBH::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4sBH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.103446567 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4sCc,
                       label: GHC.Int.$fBitsInt16_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sCc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sCo; else goto c4sCp;
       c4sCo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sCp: // global
           I64[Sp - 16] = block_c4sC9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sCv; else goto c4sCa;
       u4sCv: // global
           call _c4sC9(R1) args: 0, res: 0, upd: 0;
       c4sCa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sC9() //  [R1]
         { info_tbl: [(c4sC9,
                       label: block_c4sC9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sC9: // global
           I64[Sp] = block_c4sCf_info;
           _s4l1L::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1L::I64;
           if (R1 & 7 != 0) goto u4sCu; else goto c4sCg;
       u4sCu: // global
           call _c4sCf(R1) args: 0, res: 0, upd: 0;
       c4sCg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sCf() //  [R1]
         { info_tbl: [(c4sCf,
                       label: block_c4sCf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sCf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sCt; else goto c4sCs;
       c4sCt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sCs: // global
           _s4l1O::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1O::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.111217132 UTC

[section ""data" . GHC.Int.$fBitsInt3_closure" {
     GHC.Int.$fBitsInt3_closure:
         const GHC.Int.I16#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.112825188 UTC

[section ""data" . GHC.Int.$fNumInt2_closure" {
     GHC.Int.$fNumInt2_closure:
         const GHC.Int.I16#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.115210189 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftR_closure" {
     GHC.Int.$fBitsInt16_$cshiftR_closure:
         const GHC.Int.$fBitsInt16_$cshiftR_info;
 },
 GHC.Int.$fBitsInt16_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4sCU,
                       label: GHC.Int.$fBitsInt16_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sCU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sCY; else goto c4sCZ;
       c4sCY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sCZ: // global
           I64[Sp - 16] = block_c4sCR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sDp; else goto c4sCS;
       u4sDp: // global
           call _c4sCR(R1) args: 0, res: 0, upd: 0;
       c4sCS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sCR() //  [R1]
         { info_tbl: [(c4sCR,
                       label: block_c4sCR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sCR: // global
           I64[Sp] = block_c4sCX_info;
           _s4l1S::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1S::I64;
           if (R1 & 7 != 0) goto u4sDo; else goto c4sD1;
       u4sDo: // global
           call _c4sCX(R1) args: 0, res: 0, upd: 0;
       c4sD1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sCX() //  [R1]
         { info_tbl: [(c4sCX,
                       label: block_c4sCX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sCX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sD7; else goto c4sD6;
       c4sD7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sD6: // global
           _s4l1S::I64 = I64[Sp + 8];
           _s4l1U::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l1U::I64, 64)) goto c4sDg; else goto c4sDn;
       c4sDg: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l1S::I64, _s4l1U::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sDn: // global
           if (%MO_S_Ge_W64(_s4l1S::I64, 0)) goto c4sDl; else goto c4sDm;
       c4sDl: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sDm: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.12503452 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4sDO,
                       label: GHC.Int.$fBitsInt16_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sDO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sE3; else goto c4sE4;
       c4sE3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sE4: // global
           I64[Sp - 16] = block_c4sDL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sEa; else goto c4sDM;
       u4sEa: // global
           call _c4sDL(R1) args: 0, res: 0, upd: 0;
       c4sDM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sDL() //  [R1]
         { info_tbl: [(c4sDL,
                       label: block_c4sDL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sDL: // global
           I64[Sp] = block_c4sDR_info;
           _s4l21::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l21::I64;
           if (R1 & 7 != 0) goto u4sE9; else goto c4sDS;
       u4sE9: // global
           call _c4sDR(R1) args: 0, res: 0, upd: 0;
       c4sDS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sDR() //  [R1]
         { info_tbl: [(c4sDR,
                       label: block_c4sDR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sDR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sE8; else goto c4sE7;
       c4sE8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sE7: // global
           _s4l25::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l25::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.134068194 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftL_closure" {
     GHC.Int.$fBitsInt16_$cshiftL_closure:
         const GHC.Int.$fBitsInt16_$cshiftL_info;
 },
 GHC.Int.$fBitsInt16_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4sEy,
                       label: GHC.Int.$fBitsInt16_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sEy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sEC; else goto c4sED;
       c4sEC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sED: // global
           I64[Sp - 16] = block_c4sEv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sF0; else goto c4sEw;
       u4sF0: // global
           call _c4sEv(R1) args: 0, res: 0, upd: 0;
       c4sEw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sEv() //  [R1]
         { info_tbl: [(c4sEv,
                       label: block_c4sEv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sEv: // global
           I64[Sp] = block_c4sEB_info;
           _s4l29::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l29::I64;
           if (R1 & 7 != 0) goto u4sEZ; else goto c4sEF;
       u4sEZ: // global
           call _c4sEB(R1) args: 0, res: 0, upd: 0;
       c4sEF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sEB() //  [R1]
         { info_tbl: [(c4sEB,
                       label: block_c4sEB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sEB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sEL; else goto c4sEK;
       c4sEL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sEK: // global
           _s4l2b::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l2b::I64, 64)) goto c4sEX; else goto c4sEY;
       c4sEX: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << _s4l2b::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sEY: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.142848414 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cisSigned_closure" {
     GHC.Int.$fBitsInt16_$cisSigned_closure:
         const GHC.Int.$fBitsInt16_$cisSigned_info;
 },
 GHC.Int.$fBitsInt16_$cisSigned_entry() //  []
         { info_tbl: [(c4sFn,
                       label: GHC.Int.$fBitsInt16_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sFn: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.146942339 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotate_closure" {
     GHC.Int.$fBitsInt16_$crotate_closure:
         const GHC.Int.$fBitsInt16_$crotate_info;
 },
 GHC.Int.$fBitsInt16_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4sFC,
                       label: GHC.Int.$fBitsInt16_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sFC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sFG; else goto c4sFH;
       c4sFG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sFH: // global
           I64[Sp - 16] = block_c4sFz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sGD; else goto c4sFA;
       u4sGD: // global
           call _c4sFz(R1) args: 0, res: 0, upd: 0;
       c4sFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sFz() //  [R1]
         { info_tbl: [(c4sFz,
                       label: block_c4sFz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sFz: // global
           I64[Sp - 8] = block_c4sFF_info;
           _s4l2i::P64 = R1;
           _s4l2j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l2j::I64;
           P64[Sp + 8] = _s4l2i::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sGC; else goto c4sFJ;
       u4sGC: // global
           call _c4sFF(R1) args: 0, res: 0, upd: 0;
       c4sFJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sFF() //  [R1]
         { info_tbl: [(c4sFF,
                       label: block_c4sFF_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sFF: // global
           _s4l2o::I64 = I64[R1 + 7] & 15;
           if (_s4l2o::I64 != 0) goto u4sGA; else goto c4sGw;
       u4sGA: // global
           I64[Sp + 16] = _s4l2o::I64;
           Sp = Sp + 8;
           call _c4sFY() args: 0, res: 0, upd: 0;
       c4sGw: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4sFY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sFY: // global
           Hp = Hp + 16;
           _s4l2o::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4sGt; else goto c4sGs;
       c4sGt: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4sFX_info;
           R1 = _s4l2o::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4sGs: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4l2p::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4l2p::I64 << _s4l2o::I64) | (_s4l2p::I64 >> 16 - _s4l2o::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4sFX() //  [R1]
         { info_tbl: [(c4sFX,
                       label: block_c4sFX_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sFX: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4sFY() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.158731664 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshift_closure" {
     GHC.Int.$fBitsInt16_$cshift_closure:
         const GHC.Int.$fBitsInt16_$cshift_info;
 },
 GHC.Int.$fBitsInt16_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4sHg,
                       label: GHC.Int.$fBitsInt16_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sHg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sHk; else goto c4sHl;
       c4sHk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sHl: // global
           I64[Sp - 16] = block_c4sHd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sI8; else goto c4sHe;
       u4sI8: // global
           call _c4sHd(R1) args: 0, res: 0, upd: 0;
       c4sHe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sHd() //  [R1]
         { info_tbl: [(c4sHd,
                       label: block_c4sHd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sHd: // global
           I64[Sp] = block_c4sHj_info;
           _s4l2A::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l2A::I64;
           if (R1 & 7 != 0) goto u4sI7; else goto c4sHn;
       u4sI7: // global
           call _c4sHj(R1) args: 0, res: 0, upd: 0;
       c4sHn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sHj() //  [R1]
         { info_tbl: [(c4sHj,
                       label: block_c4sHj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sHj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sHt; else goto c4sHs;
       c4sHt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sHs: // global
           _s4l2A::I64 = I64[Sp + 8];
           _s4l2C::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l2C::I64, 0)) goto c4sHR; else goto c4sI6;
       c4sHR: // global
           _s4l2E::I64 = -_s4l2C::I64;
           if (%MO_S_Lt_W64(_s4l2E::I64, 64)) goto c4sHI; else goto c4sHP;
       c4sHI: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l2A::I64, _s4l2E::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sHP: // global
           if (%MO_S_Ge_W64(_s4l2A::I64, 0)) goto c4sI5; else goto c4sHO;
       c4sHO: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sI6: // global
           if (%MO_S_Ge_W64(_s4l2C::I64, 64)) goto c4sI5; else goto c4sI4;
       c4sI5: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sI4: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4l2A::I64 << _s4l2C::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.168626613 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplement_closure" {
     GHC.Int.$fBitsInt16_$ccomplement_closure:
         const GHC.Int.$fBitsInt16_$ccomplement_info;
 },
 GHC.Int.$fBitsInt16_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4sIB,
                       label: GHC.Int.$fBitsInt16_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sIB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sIO; else goto c4sIP;
       c4sIO: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sIP: // global
           I64[Sp - 8] = block_c4sIy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sIT; else goto c4sIz;
       u4sIT: // global
           call _c4sIy(R1) args: 0, res: 0, upd: 0;
       c4sIz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sIy() //  [R1]
         { info_tbl: [(c4sIy,
                       label: block_c4sIy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sIy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sIS; else goto c4sIR;
       c4sIS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sIR: // global
           _s4l2Q::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l2Q::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.175836923 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cxor_closure" {
     GHC.Int.$fBitsInt16_$cxor_closure:
         const GHC.Int.$fBitsInt16_$cxor_info;
 },
 GHC.Int.$fBitsInt16_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4sJb,
                       label: GHC.Int.$fBitsInt16_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sJb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sJw; else goto c4sJx;
       c4sJw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sJx: // global
           I64[Sp - 16] = block_c4sJ8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sJD; else goto c4sJ9;
       u4sJD: // global
           call _c4sJ8(R1) args: 0, res: 0, upd: 0;
       c4sJ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sJ8() //  [R1]
         { info_tbl: [(c4sJ8,
                       label: block_c4sJ8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sJ8: // global
           I64[Sp] = block_c4sJe_info;
           _s4l2U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l2U::I64;
           if (R1 & 7 != 0) goto u4sJC; else goto c4sJf;
       u4sJC: // global
           call _c4sJe(R1) args: 0, res: 0, upd: 0;
       c4sJf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sJe() //  [R1]
         { info_tbl: [(c4sJe,
                       label: block_c4sJe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sJe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sJB; else goto c4sJA;
       c4sJB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sJA: // global
           _s4l30::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l30::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.18455849 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.|._closure" {
     GHC.Int.$fBitsInt16_$c.|._closure:
         const GHC.Int.$fBitsInt16_$c.|._info;
 },
 GHC.Int.$fBitsInt16_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4sK1,
                       label: GHC.Int.$fBitsInt16_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sK1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sKm; else goto c4sKn;
       c4sKm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sKn: // global
           I64[Sp - 16] = block_c4sJY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sKt; else goto c4sJZ;
       u4sKt: // global
           call _c4sJY(R1) args: 0, res: 0, upd: 0;
       c4sJZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sJY() //  [R1]
         { info_tbl: [(c4sJY,
                       label: block_c4sJY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sJY: // global
           I64[Sp] = block_c4sK4_info;
           _s4l34::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l34::I64;
           if (R1 & 7 != 0) goto u4sKs; else goto c4sK5;
       u4sKs: // global
           call _c4sK4(R1) args: 0, res: 0, upd: 0;
       c4sK5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sK4() //  [R1]
         { info_tbl: [(c4sK4,
                       label: block_c4sK4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sK4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sKr; else goto c4sKq;
       c4sKr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sKq: // global
           _s4l3a::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l3a::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.193127589 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.&._closure" {
     GHC.Int.$fBitsInt16_$c.&._closure:
         const GHC.Int.$fBitsInt16_$c.&._info;
 },
 GHC.Int.$fBitsInt16_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4sKR,
                       label: GHC.Int.$fBitsInt16_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sKR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sLc; else goto c4sLd;
       c4sLc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sLd: // global
           I64[Sp - 16] = block_c4sKO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sLj; else goto c4sKP;
       u4sLj: // global
           call _c4sKO(R1) args: 0, res: 0, upd: 0;
       c4sKP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sKO() //  [R1]
         { info_tbl: [(c4sKO,
                       label: block_c4sKO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sKO: // global
           I64[Sp] = block_c4sKU_info;
           _s4l3e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3e::I64;
           if (R1 & 7 != 0) goto u4sLi; else goto c4sKV;
       u4sLi: // global
           call _c4sKU(R1) args: 0, res: 0, upd: 0;
       c4sKV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sKU() //  [R1]
         { info_tbl: [(c4sKU,
                       label: block_c4sKU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sKU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sLh; else goto c4sLg;
       c4sLh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sLg: // global
           _s4l3k::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l3k::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.201721632 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4sLH,
                       label: GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sLH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sLV; else goto c4sLW;
       c4sLV: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sLW: // global
           I64[Sp - 8] = block_c4sLE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sM0; else goto c4sLF;
       u4sM0: // global
           call _c4sLE(R1) args: 0, res: 0, upd: 0;
       c4sLF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sLE() //  [R1]
         { info_tbl: [(c4sLE,
                       label: block_c4sLE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sLE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sLZ; else goto c4sLY;
       c4sLZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sLY: // global
           (_c4sLN::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4sLN::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.210464957 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4sMk,
                       label: GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sMk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sMy; else goto c4sMz;
       c4sMy: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sMz: // global
           I64[Sp - 8] = block_c4sMh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sMD; else goto c4sMi;
       u4sMD: // global
           call _c4sMh(R1) args: 0, res: 0, upd: 0;
       c4sMi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sMh() //  [R1]
         { info_tbl: [(c4sMh,
                       label: block_c4sMh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sMh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sMC; else goto c4sMB;
       c4sMC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sMB: // global
           (_c4sMq::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4sMq::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.218200666 UTC

[section ""data" . GHC.Int.$fBitsInt1_closure" {
     GHC.Int.$fBitsInt1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.220185444 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt16_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt16_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4sMV,
                       label: GHC.Int.$fBitsInt16_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sMV: // global
           R1 = GHC.Int.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.224706715 UTC

[section ""data" . GHC.Int.$fNumInt32_$cfromInteger_closure" {
     GHC.Int.$fNumInt32_$cfromInteger_closure:
         const GHC.Int.$fNumInt32_$cfromInteger_info;
 },
 GHC.Int.$fNumInt32_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4sN9,
                       label: GHC.Int.$fNumInt32_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sN9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sNg; else goto c4sNh;
       c4sNg: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sNh: // global
           I64[Sp - 8] = block_c4sN7_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4sN7() //  [R1]
         { info_tbl: [(c4sN7,
                       label: block_c4sN7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sN7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sNk; else goto c4sNj;
       c4sNk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4sNj: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.230894619 UTC

[section ""data" . GHC.Int.$fNumInt32_$cnegate_closure" {
     GHC.Int.$fNumInt32_$cnegate_closure:
         const GHC.Int.$fNumInt32_$cnegate_info;
 },
 GHC.Int.$fNumInt32_$cnegate_entry() //  [R2]
         { info_tbl: [(c4sNC,
                       label: GHC.Int.$fNumInt32_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sNC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sNM; else goto c4sNN;
       c4sNM: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sNN: // global
           I64[Sp - 8] = block_c4sNz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sNR; else goto c4sNA;
       u4sNR: // global
           call _c4sNz(R1) args: 0, res: 0, upd: 0;
       c4sNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sNz() //  [R1]
         { info_tbl: [(c4sNz,
                       label: block_c4sNz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sNz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sNQ; else goto c4sNP;
       c4sNQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sNP: // global
           _s4l3F::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3F::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.237227842 UTC

[section ""data" . GHC.Int.$fNumInt32_$c*_closure" {
     GHC.Int.$fNumInt32_$c*_closure:
         const GHC.Int.$fNumInt32_$c*_info;
 },
 GHC.Int.$fNumInt32_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4sOa,
                       label: GHC.Int.$fNumInt32_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sOa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sOp; else goto c4sOq;
       c4sOp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sOq: // global
           I64[Sp - 16] = block_c4sO7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sOw; else goto c4sO8;
       u4sOw: // global
           call _c4sO7(R1) args: 0, res: 0, upd: 0;
       c4sO8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sO7() //  [R1]
         { info_tbl: [(c4sO7,
                       label: block_c4sO7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sO7: // global
           I64[Sp] = block_c4sOd_info;
           _s4l3J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3J::I64;
           if (R1 & 7 != 0) goto u4sOv; else goto c4sOe;
       u4sOv: // global
           call _c4sOd(R1) args: 0, res: 0, upd: 0;
       c4sOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sOd() //  [R1]
         { info_tbl: [(c4sOd,
                       label: block_c4sOd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sOd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sOu; else goto c4sOt;
       c4sOu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sOt: // global
           _s4l3N::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3N::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.247785573 UTC

[section ""data" . GHC.Int.$fNumInt32_$c-_closure" {
     GHC.Int.$fNumInt32_$c-_closure:
         const GHC.Int.$fNumInt32_$c-_info;
 },
 GHC.Int.$fNumInt32_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4sOV,
                       label: GHC.Int.$fNumInt32_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sOV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sPa; else goto c4sPb;
       c4sPa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sPb: // global
           I64[Sp - 16] = block_c4sOS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sPh; else goto c4sOT;
       u4sPh: // global
           call _c4sOS(R1) args: 0, res: 0, upd: 0;
       c4sOT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sOS() //  [R1]
         { info_tbl: [(c4sOS,
                       label: block_c4sOS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sOS: // global
           I64[Sp] = block_c4sOY_info;
           _s4l3R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3R::I64;
           if (R1 & 7 != 0) goto u4sPg; else goto c4sOZ;
       u4sPg: // global
           call _c4sOY(R1) args: 0, res: 0, upd: 0;
       c4sOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sOY() //  [R1]
         { info_tbl: [(c4sOY,
                       label: block_c4sOY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sOY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sPf; else goto c4sPe;
       c4sPf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sPe: // global
           _s4l3V::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3V::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.256142495 UTC

[section ""data" . GHC.Int.$fNumInt32_$c+_closure" {
     GHC.Int.$fNumInt32_$c+_closure:
         const GHC.Int.$fNumInt32_$c+_info;
 },
 GHC.Int.$fNumInt32_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4sPG,
                       label: GHC.Int.$fNumInt32_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sPG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sPV; else goto c4sPW;
       c4sPV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sPW: // global
           I64[Sp - 16] = block_c4sPD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sQ2; else goto c4sPE;
       u4sQ2: // global
           call _c4sPD(R1) args: 0, res: 0, upd: 0;
       c4sPE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sPD() //  [R1]
         { info_tbl: [(c4sPD,
                       label: block_c4sPD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sPD: // global
           I64[Sp] = block_c4sPJ_info;
           _s4l3Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3Z::I64;
           if (R1 & 7 != 0) goto u4sQ1; else goto c4sPK;
       u4sQ1: // global
           call _c4sPJ(R1) args: 0, res: 0, upd: 0;
       c4sPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sPJ() //  [R1]
         { info_tbl: [(c4sPJ,
                       label: block_c4sPJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sPJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sQ0; else goto c4sPZ;
       c4sQ0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sPZ: // global
           _s4l43::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l43::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.26456992 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt32_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt32_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt32_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4sQr,
                       label: GHC.Int.$fIntegralInt32_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sQr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sQs; else goto c4sQt;
       c4sQs: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sQt: // global
           I64[Sp - 8] = block_c4sQo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sQx; else goto c4sQp;
       u4sQx: // global
           call _c4sQo(R1) args: 0, res: 0, upd: 0;
       c4sQp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sQo() //  [R1]
         { info_tbl: [(c4sQo,
                       label: block_c4sQo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sQo: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.271178576 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cpopCount_closure" {
     GHC.Int.$fBitsInt32_$cpopCount_closure:
         const GHC.Int.$fBitsInt32_$cpopCount_info;
 },
 GHC.Int.$fBitsInt32_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4sQO,
                       label: GHC.Int.$fBitsInt32_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sQO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sR2; else goto c4sR3;
       c4sR2: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sR3: // global
           I64[Sp - 8] = block_c4sQL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sR7; else goto c4sQM;
       u4sR7: // global
           call _c4sQL(R1) args: 0, res: 0, upd: 0;
       c4sQM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sQL() //  [R1]
         { info_tbl: [(c4sQL,
                       label: block_c4sQL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sQL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sR6; else goto c4sR5;
       c4sR6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sR5: // global
           (_c4sQU::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4sQU::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.277539185 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4sRp,
                       label: GHC.Int.$fBitsInt32_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sRp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sRB; else goto c4sRC;
       c4sRB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sRC: // global
           I64[Sp - 16] = block_c4sRm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sRI; else goto c4sRn;
       u4sRI: // global
           call _c4sRm(R1) args: 0, res: 0, upd: 0;
       c4sRn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sRm() //  [R1]
         { info_tbl: [(c4sRm,
                       label: block_c4sRm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sRm: // global
           I64[Sp] = block_c4sRs_info;
           _s4l4g::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4g::I64;
           if (R1 & 7 != 0) goto u4sRH; else goto c4sRt;
       u4sRH: // global
           call _c4sRs(R1) args: 0, res: 0, upd: 0;
       c4sRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sRs() //  [R1]
         { info_tbl: [(c4sRs,
                       label: block_c4sRs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sRs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sRG; else goto c4sRF;
       c4sRG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sRF: // global
           _s4l4j::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l4j::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.285767724 UTC

[section ""data" . GHC.Int.$fBitsInt6_closure" {
     GHC.Int.$fBitsInt6_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.28738304 UTC

[section ""data" . GHC.Int.$fNumInt4_closure" {
     GHC.Int.$fNumInt4_closure:
         const GHC.Int.I32#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.28977639 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftR_closure" {
     GHC.Int.$fBitsInt32_$cshiftR_closure:
         const GHC.Int.$fBitsInt32_$cshiftR_info;
 },
 GHC.Int.$fBitsInt32_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4sS7,
                       label: GHC.Int.$fBitsInt32_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sS7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sSb; else goto c4sSc;
       c4sSb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sSc: // global
           I64[Sp - 16] = block_c4sS4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sSC; else goto c4sS5;
       u4sSC: // global
           call _c4sS4(R1) args: 0, res: 0, upd: 0;
       c4sS5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sS4() //  [R1]
         { info_tbl: [(c4sS4,
                       label: block_c4sS4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sS4: // global
           I64[Sp] = block_c4sSa_info;
           _s4l4n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4n::I64;
           if (R1 & 7 != 0) goto u4sSB; else goto c4sSe;
       u4sSB: // global
           call _c4sSa(R1) args: 0, res: 0, upd: 0;
       c4sSe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sSa() //  [R1]
         { info_tbl: [(c4sSa,
                       label: block_c4sSa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sSa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sSk; else goto c4sSj;
       c4sSk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sSj: // global
           _s4l4n::I64 = I64[Sp + 8];
           _s4l4p::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l4p::I64, 64)) goto c4sSt; else goto c4sSA;
       c4sSt: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l4n::I64, _s4l4p::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sSA: // global
           if (%MO_S_Ge_W64(_s4l4n::I64, 0)) goto c4sSy; else goto c4sSz;
       c4sSy: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sSz: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.298880755 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4sT1,
                       label: GHC.Int.$fBitsInt32_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sT1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sTg; else goto c4sTh;
       c4sTg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sTh: // global
           I64[Sp - 16] = block_c4sSY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sTn; else goto c4sSZ;
       u4sTn: // global
           call _c4sSY(R1) args: 0, res: 0, upd: 0;
       c4sSZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sSY() //  [R1]
         { info_tbl: [(c4sSY,
                       label: block_c4sSY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sSY: // global
           I64[Sp] = block_c4sT4_info;
           _s4l4w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4w::I64;
           if (R1 & 7 != 0) goto u4sTm; else goto c4sT5;
       u4sTm: // global
           call _c4sT4(R1) args: 0, res: 0, upd: 0;
       c4sT5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sT4() //  [R1]
         { info_tbl: [(c4sT4,
                       label: block_c4sT4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sT4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sTl; else goto c4sTk;
       c4sTl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sTk: // global
           _s4l4A::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l4A::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.308795882 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftL_closure" {
     GHC.Int.$fBitsInt32_$cshiftL_closure:
         const GHC.Int.$fBitsInt32_$cshiftL_info;
 },
 GHC.Int.$fBitsInt32_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4sTK,
                       label: GHC.Int.$fBitsInt32_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sTK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sTO; else goto c4sTP;
       c4sTO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sTP: // global
           I64[Sp - 16] = block_c4sTH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sUc; else goto c4sTI;
       u4sUc: // global
           call _c4sTH(R1) args: 0, res: 0, upd: 0;
       c4sTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sTH() //  [R1]
         { info_tbl: [(c4sTH,
                       label: block_c4sTH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sTH: // global
           I64[Sp] = block_c4sTN_info;
           _s4l4E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4E::I64;
           if (R1 & 7 != 0) goto u4sUb; else goto c4sTR;
       u4sUb: // global
           call _c4sTN(R1) args: 0, res: 0, upd: 0;
       c4sTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sTN() //  [R1]
         { info_tbl: [(c4sTN,
                       label: block_c4sTN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sTN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sTX; else goto c4sTW;
       c4sTX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sTW: // global
           _s4l4G::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l4G::I64, 64)) goto c4sU9; else goto c4sUa;
       c4sU9: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << _s4l4G::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sUa: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.316881507 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cisSigned_closure" {
     GHC.Int.$fBitsInt32_$cisSigned_closure:
         const GHC.Int.$fBitsInt32_$cisSigned_info;
 },
 GHC.Int.$fBitsInt32_$cisSigned_entry() //  []
         { info_tbl: [(c4sUy,
                       label: GHC.Int.$fBitsInt32_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sUy: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.321398429 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotate_closure" {
     GHC.Int.$fBitsInt32_$crotate_closure:
         const GHC.Int.$fBitsInt32_$crotate_info;
 },
 GHC.Int.$fBitsInt32_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4sUN,
                       label: GHC.Int.$fBitsInt32_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sUN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sUR; else goto c4sUS;
       c4sUR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sUS: // global
           I64[Sp - 16] = block_c4sUK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sVO; else goto c4sUL;
       u4sVO: // global
           call _c4sUK(R1) args: 0, res: 0, upd: 0;
       c4sUL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sUK() //  [R1]
         { info_tbl: [(c4sUK,
                       label: block_c4sUK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sUK: // global
           I64[Sp - 8] = block_c4sUQ_info;
           _s4l4N::P64 = R1;
           _s4l4O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l4O::I64;
           P64[Sp + 8] = _s4l4N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sVN; else goto c4sUU;
       u4sVN: // global
           call _c4sUQ(R1) args: 0, res: 0, upd: 0;
       c4sUU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sUQ() //  [R1]
         { info_tbl: [(c4sUQ,
                       label: block_c4sUQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sUQ: // global
           _s4l4T::I64 = I64[R1 + 7] & 31;
           if (_s4l4T::I64 != 0) goto u4sVL; else goto c4sVH;
       u4sVL: // global
           I64[Sp + 16] = _s4l4T::I64;
           Sp = Sp + 8;
           call _c4sV9() args: 0, res: 0, upd: 0;
       c4sVH: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4sV9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sV9: // global
           Hp = Hp + 16;
           _s4l4T::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4sVE; else goto c4sVD;
       c4sVE: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4sV8_info;
           R1 = _s4l4T::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4sVD: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4l4U::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4l4U::I64 << _s4l4T::I64) | (_s4l4U::I64 >> 32 - _s4l4T::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4sV8() //  [R1]
         { info_tbl: [(c4sV8,
                       label: block_c4sV8_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sV8: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4sV9() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.333507701 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshift_closure" {
     GHC.Int.$fBitsInt32_$cshift_closure:
         const GHC.Int.$fBitsInt32_$cshift_info;
 },
 GHC.Int.$fBitsInt32_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4sWr,
                       label: GHC.Int.$fBitsInt32_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sWr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sWv; else goto c4sWw;
       c4sWv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sWw: // global
           I64[Sp - 16] = block_c4sWo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sXj; else goto c4sWp;
       u4sXj: // global
           call _c4sWo(R1) args: 0, res: 0, upd: 0;
       c4sWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sWo() //  [R1]
         { info_tbl: [(c4sWo,
                       label: block_c4sWo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sWo: // global
           I64[Sp] = block_c4sWu_info;
           _s4l55::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l55::I64;
           if (R1 & 7 != 0) goto u4sXi; else goto c4sWy;
       u4sXi: // global
           call _c4sWu(R1) args: 0, res: 0, upd: 0;
       c4sWy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sWu() //  [R1]
         { info_tbl: [(c4sWu,
                       label: block_c4sWu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sWu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sWE; else goto c4sWD;
       c4sWE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sWD: // global
           _s4l55::I64 = I64[Sp + 8];
           _s4l57::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l57::I64, 0)) goto c4sX2; else goto c4sXh;
       c4sX2: // global
           _s4l59::I64 = -_s4l57::I64;
           if (%MO_S_Lt_W64(_s4l59::I64, 64)) goto c4sWT; else goto c4sX0;
       c4sWT: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l55::I64, _s4l59::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sX0: // global
           if (%MO_S_Ge_W64(_s4l55::I64, 0)) goto c4sXg; else goto c4sWZ;
       c4sWZ: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sXh: // global
           if (%MO_S_Ge_W64(_s4l57::I64, 64)) goto c4sXg; else goto c4sXf;
       c4sXg: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sXf: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4l55::I64 << _s4l57::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.342880106 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplement_closure" {
     GHC.Int.$fBitsInt32_$ccomplement_closure:
         const GHC.Int.$fBitsInt32_$ccomplement_info;
 },
 GHC.Int.$fBitsInt32_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4sXL,
                       label: GHC.Int.$fBitsInt32_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sXL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sXY; else goto c4sXZ;
       c4sXY: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sXZ: // global
           I64[Sp - 8] = block_c4sXI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sY3; else goto c4sXJ;
       u4sY3: // global
           call _c4sXI(R1) args: 0, res: 0, upd: 0;
       c4sXJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sXI() //  [R1]
         { info_tbl: [(c4sXI,
                       label: block_c4sXI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sXI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sY2; else goto c4sY1;
       c4sY2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sY1: // global
           _s4l5l::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.349590504 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cxor_closure" {
     GHC.Int.$fBitsInt32_$cxor_closure:
         const GHC.Int.$fBitsInt32_$cxor_info;
 },
 GHC.Int.$fBitsInt32_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4sYl,
                       label: GHC.Int.$fBitsInt32_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sYl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sYG; else goto c4sYH;
       c4sYG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sYH: // global
           I64[Sp - 16] = block_c4sYi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sYN; else goto c4sYj;
       u4sYN: // global
           call _c4sYi(R1) args: 0, res: 0, upd: 0;
       c4sYj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sYi() //  [R1]
         { info_tbl: [(c4sYi,
                       label: block_c4sYi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sYi: // global
           I64[Sp] = block_c4sYo_info;
           _s4l5p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5p::I64;
           if (R1 & 7 != 0) goto u4sYM; else goto c4sYp;
       u4sYM: // global
           call _c4sYo(R1) args: 0, res: 0, upd: 0;
       c4sYp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sYo() //  [R1]
         { info_tbl: [(c4sYo,
                       label: block_c4sYo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sYo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sYL; else goto c4sYK;
       c4sYL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sYK: // global
           _s4l5v::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5v::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.358206116 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.|._closure" {
     GHC.Int.$fBitsInt32_$c.|._closure:
         const GHC.Int.$fBitsInt32_$c.|._info;
 },
 GHC.Int.$fBitsInt32_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4sZb,
                       label: GHC.Int.$fBitsInt32_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sZb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sZw; else goto c4sZx;
       c4sZw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sZx: // global
           I64[Sp - 16] = block_c4sZ8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sZD; else goto c4sZ9;
       u4sZD: // global
           call _c4sZ8(R1) args: 0, res: 0, upd: 0;
       c4sZ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sZ8() //  [R1]
         { info_tbl: [(c4sZ8,
                       label: block_c4sZ8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sZ8: // global
           I64[Sp] = block_c4sZe_info;
           _s4l5z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5z::I64;
           if (R1 & 7 != 0) goto u4sZC; else goto c4sZf;
       u4sZC: // global
           call _c4sZe(R1) args: 0, res: 0, upd: 0;
       c4sZf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sZe() //  [R1]
         { info_tbl: [(c4sZe,
                       label: block_c4sZe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sZe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sZB; else goto c4sZA;
       c4sZB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sZA: // global
           _s4l5F::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5F::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.367218375 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.&._closure" {
     GHC.Int.$fBitsInt32_$c.&._closure:
         const GHC.Int.$fBitsInt32_$c.&._info;
 },
 GHC.Int.$fBitsInt32_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4t01,
                       label: GHC.Int.$fBitsInt32_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t01: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t0m; else goto c4t0n;
       c4t0m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t0n: // global
           I64[Sp - 16] = block_c4sZY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t0t; else goto c4sZZ;
       u4t0t: // global
           call _c4sZY(R1) args: 0, res: 0, upd: 0;
       c4sZZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4sZY() //  [R1]
         { info_tbl: [(c4sZY,
                       label: block_c4sZY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4sZY: // global
           I64[Sp] = block_c4t04_info;
           _s4l5J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5J::I64;
           if (R1 & 7 != 0) goto u4t0s; else goto c4t05;
       u4t0s: // global
           call _c4t04(R1) args: 0, res: 0, upd: 0;
       c4t05: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t04() //  [R1]
         { info_tbl: [(c4t04,
                       label: block_c4t04_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t04: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t0r; else goto c4t0q;
       c4t0r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t0q: // global
           _s4l5P::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5P::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.375568063 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4t0R,
                       label: GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t0R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t15; else goto c4t16;
       c4t15: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t16: // global
           I64[Sp - 8] = block_c4t0O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4t1a; else goto c4t0P;
       u4t1a: // global
           call _c4t0O(R1) args: 0, res: 0, upd: 0;
       c4t0P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t0O() //  [R1]
         { info_tbl: [(c4t0O,
                       label: block_c4t0O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t0O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t19; else goto c4t18;
       c4t19: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t18: // global
           (_c4t0X::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4t0X::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.382626984 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4t1u,
                       label: GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t1u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t1I; else goto c4t1J;
       c4t1I: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t1J: // global
           I64[Sp - 8] = block_c4t1r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4t1N; else goto c4t1s;
       u4t1N: // global
           call _c4t1r(R1) args: 0, res: 0, upd: 0;
       c4t1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t1r() //  [R1]
         { info_tbl: [(c4t1r,
                       label: block_c4t1r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t1r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t1M; else goto c4t1L;
       c4t1M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t1L: // global
           (_c4t1A::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4t1A::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.389022328 UTC

[section ""data" . GHC.Int.$fBitsInt4_closure" {
     GHC.Int.$fBitsInt4_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.391052836 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt32_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt32_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4t25,
                       label: GHC.Int.$fBitsInt32_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t25: // global
           R1 = GHC.Int.$fBitsInt4_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.394955676 UTC

[section ""data" . GHC.Int.$fNumInt64_$cfromInteger_closure" {
     GHC.Int.$fNumInt64_$cfromInteger_closure:
         const GHC.Int.$fNumInt64_$cfromInteger_info;
 },
 GHC.Int.$fNumInt64_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4t2j,
                       label: GHC.Int.$fNumInt64_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t2j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t2n; else goto c4t2o;
       c4t2n: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t2o: // global
           I64[Sp - 8] = block_c4t2h_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4t2h() //  [R1]
         { info_tbl: [(c4t2h,
                       label: block_c4t2h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t2h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t2r; else goto c4t2q;
       c4t2r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4t2q: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.400970801 UTC

[section ""data" . GHC.Int.$fNumInt64_$cnegate_closure" {
     GHC.Int.$fNumInt64_$cnegate_closure:
         const GHC.Int.$fNumInt64_$cnegate_info;
 },
 GHC.Int.$fNumInt64_$cnegate_entry() //  [R2]
         { info_tbl: [(c4t2I,
                       label: GHC.Int.$fNumInt64_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t2I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t2P; else goto c4t2Q;
       c4t2P: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t2Q: // global
           I64[Sp - 8] = block_c4t2F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4t2U; else goto c4t2G;
       u4t2U: // global
           call _c4t2F(R1) args: 0, res: 0, upd: 0;
       c4t2G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t2F() //  [R1]
         { info_tbl: [(c4t2F,
                       label: block_c4t2F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t2F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t2T; else goto c4t2S;
       c4t2T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t2S: // global
           _s4l68::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l68::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.408112565 UTC

[section ""data" . GHC.Int.$fNumInt64_$c*_closure" {
     GHC.Int.$fNumInt64_$c*_closure:
         const GHC.Int.$fNumInt64_$c*_info;
 },
 GHC.Int.$fNumInt64_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4t3c,
                       label: GHC.Int.$fNumInt64_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t3c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t3o; else goto c4t3p;
       c4t3o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t3p: // global
           I64[Sp - 16] = block_c4t39_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t3v; else goto c4t3a;
       u4t3v: // global
           call _c4t39(R1) args: 0, res: 0, upd: 0;
       c4t3a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t39() //  [R1]
         { info_tbl: [(c4t39,
                       label: block_c4t39_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t39: // global
           I64[Sp] = block_c4t3f_info;
           _s4l6c::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6c::I64;
           if (R1 & 7 != 0) goto u4t3u; else goto c4t3g;
       u4t3u: // global
           call _c4t3f(R1) args: 0, res: 0, upd: 0;
       c4t3g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t3f() //  [R1]
         { info_tbl: [(c4t3f,
                       label: block_c4t3f_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t3f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t3t; else goto c4t3s;
       c4t3t: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t3s: // global
           _s4l6f::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6f::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.417683172 UTC

[section ""data" . GHC.Int.$fNumInt64_$c-_closure" {
     GHC.Int.$fNumInt64_$c-_closure:
         const GHC.Int.$fNumInt64_$c-_info;
 },
 GHC.Int.$fNumInt64_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4t3T,
                       label: GHC.Int.$fNumInt64_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t3T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t45; else goto c4t46;
       c4t45: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t46: // global
           I64[Sp - 16] = block_c4t3Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t4c; else goto c4t3R;
       u4t4c: // global
           call _c4t3Q(R1) args: 0, res: 0, upd: 0;
       c4t3R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t3Q() //  [R1]
         { info_tbl: [(c4t3Q,
                       label: block_c4t3Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t3Q: // global
           I64[Sp] = block_c4t3W_info;
           _s4l6j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6j::I64;
           if (R1 & 7 != 0) goto u4t4b; else goto c4t3X;
       u4t4b: // global
           call _c4t3W(R1) args: 0, res: 0, upd: 0;
       c4t3X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t3W() //  [R1]
         { info_tbl: [(c4t3W,
                       label: block_c4t3W_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t3W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t4a; else goto c4t49;
       c4t4a: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t49: // global
           _s4l6m::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6m::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.426929388 UTC

[section ""data" . GHC.Int.$fNumInt64_$c+_closure" {
     GHC.Int.$fNumInt64_$c+_closure:
         const GHC.Int.$fNumInt64_$c+_info;
 },
 GHC.Int.$fNumInt64_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4t4A,
                       label: GHC.Int.$fNumInt64_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t4A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t4M; else goto c4t4N;
       c4t4M: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t4N: // global
           I64[Sp - 16] = block_c4t4x_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t4T; else goto c4t4y;
       u4t4T: // global
           call _c4t4x(R1) args: 0, res: 0, upd: 0;
       c4t4y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t4x() //  [R1]
         { info_tbl: [(c4t4x,
                       label: block_c4t4x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t4x: // global
           I64[Sp] = block_c4t4D_info;
           _s4l6q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6q::I64;
           if (R1 & 7 != 0) goto u4t4S; else goto c4t4E;
       u4t4S: // global
           call _c4t4D(R1) args: 0, res: 0, upd: 0;
       c4t4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t4D() //  [R1]
         { info_tbl: [(c4t4D,
                       label: block_c4t4D_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t4D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t4R; else goto c4t4Q;
       c4t4R: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t4Q: // global
           _s4l6t::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.434604878 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt64_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt64_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt64_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4t5h,
                       label: GHC.Int.$fIntegralInt64_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t5h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t5i; else goto c4t5j;
       c4t5i: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t5j: // global
           I64[Sp - 8] = block_c4t5e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4t5n; else goto c4t5f;
       u4t5n: // global
           call _c4t5e(R1) args: 0, res: 0, upd: 0;
       c4t5f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t5e() //  [R1]
         { info_tbl: [(c4t5e,
                       label: block_c4t5e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t5e: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.440347748 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cpopCount_closure" {
     GHC.Int.$fBitsInt64_$cpopCount_closure:
         const GHC.Int.$fBitsInt64_$cpopCount_info;
 },
 GHC.Int.$fBitsInt64_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4t5E,
                       label: GHC.Int.$fBitsInt64_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t5E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t5S; else goto c4t5T;
       c4t5S: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t5T: // global
           I64[Sp - 8] = block_c4t5B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4t5X; else goto c4t5C;
       u4t5X: // global
           call _c4t5B(R1) args: 0, res: 0, upd: 0;
       c4t5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t5B() //  [R1]
         { info_tbl: [(c4t5B,
                       label: block_c4t5B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t5B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t5W; else goto c4t5V;
       c4t5W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t5V: // global
           (_c4t5K::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4t5K::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.447249795 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4t6f,
                       label: GHC.Int.$fBitsInt64_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t6f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t6r; else goto c4t6s;
       c4t6r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t6s: // global
           I64[Sp - 16] = block_c4t6c_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t6y; else goto c4t6d;
       u4t6y: // global
           call _c4t6c(R1) args: 0, res: 0, upd: 0;
       c4t6d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t6c() //  [R1]
         { info_tbl: [(c4t6c,
                       label: block_c4t6c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t6c: // global
           I64[Sp] = block_c4t6i_info;
           _s4l6G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6G::I64;
           if (R1 & 7 != 0) goto u4t6x; else goto c4t6j;
       u4t6x: // global
           call _c4t6i(R1) args: 0, res: 0, upd: 0;
       c4t6j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t6i() //  [R1]
         { info_tbl: [(c4t6i,
                       label: block_c4t6i_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t6i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t6w; else goto c4t6v;
       c4t6w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t6v: // global
           _s4l6J::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6J::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.455959677 UTC

[section ""data" . GHC.Int.$fBitsInt10_closure" {
     GHC.Int.$fBitsInt10_closure:
         const GHC.Int.I64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.458868993 UTC

[section ""data" . GHC.Int.$fNumInt6_closure" {
     GHC.Int.$fNumInt6_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.462592858 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftR_closure" {
     GHC.Int.$fBitsInt64_$cshiftR_closure:
         const GHC.Int.$fBitsInt64_$cshiftR_info;
 },
 GHC.Int.$fBitsInt64_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4t6X,
                       label: GHC.Int.$fBitsInt64_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t6X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t71; else goto c4t72;
       c4t71: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t72: // global
           I64[Sp - 16] = block_c4t6U_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t7s; else goto c4t6V;
       u4t7s: // global
           call _c4t6U(R1) args: 0, res: 0, upd: 0;
       c4t6V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t6U() //  [R1]
         { info_tbl: [(c4t6U,
                       label: block_c4t6U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t6U: // global
           I64[Sp] = block_c4t70_info;
           _s4l6N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6N::I64;
           if (R1 & 7 != 0) goto u4t7r; else goto c4t74;
       u4t7r: // global
           call _c4t70(R1) args: 0, res: 0, upd: 0;
       c4t74: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t70() //  [R1]
         { info_tbl: [(c4t70,
                       label: block_c4t70_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t70: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t7a; else goto c4t79;
       c4t7a: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t79: // global
           _s4l6N::I64 = I64[Sp + 8];
           _s4l6P::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l6P::I64, 64)) goto c4t7j; else goto c4t7q;
       c4t7j: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l6N::I64, _s4l6P::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4t7q: // global
           if (%MO_S_Ge_W64(_s4l6N::I64, 0)) goto c4t7o; else goto c4t7p;
       c4t7o: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4t7p: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.476523057 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4t7R,
                       label: GHC.Int.$fBitsInt64_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t7R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t83; else goto c4t84;
       c4t83: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t84: // global
           I64[Sp - 16] = block_c4t7O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t8a; else goto c4t7P;
       u4t8a: // global
           call _c4t7O(R1) args: 0, res: 0, upd: 0;
       c4t7P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t7O() //  [R1]
         { info_tbl: [(c4t7O,
                       label: block_c4t7O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t7O: // global
           I64[Sp] = block_c4t7U_info;
           _s4l6W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6W::I64;
           if (R1 & 7 != 0) goto u4t89; else goto c4t7V;
       u4t89: // global
           call _c4t7U(R1) args: 0, res: 0, upd: 0;
       c4t7V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t7U() //  [R1]
         { info_tbl: [(c4t7U,
                       label: block_c4t7U_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t7U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t88; else goto c4t87;
       c4t88: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t87: // global
           _s4l6Z::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6Z::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.489234021 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftL_closure" {
     GHC.Int.$fBitsInt64_$cshiftL_closure:
         const GHC.Int.$fBitsInt64_$cshiftL_info;
 },
 GHC.Int.$fBitsInt64_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4t8x,
                       label: GHC.Int.$fBitsInt64_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t8x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t8B; else goto c4t8C;
       c4t8B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t8C: // global
           I64[Sp - 16] = block_c4t8u_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t8W; else goto c4t8v;
       u4t8W: // global
           call _c4t8u(R1) args: 0, res: 0, upd: 0;
       c4t8v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t8u() //  [R1]
         { info_tbl: [(c4t8u,
                       label: block_c4t8u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t8u: // global
           I64[Sp] = block_c4t8A_info;
           _s4l73::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l73::I64;
           if (R1 & 7 != 0) goto u4t8V; else goto c4t8E;
       u4t8V: // global
           call _c4t8A(R1) args: 0, res: 0, upd: 0;
       c4t8E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t8A() //  [R1]
         { info_tbl: [(c4t8A,
                       label: block_c4t8A_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t8A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t8K; else goto c4t8J;
       c4t8K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t8J: // global
           _s4l75::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l75::I64, 64)) goto c4t8T; else goto c4t8U;
       c4t8T: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s4l75::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4t8U: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.503313532 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cisSigned_closure" {
     GHC.Int.$fBitsInt64_$cisSigned_closure:
         const GHC.Int.$fBitsInt64_$cisSigned_info;
 },
 GHC.Int.$fBitsInt64_$cisSigned_entry() //  []
         { info_tbl: [(c4t9h,
                       label: GHC.Int.$fBitsInt64_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t9h: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.509882203 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotate_closure" {
     GHC.Int.$fBitsInt64_$crotate_closure:
         const GHC.Int.$fBitsInt64_$crotate_info;
 },
 GHC.Int.$fBitsInt64_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4t9w,
                       label: GHC.Int.$fBitsInt64_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t9w: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4t9A; else goto c4t9B;
       c4t9A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t9B: // global
           I64[Sp - 16] = block_c4t9t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tar; else goto c4t9u;
       u4tar: // global
           call _c4t9t(R1) args: 0, res: 0, upd: 0;
       c4t9u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t9t() //  [R1]
         { info_tbl: [(c4t9t,
                       label: block_c4t9t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t9t: // global
           I64[Sp - 8] = block_c4t9z_info;
           _s4l7b::P64 = R1;
           _s4l7c::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l7c::I64;
           P64[Sp + 8] = _s4l7b::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4taq; else goto c4t9D;
       u4taq: // global
           call _c4t9z(R1) args: 0, res: 0, upd: 0;
       c4t9D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4t9z() //  [R1]
         { info_tbl: [(c4t9z,
                       label: block_c4t9z_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t9z: // global
           _s4l7h::I64 = I64[R1 + 7] & 63;
           if (_s4l7h::I64 != 0) goto u4tao; else goto c4tak;
       u4tao: // global
           I64[Sp + 16] = _s4l7h::I64;
           Sp = Sp + 8;
           call _c4t9S() args: 0, res: 0, upd: 0;
       c4tak: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4t9S() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t9S: // global
           Hp = Hp + 16;
           _s4l7h::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4tah; else goto c4tag;
       c4tah: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4t9R_info;
           R1 = _s4l7h::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4tag: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4l7i::I64 = I64[Sp];
           I64[Hp] = (_s4l7i::I64 << _s4l7h::I64) | (_s4l7i::I64 >> 64 - _s4l7h::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4t9R() //  [R1]
         { info_tbl: [(c4t9R,
                       label: block_c4t9R_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4t9R: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4t9S() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.527469138 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshift_closure" {
     GHC.Int.$fBitsInt64_$cshift_closure:
         const GHC.Int.$fBitsInt64_$cshift_info;
 },
 GHC.Int.$fBitsInt64_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4tb2,
                       label: GHC.Int.$fBitsInt64_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tb2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tb6; else goto c4tb7;
       c4tb6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tb7: // global
           I64[Sp - 16] = block_c4taZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tbR; else goto c4tb0;
       u4tbR: // global
           call _c4taZ(R1) args: 0, res: 0, upd: 0;
       c4tb0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4taZ() //  [R1]
         { info_tbl: [(c4taZ,
                       label: block_c4taZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4taZ: // global
           I64[Sp] = block_c4tb5_info;
           _s4l7r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7r::I64;
           if (R1 & 7 != 0) goto u4tbQ; else goto c4tb9;
       u4tbQ: // global
           call _c4tb5(R1) args: 0, res: 0, upd: 0;
       c4tb9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tb5() //  [R1]
         { info_tbl: [(c4tb5,
                       label: block_c4tb5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tb5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tbf; else goto c4tbe;
       c4tbf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tbe: // global
           _s4l7r::I64 = I64[Sp + 8];
           _s4l7t::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l7t::I64, 0)) goto c4tbD; else goto c4tbP;
       c4tbD: // global
           _s4l7v::I64 = -_s4l7t::I64;
           if (%MO_S_Lt_W64(_s4l7v::I64, 64)) goto c4tbu; else goto c4tbB;
       c4tbu: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l7r::I64, _s4l7v::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tbB: // global
           if (%MO_S_Ge_W64(_s4l7r::I64, 0)) goto c4tbO; else goto c4tbA;
       c4tbA: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tbP: // global
           if (%MO_S_Ge_W64(_s4l7t::I64, 64)) goto c4tbO; else goto c4tbN;
       c4tbO: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tbN: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7r::I64 << _s4l7t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.541591324 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplement_closure" {
     GHC.Int.$fBitsInt64_$ccomplement_closure:
         const GHC.Int.$fBitsInt64_$ccomplement_info;
 },
 GHC.Int.$fBitsInt64_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4tci,
                       label: GHC.Int.$fBitsInt64_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tci: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tcv; else goto c4tcw;
       c4tcv: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tcw: // global
           I64[Sp - 8] = block_c4tcf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tcA; else goto c4tcg;
       u4tcA: // global
           call _c4tcf(R1) args: 0, res: 0, upd: 0;
       c4tcg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tcf() //  [R1]
         { info_tbl: [(c4tcf,
                       label: block_c4tcf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tcf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tcz; else goto c4tcy;
       c4tcz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tcy: // global
           _s4l7G::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7G::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.551642149 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cxor_closure" {
     GHC.Int.$fBitsInt64_$cxor_closure:
         const GHC.Int.$fBitsInt64_$cxor_info;
 },
 GHC.Int.$fBitsInt64_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4tcT,
                       label: GHC.Int.$fBitsInt64_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tcT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tde; else goto c4tdf;
       c4tde: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tdf: // global
           I64[Sp - 16] = block_c4tcQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tdl; else goto c4tcR;
       u4tdl: // global
           call _c4tcQ(R1) args: 0, res: 0, upd: 0;
       c4tcR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tcQ() //  [R1]
         { info_tbl: [(c4tcQ,
                       label: block_c4tcQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tcQ: // global
           I64[Sp] = block_c4tcW_info;
           _s4l7K::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7K::I64;
           if (R1 & 7 != 0) goto u4tdk; else goto c4tcX;
       u4tdk: // global
           call _c4tcW(R1) args: 0, res: 0, upd: 0;
       c4tcX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tcW() //  [R1]
         { info_tbl: [(c4tcW,
                       label: block_c4tcW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tcW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tdj; else goto c4tdi;
       c4tdj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tdi: // global
           _s4l7Q::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7Q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.564116615 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.|._closure" {
     GHC.Int.$fBitsInt64_$c.|._closure:
         const GHC.Int.$fBitsInt64_$c.|._info;
 },
 GHC.Int.$fBitsInt64_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4tdJ,
                       label: GHC.Int.$fBitsInt64_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tdJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4te4; else goto c4te5;
       c4te4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4te5: // global
           I64[Sp - 16] = block_c4tdG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4teb; else goto c4tdH;
       u4teb: // global
           call _c4tdG(R1) args: 0, res: 0, upd: 0;
       c4tdH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tdG() //  [R1]
         { info_tbl: [(c4tdG,
                       label: block_c4tdG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tdG: // global
           I64[Sp] = block_c4tdM_info;
           _s4l7U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7U::I64;
           if (R1 & 7 != 0) goto u4tea; else goto c4tdN;
       u4tea: // global
           call _c4tdM(R1) args: 0, res: 0, upd: 0;
       c4tdN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tdM() //  [R1]
         { info_tbl: [(c4tdM,
                       label: block_c4tdM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tdM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4te9; else goto c4te8;
       c4te9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4te8: // global
           _s4l80::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l80::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.574047929 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.&._closure" {
     GHC.Int.$fBitsInt64_$c.&._closure:
         const GHC.Int.$fBitsInt64_$c.&._info;
 },
 GHC.Int.$fBitsInt64_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4tez,
                       label: GHC.Int.$fBitsInt64_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tez: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4teU; else goto c4teV;
       c4teU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4teV: // global
           I64[Sp - 16] = block_c4tew_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tf1; else goto c4tex;
       u4tf1: // global
           call _c4tew(R1) args: 0, res: 0, upd: 0;
       c4tex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tew() //  [R1]
         { info_tbl: [(c4tew,
                       label: block_c4tew_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tew: // global
           I64[Sp] = block_c4teC_info;
           _s4l84::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l84::I64;
           if (R1 & 7 != 0) goto u4tf0; else goto c4teD;
       u4tf0: // global
           call _c4teC(R1) args: 0, res: 0, upd: 0;
       c4teD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4teC() //  [R1]
         { info_tbl: [(c4teC,
                       label: block_c4teC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4teC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4teZ; else goto c4teY;
       c4teZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4teY: // global
           _s4l8a::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l8a::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.584959378 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4tfp,
                       label: GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tfp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tfD; else goto c4tfE;
       c4tfD: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tfE: // global
           I64[Sp - 8] = block_c4tfm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tfI; else goto c4tfn;
       u4tfI: // global
           call _c4tfm(R1) args: 0, res: 0, upd: 0;
       c4tfn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tfm() //  [R1]
         { info_tbl: [(c4tfm,
                       label: block_c4tfm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tfm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tfH; else goto c4tfG;
       c4tfH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tfG: // global
           (_c4tfv::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4tfv::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.591444135 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4tg2,
                       label: GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tg2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tgg; else goto c4tgh;
       c4tgg: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tgh: // global
           I64[Sp - 8] = block_c4tfZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tgl; else goto c4tg0;
       u4tgl: // global
           call _c4tfZ(R1) args: 0, res: 0, upd: 0;
       c4tg0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tfZ() //  [R1]
         { info_tbl: [(c4tfZ,
                       label: block_c4tfZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tfZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tgk; else goto c4tgj;
       c4tgk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tgj: // global
           (_c4tg8::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4tg8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.597748528 UTC

[section ""data" . GHC.Int.$fBitsInt7_closure" {
     GHC.Int.$fBitsInt7_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.600021127 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt64_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt64_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4tgD,
                       label: GHC.Int.$fBitsInt64_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tgD: // global
           R1 = GHC.Int.$fBitsInt7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.605217134 UTC

[section ""data" . GHC.Int.eqInt8_closure" {
     GHC.Int.eqInt8_closure:
         const GHC.Int.eqInt8_info;
 },
 GHC.Int.eqInt8_entry() //  [R2, R3]
         { info_tbl: [(c4tgS,
                       label: GHC.Int.eqInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tgS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tgW; else goto c4tgX;
       c4tgW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tgX: // global
           I64[Sp - 16] = block_c4tgP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4th6; else goto c4tgQ;
       u4th6: // global
           call _c4tgP(R1) args: 0, res: 0, upd: 0;
       c4tgQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tgP() //  [R1]
         { info_tbl: [(c4tgP,
                       label: block_c4tgP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tgP: // global
           I64[Sp] = block_c4tgV_info;
           _s4l8r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8r::I64;
           if (R1 & 7 != 0) goto u4th5; else goto c4tgZ;
       u4th5: // global
           call _c4tgV(R1) args: 0, res: 0, upd: 0;
       c4tgZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tgV() //  [R1]
         { info_tbl: [(c4tgV,
                       label: block_c4tgV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tgV: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.613226344 UTC

[section ""data" . GHC.Int.$fEqInt8_closure" {
     GHC.Int.$fEqInt8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt8_closure+2;
         const GHC.Int.neInt8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.615606306 UTC

[section ""data" . GHC.Int.gtInt8_closure" {
     GHC.Int.gtInt8_closure:
         const GHC.Int.gtInt8_info;
 },
 GHC.Int.gtInt8_entry() //  [R2, R3]
         { info_tbl: [(c4thw,
                       label: GHC.Int.gtInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4thw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4thA; else goto c4thB;
       c4thA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4thB: // global
           I64[Sp - 16] = block_c4tht_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4thK; else goto c4thu;
       u4thK: // global
           call _c4tht(R1) args: 0, res: 0, upd: 0;
       c4thu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tht() //  [R1]
         { info_tbl: [(c4tht,
                       label: block_c4tht_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tht: // global
           I64[Sp] = block_c4thz_info;
           _s4l8y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8y::I64;
           if (R1 & 7 != 0) goto u4thJ; else goto c4thD;
       u4thJ: // global
           call _c4thz(R1) args: 0, res: 0, upd: 0;
       c4thD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4thz() //  [R1]
         { info_tbl: [(c4thz,
                       label: block_c4thz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4thz: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.625374314 UTC

[section ""data" . GHC.Int.geInt8_closure" {
     GHC.Int.geInt8_closure:
         const GHC.Int.geInt8_info;
 },
 GHC.Int.geInt8_entry() //  [R2, R3]
         { info_tbl: [(c4ti9,
                       label: GHC.Int.geInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ti9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tid; else goto c4tie;
       c4tid: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tie: // global
           I64[Sp - 16] = block_c4ti6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tin; else goto c4ti7;
       u4tin: // global
           call _c4ti6(R1) args: 0, res: 0, upd: 0;
       c4ti7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ti6() //  [R1]
         { info_tbl: [(c4ti6,
                       label: block_c4ti6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ti6: // global
           I64[Sp] = block_c4tic_info;
           _s4l8F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8F::I64;
           if (R1 & 7 != 0) goto u4tim; else goto c4tig;
       u4tim: // global
           call _c4tic(R1) args: 0, res: 0, upd: 0;
       c4tig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tic() //  [R1]
         { info_tbl: [(c4tic,
                       label: block_c4tic_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tic: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.636666423 UTC

[section ""data" . GHC.Int.ltInt8_closure" {
     GHC.Int.ltInt8_closure:
         const GHC.Int.ltInt8_info;
 },
 GHC.Int.ltInt8_entry() //  [R2, R3]
         { info_tbl: [(c4tiM,
                       label: GHC.Int.ltInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tiM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tiQ; else goto c4tiR;
       c4tiQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tiR: // global
           I64[Sp - 16] = block_c4tiJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tj0; else goto c4tiK;
       u4tj0: // global
           call _c4tiJ(R1) args: 0, res: 0, upd: 0;
       c4tiK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tiJ() //  [R1]
         { info_tbl: [(c4tiJ,
                       label: block_c4tiJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tiJ: // global
           I64[Sp] = block_c4tiP_info;
           _s4l8M::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8M::I64;
           if (R1 & 7 != 0) goto u4tiZ; else goto c4tiT;
       u4tiZ: // global
           call _c4tiP(R1) args: 0, res: 0, upd: 0;
       c4tiT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tiP() //  [R1]
         { info_tbl: [(c4tiP,
                       label: block_c4tiP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tiP: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.648981214 UTC

[section ""data" . GHC.Int.leInt8_closure" {
     GHC.Int.leInt8_closure:
         const GHC.Int.leInt8_info;
 },
 GHC.Int.leInt8_entry() //  [R2, R3]
         { info_tbl: [(c4tjp,
                       label: GHC.Int.leInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tjp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tjt; else goto c4tju;
       c4tjt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tju: // global
           I64[Sp - 16] = block_c4tjm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tjD; else goto c4tjn;
       u4tjD: // global
           call _c4tjm(R1) args: 0, res: 0, upd: 0;
       c4tjn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tjm() //  [R1]
         { info_tbl: [(c4tjm,
                       label: block_c4tjm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tjm: // global
           I64[Sp] = block_c4tjs_info;
           _s4l8T::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8T::I64;
           if (R1 & 7 != 0) goto u4tjC; else goto c4tjw;
       u4tjC: // global
           call _c4tjs(R1) args: 0, res: 0, upd: 0;
       c4tjw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tjs() //  [R1]
         { info_tbl: [(c4tjs,
                       label: block_c4tjs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tjs: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.660053131 UTC

[section ""data" . GHC.Int.$fOrdInt8_$ccompare_closure" {
     GHC.Int.$fOrdInt8_$ccompare_closure:
         const GHC.Int.$fOrdInt8_$ccompare_info;
 },
 GHC.Int.$fOrdInt8_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4tk2,
                       label: GHC.Int.$fOrdInt8_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tk2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tk6; else goto c4tk7;
       c4tk6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tk7: // global
           I64[Sp - 16] = block_c4tjZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tkq; else goto c4tk0;
       u4tkq: // global
           call _c4tjZ(R1) args: 0, res: 0, upd: 0;
       c4tk0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tjZ() //  [R1]
         { info_tbl: [(c4tjZ,
                       label: block_c4tjZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tjZ: // global
           I64[Sp] = block_c4tk5_info;
           _s4l90::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l90::I64;
           if (R1 & 7 != 0) goto u4tkp; else goto c4tk9;
       u4tkp: // global
           call _c4tk5(R1) args: 0, res: 0, upd: 0;
       c4tk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tk5() //  [R1]
         { info_tbl: [(c4tk5,
                       label: block_c4tk5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tk5: // global
           _s4l90::I64 = I64[Sp + 8];
           _s4l92::I64 = I64[R1 + 7];
           if (_s4l90::I64 == _s4l92::I64) goto c4tko; else goto c4tkn;
       c4tko: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tkn: // global
           if (%MO_S_Gt_W64(_s4l90::I64,
                            _s4l92::I64)) goto c4tkk; else goto c4tkl;
       c4tkk: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tkl: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.670112019 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmax_closure" {
     GHC.Int.$fOrdInt8_$cmax_closure:
         const GHC.Int.$fOrdInt8_$cmax_info;
 },
 GHC.Int.$fOrdInt8_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4tkO,
                       label: GHC.Int.$fOrdInt8_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tkO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tkS; else goto c4tkT;
       c4tkS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tkT: // global
           I64[Sp - 16] = block_c4tkL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tl6; else goto c4tkM;
       u4tl6: // global
           call _c4tkL(R1) args: 0, res: 0, upd: 0;
       c4tkM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tkL() //  [R1]
         { info_tbl: [(c4tkL,
                       label: block_c4tkL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tkL: // global
           I64[Sp - 8] = block_c4tkR_info;
           _s4l97::P64 = R1;
           _s4l98::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l98::I64;
           P64[Sp + 8] = _s4l97::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tl5; else goto c4tkV;
       u4tl5: // global
           call _c4tkR(R1) args: 0, res: 0, upd: 0;
       c4tkV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tkR() //  [R1]
         { info_tbl: [(c4tkR,
                       label: block_c4tkR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tkR: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4tl3; else goto c4tl4;
       c4tl3: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tl4: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.679589098 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmin_closure" {
     GHC.Int.$fOrdInt8_$cmin_closure:
         const GHC.Int.$fOrdInt8_$cmin_info;
 },
 GHC.Int.$fOrdInt8_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4tlw,
                       label: GHC.Int.$fOrdInt8_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tlw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tlA; else goto c4tlB;
       c4tlA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tlB: // global
           I64[Sp - 16] = block_c4tlt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tlO; else goto c4tlu;
       u4tlO: // global
           call _c4tlt(R1) args: 0, res: 0, upd: 0;
       c4tlu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tlt() //  [R1]
         { info_tbl: [(c4tlt,
                       label: block_c4tlt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tlt: // global
           I64[Sp - 8] = block_c4tlz_info;
           _s4l9e::P64 = R1;
           _s4l9f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l9f::I64;
           P64[Sp + 8] = _s4l9e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tlN; else goto c4tlD;
       u4tlN: // global
           call _c4tlz(R1) args: 0, res: 0, upd: 0;
       c4tlD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tlz() //  [R1]
         { info_tbl: [(c4tlz,
                       label: block_c4tlz_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tlz: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4tlL; else goto c4tlM;
       c4tlL: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tlM: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.687562105 UTC

[section ""data" . GHC.Int.$fOrdInt8_closure" {
     GHC.Int.$fOrdInt8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fOrdInt8_$ccompare_closure+2;
         const GHC.Int.ltInt8_closure+2;
         const GHC.Int.leInt8_closure+2;
         const GHC.Int.gtInt8_closure+2;
         const GHC.Int.geInt8_closure+2;
         const GHC.Int.$fOrdInt8_$cmax_closure+2;
         const GHC.Int.$fOrdInt8_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.690225761 UTC

[section ""data" . GHC.Int.$fIxInt8_$cinRange_closure" {
     GHC.Int.$fIxInt8_$cinRange_closure:
         const GHC.Int.$fIxInt8_$cinRange_info;
 },
 GHC.Int.$fIxInt8_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4tmf,
                       label: GHC.Int.$fIxInt8_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tmf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tmo; else goto c4tmp;
       c4tmo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tmp: // global
           I64[Sp - 16] = block_c4tmc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tmM; else goto c4tmd;
       u4tmM: // global
           call _c4tmc(R1) args: 0, res: 0, upd: 0;
       c4tmd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tmc() //  [R1]
         { info_tbl: [(c4tmc,
                       label: block_c4tmc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tmc: // global
           I64[Sp - 8] = block_c4tmi_info;
           _s4l9n::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4l9n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tmL; else goto c4tmj;
       u4tmL: // global
           call _c4tmi(R1) args: 0, res: 0, upd: 0;
       c4tmj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tmi() //  [R1]
         { info_tbl: [(c4tmi,
                       label: block_c4tmi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tmi: // global
           I64[Sp] = block_c4tmn_info;
           _s4l9p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4l9p::I64;
           if (R1 & 7 != 0) goto u4tmN; else goto c4tms;
       u4tmN: // global
           call _c4tmn(R1) args: 0, res: 0, upd: 0;
       c4tms: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tmn() //  [R1]
         { info_tbl: [(c4tmn,
                       label: block_c4tmn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tmn: // global
           _s4l9r::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4l9r::I64)) goto c4tmA; else goto c4tmE;
       c4tmA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tmE: // global
           _s4l9n::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4tmD_info;
           R1 = _s4l9n::P64;
           I64[Sp + 16] = _s4l9r::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4tmO; else goto c4tmF;
       u4tmO: // global
           call _c4tmD(R1) args: 0, res: 0, upd: 0;
       c4tmF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tmD() //  [R1]
         { info_tbl: [(c4tmD,
                       label: block_c4tmD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tmD: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.70264702 UTC

[section ""data" . GHC.Int.$fNumInt7_closure" {
     GHC.Int.$fNumInt7_closure:
         const GHC.Int.I8#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.705069813 UTC

[section ""data" . GHC.Int.$fNumInt8_$csignum_closure" {
     GHC.Int.$fNumInt8_$csignum_closure:
         const GHC.Int.$fNumInt8_$csignum_info;
 },
 GHC.Int.$fNumInt8_$csignum_entry() //  [R2]
         { info_tbl: [(c4tnn,
                       label: GHC.Int.$fNumInt8_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tnn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tno; else goto c4tnp;
       c4tno: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tnp: // global
           I64[Sp - 8] = block_c4tnk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tnD; else goto c4tnl;
       u4tnD: // global
           call _c4tnk(R1) args: 0, res: 0, upd: 0;
       c4tnl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tnk() //  [R1]
         { info_tbl: [(c4tnk,
                       label: block_c4tnk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tnk: // global
           _s4l9y::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4l9y::I64, 0)) goto c4tnB; else goto c4tnC;
       c4tnB: // global
           if (_s4l9y::I64 == 0) goto c4tnz; else goto c4tny;
       c4tnz: // global
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tny: // global
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tnC: // global
           R1 = GHC.Int.$fNumInt7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.712647765 UTC

[section ""data" . GHC.Int.$fNumInt8_$cabs_closure" {
     GHC.Int.$fNumInt8_$cabs_closure:
         const GHC.Int.$fNumInt8_$cabs_info;
 },
 GHC.Int.$fNumInt8_$cabs_entry() //  [R2]
         { info_tbl: [(c4tnX,
                       label: GHC.Int.$fNumInt8_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tnX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tnY; else goto c4tnZ;
       c4tnY: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tnZ: // global
           I64[Sp - 8] = block_c4tnU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4toi; else goto c4tnV;
       u4toi: // global
           call _c4tnU(R1) args: 0, res: 0, upd: 0;
       c4tnV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tnU() //  [R1]
         { info_tbl: [(c4tnU,
                       label: block_c4tnU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tnU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4to4; else goto c4to3;
       c4to4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4to3: // global
           _s4l9D::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l9D::I64, 0)) goto c4tog; else goto c4toh;
       c4tog: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-_s4l9D::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4toh: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.719541778 UTC

[section ""data" . GHC.Int.$fNumInt8_closure" {
     GHC.Int.$fNumInt8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt8_$c+_closure+2;
         const GHC.Int.$fNumInt8_$c-_closure+2;
         const GHC.Int.$fNumInt8_$c*_closure+2;
         const GHC.Int.$fNumInt8_$cnegate_closure+1;
         const GHC.Int.$fNumInt8_$cabs_closure+1;
         const GHC.Int.$fNumInt8_$csignum_closure+1;
         const GHC.Int.$fNumInt8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.721674084 UTC

[section ""data" . GHC.Int.$fBitsInt12_closure" {
     GHC.Int.$fBitsInt12_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt11_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.723709588 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt8_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4toD,
                       label: GHC.Int.$fBitsInt8_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4toD: // global
           R1 = GHC.Int.$fBitsInt12_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.729778223 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbit_closure" {
     GHC.Int.$fBitsInt8_$cbit_closure:
         const GHC.Int.$fBitsInt8_$cbit_info;
 },
 GHC.Int.$fBitsInt8_$cbit_entry() //  [R2]
         { info_tbl: [(c4toS,
                       label: GHC.Int.$fBitsInt8_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4toS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4toT; else goto c4toU;
       c4toT: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4toU: // global
           I64[Sp - 8] = block_c4toP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tpd; else goto c4toQ;
       u4tpd: // global
           call _c4toP(R1) args: 0, res: 0, upd: 0;
       c4toQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4toP() //  [R1]
         { info_tbl: [(c4toP,
                       label: block_c4toP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4toP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4toZ; else goto c4toY;
       c4toZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4toY: // global
           _s4l9K::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l9K::I64, 64)) goto c4tpb; else goto c4tpc;
       c4tpb: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4l9K::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tpc: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.740603691 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ctestBit_closure" {
     GHC.Int.$fBitsInt8_$ctestBit_closure:
         const GHC.Int.$fBitsInt8_$ctestBit_info;
 },
 GHC.Int.$fBitsInt8_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4tpz,
                       label: GHC.Int.$fBitsInt8_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tpz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tpD; else goto c4tpE;
       c4tpD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tpE: // global
           I64[Sp - 16] = block_c4tpw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tqm; else goto c4tpx;
       u4tqm: // global
           call _c4tpw(R1) args: 0, res: 0, upd: 0;
       c4tpx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tpw() //  [R1]
         { info_tbl: [(c4tpw,
                       label: block_c4tpw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tpw: // global
           I64[Sp] = block_c4tpC_info;
           _s4l9R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l9R::I64;
           if (R1 & 7 != 0) goto u4tql; else goto c4tpG;
       u4tql: // global
           call _c4tpC(R1) args: 0, res: 0, upd: 0;
       c4tpG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tpC() //  [R1]
         { info_tbl: [(c4tpC,
                       label: block_c4tpC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tpC: // global
           _s4l9T::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4l9T::I64, 64)) goto c4tqk; else goto c4tqj;
       c4tqj: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4l9T::I64)) == 0) goto c4tqk; else goto c4tq8;
       c4tqk: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tq8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.751183796 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateR_closure" {
     GHC.Int.$fBitsInt8_$crotateR_closure:
         const GHC.Int.$fBitsInt8_$crotateR_info;
 },
 GHC.Int.$fBitsInt8_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4tqO,
                       label: GHC.Int.$fBitsInt8_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tqO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tqS; else goto c4tqT;
       c4tqS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tqT: // global
           I64[Sp - 16] = block_c4tqL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4trS; else goto c4tqM;
       u4trS: // global
           call _c4tqL(R1) args: 0, res: 0, upd: 0;
       c4tqM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tqL() //  [R1]
         { info_tbl: [(c4tqL,
                       label: block_c4tqL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tqL: // global
           I64[Sp - 8] = block_c4tqR_info;
           _s4la3::P64 = R1;
           _s4la4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4la4::I64;
           P64[Sp + 8] = _s4la3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4trR; else goto c4tqV;
       u4trR: // global
           call _c4tqR(R1) args: 0, res: 0, upd: 0;
       c4tqV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tqR() //  [R1]
         { info_tbl: [(c4tqR,
                       label: block_c4tqR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tqR: // global
           _s4laa::I64 = -I64[R1 + 7] & 7;
           if (_s4laa::I64 != 0) goto u4trP; else goto c4trL;
       u4trP: // global
           I64[Sp + 16] = _s4laa::I64;
           Sp = Sp + 8;
           call _c4trd() args: 0, res: 0, upd: 0;
       c4trL: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4trd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4trd: // global
           Hp = Hp + 16;
           _s4laa::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4trI; else goto c4trH;
       c4trI: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4trc_info;
           R1 = _s4laa::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4trH: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4lab::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4lab::I64 << _s4laa::I64) | (_s4lab::I64 >> 8 - _s4laa::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4trc() //  [R1]
         { info_tbl: [(c4trc,
                       label: block_c4trc_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4trc: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4trd() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.765314874 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt8_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt8_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt8_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4tsv,
                       label: GHC.Int.$fBitsInt8_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tsv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tsz; else goto c4tsA;
       c4tsz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tsA: // global
           I64[Sp - 16] = block_c4tss_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tt9; else goto c4tst;
       u4tt9: // global
           call _c4tss(R1) args: 0, res: 0, upd: 0;
       c4tst: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tss() //  [R1]
         { info_tbl: [(c4tss,
                       label: block_c4tss_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tss: // global
           I64[Sp - 8] = block_c4tsy_info;
           _s4lal::P64 = R1;
           _s4lam::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lam::I64;
           P64[Sp + 8] = _s4lal::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tt8; else goto c4tsC;
       u4tt8: // global
           call _c4tsy(R1) args: 0, res: 0, upd: 0;
       c4tsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tsy() //  [R1]
         { info_tbl: [(c4tsy,
                       label: block_c4tsy_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tsy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tsI; else goto c4tsH;
       c4tsI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tsH: // global
           _s4lao::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lao::I64, 64)) goto c4tt6; else goto c4tt7;
       c4tt6: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4lao::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tt7: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.774689472 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cclearBit_closure" {
     GHC.Int.$fBitsInt8_$cclearBit_closure:
         const GHC.Int.$fBitsInt8_$cclearBit_info;
 },
 GHC.Int.$fBitsInt8_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4ttC,
                       label: GHC.Int.$fBitsInt8_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ttC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ttG; else goto c4ttH;
       c4ttG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ttH: // global
           I64[Sp - 16] = block_c4ttz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tuu; else goto c4ttA;
       u4tuu: // global
           call _c4ttz(R1) args: 0, res: 0, upd: 0;
       c4ttA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ttz() //  [R1]
         { info_tbl: [(c4ttz,
                       label: block_c4ttz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ttz: // global
           I64[Sp] = block_c4ttF_info;
           _s4laz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4laz::I64;
           if (R1 & 7 != 0) goto u4tut; else goto c4ttJ;
       u4tut: // global
           call _c4ttF(R1) args: 0, res: 0, upd: 0;
       c4ttJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ttF() //  [R1]
         { info_tbl: [(c4ttF,
                       label: block_c4ttF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ttF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ttP; else goto c4ttO;
       c4ttP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ttO: // global
           _s4laz::I64 = I64[Sp + 8];
           _s4laB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4laB::I64, 64)) goto c4tug; else goto c4tus;
       c4tug: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4laz::I64 & ~%MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4laB::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tus: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4laz::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.785756946 UTC

[section ""data" . GHC.Int.$fBitsInt8_$csetBit_closure" {
     GHC.Int.$fBitsInt8_$csetBit_closure:
         const GHC.Int.$fBitsInt8_$csetBit_info;
 },
 GHC.Int.$fBitsInt8_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4tuY,
                       label: GHC.Int.$fBitsInt8_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tuY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tv2; else goto c4tv3;
       c4tv2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tv3: // global
           I64[Sp - 16] = block_c4tuV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tvC; else goto c4tuW;
       u4tvC: // global
           call _c4tuV(R1) args: 0, res: 0, upd: 0;
       c4tuW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tuV() //  [R1]
         { info_tbl: [(c4tuV,
                       label: block_c4tuV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tuV: // global
           I64[Sp - 8] = block_c4tv1_info;
           _s4laP::P64 = R1;
           _s4laQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4laQ::I64;
           P64[Sp + 8] = _s4laP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tvB; else goto c4tv5;
       u4tvB: // global
           call _c4tv1(R1) args: 0, res: 0, upd: 0;
       c4tv5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tv1() //  [R1]
         { info_tbl: [(c4tv1,
                       label: block_c4tv1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tv1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tvb; else goto c4tva;
       c4tvb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tva: // global
           _s4laS::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4laS::I64, 64)) goto c4tvz; else goto c4tvA;
       c4tvz: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4laS::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tvA: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.794160814 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateL_closure" {
     GHC.Int.$fBitsInt8_$crotateL_closure:
         const GHC.Int.$fBitsInt8_$crotateL_info;
 },
 GHC.Int.$fBitsInt8_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4tw2,
                       label: GHC.Int.$fBitsInt8_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tw2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt8_$crotate_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.797582832 UTC

[section ""data" . GHC.Int.$fBitsInt8_closure" {
     GHC.Int.$fBitsInt8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fBitsInt8_$c.&._closure+2;
         const GHC.Int.$fBitsInt8_$c.|._closure+2;
         const GHC.Int.$fBitsInt8_$cxor_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt8_$cshift_closure+2;
         const GHC.Int.$fBitsInt8_$crotate_closure+2;
         const GHC.Int.$fBitsInt13_closure+1;
         const GHC.Int.$fBitsInt8_$cbit_closure+1;
         const GHC.Int.$fBitsInt8_$csetBit_closure+2;
         const GHC.Int.$fBitsInt8_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt8_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt8_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt8_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt8_$crotateL_closure+2;
         const GHC.Int.$fBitsInt8_$crotateR_closure+2;
         const GHC.Int.$fBitsInt8_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.800363503 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_closure" {
     GHC.Int.$fFiniteBitsInt8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt8_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.803196803 UTC

[section ""data" . GHC.Int.$fReadInt8_go_closure" {
     GHC.Int.$fReadInt8_go_closure:
         const GHC.Int.$fReadInt8_go_info;
 },
 sat_s4lbc_entry() //  [R1]
         { info_tbl: [(c4twu,
                       label: sat_s4lbc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4twu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4twv; else goto c4tww;
       c4twv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4tww: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lba_entry() //  [R1]
         { info_tbl: [(c4twE,
                       label: sat_s4lba_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4twE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4twL; else goto c4twM;
       c4twL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4twM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4twB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4twQ; else goto c4twC;
       u4twQ: // global
           call _c4twB(R1) args: 0, res: 0, upd: 0;
       c4twC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4twB() //  [R1]
         { info_tbl: [(c4twB,
                       label: block_c4twB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4twB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4twP; else goto c4twO;
       c4twP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4twO: // global
           _s4lb9::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4lb9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt8_go_entry() //  [R2]
         { info_tbl: [(c4twV,
                       label: GHC.Int.$fReadInt8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4twV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4twW; else goto c4twX;
       c4twW: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4twX: // global
           I64[Sp - 8] = block_c4twf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tx7; else goto c4twg;
       u4tx7: // global
           call _c4twf(R1) args: 0, res: 0, upd: 0;
       c4twg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4twf() //  [R1]
         { info_tbl: [(c4twf,
                       label: block_c4twf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4twf: // global
           if (R1 & 7 == 1) goto c4twS; else goto c4twT;
       c4twS: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4twT: // global
           I64[Sp - 8] = block_c4twl_info;
           _s4lb3::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lb3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tx6; else goto c4twm;
       u4tx6: // global
           call _c4twl(R1) args: 0, res: 0, upd: 0;
       c4twm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4twl() //  [R1]
         { info_tbl: [(c4twl,
                       label: block_c4twl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4twl: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4tx5; else goto c4tx4;
       c4tx5: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tx4: // global
           _s4lb5::P64 = P64[R1 + 7];
           _s4lb6::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lbc_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lba_info;
           P64[Hp - 48] = _s4lb5::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lb6::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.818919542 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadsPrec_closure" {
     GHC.Int.$fReadInt8_$creadsPrec_closure:
         const GHC.Int.$fReadInt8_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4txN,
                       label: GHC.Int.$fReadInt8_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4txN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4txR; else goto c4txS;
       c4txR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4txS: // global
           I64[Sp - 16] = block_c4txL_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lbe::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lbe::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4txL() //  [R1]
         { info_tbl: [(c4txL,
                       label: block_c4txL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4txL: // global
           _s4lbe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4txQ_info;
           R3 = _s4lbe::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4txQ() //  [R1]
         { info_tbl: [(c4txQ,
                       label: block_c4txQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4txQ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.828206701 UTC

[section ""data" . GHC.Int.$fReadInt13_closure" {
     GHC.Int.$fReadInt13_closure:
         const GHC.Int.$fReadInt13_info;
         const 0;
 },
 sat_s4lbj_entry() //  [R1, R2]
         { info_tbl: [(c4tyi,
                       label: sat_s4lbj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tyi: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt8_$creadsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt13_entry() //  [R2, R3]
         { info_tbl: [(c4tyo,
                       label: GHC.Int.$fReadInt13_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tyo: // global
           _s4lbi::P64 = R3;
           _s4lbh::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4typ; else goto c4tyq;
       c4tyq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tys; else goto c4tyr;
       c4tys: // global
           HpAlloc = 16;
           goto c4typ;
       c4typ: // global
           R3 = _s4lbi::P64;
           R2 = _s4lbh::P64;
           R1 = GHC.Int.$fReadInt13_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tyr: // global
           I64[Hp - 8] = sat_s4lbj_info;
           P64[Hp] = _s4lbh::P64;
           I64[Sp - 8] = block_c4tyl_info;
           R3 = _s4lbi::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4tyl() //  [R1]
         { info_tbl: [(c4tyl,
                       label: block_c4tyl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tyl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tyv; else goto c4tyu;
       c4tyv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tyu: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.839823405 UTC

[section ""data" . GHC.Int.$fIxInt1_closure" {
     GHC.Int.$fIxInt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.843069295 UTC

[section ""data" . GHC.Int.$fReadInt12_closure" {
     GHC.Int.$fReadInt12_closure:
         const GHC.Int.$fReadInt12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt12_entry() //  [R1]
         { info_tbl: [(c4tyP,
                       label: GHC.Int.$fReadInt12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tyP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4tyQ; else goto c4tyR;
       c4tyQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4tyR: // global
           (_c4tyM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4tyM::I64 == 0) goto c4tyO; else goto c4tyN;
       c4tyO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4tyN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4tyM::I64;
           R2 = GHC.Int.$fReadInt13_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.851176054 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadList_closure" {
     GHC.Int.$fReadInt8_$creadList_closure:
         const GHC.Int.$fReadInt8_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadList_entry() //  [R2]
         { info_tbl: [(c4tz3,
                       label: GHC.Int.$fReadInt8_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tz3: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.856870291 UTC

[section ""data" . GHC.Int.$fReadInt11_closure" {
     GHC.Int.$fReadInt11_closure:
         const GHC.Int.$fReadInt11_info;
         const 0;
 },
 GHC.Int.$fReadInt11_entry() //  [R2, R3]
         { info_tbl: [(c4tzh,
                       label: GHC.Int.$fReadInt11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tzh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tzi; else goto c4tzj;
       c4tzi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tzj: // global
           I64[Sp - 8] = block_c4tze_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt8_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4tze() //  [R1]
         { info_tbl: [(c4tze,
                       label: block_c4tze_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tze: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tzm; else goto c4tzl;
       c4tzm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tzl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.866091184 UTC

[section ""data" . GHC.Int.$fReadInt8_closure" {
     GHC.Int.$fReadInt8_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt8_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt8_$creadList_closure+1;
         const GHC.Int.$fReadInt13_closure+2;
         const GHC.Int.$fReadInt11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.869857417 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquot_closure" {
     GHC.Int.$fIntegralInt8_$cquot_closure:
         const GHC.Int.$fIntegralInt8_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4tzE,
                       label: GHC.Int.$fIntegralInt8_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tzE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tzI; else goto c4tzJ;
       c4tzI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tzJ: // global
           I64[Sp - 16] = block_c4tzB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tAk; else goto c4tzC;
       u4tAk: // global
           call _c4tzB(R1) args: 0, res: 0, upd: 0;
       c4tzC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tzB() //  [R1]
         { info_tbl: [(c4tzB,
                       label: block_c4tzB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tzB: // global
           I64[Sp] = block_c4tzH_info;
           _s4lbt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbt::I64;
           if (R1 & 7 != 0) goto u4tAj; else goto c4tzL;
       u4tAj: // global
           call _c4tzH(R1) args: 0, res: 0, upd: 0;
       c4tzL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tzH() //  [R1]
         { info_tbl: [(c4tzH,
                       label: block_c4tzH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tzH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tzR; else goto c4tzQ;
       c4tzR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tzQ: // global
           _s4lbt::I64 = I64[Sp + 8];
           _s4lbw::I64 = I64[R1 + 7];
           if (_s4lbw::I64 != (-1)) goto u4tAi; else goto c4tAg;
       u4tAi: // global
           if (_s4lbw::I64 != 0) goto c4tA2; else goto c4tAh;
       c4tA2: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4lbt::I64,
                                                                          _s4lbw::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tAh: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tAg: // global
           if (_s4lbt::I64 == (-128)) goto c4tAf; else goto c4tAe;
       c4tAf: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tAe: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4lbt::I64,
                                                                          (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.885521048 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$crem_closure" {
     GHC.Int.$fIntegralInt8_$crem_closure:
         const GHC.Int.$fIntegralInt8_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4tAM,
                       label: GHC.Int.$fIntegralInt8_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tAM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tAQ; else goto c4tAR;
       c4tAQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tAR: // global
           I64[Sp - 16] = block_c4tAJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tBd; else goto c4tAK;
       u4tBd: // global
           call _c4tAJ(R1) args: 0, res: 0, upd: 0;
       c4tAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tAJ() //  [R1]
         { info_tbl: [(c4tAJ,
                       label: block_c4tAJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tAJ: // global
           I64[Sp] = block_c4tAP_info;
           _s4lbH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbH::I64;
           if (R1 & 7 != 0) goto u4tBc; else goto c4tAT;
       u4tBc: // global
           call _c4tAP(R1) args: 0, res: 0, upd: 0;
       c4tAT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tAP() //  [R1]
         { info_tbl: [(c4tAP,
                       label: block_c4tAP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tAP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tAZ; else goto c4tAY;
       c4tAZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tAY: // global
           _s4lbK::I64 = I64[R1 + 7];
           if (_s4lbK::I64 != 0) goto c4tBa; else goto c4tBb;
       c4tBa: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Rem_W64(I64[Sp + 8],
                                                                         _s4lbK::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tBb: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.897588574 UTC

[section ""data" . GHC.Int.$w$cdiv3_closure" {
     GHC.Int.$w$cdiv3_closure:
         const GHC.Int.$w$cdiv3_info;
         const 0;
 },
 GHC.Int.$w$cdiv3_entry() //  [R2, R3]
         { info_tbl: [(c4tBD,
                       label: GHC.Int.$w$cdiv3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tBD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tBE; else goto c4tBF;
       c4tBE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tBF: // global
           if (R3 == (-1)) goto c4tBB; else goto u4tBZ;
       c4tBB: // global
           if (R2 == (-128)) goto c4tBY; else goto c4tBW;
       c4tBY: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tBW: // global
           I64[Sp - 8] = block_c4tBQ_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4tBZ: // global
           if (R3 == 0) goto c4tBC; else goto c4tBA;
       c4tBC: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tBA: // global
           I64[Sp - 8] = block_c4tBH_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4tBQ() //  [R1]
         { info_tbl: [(c4tBQ,
                       label: block_c4tBQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tBQ: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4tBH() //  [R1]
         { info_tbl: [(c4tBH,
                       label: block_c4tBH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tBH: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.909794095 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdiv_closure" {
     GHC.Int.$fIntegralInt8_$cdiv_closure:
         const GHC.Int.$fIntegralInt8_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4tCm,
                       label: GHC.Int.$fIntegralInt8_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tCm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tCz; else goto c4tCA;
       c4tCz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tCA: // global
           I64[Sp - 16] = block_c4tCj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tCH; else goto c4tCk;
       u4tCH: // global
           call _c4tCj(R1) args: 0, res: 0, upd: 0;
       c4tCk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tCj() //  [R1]
         { info_tbl: [(c4tCj,
                       label: block_c4tCj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tCj: // global
           I64[Sp] = block_c4tCp_info;
           _s4lbY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbY::I64;
           if (R1 & 7 != 0) goto u4tCG; else goto c4tCq;
       u4tCG: // global
           call _c4tCp(R1) args: 0, res: 0, upd: 0;
       c4tCq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tCp() //  [R1]
         { info_tbl: [(c4tCp,
                       label: block_c4tCp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tCp: // global
           _s4lbY::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4tCu_info;
           R3 = I64[R1 + 7];
           R2 = _s4lbY::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4tCu() //  [R1]
         { info_tbl: [(c4tCu,
                       label: block_c4tCu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tCu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tCF; else goto c4tCE;
       c4tCF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4tCE: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.92381157 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cmod_closure" {
     GHC.Int.$fIntegralInt8_$cmod_closure:
         const GHC.Int.$fIntegralInt8_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4tD6,
                       label: GHC.Int.$fIntegralInt8_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tD6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tDa; else goto c4tDb;
       c4tDa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tDb: // global
           I64[Sp - 16] = block_c4tD3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tDz; else goto c4tD4;
       u4tDz: // global
           call _c4tD3(R1) args: 0, res: 0, upd: 0;
       c4tD4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tD3() //  [R1]
         { info_tbl: [(c4tD3,
                       label: block_c4tD3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tD3: // global
           I64[Sp] = block_c4tD9_info;
           _s4lc5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lc5::I64;
           if (R1 & 7 != 0) goto u4tDy; else goto c4tDd;
       u4tDy: // global
           call _c4tD9(R1) args: 0, res: 0, upd: 0;
       c4tDd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tD9() //  [R1]
         { info_tbl: [(c4tD9,
                       label: block_c4tD9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tD9: // global
           _s4lc8::I64 = I64[R1 + 7];
           if (_s4lc8::I64 != 0) goto c4tDt; else goto c4tDx;
       c4tDt: // global
           _s4lc5::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4tDk_info;
           R3 = _s4lc8::I64;
           R2 = _s4lc5::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4tDx: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4tDk() //  [R1]
         { info_tbl: [(c4tDk,
                       label: block_c4tDk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tDk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tDw; else goto c4tDv;
       c4tDw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4tDv: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.937964309 UTC

[section ""data" . lvl6_r4kPx_closure" {
     lvl6_r4kPx_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt13_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.941499141 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquotRem_closure" {
     GHC.Int.$fIntegralInt8_$cquotRem_closure:
         const GHC.Int.$fIntegralInt8_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4tE1,
                       label: GHC.Int.$fIntegralInt8_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tE1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tE5; else goto c4tE6;
       c4tE5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tE6: // global
           I64[Sp - 16] = block_c4tDY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tEL; else goto c4tDZ;
       u4tEL: // global
           call _c4tDY(R1) args: 0, res: 0, upd: 0;
       c4tDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tDY() //  [R1]
         { info_tbl: [(c4tDY,
                       label: block_c4tDY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tDY: // global
           I64[Sp] = block_c4tE4_info;
           _s4lcf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lcf::I64;
           if (R1 & 7 != 0) goto u4tEK; else goto c4tE8;
       u4tEK: // global
           call _c4tE4(R1) args: 0, res: 0, upd: 0;
       c4tE8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tE4() //  [R1]
         { info_tbl: [(c4tE4,
                       label: block_c4tE4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tE4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4tEe; else goto c4tEd;
       c4tEe: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tEd: // global
           _s4lcf::I64 = I64[Sp + 8];
           _s4lci::I64 = I64[R1 + 7];
           if (_s4lci::I64 != (-1)) goto u4tEJ; else goto c4tEH;
       u4tEJ: // global
           if (_s4lci::I64 != 0) goto c4tEr; else goto c4tEI;
       c4tEr: // global
           (_s4lck::I64, _s4lcl::I64) = call MO_S_QuotRem W64(_s4lcf::I64, _s4lci::I64);
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcl::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lck::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tEI: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tEH: // global
           if (_s4lcf::I64 == (-128)) goto c4tEG; else goto c4tEF;
       c4tEG: // global
           Hp = Hp - 56;
           R1 = lvl6_r4kPx_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tEF: // global
           (_s4lcs::I64, _s4lct::I64) = call MO_S_QuotRem W64(_s4lcf::I64, (-1));
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lct::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcs::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.957150844 UTC

[section ""data" . GHC.Int.$w$cdivMod3_closure" {
     GHC.Int.$w$cdivMod3_closure:
         const GHC.Int.$w$cdivMod3_info;
         const 0;
 },
 GHC.Int.$w$cdivMod3_entry() //  [R2, R3]
         { info_tbl: [(c4tFn,
                       label: GHC.Int.$w$cdivMod3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tFn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tFo; else goto c4tFp;
       c4tFo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tFp: // global
           if (R3 == 0) goto c4tFm; else goto c4tFl;
       c4tFm: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tFl: // global
           if (R3 == (-1)) goto c4tHS; else goto u4tHT;
       c4tHS: // global
           if (R2 == (-128)) goto c4tHR; else goto u4tHU;
       c4tHR: // global
           R2 = GHC.Int.$fBitsInt13_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4tHU: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4tHW;
       u4tHT: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4tHW;
       u4tHW: // global
           call _c4tFu() args: 0, res: 0, upd: 0;
     }
 },
 _c4tFu() //  []
         { info_tbl: [(c4tFu,
                       label: block_c4tFu_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tFu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4tFy; else goto c4tFx;
       c4tFy: // global
           HpAlloc = 32;
           I64[Sp] = block_c4tFu_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4tFx: // global
           _s4lcz::I64 = I64[Sp + 8];
           _s4lcB::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lcz::I64, 0)) goto c4tGr; else goto c4tHI;
       c4tGr: // global
           if (%MO_S_Ge_W64(_s4lcz::I64, 0)) goto c4tFO; else goto c4tGp;
       c4tFO: // global
           (_s4lcG::I64, _s4lcH::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcH::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcG::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tGp: // global
           if (%MO_S_Le_W64(_s4lcB::I64, 0)) goto c4tG2; else goto c4tGo;
       c4tG2: // global
           (_s4lcO::I64, _s4lcP::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcP::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcO::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tGo: // global
           (_s4lcW::I64, _s4lcX::I64) = call MO_S_QuotRem W64(_s4lcz::I64 + 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcX::I64 + _s4lcB::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcW::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tHI: // global
           if (%MO_S_Ge_W64(_s4lcB::I64, 0)) goto c4tHl; else goto c4tHH;
       c4tHl: // global
           if (%MO_S_Ge_W64(_s4lcz::I64, 0)) goto c4tGI; else goto c4tHj;
       c4tGI: // global
           (_s4ld8::I64, _s4ld9::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ld9::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ld8::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tHj: // global
           if (%MO_S_Le_W64(_s4lcB::I64, 0)) goto c4tGW; else goto c4tHi;
       c4tGW: // global
           (_s4ldg::I64, _s4ldh::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldh::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldg::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tHi: // global
           (_s4ldo::I64, _s4ldp::I64) = call MO_S_QuotRem W64(_s4lcz::I64 + 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldp::I64 + _s4lcB::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldo::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tHH: // global
           (_s4ldz::I64, _s4ldA::I64) = call MO_S_QuotRem W64(_s4lcz::I64 - 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldA::I64 + _s4lcB::I64 + 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldz::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.974301121 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdivMod_closure" {
     GHC.Int.$fIntegralInt8_$cdivMod_closure:
         const GHC.Int.$fIntegralInt8_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4tIS,
                       label: GHC.Int.$fIntegralInt8_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tIS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tJ3; else goto c4tJ4;
       c4tJ3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tJ4: // global
           I64[Sp - 16] = block_c4tIP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tJb; else goto c4tIQ;
       u4tJb: // global
           call _c4tIP(R1) args: 0, res: 0, upd: 0;
       c4tIQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tIP() //  [R1]
         { info_tbl: [(c4tIP,
                       label: block_c4tIP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tIP: // global
           I64[Sp] = block_c4tIV_info;
           _s4ldO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ldO::I64;
           if (R1 & 7 != 0) goto u4tJa; else goto c4tIW;
       u4tJa: // global
           call _c4tIV(R1) args: 0, res: 0, upd: 0;
       c4tIW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tIV() //  [R1]
         { info_tbl: [(c4tIV,
                       label: block_c4tIV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tIV: // global
           _s4ldO::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4tJ0_info;
           R3 = I64[R1 + 7];
           R2 = _s4ldO::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4tJ0() //  [R1, R2]
         { info_tbl: [(c4tJ0,
                       label: block_c4tJ0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tJ0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4tJ9; else goto c4tJ8;
       c4tJ9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4tJ8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.987200724 UTC

[section ""data" . sat_s4ldU_closure" {
     sat_s4ldU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.990181067 UTC

[section ""data" . sat_s4ldV_closure" {
     sat_s4ldV_closure:
         const :_con_info;
         const sat_s4ldU_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.992974763 UTC

[section ""data" . GHC.Int.$fRealInt1_closure" {
     GHC.Int.$fRealInt1_closure:
         const GHC.Int.$fRealInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fRealInt1_entry() //  [R1]
         { info_tbl: [(c4tJB,
                       label: GHC.Int.$fRealInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tJB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tJC; else goto c4tJD;
       c4tJC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4tJD: // global
           (_c4tJy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4tJy::I64 == 0) goto c4tJA; else goto c4tJz;
       c4tJA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4tJz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4tJy::I64;
           R3 = sat_s4ldV_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:11.999864659 UTC

[section ""data" . GHC.Int.$fRealInt8_$ctoRational_closure" {
     GHC.Int.$fRealInt8_$ctoRational_closure:
         const GHC.Int.$fRealInt8_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt8_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4tJS,
                       label: GHC.Int.$fRealInt8_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tJS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tK6; else goto c4tK7;
       c4tK6: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tK7: // global
           I64[Sp - 8] = block_c4tJP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tKe; else goto c4tJQ;
       u4tKe: // global
           call _c4tJP(R1) args: 0, res: 0, upd: 0;
       c4tJQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tJP() //  [R1]
         { info_tbl: [(c4tJP,
                       label: block_c4tJP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tJP: // global
           I64[Sp] = block_c4tJV_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4tJV() //  [R1]
         { info_tbl: [(c4tJV,
                       label: block_c4tJV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tJV: // global
           I64[Sp] = block_c4tJZ_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4tJZ() //  [R1]
         { info_tbl: [(c4tJZ,
                       label: block_c4tJZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tJZ: // global
           I64[Sp] = block_c4tK3_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4tK3() //  [R1, R2]
         { info_tbl: [(c4tK3,
                       label: block_c4tK3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tK3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4tKd; else goto c4tKc;
       c4tKd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4tKc: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.014222855 UTC

[section ""data" . GHC.Int.$fRealInt8_closure" {
     GHC.Int.$fRealInt8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt8_closure+1;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fRealInt8_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.020641153 UTC

[section ""data" . GHC.Int.$fIntegralInt8_closure" {
     GHC.Int.$fIntegralInt8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt8_closure+1;
         const GHC.Int.$fEnumInt8_closure+1;
         const GHC.Int.$fIntegralInt8_$cquot_closure+2;
         const GHC.Int.$fIntegralInt8_$crem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt8_$cmod_closure+2;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt8_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.024518084 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt8_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt8_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt8_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4tKH,
                       label: GHC.Int.$fIxInt8_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tKH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tKY; else goto c4tKZ;
       c4tKY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tKZ: // global
           I64[Sp - 16] = block_c4tKE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tL6; else goto c4tKF;
       u4tL6: // global
           call _c4tKE(R1) args: 0, res: 0, upd: 0;
       c4tKF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tKE() //  [R1]
         { info_tbl: [(c4tKE,
                       label: block_c4tKE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tKE: // global
           I64[Sp] = block_c4tKK_info;
           _s4le7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4le7::P64;
           if (R1 & 7 != 0) goto u4tL5; else goto c4tKL;
       u4tL5: // global
           call _c4tKK(R1) args: 0, res: 0, upd: 0;
       c4tKL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tKK() //  [R1]
         { info_tbl: [(c4tKK,
                       label: block_c4tKK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tKK: // global
           I64[Sp] = block_c4tKP_info;
           _s4lea::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lea::I64;
           if (R1 & 7 != 0) goto u4tL7; else goto c4tKQ;
       u4tL7: // global
           call _c4tKP(R1) args: 0, res: 0, upd: 0;
       c4tKQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tKP() //  [R1]
         { info_tbl: [(c4tKP,
                       label: block_c4tKP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tKP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tL4; else goto c4tL3;
       c4tL4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tL3: // global
           _s4led::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4led::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.03604497 UTC

[section ""data" . GHC.Int.$fIxInt8_$crange_closure" {
     GHC.Int.$fIxInt8_$crange_closure:
         const GHC.Int.$fIxInt8_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$crange_entry() //  [R2]
         { info_tbl: [(c4tLz,
                       label: GHC.Int.$fIxInt8_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tLz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tLA; else goto c4tLB;
       c4tLA: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tLB: // global
           I64[Sp - 8] = block_c4tLw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tLF; else goto c4tLx;
       u4tLF: // global
           call _c4tLw(R1) args: 0, res: 0, upd: 0;
       c4tLx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tLw() //  [R1]
         { info_tbl: [(c4tLw,
                       label: block_c4tLw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tLw: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_$cenumFromTo_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.043948943 UTC

[section ""data" . GHC.Int.$fIxInt8_$crangeSize_closure" {
     GHC.Int.$fIxInt8_$crangeSize_closure:
         const GHC.Int.$fIxInt8_$crangeSize_info;
 },
 GHC.Int.$fIxInt8_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4tLW,
                       label: GHC.Int.$fIxInt8_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tLW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tM5; else goto c4tM6;
       c4tM5: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tM6: // global
           I64[Sp - 8] = block_c4tLT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tMv; else goto c4tLU;
       u4tMv: // global
           call _c4tLT(R1) args: 0, res: 0, upd: 0;
       c4tLU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tLT() //  [R1]
         { info_tbl: [(c4tLT,
                       label: block_c4tLT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tLT: // global
           I64[Sp - 8] = block_c4tLZ_info;
           _s4lel::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lel::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tMu; else goto c4tM0;
       u4tMu: // global
           call _c4tLZ(R1) args: 0, res: 0, upd: 0;
       c4tM0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tLZ() //  [R1]
         { info_tbl: [(c4tLZ,
                       label: block_c4tLZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tLZ: // global
           I64[Sp] = block_c4tM4_info;
           _s4len::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4len::I64;
           if (R1 & 7 != 0) goto u4tMw; else goto c4tM9;
       u4tMw: // global
           call _c4tM4(R1) args: 0, res: 0, upd: 0;
       c4tM9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tM4() //  [R1]
         { info_tbl: [(c4tM4,
                       label: block_c4tM4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tM4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tMf; else goto c4tMe;
       c4tMf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tMe: // global
           _s4len::I64 = I64[Sp + 8];
           _s4lep::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4len::I64,
                            _s4lep::I64)) goto c4tMj; else goto c4tMt;
       c4tMj: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tMt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lep::I64 - _s4len::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.056326587 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt8_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt8_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4tN0,
                       label: GHC.Int.$fIxInt8_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tN0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tNk; else goto c4tNl;
       c4tNk: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tNl: // global
           I64[Sp - 8] = block_c4tMX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tNs; else goto c4tMY;
       u4tNs: // global
           call _c4tMX(R1) args: 0, res: 0, upd: 0;
       c4tMY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tMX() //  [R1]
         { info_tbl: [(c4tMX,
                       label: block_c4tMX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tMX: // global
           I64[Sp - 8] = block_c4tN3_info;
           _s4lev::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lev::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tNr; else goto c4tN4;
       u4tNr: // global
           call _c4tN3(R1) args: 0, res: 0, upd: 0;
       c4tN4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tN3() //  [R1]
         { info_tbl: [(c4tN3,
                       label: block_c4tN3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tN3: // global
           I64[Sp] = block_c4tN8_info;
           _s4ley::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ley::I64;
           if (R1 & 7 != 0) goto u4tNt; else goto c4tN9;
       u4tNt: // global
           call _c4tN8(R1) args: 0, res: 0, upd: 0;
       c4tN9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tN8() //  [R1]
         { info_tbl: [(c4tN8,
                       label: block_c4tN8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tN8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tNq; else goto c4tNp;
       c4tNq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tNp: // global
           _s4leC::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4leC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.070185001 UTC

[section ""data" . GHC.Int.$fIxInt8_$cindex_closure" {
     GHC.Int.$fIxInt8_$cindex_closure:
         const GHC.Int.$fIxInt8_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4tNW,
                       label: GHC.Int.$fIxInt8_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tNW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tO5; else goto c4tO6;
       c4tO5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tO6: // global
           I64[Sp - 16] = block_c4tNT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tOF; else goto c4tNU;
       u4tOF: // global
           call _c4tNT(R1) args: 0, res: 0, upd: 0;
       c4tNU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tNT() //  [R1]
         { info_tbl: [(c4tNT,
                       label: block_c4tNT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tNT: // global
           I64[Sp - 8] = block_c4tNZ_info;
           _s4leH::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4leH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tOE; else goto c4tO0;
       u4tOE: // global
           call _c4tNZ(R1) args: 0, res: 0, upd: 0;
       c4tO0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tNZ() //  [R1]
         { info_tbl: [(c4tNZ,
                       label: block_c4tNZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tNZ: // global
           I64[Sp] = block_c4tO4_info;
           _s4leJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4leJ::I64;
           if (R1 & 7 != 0) goto u4tOG; else goto c4tO9;
       u4tOG: // global
           call _c4tO4(R1) args: 0, res: 0, upd: 0;
       c4tO9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tO4() //  [R1]
         { info_tbl: [(c4tO4,
                       label: block_c4tO4_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tO4: // global
           _s4leL::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4leL::I64)) goto c4tOh; else goto c4tOl;
       c4tOh: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tOl: // global
           I64[Sp] = block_c4tOk_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4leL::I64;
           if (R1 & 7 != 0) goto u4tOH; else goto c4tOm;
       u4tOH: // global
           call _c4tOk(R1) args: 0, res: 0, upd: 0;
       c4tOm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tOk() //  [R1]
         { info_tbl: [(c4tOk,
                       label: block_c4tOk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tOk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tOs; else goto c4tOr;
       c4tOs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tOr: // global
           _s4leL::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4leL::I64,
                            I64[R1 + 7])) goto c4tOw; else goto c4tOD;
       c4tOw: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tOD: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4leL::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.083279555 UTC

[section ""data" . GHC.Int.$fIxInt8_closure" {
     GHC.Int.$fIxInt8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fIxInt8_$crange_closure+1;
         const GHC.Int.$fIxInt8_$cindex_closure+2;
         const GHC.Int.$fIxInt8_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt8_$cinRange_closure+2;
         const GHC.Int.$fIxInt8_$crangeSize_closure+1;
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.085722196 UTC

[section ""data" . GHC.Int.eqInt16_closure" {
     GHC.Int.eqInt16_closure:
         const GHC.Int.eqInt16_info;
 },
 GHC.Int.eqInt16_entry() //  [R2, R3]
         { info_tbl: [(c4tPg,
                       label: GHC.Int.eqInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tPg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tPk; else goto c4tPl;
       c4tPk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tPl: // global
           I64[Sp - 16] = block_c4tPd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tPu; else goto c4tPe;
       u4tPu: // global
           call _c4tPd(R1) args: 0, res: 0, upd: 0;
       c4tPe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tPd() //  [R1]
         { info_tbl: [(c4tPd,
                       label: block_c4tPd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tPd: // global
           I64[Sp] = block_c4tPj_info;
           _s4leU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4leU::I64;
           if (R1 & 7 != 0) goto u4tPt; else goto c4tPn;
       u4tPt: // global
           call _c4tPj(R1) args: 0, res: 0, upd: 0;
       c4tPn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tPj() //  [R1]
         { info_tbl: [(c4tPj,
                       label: block_c4tPj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tPj: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.09646154 UTC

[section ""data" . GHC.Int.$fEqInt16_closure" {
     GHC.Int.$fEqInt16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt16_closure+2;
         const GHC.Int.neInt16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.099788748 UTC

[section ""data" . GHC.Int.gtInt16_closure" {
     GHC.Int.gtInt16_closure:
         const GHC.Int.gtInt16_info;
 },
 GHC.Int.gtInt16_entry() //  [R2, R3]
         { info_tbl: [(c4tPU,
                       label: GHC.Int.gtInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tPU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tPY; else goto c4tPZ;
       c4tPY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tPZ: // global
           I64[Sp - 16] = block_c4tPR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tQ8; else goto c4tPS;
       u4tQ8: // global
           call _c4tPR(R1) args: 0, res: 0, upd: 0;
       c4tPS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tPR() //  [R1]
         { info_tbl: [(c4tPR,
                       label: block_c4tPR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tPR: // global
           I64[Sp] = block_c4tPX_info;
           _s4lf1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lf1::I64;
           if (R1 & 7 != 0) goto u4tQ7; else goto c4tQ1;
       u4tQ7: // global
           call _c4tPX(R1) args: 0, res: 0, upd: 0;
       c4tQ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tPX() //  [R1]
         { info_tbl: [(c4tPX,
                       label: block_c4tPX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tPX: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.109846068 UTC

[section ""data" . GHC.Int.geInt16_closure" {
     GHC.Int.geInt16_closure:
         const GHC.Int.geInt16_info;
 },
 GHC.Int.geInt16_entry() //  [R2, R3]
         { info_tbl: [(c4tQx,
                       label: GHC.Int.geInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tQx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tQB; else goto c4tQC;
       c4tQB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tQC: // global
           I64[Sp - 16] = block_c4tQu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tQL; else goto c4tQv;
       u4tQL: // global
           call _c4tQu(R1) args: 0, res: 0, upd: 0;
       c4tQv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tQu() //  [R1]
         { info_tbl: [(c4tQu,
                       label: block_c4tQu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tQu: // global
           I64[Sp] = block_c4tQA_info;
           _s4lf8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lf8::I64;
           if (R1 & 7 != 0) goto u4tQK; else goto c4tQE;
       u4tQK: // global
           call _c4tQA(R1) args: 0, res: 0, upd: 0;
       c4tQE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tQA() //  [R1]
         { info_tbl: [(c4tQA,
                       label: block_c4tQA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tQA: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.121685087 UTC

[section ""data" . GHC.Int.ltInt16_closure" {
     GHC.Int.ltInt16_closure:
         const GHC.Int.ltInt16_info;
 },
 GHC.Int.ltInt16_entry() //  [R2, R3]
         { info_tbl: [(c4tRa,
                       label: GHC.Int.ltInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tRa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tRe; else goto c4tRf;
       c4tRe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tRf: // global
           I64[Sp - 16] = block_c4tR7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tRo; else goto c4tR8;
       u4tRo: // global
           call _c4tR7(R1) args: 0, res: 0, upd: 0;
       c4tR8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tR7() //  [R1]
         { info_tbl: [(c4tR7,
                       label: block_c4tR7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tR7: // global
           I64[Sp] = block_c4tRd_info;
           _s4lff::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lff::I64;
           if (R1 & 7 != 0) goto u4tRn; else goto c4tRh;
       u4tRn: // global
           call _c4tRd(R1) args: 0, res: 0, upd: 0;
       c4tRh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tRd() //  [R1]
         { info_tbl: [(c4tRd,
                       label: block_c4tRd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tRd: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.129795546 UTC

[section ""data" . GHC.Int.leInt16_closure" {
     GHC.Int.leInt16_closure:
         const GHC.Int.leInt16_info;
 },
 GHC.Int.leInt16_entry() //  [R2, R3]
         { info_tbl: [(c4tRN,
                       label: GHC.Int.leInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tRN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tRR; else goto c4tRS;
       c4tRR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tRS: // global
           I64[Sp - 16] = block_c4tRK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tS1; else goto c4tRL;
       u4tS1: // global
           call _c4tRK(R1) args: 0, res: 0, upd: 0;
       c4tRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tRK() //  [R1]
         { info_tbl: [(c4tRK,
                       label: block_c4tRK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tRK: // global
           I64[Sp] = block_c4tRQ_info;
           _s4lfm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lfm::I64;
           if (R1 & 7 != 0) goto u4tS0; else goto c4tRU;
       u4tS0: // global
           call _c4tRQ(R1) args: 0, res: 0, upd: 0;
       c4tRU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tRQ() //  [R1]
         { info_tbl: [(c4tRQ,
                       label: block_c4tRQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tRQ: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.139262586 UTC

[section ""data" . GHC.Int.$fOrdInt16_$ccompare_closure" {
     GHC.Int.$fOrdInt16_$ccompare_closure:
         const GHC.Int.$fOrdInt16_$ccompare_info;
 },
 GHC.Int.$fOrdInt16_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4tSq,
                       label: GHC.Int.$fOrdInt16_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tSq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tSu; else goto c4tSv;
       c4tSu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tSv: // global
           I64[Sp - 16] = block_c4tSn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tSO; else goto c4tSo;
       u4tSO: // global
           call _c4tSn(R1) args: 0, res: 0, upd: 0;
       c4tSo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tSn() //  [R1]
         { info_tbl: [(c4tSn,
                       label: block_c4tSn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tSn: // global
           I64[Sp] = block_c4tSt_info;
           _s4lft::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lft::I64;
           if (R1 & 7 != 0) goto u4tSN; else goto c4tSx;
       u4tSN: // global
           call _c4tSt(R1) args: 0, res: 0, upd: 0;
       c4tSx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tSt() //  [R1]
         { info_tbl: [(c4tSt,
                       label: block_c4tSt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tSt: // global
           _s4lft::I64 = I64[Sp + 8];
           _s4lfv::I64 = I64[R1 + 7];
           if (_s4lft::I64 == _s4lfv::I64) goto c4tSM; else goto c4tSL;
       c4tSM: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tSL: // global
           if (%MO_S_Gt_W64(_s4lft::I64,
                            _s4lfv::I64)) goto c4tSI; else goto c4tSJ;
       c4tSI: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tSJ: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.148206727 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmax_closure" {
     GHC.Int.$fOrdInt16_$cmax_closure:
         const GHC.Int.$fOrdInt16_$cmax_info;
 },
 GHC.Int.$fOrdInt16_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4tTc,
                       label: GHC.Int.$fOrdInt16_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tTc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tTg; else goto c4tTh;
       c4tTg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tTh: // global
           I64[Sp - 16] = block_c4tT9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tTu; else goto c4tTa;
       u4tTu: // global
           call _c4tT9(R1) args: 0, res: 0, upd: 0;
       c4tTa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tT9() //  [R1]
         { info_tbl: [(c4tT9,
                       label: block_c4tT9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tT9: // global
           I64[Sp - 8] = block_c4tTf_info;
           _s4lfA::P64 = R1;
           _s4lfB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lfB::I64;
           P64[Sp + 8] = _s4lfA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tTt; else goto c4tTj;
       u4tTt: // global
           call _c4tTf(R1) args: 0, res: 0, upd: 0;
       c4tTj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tTf() //  [R1]
         { info_tbl: [(c4tTf,
                       label: block_c4tTf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tTf: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4tTr; else goto c4tTs;
       c4tTr: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tTs: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.159544801 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmin_closure" {
     GHC.Int.$fOrdInt16_$cmin_closure:
         const GHC.Int.$fOrdInt16_$cmin_info;
 },
 GHC.Int.$fOrdInt16_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4tTU,
                       label: GHC.Int.$fOrdInt16_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tTU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tTY; else goto c4tTZ;
       c4tTY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tTZ: // global
           I64[Sp - 16] = block_c4tTR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tUc; else goto c4tTS;
       u4tUc: // global
           call _c4tTR(R1) args: 0, res: 0, upd: 0;
       c4tTS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tTR() //  [R1]
         { info_tbl: [(c4tTR,
                       label: block_c4tTR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tTR: // global
           I64[Sp - 8] = block_c4tTX_info;
           _s4lfH::P64 = R1;
           _s4lfI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lfI::I64;
           P64[Sp + 8] = _s4lfH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tUb; else goto c4tU1;
       u4tUb: // global
           call _c4tTX(R1) args: 0, res: 0, upd: 0;
       c4tU1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tTX() //  [R1]
         { info_tbl: [(c4tTX,
                       label: block_c4tTX_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tTX: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4tU9; else goto c4tUa;
       c4tU9: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tUa: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.168065629 UTC

[section ""data" . GHC.Int.$fOrdInt16_closure" {
     GHC.Int.$fOrdInt16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fOrdInt16_$ccompare_closure+2;
         const GHC.Int.ltInt16_closure+2;
         const GHC.Int.leInt16_closure+2;
         const GHC.Int.gtInt16_closure+2;
         const GHC.Int.geInt16_closure+2;
         const GHC.Int.$fOrdInt16_$cmax_closure+2;
         const GHC.Int.$fOrdInt16_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.171664441 UTC

[section ""data" . GHC.Int.$fIxInt16_$cinRange_closure" {
     GHC.Int.$fIxInt16_$cinRange_closure:
         const GHC.Int.$fIxInt16_$cinRange_info;
 },
 GHC.Int.$fIxInt16_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4tUD,
                       label: GHC.Int.$fIxInt16_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tUD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tUM; else goto c4tUN;
       c4tUM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tUN: // global
           I64[Sp - 16] = block_c4tUA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tVa; else goto c4tUB;
       u4tVa: // global
           call _c4tUA(R1) args: 0, res: 0, upd: 0;
       c4tUB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tUA() //  [R1]
         { info_tbl: [(c4tUA,
                       label: block_c4tUA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tUA: // global
           I64[Sp - 8] = block_c4tUG_info;
           _s4lfQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lfQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tV9; else goto c4tUH;
       u4tV9: // global
           call _c4tUG(R1) args: 0, res: 0, upd: 0;
       c4tUH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tUG() //  [R1]
         { info_tbl: [(c4tUG,
                       label: block_c4tUG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tUG: // global
           I64[Sp] = block_c4tUL_info;
           _s4lfS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lfS::I64;
           if (R1 & 7 != 0) goto u4tVb; else goto c4tUQ;
       u4tVb: // global
           call _c4tUL(R1) args: 0, res: 0, upd: 0;
       c4tUQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tUL() //  [R1]
         { info_tbl: [(c4tUL,
                       label: block_c4tUL_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tUL: // global
           _s4lfU::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lfU::I64)) goto c4tUY; else goto c4tV2;
       c4tUY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tV2: // global
           _s4lfQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4tV1_info;
           R1 = _s4lfQ::P64;
           I64[Sp + 16] = _s4lfU::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4tVc; else goto c4tV3;
       u4tVc: // global
           call _c4tV1(R1) args: 0, res: 0, upd: 0;
       c4tV3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tV1() //  [R1]
         { info_tbl: [(c4tV1,
                       label: block_c4tV1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tV1: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.184658548 UTC

[section ""data" . GHC.Int.$fNumInt1_closure" {
     GHC.Int.$fNumInt1_closure:
         const GHC.Int.I16#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.187546863 UTC

[section ""data" . GHC.Int.$fNumInt16_$csignum_closure" {
     GHC.Int.$fNumInt16_$csignum_closure:
         const GHC.Int.$fNumInt16_$csignum_info;
 },
 GHC.Int.$fNumInt16_$csignum_entry() //  [R2]
         { info_tbl: [(c4tVL,
                       label: GHC.Int.$fNumInt16_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tVL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tVM; else goto c4tVN;
       c4tVM: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tVN: // global
           I64[Sp - 8] = block_c4tVI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tW1; else goto c4tVJ;
       u4tW1: // global
           call _c4tVI(R1) args: 0, res: 0, upd: 0;
       c4tVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tVI() //  [R1]
         { info_tbl: [(c4tVI,
                       label: block_c4tVI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tVI: // global
           _s4lg1::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lg1::I64, 0)) goto c4tVZ; else goto c4tW0;
       c4tVZ: // global
           if (_s4lg1::I64 == 0) goto c4tVX; else goto c4tVW;
       c4tVX: // global
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tVW: // global
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tW0: // global
           R1 = GHC.Int.$fNumInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.194209111 UTC

[section ""data" . GHC.Int.$fNumInt16_$cabs_closure" {
     GHC.Int.$fNumInt16_$cabs_closure:
         const GHC.Int.$fNumInt16_$cabs_info;
 },
 GHC.Int.$fNumInt16_$cabs_entry() //  [R2]
         { info_tbl: [(c4tWl,
                       label: GHC.Int.$fNumInt16_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tWl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tWm; else goto c4tWn;
       c4tWm: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tWn: // global
           I64[Sp - 8] = block_c4tWi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tWG; else goto c4tWj;
       u4tWG: // global
           call _c4tWi(R1) args: 0, res: 0, upd: 0;
       c4tWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tWi() //  [R1]
         { info_tbl: [(c4tWi,
                       label: block_c4tWi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tWi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tWs; else goto c4tWr;
       c4tWs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tWr: // global
           _s4lg6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lg6::I64, 0)) goto c4tWE; else goto c4tWF;
       c4tWE: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-_s4lg6::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tWF: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.20139068 UTC

[section ""data" . GHC.Int.$fNumInt16_closure" {
     GHC.Int.$fNumInt16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt16_$c+_closure+2;
         const GHC.Int.$fNumInt16_$c-_closure+2;
         const GHC.Int.$fNumInt16_$c*_closure+2;
         const GHC.Int.$fNumInt16_$cnegate_closure+1;
         const GHC.Int.$fNumInt16_$cabs_closure+1;
         const GHC.Int.$fNumInt16_$csignum_closure+1;
         const GHC.Int.$fNumInt16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.203327265 UTC

[section ""data" . GHC.Int.$fBitsInt2_closure" {
     GHC.Int.$fBitsInt2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.206169096 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt16_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4tX1,
                       label: GHC.Int.$fBitsInt16_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tX1: // global
           R1 = GHC.Int.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.211635668 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbit_closure" {
     GHC.Int.$fBitsInt16_$cbit_closure:
         const GHC.Int.$fBitsInt16_$cbit_info;
 },
 GHC.Int.$fBitsInt16_$cbit_entry() //  [R2]
         { info_tbl: [(c4tXg,
                       label: GHC.Int.$fBitsInt16_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tXg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tXh; else goto c4tXi;
       c4tXh: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tXi: // global
           I64[Sp - 8] = block_c4tXd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tXB; else goto c4tXe;
       u4tXB: // global
           call _c4tXd(R1) args: 0, res: 0, upd: 0;
       c4tXe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tXd() //  [R1]
         { info_tbl: [(c4tXd,
                       label: block_c4tXd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tXd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tXn; else goto c4tXm;
       c4tXn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tXm: // global
           _s4lgd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lgd::I64, 64)) goto c4tXz; else goto c4tXA;
       c4tXz: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgd::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tXA: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.219993055 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ctestBit_closure" {
     GHC.Int.$fBitsInt16_$ctestBit_closure:
         const GHC.Int.$fBitsInt16_$ctestBit_info;
 },
 GHC.Int.$fBitsInt16_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4tXX,
                       label: GHC.Int.$fBitsInt16_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tXX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tY1; else goto c4tY2;
       c4tY1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tY2: // global
           I64[Sp - 16] = block_c4tXU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tYK; else goto c4tXV;
       u4tYK: // global
           call _c4tXU(R1) args: 0, res: 0, upd: 0;
       c4tXV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tXU() //  [R1]
         { info_tbl: [(c4tXU,
                       label: block_c4tXU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tXU: // global
           I64[Sp] = block_c4tY0_info;
           _s4lgk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lgk::I64;
           if (R1 & 7 != 0) goto u4tYJ; else goto c4tY4;
       u4tYJ: // global
           call _c4tY0(R1) args: 0, res: 0, upd: 0;
       c4tY4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tY0() //  [R1]
         { info_tbl: [(c4tY0,
                       label: block_c4tY0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tY0: // global
           _s4lgm::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4lgm::I64, 64)) goto c4tYI; else goto c4tYH;
       c4tYH: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgm::I64)) == 0) goto c4tYI; else goto c4tYw;
       c4tYI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tYw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.229791257 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateR_closure" {
     GHC.Int.$fBitsInt16_$crotateR_closure:
         const GHC.Int.$fBitsInt16_$crotateR_info;
 },
 GHC.Int.$fBitsInt16_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4tZc,
                       label: GHC.Int.$fBitsInt16_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tZc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tZg; else goto c4tZh;
       c4tZg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tZh: // global
           I64[Sp - 16] = block_c4tZ9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u0g; else goto c4tZa;
       u4u0g: // global
           call _c4tZ9(R1) args: 0, res: 0, upd: 0;
       c4tZa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tZ9() //  [R1]
         { info_tbl: [(c4tZ9,
                       label: block_c4tZ9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tZ9: // global
           I64[Sp - 8] = block_c4tZf_info;
           _s4lgw::P64 = R1;
           _s4lgx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lgx::I64;
           P64[Sp + 8] = _s4lgw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4u0f; else goto c4tZj;
       u4u0f: // global
           call _c4tZf(R1) args: 0, res: 0, upd: 0;
       c4tZj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4tZf() //  [R1]
         { info_tbl: [(c4tZf,
                       label: block_c4tZf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tZf: // global
           _s4lgD::I64 = -I64[R1 + 7] & 15;
           if (_s4lgD::I64 != 0) goto u4u0d; else goto c4u09;
       u4u0d: // global
           I64[Sp + 16] = _s4lgD::I64;
           Sp = Sp + 8;
           call _c4tZB() args: 0, res: 0, upd: 0;
       c4u09: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4tZB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tZB: // global
           Hp = Hp + 16;
           _s4lgD::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4u06; else goto c4u05;
       c4u06: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4tZA_info;
           R1 = _s4lgD::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4u05: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4lgE::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4lgE::I64 << _s4lgD::I64) | (_s4lgE::I64 >> 16 - _s4lgD::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4tZA() //  [R1]
         { info_tbl: [(c4tZA,
                       label: block_c4tZA_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4tZA: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4tZB() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.242738555 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt16_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt16_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt16_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4u0T,
                       label: GHC.Int.$fBitsInt16_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u0T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4u0X; else goto c4u0Y;
       c4u0X: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u0Y: // global
           I64[Sp - 16] = block_c4u0Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u1x; else goto c4u0R;
       u4u1x: // global
           call _c4u0Q(R1) args: 0, res: 0, upd: 0;
       c4u0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u0Q() //  [R1]
         { info_tbl: [(c4u0Q,
                       label: block_c4u0Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u0Q: // global
           I64[Sp - 8] = block_c4u0W_info;
           _s4lgO::P64 = R1;
           _s4lgP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lgP::I64;
           P64[Sp + 8] = _s4lgO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4u1w; else goto c4u10;
       u4u1w: // global
           call _c4u0W(R1) args: 0, res: 0, upd: 0;
       c4u10: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u0W() //  [R1]
         { info_tbl: [(c4u0W,
                       label: block_c4u0W_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u0W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u16; else goto c4u15;
       c4u16: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u15: // global
           _s4lgR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lgR::I64, 64)) goto c4u1u; else goto c4u1v;
       c4u1u: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgR::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u1v: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.252801677 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cclearBit_closure" {
     GHC.Int.$fBitsInt16_$cclearBit_closure:
         const GHC.Int.$fBitsInt16_$cclearBit_info;
 },
 GHC.Int.$fBitsInt16_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4u20,
                       label: GHC.Int.$fBitsInt16_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u20: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u24; else goto c4u25;
       c4u24: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u25: // global
           I64[Sp - 16] = block_c4u1X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u2S; else goto c4u1Y;
       u4u2S: // global
           call _c4u1X(R1) args: 0, res: 0, upd: 0;
       c4u1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u1X() //  [R1]
         { info_tbl: [(c4u1X,
                       label: block_c4u1X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u1X: // global
           I64[Sp] = block_c4u23_info;
           _s4lh2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lh2::I64;
           if (R1 & 7 != 0) goto u4u2R; else goto c4u27;
       u4u2R: // global
           call _c4u23(R1) args: 0, res: 0, upd: 0;
       c4u27: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u23() //  [R1]
         { info_tbl: [(c4u23,
                       label: block_c4u23_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u23: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u2d; else goto c4u2c;
       c4u2d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u2c: // global
           _s4lh2::I64 = I64[Sp + 8];
           _s4lh4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lh4::I64, 64)) goto c4u2E; else goto c4u2Q;
       c4u2E: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lh2::I64 & ~%MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lh4::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u2Q: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lh2::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.264270211 UTC

[section ""data" . GHC.Int.$fBitsInt16_$csetBit_closure" {
     GHC.Int.$fBitsInt16_$csetBit_closure:
         const GHC.Int.$fBitsInt16_$csetBit_info;
 },
 GHC.Int.$fBitsInt16_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4u3m,
                       label: GHC.Int.$fBitsInt16_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u3m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4u3q; else goto c4u3r;
       c4u3q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u3r: // global
           I64[Sp - 16] = block_c4u3j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u40; else goto c4u3k;
       u4u40: // global
           call _c4u3j(R1) args: 0, res: 0, upd: 0;
       c4u3k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u3j() //  [R1]
         { info_tbl: [(c4u3j,
                       label: block_c4u3j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u3j: // global
           I64[Sp - 8] = block_c4u3p_info;
           _s4lhi::P64 = R1;
           _s4lhj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lhj::I64;
           P64[Sp + 8] = _s4lhi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4u3Z; else goto c4u3t;
       u4u3Z: // global
           call _c4u3p(R1) args: 0, res: 0, upd: 0;
       c4u3t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u3p() //  [R1]
         { info_tbl: [(c4u3p,
                       label: block_c4u3p_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u3p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u3z; else goto c4u3y;
       c4u3z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u3y: // global
           _s4lhl::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lhl::I64, 64)) goto c4u3X; else goto c4u3Y;
       c4u3X: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lhl::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u3Y: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.273588682 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateL_closure" {
     GHC.Int.$fBitsInt16_$crotateL_closure:
         const GHC.Int.$fBitsInt16_$crotateL_info;
 },
 GHC.Int.$fBitsInt16_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4u4q,
                       label: GHC.Int.$fBitsInt16_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u4q: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt16_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.27707498 UTC

[section ""data" . GHC.Int.$fBitsInt16_closure" {
     GHC.Int.$fBitsInt16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fBitsInt16_$c.&._closure+2;
         const GHC.Int.$fBitsInt16_$c.|._closure+2;
         const GHC.Int.$fBitsInt16_$cxor_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt16_$cshift_closure+2;
         const GHC.Int.$fBitsInt16_$crotate_closure+2;
         const GHC.Int.$fBitsInt3_closure+1;
         const GHC.Int.$fBitsInt16_$cbit_closure+1;
         const GHC.Int.$fBitsInt16_$csetBit_closure+2;
         const GHC.Int.$fBitsInt16_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt16_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt16_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt16_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt16_$crotateL_closure+2;
         const GHC.Int.$fBitsInt16_$crotateR_closure+2;
         const GHC.Int.$fBitsInt16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.280162548 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_closure" {
     GHC.Int.$fFiniteBitsInt16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt16_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.283532205 UTC

[section ""data" . GHC.Int.$fReadInt16_go_closure" {
     GHC.Int.$fReadInt16_go_closure:
         const GHC.Int.$fReadInt16_go_info;
 },
 sat_s4lhF_entry() //  [R1]
         { info_tbl: [(c4u4S,
                       label: sat_s4lhF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u4S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u4T; else goto c4u4U;
       c4u4T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4u4U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lhD_entry() //  [R1]
         { info_tbl: [(c4u52,
                       label: sat_s4lhD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u52: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4u59; else goto c4u5a;
       c4u59: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4u5a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4u4Z_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4u5e; else goto c4u50;
       u4u5e: // global
           call _c4u4Z(R1) args: 0, res: 0, upd: 0;
       c4u50: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4u4Z() //  [R1]
         { info_tbl: [(c4u4Z,
                       label: block_c4u4Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u4Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u5d; else goto c4u5c;
       c4u5d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4u5c: // global
           _s4lhC::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lhC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt16_go_entry() //  [R2]
         { info_tbl: [(c4u5j,
                       label: GHC.Int.$fReadInt16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u5j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u5k; else goto c4u5l;
       c4u5k: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4u5l: // global
           I64[Sp - 8] = block_c4u4D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4u5v; else goto c4u4E;
       u4u5v: // global
           call _c4u4D(R1) args: 0, res: 0, upd: 0;
       c4u4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u4D() //  [R1]
         { info_tbl: [(c4u4D,
                       label: block_c4u4D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u4D: // global
           if (R1 & 7 == 1) goto c4u5g; else goto c4u5h;
       c4u5g: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u5h: // global
           I64[Sp - 8] = block_c4u4J_info;
           _s4lhw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lhw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4u5u; else goto c4u4K;
       u4u5u: // global
           call _c4u4J(R1) args: 0, res: 0, upd: 0;
       c4u4K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u4J() //  [R1]
         { info_tbl: [(c4u4J,
                       label: block_c4u4J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u4J: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4u5t; else goto c4u5s;
       c4u5t: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u5s: // global
           _s4lhy::P64 = P64[R1 + 7];
           _s4lhz::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lhF_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lhD_info;
           P64[Hp - 48] = _s4lhy::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lhz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.302078846 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadsPrec_closure" {
     GHC.Int.$fReadInt16_$creadsPrec_closure:
         const GHC.Int.$fReadInt16_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4u6b,
                       label: GHC.Int.$fReadInt16_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u6b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u6f; else goto c4u6g;
       c4u6f: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u6g: // global
           I64[Sp - 16] = block_c4u69_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lhH::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lhH::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4u69() //  [R1]
         { info_tbl: [(c4u69,
                       label: block_c4u69_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u69: // global
           _s4lhH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4u6e_info;
           R3 = _s4lhH::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4u6e() //  [R1]
         { info_tbl: [(c4u6e,
                       label: block_c4u6e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u6e: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.31233062 UTC

[section ""data" . GHC.Int.$fReadInt3_closure" {
     GHC.Int.$fReadInt3_closure:
         const GHC.Int.$fReadInt3_info;
         const 0;
 },
 sat_s4lhM_entry() //  [R1, R2]
         { info_tbl: [(c4u6G,
                       label: sat_s4lhM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u6G: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt16_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt3_entry() //  [R2, R3]
         { info_tbl: [(c4u6M,
                       label: GHC.Int.$fReadInt3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u6M: // global
           _s4lhL::P64 = R3;
           _s4lhK::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4u6N; else goto c4u6O;
       c4u6O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u6Q; else goto c4u6P;
       c4u6Q: // global
           HpAlloc = 16;
           goto c4u6N;
       c4u6N: // global
           R3 = _s4lhL::P64;
           R2 = _s4lhK::P64;
           R1 = GHC.Int.$fReadInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u6P: // global
           I64[Hp - 8] = sat_s4lhM_info;
           P64[Hp] = _s4lhK::P64;
           I64[Sp - 8] = block_c4u6J_info;
           R3 = _s4lhL::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4u6J() //  [R1]
         { info_tbl: [(c4u6J,
                       label: block_c4u6J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u6J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u6T; else goto c4u6S;
       c4u6T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u6S: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.322254441 UTC

[section ""data" . GHC.Int.$fReadInt2_closure" {
     GHC.Int.$fReadInt2_closure:
         const GHC.Int.$fReadInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt2_entry() //  [R1]
         { info_tbl: [(c4u7c,
                       label: GHC.Int.$fReadInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u7c: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4u7d; else goto c4u7e;
       c4u7d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4u7e: // global
           (_c4u79::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4u79::I64 == 0) goto c4u7b; else goto c4u7a;
       c4u7b: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4u7a: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4u79::I64;
           R2 = GHC.Int.$fReadInt3_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.327685814 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadList_closure" {
     GHC.Int.$fReadInt16_$creadList_closure:
         const GHC.Int.$fReadInt16_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadList_entry() //  [R2]
         { info_tbl: [(c4u7q,
                       label: GHC.Int.$fReadInt16_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u7q: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt2_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.33225583 UTC

[section ""data" . GHC.Int.$fReadInt1_closure" {
     GHC.Int.$fReadInt1_closure:
         const GHC.Int.$fReadInt1_info;
         const 0;
 },
 GHC.Int.$fReadInt1_entry() //  [R2, R3]
         { info_tbl: [(c4u7E,
                       label: GHC.Int.$fReadInt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u7E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4u7F; else goto c4u7G;
       c4u7F: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u7G: // global
           I64[Sp - 8] = block_c4u7B_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt16_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4u7B() //  [R1]
         { info_tbl: [(c4u7B,
                       label: block_c4u7B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u7B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u7J; else goto c4u7I;
       c4u7J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u7I: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.33854482 UTC

[section ""data" . GHC.Int.$fReadInt16_closure" {
     GHC.Int.$fReadInt16_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt16_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt16_$creadList_closure+1;
         const GHC.Int.$fReadInt3_closure+2;
         const GHC.Int.$fReadInt1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.34116634 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquot_closure" {
     GHC.Int.$fIntegralInt16_$cquot_closure:
         const GHC.Int.$fIntegralInt16_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4u81,
                       label: GHC.Int.$fIntegralInt16_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u81: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u85; else goto c4u86;
       c4u85: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u86: // global
           I64[Sp - 16] = block_c4u7Y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u8H; else goto c4u7Z;
       u4u8H: // global
           call _c4u7Y(R1) args: 0, res: 0, upd: 0;
       c4u7Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u7Y() //  [R1]
         { info_tbl: [(c4u7Y,
                       label: block_c4u7Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u7Y: // global
           I64[Sp] = block_c4u84_info;
           _s4lhW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lhW::I64;
           if (R1 & 7 != 0) goto u4u8G; else goto c4u88;
       u4u8G: // global
           call _c4u84(R1) args: 0, res: 0, upd: 0;
       c4u88: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u84() //  [R1]
         { info_tbl: [(c4u84,
                       label: block_c4u84_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u84: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u8e; else goto c4u8d;
       c4u8e: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u8d: // global
           _s4lhW::I64 = I64[Sp + 8];
           _s4lhZ::I64 = I64[R1 + 7];
           if (_s4lhZ::I64 != (-1)) goto u4u8F; else goto c4u8D;
       u4u8F: // global
           if (_s4lhZ::I64 != 0) goto c4u8p; else goto c4u8E;
       c4u8p: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4lhW::I64,
                                                                            _s4lhZ::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u8E: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4u8D: // global
           if (_s4lhW::I64 == (-32768)) goto c4u8C; else goto c4u8B;
       c4u8C: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4u8B: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4lhW::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.350965454 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$crem_closure" {
     GHC.Int.$fIntegralInt16_$crem_closure:
         const GHC.Int.$fIntegralInt16_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4u99,
                       label: GHC.Int.$fIntegralInt16_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u99: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u9d; else goto c4u9e;
       c4u9d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u9e: // global
           I64[Sp - 16] = block_c4u96_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u9A; else goto c4u97;
       u4u9A: // global
           call _c4u96(R1) args: 0, res: 0, upd: 0;
       c4u97: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u96() //  [R1]
         { info_tbl: [(c4u96,
                       label: block_c4u96_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u96: // global
           I64[Sp] = block_c4u9c_info;
           _s4lia::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lia::I64;
           if (R1 & 7 != 0) goto u4u9z; else goto c4u9g;
       u4u9z: // global
           call _c4u9c(R1) args: 0, res: 0, upd: 0;
       c4u9g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4u9c() //  [R1]
         { info_tbl: [(c4u9c,
                       label: block_c4u9c_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4u9c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u9m; else goto c4u9l;
       c4u9m: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u9l: // global
           _s4lid::I64 = I64[R1 + 7];
           if (_s4lid::I64 != 0) goto c4u9x; else goto c4u9y;
       c4u9x: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4lid::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u9y: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.361019359 UTC

[section ""data" . GHC.Int.$w$cdiv_closure" {
     GHC.Int.$w$cdiv_closure:
         const GHC.Int.$w$cdiv_info;
         const 0;
 },
 GHC.Int.$w$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4ua0,
                       label: GHC.Int.$w$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ua0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ua1; else goto c4ua2;
       c4ua1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ua2: // global
           if (R3 == (-1)) goto c4u9Y; else goto u4uam;
       c4u9Y: // global
           if (R2 == (-32768)) goto c4ual; else goto c4uaj;
       c4ual: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uaj: // global
           I64[Sp - 8] = block_c4uad_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4uam: // global
           if (R3 == 0) goto c4u9Z; else goto c4u9X;
       c4u9Z: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4u9X: // global
           I64[Sp - 8] = block_c4ua4_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uad() //  [R1]
         { info_tbl: [(c4uad,
                       label: block_c4uad_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uad: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4ua4() //  [R1]
         { info_tbl: [(c4ua4,
                       label: block_c4ua4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ua4: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.3696833 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdiv_closure" {
     GHC.Int.$fIntegralInt16_$cdiv_closure:
         const GHC.Int.$fIntegralInt16_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4uaJ,
                       label: GHC.Int.$fIntegralInt16_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uaJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uaW; else goto c4uaX;
       c4uaW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uaX: // global
           I64[Sp - 16] = block_c4uaG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ub4; else goto c4uaH;
       u4ub4: // global
           call _c4uaG(R1) args: 0, res: 0, upd: 0;
       c4uaH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uaG() //  [R1]
         { info_tbl: [(c4uaG,
                       label: block_c4uaG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uaG: // global
           I64[Sp] = block_c4uaM_info;
           _s4lir::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lir::I64;
           if (R1 & 7 != 0) goto u4ub3; else goto c4uaN;
       u4ub3: // global
           call _c4uaM(R1) args: 0, res: 0, upd: 0;
       c4uaN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uaM() //  [R1]
         { info_tbl: [(c4uaM,
                       label: block_c4uaM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uaM: // global
           _s4lir::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4uaR_info;
           R3 = I64[R1 + 7];
           R2 = _s4lir::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uaR() //  [R1]
         { info_tbl: [(c4uaR,
                       label: block_c4uaR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uaR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ub2; else goto c4ub1;
       c4ub2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ub1: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.382166129 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cmod_closure" {
     GHC.Int.$fIntegralInt16_$cmod_closure:
         const GHC.Int.$fIntegralInt16_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4ubt,
                       label: GHC.Int.$fIntegralInt16_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ubt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ubx; else goto c4uby;
       c4ubx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uby: // global
           I64[Sp - 16] = block_c4ubq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ubW; else goto c4ubr;
       u4ubW: // global
           call _c4ubq(R1) args: 0, res: 0, upd: 0;
       c4ubr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ubq() //  [R1]
         { info_tbl: [(c4ubq,
                       label: block_c4ubq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ubq: // global
           I64[Sp] = block_c4ubw_info;
           _s4liy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4liy::I64;
           if (R1 & 7 != 0) goto u4ubV; else goto c4ubA;
       u4ubV: // global
           call _c4ubw(R1) args: 0, res: 0, upd: 0;
       c4ubA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ubw() //  [R1]
         { info_tbl: [(c4ubw,
                       label: block_c4ubw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ubw: // global
           _s4liB::I64 = I64[R1 + 7];
           if (_s4liB::I64 != 0) goto c4ubQ; else goto c4ubU;
       c4ubQ: // global
           _s4liy::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4ubH_info;
           R3 = _s4liB::I64;
           R2 = _s4liy::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4ubU: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4ubH() //  [R1]
         { info_tbl: [(c4ubH,
                       label: block_c4ubH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ubH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ubT; else goto c4ubS;
       c4ubT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ubS: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.397063469 UTC

[section ""data" . lvl7_r4kPy_closure" {
     lvl7_r4kPy_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt3_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.399706065 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquotRem_closure" {
     GHC.Int.$fIntegralInt16_$cquotRem_closure:
         const GHC.Int.$fIntegralInt16_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4uco,
                       label: GHC.Int.$fIntegralInt16_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uco: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ucs; else goto c4uct;
       c4ucs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uct: // global
           I64[Sp - 16] = block_c4ucl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ud8; else goto c4ucm;
       u4ud8: // global
           call _c4ucl(R1) args: 0, res: 0, upd: 0;
       c4ucm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ucl() //  [R1]
         { info_tbl: [(c4ucl,
                       label: block_c4ucl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ucl: // global
           I64[Sp] = block_c4ucr_info;
           _s4liI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4liI::I64;
           if (R1 & 7 != 0) goto u4ud7; else goto c4ucv;
       u4ud7: // global
           call _c4ucr(R1) args: 0, res: 0, upd: 0;
       c4ucv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ucr() //  [R1]
         { info_tbl: [(c4ucr,
                       label: block_c4ucr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ucr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4ucB; else goto c4ucA;
       c4ucB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ucA: // global
           _s4liI::I64 = I64[Sp + 8];
           _s4liL::I64 = I64[R1 + 7];
           if (_s4liL::I64 != (-1)) goto u4ud6; else goto c4ud4;
       u4ud6: // global
           if (_s4liL::I64 != 0) goto c4ucO; else goto c4ud5;
       c4ucO: // global
           (_s4liN::I64, _s4liO::I64) = call MO_S_QuotRem W64(_s4liI::I64, _s4liL::I64);
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liO::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liN::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ud5: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4ud4: // global
           if (_s4liI::I64 == (-32768)) goto c4ud3; else goto c4ud2;
       c4ud3: // global
           Hp = Hp - 56;
           R1 = lvl7_r4kPy_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ud2: // global
           (_s4liV::I64, _s4liW::I64) = call MO_S_QuotRem W64(_s4liI::I64, (-1));
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liW::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liV::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.411953696 UTC

[section ""data" . GHC.Int.$w$cdivMod_closure" {
     GHC.Int.$w$cdivMod_closure:
         const GHC.Int.$w$cdivMod_info;
         const 0;
 },
 section ""relreadonly" . u4ugk_srtd" {
     u4ugk_srtd:
         const S4lDl_srt+536;
         const 33;
         const 4294967299;
 },
 GHC.Int.$w$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4udK,
                       label: GHC.Int.$w$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4udK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4udL; else goto c4udM;
       c4udL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4udM: // global
           if (R3 == 0) goto c4udJ; else goto c4udI;
       c4udJ: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4udI: // global
           if (R3 == (-1)) goto c4ugf; else goto u4ugg;
       c4ugf: // global
           if (R2 == (-32768)) goto c4uge; else goto u4ugh;
       c4uge: // global
           R2 = GHC.Int.$fBitsInt3_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4ugh: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4ugj;
       u4ugg: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4ugj;
       u4ugj: // global
           call _c4udR() args: 0, res: 0, upd: 0;
     }
 },
 _c4udR() //  []
         { info_tbl: [(c4udR,
                       label: block_c4udR_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4udR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4udV; else goto c4udU;
       c4udV: // global
           HpAlloc = 32;
           I64[Sp] = block_c4udR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4udU: // global
           _s4lj2::I64 = I64[Sp + 8];
           _s4lj4::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lj2::I64, 0)) goto c4ueO; else goto c4ug5;
       c4ueO: // global
           if (%MO_S_Ge_W64(_s4lj2::I64, 0)) goto c4ueb; else goto c4ueM;
       c4ueb: // global
           (_s4lj9::I64, _s4lja::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lja::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lj9::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ueM: // global
           if (%MO_S_Le_W64(_s4lj4::I64, 0)) goto c4uep; else goto c4ueL;
       c4uep: // global
           (_s4ljh::I64, _s4lji::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lji::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljh::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ueL: // global
           (_s4ljp::I64, _s4ljq::I64) = call MO_S_QuotRem W64(_s4lj2::I64 + 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljq::I64 + _s4lj4::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljp::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ug5: // global
           if (%MO_S_Ge_W64(_s4lj4::I64, 0)) goto c4ufI; else goto c4ug4;
       c4ufI: // global
           if (%MO_S_Ge_W64(_s4lj2::I64, 0)) goto c4uf5; else goto c4ufG;
       c4uf5: // global
           (_s4ljB::I64, _s4ljC::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljC::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljB::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ufG: // global
           if (%MO_S_Le_W64(_s4lj4::I64, 0)) goto c4ufj; else goto c4ufF;
       c4ufj: // global
           (_s4ljJ::I64, _s4ljK::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljK::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljJ::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ufF: // global
           (_s4ljR::I64, _s4ljS::I64) = call MO_S_QuotRem W64(_s4lj2::I64 + 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljS::I64 + _s4lj4::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljR::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ug4: // global
           (_s4lk2::I64, _s4lk3::I64) = call MO_S_QuotRem W64(_s4lj2::I64 - 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lk3::I64 + _s4lj4::I64 + 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lk2::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.425429583 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdivMod_closure" {
     GHC.Int.$fIntegralInt16_$cdivMod_closure:
         const GHC.Int.$fIntegralInt16_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4uhh,
                       label: GHC.Int.$fIntegralInt16_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uhh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uhs; else goto c4uht;
       c4uhs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uht: // global
           I64[Sp - 16] = block_c4uhe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uhA; else goto c4uhf;
       u4uhA: // global
           call _c4uhe(R1) args: 0, res: 0, upd: 0;
       c4uhf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uhe() //  [R1]
         { info_tbl: [(c4uhe,
                       label: block_c4uhe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uhe: // global
           I64[Sp] = block_c4uhk_info;
           _s4lkh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkh::I64;
           if (R1 & 7 != 0) goto u4uhz; else goto c4uhl;
       u4uhz: // global
           call _c4uhk(R1) args: 0, res: 0, upd: 0;
       c4uhl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uhk() //  [R1]
         { info_tbl: [(c4uhk,
                       label: block_c4uhk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uhk: // global
           _s4lkh::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4uhp_info;
           R3 = I64[R1 + 7];
           R2 = _s4lkh::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uhp() //  [R1, R2]
         { info_tbl: [(c4uhp,
                       label: block_c4uhp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uhp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4uhy; else goto c4uhx;
       c4uhy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4uhx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.436226904 UTC

[section ""data" . GHC.Int.$fRealInt16_$ctoRational_closure" {
     GHC.Int.$fRealInt16_$ctoRational_closure:
         const GHC.Int.$fRealInt16_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt16_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4uhZ,
                       label: GHC.Int.$fRealInt16_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uhZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uid; else goto c4uie;
       c4uid: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uie: // global
           I64[Sp - 8] = block_c4uhW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uil; else goto c4uhX;
       u4uil: // global
           call _c4uhW(R1) args: 0, res: 0, upd: 0;
       c4uhX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uhW() //  [R1]
         { info_tbl: [(c4uhW,
                       label: block_c4uhW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uhW: // global
           I64[Sp] = block_c4ui2_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ui2() //  [R1]
         { info_tbl: [(c4ui2,
                       label: block_c4ui2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ui2: // global
           I64[Sp] = block_c4ui6_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ui6() //  [R1]
         { info_tbl: [(c4ui6,
                       label: block_c4ui6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ui6: // global
           I64[Sp] = block_c4uia_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uia() //  [R1, R2]
         { info_tbl: [(c4uia,
                       label: block_c4uia_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uia: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4uik; else goto c4uij;
       c4uik: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4uij: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.448390503 UTC

[section ""data" . GHC.Int.$fRealInt16_closure" {
     GHC.Int.$fRealInt16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt16_closure+1;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fRealInt16_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.450688441 UTC

[section ""data" . GHC.Int.$fIntegralInt16_closure" {
     GHC.Int.$fIntegralInt16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt16_closure+1;
         const GHC.Int.$fEnumInt16_closure+1;
         const GHC.Int.$fIntegralInt16_$cquot_closure+2;
         const GHC.Int.$fIntegralInt16_$crem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt16_$cmod_closure+2;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt16_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.453649549 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt16_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt16_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt16_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4uiO,
                       label: GHC.Int.$fIxInt16_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uiO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uj5; else goto c4uj6;
       c4uj5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uj6: // global
           I64[Sp - 16] = block_c4uiL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ujd; else goto c4uiM;
       u4ujd: // global
           call _c4uiL(R1) args: 0, res: 0, upd: 0;
       c4uiM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uiL() //  [R1]
         { info_tbl: [(c4uiL,
                       label: block_c4uiL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uiL: // global
           I64[Sp] = block_c4uiR_info;
           _s4lky::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lky::P64;
           if (R1 & 7 != 0) goto u4ujc; else goto c4uiS;
       u4ujc: // global
           call _c4uiR(R1) args: 0, res: 0, upd: 0;
       c4uiS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uiR() //  [R1]
         { info_tbl: [(c4uiR,
                       label: block_c4uiR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uiR: // global
           I64[Sp] = block_c4uiW_info;
           _s4lkB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkB::I64;
           if (R1 & 7 != 0) goto u4uje; else goto c4uiX;
       u4uje: // global
           call _c4uiW(R1) args: 0, res: 0, upd: 0;
       c4uiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uiW() //  [R1]
         { info_tbl: [(c4uiW,
                       label: block_c4uiW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uiW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ujb; else goto c4uja;
       c4ujb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uja: // global
           _s4lkE::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lkE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.466569102 UTC

[section ""data" . GHC.Int.$fIxInt16_$crange_closure" {
     GHC.Int.$fIxInt16_$crange_closure:
         const GHC.Int.$fIxInt16_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$crange_entry() //  [R2]
         { info_tbl: [(c4ujG,
                       label: GHC.Int.$fIxInt16_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ujG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ujH; else goto c4ujI;
       c4ujH: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ujI: // global
           I64[Sp - 8] = block_c4ujD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ujM; else goto c4ujE;
       u4ujM: // global
           call _c4ujD(R1) args: 0, res: 0, upd: 0;
       c4ujE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ujD() //  [R1]
         { info_tbl: [(c4ujD,
                       label: block_c4ujD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ujD: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.47314021 UTC

[section ""data" . GHC.Int.$fIxInt16_$crangeSize_closure" {
     GHC.Int.$fIxInt16_$crangeSize_closure:
         const GHC.Int.$fIxInt16_$crangeSize_info;
 },
 GHC.Int.$fIxInt16_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4uk3,
                       label: GHC.Int.$fIxInt16_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uk3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ukc; else goto c4ukd;
       c4ukc: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ukd: // global
           I64[Sp - 8] = block_c4uk0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ukC; else goto c4uk1;
       u4ukC: // global
           call _c4uk0(R1) args: 0, res: 0, upd: 0;
       c4uk1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uk0() //  [R1]
         { info_tbl: [(c4uk0,
                       label: block_c4uk0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uk0: // global
           I64[Sp - 8] = block_c4uk6_info;
           _s4lkM::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lkM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ukB; else goto c4uk7;
       u4ukB: // global
           call _c4uk6(R1) args: 0, res: 0, upd: 0;
       c4uk7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uk6() //  [R1]
         { info_tbl: [(c4uk6,
                       label: block_c4uk6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uk6: // global
           I64[Sp] = block_c4ukb_info;
           _s4lkO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkO::I64;
           if (R1 & 7 != 0) goto u4ukD; else goto c4ukg;
       u4ukD: // global
           call _c4ukb(R1) args: 0, res: 0, upd: 0;
       c4ukg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ukb() //  [R1]
         { info_tbl: [(c4ukb,
                       label: block_c4ukb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ukb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ukm; else goto c4ukl;
       c4ukm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ukl: // global
           _s4lkO::I64 = I64[Sp + 8];
           _s4lkQ::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lkO::I64,
                            _s4lkQ::I64)) goto c4ukq; else goto c4ukA;
       c4ukq: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ukA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lkQ::I64 - _s4lkO::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.485541425 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt16_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt16_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4ul7,
                       label: GHC.Int.$fIxInt16_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ul7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ulr; else goto c4uls;
       c4ulr: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uls: // global
           I64[Sp - 8] = block_c4ul4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ulz; else goto c4ul5;
       u4ulz: // global
           call _c4ul4(R1) args: 0, res: 0, upd: 0;
       c4ul5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ul4() //  [R1]
         { info_tbl: [(c4ul4,
                       label: block_c4ul4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ul4: // global
           I64[Sp - 8] = block_c4ula_info;
           _s4lkW::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lkW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uly; else goto c4ulb;
       u4uly: // global
           call _c4ula(R1) args: 0, res: 0, upd: 0;
       c4ulb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ula() //  [R1]
         { info_tbl: [(c4ula,
                       label: block_c4ula_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ula: // global
           I64[Sp] = block_c4ulf_info;
           _s4lkZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkZ::I64;
           if (R1 & 7 != 0) goto u4ulA; else goto c4ulg;
       u4ulA: // global
           call _c4ulf(R1) args: 0, res: 0, upd: 0;
       c4ulg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ulf() //  [R1]
         { info_tbl: [(c4ulf,
                       label: block_c4ulf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ulf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ulx; else goto c4ulw;
       c4ulx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ulw: // global
           _s4ll3::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4ll3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.497950974 UTC

[section ""data" . GHC.Int.$fIxInt16_$cindex_closure" {
     GHC.Int.$fIxInt16_$cindex_closure:
         const GHC.Int.$fIxInt16_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4um3,
                       label: GHC.Int.$fIxInt16_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4um3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4umc; else goto c4umd;
       c4umc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4umd: // global
           I64[Sp - 16] = block_c4um0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4umM; else goto c4um1;
       u4umM: // global
           call _c4um0(R1) args: 0, res: 0, upd: 0;
       c4um1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4um0() //  [R1]
         { info_tbl: [(c4um0,
                       label: block_c4um0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4um0: // global
           I64[Sp - 8] = block_c4um6_info;
           _s4ll8::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4ll8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4umL; else goto c4um7;
       u4umL: // global
           call _c4um6(R1) args: 0, res: 0, upd: 0;
       c4um7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4um6() //  [R1]
         { info_tbl: [(c4um6,
                       label: block_c4um6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4um6: // global
           I64[Sp] = block_c4umb_info;
           _s4lla::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lla::I64;
           if (R1 & 7 != 0) goto u4umN; else goto c4umg;
       u4umN: // global
           call _c4umb(R1) args: 0, res: 0, upd: 0;
       c4umg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4umb() //  [R1]
         { info_tbl: [(c4umb,
                       label: block_c4umb_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4umb: // global
           _s4llc::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4llc::I64)) goto c4umo; else goto c4ums;
       c4umo: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ums: // global
           I64[Sp] = block_c4umr_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llc::I64;
           if (R1 & 7 != 0) goto u4umO; else goto c4umt;
       u4umO: // global
           call _c4umr(R1) args: 0, res: 0, upd: 0;
       c4umt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4umr() //  [R1]
         { info_tbl: [(c4umr,
                       label: block_c4umr_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4umr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4umz; else goto c4umy;
       c4umz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4umy: // global
           _s4llc::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4llc::I64,
                            I64[R1 + 7])) goto c4umD; else goto c4umK;
       c4umD: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4umK: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4llc::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.518859029 UTC

[section ""data" . GHC.Int.$fIxInt16_closure" {
     GHC.Int.$fIxInt16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fIxInt16_$crange_closure+1;
         const GHC.Int.$fIxInt16_$cindex_closure+2;
         const GHC.Int.$fIxInt16_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt16_$cinRange_closure+2;
         const GHC.Int.$fIxInt16_$crangeSize_closure+1;
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.522507742 UTC

[section ""data" . GHC.Int.eqInt32_closure" {
     GHC.Int.eqInt32_closure:
         const GHC.Int.eqInt32_info;
 },
 GHC.Int.eqInt32_entry() //  [R2, R3]
         { info_tbl: [(c4unn,
                       label: GHC.Int.eqInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4unn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4unr; else goto c4uns;
       c4unr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uns: // global
           I64[Sp - 16] = block_c4unk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4unB; else goto c4unl;
       u4unB: // global
           call _c4unk(R1) args: 0, res: 0, upd: 0;
       c4unl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4unk() //  [R1]
         { info_tbl: [(c4unk,
                       label: block_c4unk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4unk: // global
           I64[Sp] = block_c4unq_info;
           _s4lll::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lll::I64;
           if (R1 & 7 != 0) goto u4unA; else goto c4unu;
       u4unA: // global
           call _c4unq(R1) args: 0, res: 0, upd: 0;
       c4unu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4unq() //  [R1]
         { info_tbl: [(c4unq,
                       label: block_c4unq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4unq: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.53473937 UTC

[section ""data" . GHC.Int.$fEqInt32_closure" {
     GHC.Int.$fEqInt32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt32_closure+2;
         const GHC.Int.neInt32_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.538281407 UTC

[section ""data" . GHC.Int.gtInt32_closure" {
     GHC.Int.gtInt32_closure:
         const GHC.Int.gtInt32_info;
 },
 GHC.Int.gtInt32_entry() //  [R2, R3]
         { info_tbl: [(c4uo1,
                       label: GHC.Int.gtInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uo1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uo5; else goto c4uo6;
       c4uo5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uo6: // global
           I64[Sp - 16] = block_c4unY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uof; else goto c4unZ;
       u4uof: // global
           call _c4unY(R1) args: 0, res: 0, upd: 0;
       c4unZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4unY() //  [R1]
         { info_tbl: [(c4unY,
                       label: block_c4unY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4unY: // global
           I64[Sp] = block_c4uo4_info;
           _s4lls::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lls::I64;
           if (R1 & 7 != 0) goto u4uoe; else goto c4uo8;
       u4uoe: // global
           call _c4uo4(R1) args: 0, res: 0, upd: 0;
       c4uo8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uo4() //  [R1]
         { info_tbl: [(c4uo4,
                       label: block_c4uo4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uo4: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.54772338 UTC

[section ""data" . GHC.Int.geInt32_closure" {
     GHC.Int.geInt32_closure:
         const GHC.Int.geInt32_info;
 },
 GHC.Int.geInt32_entry() //  [R2, R3]
         { info_tbl: [(c4uoE,
                       label: GHC.Int.geInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uoE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uoI; else goto c4uoJ;
       c4uoI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uoJ: // global
           I64[Sp - 16] = block_c4uoB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uoS; else goto c4uoC;
       u4uoS: // global
           call _c4uoB(R1) args: 0, res: 0, upd: 0;
       c4uoC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uoB() //  [R1]
         { info_tbl: [(c4uoB,
                       label: block_c4uoB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uoB: // global
           I64[Sp] = block_c4uoH_info;
           _s4llz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llz::I64;
           if (R1 & 7 != 0) goto u4uoR; else goto c4uoL;
       u4uoR: // global
           call _c4uoH(R1) args: 0, res: 0, upd: 0;
       c4uoL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uoH() //  [R1]
         { info_tbl: [(c4uoH,
                       label: block_c4uoH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uoH: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.559825574 UTC

[section ""data" . GHC.Int.ltInt32_closure" {
     GHC.Int.ltInt32_closure:
         const GHC.Int.ltInt32_info;
 },
 GHC.Int.ltInt32_entry() //  [R2, R3]
         { info_tbl: [(c4uph,
                       label: GHC.Int.ltInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uph: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4upl; else goto c4upm;
       c4upl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4upm: // global
           I64[Sp - 16] = block_c4upe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4upv; else goto c4upf;
       u4upv: // global
           call _c4upe(R1) args: 0, res: 0, upd: 0;
       c4upf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4upe() //  [R1]
         { info_tbl: [(c4upe,
                       label: block_c4upe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4upe: // global
           I64[Sp] = block_c4upk_info;
           _s4llG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llG::I64;
           if (R1 & 7 != 0) goto u4upu; else goto c4upo;
       u4upu: // global
           call _c4upk(R1) args: 0, res: 0, upd: 0;
       c4upo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4upk() //  [R1]
         { info_tbl: [(c4upk,
                       label: block_c4upk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4upk: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.570680394 UTC

[section ""data" . GHC.Int.leInt32_closure" {
     GHC.Int.leInt32_closure:
         const GHC.Int.leInt32_info;
 },
 GHC.Int.leInt32_entry() //  [R2, R3]
         { info_tbl: [(c4upU,
                       label: GHC.Int.leInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4upU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4upY; else goto c4upZ;
       c4upY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4upZ: // global
           I64[Sp - 16] = block_c4upR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uq8; else goto c4upS;
       u4uq8: // global
           call _c4upR(R1) args: 0, res: 0, upd: 0;
       c4upS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4upR() //  [R1]
         { info_tbl: [(c4upR,
                       label: block_c4upR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4upR: // global
           I64[Sp] = block_c4upX_info;
           _s4llN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llN::I64;
           if (R1 & 7 != 0) goto u4uq7; else goto c4uq1;
       u4uq7: // global
           call _c4upX(R1) args: 0, res: 0, upd: 0;
       c4uq1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4upX() //  [R1]
         { info_tbl: [(c4upX,
                       label: block_c4upX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4upX: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.581669514 UTC

[section ""data" . GHC.Int.$fOrdInt32_$ccompare_closure" {
     GHC.Int.$fOrdInt32_$ccompare_closure:
         const GHC.Int.$fOrdInt32_$ccompare_info;
 },
 GHC.Int.$fOrdInt32_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4uqx,
                       label: GHC.Int.$fOrdInt32_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uqx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uqB; else goto c4uqC;
       c4uqB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uqC: // global
           I64[Sp - 16] = block_c4uqu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uqV; else goto c4uqv;
       u4uqV: // global
           call _c4uqu(R1) args: 0, res: 0, upd: 0;
       c4uqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uqu() //  [R1]
         { info_tbl: [(c4uqu,
                       label: block_c4uqu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uqu: // global
           I64[Sp] = block_c4uqA_info;
           _s4llU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llU::I64;
           if (R1 & 7 != 0) goto u4uqU; else goto c4uqE;
       u4uqU: // global
           call _c4uqA(R1) args: 0, res: 0, upd: 0;
       c4uqE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uqA() //  [R1]
         { info_tbl: [(c4uqA,
                       label: block_c4uqA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uqA: // global
           _s4llU::I64 = I64[Sp + 8];
           _s4llW::I64 = I64[R1 + 7];
           if (_s4llU::I64 == _s4llW::I64) goto c4uqT; else goto c4uqS;
       c4uqT: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uqS: // global
           if (%MO_S_Gt_W64(_s4llU::I64,
                            _s4llW::I64)) goto c4uqP; else goto c4uqQ;
       c4uqP: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uqQ: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.591663007 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmax_closure" {
     GHC.Int.$fOrdInt32_$cmax_closure:
         const GHC.Int.$fOrdInt32_$cmax_info;
 },
 GHC.Int.$fOrdInt32_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4urj,
                       label: GHC.Int.$fOrdInt32_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4urj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4urn; else goto c4uro;
       c4urn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uro: // global
           I64[Sp - 16] = block_c4urg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4urB; else goto c4urh;
       u4urB: // global
           call _c4urg(R1) args: 0, res: 0, upd: 0;
       c4urh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4urg() //  [R1]
         { info_tbl: [(c4urg,
                       label: block_c4urg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4urg: // global
           I64[Sp - 8] = block_c4urm_info;
           _s4lm1::P64 = R1;
           _s4lm2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lm2::I64;
           P64[Sp + 8] = _s4lm1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4urA; else goto c4urq;
       u4urA: // global
           call _c4urm(R1) args: 0, res: 0, upd: 0;
       c4urq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4urm() //  [R1]
         { info_tbl: [(c4urm,
                       label: block_c4urm_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4urm: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4ury; else goto c4urz;
       c4ury: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4urz: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.600445601 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmin_closure" {
     GHC.Int.$fOrdInt32_$cmin_closure:
         const GHC.Int.$fOrdInt32_$cmin_info;
 },
 GHC.Int.$fOrdInt32_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4us1,
                       label: GHC.Int.$fOrdInt32_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4us1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4us5; else goto c4us6;
       c4us5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4us6: // global
           I64[Sp - 16] = block_c4urY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4usj; else goto c4urZ;
       u4usj: // global
           call _c4urY(R1) args: 0, res: 0, upd: 0;
       c4urZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4urY() //  [R1]
         { info_tbl: [(c4urY,
                       label: block_c4urY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4urY: // global
           I64[Sp - 8] = block_c4us4_info;
           _s4lm8::P64 = R1;
           _s4lm9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lm9::I64;
           P64[Sp + 8] = _s4lm8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4usi; else goto c4us8;
       u4usi: // global
           call _c4us4(R1) args: 0, res: 0, upd: 0;
       c4us8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4us4() //  [R1]
         { info_tbl: [(c4us4,
                       label: block_c4us4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4us4: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4usg; else goto c4ush;
       c4usg: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ush: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.608909809 UTC

[section ""data" . GHC.Int.$fOrdInt32_closure" {
     GHC.Int.$fOrdInt32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fOrdInt32_$ccompare_closure+2;
         const GHC.Int.ltInt32_closure+2;
         const GHC.Int.leInt32_closure+2;
         const GHC.Int.gtInt32_closure+2;
         const GHC.Int.geInt32_closure+2;
         const GHC.Int.$fOrdInt32_$cmax_closure+2;
         const GHC.Int.$fOrdInt32_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.611812684 UTC

[section ""data" . GHC.Int.$fIxInt32_$cinRange_closure" {
     GHC.Int.$fIxInt32_$cinRange_closure:
         const GHC.Int.$fIxInt32_$cinRange_info;
 },
 GHC.Int.$fIxInt32_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4usK,
                       label: GHC.Int.$fIxInt32_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4usK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4usT; else goto c4usU;
       c4usT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4usU: // global
           I64[Sp - 16] = block_c4usH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uth; else goto c4usI;
       u4uth: // global
           call _c4usH(R1) args: 0, res: 0, upd: 0;
       c4usI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4usH() //  [R1]
         { info_tbl: [(c4usH,
                       label: block_c4usH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4usH: // global
           I64[Sp - 8] = block_c4usN_info;
           _s4lmh::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lmh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4utg; else goto c4usO;
       u4utg: // global
           call _c4usN(R1) args: 0, res: 0, upd: 0;
       c4usO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4usN() //  [R1]
         { info_tbl: [(c4usN,
                       label: block_c4usN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4usN: // global
           I64[Sp] = block_c4usS_info;
           _s4lmj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lmj::I64;
           if (R1 & 7 != 0) goto u4uti; else goto c4usX;
       u4uti: // global
           call _c4usS(R1) args: 0, res: 0, upd: 0;
       c4usX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4usS() //  [R1]
         { info_tbl: [(c4usS,
                       label: block_c4usS_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4usS: // global
           _s4lml::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lml::I64)) goto c4ut5; else goto c4ut9;
       c4ut5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ut9: // global
           _s4lmh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4ut8_info;
           R1 = _s4lmh::P64;
           I64[Sp + 16] = _s4lml::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4utj; else goto c4uta;
       u4utj: // global
           call _c4ut8(R1) args: 0, res: 0, upd: 0;
       c4uta: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ut8() //  [R1]
         { info_tbl: [(c4ut8,
                       label: block_c4ut8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ut8: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.624407072 UTC

[section ""data" . GHC.Int.$fNumInt3_closure" {
     GHC.Int.$fNumInt3_closure:
         const GHC.Int.I32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.626999512 UTC

[section ""data" . GHC.Int.$fNumInt32_$csignum_closure" {
     GHC.Int.$fNumInt32_$csignum_closure:
         const GHC.Int.$fNumInt32_$csignum_info;
 },
 GHC.Int.$fNumInt32_$csignum_entry() //  [R2]
         { info_tbl: [(c4utS,
                       label: GHC.Int.$fNumInt32_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4utS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4utT; else goto c4utU;
       c4utT: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4utU: // global
           I64[Sp - 8] = block_c4utP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uu8; else goto c4utQ;
       u4uu8: // global
           call _c4utP(R1) args: 0, res: 0, upd: 0;
       c4utQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4utP() //  [R1]
         { info_tbl: [(c4utP,
                       label: block_c4utP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4utP: // global
           _s4lms::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lms::I64, 0)) goto c4uu6; else goto c4uu7;
       c4uu6: // global
           if (_s4lms::I64 == 0) goto c4uu4; else goto c4uu3;
       c4uu4: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uu3: // global
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uu7: // global
           R1 = GHC.Int.$fNumInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.63362838 UTC

[section ""data" . GHC.Int.$fNumInt32_$cabs_closure" {
     GHC.Int.$fNumInt32_$cabs_closure:
         const GHC.Int.$fNumInt32_$cabs_info;
 },
 GHC.Int.$fNumInt32_$cabs_entry() //  [R2]
         { info_tbl: [(c4uus,
                       label: GHC.Int.$fNumInt32_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uus: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uut; else goto c4uuu;
       c4uut: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uuu: // global
           I64[Sp - 8] = block_c4uup_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uuN; else goto c4uuq;
       u4uuN: // global
           call _c4uup(R1) args: 0, res: 0, upd: 0;
       c4uuq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uup() //  [R1]
         { info_tbl: [(c4uup,
                       label: block_c4uup_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uup: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uuz; else goto c4uuy;
       c4uuz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uuy: // global
           _s4lmx::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lmx::I64, 0)) goto c4uuL; else goto c4uuM;
       c4uuL: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-_s4lmx::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uuM: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.640550912 UTC

[section ""data" . GHC.Int.$fNumInt32_closure" {
     GHC.Int.$fNumInt32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt32_$c+_closure+2;
         const GHC.Int.$fNumInt32_$c-_closure+2;
         const GHC.Int.$fNumInt32_$c*_closure+2;
         const GHC.Int.$fNumInt32_$cnegate_closure+1;
         const GHC.Int.$fNumInt32_$cabs_closure+1;
         const GHC.Int.$fNumInt32_$csignum_closure+1;
         const GHC.Int.$fNumInt32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.643043095 UTC

[section ""data" . GHC.Int.$fBitsInt5_closure" {
     GHC.Int.$fBitsInt5_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.645047571 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt32_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4uv8,
                       label: GHC.Int.$fBitsInt32_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uv8: // global
           R1 = GHC.Int.$fBitsInt5_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.649411885 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbit_closure" {
     GHC.Int.$fBitsInt32_$cbit_closure:
         const GHC.Int.$fBitsInt32_$cbit_info;
 },
 GHC.Int.$fBitsInt32_$cbit_entry() //  [R2]
         { info_tbl: [(c4uvn,
                       label: GHC.Int.$fBitsInt32_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uvn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uvo; else goto c4uvp;
       c4uvo: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uvp: // global
           I64[Sp - 8] = block_c4uvk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uvI; else goto c4uvl;
       u4uvI: // global
           call _c4uvk(R1) args: 0, res: 0, upd: 0;
       c4uvl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uvk() //  [R1]
         { info_tbl: [(c4uvk,
                       label: block_c4uvk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uvk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uvu; else goto c4uvt;
       c4uvu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uvt: // global
           _s4lmE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lmE::I64, 64)) goto c4uvG; else goto c4uvH;
       c4uvG: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lmE::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uvH: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.656371222 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ctestBit_closure" {
     GHC.Int.$fBitsInt32_$ctestBit_closure:
         const GHC.Int.$fBitsInt32_$ctestBit_info;
 },
 GHC.Int.$fBitsInt32_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4uw3,
                       label: GHC.Int.$fBitsInt32_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uw3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uw7; else goto c4uw8;
       c4uw7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uw8: // global
           I64[Sp - 16] = block_c4uw0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uwQ; else goto c4uw1;
       u4uwQ: // global
           call _c4uw0(R1) args: 0, res: 0, upd: 0;
       c4uw1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uw0() //  [R1]
         { info_tbl: [(c4uw0,
                       label: block_c4uw0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uw0: // global
           I64[Sp] = block_c4uw6_info;
           _s4lmL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lmL::I64;
           if (R1 & 7 != 0) goto u4uwP; else goto c4uwa;
       u4uwP: // global
           call _c4uw6(R1) args: 0, res: 0, upd: 0;
       c4uwa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uw6() //  [R1]
         { info_tbl: [(c4uw6,
                       label: block_c4uw6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uw6: // global
           _s4lmN::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4lmN::I64, 64)) goto c4uwO; else goto c4uwN;
       c4uwN: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lmN::I64)) == 0) goto c4uwO; else goto c4uwC;
       c4uwO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uwC: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.666164236 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateR_closure" {
     GHC.Int.$fBitsInt32_$crotateR_closure:
         const GHC.Int.$fBitsInt32_$crotateR_info;
 },
 GHC.Int.$fBitsInt32_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4uxh,
                       label: GHC.Int.$fBitsInt32_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uxh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uxl; else goto c4uxm;
       c4uxl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uxm: // global
           I64[Sp - 16] = block_c4uxe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uyl; else goto c4uxf;
       u4uyl: // global
           call _c4uxe(R1) args: 0, res: 0, upd: 0;
       c4uxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uxe() //  [R1]
         { info_tbl: [(c4uxe,
                       label: block_c4uxe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uxe: // global
           I64[Sp - 8] = block_c4uxk_info;
           _s4lmX::P64 = R1;
           _s4lmY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lmY::I64;
           P64[Sp + 8] = _s4lmX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uyk; else goto c4uxo;
       u4uyk: // global
           call _c4uxk(R1) args: 0, res: 0, upd: 0;
       c4uxo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uxk() //  [R1]
         { info_tbl: [(c4uxk,
                       label: block_c4uxk_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uxk: // global
           _s4ln4::I64 = -I64[R1 + 7] & 31;
           if (_s4ln4::I64 != 0) goto u4uyi; else goto c4uye;
       u4uyi: // global
           I64[Sp + 16] = _s4ln4::I64;
           Sp = Sp + 8;
           call _c4uxG() args: 0, res: 0, upd: 0;
       c4uye: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4uxG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uxG: // global
           Hp = Hp + 16;
           _s4ln4::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4uyb; else goto c4uya;
       c4uyb: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4uxF_info;
           R1 = _s4ln4::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4uya: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4ln5::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4ln5::I64 << _s4ln4::I64) | (_s4ln5::I64 >> 32 - _s4ln4::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4uxF() //  [R1]
         { info_tbl: [(c4uxF,
                       label: block_c4uxF_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uxF: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4uxG() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.678224681 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt32_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt32_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt32_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4uyY,
                       label: GHC.Int.$fBitsInt32_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uyY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uz2; else goto c4uz3;
       c4uz2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uz3: // global
           I64[Sp - 16] = block_c4uyV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uzC; else goto c4uyW;
       u4uzC: // global
           call _c4uyV(R1) args: 0, res: 0, upd: 0;
       c4uyW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uyV() //  [R1]
         { info_tbl: [(c4uyV,
                       label: block_c4uyV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uyV: // global
           I64[Sp - 8] = block_c4uz1_info;
           _s4lnf::P64 = R1;
           _s4lng::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lng::I64;
           P64[Sp + 8] = _s4lnf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uzB; else goto c4uz5;
       u4uzB: // global
           call _c4uz1(R1) args: 0, res: 0, upd: 0;
       c4uz5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uz1() //  [R1]
         { info_tbl: [(c4uz1,
                       label: block_c4uz1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uz1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uzb; else goto c4uza;
       c4uzb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uza: // global
           _s4lni::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lni::I64, 64)) goto c4uzz; else goto c4uzA;
       c4uzz: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lni::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uzA: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.687846375 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cclearBit_closure" {
     GHC.Int.$fBitsInt32_$cclearBit_closure:
         const GHC.Int.$fBitsInt32_$cclearBit_info;
 },
 GHC.Int.$fBitsInt32_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4uA4,
                       label: GHC.Int.$fBitsInt32_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uA4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uA8; else goto c4uA9;
       c4uA8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uA9: // global
           I64[Sp - 16] = block_c4uA1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uAW; else goto c4uA2;
       u4uAW: // global
           call _c4uA1(R1) args: 0, res: 0, upd: 0;
       c4uA2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uA1() //  [R1]
         { info_tbl: [(c4uA1,
                       label: block_c4uA1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uA1: // global
           I64[Sp] = block_c4uA7_info;
           _s4lnt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lnt::I64;
           if (R1 & 7 != 0) goto u4uAV; else goto c4uAb;
       u4uAV: // global
           call _c4uA7(R1) args: 0, res: 0, upd: 0;
       c4uAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uA7() //  [R1]
         { info_tbl: [(c4uA7,
                       label: block_c4uA7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uA7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uAh; else goto c4uAg;
       c4uAh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uAg: // global
           _s4lnt::I64 = I64[Sp + 8];
           _s4lnv::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lnv::I64, 64)) goto c4uAI; else goto c4uAU;
       c4uAI: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lnt::I64 & ~%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lnv::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uAU: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lnt::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.696721277 UTC

[section ""data" . GHC.Int.$fBitsInt32_$csetBit_closure" {
     GHC.Int.$fBitsInt32_$csetBit_closure:
         const GHC.Int.$fBitsInt32_$csetBit_info;
 },
 GHC.Int.$fBitsInt32_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4uBp,
                       label: GHC.Int.$fBitsInt32_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uBp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uBt; else goto c4uBu;
       c4uBt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uBu: // global
           I64[Sp - 16] = block_c4uBm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uC3; else goto c4uBn;
       u4uC3: // global
           call _c4uBm(R1) args: 0, res: 0, upd: 0;
       c4uBn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uBm() //  [R1]
         { info_tbl: [(c4uBm,
                       label: block_c4uBm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uBm: // global
           I64[Sp - 8] = block_c4uBs_info;
           _s4lnJ::P64 = R1;
           _s4lnK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lnK::I64;
           P64[Sp + 8] = _s4lnJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uC2; else goto c4uBw;
       u4uC2: // global
           call _c4uBs(R1) args: 0, res: 0, upd: 0;
       c4uBw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uBs() //  [R1]
         { info_tbl: [(c4uBs,
                       label: block_c4uBs_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uBs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uBC; else goto c4uBB;
       c4uBC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uBB: // global
           _s4lnM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lnM::I64, 64)) goto c4uC0; else goto c4uC1;
       c4uC0: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lnM::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uC1: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.706665734 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateL_closure" {
     GHC.Int.$fBitsInt32_$crotateL_closure:
         const GHC.Int.$fBitsInt32_$crotateL_info;
 },
 GHC.Int.$fBitsInt32_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4uCs,
                       label: GHC.Int.$fBitsInt32_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uCs: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt32_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.711812148 UTC

[section ""data" . GHC.Int.$fBitsInt32_closure" {
     GHC.Int.$fBitsInt32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fBitsInt32_$c.&._closure+2;
         const GHC.Int.$fBitsInt32_$c.|._closure+2;
         const GHC.Int.$fBitsInt32_$cxor_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt32_$cshift_closure+2;
         const GHC.Int.$fBitsInt32_$crotate_closure+2;
         const GHC.Int.$fBitsInt6_closure+1;
         const GHC.Int.$fBitsInt32_$cbit_closure+1;
         const GHC.Int.$fBitsInt32_$csetBit_closure+2;
         const GHC.Int.$fBitsInt32_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt32_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt32_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt32_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt32_$crotateL_closure+2;
         const GHC.Int.$fBitsInt32_$crotateR_closure+2;
         const GHC.Int.$fBitsInt32_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.714975965 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_closure" {
     GHC.Int.$fFiniteBitsInt32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt32_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.718520166 UTC

[section ""data" . GHC.Int.$fReadInt32_go_closure" {
     GHC.Int.$fReadInt32_go_closure:
         const GHC.Int.$fReadInt32_go_info;
 },
 sat_s4lo6_entry() //  [R1]
         { info_tbl: [(c4uCU,
                       label: sat_s4lo6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uCU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uCV; else goto c4uCW;
       c4uCV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4uCW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lo4_entry() //  [R1]
         { info_tbl: [(c4uD4,
                       label: sat_s4lo4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uD4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uDb; else goto c4uDc;
       c4uDb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4uDc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4uD1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4uDg; else goto c4uD2;
       u4uDg: // global
           call _c4uD1(R1) args: 0, res: 0, upd: 0;
       c4uD2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4uD1() //  [R1]
         { info_tbl: [(c4uD1,
                       label: block_c4uD1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uD1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uDf; else goto c4uDe;
       c4uDf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4uDe: // global
           _s4lo3::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lo3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt32_go_entry() //  [R2]
         { info_tbl: [(c4uDl,
                       label: GHC.Int.$fReadInt32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uDl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uDm; else goto c4uDn;
       c4uDm: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uDn: // global
           I64[Sp - 8] = block_c4uCF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uDx; else goto c4uCG;
       u4uDx: // global
           call _c4uCF(R1) args: 0, res: 0, upd: 0;
       c4uCG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uCF() //  [R1]
         { info_tbl: [(c4uCF,
                       label: block_c4uCF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uCF: // global
           if (R1 & 7 == 1) goto c4uDi; else goto c4uDj;
       c4uDi: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uDj: // global
           I64[Sp - 8] = block_c4uCL_info;
           _s4lnX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lnX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uDw; else goto c4uCM;
       u4uDw: // global
           call _c4uCL(R1) args: 0, res: 0, upd: 0;
       c4uCM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uCL() //  [R1]
         { info_tbl: [(c4uCL,
                       label: block_c4uCL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uCL: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4uDv; else goto c4uDu;
       c4uDv: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uDu: // global
           _s4lnZ::P64 = P64[R1 + 7];
           _s4lo0::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lo6_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lo4_info;
           P64[Hp - 48] = _s4lnZ::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lo0::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.734759808 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadsPrec_closure" {
     GHC.Int.$fReadInt32_$creadsPrec_closure:
         const GHC.Int.$fReadInt32_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4uEd,
                       label: GHC.Int.$fReadInt32_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uEd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uEh; else goto c4uEi;
       c4uEh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uEi: // global
           I64[Sp - 16] = block_c4uEb_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lo8::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lo8::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uEb() //  [R1]
         { info_tbl: [(c4uEb,
                       label: block_c4uEb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uEb: // global
           _s4lo8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4uEg_info;
           R3 = _s4lo8::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uEg() //  [R1]
         { info_tbl: [(c4uEg,
                       label: block_c4uEg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uEg: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.743230368 UTC

[section ""data" . GHC.Int.$fReadInt6_closure" {
     GHC.Int.$fReadInt6_closure:
         const GHC.Int.$fReadInt6_info;
         const 0;
 },
 sat_s4lod_entry() //  [R1, R2]
         { info_tbl: [(c4uEI,
                       label: sat_s4lod_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uEI: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt32_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt6_entry() //  [R2, R3]
         { info_tbl: [(c4uEO,
                       label: GHC.Int.$fReadInt6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uEO: // global
           _s4loc::P64 = R3;
           _s4lob::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4uEP; else goto c4uEQ;
       c4uEQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uES; else goto c4uER;
       c4uES: // global
           HpAlloc = 16;
           goto c4uEP;
       c4uEP: // global
           R3 = _s4loc::P64;
           R2 = _s4lob::P64;
           R1 = GHC.Int.$fReadInt6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uER: // global
           I64[Hp - 8] = sat_s4lod_info;
           P64[Hp] = _s4lob::P64;
           I64[Sp - 8] = block_c4uEL_info;
           R3 = _s4loc::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uEL() //  [R1]
         { info_tbl: [(c4uEL,
                       label: block_c4uEL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uEL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uEV; else goto c4uEU;
       c4uEV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uEU: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.752516902 UTC

[section ""data" . GHC.Int.$fReadInt5_closure" {
     GHC.Int.$fReadInt5_closure:
         const GHC.Int.$fReadInt5_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4uFh_srtd" {
     u4uFh_srtd:
         const S4lDl_srt+504;
         const 46;
         const 35184372088833;
 },
 GHC.Int.$fReadInt5_entry() //  [R1]
         { info_tbl: [(c4uFe,
                       label: GHC.Int.$fReadInt5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uFe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4uFf; else goto c4uFg;
       c4uFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4uFg: // global
           (_c4uFb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4uFb::I64 == 0) goto c4uFd; else goto c4uFc;
       c4uFd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4uFc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4uFb::I64;
           R2 = GHC.Int.$fReadInt6_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.758199711 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadList_closure" {
     GHC.Int.$fReadInt32_$creadList_closure:
         const GHC.Int.$fReadInt32_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadList_entry() //  [R2]
         { info_tbl: [(c4uFu,
                       label: GHC.Int.$fReadInt32_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uFu: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt5_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.765775031 UTC

[section ""data" . GHC.Int.$fReadInt4_closure" {
     GHC.Int.$fReadInt4_closure:
         const GHC.Int.$fReadInt4_info;
         const 0;
 },
 GHC.Int.$fReadInt4_entry() //  [R2, R3]
         { info_tbl: [(c4uFI,
                       label: GHC.Int.$fReadInt4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uFI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uFJ; else goto c4uFK;
       c4uFJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uFK: // global
           I64[Sp - 8] = block_c4uFF_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt32_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uFF() //  [R1]
         { info_tbl: [(c4uFF,
                       label: block_c4uFF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uFF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uFN; else goto c4uFM;
       c4uFN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uFM: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.774738996 UTC

[section ""data" . GHC.Int.$fReadInt32_closure" {
     GHC.Int.$fReadInt32_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt32_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt32_$creadList_closure+1;
         const GHC.Int.$fReadInt6_closure+2;
         const GHC.Int.$fReadInt4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.778717603 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquot_closure" {
     GHC.Int.$fIntegralInt32_$cquot_closure:
         const GHC.Int.$fIntegralInt32_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4uG5,
                       label: GHC.Int.$fIntegralInt32_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uG5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uG9; else goto c4uGa;
       c4uG9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uGa: // global
           I64[Sp - 16] = block_c4uG2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uGL; else goto c4uG3;
       u4uGL: // global
           call _c4uG2(R1) args: 0, res: 0, upd: 0;
       c4uG3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uG2() //  [R1]
         { info_tbl: [(c4uG2,
                       label: block_c4uG2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uG2: // global
           I64[Sp] = block_c4uG8_info;
           _s4lon::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lon::I64;
           if (R1 & 7 != 0) goto u4uGK; else goto c4uGc;
       u4uGK: // global
           call _c4uG8(R1) args: 0, res: 0, upd: 0;
       c4uGc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uG8() //  [R1]
         { info_tbl: [(c4uG8,
                       label: block_c4uG8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uG8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uGi; else goto c4uGh;
       c4uGi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uGh: // global
           _s4lon::I64 = I64[Sp + 8];
           _s4loq::I64 = I64[R1 + 7];
           if (_s4loq::I64 != (-1)) goto u4uGJ; else goto c4uGH;
       u4uGJ: // global
           if (_s4loq::I64 != 0) goto c4uGt; else goto c4uGI;
       c4uGt: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4lon::I64,
                                                                            _s4loq::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uGI: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uGH: // global
           if (_s4lon::I64 == (-2147483648)) goto c4uGG; else goto c4uGF;
       c4uGG: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uGF: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4lon::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.795131631 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$crem_closure" {
     GHC.Int.$fIntegralInt32_$crem_closure:
         const GHC.Int.$fIntegralInt32_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4uHb,
                       label: GHC.Int.$fIntegralInt32_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uHb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uHf; else goto c4uHg;
       c4uHf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uHg: // global
           I64[Sp - 16] = block_c4uH8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uHE; else goto c4uH9;
       u4uHE: // global
           call _c4uH8(R1) args: 0, res: 0, upd: 0;
       c4uH9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uH8() //  [R1]
         { info_tbl: [(c4uH8,
                       label: block_c4uH8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uH8: // global
           I64[Sp] = block_c4uHe_info;
           _s4loB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loB::I64;
           if (R1 & 7 != 0) goto u4uHD; else goto c4uHi;
       u4uHD: // global
           call _c4uHe(R1) args: 0, res: 0, upd: 0;
       c4uHi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uHe() //  [R1]
         { info_tbl: [(c4uHe,
                       label: block_c4uHe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uHe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uHo; else goto c4uHn;
       c4uHo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uHn: // global
           _s4loE::I64 = I64[R1 + 7];
           if (_s4loE::I64 != (-1)) goto u4uHC; else goto c4uHA;
       u4uHC: // global
           if (_s4loE::I64 != 0) goto c4uHz; else goto c4uHB;
       c4uHz: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4loE::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uHB: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uHA: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.809605674 UTC

[section ""data" . GHC.Int.$w$cdiv1_closure" {
     GHC.Int.$w$cdiv1_closure:
         const GHC.Int.$w$cdiv1_info;
         const 0;
 },
 GHC.Int.$w$cdiv1_entry() //  [R2, R3]
         { info_tbl: [(c4uI4,
                       label: GHC.Int.$w$cdiv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uI4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uI5; else goto c4uI6;
       c4uI5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uI6: // global
           if (R3 == (-1)) goto c4uI2; else goto u4uIq;
       c4uI2: // global
           if (R2 == (-2147483648)) goto c4uIp; else goto c4uIn;
       c4uIp: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uIn: // global
           I64[Sp - 8] = block_c4uIh_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4uIq: // global
           if (R3 == 0) goto c4uI3; else goto c4uI1;
       c4uI3: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uI1: // global
           I64[Sp - 8] = block_c4uI8_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uIh() //  [R1]
         { info_tbl: [(c4uIh,
                       label: block_c4uIh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uIh: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4uI8() //  [R1]
         { info_tbl: [(c4uI8,
                       label: block_c4uI8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uI8: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.822712382 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdiv_closure" {
     GHC.Int.$fIntegralInt32_$cdiv_closure:
         const GHC.Int.$fIntegralInt32_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4uIL,
                       label: GHC.Int.$fIntegralInt32_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uIL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uIY; else goto c4uIZ;
       c4uIY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uIZ: // global
           I64[Sp - 16] = block_c4uII_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uJ6; else goto c4uIJ;
       u4uJ6: // global
           call _c4uII(R1) args: 0, res: 0, upd: 0;
       c4uIJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uII() //  [R1]
         { info_tbl: [(c4uII,
                       label: block_c4uII_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uII: // global
           I64[Sp] = block_c4uIO_info;
           _s4loS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loS::I64;
           if (R1 & 7 != 0) goto u4uJ5; else goto c4uIP;
       u4uJ5: // global
           call _c4uIO(R1) args: 0, res: 0, upd: 0;
       c4uIP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uIO() //  [R1]
         { info_tbl: [(c4uIO,
                       label: block_c4uIO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uIO: // global
           _s4loS::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4uIT_info;
           R3 = I64[R1 + 7];
           R2 = _s4loS::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uIT() //  [R1]
         { info_tbl: [(c4uIT,
                       label: block_c4uIT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uIT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uJ4; else goto c4uJ3;
       c4uJ4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4uJ3: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.837440085 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cmod_closure" {
     GHC.Int.$fIntegralInt32_$cmod_closure:
         const GHC.Int.$fIntegralInt32_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4uJv,
                       label: GHC.Int.$fIntegralInt32_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uJv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uJz; else goto c4uJA;
       c4uJz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uJA: // global
           I64[Sp - 16] = block_c4uJs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uK0; else goto c4uJt;
       u4uK0: // global
           call _c4uJs(R1) args: 0, res: 0, upd: 0;
       c4uJt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uJs() //  [R1]
         { info_tbl: [(c4uJs,
                       label: block_c4uJs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uJs: // global
           I64[Sp] = block_c4uJy_info;
           _s4loZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loZ::I64;
           if (R1 & 7 != 0) goto u4uJZ; else goto c4uJC;
       u4uJZ: // global
           call _c4uJy(R1) args: 0, res: 0, upd: 0;
       c4uJC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uJy() //  [R1]
         { info_tbl: [(c4uJy,
                       label: block_c4uJy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uJy: // global
           _s4lp2::I64 = I64[R1 + 7];
           if (_s4lp2::I64 != (-1)) goto u4uJY; else goto c4uJW;
       u4uJY: // global
           if (_s4lp2::I64 != 0) goto c4uJS; else goto c4uJX;
       c4uJS: // global
           _s4loZ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4uJJ_info;
           R3 = _s4lp2::I64;
           R2 = _s4loZ::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4uJX: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uJW: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4uJJ() //  [R1]
         { info_tbl: [(c4uJJ,
                       label: block_c4uJJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uJJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uJV; else goto c4uJU;
       c4uJV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4uJU: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.852802128 UTC

[section ""data" . lvl8_r4kPz_closure" {
     lvl8_r4kPz_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt6_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.856875649 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquotRem_closure" {
     GHC.Int.$fIntegralInt32_$cquotRem_closure:
         const GHC.Int.$fIntegralInt32_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4uKs,
                       label: GHC.Int.$fIntegralInt32_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uKs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uKw; else goto c4uKx;
       c4uKw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uKx: // global
           I64[Sp - 16] = block_c4uKp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uLc; else goto c4uKq;
       u4uLc: // global
           call _c4uKp(R1) args: 0, res: 0, upd: 0;
       c4uKq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uKp() //  [R1]
         { info_tbl: [(c4uKp,
                       label: block_c4uKp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uKp: // global
           I64[Sp] = block_c4uKv_info;
           _s4lp9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lp9::I64;
           if (R1 & 7 != 0) goto u4uLb; else goto c4uKz;
       u4uLb: // global
           call _c4uKv(R1) args: 0, res: 0, upd: 0;
       c4uKz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uKv() //  [R1]
         { info_tbl: [(c4uKv,
                       label: block_c4uKv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uKv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4uKF; else goto c4uKE;
       c4uKF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uKE: // global
           _s4lp9::I64 = I64[Sp + 8];
           _s4lpc::I64 = I64[R1 + 7];
           if (_s4lpc::I64 != (-1)) goto u4uLa; else goto c4uL8;
       u4uLa: // global
           if (_s4lpc::I64 != 0) goto c4uKS; else goto c4uL9;
       c4uKS: // global
           (_s4lpe::I64, _s4lpf::I64) = call MO_S_QuotRem W64(_s4lp9::I64, _s4lpc::I64);
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpf::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpe::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uL9: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uL8: // global
           if (_s4lp9::I64 == (-2147483648)) goto c4uL7; else goto c4uL6;
       c4uL7: // global
           Hp = Hp - 56;
           R1 = lvl8_r4kPz_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uL6: // global
           (_s4lpm::I64, _s4lpn::I64) = call MO_S_QuotRem W64(_s4lp9::I64, (-1));
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpn::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpm::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.874471775 UTC

[section ""data" . GHC.Int.$w$cdivMod1_closure" {
     GHC.Int.$w$cdivMod1_closure:
         const GHC.Int.$w$cdivMod1_info;
         const 0;
 },
 GHC.Int.$w$cdivMod1_entry() //  [R2, R3]
         { info_tbl: [(c4uLK,
                       label: GHC.Int.$w$cdivMod1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uLK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uLL; else goto c4uLM;
       c4uLL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uLM: // global
           if (R3 == 0) goto c4uLJ; else goto c4uLI;
       c4uLJ: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uLI: // global
           if (R3 == (-1)) goto c4uOf; else goto u4uOg;
       c4uOf: // global
           if (R2 == (-2147483648)) goto c4uOe; else goto u4uOh;
       c4uOe: // global
           R2 = GHC.Int.$fBitsInt6_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4uOh: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4uOj;
       u4uOg: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4uOj;
       u4uOj: // global
           call _c4uLR() args: 0, res: 0, upd: 0;
     }
 },
 _c4uLR() //  []
         { info_tbl: [(c4uLR,
                       label: block_c4uLR_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uLR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4uLV; else goto c4uLU;
       c4uLV: // global
           HpAlloc = 32;
           I64[Sp] = block_c4uLR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4uLU: // global
           _s4lpt::I64 = I64[Sp + 8];
           _s4lpv::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lpt::I64, 0)) goto c4uMO; else goto c4uO5;
       c4uMO: // global
           if (%MO_S_Ge_W64(_s4lpt::I64, 0)) goto c4uMb; else goto c4uMM;
       c4uMb: // global
           (_s4lpA::I64, _s4lpB::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpB::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpA::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uMM: // global
           if (%MO_S_Le_W64(_s4lpv::I64, 0)) goto c4uMp; else goto c4uML;
       c4uMp: // global
           (_s4lpI::I64, _s4lpJ::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpJ::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpI::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uML: // global
           (_s4lpQ::I64, _s4lpR::I64) = call MO_S_QuotRem W64(_s4lpt::I64 + 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpR::I64 + _s4lpv::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpQ::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uO5: // global
           if (%MO_S_Ge_W64(_s4lpv::I64, 0)) goto c4uNI; else goto c4uO4;
       c4uNI: // global
           if (%MO_S_Ge_W64(_s4lpt::I64, 0)) goto c4uN5; else goto c4uNG;
       c4uN5: // global
           (_s4lq2::I64, _s4lq3::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lq3::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lq2::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uNG: // global
           if (%MO_S_Le_W64(_s4lpv::I64, 0)) goto c4uNj; else goto c4uNF;
       c4uNj: // global
           (_s4lqa::I64, _s4lqb::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqb::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqa::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uNF: // global
           (_s4lqi::I64, _s4lqj::I64) = call MO_S_QuotRem W64(_s4lpt::I64 + 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqj::I64 + _s4lpv::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqi::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uO4: // global
           (_s4lqt::I64, _s4lqu::I64) = call MO_S_QuotRem W64(_s4lpt::I64 - 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqu::I64 + _s4lpv::I64 + 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqt::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.888756374 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdivMod_closure" {
     GHC.Int.$fIntegralInt32_$cdivMod_closure:
         const GHC.Int.$fIntegralInt32_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4uP7,
                       label: GHC.Int.$fIntegralInt32_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uP7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uPi; else goto c4uPj;
       c4uPi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uPj: // global
           I64[Sp - 16] = block_c4uP4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uPq; else goto c4uP5;
       u4uPq: // global
           call _c4uP4(R1) args: 0, res: 0, upd: 0;
       c4uP5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uP4() //  [R1]
         { info_tbl: [(c4uP4,
                       label: block_c4uP4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uP4: // global
           I64[Sp] = block_c4uPa_info;
           _s4lqI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lqI::I64;
           if (R1 & 7 != 0) goto u4uPp; else goto c4uPb;
       u4uPp: // global
           call _c4uPa(R1) args: 0, res: 0, upd: 0;
       c4uPb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uPa() //  [R1]
         { info_tbl: [(c4uPa,
                       label: block_c4uPa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uPa: // global
           _s4lqI::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4uPf_info;
           R3 = I64[R1 + 7];
           R2 = _s4lqI::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uPf() //  [R1, R2]
         { info_tbl: [(c4uPf,
                       label: block_c4uPf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uPf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4uPo; else goto c4uPn;
       c4uPo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4uPn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.899204669 UTC

[section ""data" . GHC.Int.$fRealInt32_$ctoRational_closure" {
     GHC.Int.$fRealInt32_$ctoRational_closure:
         const GHC.Int.$fRealInt32_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt32_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4uPP,
                       label: GHC.Int.$fRealInt32_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uPP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uQ3; else goto c4uQ4;
       c4uQ3: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uQ4: // global
           I64[Sp - 8] = block_c4uPM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uQb; else goto c4uPN;
       u4uQb: // global
           call _c4uPM(R1) args: 0, res: 0, upd: 0;
       c4uPN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uPM() //  [R1]
         { info_tbl: [(c4uPM,
                       label: block_c4uPM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uPM: // global
           I64[Sp] = block_c4uPS_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uPS() //  [R1]
         { info_tbl: [(c4uPS,
                       label: block_c4uPS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uPS: // global
           I64[Sp] = block_c4uPW_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uPW() //  [R1]
         { info_tbl: [(c4uPW,
                       label: block_c4uPW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uPW: // global
           I64[Sp] = block_c4uQ0_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4uQ0() //  [R1, R2]
         { info_tbl: [(c4uQ0,
                       label: block_c4uQ0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uQ0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4uQa; else goto c4uQ9;
       c4uQa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4uQ9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.909919189 UTC

[section ""data" . GHC.Int.$fRealInt32_closure" {
     GHC.Int.$fRealInt32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt32_closure+1;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fRealInt32_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.911849148 UTC

[section ""data" . GHC.Int.$fIntegralInt32_closure" {
     GHC.Int.$fIntegralInt32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt32_closure+1;
         const GHC.Int.$fEnumInt32_closure+1;
         const GHC.Int.$fIntegralInt32_$cquot_closure+2;
         const GHC.Int.$fIntegralInt32_$crem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt32_$cmod_closure+2;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt32_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.914241506 UTC

[section ""data" . GHC.Int.$fIxInt32_$crange_closure" {
     GHC.Int.$fIxInt32_$crange_closure:
         const GHC.Int.$fIxInt32_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$crange_entry() //  [R2]
         { info_tbl: [(c4uQE,
                       label: GHC.Int.$fIxInt32_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uQE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uQF; else goto c4uQG;
       c4uQF: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uQG: // global
           I64[Sp - 8] = block_c4uQB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uQK; else goto c4uQC;
       u4uQK: // global
           call _c4uQB(R1) args: 0, res: 0, upd: 0;
       c4uQC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uQB() //  [R1]
         { info_tbl: [(c4uQB,
                       label: block_c4uQB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uQB: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.920937633 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt32_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt32_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt32_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4uR1,
                       label: GHC.Int.$fIxInt32_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uR1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uRi; else goto c4uRj;
       c4uRi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uRj: // global
           I64[Sp - 16] = block_c4uQY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uRq; else goto c4uQZ;
       u4uRq: // global
           call _c4uQY(R1) args: 0, res: 0, upd: 0;
       c4uQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uQY() //  [R1]
         { info_tbl: [(c4uQY,
                       label: block_c4uQY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uQY: // global
           I64[Sp] = block_c4uR4_info;
           _s4lr3::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lr3::P64;
           if (R1 & 7 != 0) goto u4uRp; else goto c4uR5;
       u4uRp: // global
           call _c4uR4(R1) args: 0, res: 0, upd: 0;
       c4uR5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uR4() //  [R1]
         { info_tbl: [(c4uR4,
                       label: block_c4uR4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uR4: // global
           I64[Sp] = block_c4uR9_info;
           _s4lr6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lr6::I64;
           if (R1 & 7 != 0) goto u4uRr; else goto c4uRa;
       u4uRr: // global
           call _c4uR9(R1) args: 0, res: 0, upd: 0;
       c4uRa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uR9() //  [R1]
         { info_tbl: [(c4uR9,
                       label: block_c4uR9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uR9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uRo; else goto c4uRn;
       c4uRo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uRn: // global
           _s4lr9::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lr9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.931462742 UTC

[section ""data" . GHC.Int.$fIxInt32_$crangeSize_closure" {
     GHC.Int.$fIxInt32_$crangeSize_closure:
         const GHC.Int.$fIxInt32_$crangeSize_info;
 },
 GHC.Int.$fIxInt32_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4uRT,
                       label: GHC.Int.$fIxInt32_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uRT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uS2; else goto c4uS3;
       c4uS2: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uS3: // global
           I64[Sp - 8] = block_c4uRQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uSs; else goto c4uRR;
       u4uSs: // global
           call _c4uRQ(R1) args: 0, res: 0, upd: 0;
       c4uRR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uRQ() //  [R1]
         { info_tbl: [(c4uRQ,
                       label: block_c4uRQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uRQ: // global
           I64[Sp - 8] = block_c4uRW_info;
           _s4lrd::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lrd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uSr; else goto c4uRX;
       u4uSr: // global
           call _c4uRW(R1) args: 0, res: 0, upd: 0;
       c4uRX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uRW() //  [R1]
         { info_tbl: [(c4uRW,
                       label: block_c4uRW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uRW: // global
           I64[Sp] = block_c4uS1_info;
           _s4lrf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrf::I64;
           if (R1 & 7 != 0) goto u4uSt; else goto c4uS6;
       u4uSt: // global
           call _c4uS1(R1) args: 0, res: 0, upd: 0;
       c4uS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uS1() //  [R1]
         { info_tbl: [(c4uS1,
                       label: block_c4uS1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uS1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uSc; else goto c4uSb;
       c4uSc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uSb: // global
           _s4lrf::I64 = I64[Sp + 8];
           _s4lrh::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lrf::I64,
                            _s4lrh::I64)) goto c4uSg; else goto c4uSq;
       c4uSg: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uSq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lrh::I64 - _s4lrf::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.943006486 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt32_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt32_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4uSX,
                       label: GHC.Int.$fIxInt32_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uSX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uTh; else goto c4uTi;
       c4uTh: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uTi: // global
           I64[Sp - 8] = block_c4uSU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uTp; else goto c4uSV;
       u4uTp: // global
           call _c4uSU(R1) args: 0, res: 0, upd: 0;
       c4uSV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uSU() //  [R1]
         { info_tbl: [(c4uSU,
                       label: block_c4uSU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uSU: // global
           I64[Sp - 8] = block_c4uT0_info;
           _s4lrn::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lrn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uTo; else goto c4uT1;
       u4uTo: // global
           call _c4uT0(R1) args: 0, res: 0, upd: 0;
       c4uT1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uT0() //  [R1]
         { info_tbl: [(c4uT0,
                       label: block_c4uT0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uT0: // global
           I64[Sp] = block_c4uT5_info;
           _s4lrq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrq::I64;
           if (R1 & 7 != 0) goto u4uTq; else goto c4uT6;
       u4uTq: // global
           call _c4uT5(R1) args: 0, res: 0, upd: 0;
       c4uT6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uT5() //  [R1]
         { info_tbl: [(c4uT5,
                       label: block_c4uT5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uT5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uTn; else goto c4uTm;
       c4uTn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uTm: // global
           _s4lru::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lru::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.9541935 UTC

[section ""data" . GHC.Int.$fIxInt32_$cindex_closure" {
     GHC.Int.$fIxInt32_$cindex_closure:
         const GHC.Int.$fIxInt32_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4uTT,
                       label: GHC.Int.$fIxInt32_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uTT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uU2; else goto c4uU3;
       c4uU2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uU3: // global
           I64[Sp - 16] = block_c4uTQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uUC; else goto c4uTR;
       u4uUC: // global
           call _c4uTQ(R1) args: 0, res: 0, upd: 0;
       c4uTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uTQ() //  [R1]
         { info_tbl: [(c4uTQ,
                       label: block_c4uTQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uTQ: // global
           I64[Sp - 8] = block_c4uTW_info;
           _s4lrz::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lrz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uUB; else goto c4uTX;
       u4uUB: // global
           call _c4uTW(R1) args: 0, res: 0, upd: 0;
       c4uTX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uTW() //  [R1]
         { info_tbl: [(c4uTW,
                       label: block_c4uTW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uTW: // global
           I64[Sp] = block_c4uU1_info;
           _s4lrB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lrB::I64;
           if (R1 & 7 != 0) goto u4uUD; else goto c4uU6;
       u4uUD: // global
           call _c4uU1(R1) args: 0, res: 0, upd: 0;
       c4uU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uU1() //  [R1]
         { info_tbl: [(c4uU1,
                       label: block_c4uU1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uU1: // global
           _s4lrD::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lrD::I64)) goto c4uUe; else goto c4uUi;
       c4uUe: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4uUi: // global
           I64[Sp] = block_c4uUh_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrD::I64;
           if (R1 & 7 != 0) goto u4uUE; else goto c4uUj;
       u4uUE: // global
           call _c4uUh(R1) args: 0, res: 0, upd: 0;
       c4uUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uUh() //  [R1]
         { info_tbl: [(c4uUh,
                       label: block_c4uUh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uUh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uUp; else goto c4uUo;
       c4uUp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uUo: // global
           _s4lrD::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4lrD::I64,
                            I64[R1 + 7])) goto c4uUt; else goto c4uUA;
       c4uUt: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4uUA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lrD::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.966155379 UTC

[section ""data" . GHC.Int.$fIxInt32_closure" {
     GHC.Int.$fIxInt32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fIxInt32_$crange_closure+1;
         const GHC.Int.$fIxInt32_$cindex_closure+2;
         const GHC.Int.$fIxInt32_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt32_$cinRange_closure+2;
         const GHC.Int.$fIxInt32_$crangeSize_closure+1;
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.968634351 UTC

[section ""data" . GHC.Int.eqInt64_closure" {
     GHC.Int.eqInt64_closure:
         const GHC.Int.eqInt64_info;
 },
 GHC.Int.eqInt64_entry() //  [R2, R3]
         { info_tbl: [(c4uVd,
                       label: GHC.Int.eqInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uVd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uVh; else goto c4uVi;
       c4uVh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uVi: // global
           I64[Sp - 16] = block_c4uVa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uVr; else goto c4uVb;
       u4uVr: // global
           call _c4uVa(R1) args: 0, res: 0, upd: 0;
       c4uVb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uVa() //  [R1]
         { info_tbl: [(c4uVa,
                       label: block_c4uVa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uVa: // global
           I64[Sp] = block_c4uVg_info;
           _s4lrM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrM::I64;
           if (R1 & 7 != 0) goto u4uVq; else goto c4uVk;
       u4uVq: // global
           call _c4uVg(R1) args: 0, res: 0, upd: 0;
       c4uVk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uVg() //  [R1]
         { info_tbl: [(c4uVg,
                       label: block_c4uVg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uVg: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.977094619 UTC

[section ""data" . GHC.Int.$fEqInt64_closure" {
     GHC.Int.$fEqInt64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt64_closure+2;
         const GHC.Int.neInt64_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.979397824 UTC

[section ""data" . GHC.Int.gtInt64_closure" {
     GHC.Int.gtInt64_closure:
         const GHC.Int.gtInt64_info;
 },
 GHC.Int.gtInt64_entry() //  [R2, R3]
         { info_tbl: [(c4uVR,
                       label: GHC.Int.gtInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uVR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uVV; else goto c4uVW;
       c4uVV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uVW: // global
           I64[Sp - 16] = block_c4uVO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uW5; else goto c4uVP;
       u4uW5: // global
           call _c4uVO(R1) args: 0, res: 0, upd: 0;
       c4uVP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uVO() //  [R1]
         { info_tbl: [(c4uVO,
                       label: block_c4uVO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uVO: // global
           I64[Sp] = block_c4uVU_info;
           _s4lrT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrT::I64;
           if (R1 & 7 != 0) goto u4uW4; else goto c4uVY;
       u4uW4: // global
           call _c4uVU(R1) args: 0, res: 0, upd: 0;
       c4uVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uVU() //  [R1]
         { info_tbl: [(c4uVU,
                       label: block_c4uVU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uVU: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.987450884 UTC

[section ""data" . GHC.Int.geInt64_closure" {
     GHC.Int.geInt64_closure:
         const GHC.Int.geInt64_info;
 },
 GHC.Int.geInt64_entry() //  [R2, R3]
         { info_tbl: [(c4uWu,
                       label: GHC.Int.geInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uWu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uWy; else goto c4uWz;
       c4uWy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uWz: // global
           I64[Sp - 16] = block_c4uWr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uWI; else goto c4uWs;
       u4uWI: // global
           call _c4uWr(R1) args: 0, res: 0, upd: 0;
       c4uWs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uWr() //  [R1]
         { info_tbl: [(c4uWr,
                       label: block_c4uWr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uWr: // global
           I64[Sp] = block_c4uWx_info;
           _s4ls0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ls0::I64;
           if (R1 & 7 != 0) goto u4uWH; else goto c4uWB;
       u4uWH: // global
           call _c4uWx(R1) args: 0, res: 0, upd: 0;
       c4uWB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uWx() //  [R1]
         { info_tbl: [(c4uWx,
                       label: block_c4uWx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uWx: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:12.996131398 UTC

[section ""data" . GHC.Int.ltInt64_closure" {
     GHC.Int.ltInt64_closure:
         const GHC.Int.ltInt64_info;
 },
 GHC.Int.ltInt64_entry() //  [R2, R3]
         { info_tbl: [(c4uX7,
                       label: GHC.Int.ltInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uX7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uXb; else goto c4uXc;
       c4uXb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uXc: // global
           I64[Sp - 16] = block_c4uX4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uXl; else goto c4uX5;
       u4uXl: // global
           call _c4uX4(R1) args: 0, res: 0, upd: 0;
       c4uX5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uX4() //  [R1]
         { info_tbl: [(c4uX4,
                       label: block_c4uX4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uX4: // global
           I64[Sp] = block_c4uXa_info;
           _s4ls7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ls7::I64;
           if (R1 & 7 != 0) goto u4uXk; else goto c4uXe;
       u4uXk: // global
           call _c4uXa(R1) args: 0, res: 0, upd: 0;
       c4uXe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uXa() //  [R1]
         { info_tbl: [(c4uXa,
                       label: block_c4uXa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uXa: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.003901427 UTC

[section ""data" . GHC.Int.leInt64_closure" {
     GHC.Int.leInt64_closure:
         const GHC.Int.leInt64_info;
 },
 GHC.Int.leInt64_entry() //  [R2, R3]
         { info_tbl: [(c4uXK,
                       label: GHC.Int.leInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uXK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uXO; else goto c4uXP;
       c4uXO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uXP: // global
           I64[Sp - 16] = block_c4uXH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uXY; else goto c4uXI;
       u4uXY: // global
           call _c4uXH(R1) args: 0, res: 0, upd: 0;
       c4uXI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uXH() //  [R1]
         { info_tbl: [(c4uXH,
                       label: block_c4uXH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uXH: // global
           I64[Sp] = block_c4uXN_info;
           _s4lse::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lse::I64;
           if (R1 & 7 != 0) goto u4uXX; else goto c4uXR;
       u4uXX: // global
           call _c4uXN(R1) args: 0, res: 0, upd: 0;
       c4uXR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uXN() //  [R1]
         { info_tbl: [(c4uXN,
                       label: block_c4uXN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uXN: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.012350053 UTC

[section ""data" . GHC.Int.$fOrdInt64_$ccompare_closure" {
     GHC.Int.$fOrdInt64_$ccompare_closure:
         const GHC.Int.$fOrdInt64_$ccompare_info;
 },
 GHC.Int.$fOrdInt64_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4uYn,
                       label: GHC.Int.$fOrdInt64_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uYn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uYr; else goto c4uYs;
       c4uYr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uYs: // global
           I64[Sp - 16] = block_c4uYk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uYL; else goto c4uYl;
       u4uYL: // global
           call _c4uYk(R1) args: 0, res: 0, upd: 0;
       c4uYl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uYk() //  [R1]
         { info_tbl: [(c4uYk,
                       label: block_c4uYk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uYk: // global
           I64[Sp] = block_c4uYq_info;
           _s4lsl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lsl::I64;
           if (R1 & 7 != 0) goto u4uYK; else goto c4uYu;
       u4uYK: // global
           call _c4uYq(R1) args: 0, res: 0, upd: 0;
       c4uYu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uYq() //  [R1]
         { info_tbl: [(c4uYq,
                       label: block_c4uYq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uYq: // global
           _s4lsl::I64 = I64[Sp + 8];
           _s4lsn::I64 = I64[R1 + 7];
           if (_s4lsl::I64 == _s4lsn::I64) goto c4uYJ; else goto c4uYI;
       c4uYJ: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uYI: // global
           if (%MO_S_Gt_W64(_s4lsl::I64,
                            _s4lsn::I64)) goto c4uYF; else goto c4uYG;
       c4uYF: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uYG: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.021209238 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmax_closure" {
     GHC.Int.$fOrdInt64_$cmax_closure:
         const GHC.Int.$fOrdInt64_$cmax_info;
 },
 GHC.Int.$fOrdInt64_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4uZ9,
                       label: GHC.Int.$fOrdInt64_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uZ9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uZd; else goto c4uZe;
       c4uZd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uZe: // global
           I64[Sp - 16] = block_c4uZ6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uZr; else goto c4uZ7;
       u4uZr: // global
           call _c4uZ6(R1) args: 0, res: 0, upd: 0;
       c4uZ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uZ6() //  [R1]
         { info_tbl: [(c4uZ6,
                       label: block_c4uZ6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uZ6: // global
           I64[Sp - 8] = block_c4uZc_info;
           _s4lss::P64 = R1;
           _s4lst::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lst::I64;
           P64[Sp + 8] = _s4lss::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uZq; else goto c4uZg;
       u4uZq: // global
           call _c4uZc(R1) args: 0, res: 0, upd: 0;
       c4uZg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uZc() //  [R1]
         { info_tbl: [(c4uZc,
                       label: block_c4uZc_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uZc: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4uZo; else goto c4uZp;
       c4uZo: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4uZp: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.030077812 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmin_closure" {
     GHC.Int.$fOrdInt64_$cmin_closure:
         const GHC.Int.$fOrdInt64_$cmin_info;
 },
 GHC.Int.$fOrdInt64_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4uZR,
                       label: GHC.Int.$fOrdInt64_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uZR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uZV; else goto c4uZW;
       c4uZV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uZW: // global
           I64[Sp - 16] = block_c4uZO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v09; else goto c4uZP;
       u4v09: // global
           call _c4uZO(R1) args: 0, res: 0, upd: 0;
       c4uZP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uZO() //  [R1]
         { info_tbl: [(c4uZO,
                       label: block_c4uZO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uZO: // global
           I64[Sp - 8] = block_c4uZU_info;
           _s4lsz::P64 = R1;
           _s4lsA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lsA::I64;
           P64[Sp + 8] = _s4lsz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v08; else goto c4uZY;
       u4v08: // global
           call _c4uZU(R1) args: 0, res: 0, upd: 0;
       c4uZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4uZU() //  [R1]
         { info_tbl: [(c4uZU,
                       label: block_c4uZU_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4uZU: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4v06; else goto c4v07;
       c4v06: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4v07: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.040486735 UTC

[section ""data" . GHC.Int.$fOrdInt64_closure" {
     GHC.Int.$fOrdInt64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fOrdInt64_$ccompare_closure+2;
         const GHC.Int.ltInt64_closure+2;
         const GHC.Int.leInt64_closure+2;
         const GHC.Int.gtInt64_closure+2;
         const GHC.Int.geInt64_closure+2;
         const GHC.Int.$fOrdInt64_$cmax_closure+2;
         const GHC.Int.$fOrdInt64_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.044365225 UTC

[section ""data" . GHC.Int.$fIxInt64_$cinRange_closure" {
     GHC.Int.$fIxInt64_$cinRange_closure:
         const GHC.Int.$fIxInt64_$cinRange_info;
 },
 GHC.Int.$fIxInt64_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4v0A,
                       label: GHC.Int.$fIxInt64_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v0A: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4v0J; else goto c4v0K;
       c4v0J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v0K: // global
           I64[Sp - 16] = block_c4v0x_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v17; else goto c4v0y;
       u4v17: // global
           call _c4v0x(R1) args: 0, res: 0, upd: 0;
       c4v0y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v0x() //  [R1]
         { info_tbl: [(c4v0x,
                       label: block_c4v0x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v0x: // global
           I64[Sp - 8] = block_c4v0D_info;
           _s4lsI::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lsI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v16; else goto c4v0E;
       u4v16: // global
           call _c4v0D(R1) args: 0, res: 0, upd: 0;
       c4v0E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v0D() //  [R1]
         { info_tbl: [(c4v0D,
                       label: block_c4v0D_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v0D: // global
           I64[Sp] = block_c4v0I_info;
           _s4lsK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lsK::I64;
           if (R1 & 7 != 0) goto u4v18; else goto c4v0N;
       u4v18: // global
           call _c4v0I(R1) args: 0, res: 0, upd: 0;
       c4v0N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v0I() //  [R1]
         { info_tbl: [(c4v0I,
                       label: block_c4v0I_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v0I: // global
           _s4lsM::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lsM::I64)) goto c4v0V; else goto c4v0Z;
       c4v0V: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v0Z: // global
           _s4lsI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4v0Y_info;
           R1 = _s4lsI::P64;
           I64[Sp + 16] = _s4lsM::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4v19; else goto c4v10;
       u4v19: // global
           call _c4v0Y(R1) args: 0, res: 0, upd: 0;
       c4v10: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v0Y() //  [R1]
         { info_tbl: [(c4v0Y,
                       label: block_c4v0Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v0Y: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.062710141 UTC

[section ""data" . GHC.Int.$fNumInt5_closure" {
     GHC.Int.$fNumInt5_closure:
         const GHC.Int.I64#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.066025651 UTC

[section ""data" . GHC.Int.$fNumInt64_$csignum_closure" {
     GHC.Int.$fNumInt64_$csignum_closure:
         const GHC.Int.$fNumInt64_$csignum_info;
 },
 GHC.Int.$fNumInt64_$csignum_entry() //  [R2]
         { info_tbl: [(c4v1I,
                       label: GHC.Int.$fNumInt64_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v1I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4v1J; else goto c4v1K;
       c4v1J: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4v1K: // global
           I64[Sp - 8] = block_c4v1F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v1Y; else goto c4v1G;
       u4v1Y: // global
           call _c4v1F(R1) args: 0, res: 0, upd: 0;
       c4v1G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v1F() //  [R1]
         { info_tbl: [(c4v1F,
                       label: block_c4v1F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v1F: // global
           _s4lsT::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lsT::I64, 0)) goto c4v1W; else goto c4v1X;
       c4v1W: // global
           if (_s4lsT::I64 == 0) goto c4v1U; else goto c4v1T;
       c4v1U: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v1T: // global
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v1X: // global
           R1 = GHC.Int.$fNumInt5_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.07628149 UTC

[section ""data" . GHC.Int.$fNumInt64_$cabs_closure" {
     GHC.Int.$fNumInt64_$cabs_closure:
         const GHC.Int.$fNumInt64_$cabs_info;
 },
 GHC.Int.$fNumInt64_$cabs_entry() //  [R2]
         { info_tbl: [(c4v2i,
                       label: GHC.Int.$fNumInt64_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v2i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4v2j; else goto c4v2k;
       c4v2j: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4v2k: // global
           I64[Sp - 8] = block_c4v2f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v2A; else goto c4v2g;
       u4v2A: // global
           call _c4v2f(R1) args: 0, res: 0, upd: 0;
       c4v2g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v2f() //  [R1]
         { info_tbl: [(c4v2f,
                       label: block_c4v2f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v2f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4v2p; else goto c4v2o;
       c4v2p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4v2o: // global
           _s4lsY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lsY::I64, 0)) goto c4v2y; else goto c4v2z;
       c4v2y: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = -_s4lsY::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v2z: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.086840297 UTC

[section ""data" . GHC.Int.$fNumInt64_closure" {
     GHC.Int.$fNumInt64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt64_$c+_closure+2;
         const GHC.Int.$fNumInt64_$c-_closure+2;
         const GHC.Int.$fNumInt64_$c*_closure+2;
         const GHC.Int.$fNumInt64_$cnegate_closure+1;
         const GHC.Int.$fNumInt64_$cabs_closure+1;
         const GHC.Int.$fNumInt64_$csignum_closure+1;
         const GHC.Int.$fNumInt64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.089773741 UTC

[section ""data" . GHC.Int.$fBitsInt9_closure" {
     GHC.Int.$fBitsInt9_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.092620177 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt64_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4v2U,
                       label: GHC.Int.$fBitsInt64_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v2U: // global
           R1 = GHC.Int.$fBitsInt9_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.098514115 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbit_closure" {
     GHC.Int.$fBitsInt64_$cbit_closure:
         const GHC.Int.$fBitsInt64_$cbit_info;
 },
 GHC.Int.$fBitsInt64_$cbit_entry() //  [R2]
         { info_tbl: [(c4v39,
                       label: GHC.Int.$fBitsInt64_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v39: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4v3a; else goto c4v3b;
       c4v3a: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4v3b: // global
           I64[Sp - 8] = block_c4v36_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v3r; else goto c4v37;
       u4v3r: // global
           call _c4v36(R1) args: 0, res: 0, upd: 0;
       c4v37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v36() //  [R1]
         { info_tbl: [(c4v36,
                       label: block_c4v36_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v36: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4v3g; else goto c4v3f;
       c4v3g: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4v3f: // global
           _s4lt4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lt4::I64, 64)) goto c4v3p; else goto c4v3q;
       c4v3p: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = 1 << _s4lt4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v3q: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.109854335 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ctestBit_closure" {
     GHC.Int.$fBitsInt64_$ctestBit_closure:
         const GHC.Int.$fBitsInt64_$ctestBit_info;
 },
 GHC.Int.$fBitsInt64_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4v3L,
                       label: GHC.Int.$fBitsInt64_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v3L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4v3P; else goto c4v3Q;
       c4v3P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v3Q: // global
           I64[Sp - 16] = block_c4v3I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v4v; else goto c4v3J;
       u4v4v: // global
           call _c4v3I(R1) args: 0, res: 0, upd: 0;
       c4v3J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v3I() //  [R1]
         { info_tbl: [(c4v3I,
                       label: block_c4v3I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v3I: // global
           I64[Sp] = block_c4v3O_info;
           _s4lta::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lta::I64;
           if (R1 & 7 != 0) goto u4v4u; else goto c4v3S;
       u4v4u: // global
           call _c4v3O(R1) args: 0, res: 0, upd: 0;
       c4v3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v3O() //  [R1]
         { info_tbl: [(c4v3O,
                       label: block_c4v3O_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v3O: // global
           _s4ltc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4ltc::I64, 64)) goto c4v4t; else goto c4v4s;
       c4v4s: // global
           if (I64[Sp + 8] & (1 << _s4ltc::I64) == 0) goto c4v4t; else goto c4v4h;
       c4v4t: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v4h: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.123284102 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateR_closure" {
     GHC.Int.$fBitsInt64_$crotateR_closure:
         const GHC.Int.$fBitsInt64_$crotateR_info;
 },
 GHC.Int.$fBitsInt64_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4v4V,
                       label: GHC.Int.$fBitsInt64_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v4V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4v4Z; else goto c4v50;
       c4v4Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v50: // global
           I64[Sp - 16] = block_c4v4S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v5T; else goto c4v4T;
       u4v5T: // global
           call _c4v4S(R1) args: 0, res: 0, upd: 0;
       c4v4T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v4S() //  [R1]
         { info_tbl: [(c4v4S,
                       label: block_c4v4S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v4S: // global
           I64[Sp - 8] = block_c4v4Y_info;
           _s4ltl::P64 = R1;
           _s4ltm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4ltm::I64;
           P64[Sp + 8] = _s4ltl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v5S; else goto c4v52;
       u4v5S: // global
           call _c4v4Y(R1) args: 0, res: 0, upd: 0;
       c4v52: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v4Y() //  [R1]
         { info_tbl: [(c4v4Y,
                       label: block_c4v4Y_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v4Y: // global
           _s4lts::I64 = -I64[R1 + 7] & 63;
           if (_s4lts::I64 != 0) goto u4v5Q; else goto c4v5M;
       u4v5Q: // global
           I64[Sp + 16] = _s4lts::I64;
           Sp = Sp + 8;
           call _c4v5k() args: 0, res: 0, upd: 0;
       c4v5M: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4v5k() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v5k: // global
           Hp = Hp + 16;
           _s4lts::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4v5J; else goto c4v5I;
       c4v5J: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4v5j_info;
           R1 = _s4lts::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4v5I: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4ltt::I64 = I64[Sp];
           I64[Hp] = (_s4ltt::I64 << _s4lts::I64) | (_s4ltt::I64 >> 64 - _s4lts::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4v5j() //  [R1]
         { info_tbl: [(c4v5j,
                       label: block_c4v5j_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v5j: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4v5k() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.142145473 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt64_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt64_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt64_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4v6u,
                       label: GHC.Int.$fBitsInt64_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v6u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4v6y; else goto c4v6z;
       c4v6y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v6z: // global
           I64[Sp - 16] = block_c4v6r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v75; else goto c4v6s;
       u4v75: // global
           call _c4v6r(R1) args: 0, res: 0, upd: 0;
       c4v6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v6r() //  [R1]
         { info_tbl: [(c4v6r,
                       label: block_c4v6r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v6r: // global
           I64[Sp - 8] = block_c4v6x_info;
           _s4ltB::P64 = R1;
           _s4ltC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4ltC::I64;
           P64[Sp + 8] = _s4ltB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v74; else goto c4v6B;
       u4v74: // global
           call _c4v6x(R1) args: 0, res: 0, upd: 0;
       c4v6B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v6x() //  [R1]
         { info_tbl: [(c4v6x,
                       label: block_c4v6x_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v6x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4v6H; else goto c4v6G;
       c4v6H: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4v6G: // global
           _s4ltE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4ltE::I64, 64)) goto c4v72; else goto c4v73;
       c4v72: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s4ltE::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v73: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.156139806 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cclearBit_closure" {
     GHC.Int.$fBitsInt64_$cclearBit_closure:
         const GHC.Int.$fBitsInt64_$cclearBit_info;
 },
 GHC.Int.$fBitsInt64_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4v7w,
                       label: GHC.Int.$fBitsInt64_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v7w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4v7A; else goto c4v7B;
       c4v7A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v7B: // global
           I64[Sp - 16] = block_c4v7t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v8l; else goto c4v7u;
       u4v8l: // global
           call _c4v7t(R1) args: 0, res: 0, upd: 0;
       c4v7u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v7t() //  [R1]
         { info_tbl: [(c4v7t,
                       label: block_c4v7t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v7t: // global
           I64[Sp] = block_c4v7z_info;
           _s4ltO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ltO::I64;
           if (R1 & 7 != 0) goto u4v8k; else goto c4v7D;
       u4v8k: // global
           call _c4v7z(R1) args: 0, res: 0, upd: 0;
       c4v7D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v7z() //  [R1]
         { info_tbl: [(c4v7z,
                       label: block_c4v7z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v7z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4v7J; else goto c4v7I;
       c4v7J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4v7I: // global
           _s4ltO::I64 = I64[Sp + 8];
           _s4ltQ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4ltQ::I64, 64)) goto c4v87; else goto c4v8j;
       c4v87: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4ltO::I64 & (1 << _s4ltQ::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v8j: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4ltO::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.170951267 UTC

[section ""data" . GHC.Int.$fBitsInt64_$csetBit_closure" {
     GHC.Int.$fBitsInt64_$csetBit_closure:
         const GHC.Int.$fBitsInt64_$csetBit_info;
 },
 GHC.Int.$fBitsInt64_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4v8P,
                       label: GHC.Int.$fBitsInt64_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v8P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4v8T; else goto c4v8U;
       c4v8T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v8U: // global
           I64[Sp - 16] = block_c4v8M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v9q; else goto c4v8N;
       u4v9q: // global
           call _c4v8M(R1) args: 0, res: 0, upd: 0;
       c4v8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v8M() //  [R1]
         { info_tbl: [(c4v8M,
                       label: block_c4v8M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v8M: // global
           I64[Sp - 8] = block_c4v8S_info;
           _s4lu3::P64 = R1;
           _s4lu4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lu4::I64;
           P64[Sp + 8] = _s4lu3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v9p; else goto c4v8W;
       u4v9p: // global
           call _c4v8S(R1) args: 0, res: 0, upd: 0;
       c4v8W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4v8S() //  [R1]
         { info_tbl: [(c4v8S,
                       label: block_c4v8S_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v8S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4v92; else goto c4v91;
       c4v92: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4v91: // global
           _s4lu6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lu6::I64, 64)) goto c4v9n; else goto c4v9o;
       c4v9n: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s4lu6::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v9o: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.184165688 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateL_closure" {
     GHC.Int.$fBitsInt64_$crotateL_closure:
         const GHC.Int.$fBitsInt64_$crotateL_info;
 },
 GHC.Int.$fBitsInt64_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4v9O,
                       label: GHC.Int.$fBitsInt64_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4v9O: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt64_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.189446788 UTC

[section ""data" . GHC.Int.$fBitsInt64_closure" {
     GHC.Int.$fBitsInt64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fBitsInt64_$c.&._closure+2;
         const GHC.Int.$fBitsInt64_$c.|._closure+2;
         const GHC.Int.$fBitsInt64_$cxor_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt64_$cshift_closure+2;
         const GHC.Int.$fBitsInt64_$crotate_closure+2;
         const GHC.Int.$fBitsInt10_closure+1;
         const GHC.Int.$fBitsInt64_$cbit_closure+1;
         const GHC.Int.$fBitsInt64_$csetBit_closure+2;
         const GHC.Int.$fBitsInt64_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt64_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt64_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt64_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt64_$crotateL_closure+2;
         const GHC.Int.$fBitsInt64_$crotateR_closure+2;
         const GHC.Int.$fBitsInt64_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.193198258 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_closure" {
     GHC.Int.$fFiniteBitsInt64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt64_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.1984891 UTC

[section ""data" . GHC.Int.$fReadInt64_go_closure" {
     GHC.Int.$fReadInt64_go_closure:
         const GHC.Int.$fReadInt64_go_info;
 },
 sat_s4luo_entry() //  [R1]
         { info_tbl: [(c4vag,
                       label: sat_s4luo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vag: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vah; else goto c4vai;
       c4vah: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vai: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4lum_entry() //  [R1]
         { info_tbl: [(c4vaq,
                       label: sat_s4lum_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vaq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4vau; else goto c4vav;
       c4vau: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vav: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4van_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4vaz; else goto c4vao;
       u4vaz: // global
           call _c4van(R1) args: 0, res: 0, upd: 0;
       c4vao: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4van() //  [R1]
         { info_tbl: [(c4van,
                       label: block_c4van_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4van: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vay; else goto c4vax;
       c4vay: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4vax: // global
           _s4lul::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lul::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt64_go_entry() //  [R2]
         { info_tbl: [(c4vaE,
                       label: GHC.Int.$fReadInt64_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vaE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vaF; else goto c4vaG;
       c4vaF: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vaG: // global
           I64[Sp - 8] = block_c4va1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vaQ; else goto c4va2;
       u4vaQ: // global
           call _c4va1(R1) args: 0, res: 0, upd: 0;
       c4va2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4va1() //  [R1]
         { info_tbl: [(c4va1,
                       label: block_c4va1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4va1: // global
           if (R1 & 7 == 1) goto c4vaB; else goto c4vaC;
       c4vaB: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4vaC: // global
           I64[Sp - 8] = block_c4va7_info;
           _s4lug::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lug::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vaP; else goto c4va8;
       u4vaP: // global
           call _c4va7(R1) args: 0, res: 0, upd: 0;
       c4va8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4va7() //  [R1]
         { info_tbl: [(c4va7,
                       label: block_c4va7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4va7: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4vaO; else goto c4vaN;
       c4vaO: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vaN: // global
           _s4lui::P64 = P64[R1 + 7];
           _s4luj::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4luo_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lum_info;
           P64[Hp - 48] = _s4lui::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4luj::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.222052917 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadsPrec_closure" {
     GHC.Int.$fReadInt64_$creadsPrec_closure:
         const GHC.Int.$fReadInt64_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4vbv,
                       label: GHC.Int.$fReadInt64_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vbv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vbz; else goto c4vbA;
       c4vbz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vbA: // global
           I64[Sp - 16] = block_c4vbt_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4luq::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4luq::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vbt() //  [R1]
         { info_tbl: [(c4vbt,
                       label: block_c4vbt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vbt: // global
           _s4luq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4vby_info;
           R3 = _s4luq::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vby() //  [R1]
         { info_tbl: [(c4vby,
                       label: block_c4vby_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vby: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.230670269 UTC

[section ""data" . GHC.Int.$fReadInt10_closure" {
     GHC.Int.$fReadInt10_closure:
         const GHC.Int.$fReadInt10_info;
         const 0;
 },
 sat_s4luv_entry() //  [R1, R2]
         { info_tbl: [(c4vc0,
                       label: sat_s4luv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vc0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt64_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt10_entry() //  [R2, R3]
         { info_tbl: [(c4vc6,
                       label: GHC.Int.$fReadInt10_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vc6: // global
           _s4luu::P64 = R3;
           _s4lut::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4vc7; else goto c4vc8;
       c4vc8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vca; else goto c4vc9;
       c4vca: // global
           HpAlloc = 16;
           goto c4vc7;
       c4vc7: // global
           R3 = _s4luu::P64;
           R2 = _s4lut::P64;
           R1 = GHC.Int.$fReadInt10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vc9: // global
           I64[Hp - 8] = sat_s4luv_info;
           P64[Hp] = _s4lut::P64;
           I64[Sp - 8] = block_c4vc3_info;
           R3 = _s4luu::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vc3() //  [R1]
         { info_tbl: [(c4vc3,
                       label: block_c4vc3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vc3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vcd; else goto c4vcc;
       c4vcd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vcc: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.239191806 UTC

[section ""data" . GHC.Int.$fReadInt9_closure" {
     GHC.Int.$fReadInt9_closure:
         const GHC.Int.$fReadInt9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4vcz_srtd" {
     u4vcz_srtd:
         const S4lDl_srt+504;
         const 70;
         const 1;
         const 32;
 },
 GHC.Int.$fReadInt9_entry() //  [R1]
         { info_tbl: [(c4vcw,
                       label: GHC.Int.$fReadInt9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vcw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4vcx; else goto c4vcy;
       c4vcx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vcy: // global
           (_c4vct::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4vct::I64 == 0) goto c4vcv; else goto c4vcu;
       c4vcv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4vcu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4vct::I64;
           R2 = GHC.Int.$fReadInt10_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.247287535 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadList_closure" {
     GHC.Int.$fReadInt64_$creadList_closure:
         const GHC.Int.$fReadInt64_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadList_entry() //  [R2]
         { info_tbl: [(c4vcM,
                       label: GHC.Int.$fReadInt64_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vcM: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt9_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.252383898 UTC

[section ""data" . GHC.Int.$fReadInt7_closure" {
     GHC.Int.$fReadInt7_closure:
         const GHC.Int.$fReadInt7_info;
         const 0;
 },
 GHC.Int.$fReadInt7_entry() //  [R2, R3]
         { info_tbl: [(c4vd0,
                       label: GHC.Int.$fReadInt7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vd0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vd1; else goto c4vd2;
       c4vd1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vd2: // global
           I64[Sp - 8] = block_c4vcX_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt64_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vcX() //  [R1]
         { info_tbl: [(c4vcX,
                       label: block_c4vcX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vcX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vd5; else goto c4vd4;
       c4vd5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vd4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.258366652 UTC

[section ""data" . GHC.Int.$fReadInt64_closure" {
     GHC.Int.$fReadInt64_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt64_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt64_$creadList_closure+1;
         const GHC.Int.$fReadInt10_closure+2;
         const GHC.Int.$fReadInt7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.261140886 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquot_closure" {
     GHC.Int.$fIntegralInt64_$cquot_closure:
         const GHC.Int.$fIntegralInt64_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4vdn,
                       label: GHC.Int.$fIntegralInt64_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vdn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vdr; else goto c4vds;
       c4vdr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vds: // global
           I64[Sp - 16] = block_c4vdk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vdX; else goto c4vdl;
       u4vdX: // global
           call _c4vdk(R1) args: 0, res: 0, upd: 0;
       c4vdl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vdk() //  [R1]
         { info_tbl: [(c4vdk,
                       label: block_c4vdk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vdk: // global
           I64[Sp] = block_c4vdq_info;
           _s4luF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4luF::I64;
           if (R1 & 7 != 0) goto u4vdW; else goto c4vdu;
       u4vdW: // global
           call _c4vdq(R1) args: 0, res: 0, upd: 0;
       c4vdu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vdq() //  [R1]
         { info_tbl: [(c4vdq,
                       label: block_c4vdq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vdq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vdA; else goto c4vdz;
       c4vdA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vdz: // global
           _s4luF::I64 = I64[Sp + 8];
           _s4luI::I64 = I64[R1 + 7];
           if (_s4luI::I64 != (-1)) goto u4vdV; else goto c4vdT;
       u4vdV: // global
           if (_s4luI::I64 != 0) goto c4vdI; else goto c4vdU;
       c4vdI: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4luF::I64, _s4luI::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4vdU: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vdT: // global
           if (_s4luF::I64 == (-9223372036854775808)) goto c4vdS; else goto c4vdR;
       c4vdS: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vdR: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4luF::I64, (-1));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.271772453 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$crem_closure" {
     GHC.Int.$fIntegralInt64_$crem_closure:
         const GHC.Int.$fIntegralInt64_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4veo,
                       label: GHC.Int.$fIntegralInt64_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4veo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ves; else goto c4vet;
       c4ves: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vet: // global
           I64[Sp - 16] = block_c4vel_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4veO; else goto c4vem;
       u4veO: // global
           call _c4vel(R1) args: 0, res: 0, upd: 0;
       c4vem: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vel() //  [R1]
         { info_tbl: [(c4vel,
                       label: block_c4vel_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vel: // global
           I64[Sp] = block_c4ver_info;
           _s4luR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4luR::I64;
           if (R1 & 7 != 0) goto u4veN; else goto c4vev;
       u4veN: // global
           call _c4ver(R1) args: 0, res: 0, upd: 0;
       c4vev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ver() //  [R1]
         { info_tbl: [(c4ver,
                       label: block_c4ver_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ver: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4veB; else goto c4veA;
       c4veB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4veA: // global
           _s4luU::I64 = I64[R1 + 7];
           if (_s4luU::I64 != (-1)) goto u4veM; else goto c4veK;
       u4veM: // global
           if (_s4luU::I64 != 0) goto c4veJ; else goto c4veL;
       c4veJ: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Rem_W64(I64[Sp + 8], _s4luU::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4veL: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4veK: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.280897838 UTC

[section ""data" . GHC.Int.$w$cdiv2_closure" {
     GHC.Int.$w$cdiv2_closure:
         const GHC.Int.$w$cdiv2_info;
         const 0;
 },
 GHC.Int.$w$cdiv2_entry() //  [R2, R3]
         { info_tbl: [(c4vfe,
                       label: GHC.Int.$w$cdiv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vfe: // global
           if (R3 == (-1)) goto c4vfc; else goto u4vfn;
       c4vfc: // global
           if (R2 == (-9223372036854775808)) goto c4vfm; else goto c4vfl;
       c4vfm: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vfl: // global
           R3 = (-1);
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
       u4vfn: // global
           if (R3 == 0) goto c4vfd; else goto c4vfb;
       c4vfd: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vfb: // global
           R3 = R3;
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.286841584 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdiv_closure" {
     GHC.Int.$fIntegralInt64_$cdiv_closure:
         const GHC.Int.$fIntegralInt64_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4vfA,
                       label: GHC.Int.$fIntegralInt64_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vfA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vfN; else goto c4vfO;
       c4vfN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vfO: // global
           I64[Sp - 16] = block_c4vfx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vfV; else goto c4vfy;
       u4vfV: // global
           call _c4vfx(R1) args: 0, res: 0, upd: 0;
       c4vfy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vfx() //  [R1]
         { info_tbl: [(c4vfx,
                       label: block_c4vfx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vfx: // global
           I64[Sp] = block_c4vfD_info;
           _s4lv5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lv5::I64;
           if (R1 & 7 != 0) goto u4vfU; else goto c4vfE;
       u4vfU: // global
           call _c4vfD(R1) args: 0, res: 0, upd: 0;
       c4vfE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vfD() //  [R1]
         { info_tbl: [(c4vfD,
                       label: block_c4vfD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vfD: // global
           _s4lv5::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4vfI_info;
           R3 = I64[R1 + 7];
           R2 = _s4lv5::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vfI() //  [R1]
         { info_tbl: [(c4vfI,
                       label: block_c4vfI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vfI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vfT; else goto c4vfS;
       c4vfT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4vfS: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.297198191 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cmod_closure" {
     GHC.Int.$fIntegralInt64_$cmod_closure:
         const GHC.Int.$fIntegralInt64_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4vgk,
                       label: GHC.Int.$fIntegralInt64_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vgk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vgo; else goto c4vgp;
       c4vgo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vgp: // global
           I64[Sp - 16] = block_c4vgh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vgM; else goto c4vgi;
       u4vgM: // global
           call _c4vgh(R1) args: 0, res: 0, upd: 0;
       c4vgi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vgh() //  [R1]
         { info_tbl: [(c4vgh,
                       label: block_c4vgh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vgh: // global
           I64[Sp] = block_c4vgn_info;
           _s4lvc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lvc::I64;
           if (R1 & 7 != 0) goto u4vgL; else goto c4vgr;
       u4vgL: // global
           call _c4vgn(R1) args: 0, res: 0, upd: 0;
       c4vgr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vgn() //  [R1]
         { info_tbl: [(c4vgn,
                       label: block_c4vgn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vgn: // global
           _s4lvf::I64 = I64[R1 + 7];
           if (_s4lvf::I64 != (-1)) goto u4vgK; else goto c4vgI;
       u4vgK: // global
           if (_s4lvf::I64 != 0) goto c4vgE; else goto c4vgJ;
       c4vgE: // global
           _s4lvc::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4vgy_info;
           R3 = _s4lvf::I64;
           R2 = _s4lvc::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4vgJ: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vgI: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4vgy() //  [R1]
         { info_tbl: [(c4vgy,
                       label: block_c4vgy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vgy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vgH; else goto c4vgG;
       c4vgH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4vgG: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.311500579 UTC

[section ""data" . lvl9_r4kPA_closure" {
     lvl9_r4kPA_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt10_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.315388207 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquotRem_closure" {
     GHC.Int.$fIntegralInt64_$cquotRem_closure:
         const GHC.Int.$fIntegralInt64_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4vhd,
                       label: GHC.Int.$fIntegralInt64_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vhd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vhh; else goto c4vhi;
       c4vhh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vhi: // global
           I64[Sp - 16] = block_c4vha_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vhL; else goto c4vhb;
       u4vhL: // global
           call _c4vha(R1) args: 0, res: 0, upd: 0;
       c4vhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vha() //  [R1]
         { info_tbl: [(c4vha,
                       label: block_c4vha_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vha: // global
           I64[Sp] = block_c4vhg_info;
           _s4lvl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lvl::I64;
           if (R1 & 7 != 0) goto u4vhK; else goto c4vhk;
       u4vhK: // global
           call _c4vhg(R1) args: 0, res: 0, upd: 0;
       c4vhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vhg() //  [R1]
         { info_tbl: [(c4vhg,
                       label: block_c4vhg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vhg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4vhq; else goto c4vhp;
       c4vhq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vhp: // global
           _s4lvl::I64 = I64[Sp + 8];
           _s4lvo::I64 = I64[R1 + 7];
           if (_s4lvo::I64 != (-1)) goto u4vhJ; else goto c4vhH;
       u4vhJ: // global
           if (_s4lvo::I64 != 0) goto c4vhx; else goto c4vhI;
       c4vhx: // global
           (_s4lvq::I64, _s4lvr::I64) = call MO_S_QuotRem W64(_s4lvl::I64, _s4lvo::I64);
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4lvr::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4lvq::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4vhI: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vhH: // global
           if (_s4lvl::I64 == (-9223372036854775808)) goto c4vhG; else goto c4vhF;
       c4vhG: // global
           Hp = Hp - 56;
           R1 = lvl9_r4kPA_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4vhF: // global
           (_s4lvw::I64, _s4lvx::I64) = call MO_S_QuotRem W64(_s4lvl::I64, (-1));
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4lvx::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4lvw::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.33221744 UTC

[section ""data" . GHC.Int.$w$cdivMod2_closure" {
     GHC.Int.$w$cdivMod2_closure:
         const GHC.Int.$w$cdivMod2_info;
         const 0;
 },
 GHC.Int.$w$cdivMod2_entry() //  [R2, R3]
         { info_tbl: [(c4vig,
                       label: GHC.Int.$w$cdivMod2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vig: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4vih; else goto c4vii;
       c4vih: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vii: // global
           if (R3 == 0) goto c4vif; else goto c4vie;
       c4vif: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vie: // global
           if (R3 == (-1)) goto c4vk5; else goto u4vk6;
       c4vk5: // global
           if (R2 == (-9223372036854775808)) goto c4vk4; else goto u4vk7;
       c4vk4: // global
           R2 = GHC.Int.$fBitsInt10_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4vk7: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4vk9;
       u4vk6: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4vk9;
       u4vk9: // global
           call _c4vin() args: 0, res: 0, upd: 0;
     }
 },
 _c4vin() //  []
         { info_tbl: [(c4vin,
                       label: block_c4vin_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vin: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4vir; else goto c4viq;
       c4vir: // global
           HpAlloc = 32;
           I64[Sp] = block_c4vin_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4viq: // global
           _s4lvB::I64 = I64[Sp + 8];
           _s4lvD::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lvB::I64, 0)) goto c4vj2; else goto c4vjV;
       c4vj2: // global
           if (%MO_S_Ge_W64(_s4lvB::I64, 0)) goto c4viB; else goto c4vj0;
       c4viB: // global
           (_s4lvI::I64, _s4lvJ::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvJ::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvI::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vj0: // global
           if (%MO_S_Le_W64(_s4lvD::I64, 0)) goto c4viJ; else goto c4viZ;
       c4viJ: // global
           (_s4lvO::I64, _s4lvP::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvP::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvO::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4viZ: // global
           (_s4lvU::I64, _s4lvV::I64) = call MO_S_QuotRem W64(_s4lvB::I64 + 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvV::I64 + _s4lvD::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvU::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vjV: // global
           if (%MO_S_Ge_W64(_s4lvD::I64, 0)) goto c4vjE; else goto c4vjU;
       c4vjE: // global
           if (%MO_S_Ge_W64(_s4lvB::I64, 0)) goto c4vjd; else goto c4vjC;
       c4vjd: // global
           (_s4lw4::I64, _s4lw5::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lw5::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lw4::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vjC: // global
           if (%MO_S_Le_W64(_s4lvD::I64, 0)) goto c4vjl; else goto c4vjB;
       c4vjl: // global
           (_s4lwa::I64, _s4lwb::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwb::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwa::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vjB: // global
           (_s4lwg::I64, _s4lwh::I64) = call MO_S_QuotRem W64(_s4lvB::I64 + 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwh::I64 + _s4lvD::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwg::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vjU: // global
           (_s4lwp::I64, _s4lwq::I64) = call MO_S_QuotRem W64(_s4lvB::I64 - 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwq::I64 + _s4lvD::I64 + 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwp::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.350201176 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdivMod_closure" {
     GHC.Int.$fIntegralInt64_$cdivMod_closure:
         const GHC.Int.$fIntegralInt64_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4vkK,
                       label: GHC.Int.$fIntegralInt64_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vkK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vkV; else goto c4vkW;
       c4vkV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vkW: // global
           I64[Sp - 16] = block_c4vkH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vl3; else goto c4vkI;
       u4vl3: // global
           call _c4vkH(R1) args: 0, res: 0, upd: 0;
       c4vkI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vkH() //  [R1]
         { info_tbl: [(c4vkH,
                       label: block_c4vkH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vkH: // global
           I64[Sp] = block_c4vkN_info;
           _s4lwC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lwC::I64;
           if (R1 & 7 != 0) goto u4vl2; else goto c4vkO;
       u4vl2: // global
           call _c4vkN(R1) args: 0, res: 0, upd: 0;
       c4vkO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vkN() //  [R1]
         { info_tbl: [(c4vkN,
                       label: block_c4vkN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vkN: // global
           _s4lwC::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4vkS_info;
           R3 = I64[R1 + 7];
           R2 = _s4lwC::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vkS() //  [R1, R2]
         { info_tbl: [(c4vkS,
                       label: block_c4vkS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vkS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4vl1; else goto c4vl0;
       c4vl1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4vl0: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.365884623 UTC

[section ""data" . GHC.Int.$fIxInt64_$crange_closure" {
     GHC.Int.$fIxInt64_$crange_closure:
         const GHC.Int.$fIxInt64_$crange_info;
 },
 GHC.Int.$fIxInt64_$crange_entry() //  [R2]
         { info_tbl: [(c4vls,
                       label: GHC.Int.$fIxInt64_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vls: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vlt; else goto c4vlu;
       c4vlt: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vlu: // global
           I64[Sp - 8] = block_c4vlp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vly; else goto c4vlq;
       u4vly: // global
           call _c4vlp(R1) args: 0, res: 0, upd: 0;
       c4vlq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vlp() //  [R1]
         { info_tbl: [(c4vlp,
                       label: block_c4vlp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vlp: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.372106075 UTC

[section ""data" . GHC.Int.$fRealInt64_$ctoRational_closure" {
     GHC.Int.$fRealInt64_$ctoRational_closure:
         const GHC.Int.$fRealInt64_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt64_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4vlP,
                       label: GHC.Int.$fRealInt64_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vlP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vm3; else goto c4vm4;
       c4vm3: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vm4: // global
           I64[Sp - 8] = block_c4vlM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vmb; else goto c4vlN;
       u4vmb: // global
           call _c4vlM(R1) args: 0, res: 0, upd: 0;
       c4vlN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vlM() //  [R1]
         { info_tbl: [(c4vlM,
                       label: block_c4vlM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vlM: // global
           I64[Sp] = block_c4vlS_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vlS() //  [R1]
         { info_tbl: [(c4vlS,
                       label: block_c4vlS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vlS: // global
           I64[Sp] = block_c4vlW_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vlW() //  [R1]
         { info_tbl: [(c4vlW,
                       label: block_c4vlW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vlW: // global
           I64[Sp] = block_c4vm0_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vm0() //  [R1, R2]
         { info_tbl: [(c4vm0,
                       label: block_c4vm0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vm0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4vma; else goto c4vm9;
       c4vma: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4vm9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.383977823 UTC

[section ""data" . GHC.Int.$fRealInt64_closure" {
     GHC.Int.$fRealInt64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt64_closure+1;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fRealInt64_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.386867488 UTC

[section ""data" . GHC.Int.$fIntegralInt64_closure" {
     GHC.Int.$fIntegralInt64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt64_closure+1;
         const GHC.Int.$fEnumInt64_closure+1;
         const GHC.Int.$fIntegralInt64_$cquot_closure+2;
         const GHC.Int.$fIntegralInt64_$crem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt64_$cmod_closure+2;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt64_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.390751275 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt64_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt64_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt64_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4vmE,
                       label: GHC.Int.$fIxInt64_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vmE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vmV; else goto c4vmW;
       c4vmV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vmW: // global
           I64[Sp - 16] = block_c4vmB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vn3; else goto c4vmC;
       u4vn3: // global
           call _c4vmB(R1) args: 0, res: 0, upd: 0;
       c4vmC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vmB() //  [R1]
         { info_tbl: [(c4vmB,
                       label: block_c4vmB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vmB: // global
           I64[Sp] = block_c4vmH_info;
           _s4lwX::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lwX::P64;
           if (R1 & 7 != 0) goto u4vn2; else goto c4vmI;
       u4vn2: // global
           call _c4vmH(R1) args: 0, res: 0, upd: 0;
       c4vmI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vmH() //  [R1]
         { info_tbl: [(c4vmH,
                       label: block_c4vmH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vmH: // global
           I64[Sp] = block_c4vmM_info;
           _s4lx0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lx0::I64;
           if (R1 & 7 != 0) goto u4vn4; else goto c4vmN;
       u4vn4: // global
           call _c4vmM(R1) args: 0, res: 0, upd: 0;
       c4vmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vmM() //  [R1]
         { info_tbl: [(c4vmM,
                       label: block_c4vmM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vmM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vn1; else goto c4vn0;
       c4vn1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vn0: // global
           _s4lx3::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lx3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.404328077 UTC

[section ""data" . GHC.Int.$fIxInt64_$crangeSize_closure" {
     GHC.Int.$fIxInt64_$crangeSize_closure:
         const GHC.Int.$fIxInt64_$crangeSize_info;
 },
 GHC.Int.$fIxInt64_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4vnw,
                       label: GHC.Int.$fIxInt64_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vnw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vnF; else goto c4vnG;
       c4vnF: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vnG: // global
           I64[Sp - 8] = block_c4vnt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vo5; else goto c4vnu;
       u4vo5: // global
           call _c4vnt(R1) args: 0, res: 0, upd: 0;
       c4vnu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vnt() //  [R1]
         { info_tbl: [(c4vnt,
                       label: block_c4vnt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vnt: // global
           I64[Sp - 8] = block_c4vnz_info;
           _s4lx7::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lx7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vo4; else goto c4vnA;
       u4vo4: // global
           call _c4vnz(R1) args: 0, res: 0, upd: 0;
       c4vnA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vnz() //  [R1]
         { info_tbl: [(c4vnz,
                       label: block_c4vnz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vnz: // global
           I64[Sp] = block_c4vnE_info;
           _s4lx9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lx9::I64;
           if (R1 & 7 != 0) goto u4vo6; else goto c4vnJ;
       u4vo6: // global
           call _c4vnE(R1) args: 0, res: 0, upd: 0;
       c4vnJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vnE() //  [R1]
         { info_tbl: [(c4vnE,
                       label: block_c4vnE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vnE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vnP; else goto c4vnO;
       c4vnP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vnO: // global
           _s4lx9::I64 = I64[Sp + 8];
           _s4lxb::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lx9::I64,
                            _s4lxb::I64)) goto c4vnT; else goto c4vo3;
       c4vnT: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4vo3: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxb::I64 - _s4lx9::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.418658783 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt64_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt64_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4voA,
                       label: GHC.Int.$fIxInt64_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4voA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4voU; else goto c4voV;
       c4voU: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4voV: // global
           I64[Sp - 8] = block_c4vox_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vp2; else goto c4voy;
       u4vp2: // global
           call _c4vox(R1) args: 0, res: 0, upd: 0;
       c4voy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vox() //  [R1]
         { info_tbl: [(c4vox,
                       label: block_c4vox_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vox: // global
           I64[Sp - 8] = block_c4voD_info;
           _s4lxh::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lxh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vp1; else goto c4voE;
       u4vp1: // global
           call _c4voD(R1) args: 0, res: 0, upd: 0;
       c4voE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4voD() //  [R1]
         { info_tbl: [(c4voD,
                       label: block_c4voD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4voD: // global
           I64[Sp] = block_c4voI_info;
           _s4lxk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxk::I64;
           if (R1 & 7 != 0) goto u4vp3; else goto c4voJ;
       u4vp3: // global
           call _c4voI(R1) args: 0, res: 0, upd: 0;
       c4voJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4voI() //  [R1]
         { info_tbl: [(c4voI,
                       label: block_c4voI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4voI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vp0; else goto c4voZ;
       c4vp0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4voZ: // global
           _s4lxo::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.431211857 UTC

[section ""data" . GHC.Int.$fIxInt64_$cindex_closure" {
     GHC.Int.$fIxInt64_$cindex_closure:
         const GHC.Int.$fIxInt64_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt64_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4vpw,
                       label: GHC.Int.$fIxInt64_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vpw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4vpF; else goto c4vpG;
       c4vpF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vpG: // global
           I64[Sp - 16] = block_c4vpt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vqf; else goto c4vpu;
       u4vqf: // global
           call _c4vpt(R1) args: 0, res: 0, upd: 0;
       c4vpu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vpt() //  [R1]
         { info_tbl: [(c4vpt,
                       label: block_c4vpt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vpt: // global
           I64[Sp - 8] = block_c4vpz_info;
           _s4lxt::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lxt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vqe; else goto c4vpA;
       u4vqe: // global
           call _c4vpz(R1) args: 0, res: 0, upd: 0;
       c4vpA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vpz() //  [R1]
         { info_tbl: [(c4vpz,
                       label: block_c4vpz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vpz: // global
           I64[Sp] = block_c4vpE_info;
           _s4lxv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lxv::I64;
           if (R1 & 7 != 0) goto u4vqg; else goto c4vpJ;
       u4vqg: // global
           call _c4vpE(R1) args: 0, res: 0, upd: 0;
       c4vpJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vpE() //  [R1]
         { info_tbl: [(c4vpE,
                       label: block_c4vpE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vpE: // global
           _s4lxx::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lxx::I64)) goto c4vpR; else goto c4vpV;
       c4vpR: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4vpV: // global
           I64[Sp] = block_c4vpU_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxx::I64;
           if (R1 & 7 != 0) goto u4vqh; else goto c4vpW;
       u4vqh: // global
           call _c4vpU(R1) args: 0, res: 0, upd: 0;
       c4vpW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vpU() //  [R1]
         { info_tbl: [(c4vpU,
                       label: block_c4vpU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vpU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vq2; else goto c4vq1;
       c4vq2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vq1: // global
           _s4lxx::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4lxx::I64,
                            I64[R1 + 7])) goto c4vq6; else goto c4vqd;
       c4vq6: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4vqd: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxx::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.444624464 UTC

[section ""data" . GHC.Int.$fIxInt64_closure" {
     GHC.Int.$fIxInt64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fIxInt64_$crange_closure+1;
         const GHC.Int.$fIxInt64_$cindex_closure+2;
         const GHC.Int.$fIxInt64_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt64_$cinRange_closure+2;
         const GHC.Int.$fIxInt64_$crangeSize_closure+1;
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.447341706 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowsPrec_closure" {
     GHC.Int.$fShowInt64_$cshowsPrec_closure:
         const GHC.Int.$fShowInt64_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt64_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4vqQ,
                       label: GHC.Int.$fShowInt64_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vqQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4vr1; else goto c4vr2;
       c4vr1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vr2: // global
           I64[Sp - 24] = block_c4vqN_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4vr9; else goto c4vqO;
       u4vr9: // global
           call _c4vqN(R1) args: 0, res: 0, upd: 0;
       c4vqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vqN() //  [R1]
         { info_tbl: [(c4vqN,
                       label: block_c4vqN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vqN: // global
           I64[Sp] = block_c4vqT_info;
           _s4lxH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxH::I64;
           if (R1 & 7 != 0) goto u4vr8; else goto c4vqU;
       u4vr8: // global
           call _c4vqT(R1) args: 0, res: 0, upd: 0;
       c4vqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vqT() //  [R1]
         { info_tbl: [(c4vqT,
                       label: block_c4vqT_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vqT: // global
           _s4lxF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4vqY_info;
           R4 = _s4lxF::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vqY() //  [R1, R2]
         { info_tbl: [(c4vqY,
                       label: block_c4vqY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vqY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4vr7; else goto c4vr6;
       c4vr7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4vr6: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.459528374 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshow_closure" {
     GHC.Int.$fShowInt64_$cshow_closure:
         const GHC.Int.$fShowInt64_$cshow_info;
 },
 GHC.Int.$fShowInt64_$cshow_entry() //  [R2]
         { info_tbl: [(c4vry,
                       label: GHC.Int.$fShowInt64_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vry: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vrE; else goto c4vrF;
       c4vrE: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vrF: // global
           I64[Sp - 8] = block_c4vrv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vrK; else goto c4vrw;
       u4vrK: // global
           call _c4vrv(R1) args: 0, res: 0, upd: 0;
       c4vrw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vrv() //  [R1]
         { info_tbl: [(c4vrv,
                       label: block_c4vrv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vrv: // global
           I64[Sp] = block_c4vrB_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vrB() //  [R1, R2]
         { info_tbl: [(c4vrB,
                       label: block_c4vrB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vrB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4vrJ; else goto c4vrI;
       c4vrJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4vrI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.468564357 UTC

[section ""data" . GHC.Int.$fShowInt3_closure" {
     GHC.Int.$fShowInt3_closure:
         const GHC.Int.$fShowInt3_info;
 },
 GHC.Int.$fShowInt3_entry() //  [R2, R3]
         { info_tbl: [(c4vs5,
                       label: GHC.Int.$fShowInt3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vs5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vsb; else goto c4vsc;
       c4vsb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vsc: // global
           I64[Sp - 16] = block_c4vs2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vsh; else goto c4vs3;
       u4vsh: // global
           call _c4vs2(R1) args: 0, res: 0, upd: 0;
       c4vs3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4vs2() //  [R1]
         { info_tbl: [(c4vs2,
                       label: block_c4vs2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vs2: // global
           _s4lxU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4vs8_info;
           R4 = _s4lxU::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4vs8() //  [R1, R2]
         { info_tbl: [(c4vs8,
                       label: block_c4vs8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vs8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4vsg; else goto c4vsf;
       c4vsg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4vsf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.477202324 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowList_closure" {
     GHC.Int.$fShowInt64_$cshowList_closure:
         const GHC.Int.$fShowInt64_$cshowList_info;
 },
 GHC.Int.$fShowInt64_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4vsz,
                       label: GHC.Int.$fShowInt64_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vsz: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt3_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.480885346 UTC

[section ""data" . GHC.Int.$fShowInt64_closure" {
     GHC.Int.$fShowInt64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt64_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt64_$cshow_closure+1;
         const GHC.Int.$fShowInt64_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.48387885 UTC

[section ""data" . GHC.Int.uncheckedIShiftL64#_closure" {
     GHC.Int.uncheckedIShiftL64#_closure:
         const GHC.Int.uncheckedIShiftL64#_info;
 },
 GHC.Int.uncheckedIShiftL64#_entry() //  [R2, R3]
         { info_tbl: [(c4vsM,
                       label: GHC.Int.uncheckedIShiftL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vsM: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.489190079 UTC

[section ""data" . GHC.Int.uncheckedIShiftRA64#_closure" {
     GHC.Int.uncheckedIShiftRA64#_closure:
         const GHC.Int.uncheckedIShiftRA64#_info;
 },
 GHC.Int.uncheckedIShiftRA64#_entry() //  [R2, R3]
         { info_tbl: [(c4vt0,
                       label: GHC.Int.uncheckedIShiftRA64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vt0: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.49430683 UTC

[section ""cstring" . GHC.Int.$trModule4_bytes" {
     GHC.Int.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.496499836 UTC

[section ""data" . GHC.Int.$trModule3_closure" {
     GHC.Int.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.498357537 UTC

[section ""cstring" . GHC.Int.$trModule2_bytes" {
     GHC.Int.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.499938524 UTC

[section ""data" . GHC.Int.$trModule1_closure" {
     GHC.Int.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.5015924 UTC

[section ""data" . GHC.Int.$trModule_closure" {
     GHC.Int.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Int.$trModule3_closure+1;
         const GHC.Int.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.503359597 UTC

[section ""data" . $krep_r4kPB_closure" {
     $krep_r4kPB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.505295777 UTC

[section ""data" . GHC.Int.$tcInt7_closure" {
     GHC.Int.$tcInt7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.507182117 UTC

[section ""data" . GHC.Int.$tcInt8_closure" {
     GHC.Int.$tcInt8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt7_closure+1;
         const GHC.Types.krep$*_closure;
         const 1422706860619545536;
         const 2126344328513082648;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.509184069 UTC

[section ""data" . $krep1_r4kPC_closure" {
     $krep1_r4kPC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.512790726 UTC

[section ""data" . GHC.Int.$tc'I8#1_closure" {
     GHC.Int.$tc'I8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep1_r4kPC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.515370053 UTC

[section ""cstring" . GHC.Int.$tc'I8#3_bytes" {
     GHC.Int.$tc'I8#3_bytes:
         I8[] [39,73,56,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.517699207 UTC

[section ""data" . GHC.Int.$tc'I8#2_closure" {
     GHC.Int.$tc'I8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I8#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.519476177 UTC

[section ""data" . GHC.Int.$tc'I8#_closure" {
     GHC.Int.$tc'I8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I8#2_closure+1;
         const GHC.Int.$tc'I8#1_closure+4;
         const 5349338056284818619;
         const 13298037281129101406;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.521454844 UTC

[section ""data" . GHC.Int.$tcInt1_closure" {
     GHC.Int.$tcInt1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.523292489 UTC

[section ""data" . GHC.Int.$tcInt16_closure" {
     GHC.Int.$tcInt16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16329117591681623238;
         const 13363230803330610095;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.525586807 UTC

[section ""data" . $krep2_r4kPD_closure" {
     $krep2_r4kPD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.527530447 UTC

[section ""data" . GHC.Int.$tc'I16#1_closure" {
     GHC.Int.$tc'I16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep2_r4kPD_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.530171628 UTC

[section ""cstring" . GHC.Int.$tc'I16#3_bytes" {
     GHC.Int.$tc'I16#3_bytes:
         I8[] [39,73,49,54,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.532258012 UTC

[section ""data" . GHC.Int.$tc'I16#2_closure" {
     GHC.Int.$tc'I16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I16#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.534315659 UTC

[section ""data" . GHC.Int.$tc'I16#_closure" {
     GHC.Int.$tc'I16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I16#2_closure+1;
         const GHC.Int.$tc'I16#1_closure+4;
         const 1077432500071562197;
         const 13676251251348512601;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.536236387 UTC

[section ""data" . GHC.Int.$tcInt3_closure" {
     GHC.Int.$tcInt3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.538562436 UTC

[section ""data" . GHC.Int.$tcInt32_closure" {
     GHC.Int.$tcInt32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt3_closure+1;
         const GHC.Types.krep$*_closure;
         const 5115671124548181797;
         const 6203735229629729265;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.540423003 UTC

[section ""data" . $krep3_r4kPE_closure" {
     $krep3_r4kPE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.542477989 UTC

[section ""data" . GHC.Int.$tc'I32#1_closure" {
     GHC.Int.$tc'I32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep3_r4kPE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.545137499 UTC

[section ""cstring" . GHC.Int.$tc'I32#3_bytes" {
     GHC.Int.$tc'I32#3_bytes:
         I8[] [39,73,51,50,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.547749869 UTC

[section ""data" . GHC.Int.$tc'I32#2_closure" {
     GHC.Int.$tc'I32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I32#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.550976738 UTC

[section ""data" . GHC.Int.$tc'I32#_closure" {
     GHC.Int.$tc'I32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I32#2_closure+1;
         const GHC.Int.$tc'I32#1_closure+4;
         const 14037617528454219662;
         const 2752255350980319305;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.553771491 UTC

[section ""data" . GHC.Int.$tcInt5_closure" {
     GHC.Int.$tcInt5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.556309138 UTC

[section ""data" . GHC.Int.$tcInt64_closure" {
     GHC.Int.$tcInt64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt5_closure+1;
         const GHC.Types.krep$*_closure;
         const 15049343324344240059;
         const 14445320765379163718;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.559089947 UTC

[section ""data" . $krep4_r4kPF_closure" {
     $krep4_r4kPF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.563240858 UTC

[section ""data" . GHC.Int.$tc'I64#1_closure" {
     GHC.Int.$tc'I64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep4_r4kPF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.565718057 UTC

[section ""cstring" . GHC.Int.$tc'I64#3_bytes" {
     GHC.Int.$tc'I64#3_bytes:
         I8[] [39,73,54,52,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.567425777 UTC

[section ""data" . GHC.Int.$tc'I64#2_closure" {
     GHC.Int.$tc'I64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I64#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.569228922 UTC

[section ""data" . GHC.Int.$tc'I64#_closure" {
     GHC.Int.$tc'I64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I64#2_closure+1;
         const GHC.Int.$tc'I64#1_closure+4;
         const 7755385358338959724;
         const 8520529638322167079;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.571987523 UTC

[section ""data" . GHC.Int.I8#_closure" {
     GHC.Int.I8#_closure:
         const GHC.Int.I8#_info;
 },
 GHC.Int.I8#_entry() //  [R2]
         { info_tbl: [(c4vtM,
                       label: GHC.Int.I8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vtM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vtQ; else goto c4vtP;
       c4vtQ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vtP: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.576122581 UTC

[section ""data" . GHC.Int.I16#_closure" {
     GHC.Int.I16#_closure:
         const GHC.Int.I16#_info;
 },
 GHC.Int.I16#_entry() //  [R2]
         { info_tbl: [(c4vu1,
                       label: GHC.Int.I16#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vu1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vu5; else goto c4vu4;
       c4vu5: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vu4: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.580301767 UTC

[section ""data" . GHC.Int.I32#_closure" {
     GHC.Int.I32#_closure:
         const GHC.Int.I32#_info;
 },
 GHC.Int.I32#_entry() //  [R2]
         { info_tbl: [(c4vug,
                       label: GHC.Int.I32#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vug: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vuk; else goto c4vuj;
       c4vuk: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vuj: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.584786608 UTC

[section ""data" . GHC.Int.I64#_closure" {
     GHC.Int.I64#_closure:
         const GHC.Int.I64#_info;
 },
 GHC.Int.I64#_entry() //  [R2]
         { info_tbl: [(c4vuv,
                       label: GHC.Int.I64#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vuv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vuz; else goto c4vuy;
       c4vuz: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vuy: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.589205333 UTC

[GHC.Int.I8#_con_entry() //  [R1]
         { info_tbl: [(c4vuF,
                       label: GHC.Int.I8#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,56,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vuF: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.592994093 UTC

[GHC.Int.I16#_con_entry() //  [R1]
         { info_tbl: [(c4vuL,
                       label: GHC.Int.I16#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,49,54,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vuL: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.596408282 UTC

[GHC.Int.I32#_con_entry() //  [R1]
         { info_tbl: [(c4vuR,
                       label: GHC.Int.I32#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,51,50,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vuR: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.599846408 UTC

[GHC.Int.I64#_con_entry() //  [R1]
         { info_tbl: [(c4vuX,
                       label: GHC.Int.I64#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,54,52,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4vuX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:13.603243775 UTC

[section ""relreadonly" . S4lDl_srt" {
     S4lDl_srt:
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt8_$cpred_closure;
         const GHC.Int.$fEnumInt7_closure;
         const GHC.Int.$fEnumInt8_$csucc_closure;
         const GHC.Int.$fEnumInt9_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl_r4kPr_closure;
         const GHC.Int.$wlvl2_closure;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum2_closure;
         const GHC.Int.$w$cenumFromThenTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Int.$wgo3_closure;
         const GHC.Int.$fEnumInt8_go_closure;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure;
         const GHC.Int.$fEnumInt8_closure;
         const GHC.Int.$fEnumInt16_$cpred_closure;
         const GHC.Int.$fEnumInt1_closure;
         const GHC.Int.$fEnumInt16_$csucc_closure;
         const GHC.Int.$fEnumInt2_closure;
         const lvl2_r4kPt_closure;
         const GHC.Int.$wlvl_closure;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum_closure;
         const GHC.Int.$w$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$wgo_closure;
         const GHC.Int.$fEnumInt16_go_closure;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure;
         const GHC.Int.$fEnumInt16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt32_$cpred_closure;
         const GHC.Int.$fEnumInt3_closure;
         const GHC.Int.$fEnumInt32_$csucc_closure;
         const GHC.Int.$fEnumInt4_closure;
         const lvl4_r4kPv_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Int.$wlvl1_closure;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum1_closure;
         const GHC.Int.$w$cenumFromTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$wgo1_closure;
         const GHC.Int.$fEnumInt32_go_closure;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure;
         const GHC.Int.$w$cenumFromThenTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt32_closure;
         const GHC.Int.$fEnumInt64_$cpred_closure;
         const GHC.Int.$fEnumInt5_closure;
         const GHC.Int.$fEnumInt64_$csucc_closure;
         const GHC.Int.$fEnumInt6_closure;
         const GHC.Int.$fEnumInt64_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Int.$fReadInt8_$creadsPrec_closure;
         const GHC.Int.$fReadInt13_closure;
         const GHC.Read.list_closure;
         const GHC.Int.$fReadInt12_closure;
         const GHC.Int.$fReadInt11_closure;
         const GHC.Int.$fReadInt8_$creadList_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fIntegralInt8_$cquot_closure;
         const GHC.Int.$fIntegralInt8_$crem_closure;
         const GHC.Int.$w$cdiv3_closure;
         const GHC.Int.$fIntegralInt8_$cdiv_closure;
         const GHC.Int.$fIntegralInt8_$cmod_closure;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure;
         const lvl6_r4kPx_closure;
         const GHC.Int.$w$cdivMod3_closure;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure;
         const sat_s4ldV_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Int.$fRealInt8_$ctoRational_closure;
         const GHC.Int.$fIxInt8_$crange_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fIxInt8_$cindex_closure;
         const GHC.Int.$fReadInt16_$creadsPrec_closure;
         const GHC.Int.$fReadInt3_closure;
         const GHC.Int.$fReadInt2_closure;
         const GHC.Int.$fReadInt1_closure;
         const GHC.Int.$fReadInt16_$creadList_closure;
         const GHC.Int.$fIntegralInt16_$cquot_closure;
         const GHC.Int.$fIntegralInt16_$crem_closure;
         const GHC.Int.$w$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cmod_closure;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure;
         const lvl7_r4kPy_closure;
         const GHC.Int.$w$cdivMod_closure;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure;
         const GHC.Int.$fRealInt16_$ctoRational_closure;
         const GHC.Int.$fIxInt16_$crange_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$fIxInt16_$cindex_closure;
         const GHC.Int.$fReadInt32_$creadsPrec_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Int.$fReadInt6_closure;
         const GHC.Int.$fReadInt5_closure;
         const GHC.Int.$fReadInt4_closure;
         const GHC.Int.$fReadInt32_$creadList_closure;
         const GHC.Int.$fIntegralInt32_$cquot_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Int.$fIntegralInt32_$crem_closure;
         const GHC.Int.$w$cdiv1_closure;
         const GHC.Int.$fIntegralInt32_$cdiv_closure;
         const GHC.Int.$fIntegralInt32_$cmod_closure;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure;
         const lvl8_r4kPz_closure;
         const GHC.Int.$w$cdivMod1_closure;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure;
         const GHC.Int.$fRealInt32_$ctoRational_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Int.$fIxInt32_$crange_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$fIxInt32_$cindex_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fReadInt64_$creadsPrec_closure;
         const GHC.Int.$fReadInt10_closure;
         const GHC.Int.$fReadInt9_closure;
         const GHC.Int.$fReadInt7_closure;
         const GHC.Int.$fReadInt64_$creadList_closure;
         const GHC.Int.$fIntegralInt64_$cquot_closure;
         const GHC.Int.$fIntegralInt64_$crem_closure;
         const GHC.Int.$fIntegralInt64_$cdiv_closure;
         const GHC.Int.$w$cdiv2_closure;
         const GHC.Int.$fIntegralInt64_$cmod_closure;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure;
         const lvl9_r4kPA_closure;
         const GHC.Int.$w$cdivMod2_closure;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure;
         const GHC.Int.$fRealInt64_$ctoRational_closure;
         const GHC.Int.$fIxInt64_$cindex_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:23.9303864 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:23.931838443 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cfromEnum_closure" {
     GHC.Int.$fEnumInt8_$cfromEnum_closure:
         const GHC.Int.$fEnumInt8_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt8_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4wdw,
                       label: GHC.Int.$fEnumInt8_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wdw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wdA; else goto c4wdB;
       c4wdA: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wdB: // global
           I64[Sp - 8] = block_c4wdt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wdF; else goto c4wdu;
       u4wdF: // global
           call _c4wdt(R1) args: 0, res: 0, upd: 0;
       c4wdu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wdt() //  [R1]
         { info_tbl: [(c4wdt,
                       label: block_c4wdt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wdt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wdE; else goto c4wdD;
       c4wdE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wdD: // global
           _s4vv6::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vv6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:23.938283814 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cfromEnum_closure" {
     GHC.Int.$fEnumInt16_$cfromEnum_closure:
         const GHC.Int.$fEnumInt16_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt16_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4wdZ,
                       label: GHC.Int.$fEnumInt16_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wdZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4we3; else goto c4we4;
       c4we3: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4we4: // global
           I64[Sp - 8] = block_c4wdW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4we8; else goto c4wdX;
       u4we8: // global
           call _c4wdW(R1) args: 0, res: 0, upd: 0;
       c4wdX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wdW() //  [R1]
         { info_tbl: [(c4wdW,
                       label: block_c4wdW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wdW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4we7; else goto c4we6;
       c4we7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4we6: // global
           _s4vv9::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vv9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:23.944809811 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cfromEnum_closure" {
     GHC.Int.$fEnumInt32_$cfromEnum_closure:
         const GHC.Int.$fEnumInt32_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt32_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4wes,
                       label: GHC.Int.$fEnumInt32_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wes: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wew; else goto c4wex;
       c4wew: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wex: // global
           I64[Sp - 8] = block_c4wep_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4weB; else goto c4weq;
       u4weB: // global
           call _c4wep(R1) args: 0, res: 0, upd: 0;
       c4weq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wep() //  [R1]
         { info_tbl: [(c4wep,
                       label: block_c4wep_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wep: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4weA; else goto c4wez;
       c4weA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wez: // global
           _s4vvc::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vvc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:23.953923363 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cfromEnum_closure" {
     GHC.Int.$fEnumInt64_$cfromEnum_closure:
         const GHC.Int.$fEnumInt64_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt64_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4weV,
                       label: GHC.Int.$fEnumInt64_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4weV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4weZ; else goto c4wf0;
       c4weZ: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wf0: // global
           I64[Sp - 8] = block_c4weS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wf4; else goto c4weT;
       u4wf4: // global
           call _c4weS(R1) args: 0, res: 0, upd: 0;
       c4weT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4weS() //  [R1]
         { info_tbl: [(c4weS,
                       label: block_c4weS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4weS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wf3; else goto c4wf2;
       c4wf3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wf2: // global
           _s4vvf::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vvf::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:23.96018299 UTC

[section ""data" . GHC.Int.$fEnumInt64_$ctoEnum_closure" {
     GHC.Int.$fEnumInt64_$ctoEnum_closure:
         const GHC.Int.$fEnumInt64_$ctoEnum_info;
 },
 GHC.Int.$fEnumInt64_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4wfo,
                       label: GHC.Int.$fEnumInt64_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wfo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wfs; else goto c4wft;
       c4wfs: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wft: // global
           I64[Sp - 8] = block_c4wfl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wfx; else goto c4wfm;
       u4wfx: // global
           call _c4wfl(R1) args: 0, res: 0, upd: 0;
       c4wfm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wfl() //  [R1]
         { info_tbl: [(c4wfl,
                       label: block_c4wfl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wfl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wfw; else goto c4wfv;
       c4wfw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wfv: // global
           _s4vvi::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vvi::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:23.968155014 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo2_closure" {
     GHC.Int.$w$cenumFromThenTo2_closure:
         const GHC.Int.$w$cenumFromThenTo2_info;
 },
 sat_s4vvw_entry() //  [R1]
         { info_tbl: [(c4wgi,
                       label: sat_s4vvw_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wgi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wgj; else goto c4wgk;
       c4wgj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wgk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4vvr_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4vvr_entry() //  [R1, R2]
         { info_tbl: [(c4wgo,
                       label: go_dn_s4vvr_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wgo: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4wgs; else goto c4wgr;
       c4wgs: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wgr: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4wgm; else goto c4wgn;
       c4wgm: // global
           _s4vvp::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4vvw_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4vvp::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wgn: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wgx::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wgx::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4vvy_entry() //  [R1]
         { info_tbl: [(c4wgy,
                       label: sat_s4vvy_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wgy: // global
           _s4vvy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wgz; else goto c4wgA;
       c4wgA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wgC; else goto c4wgB;
       c4wgC: // global
           HpAlloc = 24;
           goto c4wgz;
       c4wgz: // global
           R1 = _s4vvy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wgB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vvy::P64;
           _s4vvk::I64 = I64[_s4vvy::P64 + 24];
           _s4vvp::I64 = _s4vvk::I64 - I64[_s4vvy::P64 + 16];
           _s4vvq::I64 = I64[_s4vvy::P64 + 32] - _s4vvp::I64;
           I64[Hp - 16] = go_dn_s4vvr_info;
           I64[Hp - 8] = _s4vvp::I64;
           I64[Hp] = _s4vvq::I64;
           R2 = _s4vvk::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4vvr_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vvK_entry() //  [R1]
         { info_tbl: [(c4wh5,
                       label: sat_s4vvK_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wh5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wh6; else goto c4wh7;
       c4wh6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wh7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4vvF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4vvF_entry() //  [R1, R2]
         { info_tbl: [(c4whb,
                       label: go_up_s4vvF_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4whb: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4whf; else goto c4whe;
       c4whf: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4whe: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4wh9; else goto c4wha;
       c4wh9: // global
           _s4vvD::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4vvK_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4vvD::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wha: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4whk::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4whk::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4vvM_entry() //  [R1]
         { info_tbl: [(c4whl,
                       label: sat_s4vvM_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4whl: // global
           _s4vvM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4whm; else goto c4whn;
       c4whn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4whp; else goto c4who;
       c4whp: // global
           HpAlloc = 24;
           goto c4whm;
       c4whm: // global
           R1 = _s4vvM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4who: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vvM::P64;
           _s4vvk::I64 = I64[_s4vvM::P64 + 24];
           _s4vvD::I64 = _s4vvk::I64 - I64[_s4vvM::P64 + 16];
           _s4vvE::I64 = I64[_s4vvM::P64 + 32] - _s4vvD::I64;
           I64[Hp - 16] = go_up_s4vvF_info;
           I64[Hp - 8] = _s4vvD::I64;
           I64[Hp] = _s4vvE::I64;
           R2 = _s4vvk::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4vvF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { info_tbl: [(c4wht,
                       label: GHC.Int.$w$cenumFromThenTo2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wht: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4whx; else goto c4whw;
       c4whx: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4whw: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4whr; else goto c4whs;
       c4whr: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4whB; else goto c4whL;
       c4whB: // global
           I64[Hp - 72] = sat_s4vvy_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4whL: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4whY; else goto c4whJ;
       c4whJ: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4whH::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4whH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4whs: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4whP; else goto c4whZ;
       c4whP: // global
           I64[Hp - 72] = sat_s4vvM_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4whZ: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4whY; else goto c4whX;
       c4whY: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4whX: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4whV::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4whV::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:23.990411932 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4wjz,
                       label: GHC.Int.$fEnumInt64_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wjz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wjI; else goto c4wjJ;
       c4wjI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wjJ: // global
           I64[Sp - 24] = block_c4wjw_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4wjS; else goto c4wjx;
       u4wjS: // global
           call _c4wjw(R1) args: 0, res: 0, upd: 0;
       c4wjx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wjw() //  [R1]
         { info_tbl: [(c4wjw,
                       label: block_c4wjw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wjw: // global
           I64[Sp] = block_c4wjC_info;
           _s4vvT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vvT::I64;
           if (R1 & 7 != 0) goto u4wjR; else goto c4wjD;
       u4wjR: // global
           call _c4wjC(R1) args: 0, res: 0, upd: 0;
       c4wjD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wjC() //  [R1]
         { info_tbl: [(c4wjC,
                       label: block_c4wjC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wjC: // global
           I64[Sp] = block_c4wjH_info;
           _s4vvV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vvV::I64;
           if (R1 & 7 != 0) goto u4wjT; else goto c4wjM;
       u4wjT: // global
           call _c4wjH(R1) args: 0, res: 0, upd: 0;
       c4wjM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wjH() //  [R1]
         { info_tbl: [(c4wjH,
                       label: block_c4wjH_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wjH: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo2_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.0006597 UTC

[section ""data" . GHC.Int.$w$cenumFromTo2_closure" {
     GHC.Int.$w$cenumFromTo2_closure:
         const GHC.Int.$w$cenumFromTo2_info;
 },
 sat_s4vw6_entry() //  [R1]
         { info_tbl: [(c4wkz,
                       label: sat_s4vw6_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wkz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wkA; else goto c4wkB;
       c4wkA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wkB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vw2::I64 = I64[R1 + 32];
           if (_s4vw2::I64 == I64[R1 + 24]) goto c4wky; else goto c4wkx;
       c4wky: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4wkx: // global
           R2 = _s4vw2::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4vw1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4vw1_entry() //  [R1, R2]
         { info_tbl: [(c4wkG,
                       label: go_s4vw1_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wkG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4wkK; else goto c4wkJ;
       c4wkK: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wkJ: // global
           _s4vvZ::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4vw6_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4vvZ::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo2_entry() //  [R2, R3]
         { info_tbl: [(c4wkO,
                       label: GHC.Int.$w$cenumFromTo2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wkO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wkS; else goto c4wkR;
       c4wkS: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wkR: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4wkM; else goto c4wkN;
       c4wkM: // global
           I64[Hp - 8] = go_s4vw1_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4vw1_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4wkN: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.009366631 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4wln,
                       label: GHC.Int.$fEnumInt64_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wln: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wlr; else goto c4wls;
       c4wlr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wls: // global
           I64[Sp - 16] = block_c4wlk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wlA; else goto c4wll;
       u4wlA: // global
           call _c4wlk(R1) args: 0, res: 0, upd: 0;
       c4wll: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wlk() //  [R1]
         { info_tbl: [(c4wlk,
                       label: block_c4wlk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wlk: // global
           I64[Sp] = block_c4wlq_info;
           _s4vwa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vwa::I64;
           if (R1 & 7 != 0) goto u4wlz; else goto c4wlu;
       u4wlz: // global
           call _c4wlq(R1) args: 0, res: 0, upd: 0;
       c4wlu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wlq() //  [R1]
         { info_tbl: [(c4wlq,
                       label: block_c4wlq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wlq: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.016856476 UTC

[section ""cstring" . GHC.Int.$tcInt9_bytes" {
     GHC.Int.$tcInt9_bytes:
         I8[] [73,110,116,56]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.019227524 UTC

[section ""data" . GHC.Int.$fEnumInt7_closure" {
     GHC.Int.$fEnumInt7_closure:
         const GHC.Int.$fEnumInt7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt7_entry() //  [R1]
         { info_tbl: [(c4wlZ,
                       label: GHC.Int.$fEnumInt7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wlZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wm0; else goto c4wm1;
       c4wm0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wm1: // global
           (_c4wlU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wlU::I64 == 0) goto c4wlW; else goto c4wlV;
       c4wlW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wlV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wlU::I64;
           I64[Sp - 24] = block_c4wlX_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4wlX() //  [R1]
         { info_tbl: [(c4wlX,
                       label: block_c4wlX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wlX: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.02505006 UTC

[section ""data" . GHC.Int.$fEnumInt9_closure" {
     GHC.Int.$fEnumInt9_closure:
         const GHC.Int.$fEnumInt9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt9_entry() //  [R1]
         { info_tbl: [(c4wmq,
                       label: GHC.Int.$fEnumInt9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wmq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wmr; else goto c4wms;
       c4wmr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wms: // global
           (_c4wml::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wml::I64 == 0) goto c4wmn; else goto c4wmm;
       c4wmn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wmm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wml::I64;
           I64[Sp - 24] = block_c4wmo_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4wmo() //  [R1]
         { info_tbl: [(c4wmo,
                       label: block_c4wmo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wmo: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.031197017 UTC

[section ""data" . GHC.Int.neInt8_closure" {
     GHC.Int.neInt8_closure:
         const GHC.Int.neInt8_info;
 },
 GHC.Int.neInt8_entry() //  [R2, R3]
         { info_tbl: [(c4wmP,
                       label: GHC.Int.neInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wmP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wmT; else goto c4wmU;
       c4wmT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wmU: // global
           I64[Sp - 16] = block_c4wmM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wn3; else goto c4wmN;
       u4wn3: // global
           call _c4wmM(R1) args: 0, res: 0, upd: 0;
       c4wmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wmM() //  [R1]
         { info_tbl: [(c4wmM,
                       label: block_c4wmM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wmM: // global
           I64[Sp] = block_c4wmS_info;
           _s4vwi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vwi::I64;
           if (R1 & 7 != 0) goto u4wn2; else goto c4wmW;
       u4wn2: // global
           call _c4wmS(R1) args: 0, res: 0, upd: 0;
       c4wmW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wmS() //  [R1]
         { info_tbl: [(c4wmS,
                       label: block_c4wmS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wmS: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.039416221 UTC

[section ""data" . lvl_r4kPr_closure" {
     lvl_r4kPr_closure:
         const lvl_r4kPr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r4kPr_entry() //  [R1]
         { info_tbl: [(c4wnu,
                       label: lvl_r4kPr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wnu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wnv; else goto c4wnw;
       c4wnv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wnw: // global
           (_c4wnr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wnr::I64 == 0) goto c4wnt; else goto c4wns;
       c4wnt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wns: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wnr::I64;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.043391057 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cminBound_closure" {
     GHC.Int.$fBoundedInt8_$cminBound_closure:
         const GHC.Int.I8#_con_info;
         const (-128);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.045655582 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cpred_closure" {
     GHC.Int.$fEnumInt8_$cpred_closure:
         const GHC.Int.$fEnumInt8_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cpred_entry() //  [R2]
         { info_tbl: [(c4wnN,
                       label: GHC.Int.$fEnumInt8_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wnN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wnO; else goto c4wnP;
       c4wnO: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wnP: // global
           I64[Sp - 8] = block_c4wnK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wo7; else goto c4wnL;
       u4wo7: // global
           call _c4wnK(R1) args: 0, res: 0, upd: 0;
       c4wnL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wnK() //  [R1]
         { info_tbl: [(c4wnK,
                       label: block_c4wnK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wnK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wnU; else goto c4wnT;
       c4wnU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wnT: // global
           _s4vwp::I64 = I64[R1 + 7];
           if (_s4vwp::I64 != (-128)) goto c4wo5; else goto c4wo6;
       c4wo5: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vwp::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wo6: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.05237138 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt8_$cmaxBound_closure:
         const GHC.Int.I8#_con_info;
         const 127;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.054223161 UTC

[section ""data" . GHC.Int.$fBoundedInt8_closure" {
     GHC.Int.$fBoundedInt8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt8_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.05659463 UTC

[section ""data" . GHC.Int.$fEnumInt8_$csucc_closure" {
     GHC.Int.$fEnumInt8_$csucc_closure:
         const GHC.Int.$fEnumInt8_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$csucc_entry() //  [R2]
         { info_tbl: [(c4wow,
                       label: GHC.Int.$fEnumInt8_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wow: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wox; else goto c4woy;
       c4wox: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4woy: // global
           I64[Sp - 8] = block_c4wot_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4woQ; else goto c4wou;
       u4woQ: // global
           call _c4wot(R1) args: 0, res: 0, upd: 0;
       c4wou: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wot() //  [R1]
         { info_tbl: [(c4wot,
                       label: block_c4wot_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wot: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4woD; else goto c4woC;
       c4woD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4woC: // global
           _s4vwv::I64 = I64[R1 + 7];
           if (_s4vwv::I64 != 127) goto c4woO; else goto c4woP;
       c4woO: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vwv::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4woP: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.063801406 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowsPrec_closure" {
     GHC.Int.$fShowInt8_$cshowsPrec_closure:
         const GHC.Int.$fShowInt8_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt8_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4wpd,
                       label: GHC.Int.$fShowInt8_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wpd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wpo; else goto c4wpp;
       c4wpo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wpp: // global
           I64[Sp - 24] = block_c4wpa_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4wpw; else goto c4wpb;
       u4wpw: // global
           call _c4wpa(R1) args: 0, res: 0, upd: 0;
       c4wpb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wpa() //  [R1]
         { info_tbl: [(c4wpa,
                       label: block_c4wpa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wpa: // global
           I64[Sp] = block_c4wpg_info;
           _s4vwC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vwC::I64;
           if (R1 & 7 != 0) goto u4wpv; else goto c4wph;
       u4wpv: // global
           call _c4wpg(R1) args: 0, res: 0, upd: 0;
       c4wph: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wpg() //  [R1]
         { info_tbl: [(c4wpg,
                       label: block_c4wpg_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wpg: // global
           _s4vwA::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4wpl_info;
           R4 = _s4vwA::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4wpl() //  [R1, R2]
         { info_tbl: [(c4wpl,
                       label: block_c4wpl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wpl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wpu; else goto c4wpt;
       c4wpu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wpt: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.07447246 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshow_closure" {
     GHC.Int.$fShowInt8_$cshow_closure:
         const GHC.Int.$fShowInt8_$cshow_info;
 },
 GHC.Int.$fShowInt8_$cshow_entry() //  [R2]
         { info_tbl: [(c4wpZ,
                       label: GHC.Int.$fShowInt8_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wpZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wq5; else goto c4wq6;
       c4wq5: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wq6: // global
           I64[Sp - 8] = block_c4wpW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wqb; else goto c4wpX;
       u4wqb: // global
           call _c4wpW(R1) args: 0, res: 0, upd: 0;
       c4wpX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wpW() //  [R1]
         { info_tbl: [(c4wpW,
                       label: block_c4wpW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wpW: // global
           I64[Sp] = block_c4wq2_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4wq2() //  [R1, R2]
         { info_tbl: [(c4wq2,
                       label: block_c4wq2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wq2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wqa; else goto c4wq9;
       c4wqa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wq9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.083074853 UTC

[section ""data" . GHC.Int.$fShowInt4_closure" {
     GHC.Int.$fShowInt4_closure:
         const GHC.Int.$fShowInt4_info;
 },
 GHC.Int.$fShowInt4_entry() //  [R2, R3]
         { info_tbl: [(c4wqA,
                       label: GHC.Int.$fShowInt4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wqA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wqG; else goto c4wqH;
       c4wqG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wqH: // global
           I64[Sp - 16] = block_c4wqx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wqM; else goto c4wqy;
       u4wqM: // global
           call _c4wqx(R1) args: 0, res: 0, upd: 0;
       c4wqy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wqx() //  [R1]
         { info_tbl: [(c4wqx,
                       label: block_c4wqx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wqx: // global
           _s4vwP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4wqD_info;
           R4 = _s4vwP::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4wqD() //  [R1, R2]
         { info_tbl: [(c4wqD,
                       label: block_c4wqD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wqD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wqL; else goto c4wqK;
       c4wqL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wqK: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.090955774 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowList_closure" {
     GHC.Int.$fShowInt8_$cshowList_closure:
         const GHC.Int.$fShowInt8_$cshowList_info;
 },
 GHC.Int.$fShowInt8_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4wr7,
                       label: GHC.Int.$fShowInt8_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wr7: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.094485582 UTC

[section ""data" . GHC.Int.$fShowInt8_closure" {
     GHC.Int.$fShowInt8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt8_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt8_$cshow_closure+1;
         const GHC.Int.$fShowInt8_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.096510802 UTC

[section ""data" . GHC.Int.$wlvl2_closure" {
     GHC.Int.$wlvl2_closure:
         const GHC.Int.$wlvl2_info;
         const 0;
 },
 GHC.Int.$wlvl2_entry() //  [R2]
         { info_tbl: [(c4wrj,
                       label: GHC.Int.$wlvl2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wrj: // global
           R6 = GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl_r4kPr_closure;
           R2 = GHC.Int.$fShowInt8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.101066306 UTC

[section ""data" . GHC.Int.$w$ctoEnum2_closure" {
     GHC.Int.$w$ctoEnum2_closure:
         const GHC.Int.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum2_entry() //  [R2]
         { info_tbl: [(c4wrz,
                       label: GHC.Int.$w$ctoEnum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wrz: // global
           _s4vwY::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-128))) goto c4wrH; else goto c4wry;
       c4wry: // global
           if (%MO_S_Gt_W64(_s4vwY::I64, 127)) goto c4wrH; else goto c4wrI;
       c4wrH: // global
           R2 = _s4vwY::I64;
           call GHC.Int.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c4wrI: // global
           R1 = _s4vwY::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.105644279 UTC

[section ""data" . GHC.Int.$fEnumInt8_$ctoEnum_closure" {
     GHC.Int.$fEnumInt8_$ctoEnum_closure:
         const GHC.Int.$fEnumInt8_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4wrV,
                       label: GHC.Int.$fEnumInt8_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wrV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ws3; else goto c4ws4;
       c4ws3: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ws4: // global
           I64[Sp - 8] = block_c4wrS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ws9; else goto c4wrT;
       u4ws9: // global
           call _c4wrS(R1) args: 0, res: 0, upd: 0;
       c4wrT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wrS() //  [R1]
         { info_tbl: [(c4wrS,
                       label: block_c4wrS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wrS: // global
           I64[Sp] = block_c4wrY_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4wrY() //  [R1]
         { info_tbl: [(c4wrY,
                       label: block_c4wrY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wrY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ws8; else goto c4ws7;
       c4ws8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ws7: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.116944529 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo3_closure" {
     GHC.Int.$w$cenumFromThenTo3_closure:
         const GHC.Int.$w$cenumFromThenTo3_info;
         const 0;
 },
 sat_s4vxo_entry() //  [R1]
         { info_tbl: [(c4wsY,
                       label: sat_s4vxo_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wsY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wsZ; else goto c4wt0;
       c4wsZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wt0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4vxh_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vxm_entry() //  [R1]
         { info_tbl: [(c4wta,
                       label: sat_s4vxm_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wta: // global
           _s4vxm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wtb; else goto c4wtc;
       c4wtc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wte; else goto c4wtd;
       c4wte: // global
           HpAlloc = 16;
           goto c4wtb;
       c4wtb: // global
           R1 = _s4vxm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wtd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxm::P64;
           _s4vxi::I64 = I64[_s4vxm::P64 + 16];
           if (%MO_S_Lt_W64(_s4vxi::I64, (-128))) goto c4wtk; else goto c4wt9;
       c4wt9: // global
           if (%MO_S_Gt_W64(_s4vxi::I64, 127)) goto c4wtk; else goto c4wto;
       c4wtk: // global
           Hp = Hp - 16;
           R2 = _s4vxi::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wto: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vxi::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vxr_entry() //  [R1]
         { info_tbl: [(c4wtz,
                       label: sat_s4vxr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wtz: // global
           _s4vxr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wtA; else goto c4wtB;
       c4wtB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wtD; else goto c4wtC;
       c4wtD: // global
           HpAlloc = 16;
           goto c4wtA;
       c4wtA: // global
           R1 = _s4vxr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wtC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxr::P64;
           _s4vxi::I64 = I64[_s4vxr::P64 + 16];
           if (%MO_S_Lt_W64(_s4vxi::I64, (-128))) goto c4wtJ; else goto c4wty;
       c4wty: // global
           if (%MO_S_Gt_W64(_s4vxi::I64, 127)) goto c4wtJ; else goto c4wtN;
       c4wtJ: // global
           Hp = Hp - 16;
           R2 = _s4vxi::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wtN: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vxi::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4vxh_entry() //  [R1, R2]
         { info_tbl: [(c4wtR,
                       label: go_dn_s4vxh_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wtR: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wtV; else goto c4wtU;
       c4wtV: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wtU: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4wtP; else goto c4wtQ;
       c4wtP: // global
           _s4vxf::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vxo_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vxf::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vxm_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wtQ: // global
           I64[Hp - 80] = sat_s4vxr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wtX::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wtX::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4vxs_entry() //  [R1]
         { info_tbl: [(c4wtY,
                       label: sat_s4vxs_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wtY: // global
           _s4vxs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wtZ; else goto c4wu0;
       c4wu0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wu2; else goto c4wu1;
       c4wu2: // global
           HpAlloc = 24;
           goto c4wtZ;
       c4wtZ: // global
           R1 = _s4vxs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wu1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxs::P64;
           _s4vx8::I64 = I64[_s4vxs::P64 + 24];
           _s4vxf::I64 = _s4vx8::I64 - I64[_s4vxs::P64 + 16];
           _s4vxg::I64 = I64[_s4vxs::P64 + 32] - _s4vxf::I64;
           I64[Hp - 16] = go_dn_s4vxh_info;
           I64[Hp - 8] = _s4vxf::I64;
           I64[Hp] = _s4vxg::I64;
           R2 = _s4vx8::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4vxh_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vxe_entry() //  [R1]
         { info_tbl: [(c4wuc,
                       label: sat_s4vxe_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wuc: // global
           _s4vxe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wud; else goto c4wue;
       c4wue: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wug; else goto c4wuf;
       c4wug: // global
           HpAlloc = 16;
           goto c4wud;
       c4wud: // global
           R1 = _s4vxe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wuf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxe::P64;
           _s4vx7::I64 = I64[_s4vxe::P64 + 16];
           if (%MO_S_Lt_W64(_s4vx7::I64, (-128))) goto c4wum; else goto c4wub;
       c4wub: // global
           if (%MO_S_Gt_W64(_s4vx7::I64, 127)) goto c4wum; else goto c4wuq;
       c4wum: // global
           Hp = Hp - 16;
           R2 = _s4vx7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wuq: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vx7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vxw_entry() //  [R1]
         { info_tbl: [(c4wuE,
                       label: sat_s4vxw_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wuE: // global
           _s4vxw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wuF; else goto c4wuG;
       c4wuG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wuI; else goto c4wuH;
       c4wuI: // global
           HpAlloc = 16;
           goto c4wuF;
       c4wuF: // global
           R1 = _s4vxw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wuH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxw::P64;
           _s4vx7::I64 = I64[_s4vxw::P64 + 16];
           if (%MO_S_Lt_W64(_s4vx7::I64, (-128))) goto c4wuO; else goto c4wuD;
       c4wuD: // global
           if (%MO_S_Gt_W64(_s4vx7::I64, 127)) goto c4wuO; else goto c4wuS;
       c4wuO: // global
           Hp = Hp - 16;
           R2 = _s4vx7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wuS: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vx7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vxK_entry() //  [R1]
         { info_tbl: [(c4wvl,
                       label: sat_s4vxK_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wvl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wvm; else goto c4wvn;
       c4wvm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wvn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4vxD_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vxI_entry() //  [R1]
         { info_tbl: [(c4wvx,
                       label: sat_s4vxI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wvx: // global
           _s4vxI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wvy; else goto c4wvz;
       c4wvz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wvB; else goto c4wvA;
       c4wvB: // global
           HpAlloc = 16;
           goto c4wvy;
       c4wvy: // global
           R1 = _s4vxI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wvA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxI::P64;
           _s4vxE::I64 = I64[_s4vxI::P64 + 16];
           if (%MO_S_Lt_W64(_s4vxE::I64, (-128))) goto c4wvH; else goto c4wvw;
       c4wvw: // global
           if (%MO_S_Gt_W64(_s4vxE::I64, 127)) goto c4wvH; else goto c4wvL;
       c4wvH: // global
           Hp = Hp - 16;
           R2 = _s4vxE::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wvL: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vxE::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vxN_entry() //  [R1]
         { info_tbl: [(c4wvW,
                       label: sat_s4vxN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wvW: // global
           _s4vxN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wvX; else goto c4wvY;
       c4wvY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ww0; else goto c4wvZ;
       c4ww0: // global
           HpAlloc = 16;
           goto c4wvX;
       c4wvX: // global
           R1 = _s4vxN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wvZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxN::P64;
           _s4vxE::I64 = I64[_s4vxN::P64 + 16];
           if (%MO_S_Lt_W64(_s4vxE::I64, (-128))) goto c4ww6; else goto c4wvV;
       c4wvV: // global
           if (%MO_S_Gt_W64(_s4vxE::I64, 127)) goto c4ww6; else goto c4wwa;
       c4ww6: // global
           Hp = Hp - 16;
           R2 = _s4vxE::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wwa: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vxE::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4vxD_entry() //  [R1, R2]
         { info_tbl: [(c4wwe,
                       label: go_up_s4vxD_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wwe: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wwi; else goto c4wwh;
       c4wwi: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wwh: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4wwc; else goto c4wwd;
       c4wwc: // global
           _s4vxB::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vxK_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vxB::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vxI_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wwd: // global
           I64[Hp - 80] = sat_s4vxN_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wwk::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wwk::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4vxO_entry() //  [R1]
         { info_tbl: [(c4wwl,
                       label: sat_s4vxO_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wwl: // global
           _s4vxO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wwm; else goto c4wwn;
       c4wwn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wwp; else goto c4wwo;
       c4wwp: // global
           HpAlloc = 24;
           goto c4wwm;
       c4wwm: // global
           R1 = _s4vxO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wwo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxO::P64;
           _s4vx8::I64 = I64[_s4vxO::P64 + 24];
           _s4vxB::I64 = _s4vx8::I64 - I64[_s4vxO::P64 + 16];
           _s4vxC::I64 = I64[_s4vxO::P64 + 32] - _s4vxB::I64;
           I64[Hp - 16] = go_up_s4vxD_info;
           I64[Hp - 8] = _s4vxB::I64;
           I64[Hp] = _s4vxC::I64;
           R2 = _s4vx8::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4vxD_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vxA_entry() //  [R1]
         { info_tbl: [(c4wwz,
                       label: sat_s4vxA_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wwz: // global
           _s4vxA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wwA; else goto c4wwB;
       c4wwB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wwD; else goto c4wwC;
       c4wwD: // global
           HpAlloc = 16;
           goto c4wwA;
       c4wwA: // global
           R1 = _s4vxA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wwC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxA::P64;
           _s4vx7::I64 = I64[_s4vxA::P64 + 16];
           if (%MO_S_Lt_W64(_s4vx7::I64, (-128))) goto c4wwJ; else goto c4wwy;
       c4wwy: // global
           if (%MO_S_Gt_W64(_s4vx7::I64, 127)) goto c4wwJ; else goto c4wwN;
       c4wwJ: // global
           Hp = Hp - 16;
           R2 = _s4vx7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wwN: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vx7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vxS_entry() //  [R1]
         { info_tbl: [(c4wx1,
                       label: sat_s4vxS_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wx1: // global
           _s4vxS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wx2; else goto c4wx3;
       c4wx3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wx5; else goto c4wx4;
       c4wx5: // global
           HpAlloc = 16;
           goto c4wx2;
       c4wx2: // global
           R1 = _s4vxS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wx4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxS::P64;
           _s4vx7::I64 = I64[_s4vxS::P64 + 16];
           if (%MO_S_Lt_W64(_s4vx7::I64, (-128))) goto c4wxb; else goto c4wx0;
       c4wx0: // global
           if (%MO_S_Gt_W64(_s4vx7::I64, 127)) goto c4wxb; else goto c4wxf;
       c4wxb: // global
           Hp = Hp - 16;
           R2 = _s4vx7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wxf: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vx7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4wxj,
                       label: GHC.Int.$w$cenumFromThenTo3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wxj: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wxn; else goto c4wxm;
       c4wxn: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wxm: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4wxh; else goto c4wxi;
       c4wxh: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4wxq; else goto c4wxv;
       c4wxq: // global
           I64[Hp - 80] = sat_s4vxs_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vxe_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wxv: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4wxC; else goto c4wxt;
       c4wxt: // global
           I64[Hp - 80] = sat_s4vxw_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wxr::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wxr::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wxi: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4wxy; else goto c4wxD;
       c4wxy: // global
           I64[Hp - 80] = sat_s4vxO_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vxA_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wxD: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4wxC; else goto c4wxB;
       c4wxC: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wxB: // global
           I64[Hp - 80] = sat_s4vxS_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wxz::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wxz::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.160189165 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4wA7,
                       label: GHC.Int.$fEnumInt8_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wA7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wAg; else goto c4wAh;
       c4wAg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wAh: // global
           I64[Sp - 24] = block_c4wA4_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4wAq; else goto c4wA5;
       u4wAq: // global
           call _c4wA4(R1) args: 0, res: 0, upd: 0;
       c4wA5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wA4() //  [R1]
         { info_tbl: [(c4wA4,
                       label: block_c4wA4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wA4: // global
           I64[Sp] = block_c4wAa_info;
           _s4vxX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vxX::I64;
           if (R1 & 7 != 0) goto u4wAp; else goto c4wAb;
       u4wAp: // global
           call _c4wAa(R1) args: 0, res: 0, upd: 0;
       c4wAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wAa() //  [R1]
         { info_tbl: [(c4wAa,
                       label: block_c4wAa_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wAa: // global
           I64[Sp] = block_c4wAf_info;
           _s4vxZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vxZ::I64;
           if (R1 & 7 != 0) goto u4wAr; else goto c4wAk;
       u4wAr: // global
           call _c4wAf(R1) args: 0, res: 0, upd: 0;
       c4wAk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wAf() //  [R1]
         { info_tbl: [(c4wAf,
                       label: block_c4wAf_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wAf: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo3_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.171236947 UTC

[section ""data" . GHC.Int.$w$cenumFromTo3_closure" {
     GHC.Int.$w$cenumFromTo3_closure:
         const GHC.Int.$w$cenumFromTo3_info;
         const 0;
 },
 sat_s4vyc_entry() //  [R1]
         { info_tbl: [(c4wB7,
                       label: sat_s4vyc_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wB7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wB8; else goto c4wB9;
       c4wB8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wB9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vy6::I64 = I64[R1 + 32];
           if (_s4vy6::I64 == I64[R1 + 24]) goto c4wB6; else goto c4wB5;
       c4wB6: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4wB5: // global
           R2 = _s4vy6::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4vy5_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vy9_entry() //  [R1]
         { info_tbl: [(c4wBl,
                       label: sat_s4vy9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wBl: // global
           _s4vy9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wBm; else goto c4wBn;
       c4wBn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wBp; else goto c4wBo;
       c4wBp: // global
           HpAlloc = 16;
           goto c4wBm;
       c4wBm: // global
           R1 = _s4vy9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wBo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vy9::P64;
           _s4vy6::I64 = I64[_s4vy9::P64 + 16];
           if (%MO_S_Lt_W64(_s4vy6::I64, (-128))) goto c4wBv; else goto c4wBk;
       c4wBk: // global
           if (%MO_S_Gt_W64(_s4vy6::I64, 127)) goto c4wBv; else goto c4wBz;
       c4wBv: // global
           Hp = Hp - 16;
           R2 = _s4vy6::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wBz: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vy6::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4vy5_entry() //  [R1, R2]
         { info_tbl: [(c4wBB,
                       label: go_s4vy5_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wBB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wBF; else goto c4wBE;
       c4wBF: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wBE: // global
           _s4vy3::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vyc_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vy3::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vy9_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo3_entry() //  [R2, R3]
         { info_tbl: [(c4wBJ,
                       label: GHC.Int.$w$cenumFromTo3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wBJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wBN; else goto c4wBM;
       c4wBN: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wBM: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4wBH; else goto c4wBI;
       c4wBH: // global
           I64[Hp - 8] = go_s4vy5_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4vy5_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4wBI: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.183083235 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4wCp,
                       label: GHC.Int.$fEnumInt8_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wCp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wCt; else goto c4wCu;
       c4wCt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wCu: // global
           I64[Sp - 16] = block_c4wCm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wCC; else goto c4wCn;
       u4wCC: // global
           call _c4wCm(R1) args: 0, res: 0, upd: 0;
       c4wCn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wCm() //  [R1]
         { info_tbl: [(c4wCm,
                       label: block_c4wCm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wCm: // global
           I64[Sp] = block_c4wCs_info;
           _s4vyg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vyg::I64;
           if (R1 & 7 != 0) goto u4wCB; else goto c4wCw;
       u4wCB: // global
           call _c4wCs(R1) args: 0, res: 0, upd: 0;
       c4wCw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wCs() //  [R1]
         { info_tbl: [(c4wCs,
                       label: block_c4wCs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wCs: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo3_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.192184737 UTC

[section ""data" . GHC.Int.$wgo3_closure" {
     GHC.Int.$wgo3_closure:
         const GHC.Int.$wgo3_info;
         const 0;
 },
 sat_s4vys_entry() //  [R1]
         { info_tbl: [(c4wD4,
                       label: sat_s4vys_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wD4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wD5; else goto c4wDg;
       c4wD5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wDg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vyn::I64 = I64[R1 + 16];
           if (_s4vyn::I64 != 127) goto c4wD2; else goto c4wD3;
       c4wD2: // global
           I64[Sp - 24] = block_c4wDa_info;
           R2 = _s4vyn::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 24;
       c4wD3: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4wDa() //  [R1, R2]
         { info_tbl: [(c4wDa,
                       label: block_c4wDa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wDa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wDf; else goto c4wDe;
       c4wDf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4wDe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vym_entry() //  [R1]
         { info_tbl: [(c4wDq,
                       label: sat_s4vym_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wDq: // global
           _s4vym::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wDr; else goto c4wDs;
       c4wDs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wDu; else goto c4wDt;
       c4wDu: // global
           HpAlloc = 16;
           goto c4wDr;
       c4wDr: // global
           R1 = _s4vym::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wDt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vym::P64;
           _s4vyj::I64 = I64[_s4vym::P64 + 16];
           if (%MO_S_Lt_W64(_s4vyj::I64, (-128))) goto c4wDA; else goto c4wDp;
       c4wDp: // global
           if (%MO_S_Gt_W64(_s4vyj::I64, 127)) goto c4wDA; else goto c4wDE;
       c4wDA: // global
           Hp = Hp - 16;
           R2 = _s4vyj::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wDE: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vyj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo3_entry() //  [R2]
         { info_tbl: [(c4wDF,
                       label: GHC.Int.$wgo3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wDF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4wDJ; else goto c4wDI;
       c4wDJ: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wDI: // global
           I64[Hp - 40] = sat_s4vys_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4vym_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.203632245 UTC

[section ""data" . GHC.Int.$fEnumInt8_go_closure" {
     GHC.Int.$fEnumInt8_go_closure:
         const GHC.Int.$fEnumInt8_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_go_entry() //  [R2]
         { info_tbl: [(c4wEi,
                       label: GHC.Int.$fEnumInt8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wEi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wEj; else goto c4wEk;
       c4wEj: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wEk: // global
           I64[Sp - 8] = block_c4wEf_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4wEf() //  [R1, R2]
         { info_tbl: [(c4wEf,
                       label: block_c4wEf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wEf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wEn; else goto c4wEm;
       c4wEn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wEm: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.210336238 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFrom_closure" {
     GHC.Int.$fEnumInt8_$cenumFrom_closure:
         const GHC.Int.$fEnumInt8_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4wEG,
                       label: GHC.Int.$fEnumInt8_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wEG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wEH; else goto c4wEI;
       c4wEH: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wEI: // global
           I64[Sp - 8] = block_c4wED_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wER; else goto c4wEE;
       u4wER: // global
           call _c4wED(R1) args: 0, res: 0, upd: 0;
       c4wEE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wED() //  [R1]
         { info_tbl: [(c4wED,
                       label: block_c4wED_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wED: // global
           _s4vyz::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4vyz::I64, 127)) goto c4wEP; else goto c4wEQ;
       c4wEP: // global
           R2 = _s4vyz::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_go_entry(R2) args: 8, res: 0, upd: 8;
       c4wEQ: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.216270216 UTC

[section ""data" . GHC.Int.$fEnumInt8_closure" {
     GHC.Int.$fEnumInt8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt8_$csucc_closure+1;
         const GHC.Int.$fEnumInt8_$cpred_closure+1;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt8_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4wF8,
                       label: GHC.Int.$fEnumInt8_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wF8: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt8_closure+1;
           R2 = GHC.Int.$fEnumInt8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.22070489 UTC

[section ""cstring" . GHC.Int.$tcInt2_bytes" {
     GHC.Int.$tcInt2_bytes:
         I8[] [73,110,116,49,54]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.222983706 UTC

[section ""data" . GHC.Int.$fEnumInt1_closure" {
     GHC.Int.$fEnumInt1_closure:
         const GHC.Int.$fEnumInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt1_entry() //  [R1]
         { info_tbl: [(c4wFp,
                       label: GHC.Int.$fEnumInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wFp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wFq; else goto c4wFr;
       c4wFq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wFr: // global
           (_c4wFk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wFk::I64 == 0) goto c4wFm; else goto c4wFl;
       c4wFm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wFl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wFk::I64;
           I64[Sp - 24] = block_c4wFn_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4wFn() //  [R1]
         { info_tbl: [(c4wFn,
                       label: block_c4wFn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wFn: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.229945942 UTC

[section ""data" . GHC.Int.$fEnumInt2_closure" {
     GHC.Int.$fEnumInt2_closure:
         const GHC.Int.$fEnumInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt2_entry() //  [R1]
         { info_tbl: [(c4wFP,
                       label: GHC.Int.$fEnumInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wFP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wFQ; else goto c4wFR;
       c4wFQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wFR: // global
           (_c4wFK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wFK::I64 == 0) goto c4wFM; else goto c4wFL;
       c4wFM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wFL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wFK::I64;
           I64[Sp - 24] = block_c4wFN_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4wFN() //  [R1]
         { info_tbl: [(c4wFN,
                       label: block_c4wFN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wFN: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.236081378 UTC

[section ""data" . GHC.Int.neInt16_closure" {
     GHC.Int.neInt16_closure:
         const GHC.Int.neInt16_info;
 },
 GHC.Int.neInt16_entry() //  [R2, R3]
         { info_tbl: [(c4wGe,
                       label: GHC.Int.neInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wGe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wGi; else goto c4wGj;
       c4wGi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wGj: // global
           I64[Sp - 16] = block_c4wGb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wGs; else goto c4wGc;
       u4wGs: // global
           call _c4wGb(R1) args: 0, res: 0, upd: 0;
       c4wGc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wGb() //  [R1]
         { info_tbl: [(c4wGb,
                       label: block_c4wGb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wGb: // global
           I64[Sp] = block_c4wGh_info;
           _s4vyG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vyG::I64;
           if (R1 & 7 != 0) goto u4wGr; else goto c4wGl;
       u4wGr: // global
           call _c4wGh(R1) args: 0, res: 0, upd: 0;
       c4wGl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wGh() //  [R1]
         { info_tbl: [(c4wGh,
                       label: block_c4wGh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wGh: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.243969923 UTC

[section ""data" . lvl2_r4kPt_closure" {
     lvl2_r4kPt_closure:
         const lvl2_r4kPt_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r4kPt_entry() //  [R1]
         { info_tbl: [(c4wGT,
                       label: lvl2_r4kPt_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wGT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wGU; else goto c4wGV;
       c4wGU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wGV: // global
           (_c4wGQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wGQ::I64 == 0) goto c4wGS; else goto c4wGR;
       c4wGS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wGR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wGQ::I64;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.248775305 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cminBound_closure" {
     GHC.Int.$fBoundedInt16_$cminBound_closure:
         const GHC.Int.I16#_con_info;
         const (-32768);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.251730927 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cpred_closure" {
     GHC.Int.$fEnumInt16_$cpred_closure:
         const GHC.Int.$fEnumInt16_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cpred_entry() //  [R2]
         { info_tbl: [(c4wHc,
                       label: GHC.Int.$fEnumInt16_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wHc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wHd; else goto c4wHe;
       c4wHd: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wHe: // global
           I64[Sp - 8] = block_c4wH9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wHw; else goto c4wHa;
       u4wHw: // global
           call _c4wH9(R1) args: 0, res: 0, upd: 0;
       c4wHa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wH9() //  [R1]
         { info_tbl: [(c4wH9,
                       label: block_c4wH9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wH9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wHj; else goto c4wHi;
       c4wHj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wHi: // global
           _s4vyN::I64 = I64[R1 + 7];
           if (_s4vyN::I64 != (-32768)) goto c4wHu; else goto c4wHv;
       c4wHu: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vyN::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wHv: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.257905422 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt16_$cmaxBound_closure:
         const GHC.Int.I16#_con_info;
         const 32767;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.25970204 UTC

[section ""data" . GHC.Int.$fBoundedInt16_closure" {
     GHC.Int.$fBoundedInt16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt16_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.262081007 UTC

[section ""data" . GHC.Int.$fEnumInt16_$csucc_closure" {
     GHC.Int.$fEnumInt16_$csucc_closure:
         const GHC.Int.$fEnumInt16_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$csucc_entry() //  [R2]
         { info_tbl: [(c4wHV,
                       label: GHC.Int.$fEnumInt16_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wHV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wHW; else goto c4wHX;
       c4wHW: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wHX: // global
           I64[Sp - 8] = block_c4wHS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wIf; else goto c4wHT;
       u4wIf: // global
           call _c4wHS(R1) args: 0, res: 0, upd: 0;
       c4wHT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wHS() //  [R1]
         { info_tbl: [(c4wHS,
                       label: block_c4wHS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wHS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wI2; else goto c4wI1;
       c4wI2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wI1: // global
           _s4vyT::I64 = I64[R1 + 7];
           if (_s4vyT::I64 != 32767) goto c4wId; else goto c4wIe;
       c4wId: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vyT::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wIe: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.269088864 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowsPrec_closure" {
     GHC.Int.$fShowInt16_$cshowsPrec_closure:
         const GHC.Int.$fShowInt16_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt16_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4wIC,
                       label: GHC.Int.$fShowInt16_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wIC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wIN; else goto c4wIO;
       c4wIN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wIO: // global
           I64[Sp - 24] = block_c4wIz_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4wIV; else goto c4wIA;
       u4wIV: // global
           call _c4wIz(R1) args: 0, res: 0, upd: 0;
       c4wIA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wIz() //  [R1]
         { info_tbl: [(c4wIz,
                       label: block_c4wIz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wIz: // global
           I64[Sp] = block_c4wIF_info;
           _s4vz0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vz0::I64;
           if (R1 & 7 != 0) goto u4wIU; else goto c4wIG;
       u4wIU: // global
           call _c4wIF(R1) args: 0, res: 0, upd: 0;
       c4wIG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wIF() //  [R1]
         { info_tbl: [(c4wIF,
                       label: block_c4wIF_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wIF: // global
           _s4vyY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4wIK_info;
           R4 = _s4vyY::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4wIK() //  [R1, R2]
         { info_tbl: [(c4wIK,
                       label: block_c4wIK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wIK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wIT; else goto c4wIS;
       c4wIT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wIS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.280039201 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshow_closure" {
     GHC.Int.$fShowInt16_$cshow_closure:
         const GHC.Int.$fShowInt16_$cshow_info;
 },
 GHC.Int.$fShowInt16_$cshow_entry() //  [R2]
         { info_tbl: [(c4wJo,
                       label: GHC.Int.$fShowInt16_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wJo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wJu; else goto c4wJv;
       c4wJu: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wJv: // global
           I64[Sp - 8] = block_c4wJl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wJA; else goto c4wJm;
       u4wJA: // global
           call _c4wJl(R1) args: 0, res: 0, upd: 0;
       c4wJm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wJl() //  [R1]
         { info_tbl: [(c4wJl,
                       label: block_c4wJl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wJl: // global
           I64[Sp] = block_c4wJr_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4wJr() //  [R1, R2]
         { info_tbl: [(c4wJr,
                       label: block_c4wJr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wJr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wJz; else goto c4wJy;
       c4wJz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wJy: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.288401751 UTC

[section ""data" . GHC.Int.$fShowInt1_closure" {
     GHC.Int.$fShowInt1_closure:
         const GHC.Int.$fShowInt1_info;
 },
 GHC.Int.$fShowInt1_entry() //  [R2, R3]
         { info_tbl: [(c4wJZ,
                       label: GHC.Int.$fShowInt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wJZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wK5; else goto c4wK6;
       c4wK5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wK6: // global
           I64[Sp - 16] = block_c4wJW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wKb; else goto c4wJX;
       u4wKb: // global
           call _c4wJW(R1) args: 0, res: 0, upd: 0;
       c4wJX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wJW() //  [R1]
         { info_tbl: [(c4wJW,
                       label: block_c4wJW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wJW: // global
           _s4vzd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4wK2_info;
           R4 = _s4vzd::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4wK2() //  [R1, R2]
         { info_tbl: [(c4wK2,
                       label: block_c4wK2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wK2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wKa; else goto c4wK9;
       c4wKa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wK9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.296984369 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowList_closure" {
     GHC.Int.$fShowInt16_$cshowList_closure:
         const GHC.Int.$fShowInt16_$cshowList_info;
 },
 GHC.Int.$fShowInt16_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4wKw,
                       label: GHC.Int.$fShowInt16_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wKw: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.30050316 UTC

[section ""data" . GHC.Int.$fShowInt16_closure" {
     GHC.Int.$fShowInt16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt16_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt16_$cshow_closure+1;
         const GHC.Int.$fShowInt16_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.302899142 UTC

[section ""data" . GHC.Int.$wlvl_closure" {
     GHC.Int.$wlvl_closure:
         const GHC.Int.$wlvl_info;
         const 0;
 },
 GHC.Int.$wlvl_entry() //  [R2]
         { info_tbl: [(c4wKI,
                       label: GHC.Int.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wKI: // global
           R6 = GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r4kPt_closure;
           R2 = GHC.Int.$fShowInt16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.306900918 UTC

[section ""data" . GHC.Int.$w$ctoEnum_closure" {
     GHC.Int.$w$ctoEnum_closure:
         const GHC.Int.$w$ctoEnum_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4wKY,
                       label: GHC.Int.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wKY: // global
           _s4vzm::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-32768))) goto c4wL6; else goto c4wKX;
       c4wKX: // global
           if (%MO_S_Gt_W64(_s4vzm::I64, 32767)) goto c4wL6; else goto c4wL7;
       c4wL6: // global
           R2 = _s4vzm::I64;
           call GHC.Int.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c4wL7: // global
           R1 = _s4vzm::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.311370194 UTC

[section ""data" . GHC.Int.$fEnumInt16_$ctoEnum_closure" {
     GHC.Int.$fEnumInt16_$ctoEnum_closure:
         const GHC.Int.$fEnumInt16_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4wLk,
                       label: GHC.Int.$fEnumInt16_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wLk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wLs; else goto c4wLt;
       c4wLs: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wLt: // global
           I64[Sp - 8] = block_c4wLh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wLy; else goto c4wLi;
       u4wLy: // global
           call _c4wLh(R1) args: 0, res: 0, upd: 0;
       c4wLi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wLh() //  [R1]
         { info_tbl: [(c4wLh,
                       label: block_c4wLh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wLh: // global
           I64[Sp] = block_c4wLn_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4wLn() //  [R1]
         { info_tbl: [(c4wLn,
                       label: block_c4wLn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wLn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wLx; else goto c4wLw;
       c4wLx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4wLw: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.328439974 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo_closure" {
     GHC.Int.$w$cenumFromThenTo_closure:
         const GHC.Int.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s4vzM_entry() //  [R1]
         { info_tbl: [(c4wMn,
                       label: sat_s4vzM_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wMn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wMo; else goto c4wMp;
       c4wMo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wMp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4vzF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vzK_entry() //  [R1]
         { info_tbl: [(c4wMz,
                       label: sat_s4vzK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wMz: // global
           _s4vzK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wMA; else goto c4wMB;
       c4wMB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wMD; else goto c4wMC;
       c4wMD: // global
           HpAlloc = 16;
           goto c4wMA;
       c4wMA: // global
           R1 = _s4vzK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wMC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzK::P64;
           _s4vzG::I64 = I64[_s4vzK::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzG::I64,
                            (-32768))) goto c4wMJ; else goto c4wMy;
       c4wMy: // global
           if (%MO_S_Gt_W64(_s4vzG::I64, 32767)) goto c4wMJ; else goto c4wMN;
       c4wMJ: // global
           Hp = Hp - 16;
           R2 = _s4vzG::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wMN: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzG::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vzP_entry() //  [R1]
         { info_tbl: [(c4wMY,
                       label: sat_s4vzP_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wMY: // global
           _s4vzP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wMZ; else goto c4wN0;
       c4wN0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wN2; else goto c4wN1;
       c4wN2: // global
           HpAlloc = 16;
           goto c4wMZ;
       c4wMZ: // global
           R1 = _s4vzP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wN1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzP::P64;
           _s4vzG::I64 = I64[_s4vzP::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzG::I64,
                            (-32768))) goto c4wN8; else goto c4wMX;
       c4wMX: // global
           if (%MO_S_Gt_W64(_s4vzG::I64, 32767)) goto c4wN8; else goto c4wNc;
       c4wN8: // global
           Hp = Hp - 16;
           R2 = _s4vzG::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wNc: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzG::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4vzF_entry() //  [R1, R2]
         { info_tbl: [(c4wNg,
                       label: go_dn_s4vzF_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wNg: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wNk; else goto c4wNj;
       c4wNk: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wNj: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4wNe; else goto c4wNf;
       c4wNe: // global
           _s4vzD::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vzM_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vzD::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vzK_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wNf: // global
           I64[Hp - 80] = sat_s4vzP_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wNm::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wNm::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4vzQ_entry() //  [R1]
         { info_tbl: [(c4wNn,
                       label: sat_s4vzQ_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wNn: // global
           _s4vzQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wNo; else goto c4wNp;
       c4wNp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wNr; else goto c4wNq;
       c4wNr: // global
           HpAlloc = 24;
           goto c4wNo;
       c4wNo: // global
           R1 = _s4vzQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wNq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzQ::P64;
           _s4vzw::I64 = I64[_s4vzQ::P64 + 24];
           _s4vzD::I64 = _s4vzw::I64 - I64[_s4vzQ::P64 + 16];
           _s4vzE::I64 = I64[_s4vzQ::P64 + 32] - _s4vzD::I64;
           I64[Hp - 16] = go_dn_s4vzF_info;
           I64[Hp - 8] = _s4vzD::I64;
           I64[Hp] = _s4vzE::I64;
           R2 = _s4vzw::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4vzF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vzC_entry() //  [R1]
         { info_tbl: [(c4wNB,
                       label: sat_s4vzC_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wNB: // global
           _s4vzC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wNC; else goto c4wND;
       c4wND: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wNF; else goto c4wNE;
       c4wNF: // global
           HpAlloc = 16;
           goto c4wNC;
       c4wNC: // global
           R1 = _s4vzC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wNE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzC::P64;
           _s4vzv::I64 = I64[_s4vzC::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzv::I64,
                            (-32768))) goto c4wNL; else goto c4wNA;
       c4wNA: // global
           if (%MO_S_Gt_W64(_s4vzv::I64, 32767)) goto c4wNL; else goto c4wNP;
       c4wNL: // global
           Hp = Hp - 16;
           R2 = _s4vzv::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wNP: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzv::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vzU_entry() //  [R1]
         { info_tbl: [(c4wO3,
                       label: sat_s4vzU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wO3: // global
           _s4vzU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wO4; else goto c4wO5;
       c4wO5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wO7; else goto c4wO6;
       c4wO7: // global
           HpAlloc = 16;
           goto c4wO4;
       c4wO4: // global
           R1 = _s4vzU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wO6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzU::P64;
           _s4vzv::I64 = I64[_s4vzU::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzv::I64,
                            (-32768))) goto c4wOd; else goto c4wO2;
       c4wO2: // global
           if (%MO_S_Gt_W64(_s4vzv::I64, 32767)) goto c4wOd; else goto c4wOh;
       c4wOd: // global
           Hp = Hp - 16;
           R2 = _s4vzv::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wOh: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzv::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vA8_entry() //  [R1]
         { info_tbl: [(c4wOK,
                       label: sat_s4vA8_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wOK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wOL; else goto c4wOM;
       c4wOL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wOM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4vA1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vA6_entry() //  [R1]
         { info_tbl: [(c4wOW,
                       label: sat_s4vA6_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wOW: // global
           _s4vA6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wOX; else goto c4wOY;
       c4wOY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wP0; else goto c4wOZ;
       c4wP0: // global
           HpAlloc = 16;
           goto c4wOX;
       c4wOX: // global
           R1 = _s4vA6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wOZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vA6::P64;
           _s4vA2::I64 = I64[_s4vA6::P64 + 16];
           if (%MO_S_Lt_W64(_s4vA2::I64,
                            (-32768))) goto c4wP6; else goto c4wOV;
       c4wOV: // global
           if (%MO_S_Gt_W64(_s4vA2::I64, 32767)) goto c4wP6; else goto c4wPa;
       c4wP6: // global
           Hp = Hp - 16;
           R2 = _s4vA2::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wPa: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vA2::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vAb_entry() //  [R1]
         { info_tbl: [(c4wPl,
                       label: sat_s4vAb_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wPl: // global
           _s4vAb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wPm; else goto c4wPn;
       c4wPn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wPp; else goto c4wPo;
       c4wPp: // global
           HpAlloc = 16;
           goto c4wPm;
       c4wPm: // global
           R1 = _s4vAb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wPo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vAb::P64;
           _s4vA2::I64 = I64[_s4vAb::P64 + 16];
           if (%MO_S_Lt_W64(_s4vA2::I64,
                            (-32768))) goto c4wPv; else goto c4wPk;
       c4wPk: // global
           if (%MO_S_Gt_W64(_s4vA2::I64, 32767)) goto c4wPv; else goto c4wPz;
       c4wPv: // global
           Hp = Hp - 16;
           R2 = _s4vA2::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wPz: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vA2::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4vA1_entry() //  [R1, R2]
         { info_tbl: [(c4wPD,
                       label: go_up_s4vA1_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wPD: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wPH; else goto c4wPG;
       c4wPH: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wPG: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4wPB; else goto c4wPC;
       c4wPB: // global
           _s4vzZ::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vA8_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vzZ::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vA6_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wPC: // global
           I64[Hp - 80] = sat_s4vAb_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wPJ::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wPJ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4vAc_entry() //  [R1]
         { info_tbl: [(c4wPK,
                       label: sat_s4vAc_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wPK: // global
           _s4vAc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wPL; else goto c4wPM;
       c4wPM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wPO; else goto c4wPN;
       c4wPO: // global
           HpAlloc = 24;
           goto c4wPL;
       c4wPL: // global
           R1 = _s4vAc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wPN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vAc::P64;
           _s4vzw::I64 = I64[_s4vAc::P64 + 24];
           _s4vzZ::I64 = _s4vzw::I64 - I64[_s4vAc::P64 + 16];
           _s4vA0::I64 = I64[_s4vAc::P64 + 32] - _s4vzZ::I64;
           I64[Hp - 16] = go_up_s4vA1_info;
           I64[Hp - 8] = _s4vzZ::I64;
           I64[Hp] = _s4vA0::I64;
           R2 = _s4vzw::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4vA1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vzY_entry() //  [R1]
         { info_tbl: [(c4wPY,
                       label: sat_s4vzY_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wPY: // global
           _s4vzY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wPZ; else goto c4wQ0;
       c4wQ0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wQ2; else goto c4wQ1;
       c4wQ2: // global
           HpAlloc = 16;
           goto c4wPZ;
       c4wPZ: // global
           R1 = _s4vzY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wQ1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzY::P64;
           _s4vzv::I64 = I64[_s4vzY::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzv::I64,
                            (-32768))) goto c4wQ8; else goto c4wPX;
       c4wPX: // global
           if (%MO_S_Gt_W64(_s4vzv::I64, 32767)) goto c4wQ8; else goto c4wQc;
       c4wQ8: // global
           Hp = Hp - 16;
           R2 = _s4vzv::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wQc: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzv::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vAg_entry() //  [R1]
         { info_tbl: [(c4wQq,
                       label: sat_s4vAg_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wQq: // global
           _s4vAg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wQr; else goto c4wQs;
       c4wQs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wQu; else goto c4wQt;
       c4wQu: // global
           HpAlloc = 16;
           goto c4wQr;
       c4wQr: // global
           R1 = _s4vAg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wQt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vAg::P64;
           _s4vzv::I64 = I64[_s4vAg::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzv::I64,
                            (-32768))) goto c4wQA; else goto c4wQp;
       c4wQp: // global
           if (%MO_S_Gt_W64(_s4vzv::I64, 32767)) goto c4wQA; else goto c4wQE;
       c4wQA: // global
           Hp = Hp - 16;
           R2 = _s4vzv::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wQE: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzv::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4wQI,
                       label: GHC.Int.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wQI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wQM; else goto c4wQL;
       c4wQM: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wQL: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4wQG; else goto c4wQH;
       c4wQG: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4wQP; else goto c4wQU;
       c4wQP: // global
           I64[Hp - 80] = sat_s4vzQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vzC_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wQU: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4wR1; else goto c4wQS;
       c4wQS: // global
           I64[Hp - 80] = sat_s4vzU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wQQ::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wQQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wQH: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4wQX; else goto c4wR2;
       c4wQX: // global
           I64[Hp - 80] = sat_s4vAc_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vzY_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wR2: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4wR1; else goto c4wR0;
       c4wR1: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wR0: // global
           I64[Hp - 80] = sat_s4vAg_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wQY::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wQY::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.383691219 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4wTw,
                       label: GHC.Int.$fEnumInt16_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wTw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wTF; else goto c4wTG;
       c4wTF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wTG: // global
           I64[Sp - 24] = block_c4wTt_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4wTP; else goto c4wTu;
       u4wTP: // global
           call _c4wTt(R1) args: 0, res: 0, upd: 0;
       c4wTu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wTt() //  [R1]
         { info_tbl: [(c4wTt,
                       label: block_c4wTt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wTt: // global
           I64[Sp] = block_c4wTz_info;
           _s4vAl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vAl::I64;
           if (R1 & 7 != 0) goto u4wTO; else goto c4wTA;
       u4wTO: // global
           call _c4wTz(R1) args: 0, res: 0, upd: 0;
       c4wTA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wTz() //  [R1]
         { info_tbl: [(c4wTz,
                       label: block_c4wTz_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wTz: // global
           I64[Sp] = block_c4wTE_info;
           _s4vAn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vAn::I64;
           if (R1 & 7 != 0) goto u4wTQ; else goto c4wTJ;
       u4wTQ: // global
           call _c4wTE(R1) args: 0, res: 0, upd: 0;
       c4wTJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wTE() //  [R1]
         { info_tbl: [(c4wTE,
                       label: block_c4wTE_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wTE: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.395187975 UTC

[section ""data" . GHC.Int.$w$cenumFromTo_closure" {
     GHC.Int.$w$cenumFromTo_closure:
         const GHC.Int.$w$cenumFromTo_info;
         const 0;
 },
 sat_s4vAA_entry() //  [R1]
         { info_tbl: [(c4wUw,
                       label: sat_s4vAA_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wUw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wUx; else goto c4wUy;
       c4wUx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wUy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vAu::I64 = I64[R1 + 32];
           if (_s4vAu::I64 == I64[R1 + 24]) goto c4wUv; else goto c4wUu;
       c4wUv: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4wUu: // global
           R2 = _s4vAu::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4vAt_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vAx_entry() //  [R1]
         { info_tbl: [(c4wUK,
                       label: sat_s4vAx_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wUK: // global
           _s4vAx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wUL; else goto c4wUM;
       c4wUM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wUO; else goto c4wUN;
       c4wUO: // global
           HpAlloc = 16;
           goto c4wUL;
       c4wUL: // global
           R1 = _s4vAx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wUN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vAx::P64;
           _s4vAu::I64 = I64[_s4vAx::P64 + 16];
           if (%MO_S_Lt_W64(_s4vAu::I64,
                            (-32768))) goto c4wUU; else goto c4wUJ;
       c4wUJ: // global
           if (%MO_S_Gt_W64(_s4vAu::I64, 32767)) goto c4wUU; else goto c4wUY;
       c4wUU: // global
           Hp = Hp - 16;
           R2 = _s4vAu::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wUY: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vAu::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4vAt_entry() //  [R1, R2]
         { info_tbl: [(c4wV0,
                       label: go_s4vAt_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wV0: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wV4; else goto c4wV3;
       c4wV4: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wV3: // global
           _s4vAr::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vAA_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vAr::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vAx_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4wV8,
                       label: GHC.Int.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wV8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wVc; else goto c4wVb;
       c4wVc: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wVb: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4wV6; else goto c4wV7;
       c4wV6: // global
           I64[Hp - 8] = go_s4vAt_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4vAt_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4wV7: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.406797967 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4wVO,
                       label: GHC.Int.$fEnumInt16_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wVO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wVS; else goto c4wVT;
       c4wVS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wVT: // global
           I64[Sp - 16] = block_c4wVL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wW1; else goto c4wVM;
       u4wW1: // global
           call _c4wVL(R1) args: 0, res: 0, upd: 0;
       c4wVM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wVL() //  [R1]
         { info_tbl: [(c4wVL,
                       label: block_c4wVL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wVL: // global
           I64[Sp] = block_c4wVR_info;
           _s4vAE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vAE::I64;
           if (R1 & 7 != 0) goto u4wW0; else goto c4wVV;
       u4wW0: // global
           call _c4wVR(R1) args: 0, res: 0, upd: 0;
       c4wVV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wVR() //  [R1]
         { info_tbl: [(c4wVR,
                       label: block_c4wVR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wVR: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.415230095 UTC

[section ""data" . GHC.Int.$wgo_closure" {
     GHC.Int.$wgo_closure:
         const GHC.Int.$wgo_info;
         const 0;
 },
 sat_s4vAQ_entry() //  [R1]
         { info_tbl: [(c4wWt,
                       label: sat_s4vAQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wWt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wWu; else goto c4wWF;
       c4wWu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wWF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vAL::I64 = I64[R1 + 16];
           if (_s4vAL::I64 != 32767) goto c4wWr; else goto c4wWs;
       c4wWr: // global
           I64[Sp - 24] = block_c4wWz_info;
           R2 = _s4vAL::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c4wWs: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4wWz() //  [R1, R2]
         { info_tbl: [(c4wWz,
                       label: block_c4wWz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wWz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wWE; else goto c4wWD;
       c4wWE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4wWD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vAK_entry() //  [R1]
         { info_tbl: [(c4wWP,
                       label: sat_s4vAK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wWP: // global
           _s4vAK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wWQ; else goto c4wWR;
       c4wWR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wWT; else goto c4wWS;
       c4wWT: // global
           HpAlloc = 16;
           goto c4wWQ;
       c4wWQ: // global
           R1 = _s4vAK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wWS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vAK::P64;
           _s4vAH::I64 = I64[_s4vAK::P64 + 16];
           if (%MO_S_Lt_W64(_s4vAH::I64,
                            (-32768))) goto c4wWZ; else goto c4wWO;
       c4wWO: // global
           if (%MO_S_Gt_W64(_s4vAH::I64, 32767)) goto c4wWZ; else goto c4wX3;
       c4wWZ: // global
           Hp = Hp - 16;
           R2 = _s4vAH::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wX3: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vAH::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo_entry() //  [R2]
         { info_tbl: [(c4wX4,
                       label: GHC.Int.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wX4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4wX8; else goto c4wX7;
       c4wX8: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wX7: // global
           I64[Hp - 40] = sat_s4vAQ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4vAK_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.426998164 UTC

[section ""data" . GHC.Int.$fEnumInt16_go_closure" {
     GHC.Int.$fEnumInt16_go_closure:
         const GHC.Int.$fEnumInt16_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_go_entry() //  [R2]
         { info_tbl: [(c4wXH,
                       label: GHC.Int.$fEnumInt16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wXH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wXI; else goto c4wXJ;
       c4wXI: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wXJ: // global
           I64[Sp - 8] = block_c4wXE_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4wXE() //  [R1, R2]
         { info_tbl: [(c4wXE,
                       label: block_c4wXE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wXE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wXM; else goto c4wXL;
       c4wXM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wXL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.433192049 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFrom_closure" {
     GHC.Int.$fEnumInt16_$cenumFrom_closure:
         const GHC.Int.$fEnumInt16_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4wY5,
                       label: GHC.Int.$fEnumInt16_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wY5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wY6; else goto c4wY7;
       c4wY6: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wY7: // global
           I64[Sp - 8] = block_c4wY2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wYg; else goto c4wY3;
       u4wYg: // global
           call _c4wY2(R1) args: 0, res: 0, upd: 0;
       c4wY3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wY2() //  [R1]
         { info_tbl: [(c4wY2,
                       label: block_c4wY2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wY2: // global
           _s4vAX::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4vAX::I64, 32767)) goto c4wYe; else goto c4wYf;
       c4wYe: // global
           R2 = _s4vAX::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_go_entry(R2) args: 8, res: 0, upd: 8;
       c4wYf: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.439973091 UTC

[section ""data" . GHC.Int.$fEnumInt16_closure" {
     GHC.Int.$fEnumInt16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt16_$csucc_closure+1;
         const GHC.Int.$fEnumInt16_$cpred_closure+1;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt16_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4wYx,
                       label: GHC.Int.$fEnumInt16_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wYx: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt16_closure+1;
           R2 = GHC.Int.$fEnumInt16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.444212899 UTC

[section ""cstring" . GHC.Int.$tcInt4_bytes" {
     GHC.Int.$tcInt4_bytes:
         I8[] [73,110,116,51,50]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.446285439 UTC

[section ""data" . GHC.Int.$fEnumInt3_closure" {
     GHC.Int.$fEnumInt3_closure:
         const GHC.Int.$fEnumInt3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt3_entry() //  [R1]
         { info_tbl: [(c4wYO,
                       label: GHC.Int.$fEnumInt3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wYO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wYP; else goto c4wYQ;
       c4wYP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wYQ: // global
           (_c4wYJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wYJ::I64 == 0) goto c4wYL; else goto c4wYK;
       c4wYL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wYK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wYJ::I64;
           I64[Sp - 24] = block_c4wYM_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4wYM() //  [R1]
         { info_tbl: [(c4wYM,
                       label: block_c4wYM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wYM: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.452497509 UTC

[section ""data" . GHC.Int.$fEnumInt4_closure" {
     GHC.Int.$fEnumInt4_closure:
         const GHC.Int.$fEnumInt4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt4_entry() //  [R1]
         { info_tbl: [(c4wZe,
                       label: GHC.Int.$fEnumInt4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wZe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wZf; else goto c4wZg;
       c4wZf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wZg: // global
           (_c4wZ9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wZ9::I64 == 0) goto c4wZb; else goto c4wZa;
       c4wZb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wZa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wZ9::I64;
           I64[Sp - 24] = block_c4wZc_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4wZc() //  [R1]
         { info_tbl: [(c4wZc,
                       label: block_c4wZc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wZc: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.459440973 UTC

[section ""data" . GHC.Int.neInt32_closure" {
     GHC.Int.neInt32_closure:
         const GHC.Int.neInt32_info;
 },
 GHC.Int.neInt32_entry() //  [R2, R3]
         { info_tbl: [(c4wZD,
                       label: GHC.Int.neInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wZD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wZH; else goto c4wZI;
       c4wZH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wZI: // global
           I64[Sp - 16] = block_c4wZA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wZR; else goto c4wZB;
       u4wZR: // global
           call _c4wZA(R1) args: 0, res: 0, upd: 0;
       c4wZB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wZA() //  [R1]
         { info_tbl: [(c4wZA,
                       label: block_c4wZA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wZA: // global
           I64[Sp] = block_c4wZG_info;
           _s4vB4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vB4::I64;
           if (R1 & 7 != 0) goto u4wZQ; else goto c4wZK;
       u4wZQ: // global
           call _c4wZG(R1) args: 0, res: 0, upd: 0;
       c4wZK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4wZG() //  [R1]
         { info_tbl: [(c4wZG,
                       label: block_c4wZG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4wZG: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.467019564 UTC

[section ""data" . lvl4_r4kPv_closure" {
     lvl4_r4kPv_closure:
         const lvl4_r4kPv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r4kPv_entry() //  [R1]
         { info_tbl: [(c4x0i,
                       label: lvl4_r4kPv_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x0i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4x0j; else goto c4x0k;
       c4x0j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4x0k: // global
           (_c4x0f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4x0f::I64 == 0) goto c4x0h; else goto c4x0g;
       c4x0h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4x0g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4x0f::I64;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.471459613 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cminBound_closure" {
     GHC.Int.$fBoundedInt32_$cminBound_closure:
         const GHC.Int.I32#_con_info;
         const (-2147483648);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.473782688 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cpred_closure" {
     GHC.Int.$fEnumInt32_$cpred_closure:
         const GHC.Int.$fEnumInt32_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cpred_entry() //  [R2]
         { info_tbl: [(c4x0B,
                       label: GHC.Int.$fEnumInt32_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x0B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x0C; else goto c4x0D;
       c4x0C: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x0D: // global
           I64[Sp - 8] = block_c4x0y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4x0V; else goto c4x0z;
       u4x0V: // global
           call _c4x0y(R1) args: 0, res: 0, upd: 0;
       c4x0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x0y() //  [R1]
         { info_tbl: [(c4x0y,
                       label: block_c4x0y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x0y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x0I; else goto c4x0H;
       c4x0I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4x0H: // global
           _s4vBb::I64 = I64[R1 + 7];
           if (_s4vBb::I64 != (-2147483648)) goto c4x0T; else goto c4x0U;
       c4x0T: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4vBb::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4x0U: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.480630685 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt32_$cmaxBound_closure:
         const GHC.Int.I32#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.482455409 UTC

[section ""data" . GHC.Int.$fBoundedInt32_closure" {
     GHC.Int.$fBoundedInt32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt32_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.48474261 UTC

[section ""data" . GHC.Int.$fEnumInt32_$csucc_closure" {
     GHC.Int.$fEnumInt32_$csucc_closure:
         const GHC.Int.$fEnumInt32_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$csucc_entry() //  [R2]
         { info_tbl: [(c4x1k,
                       label: GHC.Int.$fEnumInt32_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x1k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x1l; else goto c4x1m;
       c4x1l: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x1m: // global
           I64[Sp - 8] = block_c4x1h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4x1E; else goto c4x1i;
       u4x1E: // global
           call _c4x1h(R1) args: 0, res: 0, upd: 0;
       c4x1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x1h() //  [R1]
         { info_tbl: [(c4x1h,
                       label: block_c4x1h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x1h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x1r; else goto c4x1q;
       c4x1r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4x1q: // global
           _s4vBh::I64 = I64[R1 + 7];
           if (_s4vBh::I64 != 2147483647) goto c4x1C; else goto c4x1D;
       c4x1C: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4vBh::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4x1D: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.491908316 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowsPrec_closure" {
     GHC.Int.$fShowInt32_$cshowsPrec_closure:
         const GHC.Int.$fShowInt32_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt32_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4x21,
                       label: GHC.Int.$fShowInt32_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x21: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4x2c; else goto c4x2d;
       c4x2c: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4x2d: // global
           I64[Sp - 24] = block_c4x1Y_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4x2k; else goto c4x1Z;
       u4x2k: // global
           call _c4x1Y(R1) args: 0, res: 0, upd: 0;
       c4x1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x1Y() //  [R1]
         { info_tbl: [(c4x1Y,
                       label: block_c4x1Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x1Y: // global
           I64[Sp] = block_c4x24_info;
           _s4vBo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vBo::I64;
           if (R1 & 7 != 0) goto u4x2j; else goto c4x25;
       u4x2j: // global
           call _c4x24(R1) args: 0, res: 0, upd: 0;
       c4x25: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x24() //  [R1]
         { info_tbl: [(c4x24,
                       label: block_c4x24_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x24: // global
           _s4vBm::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4x29_info;
           R4 = _s4vBm::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4x29() //  [R1, R2]
         { info_tbl: [(c4x29,
                       label: block_c4x29_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x29: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4x2i; else goto c4x2h;
       c4x2i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4x2h: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.502296311 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshow_closure" {
     GHC.Int.$fShowInt32_$cshow_closure:
         const GHC.Int.$fShowInt32_$cshow_info;
 },
 GHC.Int.$fShowInt32_$cshow_entry() //  [R2]
         { info_tbl: [(c4x2N,
                       label: GHC.Int.$fShowInt32_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x2N: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x2T; else goto c4x2U;
       c4x2T: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x2U: // global
           I64[Sp - 8] = block_c4x2K_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4x2Z; else goto c4x2L;
       u4x2Z: // global
           call _c4x2K(R1) args: 0, res: 0, upd: 0;
       c4x2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x2K() //  [R1]
         { info_tbl: [(c4x2K,
                       label: block_c4x2K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x2K: // global
           I64[Sp] = block_c4x2Q_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4x2Q() //  [R1, R2]
         { info_tbl: [(c4x2Q,
                       label: block_c4x2Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x2Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4x2Y; else goto c4x2X;
       c4x2Y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4x2X: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.510489011 UTC

[section ""data" . GHC.Int.$fShowInt2_closure" {
     GHC.Int.$fShowInt2_closure:
         const GHC.Int.$fShowInt2_info;
 },
 GHC.Int.$fShowInt2_entry() //  [R2, R3]
         { info_tbl: [(c4x3o,
                       label: GHC.Int.$fShowInt2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x3o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4x3u; else goto c4x3v;
       c4x3u: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4x3v: // global
           I64[Sp - 16] = block_c4x3l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4x3A; else goto c4x3m;
       u4x3A: // global
           call _c4x3l(R1) args: 0, res: 0, upd: 0;
       c4x3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x3l() //  [R1]
         { info_tbl: [(c4x3l,
                       label: block_c4x3l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x3l: // global
           _s4vBB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4x3r_info;
           R4 = _s4vBB::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4x3r() //  [R1, R2]
         { info_tbl: [(c4x3r,
                       label: block_c4x3r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x3r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4x3z; else goto c4x3y;
       c4x3z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4x3y: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.518626698 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowList_closure" {
     GHC.Int.$fShowInt32_$cshowList_closure:
         const GHC.Int.$fShowInt32_$cshowList_info;
 },
 GHC.Int.$fShowInt32_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4x3V,
                       label: GHC.Int.$fShowInt32_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x3V: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.522659287 UTC

[section ""data" . GHC.Int.$fShowInt32_closure" {
     GHC.Int.$fShowInt32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt32_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt32_$cshow_closure+1;
         const GHC.Int.$fShowInt32_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.524725041 UTC

[section ""data" . GHC.Int.$wlvl1_closure" {
     GHC.Int.$wlvl1_closure:
         const GHC.Int.$wlvl1_info;
         const 0;
 },
 GHC.Int.$wlvl1_entry() //  [R2]
         { info_tbl: [(c4x47,
                       label: GHC.Int.$wlvl1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x47: // global
           R6 = GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r4kPv_closure;
           R2 = GHC.Int.$fShowInt32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.528711052 UTC

[section ""data" . GHC.Int.$w$ctoEnum1_closure" {
     GHC.Int.$w$ctoEnum1_closure:
         const GHC.Int.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum1_entry() //  [R2]
         { info_tbl: [(c4x4n,
                       label: GHC.Int.$w$ctoEnum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x4n: // global
           _s4vBK::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-2147483648))) goto c4x4v; else goto c4x4m;
       c4x4m: // global
           if (%MO_S_Gt_W64(_s4vBK::I64,
                            2147483647)) goto c4x4v; else goto c4x4w;
       c4x4v: // global
           R2 = _s4vBK::I64;
           call GHC.Int.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c4x4w: // global
           R1 = _s4vBK::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.533392404 UTC

[section ""data" . GHC.Int.$fEnumInt32_$ctoEnum_closure" {
     GHC.Int.$fEnumInt32_$ctoEnum_closure:
         const GHC.Int.$fEnumInt32_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4x4J,
                       label: GHC.Int.$fEnumInt32_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x4J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x4R; else goto c4x4S;
       c4x4R: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x4S: // global
           I64[Sp - 8] = block_c4x4G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4x4X; else goto c4x4H;
       u4x4X: // global
           call _c4x4G(R1) args: 0, res: 0, upd: 0;
       c4x4H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x4G() //  [R1]
         { info_tbl: [(c4x4G,
                       label: block_c4x4G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x4G: // global
           I64[Sp] = block_c4x4M_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4x4M() //  [R1]
         { info_tbl: [(c4x4M,
                       label: block_c4x4M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x4M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x4W; else goto c4x4V;
       c4x4W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4x4V: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.542451981 UTC

[section ""data" . GHC.Int.$w$cenumFromTo1_closure" {
     GHC.Int.$w$cenumFromTo1_closure:
         const GHC.Int.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s4vC3_entry() //  [R1]
         { info_tbl: [(c4x5z,
                       label: sat_s4vC3_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x5z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4x5A; else goto c4x5B;
       c4x5A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4x5B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vBX::I64 = I64[R1 + 32];
           if (_s4vBX::I64 == I64[R1 + 24]) goto c4x5y; else goto c4x5x;
       c4x5y: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4x5x: // global
           R2 = _s4vBX::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4vBW_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vC0_entry() //  [R1]
         { info_tbl: [(c4x5N,
                       label: sat_s4vC0_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x5N: // global
           _s4vC0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4x5O; else goto c4x5P;
       c4x5P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x5R; else goto c4x5Q;
       c4x5R: // global
           HpAlloc = 16;
           goto c4x5O;
       c4x5O: // global
           R1 = _s4vC0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4x5Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vC0::P64;
           _s4vBX::I64 = I64[_s4vC0::P64 + 16];
           if (%MO_S_Lt_W64(_s4vBX::I64,
                            (-2147483648))) goto c4x5X; else goto c4x5M;
       c4x5M: // global
           if (%MO_S_Gt_W64(_s4vBX::I64,
                            2147483647)) goto c4x5X; else goto c4x61;
       c4x5X: // global
           Hp = Hp - 16;
           R2 = _s4vBX::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4x61: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vBX::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s4vBW_entry() //  [R1, R2]
         { info_tbl: [(c4x63,
                       label: go_s4vBW_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x63: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4x67; else goto c4x66;
       c4x67: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x66: // global
           _s4vBU::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vC3_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vBU::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vC0_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$w$cenumFromTo1_entry() //  [R2, R3]
         { info_tbl: [(c4x6b,
                       label: GHC.Int.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x6b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x6f; else goto c4x6e;
       c4x6f: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4x6e: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4x69; else goto c4x6a;
       c4x69: // global
           I64[Hp - 8] = go_s4vBW_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4vBW_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4x6a: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.554378997 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(c4x6R,
                       label: GHC.Int.$fEnumInt32_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x6R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4x6V; else goto c4x6W;
       c4x6V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4x6W: // global
           I64[Sp - 16] = block_c4x6O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4x74; else goto c4x6P;
       u4x74: // global
           call _c4x6O(R1) args: 0, res: 0, upd: 0;
       c4x6P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x6O() //  [R1]
         { info_tbl: [(c4x6O,
                       label: block_c4x6O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x6O: // global
           I64[Sp] = block_c4x6U_info;
           _s4vC7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vC7::I64;
           if (R1 & 7 != 0) goto u4x73; else goto c4x6Y;
       u4x73: // global
           call _c4x6U(R1) args: 0, res: 0, upd: 0;
       c4x6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x6U() //  [R1]
         { info_tbl: [(c4x6U,
                       label: block_c4x6U_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x6U: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.563888474 UTC

[section ""data" . GHC.Int.$wgo1_closure" {
     GHC.Int.$wgo1_closure:
         const GHC.Int.$wgo1_info;
         const 0;
 },
 sat_s4vCj_entry() //  [R1]
         { info_tbl: [(c4x7w,
                       label: sat_s4vCj_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x7w: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4x7x; else goto c4x7I;
       c4x7x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4x7I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vCe::I64 = I64[R1 + 16];
           if (_s4vCe::I64 != 2147483647) goto c4x7u; else goto c4x7v;
       c4x7u: // global
           I64[Sp - 24] = block_c4x7C_info;
           R2 = _s4vCe::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c4x7v: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4x7C() //  [R1, R2]
         { info_tbl: [(c4x7C,
                       label: block_c4x7C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x7C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4x7H; else goto c4x7G;
       c4x7H: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4x7G: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vCd_entry() //  [R1]
         { info_tbl: [(c4x7S,
                       label: sat_s4vCd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x7S: // global
           _s4vCd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4x7T; else goto c4x7U;
       c4x7U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x7W; else goto c4x7V;
       c4x7W: // global
           HpAlloc = 16;
           goto c4x7T;
       c4x7T: // global
           R1 = _s4vCd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4x7V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCd::P64;
           _s4vCa::I64 = I64[_s4vCd::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCa::I64,
                            (-2147483648))) goto c4x82; else goto c4x7R;
       c4x7R: // global
           if (%MO_S_Gt_W64(_s4vCa::I64,
                            2147483647)) goto c4x82; else goto c4x86;
       c4x82: // global
           Hp = Hp - 16;
           R2 = _s4vCa::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4x86: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCa::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo1_entry() //  [R2]
         { info_tbl: [(c4x87,
                       label: GHC.Int.$wgo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x87: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4x8b; else goto c4x8a;
       c4x8b: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x8a: // global
           I64[Hp - 40] = sat_s4vCj_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4vCd_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.574773202 UTC

[section ""data" . GHC.Int.$fEnumInt32_go_closure" {
     GHC.Int.$fEnumInt32_go_closure:
         const GHC.Int.$fEnumInt32_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_go_entry() //  [R2]
         { info_tbl: [(c4x8K,
                       label: GHC.Int.$fEnumInt32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x8K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x8L; else goto c4x8M;
       c4x8L: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x8M: // global
           I64[Sp - 8] = block_c4x8H_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4x8H() //  [R1, R2]
         { info_tbl: [(c4x8H,
                       label: block_c4x8H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x8H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4x8P; else goto c4x8O;
       c4x8P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4x8O: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.581546739 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFrom_closure" {
     GHC.Int.$fEnumInt32_$cenumFrom_closure:
         const GHC.Int.$fEnumInt32_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4x98,
                       label: GHC.Int.$fEnumInt32_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x98: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x99; else goto c4x9a;
       c4x99: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x9a: // global
           I64[Sp - 8] = block_c4x95_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4x9j; else goto c4x96;
       u4x9j: // global
           call _c4x95(R1) args: 0, res: 0, upd: 0;
       c4x96: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4x95() //  [R1]
         { info_tbl: [(c4x95,
                       label: block_c4x95_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4x95: // global
           _s4vCq::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4vCq::I64,
                            2147483647)) goto c4x9h; else goto c4x9i;
       c4x9h: // global
           R2 = _s4vCq::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_go_entry(R2) args: 8, res: 0, upd: 8;
       c4x9i: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.59236911 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo1_closure" {
     GHC.Int.$w$cenumFromThenTo1_closure:
         const GHC.Int.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s4vCJ_entry() //  [R1]
         { info_tbl: [(c4xa4,
                       label: sat_s4vCJ_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xa4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xa5; else goto c4xa6;
       c4xa5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xa6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4vCC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vCH_entry() //  [R1]
         { info_tbl: [(c4xag,
                       label: sat_s4vCH_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xag: // global
           _s4vCH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xah; else goto c4xai;
       c4xai: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xak; else goto c4xaj;
       c4xak: // global
           HpAlloc = 16;
           goto c4xah;
       c4xah: // global
           R1 = _s4vCH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xaj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCH::P64;
           _s4vCD::I64 = I64[_s4vCH::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCD::I64,
                            (-2147483648))) goto c4xaq; else goto c4xaf;
       c4xaf: // global
           if (%MO_S_Gt_W64(_s4vCD::I64,
                            2147483647)) goto c4xaq; else goto c4xau;
       c4xaq: // global
           Hp = Hp - 16;
           R2 = _s4vCD::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xau: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCD::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vCM_entry() //  [R1]
         { info_tbl: [(c4xaF,
                       label: sat_s4vCM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xaF: // global
           _s4vCM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xaG; else goto c4xaH;
       c4xaH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xaJ; else goto c4xaI;
       c4xaJ: // global
           HpAlloc = 16;
           goto c4xaG;
       c4xaG: // global
           R1 = _s4vCM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xaI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCM::P64;
           _s4vCD::I64 = I64[_s4vCM::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCD::I64,
                            (-2147483648))) goto c4xaP; else goto c4xaE;
       c4xaE: // global
           if (%MO_S_Gt_W64(_s4vCD::I64,
                            2147483647)) goto c4xaP; else goto c4xaT;
       c4xaP: // global
           Hp = Hp - 16;
           R2 = _s4vCD::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xaT: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCD::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_s4vCC_entry() //  [R1, R2]
         { info_tbl: [(c4xaX,
                       label: go_dn_s4vCC_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xaX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4xb1; else goto c4xb0;
       c4xb1: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xb0: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4xaV; else goto c4xaW;
       c4xaV: // global
           _s4vCA::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vCJ_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vCA::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vCH_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xaW: // global
           I64[Hp - 80] = sat_s4vCM_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4xb3::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4xb3::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4vCN_entry() //  [R1]
         { info_tbl: [(c4xb4,
                       label: sat_s4vCN_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xb4: // global
           _s4vCN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xb5; else goto c4xb6;
       c4xb6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4xb8; else goto c4xb7;
       c4xb8: // global
           HpAlloc = 24;
           goto c4xb5;
       c4xb5: // global
           R1 = _s4vCN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xb7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCN::P64;
           _s4vCt::I64 = I64[_s4vCN::P64 + 24];
           _s4vCA::I64 = _s4vCt::I64 - I64[_s4vCN::P64 + 16];
           _s4vCB::I64 = I64[_s4vCN::P64 + 32] - _s4vCA::I64;
           I64[Hp - 16] = go_dn_s4vCC_info;
           I64[Hp - 8] = _s4vCA::I64;
           I64[Hp] = _s4vCB::I64;
           R2 = _s4vCt::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4vCC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vCz_entry() //  [R1]
         { info_tbl: [(c4xbi,
                       label: sat_s4vCz_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xbi: // global
           _s4vCz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xbj; else goto c4xbk;
       c4xbk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xbm; else goto c4xbl;
       c4xbm: // global
           HpAlloc = 16;
           goto c4xbj;
       c4xbj: // global
           R1 = _s4vCz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xbl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCz::P64;
           _s4vCs::I64 = I64[_s4vCz::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCs::I64,
                            (-2147483648))) goto c4xbs; else goto c4xbh;
       c4xbh: // global
           if (%MO_S_Gt_W64(_s4vCs::I64,
                            2147483647)) goto c4xbs; else goto c4xbw;
       c4xbs: // global
           Hp = Hp - 16;
           R2 = _s4vCs::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xbw: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCs::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vCR_entry() //  [R1]
         { info_tbl: [(c4xbK,
                       label: sat_s4vCR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xbK: // global
           _s4vCR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xbL; else goto c4xbM;
       c4xbM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xbO; else goto c4xbN;
       c4xbO: // global
           HpAlloc = 16;
           goto c4xbL;
       c4xbL: // global
           R1 = _s4vCR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xbN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCR::P64;
           _s4vCs::I64 = I64[_s4vCR::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCs::I64,
                            (-2147483648))) goto c4xbU; else goto c4xbJ;
       c4xbJ: // global
           if (%MO_S_Gt_W64(_s4vCs::I64,
                            2147483647)) goto c4xbU; else goto c4xbY;
       c4xbU: // global
           Hp = Hp - 16;
           R2 = _s4vCs::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xbY: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCs::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vD5_entry() //  [R1]
         { info_tbl: [(c4xcr,
                       label: sat_s4vD5_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xcr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xcs; else goto c4xct;
       c4xcs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xct: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4vCY_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vD3_entry() //  [R1]
         { info_tbl: [(c4xcD,
                       label: sat_s4vD3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xcD: // global
           _s4vD3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xcE; else goto c4xcF;
       c4xcF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xcH; else goto c4xcG;
       c4xcH: // global
           HpAlloc = 16;
           goto c4xcE;
       c4xcE: // global
           R1 = _s4vD3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xcG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vD3::P64;
           _s4vCZ::I64 = I64[_s4vD3::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCZ::I64,
                            (-2147483648))) goto c4xcN; else goto c4xcC;
       c4xcC: // global
           if (%MO_S_Gt_W64(_s4vCZ::I64,
                            2147483647)) goto c4xcN; else goto c4xcR;
       c4xcN: // global
           Hp = Hp - 16;
           R2 = _s4vCZ::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xcR: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCZ::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vD8_entry() //  [R1]
         { info_tbl: [(c4xd2,
                       label: sat_s4vD8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xd2: // global
           _s4vD8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xd3; else goto c4xd4;
       c4xd4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xd6; else goto c4xd5;
       c4xd6: // global
           HpAlloc = 16;
           goto c4xd3;
       c4xd3: // global
           R1 = _s4vD8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xd5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vD8::P64;
           _s4vCZ::I64 = I64[_s4vD8::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCZ::I64,
                            (-2147483648))) goto c4xdc; else goto c4xd1;
       c4xd1: // global
           if (%MO_S_Gt_W64(_s4vCZ::I64,
                            2147483647)) goto c4xdc; else goto c4xdg;
       c4xdc: // global
           Hp = Hp - 16;
           R2 = _s4vCZ::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xdg: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCZ::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s4vCY_entry() //  [R1, R2]
         { info_tbl: [(c4xdk,
                       label: go_up_s4vCY_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xdk: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4xdo; else goto c4xdn;
       c4xdo: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xdn: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4xdi; else goto c4xdj;
       c4xdi: // global
           _s4vCW::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vD5_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vCW::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vD3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xdj: // global
           I64[Hp - 80] = sat_s4vD8_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4xdq::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4xdq::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4vD9_entry() //  [R1]
         { info_tbl: [(c4xdr,
                       label: sat_s4vD9_info
                       rep:HeapRep 3 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xdr: // global
           _s4vD9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xds; else goto c4xdt;
       c4xdt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4xdv; else goto c4xdu;
       c4xdv: // global
           HpAlloc = 24;
           goto c4xds;
       c4xds: // global
           R1 = _s4vD9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xdu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vD9::P64;
           _s4vCt::I64 = I64[_s4vD9::P64 + 24];
           _s4vCW::I64 = _s4vCt::I64 - I64[_s4vD9::P64 + 16];
           _s4vCX::I64 = I64[_s4vD9::P64 + 32] - _s4vCW::I64;
           I64[Hp - 16] = go_up_s4vCY_info;
           I64[Hp - 8] = _s4vCW::I64;
           I64[Hp] = _s4vCX::I64;
           R2 = _s4vCt::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4vCY_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vCV_entry() //  [R1]
         { info_tbl: [(c4xdF,
                       label: sat_s4vCV_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xdF: // global
           _s4vCV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xdG; else goto c4xdH;
       c4xdH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xdJ; else goto c4xdI;
       c4xdJ: // global
           HpAlloc = 16;
           goto c4xdG;
       c4xdG: // global
           R1 = _s4vCV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xdI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCV::P64;
           _s4vCs::I64 = I64[_s4vCV::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCs::I64,
                            (-2147483648))) goto c4xdP; else goto c4xdE;
       c4xdE: // global
           if (%MO_S_Gt_W64(_s4vCs::I64,
                            2147483647)) goto c4xdP; else goto c4xdT;
       c4xdP: // global
           Hp = Hp - 16;
           R2 = _s4vCs::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xdT: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCs::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vDd_entry() //  [R1]
         { info_tbl: [(c4xe7,
                       label: sat_s4vDd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xe7: // global
           _s4vDd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xe8; else goto c4xe9;
       c4xe9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xeb; else goto c4xea;
       c4xeb: // global
           HpAlloc = 16;
           goto c4xe8;
       c4xe8: // global
           R1 = _s4vDd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xea: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vDd::P64;
           _s4vCs::I64 = I64[_s4vDd::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCs::I64,
                            (-2147483648))) goto c4xeh; else goto c4xe6;
       c4xe6: // global
           if (%MO_S_Gt_W64(_s4vCs::I64,
                            2147483647)) goto c4xeh; else goto c4xel;
       c4xeh: // global
           Hp = Hp - 16;
           R2 = _s4vCs::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xel: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCs::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4xep,
                       label: GHC.Int.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xep: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4xet; else goto c4xes;
       c4xet: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xes: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4xen; else goto c4xeo;
       c4xen: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4xew; else goto c4xeB;
       c4xew: // global
           I64[Hp - 80] = sat_s4vCN_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vCz_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xeB: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4xeI; else goto c4xez;
       c4xez: // global
           I64[Hp - 80] = sat_s4vCR_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4xex::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4xex::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xeo: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4xeE; else goto c4xeJ;
       c4xeE: // global
           I64[Hp - 80] = sat_s4vD9_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vCV_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xeJ: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4xeI; else goto c4xeH;
       c4xeI: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xeH: // global
           I64[Hp - 80] = sat_s4vDd_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4xeF::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4xeF::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.63551718 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c4xhd,
                       label: GHC.Int.$fEnumInt32_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xhd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xhm; else goto c4xhn;
       c4xhm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xhn: // global
           I64[Sp - 24] = block_c4xha_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4xhw; else goto c4xhb;
       u4xhw: // global
           call _c4xha(R1) args: 0, res: 0, upd: 0;
       c4xhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xha() //  [R1]
         { info_tbl: [(c4xha,
                       label: block_c4xha_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xha: // global
           I64[Sp] = block_c4xhg_info;
           _s4vDi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vDi::I64;
           if (R1 & 7 != 0) goto u4xhv; else goto c4xhh;
       u4xhv: // global
           call _c4xhg(R1) args: 0, res: 0, upd: 0;
       c4xhh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xhg() //  [R1]
         { info_tbl: [(c4xhg,
                       label: block_c4xhg_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xhg: // global
           I64[Sp] = block_c4xhl_info;
           _s4vDk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vDk::I64;
           if (R1 & 7 != 0) goto u4xhx; else goto c4xhq;
       u4xhx: // global
           call _c4xhl(R1) args: 0, res: 0, upd: 0;
       c4xhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xhl() //  [R1]
         { info_tbl: [(c4xhl,
                       label: block_c4xhl_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xhl: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.645821174 UTC

[section ""data" . GHC.Int.$fEnumInt32_closure" {
     GHC.Int.$fEnumInt32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt32_$csucc_closure+1;
         const GHC.Int.$fEnumInt32_$cpred_closure+1;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt32_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4xhW,
                       label: GHC.Int.$fEnumInt32_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xhW: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt32_closure+1;
           R2 = GHC.Int.$fEnumInt32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.650577984 UTC

[section ""cstring" . GHC.Int.$tcInt6_bytes" {
     GHC.Int.$tcInt6_bytes:
         I8[] [73,110,116,54,52]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.652593417 UTC

[section ""data" . GHC.Int.$fEnumInt5_closure" {
     GHC.Int.$fEnumInt5_closure:
         const GHC.Int.$fEnumInt5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt5_entry() //  [R1]
         { info_tbl: [(c4xid,
                       label: GHC.Int.$fEnumInt5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xid: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xie; else goto c4xif;
       c4xie: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xif: // global
           (_c4xi8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4xi8::I64 == 0) goto c4xia; else goto c4xi9;
       c4xia: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4xi9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4xi8::I64;
           I64[Sp - 24] = block_c4xib_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4xib() //  [R1]
         { info_tbl: [(c4xib,
                       label: block_c4xib_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xib: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.65860241 UTC

[section ""data" . GHC.Int.$fEnumInt6_closure" {
     GHC.Int.$fEnumInt6_closure:
         const GHC.Int.$fEnumInt6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt6_entry() //  [R1]
         { info_tbl: [(c4xiD,
                       label: GHC.Int.$fEnumInt6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xiD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xiE; else goto c4xiF;
       c4xiE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xiF: // global
           (_c4xiy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4xiy::I64 == 0) goto c4xiA; else goto c4xiz;
       c4xiA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4xiz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4xiy::I64;
           I64[Sp - 24] = block_c4xiB_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4xiB() //  [R1]
         { info_tbl: [(c4xiB,
                       label: block_c4xiB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xiB: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.665104348 UTC

[section ""data" . GHC.Int.neInt64_closure" {
     GHC.Int.neInt64_closure:
         const GHC.Int.neInt64_info;
 },
 GHC.Int.neInt64_entry() //  [R2, R3]
         { info_tbl: [(c4xj2,
                       label: GHC.Int.neInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xj2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xj6; else goto c4xj7;
       c4xj6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xj7: // global
           I64[Sp - 16] = block_c4xiZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xjg; else goto c4xj0;
       u4xjg: // global
           call _c4xiZ(R1) args: 0, res: 0, upd: 0;
       c4xj0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xiZ() //  [R1]
         { info_tbl: [(c4xiZ,
                       label: block_c4xiZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xiZ: // global
           I64[Sp] = block_c4xj5_info;
           _s4vDs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vDs::I64;
           if (R1 & 7 != 0) goto u4xjf; else goto c4xj9;
       u4xjf: // global
           call _c4xj5(R1) args: 0, res: 0, upd: 0;
       c4xj9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xj5() //  [R1]
         { info_tbl: [(c4xj5,
                       label: block_c4xj5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xj5: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.672876637 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cminBound_closure" {
     GHC.Int.$fBoundedInt64_$cminBound_closure:
         const GHC.Int.I64#_con_info;
         const (-9223372036854775808);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.675407056 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cpred_closure" {
     GHC.Int.$fEnumInt64_$cpred_closure:
         const GHC.Int.$fEnumInt64_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cpred_entry() //  [R2]
         { info_tbl: [(c4xjJ,
                       label: GHC.Int.$fEnumInt64_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xjJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xjK; else goto c4xjL;
       c4xjK: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xjL: // global
           I64[Sp - 8] = block_c4xjG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xk0; else goto c4xjH;
       u4xk0: // global
           call _c4xjG(R1) args: 0, res: 0, upd: 0;
       c4xjH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xjG() //  [R1]
         { info_tbl: [(c4xjG,
                       label: block_c4xjG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xjG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xjQ; else goto c4xjP;
       c4xjQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xjP: // global
           _s4vDz::I64 = I64[R1 + 7];
           if (_s4vDz::I64 != (-9223372036854775808)) goto c4xjY; else goto c4xjZ;
       c4xjY: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vDz::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xjZ: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.681485758 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt64_$cmaxBound_closure:
         const GHC.Int.I64#_con_info;
         const 9223372036854775807;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.683316048 UTC

[section ""data" . GHC.Int.$fBoundedInt64_closure" {
     GHC.Int.$fBoundedInt64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt64_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.689226506 UTC

[section ""data" . GHC.Int.$fEnumInt64_$csucc_closure" {
     GHC.Int.$fEnumInt64_$csucc_closure:
         const GHC.Int.$fEnumInt64_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$csucc_entry() //  [R2]
         { info_tbl: [(c4xkp,
                       label: GHC.Int.$fEnumInt64_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xkp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xkq; else goto c4xkr;
       c4xkq: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xkr: // global
           I64[Sp - 8] = block_c4xkm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xkG; else goto c4xkn;
       u4xkG: // global
           call _c4xkm(R1) args: 0, res: 0, upd: 0;
       c4xkn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xkm() //  [R1]
         { info_tbl: [(c4xkm,
                       label: block_c4xkm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xkm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xkw; else goto c4xkv;
       c4xkw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xkv: // global
           _s4vDE::I64 = I64[R1 + 7];
           if (_s4vDE::I64 != 9223372036854775807) goto c4xkE; else goto c4xkF;
       c4xkE: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vDE::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xkF: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.696876937 UTC

[section ""data" . GHC.Int.$wgo2_closure" {
     GHC.Int.$wgo2_closure:
         const GHC.Int.$wgo2_info;
 },
 sat_s4vDN_entry() //  [R1]
         { info_tbl: [(c4xl8,
                       label: sat_s4vDN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xl8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xl9; else goto c4xlk;
       c4xl9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xlk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vDI::I64 = I64[R1 + 16];
           if (_s4vDI::I64 != 9223372036854775807) goto c4xl6; else goto c4xl7;
       c4xl6: // global
           I64[Sp - 24] = block_c4xle_info;
           R2 = _s4vDI::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c4xl7: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 _c4xle() //  [R1, R2]
         { info_tbl: [(c4xle,
                       label: block_c4xle_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xle: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4xlj; else goto c4xli;
       c4xlj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4xli: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$wgo2_entry() //  [R2]
         { info_tbl: [(c4xlm,
                       label: GHC.Int.$wgo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xlm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4xlq; else goto c4xlp;
       c4xlq: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Int.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xlp: // global
           I64[Hp - 32] = sat_s4vDN_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R2 = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.705913832 UTC

[section ""data" . GHC.Int.$fEnumInt64_go_closure" {
     GHC.Int.$fEnumInt64_go_closure:
         const GHC.Int.$fEnumInt64_go_info;
 },
 GHC.Int.$fEnumInt64_go_entry() //  [R2]
         { info_tbl: [(c4xlT,
                       label: GHC.Int.$fEnumInt64_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xlT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xlU; else goto c4xlV;
       c4xlU: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xlV: // global
           I64[Sp - 8] = block_c4xlQ_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4xlQ() //  [R1, R2]
         { info_tbl: [(c4xlQ,
                       label: block_c4xlQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xlQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4xlY; else goto c4xlX;
       c4xlY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4xlX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.712939481 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFrom_closure" {
     GHC.Int.$fEnumInt64_$cenumFrom_closure:
         const GHC.Int.$fEnumInt64_$cenumFrom_info;
 },
 GHC.Int.$fEnumInt64_$cenumFrom_entry() //  [R2]
         { info_tbl: [(c4xmh,
                       label: GHC.Int.$fEnumInt64_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xmh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xmi; else goto c4xmj;
       c4xmi: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xmj: // global
           I64[Sp - 8] = block_c4xme_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xmn; else goto c4xmf;
       u4xmn: // global
           call _c4xme(R1) args: 0, res: 0, upd: 0;
       c4xmf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xme() //  [R1]
         { info_tbl: [(c4xme,
                       label: block_c4xme_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xme: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.718428806 UTC

[section ""data" . GHC.Int.$fEnumInt64_closure" {
     GHC.Int.$fEnumInt64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt64_$csucc_closure+1;
         const GHC.Int.$fEnumInt64_$cpred_closure+1;
         const GHC.Int.$fEnumInt64_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt64_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4xmC,
                       label: GHC.Int.$fEnumInt64_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xmC: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt64_closure+1;
           R2 = GHC.Int.$fEnumInt64_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.723331674 UTC

[section ""data" . GHC.Int.$fNumInt8_$cfromInteger_closure" {
     GHC.Int.$fNumInt8_$cfromInteger_closure:
         const GHC.Int.$fNumInt8_$cfromInteger_info;
 },
 GHC.Int.$fNumInt8_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4xmQ,
                       label: GHC.Int.$fNumInt8_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xmQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xmX; else goto c4xmY;
       c4xmX: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xmY: // global
           I64[Sp - 8] = block_c4xmO_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4xmO() //  [R1]
         { info_tbl: [(c4xmO,
                       label: block_c4xmO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xmO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xn1; else goto c4xn0;
       c4xn1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4xn0: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.729776142 UTC

[section ""data" . GHC.Int.$fNumInt8_$cnegate_closure" {
     GHC.Int.$fNumInt8_$cnegate_closure:
         const GHC.Int.$fNumInt8_$cnegate_info;
 },
 GHC.Int.$fNumInt8_$cnegate_entry() //  [R2]
         { info_tbl: [(c4xnm,
                       label: GHC.Int.$fNumInt8_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xnm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xnw; else goto c4xnx;
       c4xnw: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xnx: // global
           I64[Sp - 8] = block_c4xnj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xnB; else goto c4xnk;
       u4xnB: // global
           call _c4xnj(R1) args: 0, res: 0, upd: 0;
       c4xnk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xnj() //  [R1]
         { info_tbl: [(c4xnj,
                       label: block_c4xnj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xnj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xnA; else goto c4xnz;
       c4xnA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xnz: // global
           _s4vE2::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vE2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.73685217 UTC

[section ""data" . GHC.Int.$fNumInt8_$c*_closure" {
     GHC.Int.$fNumInt8_$c*_closure:
         const GHC.Int.$fNumInt8_$c*_info;
 },
 GHC.Int.$fNumInt8_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4xnW,
                       label: GHC.Int.$fNumInt8_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xnW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xob; else goto c4xoc;
       c4xob: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xoc: // global
           I64[Sp - 16] = block_c4xnT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xoi; else goto c4xnU;
       u4xoi: // global
           call _c4xnT(R1) args: 0, res: 0, upd: 0;
       c4xnU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xnT() //  [R1]
         { info_tbl: [(c4xnT,
                       label: block_c4xnT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xnT: // global
           I64[Sp] = block_c4xnZ_info;
           _s4vE6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vE6::I64;
           if (R1 & 7 != 0) goto u4xoh; else goto c4xo0;
       u4xoh: // global
           call _c4xnZ(R1) args: 0, res: 0, upd: 0;
       c4xo0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xnZ() //  [R1]
         { info_tbl: [(c4xnZ,
                       label: block_c4xnZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xnZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xog; else goto c4xof;
       c4xog: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xof: // global
           _s4vEa::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vEa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.745236431 UTC

[section ""data" . GHC.Int.$fNumInt8_$c-_closure" {
     GHC.Int.$fNumInt8_$c-_closure:
         const GHC.Int.$fNumInt8_$c-_info;
 },
 GHC.Int.$fNumInt8_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4xoK,
                       label: GHC.Int.$fNumInt8_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xoK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xoZ; else goto c4xp0;
       c4xoZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xp0: // global
           I64[Sp - 16] = block_c4xoH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xp6; else goto c4xoI;
       u4xp6: // global
           call _c4xoH(R1) args: 0, res: 0, upd: 0;
       c4xoI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xoH() //  [R1]
         { info_tbl: [(c4xoH,
                       label: block_c4xoH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xoH: // global
           I64[Sp] = block_c4xoN_info;
           _s4vEe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vEe::I64;
           if (R1 & 7 != 0) goto u4xp5; else goto c4xoO;
       u4xp5: // global
           call _c4xoN(R1) args: 0, res: 0, upd: 0;
       c4xoO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xoN() //  [R1]
         { info_tbl: [(c4xoN,
                       label: block_c4xoN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xoN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xp4; else goto c4xp3;
       c4xp4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xp3: // global
           _s4vEi::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vEi::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.754089701 UTC

[section ""data" . GHC.Int.$fNumInt8_$c+_closure" {
     GHC.Int.$fNumInt8_$c+_closure:
         const GHC.Int.$fNumInt8_$c+_info;
 },
 GHC.Int.$fNumInt8_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4xpy,
                       label: GHC.Int.$fNumInt8_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xpy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xpN; else goto c4xpO;
       c4xpN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xpO: // global
           I64[Sp - 16] = block_c4xpv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xpU; else goto c4xpw;
       u4xpU: // global
           call _c4xpv(R1) args: 0, res: 0, upd: 0;
       c4xpw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xpv() //  [R1]
         { info_tbl: [(c4xpv,
                       label: block_c4xpv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xpv: // global
           I64[Sp] = block_c4xpB_info;
           _s4vEm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vEm::I64;
           if (R1 & 7 != 0) goto u4xpT; else goto c4xpC;
       u4xpT: // global
           call _c4xpB(R1) args: 0, res: 0, upd: 0;
       c4xpC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xpB() //  [R1]
         { info_tbl: [(c4xpB,
                       label: block_c4xpB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xpB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xpS; else goto c4xpR;
       c4xpS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xpR: // global
           _s4vEq::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vEq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.762433782 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt8_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt8_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt8_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4xqm,
                       label: GHC.Int.$fIntegralInt8_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xqm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xqn; else goto c4xqo;
       c4xqn: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xqo: // global
           I64[Sp - 8] = block_c4xqj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xqs; else goto c4xqk;
       u4xqs: // global
           call _c4xqj(R1) args: 0, res: 0, upd: 0;
       c4xqk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xqj() //  [R1]
         { info_tbl: [(c4xqj,
                       label: block_c4xqj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xqj: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.768189805 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cpopCount_closure" {
     GHC.Int.$fBitsInt8_$cpopCount_closure:
         const GHC.Int.$fBitsInt8_$cpopCount_info;
 },
 GHC.Int.$fBitsInt8_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4xqK,
                       label: GHC.Int.$fBitsInt8_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xqK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xqY; else goto c4xqZ;
       c4xqY: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xqZ: // global
           I64[Sp - 8] = block_c4xqH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xr3; else goto c4xqI;
       u4xr3: // global
           call _c4xqH(R1) args: 0, res: 0, upd: 0;
       c4xqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xqH() //  [R1]
         { info_tbl: [(c4xqH,
                       label: block_c4xqH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xqH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xr2; else goto c4xr1;
       c4xr2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xr1: // global
           (_c4xqQ::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xqQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.775250392 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4xrn,
                       label: GHC.Int.$fBitsInt8_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xrn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xrz; else goto c4xrA;
       c4xrz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xrA: // global
           I64[Sp - 16] = block_c4xrk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xrG; else goto c4xrl;
       u4xrG: // global
           call _c4xrk(R1) args: 0, res: 0, upd: 0;
       c4xrl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xrk() //  [R1]
         { info_tbl: [(c4xrk,
                       label: block_c4xrk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xrk: // global
           I64[Sp] = block_c4xrq_info;
           _s4vED::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vED::I64;
           if (R1 & 7 != 0) goto u4xrF; else goto c4xrr;
       u4xrF: // global
           call _c4xrq(R1) args: 0, res: 0, upd: 0;
       c4xrr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xrq() //  [R1]
         { info_tbl: [(c4xrq,
                       label: block_c4xrq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xrq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xrE; else goto c4xrD;
       c4xrE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xrD: // global
           _s4vEG::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vEG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.783142056 UTC

[section ""data" . GHC.Int.$fBitsInt13_closure" {
     GHC.Int.$fBitsInt13_closure:
         const GHC.Int.I8#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.784871839 UTC

[section ""data" . GHC.Int.$fNumInt9_closure" {
     GHC.Int.$fNumInt9_closure:
         const GHC.Int.I8#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.787317756 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftR_closure" {
     GHC.Int.$fBitsInt8_$cshiftR_closure:
         const GHC.Int.$fBitsInt8_$cshiftR_info;
 },
 GHC.Int.$fBitsInt8_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4xs8,
                       label: GHC.Int.$fBitsInt8_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xs8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xsc; else goto c4xsd;
       c4xsc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xsd: // global
           I64[Sp - 16] = block_c4xs5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xsD; else goto c4xs6;
       u4xsD: // global
           call _c4xs5(R1) args: 0, res: 0, upd: 0;
       c4xs6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xs5() //  [R1]
         { info_tbl: [(c4xs5,
                       label: block_c4xs5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xs5: // global
           I64[Sp] = block_c4xsb_info;
           _s4vEK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vEK::I64;
           if (R1 & 7 != 0) goto u4xsC; else goto c4xsf;
       u4xsC: // global
           call _c4xsb(R1) args: 0, res: 0, upd: 0;
       c4xsf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xsb() //  [R1]
         { info_tbl: [(c4xsb,
                       label: block_c4xsb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xsb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xsl; else goto c4xsk;
       c4xsl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xsk: // global
           _s4vEK::I64 = I64[Sp + 8];
           _s4vEM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vEM::I64, 64)) goto c4xsu; else goto c4xsB;
       c4xsu: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vEK::I64, _s4vEM::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xsB: // global
           if (%MO_S_Ge_W64(_s4vEK::I64, 0)) goto c4xsz; else goto c4xsA;
       c4xsz: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xsA: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.797006476 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4xt5,
                       label: GHC.Int.$fBitsInt8_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xt5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xtk; else goto c4xtl;
       c4xtk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xtl: // global
           I64[Sp - 16] = block_c4xt2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xtr; else goto c4xt3;
       u4xtr: // global
           call _c4xt2(R1) args: 0, res: 0, upd: 0;
       c4xt3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xt2() //  [R1]
         { info_tbl: [(c4xt2,
                       label: block_c4xt2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xt2: // global
           I64[Sp] = block_c4xt8_info;
           _s4vET::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vET::I64;
           if (R1 & 7 != 0) goto u4xtq; else goto c4xt9;
       u4xtq: // global
           call _c4xt8(R1) args: 0, res: 0, upd: 0;
       c4xt9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xt8() //  [R1]
         { info_tbl: [(c4xt8,
                       label: block_c4xt8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xt8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xtp; else goto c4xto;
       c4xtp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xto: // global
           _s4vEX::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vEX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.805443866 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftL_closure" {
     GHC.Int.$fBitsInt8_$cshiftL_closure:
         const GHC.Int.$fBitsInt8_$cshiftL_info;
 },
 GHC.Int.$fBitsInt8_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4xtS,
                       label: GHC.Int.$fBitsInt8_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xtS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xtW; else goto c4xtX;
       c4xtW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xtX: // global
           I64[Sp - 16] = block_c4xtP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xuk; else goto c4xtQ;
       u4xuk: // global
           call _c4xtP(R1) args: 0, res: 0, upd: 0;
       c4xtQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xtP() //  [R1]
         { info_tbl: [(c4xtP,
                       label: block_c4xtP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xtP: // global
           I64[Sp] = block_c4xtV_info;
           _s4vF1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vF1::I64;
           if (R1 & 7 != 0) goto u4xuj; else goto c4xtZ;
       u4xuj: // global
           call _c4xtV(R1) args: 0, res: 0, upd: 0;
       c4xtZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xtV() //  [R1]
         { info_tbl: [(c4xtV,
                       label: block_c4xtV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xtV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xu5; else goto c4xu4;
       c4xu5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xu4: // global
           _s4vF3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vF3::I64, 64)) goto c4xuh; else goto c4xui;
       c4xuh: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << _s4vF3::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xui: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.814535521 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cisSigned_closure" {
     GHC.Int.$fBitsInt8_$cisSigned_closure:
         const GHC.Int.$fBitsInt8_$cisSigned_info;
 },
 GHC.Int.$fBitsInt8_$cisSigned_entry() //  []
         { info_tbl: [(c4xuK,
                       label: GHC.Int.$fBitsInt8_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xuK: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.818827858 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotate_closure" {
     GHC.Int.$fBitsInt8_$crotate_closure:
         const GHC.Int.$fBitsInt8_$crotate_info;
 },
 GHC.Int.$fBitsInt8_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4xv0,
                       label: GHC.Int.$fBitsInt8_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xv0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xv4; else goto c4xv5;
       c4xv4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xv5: // global
           I64[Sp - 16] = block_c4xuX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xw1; else goto c4xuY;
       u4xw1: // global
           call _c4xuX(R1) args: 0, res: 0, upd: 0;
       c4xuY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xuX() //  [R1]
         { info_tbl: [(c4xuX,
                       label: block_c4xuX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xuX: // global
           I64[Sp - 8] = block_c4xv3_info;
           _s4vFa::P64 = R1;
           _s4vFb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vFb::I64;
           P64[Sp + 8] = _s4vFa::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xw0; else goto c4xv7;
       u4xw0: // global
           call _c4xv3(R1) args: 0, res: 0, upd: 0;
       c4xv7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xv3() //  [R1]
         { info_tbl: [(c4xv3,
                       label: block_c4xv3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xv3: // global
           _s4vFg::I64 = I64[R1 + 7] & 7;
           if (_s4vFg::I64 != 0) goto u4xvY; else goto c4xvU;
       u4xvY: // global
           I64[Sp + 16] = _s4vFg::I64;
           Sp = Sp + 8;
           call _c4xvm() args: 0, res: 0, upd: 0;
       c4xvU: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4xvm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xvm: // global
           Hp = Hp + 16;
           _s4vFg::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4xvR; else goto c4xvQ;
       c4xvR: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4xvl_info;
           R1 = _s4vFg::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4xvQ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4vFh::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4vFh::I64 << _s4vFg::I64) | (_s4vFh::I64 >> 8 - _s4vFg::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4xvl() //  [R1]
         { info_tbl: [(c4xvl,
                       label: block_c4xvl_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xvl: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4xvm() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.831086671 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshift_closure" {
     GHC.Int.$fBitsInt8_$cshift_closure:
         const GHC.Int.$fBitsInt8_$cshift_info;
 },
 GHC.Int.$fBitsInt8_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4xwI,
                       label: GHC.Int.$fBitsInt8_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xwI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xwM; else goto c4xwN;
       c4xwM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xwN: // global
           I64[Sp - 16] = block_c4xwF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xxA; else goto c4xwG;
       u4xxA: // global
           call _c4xwF(R1) args: 0, res: 0, upd: 0;
       c4xwG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xwF() //  [R1]
         { info_tbl: [(c4xwF,
                       label: block_c4xwF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xwF: // global
           I64[Sp] = block_c4xwL_info;
           _s4vFs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vFs::I64;
           if (R1 & 7 != 0) goto u4xxz; else goto c4xwP;
       u4xxz: // global
           call _c4xwL(R1) args: 0, res: 0, upd: 0;
       c4xwP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xwL() //  [R1]
         { info_tbl: [(c4xwL,
                       label: block_c4xwL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xwL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xwV; else goto c4xwU;
       c4xwV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xwU: // global
           _s4vFs::I64 = I64[Sp + 8];
           _s4vFu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vFu::I64, 0)) goto c4xxj; else goto c4xxy;
       c4xxj: // global
           _s4vFw::I64 = -_s4vFu::I64;
           if (%MO_S_Lt_W64(_s4vFw::I64, 64)) goto c4xxa; else goto c4xxh;
       c4xxa: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vFs::I64, _s4vFw::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xxh: // global
           if (%MO_S_Ge_W64(_s4vFs::I64, 0)) goto c4xxx; else goto c4xxg;
       c4xxg: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xxy: // global
           if (%MO_S_Ge_W64(_s4vFu::I64, 64)) goto c4xxx; else goto c4xxw;
       c4xxx: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xxw: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vFs::I64 << _s4vFu::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.841983574 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplement_closure" {
     GHC.Int.$fBitsInt8_$ccomplement_closure:
         const GHC.Int.$fBitsInt8_$ccomplement_info;
 },
 GHC.Int.$fBitsInt8_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4xy7,
                       label: GHC.Int.$fBitsInt8_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xy7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xyk; else goto c4xyl;
       c4xyk: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xyl: // global
           I64[Sp - 8] = block_c4xy4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xyp; else goto c4xy5;
       u4xyp: // global
           call _c4xy4(R1) args: 0, res: 0, upd: 0;
       c4xy5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xy4() //  [R1]
         { info_tbl: [(c4xy4,
                       label: block_c4xy4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xy4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xyo; else goto c4xyn;
       c4xyo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xyn: // global
           _s4vFI::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vFI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.849184299 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cxor_closure" {
     GHC.Int.$fBitsInt8_$cxor_closure:
         const GHC.Int.$fBitsInt8_$cxor_info;
 },
 GHC.Int.$fBitsInt8_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4xyJ,
                       label: GHC.Int.$fBitsInt8_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xyJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xz4; else goto c4xz5;
       c4xz4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xz5: // global
           I64[Sp - 16] = block_c4xyG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xzb; else goto c4xyH;
       u4xzb: // global
           call _c4xyG(R1) args: 0, res: 0, upd: 0;
       c4xyH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xyG() //  [R1]
         { info_tbl: [(c4xyG,
                       label: block_c4xyG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xyG: // global
           I64[Sp] = block_c4xyM_info;
           _s4vFM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vFM::I64;
           if (R1 & 7 != 0) goto u4xza; else goto c4xyN;
       u4xza: // global
           call _c4xyM(R1) args: 0, res: 0, upd: 0;
       c4xyN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xyM() //  [R1]
         { info_tbl: [(c4xyM,
                       label: block_c4xyM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xyM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xz9; else goto c4xz8;
       c4xz9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xz8: // global
           _s4vFS::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vFS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.858854179 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.|._closure" {
     GHC.Int.$fBitsInt8_$c.|._closure:
         const GHC.Int.$fBitsInt8_$c.|._info;
 },
 GHC.Int.$fBitsInt8_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4xzC,
                       label: GHC.Int.$fBitsInt8_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xzC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xzX; else goto c4xzY;
       c4xzX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xzY: // global
           I64[Sp - 16] = block_c4xzz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xA4; else goto c4xzA;
       u4xA4: // global
           call _c4xzz(R1) args: 0, res: 0, upd: 0;
       c4xzA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xzz() //  [R1]
         { info_tbl: [(c4xzz,
                       label: block_c4xzz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xzz: // global
           I64[Sp] = block_c4xzF_info;
           _s4vFW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vFW::I64;
           if (R1 & 7 != 0) goto u4xA3; else goto c4xzG;
       u4xA3: // global
           call _c4xzF(R1) args: 0, res: 0, upd: 0;
       c4xzG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xzF() //  [R1]
         { info_tbl: [(c4xzF,
                       label: block_c4xzF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xzF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xA2; else goto c4xA1;
       c4xA2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xA1: // global
           _s4vG2::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vG2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.867901891 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.&._closure" {
     GHC.Int.$fBitsInt8_$c.&._closure:
         const GHC.Int.$fBitsInt8_$c.&._info;
 },
 GHC.Int.$fBitsInt8_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4xAv,
                       label: GHC.Int.$fBitsInt8_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xAv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xAQ; else goto c4xAR;
       c4xAQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xAR: // global
           I64[Sp - 16] = block_c4xAs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xAX; else goto c4xAt;
       u4xAX: // global
           call _c4xAs(R1) args: 0, res: 0, upd: 0;
       c4xAt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xAs() //  [R1]
         { info_tbl: [(c4xAs,
                       label: block_c4xAs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xAs: // global
           I64[Sp] = block_c4xAy_info;
           _s4vG6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vG6::I64;
           if (R1 & 7 != 0) goto u4xAW; else goto c4xAz;
       u4xAW: // global
           call _c4xAy(R1) args: 0, res: 0, upd: 0;
       c4xAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xAy() //  [R1]
         { info_tbl: [(c4xAy,
                       label: block_c4xAy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xAy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xAV; else goto c4xAU;
       c4xAV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xAU: // global
           _s4vGc::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vGc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.876650689 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4xBo,
                       label: GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xBo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xBC; else goto c4xBD;
       c4xBC: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xBD: // global
           I64[Sp - 8] = block_c4xBl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xBH; else goto c4xBm;
       u4xBH: // global
           call _c4xBl(R1) args: 0, res: 0, upd: 0;
       c4xBm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xBl() //  [R1]
         { info_tbl: [(c4xBl,
                       label: block_c4xBl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xBl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xBG; else goto c4xBF;
       c4xBG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xBF: // global
           (_c4xBu::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xBu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.88459157 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4xC3,
                       label: GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xC3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xCh; else goto c4xCi;
       c4xCh: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xCi: // global
           I64[Sp - 8] = block_c4xC0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xCm; else goto c4xC1;
       u4xCm: // global
           call _c4xC0(R1) args: 0, res: 0, upd: 0;
       c4xC1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xC0() //  [R1]
         { info_tbl: [(c4xC0,
                       label: block_c4xC0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xC0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xCl; else goto c4xCk;
       c4xCl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xCk: // global
           (_c4xC9::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xC9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.892100396 UTC

[section ""data" . GHC.Int.$fBitsInt11_closure" {
     GHC.Int.$fBitsInt11_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.895170755 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt8_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt8_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4xCG,
                       label: GHC.Int.$fBitsInt8_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xCG: // global
           R1 = GHC.Int.$fBitsInt11_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.901367125 UTC

[section ""data" . GHC.Int.$fNumInt16_$cfromInteger_closure" {
     GHC.Int.$fNumInt16_$cfromInteger_closure:
         const GHC.Int.$fNumInt16_$cfromInteger_info;
 },
 GHC.Int.$fNumInt16_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4xCU,
                       label: GHC.Int.$fNumInt16_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xCU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xD1; else goto c4xD2;
       c4xD1: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xD2: // global
           I64[Sp - 8] = block_c4xCS_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4xCS() //  [R1]
         { info_tbl: [(c4xCS,
                       label: block_c4xCS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xCS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xD5; else goto c4xD4;
       c4xD5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4xD4: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.912144289 UTC

[section ""data" . GHC.Int.$fNumInt16_$cnegate_closure" {
     GHC.Int.$fNumInt16_$cnegate_closure:
         const GHC.Int.$fNumInt16_$cnegate_info;
 },
 GHC.Int.$fNumInt16_$cnegate_entry() //  [R2]
         { info_tbl: [(c4xDq,
                       label: GHC.Int.$fNumInt16_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xDq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xDA; else goto c4xDB;
       c4xDA: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xDB: // global
           I64[Sp - 8] = block_c4xDn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xDF; else goto c4xDo;
       u4xDF: // global
           call _c4xDn(R1) args: 0, res: 0, upd: 0;
       c4xDo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xDn() //  [R1]
         { info_tbl: [(c4xDn,
                       label: block_c4xDn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xDn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xDE; else goto c4xDD;
       c4xDE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xDD: // global
           _s4vGx::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vGx::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.922250016 UTC

[section ""data" . GHC.Int.$fNumInt16_$c*_closure" {
     GHC.Int.$fNumInt16_$c*_closure:
         const GHC.Int.$fNumInt16_$c*_info;
 },
 GHC.Int.$fNumInt16_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4xE0,
                       label: GHC.Int.$fNumInt16_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xE0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xEf; else goto c4xEg;
       c4xEf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xEg: // global
           I64[Sp - 16] = block_c4xDX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xEm; else goto c4xDY;
       u4xEm: // global
           call _c4xDX(R1) args: 0, res: 0, upd: 0;
       c4xDY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xDX() //  [R1]
         { info_tbl: [(c4xDX,
                       label: block_c4xDX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xDX: // global
           I64[Sp] = block_c4xE3_info;
           _s4vGB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vGB::I64;
           if (R1 & 7 != 0) goto u4xEl; else goto c4xE4;
       u4xEl: // global
           call _c4xE3(R1) args: 0, res: 0, upd: 0;
       c4xE4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xE3() //  [R1]
         { info_tbl: [(c4xE3,
                       label: block_c4xE3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xE3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xEk; else goto c4xEj;
       c4xEk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xEj: // global
           _s4vGF::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vGF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.931314986 UTC

[section ""data" . GHC.Int.$fNumInt16_$c-_closure" {
     GHC.Int.$fNumInt16_$c-_closure:
         const GHC.Int.$fNumInt16_$c-_info;
 },
 GHC.Int.$fNumInt16_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4xEO,
                       label: GHC.Int.$fNumInt16_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xEO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xF3; else goto c4xF4;
       c4xF3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xF4: // global
           I64[Sp - 16] = block_c4xEL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xFa; else goto c4xEM;
       u4xFa: // global
           call _c4xEL(R1) args: 0, res: 0, upd: 0;
       c4xEM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xEL() //  [R1]
         { info_tbl: [(c4xEL,
                       label: block_c4xEL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xEL: // global
           I64[Sp] = block_c4xER_info;
           _s4vGJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vGJ::I64;
           if (R1 & 7 != 0) goto u4xF9; else goto c4xES;
       u4xF9: // global
           call _c4xER(R1) args: 0, res: 0, upd: 0;
       c4xES: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xER() //  [R1]
         { info_tbl: [(c4xER,
                       label: block_c4xER_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xER: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xF8; else goto c4xF7;
       c4xF8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xF7: // global
           _s4vGN::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vGN::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.945025114 UTC

[section ""data" . GHC.Int.$fNumInt16_$c+_closure" {
     GHC.Int.$fNumInt16_$c+_closure:
         const GHC.Int.$fNumInt16_$c+_info;
 },
 GHC.Int.$fNumInt16_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4xFC,
                       label: GHC.Int.$fNumInt16_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xFC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xFR; else goto c4xFS;
       c4xFR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xFS: // global
           I64[Sp - 16] = block_c4xFz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xFY; else goto c4xFA;
       u4xFY: // global
           call _c4xFz(R1) args: 0, res: 0, upd: 0;
       c4xFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xFz() //  [R1]
         { info_tbl: [(c4xFz,
                       label: block_c4xFz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xFz: // global
           I64[Sp] = block_c4xFF_info;
           _s4vGR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vGR::I64;
           if (R1 & 7 != 0) goto u4xFX; else goto c4xFG;
       u4xFX: // global
           call _c4xFF(R1) args: 0, res: 0, upd: 0;
       c4xFG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xFF() //  [R1]
         { info_tbl: [(c4xFF,
                       label: block_c4xFF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xFF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xFW; else goto c4xFV;
       c4xFW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xFV: // global
           _s4vGV::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vGV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.957465728 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt16_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt16_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt16_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4xGq,
                       label: GHC.Int.$fIntegralInt16_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xGq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xGr; else goto c4xGs;
       c4xGr: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xGs: // global
           I64[Sp - 8] = block_c4xGn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xGw; else goto c4xGo;
       u4xGw: // global
           call _c4xGn(R1) args: 0, res: 0, upd: 0;
       c4xGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xGn() //  [R1]
         { info_tbl: [(c4xGn,
                       label: block_c4xGn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xGn: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.966972652 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cpopCount_closure" {
     GHC.Int.$fBitsInt16_$cpopCount_closure:
         const GHC.Int.$fBitsInt16_$cpopCount_info;
 },
 GHC.Int.$fBitsInt16_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4xGO,
                       label: GHC.Int.$fBitsInt16_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xGO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xH2; else goto c4xH3;
       c4xH2: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xH3: // global
           I64[Sp - 8] = block_c4xGL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xH7; else goto c4xGM;
       u4xH7: // global
           call _c4xGL(R1) args: 0, res: 0, upd: 0;
       c4xGM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xGL() //  [R1]
         { info_tbl: [(c4xGL,
                       label: block_c4xGL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xGL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xH6; else goto c4xH5;
       c4xH6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xH5: // global
           (_c4xGU::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xGU::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.974638579 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4xHr,
                       label: GHC.Int.$fBitsInt16_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xHD; else goto c4xHE;
       c4xHD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xHE: // global
           I64[Sp - 16] = block_c4xHo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xHK; else goto c4xHp;
       u4xHK: // global
           call _c4xHo(R1) args: 0, res: 0, upd: 0;
       c4xHp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xHo() //  [R1]
         { info_tbl: [(c4xHo,
                       label: block_c4xHo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xHo: // global
           I64[Sp] = block_c4xHu_info;
           _s4vH8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vH8::I64;
           if (R1 & 7 != 0) goto u4xHJ; else goto c4xHv;
       u4xHJ: // global
           call _c4xHu(R1) args: 0, res: 0, upd: 0;
       c4xHv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xHu() //  [R1]
         { info_tbl: [(c4xHu,
                       label: block_c4xHu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xHu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xHI; else goto c4xHH;
       c4xHI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xHH: // global
           _s4vHb::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vHb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.982394466 UTC

[section ""data" . GHC.Int.$fBitsInt3_closure" {
     GHC.Int.$fBitsInt3_closure:
         const GHC.Int.I16#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.984197622 UTC

[section ""data" . GHC.Int.$fNumInt2_closure" {
     GHC.Int.$fNumInt2_closure:
         const GHC.Int.I16#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:24.987797033 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftR_closure" {
     GHC.Int.$fBitsInt16_$cshiftR_closure:
         const GHC.Int.$fBitsInt16_$cshiftR_info;
 },
 GHC.Int.$fBitsInt16_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4xIc,
                       label: GHC.Int.$fBitsInt16_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xIc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xIg; else goto c4xIh;
       c4xIg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xIh: // global
           I64[Sp - 16] = block_c4xI9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xIH; else goto c4xIa;
       u4xIH: // global
           call _c4xI9(R1) args: 0, res: 0, upd: 0;
       c4xIa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xI9() //  [R1]
         { info_tbl: [(c4xI9,
                       label: block_c4xI9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xI9: // global
           I64[Sp] = block_c4xIf_info;
           _s4vHf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vHf::I64;
           if (R1 & 7 != 0) goto u4xIG; else goto c4xIj;
       u4xIG: // global
           call _c4xIf(R1) args: 0, res: 0, upd: 0;
       c4xIj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xIf() //  [R1]
         { info_tbl: [(c4xIf,
                       label: block_c4xIf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xIf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xIp; else goto c4xIo;
       c4xIp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xIo: // global
           _s4vHf::I64 = I64[Sp + 8];
           _s4vHh::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vHh::I64, 64)) goto c4xIy; else goto c4xIF;
       c4xIy: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vHf::I64, _s4vHh::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xIF: // global
           if (%MO_S_Ge_W64(_s4vHf::I64, 0)) goto c4xID; else goto c4xIE;
       c4xID: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xIE: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.002707478 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4xJ9,
                       label: GHC.Int.$fBitsInt16_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xJ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xJo; else goto c4xJp;
       c4xJo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xJp: // global
           I64[Sp - 16] = block_c4xJ6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xJv; else goto c4xJ7;
       u4xJv: // global
           call _c4xJ6(R1) args: 0, res: 0, upd: 0;
       c4xJ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xJ6() //  [R1]
         { info_tbl: [(c4xJ6,
                       label: block_c4xJ6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xJ6: // global
           I64[Sp] = block_c4xJc_info;
           _s4vHo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vHo::I64;
           if (R1 & 7 != 0) goto u4xJu; else goto c4xJd;
       u4xJu: // global
           call _c4xJc(R1) args: 0, res: 0, upd: 0;
       c4xJd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xJc() //  [R1]
         { info_tbl: [(c4xJc,
                       label: block_c4xJc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xJc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xJt; else goto c4xJs;
       c4xJt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xJs: // global
           _s4vHs::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vHs::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.015364101 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftL_closure" {
     GHC.Int.$fBitsInt16_$cshiftL_closure:
         const GHC.Int.$fBitsInt16_$cshiftL_info;
 },
 GHC.Int.$fBitsInt16_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4xJW,
                       label: GHC.Int.$fBitsInt16_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xJW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xK0; else goto c4xK1;
       c4xK0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xK1: // global
           I64[Sp - 16] = block_c4xJT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xKo; else goto c4xJU;
       u4xKo: // global
           call _c4xJT(R1) args: 0, res: 0, upd: 0;
       c4xJU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xJT() //  [R1]
         { info_tbl: [(c4xJT,
                       label: block_c4xJT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xJT: // global
           I64[Sp] = block_c4xJZ_info;
           _s4vHw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vHw::I64;
           if (R1 & 7 != 0) goto u4xKn; else goto c4xK3;
       u4xKn: // global
           call _c4xJZ(R1) args: 0, res: 0, upd: 0;
       c4xK3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xJZ() //  [R1]
         { info_tbl: [(c4xJZ,
                       label: block_c4xJZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xJZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xK9; else goto c4xK8;
       c4xK9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xK8: // global
           _s4vHy::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vHy::I64, 64)) goto c4xKl; else goto c4xKm;
       c4xKl: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << _s4vHy::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xKm: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.026273924 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cisSigned_closure" {
     GHC.Int.$fBitsInt16_$cisSigned_closure:
         const GHC.Int.$fBitsInt16_$cisSigned_info;
 },
 GHC.Int.$fBitsInt16_$cisSigned_entry() //  []
         { info_tbl: [(c4xKO,
                       label: GHC.Int.$fBitsInt16_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xKO: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.030466333 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotate_closure" {
     GHC.Int.$fBitsInt16_$crotate_closure:
         const GHC.Int.$fBitsInt16_$crotate_info;
 },
 GHC.Int.$fBitsInt16_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4xL4,
                       label: GHC.Int.$fBitsInt16_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xL4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xL8; else goto c4xL9;
       c4xL8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xL9: // global
           I64[Sp - 16] = block_c4xL1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xM5; else goto c4xL2;
       u4xM5: // global
           call _c4xL1(R1) args: 0, res: 0, upd: 0;
       c4xL2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xL1() //  [R1]
         { info_tbl: [(c4xL1,
                       label: block_c4xL1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xL1: // global
           I64[Sp - 8] = block_c4xL7_info;
           _s4vHF::P64 = R1;
           _s4vHG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vHG::I64;
           P64[Sp + 8] = _s4vHF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xM4; else goto c4xLb;
       u4xM4: // global
           call _c4xL7(R1) args: 0, res: 0, upd: 0;
       c4xLb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xL7() //  [R1]
         { info_tbl: [(c4xL7,
                       label: block_c4xL7_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xL7: // global
           _s4vHL::I64 = I64[R1 + 7] & 15;
           if (_s4vHL::I64 != 0) goto u4xM2; else goto c4xLY;
       u4xM2: // global
           I64[Sp + 16] = _s4vHL::I64;
           Sp = Sp + 8;
           call _c4xLq() args: 0, res: 0, upd: 0;
       c4xLY: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4xLq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xLq: // global
           Hp = Hp + 16;
           _s4vHL::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4xLV; else goto c4xLU;
       c4xLV: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4xLp_info;
           R1 = _s4vHL::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4xLU: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4vHM::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4vHM::I64 << _s4vHL::I64) | (_s4vHM::I64 >> 16 - _s4vHL::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4xLp() //  [R1]
         { info_tbl: [(c4xLp,
                       label: block_c4xLp_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xLp: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4xLq() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.041989008 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshift_closure" {
     GHC.Int.$fBitsInt16_$cshift_closure:
         const GHC.Int.$fBitsInt16_$cshift_info;
 },
 GHC.Int.$fBitsInt16_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4xMM,
                       label: GHC.Int.$fBitsInt16_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xMM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xMQ; else goto c4xMR;
       c4xMQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xMR: // global
           I64[Sp - 16] = block_c4xMJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xNE; else goto c4xMK;
       u4xNE: // global
           call _c4xMJ(R1) args: 0, res: 0, upd: 0;
       c4xMK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xMJ() //  [R1]
         { info_tbl: [(c4xMJ,
                       label: block_c4xMJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xMJ: // global
           I64[Sp] = block_c4xMP_info;
           _s4vHX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vHX::I64;
           if (R1 & 7 != 0) goto u4xND; else goto c4xMT;
       u4xND: // global
           call _c4xMP(R1) args: 0, res: 0, upd: 0;
       c4xMT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xMP() //  [R1]
         { info_tbl: [(c4xMP,
                       label: block_c4xMP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xMP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xMZ; else goto c4xMY;
       c4xMZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xMY: // global
           _s4vHX::I64 = I64[Sp + 8];
           _s4vHZ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vHZ::I64, 0)) goto c4xNn; else goto c4xNC;
       c4xNn: // global
           _s4vI1::I64 = -_s4vHZ::I64;
           if (%MO_S_Lt_W64(_s4vI1::I64, 64)) goto c4xNe; else goto c4xNl;
       c4xNe: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vHX::I64, _s4vI1::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xNl: // global
           if (%MO_S_Ge_W64(_s4vHX::I64, 0)) goto c4xNB; else goto c4xNk;
       c4xNk: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xNC: // global
           if (%MO_S_Ge_W64(_s4vHZ::I64, 64)) goto c4xNB; else goto c4xNA;
       c4xNB: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xNA: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vHX::I64 << _s4vHZ::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.052079367 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplement_closure" {
     GHC.Int.$fBitsInt16_$ccomplement_closure:
         const GHC.Int.$fBitsInt16_$ccomplement_info;
 },
 GHC.Int.$fBitsInt16_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4xOb,
                       label: GHC.Int.$fBitsInt16_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xOb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xOo; else goto c4xOp;
       c4xOo: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xOp: // global
           I64[Sp - 8] = block_c4xO8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xOt; else goto c4xO9;
       u4xOt: // global
           call _c4xO8(R1) args: 0, res: 0, upd: 0;
       c4xO9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xO8() //  [R1]
         { info_tbl: [(c4xO8,
                       label: block_c4xO8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xO8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xOs; else goto c4xOr;
       c4xOs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xOr: // global
           _s4vId::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vId::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.058519131 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cxor_closure" {
     GHC.Int.$fBitsInt16_$cxor_closure:
         const GHC.Int.$fBitsInt16_$cxor_info;
 },
 GHC.Int.$fBitsInt16_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4xON,
                       label: GHC.Int.$fBitsInt16_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xON: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xP8; else goto c4xP9;
       c4xP8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xP9: // global
           I64[Sp - 16] = block_c4xOK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xPf; else goto c4xOL;
       u4xPf: // global
           call _c4xOK(R1) args: 0, res: 0, upd: 0;
       c4xOL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xOK() //  [R1]
         { info_tbl: [(c4xOK,
                       label: block_c4xOK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xOK: // global
           I64[Sp] = block_c4xOQ_info;
           _s4vIh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vIh::I64;
           if (R1 & 7 != 0) goto u4xPe; else goto c4xOR;
       u4xPe: // global
           call _c4xOQ(R1) args: 0, res: 0, upd: 0;
       c4xOR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xOQ() //  [R1]
         { info_tbl: [(c4xOQ,
                       label: block_c4xOQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xOQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xPd; else goto c4xPc;
       c4xPd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xPc: // global
           _s4vIn::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vIn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.06773938 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.|._closure" {
     GHC.Int.$fBitsInt16_$c.|._closure:
         const GHC.Int.$fBitsInt16_$c.|._info;
 },
 GHC.Int.$fBitsInt16_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4xPG,
                       label: GHC.Int.$fBitsInt16_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xPG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xQ1; else goto c4xQ2;
       c4xQ1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xQ2: // global
           I64[Sp - 16] = block_c4xPD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xQ8; else goto c4xPE;
       u4xQ8: // global
           call _c4xPD(R1) args: 0, res: 0, upd: 0;
       c4xPE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xPD() //  [R1]
         { info_tbl: [(c4xPD,
                       label: block_c4xPD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xPD: // global
           I64[Sp] = block_c4xPJ_info;
           _s4vIr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vIr::I64;
           if (R1 & 7 != 0) goto u4xQ7; else goto c4xPK;
       u4xQ7: // global
           call _c4xPJ(R1) args: 0, res: 0, upd: 0;
       c4xPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xPJ() //  [R1]
         { info_tbl: [(c4xPJ,
                       label: block_c4xPJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xPJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xQ6; else goto c4xQ5;
       c4xQ6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xQ5: // global
           _s4vIx::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vIx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.075893477 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.&._closure" {
     GHC.Int.$fBitsInt16_$c.&._closure:
         const GHC.Int.$fBitsInt16_$c.&._info;
 },
 GHC.Int.$fBitsInt16_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4xQz,
                       label: GHC.Int.$fBitsInt16_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xQz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xQU; else goto c4xQV;
       c4xQU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xQV: // global
           I64[Sp - 16] = block_c4xQw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xR1; else goto c4xQx;
       u4xR1: // global
           call _c4xQw(R1) args: 0, res: 0, upd: 0;
       c4xQx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xQw() //  [R1]
         { info_tbl: [(c4xQw,
                       label: block_c4xQw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xQw: // global
           I64[Sp] = block_c4xQC_info;
           _s4vIB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vIB::I64;
           if (R1 & 7 != 0) goto u4xR0; else goto c4xQD;
       u4xR0: // global
           call _c4xQC(R1) args: 0, res: 0, upd: 0;
       c4xQD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xQC() //  [R1]
         { info_tbl: [(c4xQC,
                       label: block_c4xQC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xQC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xQZ; else goto c4xQY;
       c4xQZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xQY: // global
           _s4vIH::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vIH::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.08433539 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4xRs,
                       label: GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xRs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xRG; else goto c4xRH;
       c4xRG: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xRH: // global
           I64[Sp - 8] = block_c4xRp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xRL; else goto c4xRq;
       u4xRL: // global
           call _c4xRp(R1) args: 0, res: 0, upd: 0;
       c4xRq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xRp() //  [R1]
         { info_tbl: [(c4xRp,
                       label: block_c4xRp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xRp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xRK; else goto c4xRJ;
       c4xRK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xRJ: // global
           (_c4xRy::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xRy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.091214781 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4xS7,
                       label: GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xS7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xSl; else goto c4xSm;
       c4xSl: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xSm: // global
           I64[Sp - 8] = block_c4xS4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xSq; else goto c4xS5;
       u4xSq: // global
           call _c4xS4(R1) args: 0, res: 0, upd: 0;
       c4xS5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xS4() //  [R1]
         { info_tbl: [(c4xS4,
                       label: block_c4xS4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xS4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xSp; else goto c4xSo;
       c4xSp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xSo: // global
           (_c4xSd::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xSd::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.097117529 UTC

[section ""data" . GHC.Int.$fBitsInt1_closure" {
     GHC.Int.$fBitsInt1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.099128127 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt16_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt16_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4xSK,
                       label: GHC.Int.$fBitsInt16_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xSK: // global
           R1 = GHC.Int.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.102940622 UTC

[section ""data" . GHC.Int.$fNumInt32_$cfromInteger_closure" {
     GHC.Int.$fNumInt32_$cfromInteger_closure:
         const GHC.Int.$fNumInt32_$cfromInteger_info;
 },
 GHC.Int.$fNumInt32_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4xSY,
                       label: GHC.Int.$fNumInt32_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xSY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xT5; else goto c4xT6;
       c4xT5: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xT6: // global
           I64[Sp - 8] = block_c4xSW_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4xSW() //  [R1]
         { info_tbl: [(c4xSW,
                       label: block_c4xSW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xSW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xT9; else goto c4xT8;
       c4xT9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4xT8: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.10951479 UTC

[section ""data" . GHC.Int.$fNumInt32_$cnegate_closure" {
     GHC.Int.$fNumInt32_$cnegate_closure:
         const GHC.Int.$fNumInt32_$cnegate_info;
 },
 GHC.Int.$fNumInt32_$cnegate_entry() //  [R2]
         { info_tbl: [(c4xTt,
                       label: GHC.Int.$fNumInt32_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xTt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xTD; else goto c4xTE;
       c4xTD: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xTE: // global
           I64[Sp - 8] = block_c4xTq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xTI; else goto c4xTr;
       u4xTI: // global
           call _c4xTq(R1) args: 0, res: 0, upd: 0;
       c4xTr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xTq() //  [R1]
         { info_tbl: [(c4xTq,
                       label: block_c4xTq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xTq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xTH; else goto c4xTG;
       c4xTH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xTG: // global
           _s4vJ2::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJ2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.115551739 UTC

[section ""data" . GHC.Int.$fNumInt32_$c*_closure" {
     GHC.Int.$fNumInt32_$c*_closure:
         const GHC.Int.$fNumInt32_$c*_info;
 },
 GHC.Int.$fNumInt32_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4xU3,
                       label: GHC.Int.$fNumInt32_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xU3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xUi; else goto c4xUj;
       c4xUi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xUj: // global
           I64[Sp - 16] = block_c4xU0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xUp; else goto c4xU1;
       u4xUp: // global
           call _c4xU0(R1) args: 0, res: 0, upd: 0;
       c4xU1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xU0() //  [R1]
         { info_tbl: [(c4xU0,
                       label: block_c4xU0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xU0: // global
           I64[Sp] = block_c4xU6_info;
           _s4vJ6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJ6::I64;
           if (R1 & 7 != 0) goto u4xUo; else goto c4xU7;
       u4xUo: // global
           call _c4xU6(R1) args: 0, res: 0, upd: 0;
       c4xU7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xU6() //  [R1]
         { info_tbl: [(c4xU6,
                       label: block_c4xU6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xU6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xUn; else goto c4xUm;
       c4xUn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xUm: // global
           _s4vJa::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.124011721 UTC

[section ""data" . GHC.Int.$fNumInt32_$c-_closure" {
     GHC.Int.$fNumInt32_$c-_closure:
         const GHC.Int.$fNumInt32_$c-_info;
 },
 GHC.Int.$fNumInt32_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4xUR,
                       label: GHC.Int.$fNumInt32_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xUR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xV6; else goto c4xV7;
       c4xV6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xV7: // global
           I64[Sp - 16] = block_c4xUO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xVd; else goto c4xUP;
       u4xVd: // global
           call _c4xUO(R1) args: 0, res: 0, upd: 0;
       c4xUP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xUO() //  [R1]
         { info_tbl: [(c4xUO,
                       label: block_c4xUO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xUO: // global
           I64[Sp] = block_c4xUU_info;
           _s4vJe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJe::I64;
           if (R1 & 7 != 0) goto u4xVc; else goto c4xUV;
       u4xVc: // global
           call _c4xUU(R1) args: 0, res: 0, upd: 0;
       c4xUV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xUU() //  [R1]
         { info_tbl: [(c4xUU,
                       label: block_c4xUU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xUU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xVb; else goto c4xVa;
       c4xVb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xVa: // global
           _s4vJi::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJi::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.133154262 UTC

[section ""data" . GHC.Int.$fNumInt32_$c+_closure" {
     GHC.Int.$fNumInt32_$c+_closure:
         const GHC.Int.$fNumInt32_$c+_info;
 },
 GHC.Int.$fNumInt32_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4xVF,
                       label: GHC.Int.$fNumInt32_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xVF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xVU; else goto c4xVV;
       c4xVU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xVV: // global
           I64[Sp - 16] = block_c4xVC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xW1; else goto c4xVD;
       u4xW1: // global
           call _c4xVC(R1) args: 0, res: 0, upd: 0;
       c4xVD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xVC() //  [R1]
         { info_tbl: [(c4xVC,
                       label: block_c4xVC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xVC: // global
           I64[Sp] = block_c4xVI_info;
           _s4vJm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJm::I64;
           if (R1 & 7 != 0) goto u4xW0; else goto c4xVJ;
       u4xW0: // global
           call _c4xVI(R1) args: 0, res: 0, upd: 0;
       c4xVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xVI() //  [R1]
         { info_tbl: [(c4xVI,
                       label: block_c4xVI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xVI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xVZ; else goto c4xVY;
       c4xVZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xVY: // global
           _s4vJq::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.14108299 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt32_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt32_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt32_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4xWt,
                       label: GHC.Int.$fIntegralInt32_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xWt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xWu; else goto c4xWv;
       c4xWu: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xWv: // global
           I64[Sp - 8] = block_c4xWq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xWz; else goto c4xWr;
       u4xWz: // global
           call _c4xWq(R1) args: 0, res: 0, upd: 0;
       c4xWr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xWq() //  [R1]
         { info_tbl: [(c4xWq,
                       label: block_c4xWq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xWq: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.147051342 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cpopCount_closure" {
     GHC.Int.$fBitsInt32_$cpopCount_closure:
         const GHC.Int.$fBitsInt32_$cpopCount_info;
 },
 GHC.Int.$fBitsInt32_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4xWR,
                       label: GHC.Int.$fBitsInt32_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xWR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xX5; else goto c4xX6;
       c4xX5: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xX6: // global
           I64[Sp - 8] = block_c4xWO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xXa; else goto c4xWP;
       u4xXa: // global
           call _c4xWO(R1) args: 0, res: 0, upd: 0;
       c4xWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xWO() //  [R1]
         { info_tbl: [(c4xWO,
                       label: block_c4xWO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xWO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xX9; else goto c4xX8;
       c4xX9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xX8: // global
           (_c4xWX::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xWX::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.154353792 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4xXu,
                       label: GHC.Int.$fBitsInt32_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xXu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xXG; else goto c4xXH;
       c4xXG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xXH: // global
           I64[Sp - 16] = block_c4xXr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xXN; else goto c4xXs;
       u4xXN: // global
           call _c4xXr(R1) args: 0, res: 0, upd: 0;
       c4xXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xXr() //  [R1]
         { info_tbl: [(c4xXr,
                       label: block_c4xXr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xXr: // global
           I64[Sp] = block_c4xXx_info;
           _s4vJD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJD::I64;
           if (R1 & 7 != 0) goto u4xXM; else goto c4xXy;
       u4xXM: // global
           call _c4xXx(R1) args: 0, res: 0, upd: 0;
       c4xXy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xXx() //  [R1]
         { info_tbl: [(c4xXx,
                       label: block_c4xXx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xXx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xXL; else goto c4xXK;
       c4xXL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xXK: // global
           _s4vJG::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.162187059 UTC

[section ""data" . GHC.Int.$fBitsInt6_closure" {
     GHC.Int.$fBitsInt6_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.163885064 UTC

[section ""data" . GHC.Int.$fNumInt4_closure" {
     GHC.Int.$fNumInt4_closure:
         const GHC.Int.I32#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.166323564 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftR_closure" {
     GHC.Int.$fBitsInt32_$cshiftR_closure:
         const GHC.Int.$fBitsInt32_$cshiftR_info;
 },
 GHC.Int.$fBitsInt32_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4xYf,
                       label: GHC.Int.$fBitsInt32_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xYf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xYj; else goto c4xYk;
       c4xYj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xYk: // global
           I64[Sp - 16] = block_c4xYc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xYK; else goto c4xYd;
       u4xYK: // global
           call _c4xYc(R1) args: 0, res: 0, upd: 0;
       c4xYd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xYc() //  [R1]
         { info_tbl: [(c4xYc,
                       label: block_c4xYc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xYc: // global
           I64[Sp] = block_c4xYi_info;
           _s4vJK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJK::I64;
           if (R1 & 7 != 0) goto u4xYJ; else goto c4xYm;
       u4xYJ: // global
           call _c4xYi(R1) args: 0, res: 0, upd: 0;
       c4xYm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xYi() //  [R1]
         { info_tbl: [(c4xYi,
                       label: block_c4xYi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xYi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xYs; else goto c4xYr;
       c4xYs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xYr: // global
           _s4vJK::I64 = I64[Sp + 8];
           _s4vJM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vJM::I64, 64)) goto c4xYB; else goto c4xYI;
       c4xYB: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vJK::I64, _s4vJM::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xYI: // global
           if (%MO_S_Ge_W64(_s4vJK::I64, 0)) goto c4xYG; else goto c4xYH;
       c4xYG: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xYH: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.175786417 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4xZc,
                       label: GHC.Int.$fBitsInt32_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xZc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xZr; else goto c4xZs;
       c4xZr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xZs: // global
           I64[Sp - 16] = block_c4xZ9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xZy; else goto c4xZa;
       u4xZy: // global
           call _c4xZ9(R1) args: 0, res: 0, upd: 0;
       c4xZa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xZ9() //  [R1]
         { info_tbl: [(c4xZ9,
                       label: block_c4xZ9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xZ9: // global
           I64[Sp] = block_c4xZf_info;
           _s4vJT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJT::I64;
           if (R1 & 7 != 0) goto u4xZx; else goto c4xZg;
       u4xZx: // global
           call _c4xZf(R1) args: 0, res: 0, upd: 0;
       c4xZg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xZf() //  [R1]
         { info_tbl: [(c4xZf,
                       label: block_c4xZf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xZf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xZw; else goto c4xZv;
       c4xZw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xZv: // global
           _s4vJX::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.184480762 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftL_closure" {
     GHC.Int.$fBitsInt32_$cshiftL_closure:
         const GHC.Int.$fBitsInt32_$cshiftL_info;
 },
 GHC.Int.$fBitsInt32_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4xZY,
                       label: GHC.Int.$fBitsInt32_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xZY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4y02; else goto c4y03;
       c4y02: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y03: // global
           I64[Sp - 16] = block_c4xZV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y0q; else goto c4xZW;
       u4y0q: // global
           call _c4xZV(R1) args: 0, res: 0, upd: 0;
       c4xZW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4xZV() //  [R1]
         { info_tbl: [(c4xZV,
                       label: block_c4xZV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4xZV: // global
           I64[Sp] = block_c4y01_info;
           _s4vK1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vK1::I64;
           if (R1 & 7 != 0) goto u4y0p; else goto c4y05;
       u4y0p: // global
           call _c4y01(R1) args: 0, res: 0, upd: 0;
       c4y05: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y01() //  [R1]
         { info_tbl: [(c4y01,
                       label: block_c4y01_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y01: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y0b; else goto c4y0a;
       c4y0b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y0a: // global
           _s4vK3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vK3::I64, 64)) goto c4y0n; else goto c4y0o;
       c4y0n: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << _s4vK3::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4y0o: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.193287634 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cisSigned_closure" {
     GHC.Int.$fBitsInt32_$cisSigned_closure:
         const GHC.Int.$fBitsInt32_$cisSigned_info;
 },
 GHC.Int.$fBitsInt32_$cisSigned_entry() //  []
         { info_tbl: [(c4y0P,
                       label: GHC.Int.$fBitsInt32_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y0P: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.197526441 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotate_closure" {
     GHC.Int.$fBitsInt32_$crotate_closure:
         const GHC.Int.$fBitsInt32_$crotate_info;
 },
 GHC.Int.$fBitsInt32_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4y15,
                       label: GHC.Int.$fBitsInt32_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y15: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4y19; else goto c4y1a;
       c4y19: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y1a: // global
           I64[Sp - 16] = block_c4y12_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y26; else goto c4y13;
       u4y26: // global
           call _c4y12(R1) args: 0, res: 0, upd: 0;
       c4y13: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y12() //  [R1]
         { info_tbl: [(c4y12,
                       label: block_c4y12_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y12: // global
           I64[Sp - 8] = block_c4y18_info;
           _s4vKa::P64 = R1;
           _s4vKb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vKb::I64;
           P64[Sp + 8] = _s4vKa::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4y25; else goto c4y1c;
       u4y25: // global
           call _c4y18(R1) args: 0, res: 0, upd: 0;
       c4y1c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y18() //  [R1]
         { info_tbl: [(c4y18,
                       label: block_c4y18_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y18: // global
           _s4vKg::I64 = I64[R1 + 7] & 31;
           if (_s4vKg::I64 != 0) goto u4y23; else goto c4y1Z;
       u4y23: // global
           I64[Sp + 16] = _s4vKg::I64;
           Sp = Sp + 8;
           call _c4y1r() args: 0, res: 0, upd: 0;
       c4y1Z: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4y1r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y1r: // global
           Hp = Hp + 16;
           _s4vKg::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4y1W; else goto c4y1V;
       c4y1W: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4y1q_info;
           R1 = _s4vKg::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4y1V: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4vKh::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4vKh::I64 << _s4vKg::I64) | (_s4vKh::I64 >> 32 - _s4vKg::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4y1q() //  [R1]
         { info_tbl: [(c4y1q,
                       label: block_c4y1q_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y1q: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4y1r() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.209523473 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshift_closure" {
     GHC.Int.$fBitsInt32_$cshift_closure:
         const GHC.Int.$fBitsInt32_$cshift_info;
 },
 GHC.Int.$fBitsInt32_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4y2N,
                       label: GHC.Int.$fBitsInt32_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y2N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4y2R; else goto c4y2S;
       c4y2R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y2S: // global
           I64[Sp - 16] = block_c4y2K_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y3F; else goto c4y2L;
       u4y3F: // global
           call _c4y2K(R1) args: 0, res: 0, upd: 0;
       c4y2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y2K() //  [R1]
         { info_tbl: [(c4y2K,
                       label: block_c4y2K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y2K: // global
           I64[Sp] = block_c4y2Q_info;
           _s4vKs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vKs::I64;
           if (R1 & 7 != 0) goto u4y3E; else goto c4y2U;
       u4y3E: // global
           call _c4y2Q(R1) args: 0, res: 0, upd: 0;
       c4y2U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y2Q() //  [R1]
         { info_tbl: [(c4y2Q,
                       label: block_c4y2Q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y2Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y30; else goto c4y2Z;
       c4y30: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y2Z: // global
           _s4vKs::I64 = I64[Sp + 8];
           _s4vKu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vKu::I64, 0)) goto c4y3o; else goto c4y3D;
       c4y3o: // global
           _s4vKw::I64 = -_s4vKu::I64;
           if (%MO_S_Lt_W64(_s4vKw::I64, 64)) goto c4y3f; else goto c4y3m;
       c4y3f: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vKs::I64, _s4vKw::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4y3m: // global
           if (%MO_S_Ge_W64(_s4vKs::I64, 0)) goto c4y3C; else goto c4y3l;
       c4y3l: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4y3D: // global
           if (%MO_S_Ge_W64(_s4vKu::I64, 64)) goto c4y3C; else goto c4y3B;
       c4y3C: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4y3B: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4vKs::I64 << _s4vKu::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.219402693 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplement_closure" {
     GHC.Int.$fBitsInt32_$ccomplement_closure:
         const GHC.Int.$fBitsInt32_$ccomplement_info;
 },
 GHC.Int.$fBitsInt32_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4y4b,
                       label: GHC.Int.$fBitsInt32_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y4b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4y4o; else goto c4y4p;
       c4y4o: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4y4p: // global
           I64[Sp - 8] = block_c4y48_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4y4t; else goto c4y49;
       u4y4t: // global
           call _c4y48(R1) args: 0, res: 0, upd: 0;
       c4y49: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y48() //  [R1]
         { info_tbl: [(c4y48,
                       label: block_c4y48_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y48: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y4s; else goto c4y4r;
       c4y4s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y4r: // global
           _s4vKI::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vKI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.22557889 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cxor_closure" {
     GHC.Int.$fBitsInt32_$cxor_closure:
         const GHC.Int.$fBitsInt32_$cxor_info;
 },
 GHC.Int.$fBitsInt32_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4y4N,
                       label: GHC.Int.$fBitsInt32_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y4N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4y58; else goto c4y59;
       c4y58: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y59: // global
           I64[Sp - 16] = block_c4y4K_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y5f; else goto c4y4L;
       u4y5f: // global
           call _c4y4K(R1) args: 0, res: 0, upd: 0;
       c4y4L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y4K() //  [R1]
         { info_tbl: [(c4y4K,
                       label: block_c4y4K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y4K: // global
           I64[Sp] = block_c4y4Q_info;
           _s4vKM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vKM::I64;
           if (R1 & 7 != 0) goto u4y5e; else goto c4y4R;
       u4y5e: // global
           call _c4y4Q(R1) args: 0, res: 0, upd: 0;
       c4y4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y4Q() //  [R1]
         { info_tbl: [(c4y4Q,
                       label: block_c4y4Q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y4Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y5d; else goto c4y5c;
       c4y5d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y5c: // global
           _s4vKS::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vKS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.23453526 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.|._closure" {
     GHC.Int.$fBitsInt32_$c.|._closure:
         const GHC.Int.$fBitsInt32_$c.|._info;
 },
 GHC.Int.$fBitsInt32_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4y5G,
                       label: GHC.Int.$fBitsInt32_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y5G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4y61; else goto c4y62;
       c4y61: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y62: // global
           I64[Sp - 16] = block_c4y5D_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y68; else goto c4y5E;
       u4y68: // global
           call _c4y5D(R1) args: 0, res: 0, upd: 0;
       c4y5E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y5D() //  [R1]
         { info_tbl: [(c4y5D,
                       label: block_c4y5D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y5D: // global
           I64[Sp] = block_c4y5J_info;
           _s4vKW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vKW::I64;
           if (R1 & 7 != 0) goto u4y67; else goto c4y5K;
       u4y67: // global
           call _c4y5J(R1) args: 0, res: 0, upd: 0;
       c4y5K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y5J() //  [R1]
         { info_tbl: [(c4y5J,
                       label: block_c4y5J_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y5J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y66; else goto c4y65;
       c4y66: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y65: // global
           _s4vL2::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vL2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.242855693 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.&._closure" {
     GHC.Int.$fBitsInt32_$c.&._closure:
         const GHC.Int.$fBitsInt32_$c.&._info;
 },
 GHC.Int.$fBitsInt32_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4y6z,
                       label: GHC.Int.$fBitsInt32_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y6z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4y6U; else goto c4y6V;
       c4y6U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y6V: // global
           I64[Sp - 16] = block_c4y6w_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y71; else goto c4y6x;
       u4y71: // global
           call _c4y6w(R1) args: 0, res: 0, upd: 0;
       c4y6x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y6w() //  [R1]
         { info_tbl: [(c4y6w,
                       label: block_c4y6w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y6w: // global
           I64[Sp] = block_c4y6C_info;
           _s4vL6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vL6::I64;
           if (R1 & 7 != 0) goto u4y70; else goto c4y6D;
       u4y70: // global
           call _c4y6C(R1) args: 0, res: 0, upd: 0;
       c4y6D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y6C() //  [R1]
         { info_tbl: [(c4y6C,
                       label: block_c4y6C_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y6C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y6Z; else goto c4y6Y;
       c4y6Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y6Y: // global
           _s4vLc::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vLc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.251397952 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4y7s,
                       label: GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y7s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4y7G; else goto c4y7H;
       c4y7G: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4y7H: // global
           I64[Sp - 8] = block_c4y7p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4y7L; else goto c4y7q;
       u4y7L: // global
           call _c4y7p(R1) args: 0, res: 0, upd: 0;
       c4y7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y7p() //  [R1]
         { info_tbl: [(c4y7p,
                       label: block_c4y7p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y7p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y7K; else goto c4y7J;
       c4y7K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y7J: // global
           (_c4y7y::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4y7y::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.257869953 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4y87,
                       label: GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y87: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4y8l; else goto c4y8m;
       c4y8l: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4y8m: // global
           I64[Sp - 8] = block_c4y84_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4y8q; else goto c4y85;
       u4y8q: // global
           call _c4y84(R1) args: 0, res: 0, upd: 0;
       c4y85: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y84() //  [R1]
         { info_tbl: [(c4y84,
                       label: block_c4y84_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y84: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y8p; else goto c4y8o;
       c4y8p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y8o: // global
           (_c4y8d::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4y8d::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.263672582 UTC

[section ""data" . GHC.Int.$fBitsInt4_closure" {
     GHC.Int.$fBitsInt4_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.265814106 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt32_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt32_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4y8K,
                       label: GHC.Int.$fBitsInt32_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y8K: // global
           R1 = GHC.Int.$fBitsInt4_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.269635899 UTC

[section ""data" . GHC.Int.$fNumInt64_$cfromInteger_closure" {
     GHC.Int.$fNumInt64_$cfromInteger_closure:
         const GHC.Int.$fNumInt64_$cfromInteger_info;
 },
 GHC.Int.$fNumInt64_$cfromInteger_entry() //  [R2]
         { info_tbl: [(c4y8Y,
                       label: GHC.Int.$fNumInt64_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y8Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4y92; else goto c4y93;
       c4y92: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4y93: // global
           I64[Sp - 8] = block_c4y8W_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4y8W() //  [R1]
         { info_tbl: [(c4y8W,
                       label: block_c4y8W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y8W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y96; else goto c4y95;
       c4y96: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4y95: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.2761126 UTC

[section ""data" . GHC.Int.$fNumInt64_$cnegate_closure" {
     GHC.Int.$fNumInt64_$cnegate_closure:
         const GHC.Int.$fNumInt64_$cnegate_info;
 },
 GHC.Int.$fNumInt64_$cnegate_entry() //  [R2]
         { info_tbl: [(c4y9p,
                       label: GHC.Int.$fNumInt64_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y9p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4y9w; else goto c4y9x;
       c4y9w: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4y9x: // global
           I64[Sp - 8] = block_c4y9m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4y9B; else goto c4y9n;
       u4y9B: // global
           call _c4y9m(R1) args: 0, res: 0, upd: 0;
       c4y9n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y9m() //  [R1]
         { info_tbl: [(c4y9m,
                       label: block_c4y9m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y9m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y9A; else goto c4y9z;
       c4y9A: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y9z: // global
           _s4vLv::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vLv::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.282855008 UTC

[section ""data" . GHC.Int.$fNumInt64_$c*_closure" {
     GHC.Int.$fNumInt64_$c*_closure:
         const GHC.Int.$fNumInt64_$c*_info;
 },
 GHC.Int.$fNumInt64_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4y9V,
                       label: GHC.Int.$fNumInt64_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y9V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ya7; else goto c4ya8;
       c4ya7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ya8: // global
           I64[Sp - 16] = block_c4y9S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yae; else goto c4y9T;
       u4yae: // global
           call _c4y9S(R1) args: 0, res: 0, upd: 0;
       c4y9T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y9S() //  [R1]
         { info_tbl: [(c4y9S,
                       label: block_c4y9S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y9S: // global
           I64[Sp] = block_c4y9Y_info;
           _s4vLz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vLz::I64;
           if (R1 & 7 != 0) goto u4yad; else goto c4y9Z;
       u4yad: // global
           call _c4y9Y(R1) args: 0, res: 0, upd: 0;
       c4y9Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4y9Y() //  [R1]
         { info_tbl: [(c4y9Y,
                       label: block_c4y9Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4y9Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yac; else goto c4yab;
       c4yac: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yab: // global
           _s4vLC::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vLC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.291178578 UTC

[section ""data" . GHC.Int.$fNumInt64_$c-_closure" {
     GHC.Int.$fNumInt64_$c-_closure:
         const GHC.Int.$fNumInt64_$c-_info;
 },
 GHC.Int.$fNumInt64_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4yaF,
                       label: GHC.Int.$fNumInt64_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yaF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yaR; else goto c4yaS;
       c4yaR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yaS: // global
           I64[Sp - 16] = block_c4yaC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yaY; else goto c4yaD;
       u4yaY: // global
           call _c4yaC(R1) args: 0, res: 0, upd: 0;
       c4yaD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yaC() //  [R1]
         { info_tbl: [(c4yaC,
                       label: block_c4yaC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yaC: // global
           I64[Sp] = block_c4yaI_info;
           _s4vLG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vLG::I64;
           if (R1 & 7 != 0) goto u4yaX; else goto c4yaJ;
       u4yaX: // global
           call _c4yaI(R1) args: 0, res: 0, upd: 0;
       c4yaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yaI() //  [R1]
         { info_tbl: [(c4yaI,
                       label: block_c4yaI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yaI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yaW; else goto c4yaV;
       c4yaW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yaV: // global
           _s4vLJ::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vLJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.300392377 UTC

[section ""data" . GHC.Int.$fNumInt64_$c+_closure" {
     GHC.Int.$fNumInt64_$c+_closure:
         const GHC.Int.$fNumInt64_$c+_info;
 },
 GHC.Int.$fNumInt64_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4ybp,
                       label: GHC.Int.$fNumInt64_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ybp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ybB; else goto c4ybC;
       c4ybB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ybC: // global
           I64[Sp - 16] = block_c4ybm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ybI; else goto c4ybn;
       u4ybI: // global
           call _c4ybm(R1) args: 0, res: 0, upd: 0;
       c4ybn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ybm() //  [R1]
         { info_tbl: [(c4ybm,
                       label: block_c4ybm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ybm: // global
           I64[Sp] = block_c4ybs_info;
           _s4vLN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vLN::I64;
           if (R1 & 7 != 0) goto u4ybH; else goto c4ybt;
       u4ybH: // global
           call _c4ybs(R1) args: 0, res: 0, upd: 0;
       c4ybt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ybs() //  [R1]
         { info_tbl: [(c4ybs,
                       label: block_c4ybs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ybs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ybG; else goto c4ybF;
       c4ybG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ybF: // global
           _s4vLQ::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vLQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.308363204 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt64_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt64_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt64_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4yc9,
                       label: GHC.Int.$fIntegralInt64_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yc9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yca; else goto c4ycb;
       c4yca: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ycb: // global
           I64[Sp - 8] = block_c4yc6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ycf; else goto c4yc7;
       u4ycf: // global
           call _c4yc6(R1) args: 0, res: 0, upd: 0;
       c4yc7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yc6() //  [R1]
         { info_tbl: [(c4yc6,
                       label: block_c4yc6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yc6: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.315224776 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cpopCount_closure" {
     GHC.Int.$fBitsInt64_$cpopCount_closure:
         const GHC.Int.$fBitsInt64_$cpopCount_info;
 },
 GHC.Int.$fBitsInt64_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4ycx,
                       label: GHC.Int.$fBitsInt64_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ycx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ycL; else goto c4ycM;
       c4ycL: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ycM: // global
           I64[Sp - 8] = block_c4ycu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ycQ; else goto c4ycv;
       u4ycQ: // global
           call _c4ycu(R1) args: 0, res: 0, upd: 0;
       c4ycv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ycu() //  [R1]
         { info_tbl: [(c4ycu,
                       label: block_c4ycu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ycu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ycP; else goto c4ycO;
       c4ycP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ycO: // global
           (_c4ycD::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4ycD::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.321793561 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4yda,
                       label: GHC.Int.$fBitsInt64_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yda: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ydm; else goto c4ydn;
       c4ydm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ydn: // global
           I64[Sp - 16] = block_c4yd7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ydt; else goto c4yd8;
       u4ydt: // global
           call _c4yd7(R1) args: 0, res: 0, upd: 0;
       c4yd8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yd7() //  [R1]
         { info_tbl: [(c4yd7,
                       label: block_c4yd7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yd7: // global
           I64[Sp] = block_c4ydd_info;
           _s4vM3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vM3::I64;
           if (R1 & 7 != 0) goto u4yds; else goto c4yde;
       u4yds: // global
           call _c4ydd(R1) args: 0, res: 0, upd: 0;
       c4yde: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ydd() //  [R1]
         { info_tbl: [(c4ydd,
                       label: block_c4ydd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ydd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ydr; else goto c4ydq;
       c4ydr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ydq: // global
           _s4vM6::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vM6::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.329850697 UTC

[section ""data" . GHC.Int.$fBitsInt10_closure" {
     GHC.Int.$fBitsInt10_closure:
         const GHC.Int.I64#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.331610035 UTC

[section ""data" . GHC.Int.$fNumInt6_closure" {
     GHC.Int.$fNumInt6_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.334510164 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftR_closure" {
     GHC.Int.$fBitsInt64_$cshiftR_closure:
         const GHC.Int.$fBitsInt64_$cshiftR_info;
 },
 GHC.Int.$fBitsInt64_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4ydV,
                       label: GHC.Int.$fBitsInt64_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ydV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ydZ; else goto c4ye0;
       c4ydZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ye0: // global
           I64[Sp - 16] = block_c4ydS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yeq; else goto c4ydT;
       u4yeq: // global
           call _c4ydS(R1) args: 0, res: 0, upd: 0;
       c4ydT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ydS() //  [R1]
         { info_tbl: [(c4ydS,
                       label: block_c4ydS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ydS: // global
           I64[Sp] = block_c4ydY_info;
           _s4vMa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vMa::I64;
           if (R1 & 7 != 0) goto u4yep; else goto c4ye2;
       u4yep: // global
           call _c4ydY(R1) args: 0, res: 0, upd: 0;
       c4ye2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ydY() //  [R1]
         { info_tbl: [(c4ydY,
                       label: block_c4ydY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ydY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ye8; else goto c4ye7;
       c4ye8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ye7: // global
           _s4vMa::I64 = I64[Sp + 8];
           _s4vMc::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vMc::I64, 64)) goto c4yeh; else goto c4yeo;
       c4yeh: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vMa::I64, _s4vMc::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yeo: // global
           if (%MO_S_Ge_W64(_s4vMa::I64, 0)) goto c4yem; else goto c4yen;
       c4yem: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yen: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.343096462 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4yeS,
                       label: GHC.Int.$fBitsInt64_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yeS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yf4; else goto c4yf5;
       c4yf4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yf5: // global
           I64[Sp - 16] = block_c4yeP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yfb; else goto c4yeQ;
       u4yfb: // global
           call _c4yeP(R1) args: 0, res: 0, upd: 0;
       c4yeQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yeP() //  [R1]
         { info_tbl: [(c4yeP,
                       label: block_c4yeP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yeP: // global
           I64[Sp] = block_c4yeV_info;
           _s4vMj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vMj::I64;
           if (R1 & 7 != 0) goto u4yfa; else goto c4yeW;
       u4yfa: // global
           call _c4yeV(R1) args: 0, res: 0, upd: 0;
       c4yeW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yeV() //  [R1]
         { info_tbl: [(c4yeV,
                       label: block_c4yeV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yeV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yf9; else goto c4yf8;
       c4yf9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yf8: // global
           _s4vMm::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vMm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.351639353 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftL_closure" {
     GHC.Int.$fBitsInt64_$cshiftL_closure:
         const GHC.Int.$fBitsInt64_$cshiftL_info;
 },
 GHC.Int.$fBitsInt64_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4yfB,
                       label: GHC.Int.$fBitsInt64_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yfB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yfF; else goto c4yfG;
       c4yfF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yfG: // global
           I64[Sp - 16] = block_c4yfy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yg0; else goto c4yfz;
       u4yg0: // global
           call _c4yfy(R1) args: 0, res: 0, upd: 0;
       c4yfz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yfy() //  [R1]
         { info_tbl: [(c4yfy,
                       label: block_c4yfy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yfy: // global
           I64[Sp] = block_c4yfE_info;
           _s4vMq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vMq::I64;
           if (R1 & 7 != 0) goto u4yfZ; else goto c4yfI;
       u4yfZ: // global
           call _c4yfE(R1) args: 0, res: 0, upd: 0;
       c4yfI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yfE() //  [R1]
         { info_tbl: [(c4yfE,
                       label: block_c4yfE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yfE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yfO; else goto c4yfN;
       c4yfO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yfN: // global
           _s4vMs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vMs::I64, 64)) goto c4yfX; else goto c4yfY;
       c4yfX: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s4vMs::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yfY: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.360688341 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cisSigned_closure" {
     GHC.Int.$fBitsInt64_$cisSigned_closure:
         const GHC.Int.$fBitsInt64_$cisSigned_info;
 },
 GHC.Int.$fBitsInt64_$cisSigned_entry() //  []
         { info_tbl: [(c4ygo,
                       label: GHC.Int.$fBitsInt64_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ygo: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.364885339 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotate_closure" {
     GHC.Int.$fBitsInt64_$crotate_closure:
         const GHC.Int.$fBitsInt64_$crotate_info;
 },
 GHC.Int.$fBitsInt64_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4ygE,
                       label: GHC.Int.$fBitsInt64_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ygE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ygI; else goto c4ygJ;
       c4ygI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ygJ: // global
           I64[Sp - 16] = block_c4ygB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yhz; else goto c4ygC;
       u4yhz: // global
           call _c4ygB(R1) args: 0, res: 0, upd: 0;
       c4ygC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ygB() //  [R1]
         { info_tbl: [(c4ygB,
                       label: block_c4ygB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ygB: // global
           I64[Sp - 8] = block_c4ygH_info;
           _s4vMy::P64 = R1;
           _s4vMz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vMz::I64;
           P64[Sp + 8] = _s4vMy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yhy; else goto c4ygL;
       u4yhy: // global
           call _c4ygH(R1) args: 0, res: 0, upd: 0;
       c4ygL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ygH() //  [R1]
         { info_tbl: [(c4ygH,
                       label: block_c4ygH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ygH: // global
           _s4vME::I64 = I64[R1 + 7] & 63;
           if (_s4vME::I64 != 0) goto u4yhw; else goto c4yhs;
       u4yhw: // global
           I64[Sp + 16] = _s4vME::I64;
           Sp = Sp + 8;
           call _c4yh0() args: 0, res: 0, upd: 0;
       c4yhs: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4yh0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yh0: // global
           Hp = Hp + 16;
           _s4vME::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4yhp; else goto c4yho;
       c4yhp: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4ygZ_info;
           R1 = _s4vME::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4yho: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4vMF::I64 = I64[Sp];
           I64[Hp] = (_s4vMF::I64 << _s4vME::I64) | (_s4vMF::I64 >> 64 - _s4vME::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4ygZ() //  [R1]
         { info_tbl: [(c4ygZ,
                       label: block_c4ygZ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ygZ: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4yh0() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.376939456 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshift_closure" {
     GHC.Int.$fBitsInt64_$cshift_closure:
         const GHC.Int.$fBitsInt64_$cshift_info;
 },
 GHC.Int.$fBitsInt64_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4yie,
                       label: GHC.Int.$fBitsInt64_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yie: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yii; else goto c4yij;
       c4yii: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yij: // global
           I64[Sp - 16] = block_c4yib_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yj3; else goto c4yic;
       u4yj3: // global
           call _c4yib(R1) args: 0, res: 0, upd: 0;
       c4yic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yib() //  [R1]
         { info_tbl: [(c4yib,
                       label: block_c4yib_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yib: // global
           I64[Sp] = block_c4yih_info;
           _s4vMO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vMO::I64;
           if (R1 & 7 != 0) goto u4yj2; else goto c4yil;
       u4yj2: // global
           call _c4yih(R1) args: 0, res: 0, upd: 0;
       c4yil: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yih() //  [R1]
         { info_tbl: [(c4yih,
                       label: block_c4yih_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yih: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yir; else goto c4yiq;
       c4yir: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yiq: // global
           _s4vMO::I64 = I64[Sp + 8];
           _s4vMQ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vMQ::I64, 0)) goto c4yiP; else goto c4yj1;
       c4yiP: // global
           _s4vMS::I64 = -_s4vMQ::I64;
           if (%MO_S_Lt_W64(_s4vMS::I64, 64)) goto c4yiG; else goto c4yiN;
       c4yiG: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vMO::I64, _s4vMS::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yiN: // global
           if (%MO_S_Ge_W64(_s4vMO::I64, 0)) goto c4yj0; else goto c4yiM;
       c4yiM: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yj1: // global
           if (%MO_S_Ge_W64(_s4vMQ::I64, 64)) goto c4yj0; else goto c4yiZ;
       c4yj0: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yiZ: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vMO::I64 << _s4vMQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.386350208 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplement_closure" {
     GHC.Int.$fBitsInt64_$ccomplement_closure:
         const GHC.Int.$fBitsInt64_$ccomplement_info;
 },
 GHC.Int.$fBitsInt64_$ccomplement_entry() //  [R2]
         { info_tbl: [(c4yjy,
                       label: GHC.Int.$fBitsInt64_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yjy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yjL; else goto c4yjM;
       c4yjL: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yjM: // global
           I64[Sp - 8] = block_c4yjv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yjQ; else goto c4yjw;
       u4yjQ: // global
           call _c4yjv(R1) args: 0, res: 0, upd: 0;
       c4yjw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yjv() //  [R1]
         { info_tbl: [(c4yjv,
                       label: block_c4yjv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yjv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yjP; else goto c4yjO;
       c4yjP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yjO: // global
           _s4vN3::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vN3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.39272662 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cxor_closure" {
     GHC.Int.$fBitsInt64_$cxor_closure:
         const GHC.Int.$fBitsInt64_$cxor_info;
 },
 GHC.Int.$fBitsInt64_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4ykb,
                       label: GHC.Int.$fBitsInt64_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ykb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ykw; else goto c4ykx;
       c4ykw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ykx: // global
           I64[Sp - 16] = block_c4yk8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ykD; else goto c4yk9;
       u4ykD: // global
           call _c4yk8(R1) args: 0, res: 0, upd: 0;
       c4yk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yk8() //  [R1]
         { info_tbl: [(c4yk8,
                       label: block_c4yk8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yk8: // global
           I64[Sp] = block_c4yke_info;
           _s4vN7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vN7::I64;
           if (R1 & 7 != 0) goto u4ykC; else goto c4ykf;
       u4ykC: // global
           call _c4yke(R1) args: 0, res: 0, upd: 0;
       c4ykf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yke() //  [R1]
         { info_tbl: [(c4yke,
                       label: block_c4yke_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yke: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ykB; else goto c4ykA;
       c4ykB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ykA: // global
           _s4vNd::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vNd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.401765479 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.|._closure" {
     GHC.Int.$fBitsInt64_$c.|._closure:
         const GHC.Int.$fBitsInt64_$c.|._info;
 },
 GHC.Int.$fBitsInt64_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4yl4,
                       label: GHC.Int.$fBitsInt64_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yl4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ylp; else goto c4ylq;
       c4ylp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ylq: // global
           I64[Sp - 16] = block_c4yl1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ylw; else goto c4yl2;
       u4ylw: // global
           call _c4yl1(R1) args: 0, res: 0, upd: 0;
       c4yl2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yl1() //  [R1]
         { info_tbl: [(c4yl1,
                       label: block_c4yl1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yl1: // global
           I64[Sp] = block_c4yl7_info;
           _s4vNh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vNh::I64;
           if (R1 & 7 != 0) goto u4ylv; else goto c4yl8;
       u4ylv: // global
           call _c4yl7(R1) args: 0, res: 0, upd: 0;
       c4yl8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yl7() //  [R1]
         { info_tbl: [(c4yl7,
                       label: block_c4yl7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yl7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ylu; else goto c4ylt;
       c4ylu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ylt: // global
           _s4vNn::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vNn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.410124409 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.&._closure" {
     GHC.Int.$fBitsInt64_$c.&._closure:
         const GHC.Int.$fBitsInt64_$c.&._info;
 },
 GHC.Int.$fBitsInt64_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4ylX,
                       label: GHC.Int.$fBitsInt64_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ylX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ymi; else goto c4ymj;
       c4ymi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ymj: // global
           I64[Sp - 16] = block_c4ylU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ymp; else goto c4ylV;
       u4ymp: // global
           call _c4ylU(R1) args: 0, res: 0, upd: 0;
       c4ylV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ylU() //  [R1]
         { info_tbl: [(c4ylU,
                       label: block_c4ylU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ylU: // global
           I64[Sp] = block_c4ym0_info;
           _s4vNr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vNr::I64;
           if (R1 & 7 != 0) goto u4ymo; else goto c4ym1;
       u4ymo: // global
           call _c4ym0(R1) args: 0, res: 0, upd: 0;
       c4ym1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ym0() //  [R1]
         { info_tbl: [(c4ym0,
                       label: block_c4ym0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ym0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ymn; else goto c4ymm;
       c4ymn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ymm: // global
           _s4vNx::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vNx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.418867863 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c4ymQ,
                       label: GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ymQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yn4; else goto c4yn5;
       c4yn4: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yn5: // global
           I64[Sp - 8] = block_c4ymN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yn9; else goto c4ymO;
       u4yn9: // global
           call _c4ymN(R1) args: 0, res: 0, upd: 0;
       c4ymO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ymN() //  [R1]
         { info_tbl: [(c4ymN,
                       label: block_c4ymN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ymN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yn8; else goto c4yn7;
       c4yn8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yn7: // global
           (_c4ymW::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4ymW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.425551914 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c4ynv,
                       label: GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ynv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ynJ; else goto c4ynK;
       c4ynJ: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ynK: // global
           I64[Sp - 8] = block_c4yns_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ynO; else goto c4ynt;
       u4ynO: // global
           call _c4yns(R1) args: 0, res: 0, upd: 0;
       c4ynt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yns() //  [R1]
         { info_tbl: [(c4yns,
                       label: block_c4yns_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yns: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ynN; else goto c4ynM;
       c4ynN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ynM: // global
           (_c4ynB::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4ynB::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.431427577 UTC

[section ""data" . GHC.Int.$fBitsInt7_closure" {
     GHC.Int.$fBitsInt7_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.433685669 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt64_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt64_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c4yo8,
                       label: GHC.Int.$fBitsInt64_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yo8: // global
           R1 = GHC.Int.$fBitsInt7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.438309577 UTC

[section ""data" . GHC.Int.eqInt8_closure" {
     GHC.Int.eqInt8_closure:
         const GHC.Int.eqInt8_info;
 },
 GHC.Int.eqInt8_entry() //  [R2, R3]
         { info_tbl: [(c4yon,
                       label: GHC.Int.eqInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yon: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yor; else goto c4yos;
       c4yor: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yos: // global
           I64[Sp - 16] = block_c4yok_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yoB; else goto c4yol;
       u4yoB: // global
           call _c4yok(R1) args: 0, res: 0, upd: 0;
       c4yol: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yok() //  [R1]
         { info_tbl: [(c4yok,
                       label: block_c4yok_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yok: // global
           I64[Sp] = block_c4yoq_info;
           _s4vNO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vNO::I64;
           if (R1 & 7 != 0) goto u4yoA; else goto c4you;
       u4yoA: // global
           call _c4yoq(R1) args: 0, res: 0, upd: 0;
       c4you: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yoq() //  [R1]
         { info_tbl: [(c4yoq,
                       label: block_c4yoq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yoq: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.446006595 UTC

[section ""data" . GHC.Int.$fEqInt8_closure" {
     GHC.Int.$fEqInt8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt8_closure+2;
         const GHC.Int.neInt8_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.448245672 UTC

[section ""data" . GHC.Int.gtInt8_closure" {
     GHC.Int.gtInt8_closure:
         const GHC.Int.gtInt8_info;
 },
 GHC.Int.gtInt8_entry() //  [R2, R3]
         { info_tbl: [(c4yp4,
                       label: GHC.Int.gtInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yp4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yp8; else goto c4yp9;
       c4yp8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yp9: // global
           I64[Sp - 16] = block_c4yp1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ypi; else goto c4yp2;
       u4ypi: // global
           call _c4yp1(R1) args: 0, res: 0, upd: 0;
       c4yp2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yp1() //  [R1]
         { info_tbl: [(c4yp1,
                       label: block_c4yp1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yp1: // global
           I64[Sp] = block_c4yp7_info;
           _s4vNV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vNV::I64;
           if (R1 & 7 != 0) goto u4yph; else goto c4ypb;
       u4yph: // global
           call _c4yp7(R1) args: 0, res: 0, upd: 0;
       c4ypb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yp7() //  [R1]
         { info_tbl: [(c4yp7,
                       label: block_c4yp7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yp7: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.458377804 UTC

[section ""data" . GHC.Int.geInt8_closure" {
     GHC.Int.geInt8_closure:
         const GHC.Int.geInt8_info;
 },
 GHC.Int.geInt8_entry() //  [R2, R3]
         { info_tbl: [(c4ypK,
                       label: GHC.Int.geInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ypK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ypO; else goto c4ypP;
       c4ypO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ypP: // global
           I64[Sp - 16] = block_c4ypH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ypY; else goto c4ypI;
       u4ypY: // global
           call _c4ypH(R1) args: 0, res: 0, upd: 0;
       c4ypI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ypH() //  [R1]
         { info_tbl: [(c4ypH,
                       label: block_c4ypH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ypH: // global
           I64[Sp] = block_c4ypN_info;
           _s4vO2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vO2::I64;
           if (R1 & 7 != 0) goto u4ypX; else goto c4ypR;
       u4ypX: // global
           call _c4ypN(R1) args: 0, res: 0, upd: 0;
       c4ypR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ypN() //  [R1]
         { info_tbl: [(c4ypN,
                       label: block_c4ypN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ypN: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.469620503 UTC

[section ""data" . GHC.Int.ltInt8_closure" {
     GHC.Int.ltInt8_closure:
         const GHC.Int.ltInt8_info;
 },
 GHC.Int.ltInt8_entry() //  [R2, R3]
         { info_tbl: [(c4yqq,
                       label: GHC.Int.ltInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yqq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yqu; else goto c4yqv;
       c4yqu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yqv: // global
           I64[Sp - 16] = block_c4yqn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yqE; else goto c4yqo;
       u4yqE: // global
           call _c4yqn(R1) args: 0, res: 0, upd: 0;
       c4yqo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yqn() //  [R1]
         { info_tbl: [(c4yqn,
                       label: block_c4yqn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yqn: // global
           I64[Sp] = block_c4yqt_info;
           _s4vO9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vO9::I64;
           if (R1 & 7 != 0) goto u4yqD; else goto c4yqx;
       u4yqD: // global
           call _c4yqt(R1) args: 0, res: 0, upd: 0;
       c4yqx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yqt() //  [R1]
         { info_tbl: [(c4yqt,
                       label: block_c4yqt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yqt: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.47750872 UTC

[section ""data" . GHC.Int.leInt8_closure" {
     GHC.Int.leInt8_closure:
         const GHC.Int.leInt8_info;
 },
 GHC.Int.leInt8_entry() //  [R2, R3]
         { info_tbl: [(c4yr6,
                       label: GHC.Int.leInt8_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yr6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yra; else goto c4yrb;
       c4yra: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yrb: // global
           I64[Sp - 16] = block_c4yr3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yrk; else goto c4yr4;
       u4yrk: // global
           call _c4yr3(R1) args: 0, res: 0, upd: 0;
       c4yr4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yr3() //  [R1]
         { info_tbl: [(c4yr3,
                       label: block_c4yr3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yr3: // global
           I64[Sp] = block_c4yr9_info;
           _s4vOg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vOg::I64;
           if (R1 & 7 != 0) goto u4yrj; else goto c4yrd;
       u4yrj: // global
           call _c4yr9(R1) args: 0, res: 0, upd: 0;
       c4yrd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yr9() //  [R1]
         { info_tbl: [(c4yr9,
                       label: block_c4yr9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yr9: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.486908333 UTC

[section ""data" . GHC.Int.$fOrdInt8_$ccompare_closure" {
     GHC.Int.$fOrdInt8_$ccompare_closure:
         const GHC.Int.$fOrdInt8_$ccompare_info;
 },
 GHC.Int.$fOrdInt8_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4yrM,
                       label: GHC.Int.$fOrdInt8_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yrM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yrQ; else goto c4yrR;
       c4yrQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yrR: // global
           I64[Sp - 16] = block_c4yrJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ysa; else goto c4yrK;
       u4ysa: // global
           call _c4yrJ(R1) args: 0, res: 0, upd: 0;
       c4yrK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yrJ() //  [R1]
         { info_tbl: [(c4yrJ,
                       label: block_c4yrJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yrJ: // global
           I64[Sp] = block_c4yrP_info;
           _s4vOn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vOn::I64;
           if (R1 & 7 != 0) goto u4ys9; else goto c4yrT;
       u4ys9: // global
           call _c4yrP(R1) args: 0, res: 0, upd: 0;
       c4yrT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yrP() //  [R1]
         { info_tbl: [(c4yrP,
                       label: block_c4yrP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yrP: // global
           _s4vOn::I64 = I64[Sp + 8];
           _s4vOp::I64 = I64[R1 + 7];
           if (_s4vOn::I64 == _s4vOp::I64) goto c4ys8; else goto c4ys7;
       c4ys8: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ys7: // global
           if (%MO_S_Gt_W64(_s4vOn::I64,
                            _s4vOp::I64)) goto c4ys4; else goto c4ys5;
       c4ys4: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ys5: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.495349716 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmax_closure" {
     GHC.Int.$fOrdInt8_$cmax_closure:
         const GHC.Int.$fOrdInt8_$cmax_info;
 },
 GHC.Int.$fOrdInt8_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4ysD,
                       label: GHC.Int.$fOrdInt8_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ysD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ysH; else goto c4ysI;
       c4ysH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ysI: // global
           I64[Sp - 16] = block_c4ysA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ysV; else goto c4ysB;
       u4ysV: // global
           call _c4ysA(R1) args: 0, res: 0, upd: 0;
       c4ysB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ysA() //  [R1]
         { info_tbl: [(c4ysA,
                       label: block_c4ysA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ysA: // global
           I64[Sp - 8] = block_c4ysG_info;
           _s4vOu::P64 = R1;
           _s4vOv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vOv::I64;
           P64[Sp + 8] = _s4vOu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ysU; else goto c4ysK;
       u4ysU: // global
           call _c4ysG(R1) args: 0, res: 0, upd: 0;
       c4ysK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ysG() //  [R1]
         { info_tbl: [(c4ysG,
                       label: block_c4ysG_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ysG: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4ysS; else goto c4ysT;
       c4ysS: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ysT: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.504525966 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmin_closure" {
     GHC.Int.$fOrdInt8_$cmin_closure:
         const GHC.Int.$fOrdInt8_$cmin_info;
 },
 GHC.Int.$fOrdInt8_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4ytn,
                       label: GHC.Int.$fOrdInt8_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ytn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ytr; else goto c4yts;
       c4ytr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yts: // global
           I64[Sp - 16] = block_c4ytk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ytF; else goto c4ytl;
       u4ytF: // global
           call _c4ytk(R1) args: 0, res: 0, upd: 0;
       c4ytl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ytk() //  [R1]
         { info_tbl: [(c4ytk,
                       label: block_c4ytk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ytk: // global
           I64[Sp - 8] = block_c4ytq_info;
           _s4vOB::P64 = R1;
           _s4vOC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vOC::I64;
           P64[Sp + 8] = _s4vOB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ytE; else goto c4ytu;
       u4ytE: // global
           call _c4ytq(R1) args: 0, res: 0, upd: 0;
       c4ytu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ytq() //  [R1]
         { info_tbl: [(c4ytq,
                       label: block_c4ytq_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ytq: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4ytC; else goto c4ytD;
       c4ytC: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ytD: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.512036516 UTC

[section ""data" . GHC.Int.$fOrdInt8_closure" {
     GHC.Int.$fOrdInt8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fOrdInt8_$ccompare_closure+2;
         const GHC.Int.ltInt8_closure+2;
         const GHC.Int.leInt8_closure+2;
         const GHC.Int.gtInt8_closure+2;
         const GHC.Int.geInt8_closure+2;
         const GHC.Int.$fOrdInt8_$cmax_closure+2;
         const GHC.Int.$fOrdInt8_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.514743541 UTC

[section ""data" . GHC.Int.$fIxInt8_$cinRange_closure" {
     GHC.Int.$fIxInt8_$cinRange_closure:
         const GHC.Int.$fIxInt8_$cinRange_info;
 },
 GHC.Int.$fIxInt8_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4yu8,
                       label: GHC.Int.$fIxInt8_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yu8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yuh; else goto c4yui;
       c4yuh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yui: // global
           I64[Sp - 16] = block_c4yu5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yuF; else goto c4yu6;
       u4yuF: // global
           call _c4yu5(R1) args: 0, res: 0, upd: 0;
       c4yu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yu5() //  [R1]
         { info_tbl: [(c4yu5,
                       label: block_c4yu5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yu5: // global
           I64[Sp - 8] = block_c4yub_info;
           _s4vOK::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4vOK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yuE; else goto c4yuc;
       u4yuE: // global
           call _c4yub(R1) args: 0, res: 0, upd: 0;
       c4yuc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yub() //  [R1]
         { info_tbl: [(c4yub,
                       label: block_c4yub_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yub: // global
           I64[Sp] = block_c4yug_info;
           _s4vOM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vOM::I64;
           if (R1 & 7 != 0) goto u4yuG; else goto c4yul;
       u4yuG: // global
           call _c4yug(R1) args: 0, res: 0, upd: 0;
       c4yul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yug() //  [R1]
         { info_tbl: [(c4yug,
                       label: block_c4yug_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yug: // global
           _s4vOO::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4vOO::I64)) goto c4yut; else goto c4yux;
       c4yut: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yux: // global
           _s4vOK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4yuw_info;
           R1 = _s4vOK::P64;
           I64[Sp + 16] = _s4vOO::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4yuH; else goto c4yuy;
       u4yuH: // global
           call _c4yuw(R1) args: 0, res: 0, upd: 0;
       c4yuy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yuw() //  [R1]
         { info_tbl: [(c4yuw,
                       label: block_c4yuw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yuw: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.52716339 UTC

[section ""data" . GHC.Int.$fNumInt7_closure" {
     GHC.Int.$fNumInt7_closure:
         const GHC.Int.I8#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.529398017 UTC

[section ""data" . GHC.Int.$fNumInt8_$csignum_closure" {
     GHC.Int.$fNumInt8_$csignum_closure:
         const GHC.Int.$fNumInt8_$csignum_info;
 },
 GHC.Int.$fNumInt8_$csignum_entry() //  [R2]
         { info_tbl: [(c4yvm,
                       label: GHC.Int.$fNumInt8_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yvm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yvn; else goto c4yvo;
       c4yvn: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yvo: // global
           I64[Sp - 8] = block_c4yvj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yvC; else goto c4yvk;
       u4yvC: // global
           call _c4yvj(R1) args: 0, res: 0, upd: 0;
       c4yvk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yvj() //  [R1]
         { info_tbl: [(c4yvj,
                       label: block_c4yvj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yvj: // global
           _s4vOV::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4vOV::I64, 0)) goto c4yvA; else goto c4yvB;
       c4yvA: // global
           if (_s4vOV::I64 == 0) goto c4yvy; else goto c4yvx;
       c4yvy: // global
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yvx: // global
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yvB: // global
           R1 = GHC.Int.$fNumInt7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.535949797 UTC

[section ""data" . GHC.Int.$fNumInt8_$cabs_closure" {
     GHC.Int.$fNumInt8_$cabs_closure:
         const GHC.Int.$fNumInt8_$cabs_info;
 },
 GHC.Int.$fNumInt8_$cabs_entry() //  [R2]
         { info_tbl: [(c4yvX,
                       label: GHC.Int.$fNumInt8_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yvX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yvY; else goto c4yvZ;
       c4yvY: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yvZ: // global
           I64[Sp - 8] = block_c4yvU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ywi; else goto c4yvV;
       u4ywi: // global
           call _c4yvU(R1) args: 0, res: 0, upd: 0;
       c4yvV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yvU() //  [R1]
         { info_tbl: [(c4yvU,
                       label: block_c4yvU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yvU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yw4; else goto c4yw3;
       c4yw4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yw3: // global
           _s4vP0::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vP0::I64, 0)) goto c4ywg; else goto c4ywh;
       c4ywg: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-_s4vP0::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ywh: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.542817969 UTC

[section ""data" . GHC.Int.$fNumInt8_closure" {
     GHC.Int.$fNumInt8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt8_$c+_closure+2;
         const GHC.Int.$fNumInt8_$c-_closure+2;
         const GHC.Int.$fNumInt8_$c*_closure+2;
         const GHC.Int.$fNumInt8_$cnegate_closure+1;
         const GHC.Int.$fNumInt8_$cabs_closure+1;
         const GHC.Int.$fNumInt8_$csignum_closure+1;
         const GHC.Int.$fNumInt8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.544917529 UTC

[section ""data" . GHC.Int.$fBitsInt12_closure" {
     GHC.Int.$fBitsInt12_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt11_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.547547035 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt8_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4ywF,
                       label: GHC.Int.$fBitsInt8_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ywF: // global
           R1 = GHC.Int.$fBitsInt12_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.552537965 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbit_closure" {
     GHC.Int.$fBitsInt8_$cbit_closure:
         const GHC.Int.$fBitsInt8_$cbit_info;
 },
 GHC.Int.$fBitsInt8_$cbit_entry() //  [R2]
         { info_tbl: [(c4ywU,
                       label: GHC.Int.$fBitsInt8_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ywU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ywV; else goto c4ywW;
       c4ywV: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ywW: // global
           I64[Sp - 8] = block_c4ywR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yxf; else goto c4ywS;
       u4yxf: // global
           call _c4ywR(R1) args: 0, res: 0, upd: 0;
       c4ywS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ywR() //  [R1]
         { info_tbl: [(c4ywR,
                       label: block_c4ywR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ywR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yx1; else goto c4yx0;
       c4yx1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yx0: // global
           _s4vP7::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vP7::I64, 64)) goto c4yxd; else goto c4yxe;
       c4yxd: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4vP7::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yxe: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.563041814 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ctestBit_closure" {
     GHC.Int.$fBitsInt8_$ctestBit_closure:
         const GHC.Int.$fBitsInt8_$ctestBit_info;
 },
 GHC.Int.$fBitsInt8_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4yxD,
                       label: GHC.Int.$fBitsInt8_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yxD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yxH; else goto c4yxI;
       c4yxH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yxI: // global
           I64[Sp - 16] = block_c4yxA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yyq; else goto c4yxB;
       u4yyq: // global
           call _c4yxA(R1) args: 0, res: 0, upd: 0;
       c4yxB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yxA() //  [R1]
         { info_tbl: [(c4yxA,
                       label: block_c4yxA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yxA: // global
           I64[Sp] = block_c4yxG_info;
           _s4vPe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vPe::I64;
           if (R1 & 7 != 0) goto u4yyp; else goto c4yxK;
       u4yyp: // global
           call _c4yxG(R1) args: 0, res: 0, upd: 0;
       c4yxK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yxG() //  [R1]
         { info_tbl: [(c4yxG,
                       label: block_c4yxG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yxG: // global
           _s4vPg::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4vPg::I64, 64)) goto c4yyo; else goto c4yyn;
       c4yyn: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4vPg::I64)) == 0) goto c4yyo; else goto c4yyc;
       c4yyo: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yyc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.576688741 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateR_closure" {
     GHC.Int.$fBitsInt8_$crotateR_closure:
         const GHC.Int.$fBitsInt8_$crotateR_info;
 },
 GHC.Int.$fBitsInt8_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4yyW,
                       label: GHC.Int.$fBitsInt8_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yyW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yz0; else goto c4yz1;
       c4yz0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yz1: // global
           I64[Sp - 16] = block_c4yyT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yA0; else goto c4yyU;
       u4yA0: // global
           call _c4yyT(R1) args: 0, res: 0, upd: 0;
       c4yyU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yyT() //  [R1]
         { info_tbl: [(c4yyT,
                       label: block_c4yyT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yyT: // global
           I64[Sp - 8] = block_c4yyZ_info;
           _s4vPq::P64 = R1;
           _s4vPr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vPr::I64;
           P64[Sp + 8] = _s4vPq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yzZ; else goto c4yz3;
       u4yzZ: // global
           call _c4yyZ(R1) args: 0, res: 0, upd: 0;
       c4yz3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yyZ() //  [R1]
         { info_tbl: [(c4yyZ,
                       label: block_c4yyZ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yyZ: // global
           _s4vPx::I64 = -I64[R1 + 7] & 7;
           if (_s4vPx::I64 != 0) goto u4yzX; else goto c4yzT;
       u4yzX: // global
           I64[Sp + 16] = _s4vPx::I64;
           Sp = Sp + 8;
           call _c4yzl() args: 0, res: 0, upd: 0;
       c4yzT: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4yzl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yzl: // global
           Hp = Hp + 16;
           _s4vPx::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4yzQ; else goto c4yzP;
       c4yzQ: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4yzk_info;
           R1 = _s4vPx::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4yzP: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4vPy::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4vPy::I64 << _s4vPx::I64) | (_s4vPy::I64 >> 8 - _s4vPx::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4yzk() //  [R1]
         { info_tbl: [(c4yzk,
                       label: block_c4yzk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yzk: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4yzl() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.591629434 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt8_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt8_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt8_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4yAH,
                       label: GHC.Int.$fBitsInt8_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yAH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yAL; else goto c4yAM;
       c4yAL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yAM: // global
           I64[Sp - 16] = block_c4yAE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yBl; else goto c4yAF;
       u4yBl: // global
           call _c4yAE(R1) args: 0, res: 0, upd: 0;
       c4yAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yAE() //  [R1]
         { info_tbl: [(c4yAE,
                       label: block_c4yAE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yAE: // global
           I64[Sp - 8] = block_c4yAK_info;
           _s4vPI::P64 = R1;
           _s4vPJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vPJ::I64;
           P64[Sp + 8] = _s4vPI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yBk; else goto c4yAO;
       u4yBk: // global
           call _c4yAK(R1) args: 0, res: 0, upd: 0;
       c4yAO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yAK() //  [R1]
         { info_tbl: [(c4yAK,
                       label: block_c4yAK_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yAK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yAU; else goto c4yAT;
       c4yAU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yAT: // global
           _s4vPL::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vPL::I64, 64)) goto c4yBi; else goto c4yBj;
       c4yBi: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4vPL::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yBj: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.602692946 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cclearBit_closure" {
     GHC.Int.$fBitsInt8_$cclearBit_closure:
         const GHC.Int.$fBitsInt8_$cclearBit_info;
 },
 GHC.Int.$fBitsInt8_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4yBR,
                       label: GHC.Int.$fBitsInt8_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yBR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yBV; else goto c4yBW;
       c4yBV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yBW: // global
           I64[Sp - 16] = block_c4yBO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yCJ; else goto c4yBP;
       u4yCJ: // global
           call _c4yBO(R1) args: 0, res: 0, upd: 0;
       c4yBP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yBO() //  [R1]
         { info_tbl: [(c4yBO,
                       label: block_c4yBO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yBO: // global
           I64[Sp] = block_c4yBU_info;
           _s4vPW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vPW::I64;
           if (R1 & 7 != 0) goto u4yCI; else goto c4yBY;
       u4yCI: // global
           call _c4yBU(R1) args: 0, res: 0, upd: 0;
       c4yBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yBU() //  [R1]
         { info_tbl: [(c4yBU,
                       label: block_c4yBU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yBU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yC4; else goto c4yC3;
       c4yC4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yC3: // global
           _s4vPW::I64 = I64[Sp + 8];
           _s4vPY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vPY::I64, 64)) goto c4yCv; else goto c4yCH;
       c4yCv: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vPW::I64 & ~%MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4vPY::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yCH: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vPW::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.611411058 UTC

[section ""data" . GHC.Int.$fBitsInt8_$csetBit_closure" {
     GHC.Int.$fBitsInt8_$csetBit_closure:
         const GHC.Int.$fBitsInt8_$csetBit_info;
 },
 GHC.Int.$fBitsInt8_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4yDh,
                       label: GHC.Int.$fBitsInt8_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yDh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yDl; else goto c4yDm;
       c4yDl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yDm: // global
           I64[Sp - 16] = block_c4yDe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yDV; else goto c4yDf;
       u4yDV: // global
           call _c4yDe(R1) args: 0, res: 0, upd: 0;
       c4yDf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yDe() //  [R1]
         { info_tbl: [(c4yDe,
                       label: block_c4yDe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yDe: // global
           I64[Sp - 8] = block_c4yDk_info;
           _s4vQc::P64 = R1;
           _s4vQd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vQd::I64;
           P64[Sp + 8] = _s4vQc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yDU; else goto c4yDo;
       u4yDU: // global
           call _c4yDk(R1) args: 0, res: 0, upd: 0;
       c4yDo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yDk() //  [R1]
         { info_tbl: [(c4yDk,
                       label: block_c4yDk_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yDk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yDu; else goto c4yDt;
       c4yDu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yDt: // global
           _s4vQf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vQf::I64, 64)) goto c4yDS; else goto c4yDT;
       c4yDS: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4vQf::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yDT: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.62040592 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateL_closure" {
     GHC.Int.$fBitsInt8_$crotateL_closure:
         const GHC.Int.$fBitsInt8_$crotateL_info;
 },
 GHC.Int.$fBitsInt8_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4yEo,
                       label: GHC.Int.$fBitsInt8_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yEo: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt8_$crotate_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.623770859 UTC

[section ""data" . GHC.Int.$fBitsInt8_closure" {
     GHC.Int.$fBitsInt8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fBitsInt8_$c.&._closure+2;
         const GHC.Int.$fBitsInt8_$c.|._closure+2;
         const GHC.Int.$fBitsInt8_$cxor_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt8_$cshift_closure+2;
         const GHC.Int.$fBitsInt8_$crotate_closure+2;
         const GHC.Int.$fBitsInt13_closure+1;
         const GHC.Int.$fBitsInt8_$cbit_closure+1;
         const GHC.Int.$fBitsInt8_$csetBit_closure+2;
         const GHC.Int.$fBitsInt8_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt8_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt8_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt8_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt8_$crotateL_closure+2;
         const GHC.Int.$fBitsInt8_$crotateR_closure+2;
         const GHC.Int.$fBitsInt8_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.626156072 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_closure" {
     GHC.Int.$fFiniteBitsInt8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt8_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.62891267 UTC

[section ""data" . GHC.Int.$fReadInt8_go_closure" {
     GHC.Int.$fReadInt8_go_closure:
         const GHC.Int.$fReadInt8_go_info;
 },
 sat_s4vQz_entry() //  [R1]
         { info_tbl: [(c4yEQ,
                       label: sat_s4vQz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yEQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yER; else goto c4yES;
       c4yER: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4yES: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vQx_entry() //  [R1]
         { info_tbl: [(c4yF0,
                       label: sat_s4vQx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yF0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yF7; else goto c4yF8;
       c4yF7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4yF8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4yEX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4yFc; else goto c4yEY;
       u4yFc: // global
           call _c4yEX(R1) args: 0, res: 0, upd: 0;
       c4yEY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4yEX() //  [R1]
         { info_tbl: [(c4yEX,
                       label: block_c4yEX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yEX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yFb; else goto c4yFa;
       c4yFb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4yFa: // global
           _s4vQw::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vQw::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt8_go_entry() //  [R2]
         { info_tbl: [(c4yFh,
                       label: GHC.Int.$fReadInt8_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yFh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yFi; else goto c4yFj;
       c4yFi: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yFj: // global
           I64[Sp - 8] = block_c4yEB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yFt; else goto c4yEC;
       u4yFt: // global
           call _c4yEB(R1) args: 0, res: 0, upd: 0;
       c4yEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yEB() //  [R1]
         { info_tbl: [(c4yEB,
                       label: block_c4yEB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yEB: // global
           if (R1 & 7 == 1) goto c4yFe; else goto c4yFf;
       c4yFe: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yFf: // global
           I64[Sp - 8] = block_c4yEH_info;
           _s4vQq::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4vQq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yFs; else goto c4yEI;
       u4yFs: // global
           call _c4yEH(R1) args: 0, res: 0, upd: 0;
       c4yEI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yEH() //  [R1]
         { info_tbl: [(c4yEH,
                       label: block_c4yEH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yEH: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4yFr; else goto c4yFq;
       c4yFr: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yFq: // global
           _s4vQs::P64 = P64[R1 + 7];
           _s4vQt::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4vQz_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4vQx_info;
           P64[Hp - 48] = _s4vQs::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4vQt::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.649082741 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadsPrec_closure" {
     GHC.Int.$fReadInt8_$creadsPrec_closure:
         const GHC.Int.$fReadInt8_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4yGk,
                       label: GHC.Int.$fReadInt8_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yGk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yGo; else goto c4yGp;
       c4yGo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yGp: // global
           I64[Sp - 16] = block_c4yGi_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4vQB::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4vQB::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4yGi() //  [R1]
         { info_tbl: [(c4yGi,
                       label: block_c4yGi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yGi: // global
           _s4vQB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4yGn_info;
           R3 = _s4vQB::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4yGn() //  [R1]
         { info_tbl: [(c4yGn,
                       label: block_c4yGn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yGn: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.656715698 UTC

[section ""data" . GHC.Int.$fReadInt13_closure" {
     GHC.Int.$fReadInt13_closure:
         const GHC.Int.$fReadInt13_info;
         const 0;
 },
 sat_s4vQG_entry() //  [R1, R2]
         { info_tbl: [(c4yGT,
                       label: sat_s4vQG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yGT: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt8_$creadsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt13_entry() //  [R2, R3]
         { info_tbl: [(c4yGZ,
                       label: GHC.Int.$fReadInt13_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yGZ: // global
           _s4vQF::P64 = R3;
           _s4vQE::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4yH0; else goto c4yH1;
       c4yH1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yH3; else goto c4yH2;
       c4yH3: // global
           HpAlloc = 16;
           goto c4yH0;
       c4yH0: // global
           R3 = _s4vQF::P64;
           R2 = _s4vQE::P64;
           R1 = GHC.Int.$fReadInt13_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yH2: // global
           I64[Hp - 8] = sat_s4vQG_info;
           P64[Hp] = _s4vQE::P64;
           I64[Sp - 8] = block_c4yGW_info;
           R3 = _s4vQF::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4yGW() //  [R1]
         { info_tbl: [(c4yGW,
                       label: block_c4yGW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yGW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yH6; else goto c4yH5;
       c4yH6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yH5: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.66498436 UTC

[section ""data" . GHC.Int.$fIxInt1_closure" {
     GHC.Int.$fIxInt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.667003178 UTC

[section ""data" . GHC.Int.$fReadInt12_closure" {
     GHC.Int.$fReadInt12_closure:
         const GHC.Int.$fReadInt12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt12_entry() //  [R1]
         { info_tbl: [(c4yHt,
                       label: GHC.Int.$fReadInt12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yHt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4yHu; else goto c4yHv;
       c4yHu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4yHv: // global
           (_c4yHq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4yHq::I64 == 0) goto c4yHs; else goto c4yHr;
       c4yHs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4yHr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4yHq::I64;
           R2 = GHC.Int.$fReadInt13_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.671230416 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadList_closure" {
     GHC.Int.$fReadInt8_$creadList_closure:
         const GHC.Int.$fReadInt8_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadList_entry() //  [R2]
         { info_tbl: [(c4yHM,
                       label: GHC.Int.$fReadInt8_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yHM: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.675032686 UTC

[section ""data" . GHC.Int.$fReadInt11_closure" {
     GHC.Int.$fReadInt11_closure:
         const GHC.Int.$fReadInt11_info;
         const 0;
 },
 GHC.Int.$fReadInt11_entry() //  [R2, R3]
         { info_tbl: [(c4yI0,
                       label: GHC.Int.$fReadInt11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yI0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yI1; else goto c4yI2;
       c4yI1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yI2: // global
           I64[Sp - 8] = block_c4yHX_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt8_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4yHX() //  [R1]
         { info_tbl: [(c4yHX,
                       label: block_c4yHX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yHX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yI5; else goto c4yI4;
       c4yI5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yI4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.680482408 UTC

[section ""data" . GHC.Int.$fReadInt8_closure" {
     GHC.Int.$fReadInt8_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt8_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt8_$creadList_closure+1;
         const GHC.Int.$fReadInt13_closure+2;
         const GHC.Int.$fReadInt11_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.683059816 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquot_closure" {
     GHC.Int.$fIntegralInt8_$cquot_closure:
         const GHC.Int.$fIntegralInt8_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4yIp,
                       label: GHC.Int.$fIntegralInt8_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yIp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yIt; else goto c4yIu;
       c4yIt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yIu: // global
           I64[Sp - 16] = block_c4yIm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yJ5; else goto c4yIn;
       u4yJ5: // global
           call _c4yIm(R1) args: 0, res: 0, upd: 0;
       c4yIn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yIm() //  [R1]
         { info_tbl: [(c4yIm,
                       label: block_c4yIm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yIm: // global
           I64[Sp] = block_c4yIs_info;
           _s4vQQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vQQ::I64;
           if (R1 & 7 != 0) goto u4yJ4; else goto c4yIw;
       u4yJ4: // global
           call _c4yIs(R1) args: 0, res: 0, upd: 0;
       c4yIw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yIs() //  [R1]
         { info_tbl: [(c4yIs,
                       label: block_c4yIs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yIs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yIC; else goto c4yIB;
       c4yIC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yIB: // global
           _s4vQQ::I64 = I64[Sp + 8];
           _s4vQT::I64 = I64[R1 + 7];
           if (_s4vQT::I64 != (-1)) goto u4yJ3; else goto c4yJ1;
       u4yJ3: // global
           if (_s4vQT::I64 != 0) goto c4yIN; else goto c4yJ2;
       c4yIN: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4vQQ::I64,
                                                                          _s4vQT::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yJ2: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yJ1: // global
           if (_s4vQQ::I64 == (-128)) goto c4yJ0; else goto c4yIZ;
       c4yJ0: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yIZ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4vQQ::I64,
                                                                          (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.694323588 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$crem_closure" {
     GHC.Int.$fIntegralInt8_$crem_closure:
         const GHC.Int.$fIntegralInt8_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4yJB,
                       label: GHC.Int.$fIntegralInt8_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yJB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yJF; else goto c4yJG;
       c4yJF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yJG: // global
           I64[Sp - 16] = block_c4yJy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yK2; else goto c4yJz;
       u4yK2: // global
           call _c4yJy(R1) args: 0, res: 0, upd: 0;
       c4yJz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yJy() //  [R1]
         { info_tbl: [(c4yJy,
                       label: block_c4yJy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yJy: // global
           I64[Sp] = block_c4yJE_info;
           _s4vR4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vR4::I64;
           if (R1 & 7 != 0) goto u4yK1; else goto c4yJI;
       u4yK1: // global
           call _c4yJE(R1) args: 0, res: 0, upd: 0;
       c4yJI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yJE() //  [R1]
         { info_tbl: [(c4yJE,
                       label: block_c4yJE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yJE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yJO; else goto c4yJN;
       c4yJO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yJN: // global
           _s4vR7::I64 = I64[R1 + 7];
           if (_s4vR7::I64 != 0) goto c4yJZ; else goto c4yK0;
       c4yJZ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Rem_W64(I64[Sp + 8],
                                                                         _s4vR7::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yK0: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.703098075 UTC

[section ""data" . GHC.Int.$w$cdiv3_closure" {
     GHC.Int.$w$cdiv3_closure:
         const GHC.Int.$w$cdiv3_info;
         const 0;
 },
 GHC.Int.$w$cdiv3_entry() //  [R2, R3]
         { info_tbl: [(c4yKv,
                       label: GHC.Int.$w$cdiv3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yKv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yKw; else goto c4yKx;
       c4yKw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yKx: // global
           if (R3 == (-1)) goto c4yKt; else goto u4yKR;
       c4yKt: // global
           if (R2 == (-128)) goto c4yKQ; else goto c4yKO;
       c4yKQ: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yKO: // global
           I64[Sp - 8] = block_c4yKI_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4yKR: // global
           if (R3 == 0) goto c4yKu; else goto c4yKs;
       c4yKu: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yKs: // global
           I64[Sp - 8] = block_c4yKz_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4yKI() //  [R1]
         { info_tbl: [(c4yKI,
                       label: block_c4yKI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yKI: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4yKz() //  [R1]
         { info_tbl: [(c4yKz,
                       label: block_c4yKz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yKz: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.71204499 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdiv_closure" {
     GHC.Int.$fIntegralInt8_$cdiv_closure:
         const GHC.Int.$fIntegralInt8_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4yLg,
                       label: GHC.Int.$fIntegralInt8_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yLg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yLt; else goto c4yLu;
       c4yLt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yLu: // global
           I64[Sp - 16] = block_c4yLd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yLB; else goto c4yLe;
       u4yLB: // global
           call _c4yLd(R1) args: 0, res: 0, upd: 0;
       c4yLe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yLd() //  [R1]
         { info_tbl: [(c4yLd,
                       label: block_c4yLd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yLd: // global
           I64[Sp] = block_c4yLj_info;
           _s4vRl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vRl::I64;
           if (R1 & 7 != 0) goto u4yLA; else goto c4yLk;
       u4yLA: // global
           call _c4yLj(R1) args: 0, res: 0, upd: 0;
       c4yLk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yLj() //  [R1]
         { info_tbl: [(c4yLj,
                       label: block_c4yLj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yLj: // global
           _s4vRl::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4yLo_info;
           R3 = I64[R1 + 7];
           R2 = _s4vRl::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4yLo() //  [R1]
         { info_tbl: [(c4yLo,
                       label: block_c4yLo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yLo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yLz; else goto c4yLy;
       c4yLz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4yLy: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.721618727 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cmod_closure" {
     GHC.Int.$fIntegralInt8_$cmod_closure:
         const GHC.Int.$fIntegralInt8_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4yM4,
                       label: GHC.Int.$fIntegralInt8_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yM4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yM8; else goto c4yM9;
       c4yM8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yM9: // global
           I64[Sp - 16] = block_c4yM1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yMx; else goto c4yM2;
       u4yMx: // global
           call _c4yM1(R1) args: 0, res: 0, upd: 0;
       c4yM2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yM1() //  [R1]
         { info_tbl: [(c4yM1,
                       label: block_c4yM1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yM1: // global
           I64[Sp] = block_c4yM7_info;
           _s4vRs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vRs::I64;
           if (R1 & 7 != 0) goto u4yMw; else goto c4yMb;
       u4yMw: // global
           call _c4yM7(R1) args: 0, res: 0, upd: 0;
       c4yMb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yM7() //  [R1]
         { info_tbl: [(c4yM7,
                       label: block_c4yM7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yM7: // global
           _s4vRv::I64 = I64[R1 + 7];
           if (_s4vRv::I64 != 0) goto c4yMr; else goto c4yMv;
       c4yMr: // global
           _s4vRs::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4yMi_info;
           R3 = _s4vRv::I64;
           R2 = _s4vRs::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4yMv: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4yMi() //  [R1]
         { info_tbl: [(c4yMi,
                       label: block_c4yMi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yMi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yMu; else goto c4yMt;
       c4yMu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4yMt: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.731400148 UTC

[section ""data" . lvl6_r4kPx_closure" {
     lvl6_r4kPx_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt13_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.733971591 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquotRem_closure" {
     GHC.Int.$fIntegralInt8_$cquotRem_closure:
         const GHC.Int.$fIntegralInt8_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4yN3,
                       label: GHC.Int.$fIntegralInt8_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yN3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yN7; else goto c4yN8;
       c4yN7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yN8: // global
           I64[Sp - 16] = block_c4yN0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yNN; else goto c4yN1;
       u4yNN: // global
           call _c4yN0(R1) args: 0, res: 0, upd: 0;
       c4yN1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yN0() //  [R1]
         { info_tbl: [(c4yN0,
                       label: block_c4yN0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yN0: // global
           I64[Sp] = block_c4yN6_info;
           _s4vRC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vRC::I64;
           if (R1 & 7 != 0) goto u4yNM; else goto c4yNa;
       u4yNM: // global
           call _c4yN6(R1) args: 0, res: 0, upd: 0;
       c4yNa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yN6() //  [R1]
         { info_tbl: [(c4yN6,
                       label: block_c4yN6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yN6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4yNg; else goto c4yNf;
       c4yNg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yNf: // global
           _s4vRC::I64 = I64[Sp + 8];
           _s4vRF::I64 = I64[R1 + 7];
           if (_s4vRF::I64 != (-1)) goto u4yNL; else goto c4yNJ;
       u4yNL: // global
           if (_s4vRF::I64 != 0) goto c4yNt; else goto c4yNK;
       c4yNt: // global
           (_s4vRH::I64, _s4vRI::I64) = call MO_S_QuotRem W64(_s4vRC::I64, _s4vRF::I64);
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vRI::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vRH::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yNK: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yNJ: // global
           if (_s4vRC::I64 == (-128)) goto c4yNI; else goto c4yNH;
       c4yNI: // global
           Hp = Hp - 56;
           R1 = lvl6_r4kPx_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yNH: // global
           (_s4vRP::I64, _s4vRQ::I64) = call MO_S_QuotRem W64(_s4vRC::I64, (-1));
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vRQ::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vRP::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.744688222 UTC

[section ""data" . GHC.Int.$w$cdivMod3_closure" {
     GHC.Int.$w$cdivMod3_closure:
         const GHC.Int.$w$cdivMod3_info;
         const 0;
 },
 GHC.Int.$w$cdivMod3_entry() //  [R2, R3]
         { info_tbl: [(c4yOx,
                       label: GHC.Int.$w$cdivMod3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yOx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yOy; else goto c4yOz;
       c4yOy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yOz: // global
           if (R3 == 0) goto c4yOw; else goto c4yOv;
       c4yOw: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yOv: // global
           if (R3 == (-1)) goto c4yR2; else goto u4yR3;
       c4yR2: // global
           if (R2 == (-128)) goto c4yR1; else goto u4yR4;
       c4yR1: // global
           R2 = GHC.Int.$fBitsInt13_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4yR4: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4yR6;
       u4yR3: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4yR6;
       u4yR6: // global
           call _c4yOE() args: 0, res: 0, upd: 0;
     }
 },
 _c4yOE() //  []
         { info_tbl: [(c4yOE,
                       label: block_c4yOE_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yOE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4yOI; else goto c4yOH;
       c4yOI: // global
           HpAlloc = 32;
           I64[Sp] = block_c4yOE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4yOH: // global
           _s4vRW::I64 = I64[Sp + 8];
           _s4vRY::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4vRW::I64, 0)) goto c4yPB; else goto c4yQS;
       c4yPB: // global
           if (%MO_S_Ge_W64(_s4vRW::I64, 0)) goto c4yOY; else goto c4yPz;
       c4yOY: // global
           (_s4vS3::I64, _s4vS4::I64) = call MO_S_QuotRem W64(_s4vRW::I64, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vS4::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vS3::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yPz: // global
           if (%MO_S_Le_W64(_s4vRY::I64, 0)) goto c4yPc; else goto c4yPy;
       c4yPc: // global
           (_s4vSb::I64, _s4vSc::I64) = call MO_S_QuotRem W64(_s4vRW::I64, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSc::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSb::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yPy: // global
           (_s4vSj::I64, _s4vSk::I64) = call MO_S_QuotRem W64(_s4vRW::I64 + 1, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSk::I64 + _s4vRY::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSj::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yQS: // global
           if (%MO_S_Ge_W64(_s4vRY::I64, 0)) goto c4yQv; else goto c4yQR;
       c4yQv: // global
           if (%MO_S_Ge_W64(_s4vRW::I64, 0)) goto c4yPS; else goto c4yQt;
       c4yPS: // global
           (_s4vSv::I64, _s4vSw::I64) = call MO_S_QuotRem W64(_s4vRW::I64, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSw::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSv::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yQt: // global
           if (%MO_S_Le_W64(_s4vRY::I64, 0)) goto c4yQ6; else goto c4yQs;
       c4yQ6: // global
           (_s4vSD::I64, _s4vSE::I64) = call MO_S_QuotRem W64(_s4vRW::I64, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSE::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSD::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yQs: // global
           (_s4vSL::I64, _s4vSM::I64) = call MO_S_QuotRem W64(_s4vRW::I64 + 1, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSM::I64 + _s4vRY::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSL::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yQR: // global
           (_s4vSW::I64, _s4vSX::I64) = call MO_S_QuotRem W64(_s4vRW::I64 - 1, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSX::I64 + _s4vRY::I64 + 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSW::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.7559568 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdivMod_closure" {
     GHC.Int.$fIntegralInt8_$cdivMod_closure:
         const GHC.Int.$fIntegralInt8_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4ySh,
                       label: GHC.Int.$fIntegralInt8_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ySh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ySs; else goto c4ySt;
       c4ySs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ySt: // global
           I64[Sp - 16] = block_c4ySe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ySA; else goto c4ySf;
       u4ySA: // global
           call _c4ySe(R1) args: 0, res: 0, upd: 0;
       c4ySf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ySe() //  [R1]
         { info_tbl: [(c4ySe,
                       label: block_c4ySe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ySe: // global
           I64[Sp] = block_c4ySk_info;
           _s4vTb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vTb::I64;
           if (R1 & 7 != 0) goto u4ySz; else goto c4ySl;
       u4ySz: // global
           call _c4ySk(R1) args: 0, res: 0, upd: 0;
       c4ySl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ySk() //  [R1]
         { info_tbl: [(c4ySk,
                       label: block_c4ySk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ySk: // global
           _s4vTb::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4ySp_info;
           R3 = I64[R1 + 7];
           R2 = _s4vTb::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ySp() //  [R1, R2]
         { info_tbl: [(c4ySp,
                       label: block_c4ySp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ySp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ySy; else goto c4ySx;
       c4ySy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ySx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.764965262 UTC

[section ""data" . sat_s4vTh_closure" {
     sat_s4vTh_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.767101168 UTC

[section ""data" . sat_s4vTi_closure" {
     sat_s4vTi_closure:
         const :_con_info;
         const sat_s4vTh_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.769685533 UTC

[section ""data" . GHC.Int.$fRealInt1_closure" {
     GHC.Int.$fRealInt1_closure:
         const GHC.Int.$fRealInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fRealInt1_entry() //  [R1]
         { info_tbl: [(c4yT4,
                       label: GHC.Int.$fRealInt1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yT4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yT5; else goto c4yT6;
       c4yT5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4yT6: // global
           (_c4yT1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4yT1::I64 == 0) goto c4yT3; else goto c4yT2;
       c4yT3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4yT2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4yT1::I64;
           R3 = sat_s4vTi_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.774407163 UTC

[section ""data" . GHC.Int.$fRealInt8_$ctoRational_closure" {
     GHC.Int.$fRealInt8_$ctoRational_closure:
         const GHC.Int.$fRealInt8_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt8_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4yTn,
                       label: GHC.Int.$fRealInt8_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yTn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yTB; else goto c4yTC;
       c4yTB: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yTC: // global
           I64[Sp - 8] = block_c4yTk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yTJ; else goto c4yTl;
       u4yTJ: // global
           call _c4yTk(R1) args: 0, res: 0, upd: 0;
       c4yTl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yTk() //  [R1]
         { info_tbl: [(c4yTk,
                       label: block_c4yTk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yTk: // global
           I64[Sp] = block_c4yTq_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4yTq() //  [R1]
         { info_tbl: [(c4yTq,
                       label: block_c4yTq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yTq: // global
           I64[Sp] = block_c4yTu_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4yTu() //  [R1]
         { info_tbl: [(c4yTu,
                       label: block_c4yTu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yTu: // global
           I64[Sp] = block_c4yTy_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4yTy() //  [R1, R2]
         { info_tbl: [(c4yTy,
                       label: block_c4yTy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yTy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4yTI; else goto c4yTH;
       c4yTI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4yTH: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.785146897 UTC

[section ""data" . GHC.Int.$fRealInt8_closure" {
     GHC.Int.$fRealInt8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt8_closure+1;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fRealInt8_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.787178202 UTC

[section ""data" . GHC.Int.$fIntegralInt8_closure" {
     GHC.Int.$fIntegralInt8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt8_closure+1;
         const GHC.Int.$fEnumInt8_closure+1;
         const GHC.Int.$fIntegralInt8_$cquot_closure+2;
         const GHC.Int.$fIntegralInt8_$crem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt8_$cmod_closure+2;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt8_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.79058448 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt8_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt8_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt8_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4yUh,
                       label: GHC.Int.$fIxInt8_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yUh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yUy; else goto c4yUz;
       c4yUy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yUz: // global
           I64[Sp - 16] = block_c4yUe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yUG; else goto c4yUf;
       u4yUG: // global
           call _c4yUe(R1) args: 0, res: 0, upd: 0;
       c4yUf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yUe() //  [R1]
         { info_tbl: [(c4yUe,
                       label: block_c4yUe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yUe: // global
           I64[Sp] = block_c4yUk_info;
           _s4vTu::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4vTu::P64;
           if (R1 & 7 != 0) goto u4yUF; else goto c4yUl;
       u4yUF: // global
           call _c4yUk(R1) args: 0, res: 0, upd: 0;
       c4yUl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yUk() //  [R1]
         { info_tbl: [(c4yUk,
                       label: block_c4yUk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yUk: // global
           I64[Sp] = block_c4yUp_info;
           _s4vTx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vTx::I64;
           if (R1 & 7 != 0) goto u4yUH; else goto c4yUq;
       u4yUH: // global
           call _c4yUp(R1) args: 0, res: 0, upd: 0;
       c4yUq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yUp() //  [R1]
         { info_tbl: [(c4yUp,
                       label: block_c4yUp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yUp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yUE; else goto c4yUD;
       c4yUE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yUD: // global
           _s4vTA::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vTA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.800340002 UTC

[section ""data" . GHC.Int.$fIxInt8_$crange_closure" {
     GHC.Int.$fIxInt8_$crange_closure:
         const GHC.Int.$fIxInt8_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$crange_entry() //  [R2]
         { info_tbl: [(c4yVd,
                       label: GHC.Int.$fIxInt8_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yVd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yVe; else goto c4yVf;
       c4yVe: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yVf: // global
           I64[Sp - 8] = block_c4yVa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yVj; else goto c4yVb;
       u4yVj: // global
           call _c4yVa(R1) args: 0, res: 0, upd: 0;
       c4yVb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yVa() //  [R1]
         { info_tbl: [(c4yVa,
                       label: block_c4yVa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yVa: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_$cenumFromTo_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.80646508 UTC

[section ""data" . GHC.Int.$fIxInt8_$crangeSize_closure" {
     GHC.Int.$fIxInt8_$crangeSize_closure:
         const GHC.Int.$fIxInt8_$crangeSize_info;
 },
 GHC.Int.$fIxInt8_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4yVB,
                       label: GHC.Int.$fIxInt8_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yVB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yVK; else goto c4yVL;
       c4yVK: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yVL: // global
           I64[Sp - 8] = block_c4yVy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yWa; else goto c4yVz;
       u4yWa: // global
           call _c4yVy(R1) args: 0, res: 0, upd: 0;
       c4yVz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yVy() //  [R1]
         { info_tbl: [(c4yVy,
                       label: block_c4yVy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yVy: // global
           I64[Sp - 8] = block_c4yVE_info;
           _s4vTI::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4vTI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yW9; else goto c4yVF;
       u4yW9: // global
           call _c4yVE(R1) args: 0, res: 0, upd: 0;
       c4yVF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yVE() //  [R1]
         { info_tbl: [(c4yVE,
                       label: block_c4yVE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yVE: // global
           I64[Sp] = block_c4yVJ_info;
           _s4vTK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vTK::I64;
           if (R1 & 7 != 0) goto u4yWb; else goto c4yVO;
       u4yWb: // global
           call _c4yVJ(R1) args: 0, res: 0, upd: 0;
       c4yVO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yVJ() //  [R1]
         { info_tbl: [(c4yVJ,
                       label: block_c4yVJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yVJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yVU; else goto c4yVT;
       c4yVU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yVT: // global
           _s4vTK::I64 = I64[Sp + 8];
           _s4vTM::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4vTK::I64,
                            _s4vTM::I64)) goto c4yVY; else goto c4yW8;
       c4yVY: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yW8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vTM::I64 - _s4vTK::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.817553793 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt8_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt8_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4yWJ,
                       label: GHC.Int.$fIxInt8_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yWJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yX3; else goto c4yX4;
       c4yX3: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yX4: // global
           I64[Sp - 8] = block_c4yWG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yXb; else goto c4yWH;
       u4yXb: // global
           call _c4yWG(R1) args: 0, res: 0, upd: 0;
       c4yWH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yWG() //  [R1]
         { info_tbl: [(c4yWG,
                       label: block_c4yWG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yWG: // global
           I64[Sp - 8] = block_c4yWM_info;
           _s4vTS::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4vTS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yXa; else goto c4yWN;
       u4yXa: // global
           call _c4yWM(R1) args: 0, res: 0, upd: 0;
       c4yWN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yWM() //  [R1]
         { info_tbl: [(c4yWM,
                       label: block_c4yWM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yWM: // global
           I64[Sp] = block_c4yWR_info;
           _s4vTV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vTV::I64;
           if (R1 & 7 != 0) goto u4yXc; else goto c4yWS;
       u4yXc: // global
           call _c4yWR(R1) args: 0, res: 0, upd: 0;
       c4yWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yWR() //  [R1]
         { info_tbl: [(c4yWR,
                       label: block_c4yWR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yWR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yX9; else goto c4yX8;
       c4yX9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yX8: // global
           _s4vTZ::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vTZ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.827721599 UTC

[section ""data" . GHC.Int.$fIxInt8_$cindex_closure" {
     GHC.Int.$fIxInt8_$cindex_closure:
         const GHC.Int.$fIxInt8_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4yXJ,
                       label: GHC.Int.$fIxInt8_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yXJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yXS; else goto c4yXT;
       c4yXS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yXT: // global
           I64[Sp - 16] = block_c4yXG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yYs; else goto c4yXH;
       u4yYs: // global
           call _c4yXG(R1) args: 0, res: 0, upd: 0;
       c4yXH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yXG() //  [R1]
         { info_tbl: [(c4yXG,
                       label: block_c4yXG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yXG: // global
           I64[Sp - 8] = block_c4yXM_info;
           _s4vU4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4vU4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yYr; else goto c4yXN;
       u4yYr: // global
           call _c4yXM(R1) args: 0, res: 0, upd: 0;
       c4yXN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yXM() //  [R1]
         { info_tbl: [(c4yXM,
                       label: block_c4yXM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yXM: // global
           I64[Sp] = block_c4yXR_info;
           _s4vU6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vU6::I64;
           if (R1 & 7 != 0) goto u4yYt; else goto c4yXW;
       u4yYt: // global
           call _c4yXR(R1) args: 0, res: 0, upd: 0;
       c4yXW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yXR() //  [R1]
         { info_tbl: [(c4yXR,
                       label: block_c4yXR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yXR: // global
           _s4vU8::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4vU8::I64)) goto c4yY4; else goto c4yY8;
       c4yY4: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4yY8: // global
           I64[Sp] = block_c4yY7_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vU8::I64;
           if (R1 & 7 != 0) goto u4yYu; else goto c4yY9;
       u4yYu: // global
           call _c4yY7(R1) args: 0, res: 0, upd: 0;
       c4yY9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yY7() //  [R1]
         { info_tbl: [(c4yY7,
                       label: block_c4yY7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yY7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yYf; else goto c4yYe;
       c4yYf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yYe: // global
           _s4vU8::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4vU8::I64,
                            I64[R1 + 7])) goto c4yYj; else goto c4yYq;
       c4yYj: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4yYq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vU8::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.840493785 UTC

[section ""data" . GHC.Int.$fIxInt8_closure" {
     GHC.Int.$fIxInt8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fIxInt8_$crange_closure+1;
         const GHC.Int.$fIxInt8_$cindex_closure+2;
         const GHC.Int.$fIxInt8_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt8_$cinRange_closure+2;
         const GHC.Int.$fIxInt8_$crangeSize_closure+1;
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.842945751 UTC

[section ""data" . GHC.Int.eqInt16_closure" {
     GHC.Int.eqInt16_closure:
         const GHC.Int.eqInt16_info;
 },
 GHC.Int.eqInt16_entry() //  [R2, R3]
         { info_tbl: [(c4yZ8,
                       label: GHC.Int.eqInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yZ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yZc; else goto c4yZd;
       c4yZc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yZd: // global
           I64[Sp - 16] = block_c4yZ5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yZm; else goto c4yZ6;
       u4yZm: // global
           call _c4yZ5(R1) args: 0, res: 0, upd: 0;
       c4yZ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yZ5() //  [R1]
         { info_tbl: [(c4yZ5,
                       label: block_c4yZ5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yZ5: // global
           I64[Sp] = block_c4yZb_info;
           _s4vUh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUh::I64;
           if (R1 & 7 != 0) goto u4yZl; else goto c4yZf;
       u4yZl: // global
           call _c4yZb(R1) args: 0, res: 0, upd: 0;
       c4yZf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yZb() //  [R1]
         { info_tbl: [(c4yZb,
                       label: block_c4yZb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yZb: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.851218869 UTC

[section ""data" . GHC.Int.$fEqInt16_closure" {
     GHC.Int.$fEqInt16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt16_closure+2;
         const GHC.Int.neInt16_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.853545115 UTC

[section ""data" . GHC.Int.gtInt16_closure" {
     GHC.Int.gtInt16_closure:
         const GHC.Int.gtInt16_info;
 },
 GHC.Int.gtInt16_entry() //  [R2, R3]
         { info_tbl: [(c4yZP,
                       label: GHC.Int.gtInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yZP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yZT; else goto c4yZU;
       c4yZT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yZU: // global
           I64[Sp - 16] = block_c4yZM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z03; else goto c4yZN;
       u4z03: // global
           call _c4yZM(R1) args: 0, res: 0, upd: 0;
       c4yZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yZM() //  [R1]
         { info_tbl: [(c4yZM,
                       label: block_c4yZM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yZM: // global
           I64[Sp] = block_c4yZS_info;
           _s4vUo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUo::I64;
           if (R1 & 7 != 0) goto u4z02; else goto c4yZW;
       u4z02: // global
           call _c4yZS(R1) args: 0, res: 0, upd: 0;
       c4yZW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4yZS() //  [R1]
         { info_tbl: [(c4yZS,
                       label: block_c4yZS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4yZS: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.861235358 UTC

[section ""data" . GHC.Int.geInt16_closure" {
     GHC.Int.geInt16_closure:
         const GHC.Int.geInt16_info;
 },
 GHC.Int.geInt16_entry() //  [R2, R3]
         { info_tbl: [(c4z0v,
                       label: GHC.Int.geInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z0v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4z0z; else goto c4z0A;
       c4z0z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z0A: // global
           I64[Sp - 16] = block_c4z0s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z0J; else goto c4z0t;
       u4z0J: // global
           call _c4z0s(R1) args: 0, res: 0, upd: 0;
       c4z0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z0s() //  [R1]
         { info_tbl: [(c4z0s,
                       label: block_c4z0s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z0s: // global
           I64[Sp] = block_c4z0y_info;
           _s4vUv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUv::I64;
           if (R1 & 7 != 0) goto u4z0I; else goto c4z0C;
       u4z0I: // global
           call _c4z0y(R1) args: 0, res: 0, upd: 0;
       c4z0C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z0y() //  [R1]
         { info_tbl: [(c4z0y,
                       label: block_c4z0y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z0y: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.869631136 UTC

[section ""data" . GHC.Int.ltInt16_closure" {
     GHC.Int.ltInt16_closure:
         const GHC.Int.ltInt16_info;
 },
 GHC.Int.ltInt16_entry() //  [R2, R3]
         { info_tbl: [(c4z1b,
                       label: GHC.Int.ltInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z1b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4z1f; else goto c4z1g;
       c4z1f: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z1g: // global
           I64[Sp - 16] = block_c4z18_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z1p; else goto c4z19;
       u4z1p: // global
           call _c4z18(R1) args: 0, res: 0, upd: 0;
       c4z19: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z18() //  [R1]
         { info_tbl: [(c4z18,
                       label: block_c4z18_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z18: // global
           I64[Sp] = block_c4z1e_info;
           _s4vUC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUC::I64;
           if (R1 & 7 != 0) goto u4z1o; else goto c4z1i;
       u4z1o: // global
           call _c4z1e(R1) args: 0, res: 0, upd: 0;
       c4z1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z1e() //  [R1]
         { info_tbl: [(c4z1e,
                       label: block_c4z1e_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z1e: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.87827214 UTC

[section ""data" . GHC.Int.leInt16_closure" {
     GHC.Int.leInt16_closure:
         const GHC.Int.leInt16_info;
 },
 GHC.Int.leInt16_entry() //  [R2, R3]
         { info_tbl: [(c4z1R,
                       label: GHC.Int.leInt16_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z1R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4z1V; else goto c4z1W;
       c4z1V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z1W: // global
           I64[Sp - 16] = block_c4z1O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z25; else goto c4z1P;
       u4z25: // global
           call _c4z1O(R1) args: 0, res: 0, upd: 0;
       c4z1P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z1O() //  [R1]
         { info_tbl: [(c4z1O,
                       label: block_c4z1O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z1O: // global
           I64[Sp] = block_c4z1U_info;
           _s4vUJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUJ::I64;
           if (R1 & 7 != 0) goto u4z24; else goto c4z1Y;
       u4z24: // global
           call _c4z1U(R1) args: 0, res: 0, upd: 0;
       c4z1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z1U() //  [R1]
         { info_tbl: [(c4z1U,
                       label: block_c4z1U_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z1U: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.886166684 UTC

[section ""data" . GHC.Int.$fOrdInt16_$ccompare_closure" {
     GHC.Int.$fOrdInt16_$ccompare_closure:
         const GHC.Int.$fOrdInt16_$ccompare_info;
 },
 GHC.Int.$fOrdInt16_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4z2x,
                       label: GHC.Int.$fOrdInt16_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z2x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4z2B; else goto c4z2C;
       c4z2B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z2C: // global
           I64[Sp - 16] = block_c4z2u_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z2V; else goto c4z2v;
       u4z2V: // global
           call _c4z2u(R1) args: 0, res: 0, upd: 0;
       c4z2v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z2u() //  [R1]
         { info_tbl: [(c4z2u,
                       label: block_c4z2u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z2u: // global
           I64[Sp] = block_c4z2A_info;
           _s4vUQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUQ::I64;
           if (R1 & 7 != 0) goto u4z2U; else goto c4z2E;
       u4z2U: // global
           call _c4z2A(R1) args: 0, res: 0, upd: 0;
       c4z2E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z2A() //  [R1]
         { info_tbl: [(c4z2A,
                       label: block_c4z2A_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z2A: // global
           _s4vUQ::I64 = I64[Sp + 8];
           _s4vUS::I64 = I64[R1 + 7];
           if (_s4vUQ::I64 == _s4vUS::I64) goto c4z2T; else goto c4z2S;
       c4z2T: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z2S: // global
           if (%MO_S_Gt_W64(_s4vUQ::I64,
                            _s4vUS::I64)) goto c4z2P; else goto c4z2Q;
       c4z2P: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z2Q: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.895460864 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmax_closure" {
     GHC.Int.$fOrdInt16_$cmax_closure:
         const GHC.Int.$fOrdInt16_$cmax_info;
 },
 GHC.Int.$fOrdInt16_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4z3o,
                       label: GHC.Int.$fOrdInt16_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z3o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4z3s; else goto c4z3t;
       c4z3s: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z3t: // global
           I64[Sp - 16] = block_c4z3l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z3G; else goto c4z3m;
       u4z3G: // global
           call _c4z3l(R1) args: 0, res: 0, upd: 0;
       c4z3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z3l() //  [R1]
         { info_tbl: [(c4z3l,
                       label: block_c4z3l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z3l: // global
           I64[Sp - 8] = block_c4z3r_info;
           _s4vUX::P64 = R1;
           _s4vUY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vUY::I64;
           P64[Sp + 8] = _s4vUX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z3F; else goto c4z3v;
       u4z3F: // global
           call _c4z3r(R1) args: 0, res: 0, upd: 0;
       c4z3v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z3r() //  [R1]
         { info_tbl: [(c4z3r,
                       label: block_c4z3r_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z3r: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4z3D; else goto c4z3E;
       c4z3D: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4z3E: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.903547587 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmin_closure" {
     GHC.Int.$fOrdInt16_$cmin_closure:
         const GHC.Int.$fOrdInt16_$cmin_info;
 },
 GHC.Int.$fOrdInt16_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4z48,
                       label: GHC.Int.$fOrdInt16_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z48: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4z4c; else goto c4z4d;
       c4z4c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z4d: // global
           I64[Sp - 16] = block_c4z45_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z4q; else goto c4z46;
       u4z4q: // global
           call _c4z45(R1) args: 0, res: 0, upd: 0;
       c4z46: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z45() //  [R1]
         { info_tbl: [(c4z45,
                       label: block_c4z45_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z45: // global
           I64[Sp - 8] = block_c4z4b_info;
           _s4vV4::P64 = R1;
           _s4vV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vV5::I64;
           P64[Sp + 8] = _s4vV4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z4p; else goto c4z4f;
       u4z4p: // global
           call _c4z4b(R1) args: 0, res: 0, upd: 0;
       c4z4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z4b() //  [R1]
         { info_tbl: [(c4z4b,
                       label: block_c4z4b_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z4b: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4z4n; else goto c4z4o;
       c4z4n: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4z4o: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.91230823 UTC

[section ""data" . GHC.Int.$fOrdInt16_closure" {
     GHC.Int.$fOrdInt16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fOrdInt16_$ccompare_closure+2;
         const GHC.Int.ltInt16_closure+2;
         const GHC.Int.leInt16_closure+2;
         const GHC.Int.gtInt16_closure+2;
         const GHC.Int.geInt16_closure+2;
         const GHC.Int.$fOrdInt16_$cmax_closure+2;
         const GHC.Int.$fOrdInt16_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.914983494 UTC

[section ""data" . GHC.Int.$fIxInt16_$cinRange_closure" {
     GHC.Int.$fIxInt16_$cinRange_closure:
         const GHC.Int.$fIxInt16_$cinRange_info;
 },
 GHC.Int.$fIxInt16_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4z4T,
                       label: GHC.Int.$fIxInt16_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z4T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4z52; else goto c4z53;
       c4z52: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z53: // global
           I64[Sp - 16] = block_c4z4Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z5q; else goto c4z4R;
       u4z5q: // global
           call _c4z4Q(R1) args: 0, res: 0, upd: 0;
       c4z4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z4Q() //  [R1]
         { info_tbl: [(c4z4Q,
                       label: block_c4z4Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z4Q: // global
           I64[Sp - 8] = block_c4z4W_info;
           _s4vVd::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4vVd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z5p; else goto c4z4X;
       u4z5p: // global
           call _c4z4W(R1) args: 0, res: 0, upd: 0;
       c4z4X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z4W() //  [R1]
         { info_tbl: [(c4z4W,
                       label: block_c4z4W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z4W: // global
           I64[Sp] = block_c4z51_info;
           _s4vVf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vVf::I64;
           if (R1 & 7 != 0) goto u4z5r; else goto c4z56;
       u4z5r: // global
           call _c4z51(R1) args: 0, res: 0, upd: 0;
       c4z56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z51() //  [R1]
         { info_tbl: [(c4z51,
                       label: block_c4z51_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z51: // global
           _s4vVh::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4vVh::I64)) goto c4z5e; else goto c4z5i;
       c4z5e: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z5i: // global
           _s4vVd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4z5h_info;
           R1 = _s4vVd::P64;
           I64[Sp + 16] = _s4vVh::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4z5s; else goto c4z5j;
       u4z5s: // global
           call _c4z5h(R1) args: 0, res: 0, upd: 0;
       c4z5j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z5h() //  [R1]
         { info_tbl: [(c4z5h,
                       label: block_c4z5h_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z5h: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.926303062 UTC

[section ""data" . GHC.Int.$fNumInt1_closure" {
     GHC.Int.$fNumInt1_closure:
         const GHC.Int.I16#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.928556813 UTC

[section ""data" . GHC.Int.$fNumInt16_$csignum_closure" {
     GHC.Int.$fNumInt16_$csignum_closure:
         const GHC.Int.$fNumInt16_$csignum_info;
 },
 GHC.Int.$fNumInt16_$csignum_entry() //  [R2]
         { info_tbl: [(c4z67,
                       label: GHC.Int.$fNumInt16_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z67: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4z68; else goto c4z69;
       c4z68: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4z69: // global
           I64[Sp - 8] = block_c4z64_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z6n; else goto c4z65;
       u4z6n: // global
           call _c4z64(R1) args: 0, res: 0, upd: 0;
       c4z65: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z64() //  [R1]
         { info_tbl: [(c4z64,
                       label: block_c4z64_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z64: // global
           _s4vVo::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4vVo::I64, 0)) goto c4z6l; else goto c4z6m;
       c4z6l: // global
           if (_s4vVo::I64 == 0) goto c4z6j; else goto c4z6i;
       c4z6j: // global
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z6i: // global
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z6m: // global
           R1 = GHC.Int.$fNumInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.936174533 UTC

[section ""data" . GHC.Int.$fNumInt16_$cabs_closure" {
     GHC.Int.$fNumInt16_$cabs_closure:
         const GHC.Int.$fNumInt16_$cabs_info;
 },
 GHC.Int.$fNumInt16_$cabs_entry() //  [R2]
         { info_tbl: [(c4z6I,
                       label: GHC.Int.$fNumInt16_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z6I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4z6J; else goto c4z6K;
       c4z6J: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4z6K: // global
           I64[Sp - 8] = block_c4z6F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z73; else goto c4z6G;
       u4z73: // global
           call _c4z6F(R1) args: 0, res: 0, upd: 0;
       c4z6G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z6F() //  [R1]
         { info_tbl: [(c4z6F,
                       label: block_c4z6F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z6F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4z6P; else goto c4z6O;
       c4z6P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4z6O: // global
           _s4vVt::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vVt::I64, 0)) goto c4z71; else goto c4z72;
       c4z71: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-_s4vVt::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z72: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.942224956 UTC

[section ""data" . GHC.Int.$fNumInt16_closure" {
     GHC.Int.$fNumInt16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt16_$c+_closure+2;
         const GHC.Int.$fNumInt16_$c-_closure+2;
         const GHC.Int.$fNumInt16_$c*_closure+2;
         const GHC.Int.$fNumInt16_$cnegate_closure+1;
         const GHC.Int.$fNumInt16_$cabs_closure+1;
         const GHC.Int.$fNumInt16_$csignum_closure+1;
         const GHC.Int.$fNumInt16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.944083813 UTC

[section ""data" . GHC.Int.$fBitsInt2_closure" {
     GHC.Int.$fBitsInt2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.946062812 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt16_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4z7q,
                       label: GHC.Int.$fBitsInt16_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z7q: // global
           R1 = GHC.Int.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.950016327 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbit_closure" {
     GHC.Int.$fBitsInt16_$cbit_closure:
         const GHC.Int.$fBitsInt16_$cbit_info;
 },
 GHC.Int.$fBitsInt16_$cbit_entry() //  [R2]
         { info_tbl: [(c4z7F,
                       label: GHC.Int.$fBitsInt16_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z7F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4z7G; else goto c4z7H;
       c4z7G: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4z7H: // global
           I64[Sp - 8] = block_c4z7C_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z80; else goto c4z7D;
       u4z80: // global
           call _c4z7C(R1) args: 0, res: 0, upd: 0;
       c4z7D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z7C() //  [R1]
         { info_tbl: [(c4z7C,
                       label: block_c4z7C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z7C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4z7M; else goto c4z7L;
       c4z7M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4z7L: // global
           _s4vVA::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vVA::I64, 64)) goto c4z7Y; else goto c4z7Z;
       c4z7Y: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4vVA::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z7Z: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.957476537 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ctestBit_closure" {
     GHC.Int.$fBitsInt16_$ctestBit_closure:
         const GHC.Int.$fBitsInt16_$ctestBit_info;
 },
 GHC.Int.$fBitsInt16_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4z8o,
                       label: GHC.Int.$fBitsInt16_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z8o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4z8s; else goto c4z8t;
       c4z8s: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z8t: // global
           I64[Sp - 16] = block_c4z8l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z9b; else goto c4z8m;
       u4z9b: // global
           call _c4z8l(R1) args: 0, res: 0, upd: 0;
       c4z8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z8l() //  [R1]
         { info_tbl: [(c4z8l,
                       label: block_c4z8l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z8l: // global
           I64[Sp] = block_c4z8r_info;
           _s4vVH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vVH::I64;
           if (R1 & 7 != 0) goto u4z9a; else goto c4z8v;
       u4z9a: // global
           call _c4z8r(R1) args: 0, res: 0, upd: 0;
       c4z8v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z8r() //  [R1]
         { info_tbl: [(c4z8r,
                       label: block_c4z8r_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z8r: // global
           _s4vVJ::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4vVJ::I64, 64)) goto c4z99; else goto c4z98;
       c4z98: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4vVJ::I64)) == 0) goto c4z99; else goto c4z8X;
       c4z99: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z8X: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.966569688 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateR_closure" {
     GHC.Int.$fBitsInt16_$crotateR_closure:
         const GHC.Int.$fBitsInt16_$crotateR_info;
 },
 GHC.Int.$fBitsInt16_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4z9H,
                       label: GHC.Int.$fBitsInt16_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z9H: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4z9L; else goto c4z9M;
       c4z9L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z9M: // global
           I64[Sp - 16] = block_c4z9E_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zaL; else goto c4z9F;
       u4zaL: // global
           call _c4z9E(R1) args: 0, res: 0, upd: 0;
       c4z9F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z9E() //  [R1]
         { info_tbl: [(c4z9E,
                       label: block_c4z9E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z9E: // global
           I64[Sp - 8] = block_c4z9K_info;
           _s4vVT::P64 = R1;
           _s4vVU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vVU::I64;
           P64[Sp + 8] = _s4vVT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zaK; else goto c4z9O;
       u4zaK: // global
           call _c4z9K(R1) args: 0, res: 0, upd: 0;
       c4z9O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4z9K() //  [R1]
         { info_tbl: [(c4z9K,
                       label: block_c4z9K_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4z9K: // global
           _s4vW0::I64 = -I64[R1 + 7] & 15;
           if (_s4vW0::I64 != 0) goto u4zaI; else goto c4zaE;
       u4zaI: // global
           I64[Sp + 16] = _s4vW0::I64;
           Sp = Sp + 8;
           call _c4za6() args: 0, res: 0, upd: 0;
       c4zaE: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4za6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4za6: // global
           Hp = Hp + 16;
           _s4vW0::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4zaB; else goto c4zaA;
       c4zaB: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4za5_info;
           R1 = _s4vW0::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4zaA: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4vW1::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4vW1::I64 << _s4vW0::I64) | (_s4vW1::I64 >> 16 - _s4vW0::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4za5() //  [R1]
         { info_tbl: [(c4za5,
                       label: block_c4za5_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4za5: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4za6() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.978867008 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt16_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt16_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt16_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4zbs,
                       label: GHC.Int.$fBitsInt16_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zbs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zbw; else goto c4zbx;
       c4zbw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zbx: // global
           I64[Sp - 16] = block_c4zbp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zc6; else goto c4zbq;
       u4zc6: // global
           call _c4zbp(R1) args: 0, res: 0, upd: 0;
       c4zbq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zbp() //  [R1]
         { info_tbl: [(c4zbp,
                       label: block_c4zbp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zbp: // global
           I64[Sp - 8] = block_c4zbv_info;
           _s4vWb::P64 = R1;
           _s4vWc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vWc::I64;
           P64[Sp + 8] = _s4vWb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zc5; else goto c4zbz;
       u4zc5: // global
           call _c4zbv(R1) args: 0, res: 0, upd: 0;
       c4zbz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zbv() //  [R1]
         { info_tbl: [(c4zbv,
                       label: block_c4zbv_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zbv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zbF; else goto c4zbE;
       c4zbF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zbE: // global
           _s4vWe::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vWe::I64, 64)) goto c4zc3; else goto c4zc4;
       c4zc3: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4vWe::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zc4: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.988744617 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cclearBit_closure" {
     GHC.Int.$fBitsInt16_$cclearBit_closure:
         const GHC.Int.$fBitsInt16_$cclearBit_info;
 },
 GHC.Int.$fBitsInt16_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4zcC,
                       label: GHC.Int.$fBitsInt16_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zcC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zcG; else goto c4zcH;
       c4zcG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zcH: // global
           I64[Sp - 16] = block_c4zcz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zdu; else goto c4zcA;
       u4zdu: // global
           call _c4zcz(R1) args: 0, res: 0, upd: 0;
       c4zcA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zcz() //  [R1]
         { info_tbl: [(c4zcz,
                       label: block_c4zcz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zcz: // global
           I64[Sp] = block_c4zcF_info;
           _s4vWp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vWp::I64;
           if (R1 & 7 != 0) goto u4zdt; else goto c4zcJ;
       u4zdt: // global
           call _c4zcF(R1) args: 0, res: 0, upd: 0;
       c4zcJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zcF() //  [R1]
         { info_tbl: [(c4zcF,
                       label: block_c4zcF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zcF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zcP; else goto c4zcO;
       c4zcP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zcO: // global
           _s4vWp::I64 = I64[Sp + 8];
           _s4vWr::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vWr::I64, 64)) goto c4zdg; else goto c4zds;
       c4zdg: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vWp::I64 & ~%MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4vWr::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zds: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vWp::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:25.998539129 UTC

[section ""data" . GHC.Int.$fBitsInt16_$csetBit_closure" {
     GHC.Int.$fBitsInt16_$csetBit_closure:
         const GHC.Int.$fBitsInt16_$csetBit_info;
 },
 GHC.Int.$fBitsInt16_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4ze2,
                       label: GHC.Int.$fBitsInt16_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ze2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ze6; else goto c4ze7;
       c4ze6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ze7: // global
           I64[Sp - 16] = block_c4zdZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zeG; else goto c4ze0;
       u4zeG: // global
           call _c4zdZ(R1) args: 0, res: 0, upd: 0;
       c4ze0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zdZ() //  [R1]
         { info_tbl: [(c4zdZ,
                       label: block_c4zdZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zdZ: // global
           I64[Sp - 8] = block_c4ze5_info;
           _s4vWF::P64 = R1;
           _s4vWG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vWG::I64;
           P64[Sp + 8] = _s4vWF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zeF; else goto c4ze9;
       u4zeF: // global
           call _c4ze5(R1) args: 0, res: 0, upd: 0;
       c4ze9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ze5() //  [R1]
         { info_tbl: [(c4ze5,
                       label: block_c4ze5_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ze5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zef; else goto c4zee;
       c4zef: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zee: // global
           _s4vWI::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vWI::I64, 64)) goto c4zeD; else goto c4zeE;
       c4zeD: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4vWI::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zeE: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.006832726 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateL_closure" {
     GHC.Int.$fBitsInt16_$crotateL_closure:
         const GHC.Int.$fBitsInt16_$crotateL_info;
 },
 GHC.Int.$fBitsInt16_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4zf9,
                       label: GHC.Int.$fBitsInt16_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zf9: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt16_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.010382056 UTC

[section ""data" . GHC.Int.$fBitsInt16_closure" {
     GHC.Int.$fBitsInt16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fBitsInt16_$c.&._closure+2;
         const GHC.Int.$fBitsInt16_$c.|._closure+2;
         const GHC.Int.$fBitsInt16_$cxor_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt16_$cshift_closure+2;
         const GHC.Int.$fBitsInt16_$crotate_closure+2;
         const GHC.Int.$fBitsInt3_closure+1;
         const GHC.Int.$fBitsInt16_$cbit_closure+1;
         const GHC.Int.$fBitsInt16_$csetBit_closure+2;
         const GHC.Int.$fBitsInt16_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt16_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt16_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt16_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt16_$crotateL_closure+2;
         const GHC.Int.$fBitsInt16_$crotateR_closure+2;
         const GHC.Int.$fBitsInt16_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.012606922 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_closure" {
     GHC.Int.$fFiniteBitsInt16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt16_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.01565083 UTC

[section ""data" . GHC.Int.$fReadInt16_go_closure" {
     GHC.Int.$fReadInt16_go_closure:
         const GHC.Int.$fReadInt16_go_info;
 },
 sat_s4vX2_entry() //  [R1]
         { info_tbl: [(c4zfB,
                       label: sat_s4vX2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zfB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zfC; else goto c4zfD;
       c4zfC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zfD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4vX0_entry() //  [R1]
         { info_tbl: [(c4zfL,
                       label: sat_s4vX0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zfL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zfS; else goto c4zfT;
       c4zfS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zfT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4zfI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4zfX; else goto c4zfJ;
       u4zfX: // global
           call _c4zfI(R1) args: 0, res: 0, upd: 0;
       c4zfJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4zfI() //  [R1]
         { info_tbl: [(c4zfI,
                       label: block_c4zfI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zfI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zfW; else goto c4zfV;
       c4zfW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4zfV: // global
           _s4vWZ::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vWZ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt16_go_entry() //  [R2]
         { info_tbl: [(c4zg2,
                       label: GHC.Int.$fReadInt16_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zg2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zg3; else goto c4zg4;
       c4zg3: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zg4: // global
           I64[Sp - 8] = block_c4zfm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zge; else goto c4zfn;
       u4zge: // global
           call _c4zfm(R1) args: 0, res: 0, upd: 0;
       c4zfn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zfm() //  [R1]
         { info_tbl: [(c4zfm,
                       label: block_c4zfm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zfm: // global
           if (R1 & 7 == 1) goto c4zfZ; else goto c4zg0;
       c4zfZ: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zg0: // global
           I64[Sp - 8] = block_c4zfs_info;
           _s4vWT::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4vWT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zgd; else goto c4zft;
       u4zgd: // global
           call _c4zfs(R1) args: 0, res: 0, upd: 0;
       c4zft: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zfs() //  [R1]
         { info_tbl: [(c4zfs,
                       label: block_c4zfs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zfs: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4zgc; else goto c4zgb;
       c4zgc: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zgb: // global
           _s4vWV::P64 = P64[R1 + 7];
           _s4vWW::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4vX2_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4vX0_info;
           P64[Hp - 48] = _s4vWV::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4vWW::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.030842923 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadsPrec_closure" {
     GHC.Int.$fReadInt16_$creadsPrec_closure:
         const GHC.Int.$fReadInt16_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4zh5,
                       label: GHC.Int.$fReadInt16_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zh5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zh9; else goto c4zha;
       c4zh9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zha: // global
           I64[Sp - 16] = block_c4zh3_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4vX4::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4vX4::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zh3() //  [R1]
         { info_tbl: [(c4zh3,
                       label: block_c4zh3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zh3: // global
           _s4vX4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4zh8_info;
           R3 = _s4vX4::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zh8() //  [R1]
         { info_tbl: [(c4zh8,
                       label: block_c4zh8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zh8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.039395886 UTC

[section ""data" . GHC.Int.$fReadInt3_closure" {
     GHC.Int.$fReadInt3_closure:
         const GHC.Int.$fReadInt3_info;
         const 0;
 },
 sat_s4vX9_entry() //  [R1, R2]
         { info_tbl: [(c4zhE,
                       label: sat_s4vX9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zhE: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt16_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt3_entry() //  [R2, R3]
         { info_tbl: [(c4zhK,
                       label: GHC.Int.$fReadInt3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zhK: // global
           _s4vX8::P64 = R3;
           _s4vX7::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4zhL; else goto c4zhM;
       c4zhM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zhO; else goto c4zhN;
       c4zhO: // global
           HpAlloc = 16;
           goto c4zhL;
       c4zhL: // global
           R3 = _s4vX8::P64;
           R2 = _s4vX7::P64;
           R1 = GHC.Int.$fReadInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zhN: // global
           I64[Hp - 8] = sat_s4vX9_info;
           P64[Hp] = _s4vX7::P64;
           I64[Sp - 8] = block_c4zhH_info;
           R3 = _s4vX8::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zhH() //  [R1]
         { info_tbl: [(c4zhH,
                       label: block_c4zhH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zhH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zhR; else goto c4zhQ;
       c4zhR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zhQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.047434526 UTC

[section ""data" . GHC.Int.$fReadInt2_closure" {
     GHC.Int.$fReadInt2_closure:
         const GHC.Int.$fReadInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt2_entry() //  [R1]
         { info_tbl: [(c4zid,
                       label: GHC.Int.$fReadInt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zid: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4zie; else goto c4zif;
       c4zie: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zif: // global
           (_c4zia::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4zia::I64 == 0) goto c4zic; else goto c4zib;
       c4zic: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4zib: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4zia::I64;
           R2 = GHC.Int.$fReadInt3_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.052129016 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadList_closure" {
     GHC.Int.$fReadInt16_$creadList_closure:
         const GHC.Int.$fReadInt16_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadList_entry() //  [R2]
         { info_tbl: [(c4ziw,
                       label: GHC.Int.$fReadInt16_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ziw: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt2_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.05603675 UTC

[section ""data" . GHC.Int.$fReadInt1_closure" {
     GHC.Int.$fReadInt1_closure:
         const GHC.Int.$fReadInt1_info;
         const 0;
 },
 GHC.Int.$fReadInt1_entry() //  [R2, R3]
         { info_tbl: [(c4ziK,
                       label: GHC.Int.$fReadInt1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ziK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ziL; else goto c4ziM;
       c4ziL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ziM: // global
           I64[Sp - 8] = block_c4ziH_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt16_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ziH() //  [R1]
         { info_tbl: [(c4ziH,
                       label: block_c4ziH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ziH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ziP; else goto c4ziO;
       c4ziP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ziO: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.0628101 UTC

[section ""data" . GHC.Int.$fReadInt16_closure" {
     GHC.Int.$fReadInt16_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt16_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt16_$creadList_closure+1;
         const GHC.Int.$fReadInt3_closure+2;
         const GHC.Int.$fReadInt1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.065496068 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquot_closure" {
     GHC.Int.$fIntegralInt16_$cquot_closure:
         const GHC.Int.$fIntegralInt16_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4zj9,
                       label: GHC.Int.$fIntegralInt16_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zj9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zjd; else goto c4zje;
       c4zjd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zje: // global
           I64[Sp - 16] = block_c4zj6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zjP; else goto c4zj7;
       u4zjP: // global
           call _c4zj6(R1) args: 0, res: 0, upd: 0;
       c4zj7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zj6() //  [R1]
         { info_tbl: [(c4zj6,
                       label: block_c4zj6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zj6: // global
           I64[Sp] = block_c4zjc_info;
           _s4vXj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vXj::I64;
           if (R1 & 7 != 0) goto u4zjO; else goto c4zjg;
       u4zjO: // global
           call _c4zjc(R1) args: 0, res: 0, upd: 0;
       c4zjg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zjc() //  [R1]
         { info_tbl: [(c4zjc,
                       label: block_c4zjc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zjc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zjm; else goto c4zjl;
       c4zjm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zjl: // global
           _s4vXj::I64 = I64[Sp + 8];
           _s4vXm::I64 = I64[R1 + 7];
           if (_s4vXm::I64 != (-1)) goto u4zjN; else goto c4zjL;
       u4zjN: // global
           if (_s4vXm::I64 != 0) goto c4zjx; else goto c4zjM;
       c4zjx: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4vXj::I64,
                                                                            _s4vXm::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zjM: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zjL: // global
           if (_s4vXj::I64 == (-32768)) goto c4zjK; else goto c4zjJ;
       c4zjK: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zjJ: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4vXj::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.076409407 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$crem_closure" {
     GHC.Int.$fIntegralInt16_$crem_closure:
         const GHC.Int.$fIntegralInt16_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4zkl,
                       label: GHC.Int.$fIntegralInt16_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zkl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zkp; else goto c4zkq;
       c4zkp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zkq: // global
           I64[Sp - 16] = block_c4zki_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zkM; else goto c4zkj;
       u4zkM: // global
           call _c4zki(R1) args: 0, res: 0, upd: 0;
       c4zkj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zki() //  [R1]
         { info_tbl: [(c4zki,
                       label: block_c4zki_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zki: // global
           I64[Sp] = block_c4zko_info;
           _s4vXx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vXx::I64;
           if (R1 & 7 != 0) goto u4zkL; else goto c4zks;
       u4zkL: // global
           call _c4zko(R1) args: 0, res: 0, upd: 0;
       c4zks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zko() //  [R1]
         { info_tbl: [(c4zko,
                       label: block_c4zko_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zko: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zky; else goto c4zkx;
       c4zky: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zkx: // global
           _s4vXA::I64 = I64[R1 + 7];
           if (_s4vXA::I64 != 0) goto c4zkJ; else goto c4zkK;
       c4zkJ: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4vXA::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zkK: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.086261588 UTC

[section ""data" . GHC.Int.$w$cdiv_closure" {
     GHC.Int.$w$cdiv_closure:
         const GHC.Int.$w$cdiv_info;
         const 0;
 },
 GHC.Int.$w$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4zlf,
                       label: GHC.Int.$w$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zlf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zlg; else goto c4zlh;
       c4zlg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zlh: // global
           if (R3 == (-1)) goto c4zld; else goto u4zlB;
       c4zld: // global
           if (R2 == (-32768)) goto c4zlA; else goto c4zly;
       c4zlA: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zly: // global
           I64[Sp - 8] = block_c4zls_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4zlB: // global
           if (R3 == 0) goto c4zle; else goto c4zlc;
       c4zle: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zlc: // global
           I64[Sp - 8] = block_c4zlj_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zls() //  [R1]
         { info_tbl: [(c4zls,
                       label: block_c4zls_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zls: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4zlj() //  [R1]
         { info_tbl: [(c4zlj,
                       label: block_c4zlj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zlj: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.094433418 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdiv_closure" {
     GHC.Int.$fIntegralInt16_$cdiv_closure:
         const GHC.Int.$fIntegralInt16_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4zm0,
                       label: GHC.Int.$fIntegralInt16_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zm0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zmd; else goto c4zme;
       c4zmd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zme: // global
           I64[Sp - 16] = block_c4zlX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zml; else goto c4zlY;
       u4zml: // global
           call _c4zlX(R1) args: 0, res: 0, upd: 0;
       c4zlY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zlX() //  [R1]
         { info_tbl: [(c4zlX,
                       label: block_c4zlX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zlX: // global
           I64[Sp] = block_c4zm3_info;
           _s4vXO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vXO::I64;
           if (R1 & 7 != 0) goto u4zmk; else goto c4zm4;
       u4zmk: // global
           call _c4zm3(R1) args: 0, res: 0, upd: 0;
       c4zm4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zm3() //  [R1]
         { info_tbl: [(c4zm3,
                       label: block_c4zm3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zm3: // global
           _s4vXO::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4zm8_info;
           R3 = I64[R1 + 7];
           R2 = _s4vXO::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zm8() //  [R1]
         { info_tbl: [(c4zm8,
                       label: block_c4zm8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zm8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zmj; else goto c4zmi;
       c4zmj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4zmi: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.105638285 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cmod_closure" {
     GHC.Int.$fIntegralInt16_$cmod_closure:
         const GHC.Int.$fIntegralInt16_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4zmO,
                       label: GHC.Int.$fIntegralInt16_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zmO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zmS; else goto c4zmT;
       c4zmS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zmT: // global
           I64[Sp - 16] = block_c4zmL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4znh; else goto c4zmM;
       u4znh: // global
           call _c4zmL(R1) args: 0, res: 0, upd: 0;
       c4zmM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zmL() //  [R1]
         { info_tbl: [(c4zmL,
                       label: block_c4zmL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zmL: // global
           I64[Sp] = block_c4zmR_info;
           _s4vXV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vXV::I64;
           if (R1 & 7 != 0) goto u4zng; else goto c4zmV;
       u4zng: // global
           call _c4zmR(R1) args: 0, res: 0, upd: 0;
       c4zmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zmR() //  [R1]
         { info_tbl: [(c4zmR,
                       label: block_c4zmR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zmR: // global
           _s4vXY::I64 = I64[R1 + 7];
           if (_s4vXY::I64 != 0) goto c4znb; else goto c4znf;
       c4znb: // global
           _s4vXV::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4zn2_info;
           R3 = _s4vXY::I64;
           R2 = _s4vXV::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4znf: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4zn2() //  [R1]
         { info_tbl: [(c4zn2,
                       label: block_c4zn2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zn2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zne; else goto c4znd;
       c4zne: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4znd: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.115343284 UTC

[section ""data" . lvl7_r4kPy_closure" {
     lvl7_r4kPy_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt3_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.118093883 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquotRem_closure" {
     GHC.Int.$fIntegralInt16_$cquotRem_closure:
         const GHC.Int.$fIntegralInt16_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4znN,
                       label: GHC.Int.$fIntegralInt16_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4znN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4znR; else goto c4znS;
       c4znR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4znS: // global
           I64[Sp - 16] = block_c4znK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zox; else goto c4znL;
       u4zox: // global
           call _c4znK(R1) args: 0, res: 0, upd: 0;
       c4znL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4znK() //  [R1]
         { info_tbl: [(c4znK,
                       label: block_c4znK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4znK: // global
           I64[Sp] = block_c4znQ_info;
           _s4vY5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vY5::I64;
           if (R1 & 7 != 0) goto u4zow; else goto c4znU;
       u4zow: // global
           call _c4znQ(R1) args: 0, res: 0, upd: 0;
       c4znU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4znQ() //  [R1]
         { info_tbl: [(c4znQ,
                       label: block_c4znQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4znQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4zo0; else goto c4znZ;
       c4zo0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4znZ: // global
           _s4vY5::I64 = I64[Sp + 8];
           _s4vY8::I64 = I64[R1 + 7];
           if (_s4vY8::I64 != (-1)) goto u4zov; else goto c4zot;
       u4zov: // global
           if (_s4vY8::I64 != 0) goto c4zod; else goto c4zou;
       c4zod: // global
           (_s4vYa::I64, _s4vYb::I64) = call MO_S_QuotRem W64(_s4vY5::I64, _s4vY8::I64);
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYb::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYa::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zou: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zot: // global
           if (_s4vY5::I64 == (-32768)) goto c4zos; else goto c4zor;
       c4zos: // global
           Hp = Hp - 56;
           R1 = lvl7_r4kPy_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zor: // global
           (_s4vYi::I64, _s4vYj::I64) = call MO_S_QuotRem W64(_s4vY5::I64, (-1));
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYj::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYi::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.130574572 UTC

[section ""data" . GHC.Int.$w$cdivMod_closure" {
     GHC.Int.$w$cdivMod_closure:
         const GHC.Int.$w$cdivMod_info;
         const 0;
 },
 section ""relreadonly" . u4zrR_srtd" {
     u4zrR_srtd:
         const S4wm5_srt+536;
         const 33;
         const 4294967299;
 },
 GHC.Int.$w$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4zph,
                       label: GHC.Int.$w$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zph: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zpi; else goto c4zpj;
       c4zpi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zpj: // global
           if (R3 == 0) goto c4zpg; else goto c4zpf;
       c4zpg: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zpf: // global
           if (R3 == (-1)) goto c4zrM; else goto u4zrN;
       c4zrM: // global
           if (R2 == (-32768)) goto c4zrL; else goto u4zrO;
       c4zrL: // global
           R2 = GHC.Int.$fBitsInt3_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4zrO: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4zrQ;
       u4zrN: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4zrQ;
       u4zrQ: // global
           call _c4zpo() args: 0, res: 0, upd: 0;
     }
 },
 _c4zpo() //  []
         { info_tbl: [(c4zpo,
                       label: block_c4zpo_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zpo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4zps; else goto c4zpr;
       c4zps: // global
           HpAlloc = 32;
           I64[Sp] = block_c4zpo_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4zpr: // global
           _s4vYp::I64 = I64[Sp + 8];
           _s4vYr::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4vYp::I64, 0)) goto c4zql; else goto c4zrC;
       c4zql: // global
           if (%MO_S_Ge_W64(_s4vYp::I64, 0)) goto c4zpI; else goto c4zqj;
       c4zpI: // global
           (_s4vYw::I64, _s4vYx::I64) = call MO_S_QuotRem W64(_s4vYp::I64, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYx::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYw::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zqj: // global
           if (%MO_S_Le_W64(_s4vYr::I64, 0)) goto c4zpW; else goto c4zqi;
       c4zpW: // global
           (_s4vYE::I64, _s4vYF::I64) = call MO_S_QuotRem W64(_s4vYp::I64, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYF::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYE::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zqi: // global
           (_s4vYM::I64, _s4vYN::I64) = call MO_S_QuotRem W64(_s4vYp::I64 + 1, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYN::I64 + _s4vYr::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYM::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zrC: // global
           if (%MO_S_Ge_W64(_s4vYr::I64, 0)) goto c4zrf; else goto c4zrB;
       c4zrf: // global
           if (%MO_S_Ge_W64(_s4vYp::I64, 0)) goto c4zqC; else goto c4zrd;
       c4zqC: // global
           (_s4vYY::I64, _s4vYZ::I64) = call MO_S_QuotRem W64(_s4vYp::I64, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYZ::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYY::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zrd: // global
           if (%MO_S_Le_W64(_s4vYr::I64, 0)) goto c4zqQ; else goto c4zrc;
       c4zqQ: // global
           (_s4vZ6::I64, _s4vZ7::I64) = call MO_S_QuotRem W64(_s4vYp::I64, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZ7::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZ6::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zrc: // global
           (_s4vZe::I64, _s4vZf::I64) = call MO_S_QuotRem W64(_s4vYp::I64 + 1, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZf::I64 + _s4vYr::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZe::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zrB: // global
           (_s4vZp::I64, _s4vZq::I64) = call MO_S_QuotRem W64(_s4vYp::I64 - 1, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZq::I64 + _s4vYr::I64 + 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZp::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.142906581 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdivMod_closure" {
     GHC.Int.$fIntegralInt16_$cdivMod_closure:
         const GHC.Int.$fIntegralInt16_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4zt3,
                       label: GHC.Int.$fIntegralInt16_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zt3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zte; else goto c4ztf;
       c4zte: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ztf: // global
           I64[Sp - 16] = block_c4zt0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ztm; else goto c4zt1;
       u4ztm: // global
           call _c4zt0(R1) args: 0, res: 0, upd: 0;
       c4zt1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zt0() //  [R1]
         { info_tbl: [(c4zt0,
                       label: block_c4zt0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zt0: // global
           I64[Sp] = block_c4zt6_info;
           _s4vZE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vZE::I64;
           if (R1 & 7 != 0) goto u4ztl; else goto c4zt7;
       u4ztl: // global
           call _c4zt6(R1) args: 0, res: 0, upd: 0;
       c4zt7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zt6() //  [R1]
         { info_tbl: [(c4zt6,
                       label: block_c4zt6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zt6: // global
           _s4vZE::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4ztb_info;
           R3 = I64[R1 + 7];
           R2 = _s4vZE::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ztb() //  [R1, R2]
         { info_tbl: [(c4ztb,
                       label: block_c4ztb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ztb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ztk; else goto c4ztj;
       c4ztk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ztj: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.15405017 UTC

[section ""data" . GHC.Int.$fRealInt16_$ctoRational_closure" {
     GHC.Int.$fRealInt16_$ctoRational_closure:
         const GHC.Int.$fRealInt16_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt16_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4ztP,
                       label: GHC.Int.$fRealInt16_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ztP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zu3; else goto c4zu4;
       c4zu3: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zu4: // global
           I64[Sp - 8] = block_c4ztM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zub; else goto c4ztN;
       u4zub: // global
           call _c4ztM(R1) args: 0, res: 0, upd: 0;
       c4ztN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ztM() //  [R1]
         { info_tbl: [(c4ztM,
                       label: block_c4ztM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ztM: // global
           I64[Sp] = block_c4ztS_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ztS() //  [R1]
         { info_tbl: [(c4ztS,
                       label: block_c4ztS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ztS: // global
           I64[Sp] = block_c4ztW_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ztW() //  [R1]
         { info_tbl: [(c4ztW,
                       label: block_c4ztW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ztW: // global
           I64[Sp] = block_c4zu0_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zu0() //  [R1, R2]
         { info_tbl: [(c4zu0,
                       label: block_c4zu0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zu0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4zua; else goto c4zu9;
       c4zua: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4zu9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.165157447 UTC

[section ""data" . GHC.Int.$fRealInt16_closure" {
     GHC.Int.$fRealInt16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt16_closure+1;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fRealInt16_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.167647562 UTC

[section ""data" . GHC.Int.$fIntegralInt16_closure" {
     GHC.Int.$fIntegralInt16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt16_closure+1;
         const GHC.Int.$fEnumInt16_closure+1;
         const GHC.Int.$fIntegralInt16_$cquot_closure+2;
         const GHC.Int.$fIntegralInt16_$crem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt16_$cmod_closure+2;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt16_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.171106586 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt16_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt16_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt16_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4zuJ,
                       label: GHC.Int.$fIxInt16_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zuJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zv0; else goto c4zv1;
       c4zv0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zv1: // global
           I64[Sp - 16] = block_c4zuG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zv8; else goto c4zuH;
       u4zv8: // global
           call _c4zuG(R1) args: 0, res: 0, upd: 0;
       c4zuH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zuG() //  [R1]
         { info_tbl: [(c4zuG,
                       label: block_c4zuG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zuG: // global
           I64[Sp] = block_c4zuM_info;
           _s4vZV::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4vZV::P64;
           if (R1 & 7 != 0) goto u4zv7; else goto c4zuN;
       u4zv7: // global
           call _c4zuM(R1) args: 0, res: 0, upd: 0;
       c4zuN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zuM() //  [R1]
         { info_tbl: [(c4zuM,
                       label: block_c4zuM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zuM: // global
           I64[Sp] = block_c4zuR_info;
           _s4vZY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vZY::I64;
           if (R1 & 7 != 0) goto u4zv9; else goto c4zuS;
       u4zv9: // global
           call _c4zuR(R1) args: 0, res: 0, upd: 0;
       c4zuS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zuR() //  [R1]
         { info_tbl: [(c4zuR,
                       label: block_c4zuR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zuR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zv6; else goto c4zv5;
       c4zv6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zv5: // global
           _s4w01::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w01::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.181030041 UTC

[section ""data" . GHC.Int.$fIxInt16_$crange_closure" {
     GHC.Int.$fIxInt16_$crange_closure:
         const GHC.Int.$fIxInt16_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$crange_entry() //  [R2]
         { info_tbl: [(c4zvF,
                       label: GHC.Int.$fIxInt16_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zvF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zvG; else goto c4zvH;
       c4zvG: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zvH: // global
           I64[Sp - 8] = block_c4zvC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zvL; else goto c4zvD;
       u4zvL: // global
           call _c4zvC(R1) args: 0, res: 0, upd: 0;
       c4zvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zvC() //  [R1]
         { info_tbl: [(c4zvC,
                       label: block_c4zvC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zvC: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.188006059 UTC

[section ""data" . GHC.Int.$fIxInt16_$crangeSize_closure" {
     GHC.Int.$fIxInt16_$crangeSize_closure:
         const GHC.Int.$fIxInt16_$crangeSize_info;
 },
 GHC.Int.$fIxInt16_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4zw3,
                       label: GHC.Int.$fIxInt16_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zw3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zwc; else goto c4zwd;
       c4zwc: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zwd: // global
           I64[Sp - 8] = block_c4zw0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zwC; else goto c4zw1;
       u4zwC: // global
           call _c4zw0(R1) args: 0, res: 0, upd: 0;
       c4zw1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zw0() //  [R1]
         { info_tbl: [(c4zw0,
                       label: block_c4zw0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zw0: // global
           I64[Sp - 8] = block_c4zw6_info;
           _s4w09::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w09::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zwB; else goto c4zw7;
       u4zwB: // global
           call _c4zw6(R1) args: 0, res: 0, upd: 0;
       c4zw7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zw6() //  [R1]
         { info_tbl: [(c4zw6,
                       label: block_c4zw6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zw6: // global
           I64[Sp] = block_c4zwb_info;
           _s4w0b::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0b::I64;
           if (R1 & 7 != 0) goto u4zwD; else goto c4zwg;
       u4zwD: // global
           call _c4zwb(R1) args: 0, res: 0, upd: 0;
       c4zwg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zwb() //  [R1]
         { info_tbl: [(c4zwb,
                       label: block_c4zwb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zwb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zwm; else goto c4zwl;
       c4zwm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zwl: // global
           _s4w0b::I64 = I64[Sp + 8];
           _s4w0d::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4w0b::I64,
                            _s4w0d::I64)) goto c4zwq; else goto c4zwA;
       c4zwq: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zwA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w0d::I64 - _s4w0b::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.198883116 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt16_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt16_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4zxb,
                       label: GHC.Int.$fIxInt16_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zxb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zxv; else goto c4zxw;
       c4zxv: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zxw: // global
           I64[Sp - 8] = block_c4zx8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zxD; else goto c4zx9;
       u4zxD: // global
           call _c4zx8(R1) args: 0, res: 0, upd: 0;
       c4zx9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zx8() //  [R1]
         { info_tbl: [(c4zx8,
                       label: block_c4zx8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zx8: // global
           I64[Sp - 8] = block_c4zxe_info;
           _s4w0j::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4w0j::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zxC; else goto c4zxf;
       u4zxC: // global
           call _c4zxe(R1) args: 0, res: 0, upd: 0;
       c4zxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zxe() //  [R1]
         { info_tbl: [(c4zxe,
                       label: block_c4zxe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zxe: // global
           I64[Sp] = block_c4zxj_info;
           _s4w0m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0m::I64;
           if (R1 & 7 != 0) goto u4zxE; else goto c4zxk;
       u4zxE: // global
           call _c4zxj(R1) args: 0, res: 0, upd: 0;
       c4zxk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zxj() //  [R1]
         { info_tbl: [(c4zxj,
                       label: block_c4zxj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zxj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zxB; else goto c4zxA;
       c4zxB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zxA: // global
           _s4w0q::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w0q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.210320043 UTC

[section ""data" . GHC.Int.$fIxInt16_$cindex_closure" {
     GHC.Int.$fIxInt16_$cindex_closure:
         const GHC.Int.$fIxInt16_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4zyb,
                       label: GHC.Int.$fIxInt16_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zyb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zyk; else goto c4zyl;
       c4zyk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zyl: // global
           I64[Sp - 16] = block_c4zy8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zyU; else goto c4zy9;
       u4zyU: // global
           call _c4zy8(R1) args: 0, res: 0, upd: 0;
       c4zy9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zy8() //  [R1]
         { info_tbl: [(c4zy8,
                       label: block_c4zy8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zy8: // global
           I64[Sp - 8] = block_c4zye_info;
           _s4w0v::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w0v::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zyT; else goto c4zyf;
       u4zyT: // global
           call _c4zye(R1) args: 0, res: 0, upd: 0;
       c4zyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zye() //  [R1]
         { info_tbl: [(c4zye,
                       label: block_c4zye_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zye: // global
           I64[Sp] = block_c4zyj_info;
           _s4w0x::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4w0x::I64;
           if (R1 & 7 != 0) goto u4zyV; else goto c4zyo;
       u4zyV: // global
           call _c4zyj(R1) args: 0, res: 0, upd: 0;
       c4zyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zyj() //  [R1]
         { info_tbl: [(c4zyj,
                       label: block_c4zyj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zyj: // global
           _s4w0z::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4w0z::I64)) goto c4zyw; else goto c4zyA;
       c4zyw: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4zyA: // global
           I64[Sp] = block_c4zyz_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0z::I64;
           if (R1 & 7 != 0) goto u4zyW; else goto c4zyB;
       u4zyW: // global
           call _c4zyz(R1) args: 0, res: 0, upd: 0;
       c4zyB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zyz() //  [R1]
         { info_tbl: [(c4zyz,
                       label: block_c4zyz_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zyz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zyH; else goto c4zyG;
       c4zyH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zyG: // global
           _s4w0z::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4w0z::I64,
                            I64[R1 + 7])) goto c4zyL; else goto c4zyS;
       c4zyL: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4zyS: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w0z::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.222338719 UTC

[section ""data" . GHC.Int.$fIxInt16_closure" {
     GHC.Int.$fIxInt16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fIxInt16_$crange_closure+1;
         const GHC.Int.$fIxInt16_$cindex_closure+2;
         const GHC.Int.$fIxInt16_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt16_$cinRange_closure+2;
         const GHC.Int.$fIxInt16_$crangeSize_closure+1;
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.224749462 UTC

[section ""data" . GHC.Int.eqInt32_closure" {
     GHC.Int.eqInt32_closure:
         const GHC.Int.eqInt32_info;
 },
 GHC.Int.eqInt32_entry() //  [R2, R3]
         { info_tbl: [(c4zzA,
                       label: GHC.Int.eqInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zzA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zzE; else goto c4zzF;
       c4zzE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zzF: // global
           I64[Sp - 16] = block_c4zzx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zzO; else goto c4zzy;
       u4zzO: // global
           call _c4zzx(R1) args: 0, res: 0, upd: 0;
       c4zzy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zzx() //  [R1]
         { info_tbl: [(c4zzx,
                       label: block_c4zzx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zzx: // global
           I64[Sp] = block_c4zzD_info;
           _s4w0I::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0I::I64;
           if (R1 & 7 != 0) goto u4zzN; else goto c4zzH;
       u4zzN: // global
           call _c4zzD(R1) args: 0, res: 0, upd: 0;
       c4zzH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zzD() //  [R1]
         { info_tbl: [(c4zzD,
                       label: block_c4zzD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zzD: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.232875618 UTC

[section ""data" . GHC.Int.$fEqInt32_closure" {
     GHC.Int.$fEqInt32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt32_closure+2;
         const GHC.Int.neInt32_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.238870281 UTC

[section ""data" . GHC.Int.gtInt32_closure" {
     GHC.Int.gtInt32_closure:
         const GHC.Int.gtInt32_info;
 },
 GHC.Int.gtInt32_entry() //  [R2, R3]
         { info_tbl: [(c4zAh,
                       label: GHC.Int.gtInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zAh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zAl; else goto c4zAm;
       c4zAl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zAm: // global
           I64[Sp - 16] = block_c4zAe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zAv; else goto c4zAf;
       u4zAv: // global
           call _c4zAe(R1) args: 0, res: 0, upd: 0;
       c4zAf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zAe() //  [R1]
         { info_tbl: [(c4zAe,
                       label: block_c4zAe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zAe: // global
           I64[Sp] = block_c4zAk_info;
           _s4w0P::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0P::I64;
           if (R1 & 7 != 0) goto u4zAu; else goto c4zAo;
       u4zAu: // global
           call _c4zAk(R1) args: 0, res: 0, upd: 0;
       c4zAo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zAk() //  [R1]
         { info_tbl: [(c4zAk,
                       label: block_c4zAk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zAk: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.247251206 UTC

[section ""data" . GHC.Int.geInt32_closure" {
     GHC.Int.geInt32_closure:
         const GHC.Int.geInt32_info;
 },
 GHC.Int.geInt32_entry() //  [R2, R3]
         { info_tbl: [(c4zAX,
                       label: GHC.Int.geInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zAX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zB1; else goto c4zB2;
       c4zB1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zB2: // global
           I64[Sp - 16] = block_c4zAU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zBb; else goto c4zAV;
       u4zBb: // global
           call _c4zAU(R1) args: 0, res: 0, upd: 0;
       c4zAV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zAU() //  [R1]
         { info_tbl: [(c4zAU,
                       label: block_c4zAU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zAU: // global
           I64[Sp] = block_c4zB0_info;
           _s4w0W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0W::I64;
           if (R1 & 7 != 0) goto u4zBa; else goto c4zB4;
       u4zBa: // global
           call _c4zB0(R1) args: 0, res: 0, upd: 0;
       c4zB4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zB0() //  [R1]
         { info_tbl: [(c4zB0,
                       label: block_c4zB0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zB0: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.256505326 UTC

[section ""data" . GHC.Int.ltInt32_closure" {
     GHC.Int.ltInt32_closure:
         const GHC.Int.ltInt32_info;
 },
 GHC.Int.ltInt32_entry() //  [R2, R3]
         { info_tbl: [(c4zBD,
                       label: GHC.Int.ltInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zBD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zBH; else goto c4zBI;
       c4zBH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zBI: // global
           I64[Sp - 16] = block_c4zBA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zBR; else goto c4zBB;
       u4zBR: // global
           call _c4zBA(R1) args: 0, res: 0, upd: 0;
       c4zBB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zBA() //  [R1]
         { info_tbl: [(c4zBA,
                       label: block_c4zBA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zBA: // global
           I64[Sp] = block_c4zBG_info;
           _s4w13::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w13::I64;
           if (R1 & 7 != 0) goto u4zBQ; else goto c4zBK;
       u4zBQ: // global
           call _c4zBG(R1) args: 0, res: 0, upd: 0;
       c4zBK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zBG() //  [R1]
         { info_tbl: [(c4zBG,
                       label: block_c4zBG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zBG: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.264916872 UTC

[section ""data" . GHC.Int.leInt32_closure" {
     GHC.Int.leInt32_closure:
         const GHC.Int.leInt32_info;
 },
 GHC.Int.leInt32_entry() //  [R2, R3]
         { info_tbl: [(c4zCj,
                       label: GHC.Int.leInt32_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zCj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zCn; else goto c4zCo;
       c4zCn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zCo: // global
           I64[Sp - 16] = block_c4zCg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zCx; else goto c4zCh;
       u4zCx: // global
           call _c4zCg(R1) args: 0, res: 0, upd: 0;
       c4zCh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zCg() //  [R1]
         { info_tbl: [(c4zCg,
                       label: block_c4zCg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zCg: // global
           I64[Sp] = block_c4zCm_info;
           _s4w1a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w1a::I64;
           if (R1 & 7 != 0) goto u4zCw; else goto c4zCq;
       u4zCw: // global
           call _c4zCm(R1) args: 0, res: 0, upd: 0;
       c4zCq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zCm() //  [R1]
         { info_tbl: [(c4zCm,
                       label: block_c4zCm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zCm: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.273351352 UTC

[section ""data" . GHC.Int.$fOrdInt32_$ccompare_closure" {
     GHC.Int.$fOrdInt32_$ccompare_closure:
         const GHC.Int.$fOrdInt32_$ccompare_info;
 },
 GHC.Int.$fOrdInt32_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4zCZ,
                       label: GHC.Int.$fOrdInt32_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zCZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zD3; else goto c4zD4;
       c4zD3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zD4: // global
           I64[Sp - 16] = block_c4zCW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zDn; else goto c4zCX;
       u4zDn: // global
           call _c4zCW(R1) args: 0, res: 0, upd: 0;
       c4zCX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zCW() //  [R1]
         { info_tbl: [(c4zCW,
                       label: block_c4zCW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zCW: // global
           I64[Sp] = block_c4zD2_info;
           _s4w1h::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w1h::I64;
           if (R1 & 7 != 0) goto u4zDm; else goto c4zD6;
       u4zDm: // global
           call _c4zD2(R1) args: 0, res: 0, upd: 0;
       c4zD6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zD2() //  [R1]
         { info_tbl: [(c4zD2,
                       label: block_c4zD2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zD2: // global
           _s4w1h::I64 = I64[Sp + 8];
           _s4w1j::I64 = I64[R1 + 7];
           if (_s4w1h::I64 == _s4w1j::I64) goto c4zDl; else goto c4zDk;
       c4zDl: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zDk: // global
           if (%MO_S_Gt_W64(_s4w1h::I64,
                            _s4w1j::I64)) goto c4zDh; else goto c4zDi;
       c4zDh: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zDi: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.283043393 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmax_closure" {
     GHC.Int.$fOrdInt32_$cmax_closure:
         const GHC.Int.$fOrdInt32_$cmax_info;
 },
 GHC.Int.$fOrdInt32_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4zDQ,
                       label: GHC.Int.$fOrdInt32_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zDQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zDU; else goto c4zDV;
       c4zDU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zDV: // global
           I64[Sp - 16] = block_c4zDN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zE8; else goto c4zDO;
       u4zE8: // global
           call _c4zDN(R1) args: 0, res: 0, upd: 0;
       c4zDO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zDN() //  [R1]
         { info_tbl: [(c4zDN,
                       label: block_c4zDN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zDN: // global
           I64[Sp - 8] = block_c4zDT_info;
           _s4w1o::P64 = R1;
           _s4w1p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w1p::I64;
           P64[Sp + 8] = _s4w1o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zE7; else goto c4zDX;
       u4zE7: // global
           call _c4zDT(R1) args: 0, res: 0, upd: 0;
       c4zDX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zDT() //  [R1]
         { info_tbl: [(c4zDT,
                       label: block_c4zDT_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zDT: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4zE5; else goto c4zE6;
       c4zE5: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4zE6: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.291343659 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmin_closure" {
     GHC.Int.$fOrdInt32_$cmin_closure:
         const GHC.Int.$fOrdInt32_$cmin_info;
 },
 GHC.Int.$fOrdInt32_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4zEA,
                       label: GHC.Int.$fOrdInt32_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zEA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zEE; else goto c4zEF;
       c4zEE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zEF: // global
           I64[Sp - 16] = block_c4zEx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zES; else goto c4zEy;
       u4zES: // global
           call _c4zEx(R1) args: 0, res: 0, upd: 0;
       c4zEy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zEx() //  [R1]
         { info_tbl: [(c4zEx,
                       label: block_c4zEx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zEx: // global
           I64[Sp - 8] = block_c4zED_info;
           _s4w1v::P64 = R1;
           _s4w1w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w1w::I64;
           P64[Sp + 8] = _s4w1v::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zER; else goto c4zEH;
       u4zER: // global
           call _c4zED(R1) args: 0, res: 0, upd: 0;
       c4zEH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zED() //  [R1]
         { info_tbl: [(c4zED,
                       label: block_c4zED_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zED: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4zEP; else goto c4zEQ;
       c4zEP: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4zEQ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.299982092 UTC

[section ""data" . GHC.Int.$fOrdInt32_closure" {
     GHC.Int.$fOrdInt32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fOrdInt32_$ccompare_closure+2;
         const GHC.Int.ltInt32_closure+2;
         const GHC.Int.leInt32_closure+2;
         const GHC.Int.gtInt32_closure+2;
         const GHC.Int.geInt32_closure+2;
         const GHC.Int.$fOrdInt32_$cmax_closure+2;
         const GHC.Int.$fOrdInt32_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.302623719 UTC

[section ""data" . GHC.Int.$fIxInt32_$cinRange_closure" {
     GHC.Int.$fIxInt32_$cinRange_closure:
         const GHC.Int.$fIxInt32_$cinRange_info;
 },
 GHC.Int.$fIxInt32_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4zFl,
                       label: GHC.Int.$fIxInt32_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zFl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zFu; else goto c4zFv;
       c4zFu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zFv: // global
           I64[Sp - 16] = block_c4zFi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zFS; else goto c4zFj;
       u4zFS: // global
           call _c4zFi(R1) args: 0, res: 0, upd: 0;
       c4zFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zFi() //  [R1]
         { info_tbl: [(c4zFi,
                       label: block_c4zFi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zFi: // global
           I64[Sp - 8] = block_c4zFo_info;
           _s4w1E::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w1E::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zFR; else goto c4zFp;
       u4zFR: // global
           call _c4zFo(R1) args: 0, res: 0, upd: 0;
       c4zFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zFo() //  [R1]
         { info_tbl: [(c4zFo,
                       label: block_c4zFo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zFo: // global
           I64[Sp] = block_c4zFt_info;
           _s4w1G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4w1G::I64;
           if (R1 & 7 != 0) goto u4zFT; else goto c4zFy;
       u4zFT: // global
           call _c4zFt(R1) args: 0, res: 0, upd: 0;
       c4zFy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zFt() //  [R1]
         { info_tbl: [(c4zFt,
                       label: block_c4zFt_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zFt: // global
           _s4w1I::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4w1I::I64)) goto c4zFG; else goto c4zFK;
       c4zFG: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zFK: // global
           _s4w1E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4zFJ_info;
           R1 = _s4w1E::P64;
           I64[Sp + 16] = _s4w1I::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4zFU; else goto c4zFL;
       u4zFU: // global
           call _c4zFJ(R1) args: 0, res: 0, upd: 0;
       c4zFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zFJ() //  [R1]
         { info_tbl: [(c4zFJ,
                       label: block_c4zFJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zFJ: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.314891769 UTC

[section ""data" . GHC.Int.$fNumInt3_closure" {
     GHC.Int.$fNumInt3_closure:
         const GHC.Int.I32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.317854323 UTC

[section ""data" . GHC.Int.$fNumInt32_$csignum_closure" {
     GHC.Int.$fNumInt32_$csignum_closure:
         const GHC.Int.$fNumInt32_$csignum_info;
 },
 GHC.Int.$fNumInt32_$csignum_entry() //  [R2]
         { info_tbl: [(c4zGz,
                       label: GHC.Int.$fNumInt32_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zGz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zGA; else goto c4zGB;
       c4zGA: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zGB: // global
           I64[Sp - 8] = block_c4zGw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zGP; else goto c4zGx;
       u4zGP: // global
           call _c4zGw(R1) args: 0, res: 0, upd: 0;
       c4zGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zGw() //  [R1]
         { info_tbl: [(c4zGw,
                       label: block_c4zGw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zGw: // global
           _s4w1P::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4w1P::I64, 0)) goto c4zGN; else goto c4zGO;
       c4zGN: // global
           if (_s4w1P::I64 == 0) goto c4zGL; else goto c4zGK;
       c4zGL: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zGK: // global
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zGO: // global
           R1 = GHC.Int.$fNumInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.325104091 UTC

[section ""data" . GHC.Int.$fNumInt32_$cabs_closure" {
     GHC.Int.$fNumInt32_$cabs_closure:
         const GHC.Int.$fNumInt32_$cabs_info;
 },
 GHC.Int.$fNumInt32_$cabs_entry() //  [R2]
         { info_tbl: [(c4zHa,
                       label: GHC.Int.$fNumInt32_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zHa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zHb; else goto c4zHc;
       c4zHb: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zHc: // global
           I64[Sp - 8] = block_c4zH7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zHv; else goto c4zH8;
       u4zHv: // global
           call _c4zH7(R1) args: 0, res: 0, upd: 0;
       c4zH8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zH7() //  [R1]
         { info_tbl: [(c4zH7,
                       label: block_c4zH7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zH7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zHh; else goto c4zHg;
       c4zHh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zHg: // global
           _s4w1U::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w1U::I64, 0)) goto c4zHt; else goto c4zHu;
       c4zHt: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-_s4w1U::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zHu: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.331660435 UTC

[section ""data" . GHC.Int.$fNumInt32_closure" {
     GHC.Int.$fNumInt32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt32_$c+_closure+2;
         const GHC.Int.$fNumInt32_$c-_closure+2;
         const GHC.Int.$fNumInt32_$c*_closure+2;
         const GHC.Int.$fNumInt32_$cnegate_closure+1;
         const GHC.Int.$fNumInt32_$cabs_closure+1;
         const GHC.Int.$fNumInt32_$csignum_closure+1;
         const GHC.Int.$fNumInt32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.333920984 UTC

[section ""data" . GHC.Int.$fBitsInt5_closure" {
     GHC.Int.$fBitsInt5_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.336125409 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt32_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4zHS,
                       label: GHC.Int.$fBitsInt32_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zHS: // global
           R1 = GHC.Int.$fBitsInt5_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.340832515 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbit_closure" {
     GHC.Int.$fBitsInt32_$cbit_closure:
         const GHC.Int.$fBitsInt32_$cbit_info;
 },
 GHC.Int.$fBitsInt32_$cbit_entry() //  [R2]
         { info_tbl: [(c4zI7,
                       label: GHC.Int.$fBitsInt32_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zI7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zI8; else goto c4zI9;
       c4zI8: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zI9: // global
           I64[Sp - 8] = block_c4zI4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zIs; else goto c4zI5;
       u4zIs: // global
           call _c4zI4(R1) args: 0, res: 0, upd: 0;
       c4zI5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zI4() //  [R1]
         { info_tbl: [(c4zI4,
                       label: block_c4zI4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zI4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zIe; else goto c4zId;
       c4zIe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zId: // global
           _s4w21::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w21::I64, 64)) goto c4zIq; else goto c4zIr;
       c4zIq: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4w21::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zIr: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.348044412 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ctestBit_closure" {
     GHC.Int.$fBitsInt32_$ctestBit_closure:
         const GHC.Int.$fBitsInt32_$ctestBit_info;
 },
 GHC.Int.$fBitsInt32_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4zIP,
                       label: GHC.Int.$fBitsInt32_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zIP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zIT; else goto c4zIU;
       c4zIT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zIU: // global
           I64[Sp - 16] = block_c4zIM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zJC; else goto c4zIN;
       u4zJC: // global
           call _c4zIM(R1) args: 0, res: 0, upd: 0;
       c4zIN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zIM() //  [R1]
         { info_tbl: [(c4zIM,
                       label: block_c4zIM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zIM: // global
           I64[Sp] = block_c4zIS_info;
           _s4w28::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w28::I64;
           if (R1 & 7 != 0) goto u4zJB; else goto c4zIW;
       u4zJB: // global
           call _c4zIS(R1) args: 0, res: 0, upd: 0;
       c4zIW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zIS() //  [R1]
         { info_tbl: [(c4zIS,
                       label: block_c4zIS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zIS: // global
           _s4w2a::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4w2a::I64, 64)) goto c4zJA; else goto c4zJz;
       c4zJz: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4w2a::I64)) == 0) goto c4zJA; else goto c4zJo;
       c4zJA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zJo: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.358064369 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateR_closure" {
     GHC.Int.$fBitsInt32_$crotateR_closure:
         const GHC.Int.$fBitsInt32_$crotateR_info;
 },
 GHC.Int.$fBitsInt32_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4zK7,
                       label: GHC.Int.$fBitsInt32_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zK7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zKb; else goto c4zKc;
       c4zKb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zKc: // global
           I64[Sp - 16] = block_c4zK4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zLb; else goto c4zK5;
       u4zLb: // global
           call _c4zK4(R1) args: 0, res: 0, upd: 0;
       c4zK5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zK4() //  [R1]
         { info_tbl: [(c4zK4,
                       label: block_c4zK4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zK4: // global
           I64[Sp - 8] = block_c4zKa_info;
           _s4w2k::P64 = R1;
           _s4w2l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w2l::I64;
           P64[Sp + 8] = _s4w2k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zLa; else goto c4zKe;
       u4zLa: // global
           call _c4zKa(R1) args: 0, res: 0, upd: 0;
       c4zKe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zKa() //  [R1]
         { info_tbl: [(c4zKa,
                       label: block_c4zKa_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zKa: // global
           _s4w2r::I64 = -I64[R1 + 7] & 31;
           if (_s4w2r::I64 != 0) goto u4zL8; else goto c4zL4;
       u4zL8: // global
           I64[Sp + 16] = _s4w2r::I64;
           Sp = Sp + 8;
           call _c4zKw() args: 0, res: 0, upd: 0;
       c4zL4: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4zKw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zKw: // global
           Hp = Hp + 16;
           _s4w2r::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4zL1; else goto c4zL0;
       c4zL1: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4zKv_info;
           R1 = _s4w2r::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4zL0: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4w2s::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4w2s::I64 << _s4w2r::I64) | (_s4w2s::I64 >> 32 - _s4w2r::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4zKv() //  [R1]
         { info_tbl: [(c4zKv,
                       label: block_c4zKv_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zKv: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4zKw() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.371113735 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt32_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt32_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt32_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4zLS,
                       label: GHC.Int.$fBitsInt32_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zLS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zLW; else goto c4zLX;
       c4zLW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zLX: // global
           I64[Sp - 16] = block_c4zLP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zMw; else goto c4zLQ;
       u4zMw: // global
           call _c4zLP(R1) args: 0, res: 0, upd: 0;
       c4zLQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zLP() //  [R1]
         { info_tbl: [(c4zLP,
                       label: block_c4zLP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zLP: // global
           I64[Sp - 8] = block_c4zLV_info;
           _s4w2C::P64 = R1;
           _s4w2D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w2D::I64;
           P64[Sp + 8] = _s4w2C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zMv; else goto c4zLZ;
       u4zMv: // global
           call _c4zLV(R1) args: 0, res: 0, upd: 0;
       c4zLZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zLV() //  [R1]
         { info_tbl: [(c4zLV,
                       label: block_c4zLV_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zLV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zM5; else goto c4zM4;
       c4zM5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zM4: // global
           _s4w2F::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w2F::I64, 64)) goto c4zMt; else goto c4zMu;
       c4zMt: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4w2F::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zMu: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.380530478 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cclearBit_closure" {
     GHC.Int.$fBitsInt32_$cclearBit_closure:
         const GHC.Int.$fBitsInt32_$cclearBit_info;
 },
 GHC.Int.$fBitsInt32_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4zN1,
                       label: GHC.Int.$fBitsInt32_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zN1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zN5; else goto c4zN6;
       c4zN5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zN6: // global
           I64[Sp - 16] = block_c4zMY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zNT; else goto c4zMZ;
       u4zNT: // global
           call _c4zMY(R1) args: 0, res: 0, upd: 0;
       c4zMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zMY() //  [R1]
         { info_tbl: [(c4zMY,
                       label: block_c4zMY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zMY: // global
           I64[Sp] = block_c4zN4_info;
           _s4w2Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w2Q::I64;
           if (R1 & 7 != 0) goto u4zNS; else goto c4zN8;
       u4zNS: // global
           call _c4zN4(R1) args: 0, res: 0, upd: 0;
       c4zN8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zN4() //  [R1]
         { info_tbl: [(c4zN4,
                       label: block_c4zN4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zN4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zNe; else goto c4zNd;
       c4zNe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zNd: // global
           _s4w2Q::I64 = I64[Sp + 8];
           _s4w2S::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w2S::I64, 64)) goto c4zNF; else goto c4zNR;
       c4zNF: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4w2Q::I64 & ~%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4w2S::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zNR: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4w2Q::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.391014062 UTC

[section ""data" . GHC.Int.$fBitsInt32_$csetBit_closure" {
     GHC.Int.$fBitsInt32_$csetBit_closure:
         const GHC.Int.$fBitsInt32_$csetBit_info;
 },
 GHC.Int.$fBitsInt32_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4zOq,
                       label: GHC.Int.$fBitsInt32_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zOq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zOu; else goto c4zOv;
       c4zOu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zOv: // global
           I64[Sp - 16] = block_c4zOn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zP4; else goto c4zOo;
       u4zP4: // global
           call _c4zOn(R1) args: 0, res: 0, upd: 0;
       c4zOo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zOn() //  [R1]
         { info_tbl: [(c4zOn,
                       label: block_c4zOn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zOn: // global
           I64[Sp - 8] = block_c4zOt_info;
           _s4w36::P64 = R1;
           _s4w37::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w37::I64;
           P64[Sp + 8] = _s4w36::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zP3; else goto c4zOx;
       u4zP3: // global
           call _c4zOt(R1) args: 0, res: 0, upd: 0;
       c4zOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zOt() //  [R1]
         { info_tbl: [(c4zOt,
                       label: block_c4zOt_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zOt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zOD; else goto c4zOC;
       c4zOD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zOC: // global
           _s4w39::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w39::I64, 64)) goto c4zP1; else goto c4zP2;
       c4zP1: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4w39::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zP2: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.399816492 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateL_closure" {
     GHC.Int.$fBitsInt32_$crotateL_closure:
         const GHC.Int.$fBitsInt32_$crotateL_info;
 },
 GHC.Int.$fBitsInt32_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4zPw,
                       label: GHC.Int.$fBitsInt32_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zPw: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt32_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.403898713 UTC

[section ""data" . GHC.Int.$fBitsInt32_closure" {
     GHC.Int.$fBitsInt32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fBitsInt32_$c.&._closure+2;
         const GHC.Int.$fBitsInt32_$c.|._closure+2;
         const GHC.Int.$fBitsInt32_$cxor_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt32_$cshift_closure+2;
         const GHC.Int.$fBitsInt32_$crotate_closure+2;
         const GHC.Int.$fBitsInt6_closure+1;
         const GHC.Int.$fBitsInt32_$cbit_closure+1;
         const GHC.Int.$fBitsInt32_$csetBit_closure+2;
         const GHC.Int.$fBitsInt32_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt32_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt32_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt32_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt32_$crotateL_closure+2;
         const GHC.Int.$fBitsInt32_$crotateR_closure+2;
         const GHC.Int.$fBitsInt32_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.406180299 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_closure" {
     GHC.Int.$fFiniteBitsInt32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt32_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.409133004 UTC

[section ""data" . GHC.Int.$fReadInt32_go_closure" {
     GHC.Int.$fReadInt32_go_closure:
         const GHC.Int.$fReadInt32_go_info;
 },
 sat_s4w3t_entry() //  [R1]
         { info_tbl: [(c4zPY,
                       label: sat_s4w3t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zPY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zPZ; else goto c4zQ0;
       c4zPZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zQ0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4w3r_entry() //  [R1]
         { info_tbl: [(c4zQ8,
                       label: sat_s4w3r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zQ8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zQf; else goto c4zQg;
       c4zQf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zQg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4zQ5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4zQk; else goto c4zQ6;
       u4zQk: // global
           call _c4zQ5(R1) args: 0, res: 0, upd: 0;
       c4zQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4zQ5() //  [R1]
         { info_tbl: [(c4zQ5,
                       label: block_c4zQ5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zQ5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zQj; else goto c4zQi;
       c4zQj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4zQi: // global
           _s4w3q::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4w3q::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt32_go_entry() //  [R2]
         { info_tbl: [(c4zQp,
                       label: GHC.Int.$fReadInt32_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zQp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zQq; else goto c4zQr;
       c4zQq: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zQr: // global
           I64[Sp - 8] = block_c4zPJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zQB; else goto c4zPK;
       u4zQB: // global
           call _c4zPJ(R1) args: 0, res: 0, upd: 0;
       c4zPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zPJ() //  [R1]
         { info_tbl: [(c4zPJ,
                       label: block_c4zPJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zPJ: // global
           if (R1 & 7 == 1) goto c4zQm; else goto c4zQn;
       c4zQm: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zQn: // global
           I64[Sp - 8] = block_c4zPP_info;
           _s4w3k::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4w3k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zQA; else goto c4zPQ;
       u4zQA: // global
           call _c4zPP(R1) args: 0, res: 0, upd: 0;
       c4zPQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zPP() //  [R1]
         { info_tbl: [(c4zPP,
                       label: block_c4zPP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zPP: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4zQz; else goto c4zQy;
       c4zQz: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zQy: // global
           _s4w3m::P64 = P64[R1 + 7];
           _s4w3n::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4w3t_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4w3r_info;
           P64[Hp - 48] = _s4w3m::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4w3n::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.424932512 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadsPrec_closure" {
     GHC.Int.$fReadInt32_$creadsPrec_closure:
         const GHC.Int.$fReadInt32_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4zRs,
                       label: GHC.Int.$fReadInt32_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zRs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zRw; else goto c4zRx;
       c4zRw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zRx: // global
           I64[Sp - 16] = block_c4zRq_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4w3v::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4w3v::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zRq() //  [R1]
         { info_tbl: [(c4zRq,
                       label: block_c4zRq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zRq: // global
           _s4w3v::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4zRv_info;
           R3 = _s4w3v::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zRv() //  [R1]
         { info_tbl: [(c4zRv,
                       label: block_c4zRv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zRv: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.432931227 UTC

[section ""data" . GHC.Int.$fReadInt6_closure" {
     GHC.Int.$fReadInt6_closure:
         const GHC.Int.$fReadInt6_info;
         const 0;
 },
 sat_s4w3A_entry() //  [R1, R2]
         { info_tbl: [(c4zS1,
                       label: sat_s4w3A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zS1: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt32_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt6_entry() //  [R2, R3]
         { info_tbl: [(c4zS7,
                       label: GHC.Int.$fReadInt6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zS7: // global
           _s4w3z::P64 = R3;
           _s4w3y::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4zS8; else goto c4zS9;
       c4zS9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zSb; else goto c4zSa;
       c4zSb: // global
           HpAlloc = 16;
           goto c4zS8;
       c4zS8: // global
           R3 = _s4w3z::P64;
           R2 = _s4w3y::P64;
           R1 = GHC.Int.$fReadInt6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zSa: // global
           I64[Hp - 8] = sat_s4w3A_info;
           P64[Hp] = _s4w3y::P64;
           I64[Sp - 8] = block_c4zS4_info;
           R3 = _s4w3z::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zS4() //  [R1]
         { info_tbl: [(c4zS4,
                       label: block_c4zS4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zS4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zSe; else goto c4zSd;
       c4zSe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zSd: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.441715897 UTC

[section ""data" . GHC.Int.$fReadInt5_closure" {
     GHC.Int.$fReadInt5_closure:
         const GHC.Int.$fReadInt5_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4zSD_srtd" {
     u4zSD_srtd:
         const S4wm5_srt+504;
         const 46;
         const 35184372088833;
 },
 GHC.Int.$fReadInt5_entry() //  [R1]
         { info_tbl: [(c4zSA,
                       label: GHC.Int.$fReadInt5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zSA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4zSB; else goto c4zSC;
       c4zSB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zSC: // global
           (_c4zSx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4zSx::I64 == 0) goto c4zSz; else goto c4zSy;
       c4zSz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4zSy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4zSx::I64;
           R2 = GHC.Int.$fReadInt6_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.447809669 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadList_closure" {
     GHC.Int.$fReadInt32_$creadList_closure:
         const GHC.Int.$fReadInt32_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadList_entry() //  [R2]
         { info_tbl: [(c4zSV,
                       label: GHC.Int.$fReadInt32_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zSV: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt5_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.451932405 UTC

[section ""data" . GHC.Int.$fReadInt4_closure" {
     GHC.Int.$fReadInt4_closure:
         const GHC.Int.$fReadInt4_info;
         const 0;
 },
 GHC.Int.$fReadInt4_entry() //  [R2, R3]
         { info_tbl: [(c4zT9,
                       label: GHC.Int.$fReadInt4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zT9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zTa; else goto c4zTb;
       c4zTa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zTb: // global
           I64[Sp - 8] = block_c4zT6_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt32_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zT6() //  [R1]
         { info_tbl: [(c4zT6,
                       label: block_c4zT6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zT6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zTe; else goto c4zTd;
       c4zTe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zTd: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.461133816 UTC

[section ""data" . GHC.Int.$fReadInt32_closure" {
     GHC.Int.$fReadInt32_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt32_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt32_$creadList_closure+1;
         const GHC.Int.$fReadInt6_closure+2;
         const GHC.Int.$fReadInt4_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.464818185 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquot_closure" {
     GHC.Int.$fIntegralInt32_$cquot_closure:
         const GHC.Int.$fIntegralInt32_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4zTy,
                       label: GHC.Int.$fIntegralInt32_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zTy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zTC; else goto c4zTD;
       c4zTC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zTD: // global
           I64[Sp - 16] = block_c4zTv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zUe; else goto c4zTw;
       u4zUe: // global
           call _c4zTv(R1) args: 0, res: 0, upd: 0;
       c4zTw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zTv() //  [R1]
         { info_tbl: [(c4zTv,
                       label: block_c4zTv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zTv: // global
           I64[Sp] = block_c4zTB_info;
           _s4w3K::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w3K::I64;
           if (R1 & 7 != 0) goto u4zUd; else goto c4zTF;
       u4zUd: // global
           call _c4zTB(R1) args: 0, res: 0, upd: 0;
       c4zTF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zTB() //  [R1]
         { info_tbl: [(c4zTB,
                       label: block_c4zTB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zTB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zTL; else goto c4zTK;
       c4zTL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zTK: // global
           _s4w3K::I64 = I64[Sp + 8];
           _s4w3N::I64 = I64[R1 + 7];
           if (_s4w3N::I64 != (-1)) goto u4zUc; else goto c4zUa;
       u4zUc: // global
           if (_s4w3N::I64 != 0) goto c4zTW; else goto c4zUb;
       c4zTW: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4w3K::I64,
                                                                            _s4w3N::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zUb: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zUa: // global
           if (_s4w3K::I64 == (-2147483648)) goto c4zU9; else goto c4zU8;
       c4zU9: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zU8: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4w3K::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.475443588 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$crem_closure" {
     GHC.Int.$fIntegralInt32_$crem_closure:
         const GHC.Int.$fIntegralInt32_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4zUI,
                       label: GHC.Int.$fIntegralInt32_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zUI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zUM; else goto c4zUN;
       c4zUM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zUN: // global
           I64[Sp - 16] = block_c4zUF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zVb; else goto c4zUG;
       u4zVb: // global
           call _c4zUF(R1) args: 0, res: 0, upd: 0;
       c4zUG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zUF() //  [R1]
         { info_tbl: [(c4zUF,
                       label: block_c4zUF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zUF: // global
           I64[Sp] = block_c4zUL_info;
           _s4w3Y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w3Y::I64;
           if (R1 & 7 != 0) goto u4zVa; else goto c4zUP;
       u4zVa: // global
           call _c4zUL(R1) args: 0, res: 0, upd: 0;
       c4zUP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zUL() //  [R1]
         { info_tbl: [(c4zUL,
                       label: block_c4zUL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zUL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zUV; else goto c4zUU;
       c4zUV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zUU: // global
           _s4w41::I64 = I64[R1 + 7];
           if (_s4w41::I64 != (-1)) goto u4zV9; else goto c4zV7;
       u4zV9: // global
           if (_s4w41::I64 != 0) goto c4zV6; else goto c4zV8;
       c4zV6: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4w41::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zV8: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zV7: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.484599094 UTC

[section ""data" . GHC.Int.$w$cdiv1_closure" {
     GHC.Int.$w$cdiv1_closure:
         const GHC.Int.$w$cdiv1_info;
         const 0;
 },
 GHC.Int.$w$cdiv1_entry() //  [R2, R3]
         { info_tbl: [(c4zVE,
                       label: GHC.Int.$w$cdiv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zVE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zVF; else goto c4zVG;
       c4zVF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zVG: // global
           if (R3 == (-1)) goto c4zVC; else goto u4zW0;
       c4zVC: // global
           if (R2 == (-2147483648)) goto c4zVZ; else goto c4zVX;
       c4zVZ: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zVX: // global
           I64[Sp - 8] = block_c4zVR_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4zW0: // global
           if (R3 == 0) goto c4zVD; else goto c4zVB;
       c4zVD: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zVB: // global
           I64[Sp - 8] = block_c4zVI_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zVR() //  [R1]
         { info_tbl: [(c4zVR,
                       label: block_c4zVR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zVR: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4zVI() //  [R1]
         { info_tbl: [(c4zVI,
                       label: block_c4zVI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zVI: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.494338981 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdiv_closure" {
     GHC.Int.$fIntegralInt32_$cdiv_closure:
         const GHC.Int.$fIntegralInt32_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4zWn,
                       label: GHC.Int.$fIntegralInt32_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zWn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zWA; else goto c4zWB;
       c4zWA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zWB: // global
           I64[Sp - 16] = block_c4zWk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zWI; else goto c4zWl;
       u4zWI: // global
           call _c4zWk(R1) args: 0, res: 0, upd: 0;
       c4zWl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zWk() //  [R1]
         { info_tbl: [(c4zWk,
                       label: block_c4zWk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zWk: // global
           I64[Sp] = block_c4zWq_info;
           _s4w4f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w4f::I64;
           if (R1 & 7 != 0) goto u4zWH; else goto c4zWr;
       u4zWH: // global
           call _c4zWq(R1) args: 0, res: 0, upd: 0;
       c4zWr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zWq() //  [R1]
         { info_tbl: [(c4zWq,
                       label: block_c4zWq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zWq: // global
           _s4w4f::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4zWv_info;
           R3 = I64[R1 + 7];
           R2 = _s4w4f::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4zWv() //  [R1]
         { info_tbl: [(c4zWv,
                       label: block_c4zWv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zWv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zWG; else goto c4zWF;
       c4zWG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4zWF: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.504517411 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cmod_closure" {
     GHC.Int.$fIntegralInt32_$cmod_closure:
         const GHC.Int.$fIntegralInt32_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4zXb,
                       label: GHC.Int.$fIntegralInt32_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zXb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zXf; else goto c4zXg;
       c4zXf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zXg: // global
           I64[Sp - 16] = block_c4zX8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zXG; else goto c4zX9;
       u4zXG: // global
           call _c4zX8(R1) args: 0, res: 0, upd: 0;
       c4zX9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zX8() //  [R1]
         { info_tbl: [(c4zX8,
                       label: block_c4zX8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zX8: // global
           I64[Sp] = block_c4zXe_info;
           _s4w4m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w4m::I64;
           if (R1 & 7 != 0) goto u4zXF; else goto c4zXi;
       u4zXF: // global
           call _c4zXe(R1) args: 0, res: 0, upd: 0;
       c4zXi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zXe() //  [R1]
         { info_tbl: [(c4zXe,
                       label: block_c4zXe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zXe: // global
           _s4w4p::I64 = I64[R1 + 7];
           if (_s4w4p::I64 != (-1)) goto u4zXE; else goto c4zXC;
       u4zXE: // global
           if (_s4w4p::I64 != 0) goto c4zXy; else goto c4zXD;
       c4zXy: // global
           _s4w4m::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4zXp_info;
           R3 = _s4w4p::I64;
           R2 = _s4w4m::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4zXD: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zXC: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4zXp() //  [R1]
         { info_tbl: [(c4zXp,
                       label: block_c4zXp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zXp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zXB; else goto c4zXA;
       c4zXB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4zXA: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.51564856 UTC

[section ""data" . lvl8_r4kPz_closure" {
     lvl8_r4kPz_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt6_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.518397439 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquotRem_closure" {
     GHC.Int.$fIntegralInt32_$cquotRem_closure:
         const GHC.Int.$fIntegralInt32_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4zYc,
                       label: GHC.Int.$fIntegralInt32_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zYc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zYg; else goto c4zYh;
       c4zYg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zYh: // global
           I64[Sp - 16] = block_c4zY9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zYW; else goto c4zYa;
       u4zYW: // global
           call _c4zY9(R1) args: 0, res: 0, upd: 0;
       c4zYa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zY9() //  [R1]
         { info_tbl: [(c4zY9,
                       label: block_c4zY9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zY9: // global
           I64[Sp] = block_c4zYf_info;
           _s4w4w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w4w::I64;
           if (R1 & 7 != 0) goto u4zYV; else goto c4zYj;
       u4zYV: // global
           call _c4zYf(R1) args: 0, res: 0, upd: 0;
       c4zYj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4zYf() //  [R1]
         { info_tbl: [(c4zYf,
                       label: block_c4zYf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zYf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4zYp; else goto c4zYo;
       c4zYp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zYo: // global
           _s4w4w::I64 = I64[Sp + 8];
           _s4w4z::I64 = I64[R1 + 7];
           if (_s4w4z::I64 != (-1)) goto u4zYU; else goto c4zYS;
       u4zYU: // global
           if (_s4w4z::I64 != 0) goto c4zYC; else goto c4zYT;
       c4zYC: // global
           (_s4w4B::I64, _s4w4C::I64) = call MO_S_QuotRem W64(_s4w4w::I64, _s4w4z::I64);
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4C::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4B::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zYT: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zYS: // global
           if (_s4w4w::I64 == (-2147483648)) goto c4zYR; else goto c4zYQ;
       c4zYR: // global
           Hp = Hp - 56;
           R1 = lvl8_r4kPz_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zYQ: // global
           (_s4w4J::I64, _s4w4K::I64) = call MO_S_QuotRem W64(_s4w4w::I64, (-1));
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4K::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4J::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.530379844 UTC

[section ""data" . GHC.Int.$w$cdivMod1_closure" {
     GHC.Int.$w$cdivMod1_closure:
         const GHC.Int.$w$cdivMod1_info;
         const 0;
 },
 GHC.Int.$w$cdivMod1_entry() //  [R2, R3]
         { info_tbl: [(c4zZC,
                       label: GHC.Int.$w$cdivMod1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zZC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zZD; else goto c4zZE;
       c4zZD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zZE: // global
           if (R3 == 0) goto c4zZB; else goto c4zZA;
       c4zZB: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zZA: // global
           if (R3 == (-1)) goto c4A27; else goto u4A28;
       c4A27: // global
           if (R2 == (-2147483648)) goto c4A26; else goto u4A29;
       c4A26: // global
           R2 = GHC.Int.$fBitsInt6_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4A29: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4A2b;
       u4A28: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4A2b;
       u4A2b: // global
           call _c4zZJ() args: 0, res: 0, upd: 0;
     }
 },
 _c4zZJ() //  []
         { info_tbl: [(c4zZJ,
                       label: block_c4zZJ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4zZJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4zZN; else goto c4zZM;
       c4zZN: // global
           HpAlloc = 32;
           I64[Sp] = block_c4zZJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4zZM: // global
           _s4w4Q::I64 = I64[Sp + 8];
           _s4w4S::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4w4Q::I64, 0)) goto c4A0G; else goto c4A1X;
       c4A0G: // global
           if (%MO_S_Ge_W64(_s4w4Q::I64, 0)) goto c4A03; else goto c4A0E;
       c4A03: // global
           (_s4w4X::I64, _s4w4Y::I64) = call MO_S_QuotRem W64(_s4w4Q::I64, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4Y::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4X::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A0E: // global
           if (%MO_S_Le_W64(_s4w4S::I64, 0)) goto c4A0h; else goto c4A0D;
       c4A0h: // global
           (_s4w55::I64, _s4w56::I64) = call MO_S_QuotRem W64(_s4w4Q::I64, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w56::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w55::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A0D: // global
           (_s4w5d::I64, _s4w5e::I64) = call MO_S_QuotRem W64(_s4w4Q::I64 + 1, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5e::I64 + _s4w4S::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5d::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A1X: // global
           if (%MO_S_Ge_W64(_s4w4S::I64, 0)) goto c4A1A; else goto c4A1W;
       c4A1A: // global
           if (%MO_S_Ge_W64(_s4w4Q::I64, 0)) goto c4A0X; else goto c4A1y;
       c4A0X: // global
           (_s4w5p::I64, _s4w5q::I64) = call MO_S_QuotRem W64(_s4w4Q::I64, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5q::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5p::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A1y: // global
           if (%MO_S_Le_W64(_s4w4S::I64, 0)) goto c4A1b; else goto c4A1x;
       c4A1b: // global
           (_s4w5x::I64, _s4w5y::I64) = call MO_S_QuotRem W64(_s4w4Q::I64, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5y::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5x::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A1x: // global
           (_s4w5F::I64, _s4w5G::I64) = call MO_S_QuotRem W64(_s4w4Q::I64 + 1, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5G::I64 + _s4w4S::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5F::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A1W: // global
           (_s4w5Q::I64, _s4w5R::I64) = call MO_S_QuotRem W64(_s4w4Q::I64 - 1, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5R::I64 + _s4w4S::I64 + 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5Q::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.542751026 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdivMod_closure" {
     GHC.Int.$fIntegralInt32_$cdivMod_closure:
         const GHC.Int.$fIntegralInt32_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4A3e,
                       label: GHC.Int.$fIntegralInt32_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A3e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4A3p; else goto c4A3q;
       c4A3p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4A3q: // global
           I64[Sp - 16] = block_c4A3b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4A3x; else goto c4A3c;
       u4A3x: // global
           call _c4A3b(R1) args: 0, res: 0, upd: 0;
       c4A3c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A3b() //  [R1]
         { info_tbl: [(c4A3b,
                       label: block_c4A3b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A3b: // global
           I64[Sp] = block_c4A3h_info;
           _s4w65::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w65::I64;
           if (R1 & 7 != 0) goto u4A3w; else goto c4A3i;
       u4A3w: // global
           call _c4A3h(R1) args: 0, res: 0, upd: 0;
       c4A3i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A3h() //  [R1]
         { info_tbl: [(c4A3h,
                       label: block_c4A3h_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A3h: // global
           _s4w65::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4A3m_info;
           R3 = I64[R1 + 7];
           R2 = _s4w65::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4A3m() //  [R1, R2]
         { info_tbl: [(c4A3m,
                       label: block_c4A3m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A3m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4A3v; else goto c4A3u;
       c4A3v: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4A3u: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.553763465 UTC

[section ""data" . GHC.Int.$fRealInt32_$ctoRational_closure" {
     GHC.Int.$fRealInt32_$ctoRational_closure:
         const GHC.Int.$fRealInt32_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt32_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4A40,
                       label: GHC.Int.$fRealInt32_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A40: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4A4e; else goto c4A4f;
       c4A4e: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4A4f: // global
           I64[Sp - 8] = block_c4A3X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A4m; else goto c4A3Y;
       u4A4m: // global
           call _c4A3X(R1) args: 0, res: 0, upd: 0;
       c4A3Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A3X() //  [R1]
         { info_tbl: [(c4A3X,
                       label: block_c4A3X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A3X: // global
           I64[Sp] = block_c4A43_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4A43() //  [R1]
         { info_tbl: [(c4A43,
                       label: block_c4A43_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A43: // global
           I64[Sp] = block_c4A47_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4A47() //  [R1]
         { info_tbl: [(c4A47,
                       label: block_c4A47_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A47: // global
           I64[Sp] = block_c4A4b_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4A4b() //  [R1, R2]
         { info_tbl: [(c4A4b,
                       label: block_c4A4b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A4b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4A4l; else goto c4A4k;
       c4A4l: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4A4k: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.565097082 UTC

[section ""data" . GHC.Int.$fRealInt32_closure" {
     GHC.Int.$fRealInt32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt32_closure+1;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fRealInt32_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.566996392 UTC

[section ""data" . GHC.Int.$fIntegralInt32_closure" {
     GHC.Int.$fIntegralInt32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt32_closure+1;
         const GHC.Int.$fEnumInt32_closure+1;
         const GHC.Int.$fIntegralInt32_$cquot_closure+2;
         const GHC.Int.$fIntegralInt32_$crem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt32_$cmod_closure+2;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt32_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.569446508 UTC

[section ""data" . GHC.Int.$fIxInt32_$crange_closure" {
     GHC.Int.$fIxInt32_$crange_closure:
         const GHC.Int.$fIxInt32_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$crange_entry() //  [R2]
         { info_tbl: [(c4A4U,
                       label: GHC.Int.$fIxInt32_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A4U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4A4V; else goto c4A4W;
       c4A4V: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4A4W: // global
           I64[Sp - 8] = block_c4A4R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A50; else goto c4A4S;
       u4A50: // global
           call _c4A4R(R1) args: 0, res: 0, upd: 0;
       c4A4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A4R() //  [R1]
         { info_tbl: [(c4A4R,
                       label: block_c4A4R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A4R: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.576355926 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt32_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt32_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt32_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4A5i,
                       label: GHC.Int.$fIxInt32_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A5i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4A5z; else goto c4A5A;
       c4A5z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4A5A: // global
           I64[Sp - 16] = block_c4A5f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4A5H; else goto c4A5g;
       u4A5H: // global
           call _c4A5f(R1) args: 0, res: 0, upd: 0;
       c4A5g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A5f() //  [R1]
         { info_tbl: [(c4A5f,
                       label: block_c4A5f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A5f: // global
           I64[Sp] = block_c4A5l_info;
           _s4w6q::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4w6q::P64;
           if (R1 & 7 != 0) goto u4A5G; else goto c4A5m;
       u4A5G: // global
           call _c4A5l(R1) args: 0, res: 0, upd: 0;
       c4A5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A5l() //  [R1]
         { info_tbl: [(c4A5l,
                       label: block_c4A5l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A5l: // global
           I64[Sp] = block_c4A5q_info;
           _s4w6t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w6t::I64;
           if (R1 & 7 != 0) goto u4A5I; else goto c4A5r;
       u4A5I: // global
           call _c4A5q(R1) args: 0, res: 0, upd: 0;
       c4A5r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A5q() //  [R1]
         { info_tbl: [(c4A5q,
                       label: block_c4A5q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A5q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4A5F; else goto c4A5E;
       c4A5F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4A5E: // global
           _s4w6w::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w6w::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.58675783 UTC

[section ""data" . GHC.Int.$fIxInt32_$crangeSize_closure" {
     GHC.Int.$fIxInt32_$crangeSize_closure:
         const GHC.Int.$fIxInt32_$crangeSize_info;
 },
 GHC.Int.$fIxInt32_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4A6e,
                       label: GHC.Int.$fIxInt32_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A6e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4A6n; else goto c4A6o;
       c4A6n: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4A6o: // global
           I64[Sp - 8] = block_c4A6b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A6N; else goto c4A6c;
       u4A6N: // global
           call _c4A6b(R1) args: 0, res: 0, upd: 0;
       c4A6c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A6b() //  [R1]
         { info_tbl: [(c4A6b,
                       label: block_c4A6b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A6b: // global
           I64[Sp - 8] = block_c4A6h_info;
           _s4w6A::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w6A::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A6M; else goto c4A6i;
       u4A6M: // global
           call _c4A6h(R1) args: 0, res: 0, upd: 0;
       c4A6i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A6h() //  [R1]
         { info_tbl: [(c4A6h,
                       label: block_c4A6h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A6h: // global
           I64[Sp] = block_c4A6m_info;
           _s4w6C::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w6C::I64;
           if (R1 & 7 != 0) goto u4A6O; else goto c4A6r;
       u4A6O: // global
           call _c4A6m(R1) args: 0, res: 0, upd: 0;
       c4A6r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A6m() //  [R1]
         { info_tbl: [(c4A6m,
                       label: block_c4A6m_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A6m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4A6x; else goto c4A6w;
       c4A6x: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4A6w: // global
           _s4w6C::I64 = I64[Sp + 8];
           _s4w6E::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4w6C::I64,
                            _s4w6E::I64)) goto c4A6B; else goto c4A6L;
       c4A6B: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4A6L: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w6E::I64 - _s4w6C::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.598593918 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt32_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt32_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4A7m,
                       label: GHC.Int.$fIxInt32_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A7m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4A7G; else goto c4A7H;
       c4A7G: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4A7H: // global
           I64[Sp - 8] = block_c4A7j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A7O; else goto c4A7k;
       u4A7O: // global
           call _c4A7j(R1) args: 0, res: 0, upd: 0;
       c4A7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A7j() //  [R1]
         { info_tbl: [(c4A7j,
                       label: block_c4A7j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A7j: // global
           I64[Sp - 8] = block_c4A7p_info;
           _s4w6K::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4w6K::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A7N; else goto c4A7q;
       u4A7N: // global
           call _c4A7p(R1) args: 0, res: 0, upd: 0;
       c4A7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A7p() //  [R1]
         { info_tbl: [(c4A7p,
                       label: block_c4A7p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A7p: // global
           I64[Sp] = block_c4A7u_info;
           _s4w6N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w6N::I64;
           if (R1 & 7 != 0) goto u4A7P; else goto c4A7v;
       u4A7P: // global
           call _c4A7u(R1) args: 0, res: 0, upd: 0;
       c4A7v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A7u() //  [R1]
         { info_tbl: [(c4A7u,
                       label: block_c4A7u_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A7u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4A7M; else goto c4A7L;
       c4A7M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4A7L: // global
           _s4w6R::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w6R::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.609131147 UTC

[section ""data" . GHC.Int.$fIxInt32_$cindex_closure" {
     GHC.Int.$fIxInt32_$cindex_closure:
         const GHC.Int.$fIxInt32_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4A8m,
                       label: GHC.Int.$fIxInt32_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A8m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4A8v; else goto c4A8w;
       c4A8v: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4A8w: // global
           I64[Sp - 16] = block_c4A8j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4A95; else goto c4A8k;
       u4A95: // global
           call _c4A8j(R1) args: 0, res: 0, upd: 0;
       c4A8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A8j() //  [R1]
         { info_tbl: [(c4A8j,
                       label: block_c4A8j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A8j: // global
           I64[Sp - 8] = block_c4A8p_info;
           _s4w6W::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w6W::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A94; else goto c4A8q;
       u4A94: // global
           call _c4A8p(R1) args: 0, res: 0, upd: 0;
       c4A8q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A8p() //  [R1]
         { info_tbl: [(c4A8p,
                       label: block_c4A8p_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A8p: // global
           I64[Sp] = block_c4A8u_info;
           _s4w6Y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4w6Y::I64;
           if (R1 & 7 != 0) goto u4A96; else goto c4A8z;
       u4A96: // global
           call _c4A8u(R1) args: 0, res: 0, upd: 0;
       c4A8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A8u() //  [R1]
         { info_tbl: [(c4A8u,
                       label: block_c4A8u_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A8u: // global
           _s4w70::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4w70::I64)) goto c4A8H; else goto c4A8L;
       c4A8H: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4A8L: // global
           I64[Sp] = block_c4A8K_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w70::I64;
           if (R1 & 7 != 0) goto u4A97; else goto c4A8M;
       u4A97: // global
           call _c4A8K(R1) args: 0, res: 0, upd: 0;
       c4A8M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A8K() //  [R1]
         { info_tbl: [(c4A8K,
                       label: block_c4A8K_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A8K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4A8S; else goto c4A8R;
       c4A8S: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4A8R: // global
           _s4w70::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4w70::I64,
                            I64[R1 + 7])) goto c4A8W; else goto c4A93;
       c4A8W: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4A93: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w70::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.622644261 UTC

[section ""data" . GHC.Int.$fIxInt32_closure" {
     GHC.Int.$fIxInt32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fIxInt32_$crange_closure+1;
         const GHC.Int.$fIxInt32_$cindex_closure+2;
         const GHC.Int.$fIxInt32_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt32_$cinRange_closure+2;
         const GHC.Int.$fIxInt32_$crangeSize_closure+1;
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.625105692 UTC

[section ""data" . GHC.Int.eqInt64_closure" {
     GHC.Int.eqInt64_closure:
         const GHC.Int.eqInt64_info;
 },
 GHC.Int.eqInt64_entry() //  [R2, R3]
         { info_tbl: [(c4A9L,
                       label: GHC.Int.eqInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A9L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4A9P; else goto c4A9Q;
       c4A9P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4A9Q: // global
           I64[Sp - 16] = block_c4A9I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4A9Z; else goto c4A9J;
       u4A9Z: // global
           call _c4A9I(R1) args: 0, res: 0, upd: 0;
       c4A9J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A9I() //  [R1]
         { info_tbl: [(c4A9I,
                       label: block_c4A9I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A9I: // global
           I64[Sp] = block_c4A9O_info;
           _s4w79::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w79::I64;
           if (R1 & 7 != 0) goto u4A9Y; else goto c4A9S;
       u4A9Y: // global
           call _c4A9O(R1) args: 0, res: 0, upd: 0;
       c4A9S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4A9O() //  [R1]
         { info_tbl: [(c4A9O,
                       label: block_c4A9O_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4A9O: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.633215438 UTC

[section ""data" . GHC.Int.$fEqInt64_closure" {
     GHC.Int.$fEqInt64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt64_closure+2;
         const GHC.Int.neInt64_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.635820542 UTC

[section ""data" . GHC.Int.gtInt64_closure" {
     GHC.Int.gtInt64_closure:
         const GHC.Int.gtInt64_info;
 },
 GHC.Int.gtInt64_entry() //  [R2, R3]
         { info_tbl: [(c4Aas,
                       label: GHC.Int.gtInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aas: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Aaw; else goto c4Aax;
       c4Aaw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Aax: // global
           I64[Sp - 16] = block_c4Aap_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AaG; else goto c4Aaq;
       u4AaG: // global
           call _c4Aap(R1) args: 0, res: 0, upd: 0;
       c4Aaq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Aap() //  [R1]
         { info_tbl: [(c4Aap,
                       label: block_c4Aap_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aap: // global
           I64[Sp] = block_c4Aav_info;
           _s4w7g::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w7g::I64;
           if (R1 & 7 != 0) goto u4AaF; else goto c4Aaz;
       u4AaF: // global
           call _c4Aav(R1) args: 0, res: 0, upd: 0;
       c4Aaz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Aav() //  [R1]
         { info_tbl: [(c4Aav,
                       label: block_c4Aav_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aav: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.644448027 UTC

[section ""data" . GHC.Int.geInt64_closure" {
     GHC.Int.geInt64_closure:
         const GHC.Int.geInt64_info;
 },
 GHC.Int.geInt64_entry() //  [R2, R3]
         { info_tbl: [(c4Ab8,
                       label: GHC.Int.geInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ab8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Abc; else goto c4Abd;
       c4Abc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Abd: // global
           I64[Sp - 16] = block_c4Ab5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Abm; else goto c4Ab6;
       u4Abm: // global
           call _c4Ab5(R1) args: 0, res: 0, upd: 0;
       c4Ab6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ab5() //  [R1]
         { info_tbl: [(c4Ab5,
                       label: block_c4Ab5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ab5: // global
           I64[Sp] = block_c4Abb_info;
           _s4w7n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w7n::I64;
           if (R1 & 7 != 0) goto u4Abl; else goto c4Abf;
       u4Abl: // global
           call _c4Abb(R1) args: 0, res: 0, upd: 0;
       c4Abf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Abb() //  [R1]
         { info_tbl: [(c4Abb,
                       label: block_c4Abb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Abb: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.652599583 UTC

[section ""data" . GHC.Int.ltInt64_closure" {
     GHC.Int.ltInt64_closure:
         const GHC.Int.ltInt64_info;
 },
 GHC.Int.ltInt64_entry() //  [R2, R3]
         { info_tbl: [(c4AbO,
                       label: GHC.Int.ltInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AbO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AbS; else goto c4AbT;
       c4AbS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AbT: // global
           I64[Sp - 16] = block_c4AbL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ac2; else goto c4AbM;
       u4Ac2: // global
           call _c4AbL(R1) args: 0, res: 0, upd: 0;
       c4AbM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AbL() //  [R1]
         { info_tbl: [(c4AbL,
                       label: block_c4AbL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AbL: // global
           I64[Sp] = block_c4AbR_info;
           _s4w7u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w7u::I64;
           if (R1 & 7 != 0) goto u4Ac1; else goto c4AbV;
       u4Ac1: // global
           call _c4AbR(R1) args: 0, res: 0, upd: 0;
       c4AbV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AbR() //  [R1]
         { info_tbl: [(c4AbR,
                       label: block_c4AbR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AbR: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.66159478 UTC

[section ""data" . GHC.Int.leInt64_closure" {
     GHC.Int.leInt64_closure:
         const GHC.Int.leInt64_info;
 },
 GHC.Int.leInt64_entry() //  [R2, R3]
         { info_tbl: [(c4Acu,
                       label: GHC.Int.leInt64_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Acu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Acy; else goto c4Acz;
       c4Acy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Acz: // global
           I64[Sp - 16] = block_c4Acr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AcI; else goto c4Acs;
       u4AcI: // global
           call _c4Acr(R1) args: 0, res: 0, upd: 0;
       c4Acs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Acr() //  [R1]
         { info_tbl: [(c4Acr,
                       label: block_c4Acr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Acr: // global
           I64[Sp] = block_c4Acx_info;
           _s4w7B::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w7B::I64;
           if (R1 & 7 != 0) goto u4AcH; else goto c4AcB;
       u4AcH: // global
           call _c4Acx(R1) args: 0, res: 0, upd: 0;
       c4AcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Acx() //  [R1]
         { info_tbl: [(c4Acx,
                       label: block_c4Acx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Acx: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.66928998 UTC

[section ""data" . GHC.Int.$fOrdInt64_$ccompare_closure" {
     GHC.Int.$fOrdInt64_$ccompare_closure:
         const GHC.Int.$fOrdInt64_$ccompare_info;
 },
 GHC.Int.$fOrdInt64_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4Ada,
                       label: GHC.Int.$fOrdInt64_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ada: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ade; else goto c4Adf;
       c4Ade: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Adf: // global
           I64[Sp - 16] = block_c4Ad7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ady; else goto c4Ad8;
       u4Ady: // global
           call _c4Ad7(R1) args: 0, res: 0, upd: 0;
       c4Ad8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ad7() //  [R1]
         { info_tbl: [(c4Ad7,
                       label: block_c4Ad7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ad7: // global
           I64[Sp] = block_c4Add_info;
           _s4w7I::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w7I::I64;
           if (R1 & 7 != 0) goto u4Adx; else goto c4Adh;
       u4Adx: // global
           call _c4Add(R1) args: 0, res: 0, upd: 0;
       c4Adh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Add() //  [R1]
         { info_tbl: [(c4Add,
                       label: block_c4Add_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Add: // global
           _s4w7I::I64 = I64[Sp + 8];
           _s4w7K::I64 = I64[R1 + 7];
           if (_s4w7I::I64 == _s4w7K::I64) goto c4Adw; else goto c4Adv;
       c4Adw: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Adv: // global
           if (%MO_S_Gt_W64(_s4w7I::I64,
                            _s4w7K::I64)) goto c4Ads; else goto c4Adt;
       c4Ads: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Adt: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.67831386 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmax_closure" {
     GHC.Int.$fOrdInt64_$cmax_closure:
         const GHC.Int.$fOrdInt64_$cmax_info;
 },
 GHC.Int.$fOrdInt64_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c4Ae1,
                       label: GHC.Int.$fOrdInt64_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ae1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Ae5; else goto c4Ae6;
       c4Ae5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ae6: // global
           I64[Sp - 16] = block_c4AdY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Aej; else goto c4AdZ;
       u4Aej: // global
           call _c4AdY(R1) args: 0, res: 0, upd: 0;
       c4AdZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AdY() //  [R1]
         { info_tbl: [(c4AdY,
                       label: block_c4AdY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AdY: // global
           I64[Sp - 8] = block_c4Ae4_info;
           _s4w7P::P64 = R1;
           _s4w7Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w7Q::I64;
           P64[Sp + 8] = _s4w7P::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Aei; else goto c4Ae8;
       u4Aei: // global
           call _c4Ae4(R1) args: 0, res: 0, upd: 0;
       c4Ae8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ae4() //  [R1]
         { info_tbl: [(c4Ae4,
                       label: block_c4Ae4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ae4: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4Aeg; else goto c4Aeh;
       c4Aeg: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4Aeh: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.687060521 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmin_closure" {
     GHC.Int.$fOrdInt64_$cmin_closure:
         const GHC.Int.$fOrdInt64_$cmin_info;
 },
 GHC.Int.$fOrdInt64_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c4AeL,
                       label: GHC.Int.$fOrdInt64_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AeL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4AeP; else goto c4AeQ;
       c4AeP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AeQ: // global
           I64[Sp - 16] = block_c4AeI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Af3; else goto c4AeJ;
       u4Af3: // global
           call _c4AeI(R1) args: 0, res: 0, upd: 0;
       c4AeJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AeI() //  [R1]
         { info_tbl: [(c4AeI,
                       label: block_c4AeI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AeI: // global
           I64[Sp - 8] = block_c4AeO_info;
           _s4w7W::P64 = R1;
           _s4w7X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w7X::I64;
           P64[Sp + 8] = _s4w7W::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Af2; else goto c4AeS;
       u4Af2: // global
           call _c4AeO(R1) args: 0, res: 0, upd: 0;
       c4AeS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AeO() //  [R1]
         { info_tbl: [(c4AeO,
                       label: block_c4AeO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AeO: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4Af0; else goto c4Af1;
       c4Af0: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4Af1: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.694958687 UTC

[section ""data" . GHC.Int.$fOrdInt64_closure" {
     GHC.Int.$fOrdInt64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fOrdInt64_$ccompare_closure+2;
         const GHC.Int.ltInt64_closure+2;
         const GHC.Int.leInt64_closure+2;
         const GHC.Int.gtInt64_closure+2;
         const GHC.Int.geInt64_closure+2;
         const GHC.Int.$fOrdInt64_$cmax_closure+2;
         const GHC.Int.$fOrdInt64_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.697700044 UTC

[section ""data" . GHC.Int.$fIxInt64_$cinRange_closure" {
     GHC.Int.$fIxInt64_$cinRange_closure:
         const GHC.Int.$fIxInt64_$cinRange_info;
 },
 GHC.Int.$fIxInt64_$cinRange_entry() //  [R2, R3]
         { info_tbl: [(c4Afw,
                       label: GHC.Int.$fIxInt64_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Afw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4AfF; else goto c4AfG;
       c4AfF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AfG: // global
           I64[Sp - 16] = block_c4Aft_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ag3; else goto c4Afu;
       u4Ag3: // global
           call _c4Aft(R1) args: 0, res: 0, upd: 0;
       c4Afu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Aft() //  [R1]
         { info_tbl: [(c4Aft,
                       label: block_c4Aft_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aft: // global
           I64[Sp - 8] = block_c4Afz_info;
           _s4w85::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w85::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Ag2; else goto c4AfA;
       u4Ag2: // global
           call _c4Afz(R1) args: 0, res: 0, upd: 0;
       c4AfA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Afz() //  [R1]
         { info_tbl: [(c4Afz,
                       label: block_c4Afz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Afz: // global
           I64[Sp] = block_c4AfE_info;
           _s4w87::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4w87::I64;
           if (R1 & 7 != 0) goto u4Ag4; else goto c4AfJ;
       u4Ag4: // global
           call _c4AfE(R1) args: 0, res: 0, upd: 0;
       c4AfJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AfE() //  [R1]
         { info_tbl: [(c4AfE,
                       label: block_c4AfE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AfE: // global
           _s4w89::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4w89::I64)) goto c4AfR; else goto c4AfV;
       c4AfR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AfV: // global
           _s4w85::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4AfU_info;
           R1 = _s4w85::P64;
           I64[Sp + 16] = _s4w89::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ag5; else goto c4AfW;
       u4Ag5: // global
           call _c4AfU(R1) args: 0, res: 0, upd: 0;
       c4AfW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AfU() //  [R1]
         { info_tbl: [(c4AfU,
                       label: block_c4AfU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AfU: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.710207982 UTC

[section ""data" . GHC.Int.$fNumInt5_closure" {
     GHC.Int.$fNumInt5_closure:
         const GHC.Int.I64#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.712446209 UTC

[section ""data" . GHC.Int.$fNumInt64_$csignum_closure" {
     GHC.Int.$fNumInt64_$csignum_closure:
         const GHC.Int.$fNumInt64_$csignum_info;
 },
 GHC.Int.$fNumInt64_$csignum_entry() //  [R2]
         { info_tbl: [(c4AgK,
                       label: GHC.Int.$fNumInt64_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AgK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4AgL; else goto c4AgM;
       c4AgL: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AgM: // global
           I64[Sp - 8] = block_c4AgH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Ah0; else goto c4AgI;
       u4Ah0: // global
           call _c4AgH(R1) args: 0, res: 0, upd: 0;
       c4AgI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AgH() //  [R1]
         { info_tbl: [(c4AgH,
                       label: block_c4AgH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AgH: // global
           _s4w8g::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4w8g::I64, 0)) goto c4AgY; else goto c4AgZ;
       c4AgY: // global
           if (_s4w8g::I64 == 0) goto c4AgW; else goto c4AgV;
       c4AgW: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AgV: // global
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AgZ: // global
           R1 = GHC.Int.$fNumInt5_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.719278544 UTC

[section ""data" . GHC.Int.$fNumInt64_$cabs_closure" {
     GHC.Int.$fNumInt64_$cabs_closure:
         const GHC.Int.$fNumInt64_$cabs_info;
 },
 GHC.Int.$fNumInt64_$cabs_entry() //  [R2]
         { info_tbl: [(c4Ahl,
                       label: GHC.Int.$fNumInt64_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ahl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Ahm; else goto c4Ahn;
       c4Ahm: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Ahn: // global
           I64[Sp - 8] = block_c4Ahi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AhD; else goto c4Ahj;
       u4AhD: // global
           call _c4Ahi(R1) args: 0, res: 0, upd: 0;
       c4Ahj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ahi() //  [R1]
         { info_tbl: [(c4Ahi,
                       label: block_c4Ahi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ahi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ahs; else goto c4Ahr;
       c4Ahs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Ahr: // global
           _s4w8l::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w8l::I64, 0)) goto c4AhB; else goto c4AhC;
       c4AhB: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = -_s4w8l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AhC: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.726461294 UTC

[section ""data" . GHC.Int.$fNumInt64_closure" {
     GHC.Int.$fNumInt64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt64_$c+_closure+2;
         const GHC.Int.$fNumInt64_$c-_closure+2;
         const GHC.Int.$fNumInt64_$c*_closure+2;
         const GHC.Int.$fNumInt64_$cnegate_closure+1;
         const GHC.Int.$fNumInt64_$cabs_closure+1;
         const GHC.Int.$fNumInt64_$csignum_closure+1;
         const GHC.Int.$fNumInt64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.728299961 UTC

[section ""data" . GHC.Int.$fBitsInt9_closure" {
     GHC.Int.$fBitsInt9_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.730285067 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt64_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4AhZ,
                       label: GHC.Int.$fBitsInt64_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AhZ: // global
           R1 = GHC.Int.$fBitsInt9_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.734263922 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbit_closure" {
     GHC.Int.$fBitsInt64_$cbit_closure:
         const GHC.Int.$fBitsInt64_$cbit_info;
 },
 GHC.Int.$fBitsInt64_$cbit_entry() //  [R2]
         { info_tbl: [(c4Aie,
                       label: GHC.Int.$fBitsInt64_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aie: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Aif; else goto c4Aig;
       c4Aif: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Aig: // global
           I64[Sp - 8] = block_c4Aib_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Aiw; else goto c4Aic;
       u4Aiw: // global
           call _c4Aib(R1) args: 0, res: 0, upd: 0;
       c4Aic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Aib() //  [R1]
         { info_tbl: [(c4Aib,
                       label: block_c4Aib_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aib: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ail; else goto c4Aik;
       c4Ail: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Aik: // global
           _s4w8r::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w8r::I64, 64)) goto c4Aiu; else goto c4Aiv;
       c4Aiu: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = 1 << _s4w8r::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Aiv: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.742259224 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ctestBit_closure" {
     GHC.Int.$fBitsInt64_$ctestBit_closure:
         const GHC.Int.$fBitsInt64_$ctestBit_info;
 },
 GHC.Int.$fBitsInt64_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4AiS,
                       label: GHC.Int.$fBitsInt64_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AiS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AiW; else goto c4AiX;
       c4AiW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AiX: // global
           I64[Sp - 16] = block_c4AiP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AjC; else goto c4AiQ;
       u4AjC: // global
           call _c4AiP(R1) args: 0, res: 0, upd: 0;
       c4AiQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AiP() //  [R1]
         { info_tbl: [(c4AiP,
                       label: block_c4AiP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AiP: // global
           I64[Sp] = block_c4AiV_info;
           _s4w8x::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w8x::I64;
           if (R1 & 7 != 0) goto u4AjB; else goto c4AiZ;
       u4AjB: // global
           call _c4AiV(R1) args: 0, res: 0, upd: 0;
       c4AiZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AiV() //  [R1]
         { info_tbl: [(c4AiV,
                       label: block_c4AiV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AiV: // global
           _s4w8z::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4w8z::I64, 64)) goto c4AjA; else goto c4Ajz;
       c4Ajz: // global
           if (I64[Sp + 8] & (1 << _s4w8z::I64) == 0) goto c4AjA; else goto c4Ajo;
       c4AjA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ajo: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.750923769 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateR_closure" {
     GHC.Int.$fBitsInt64_$crotateR_closure:
         const GHC.Int.$fBitsInt64_$crotateR_info;
 },
 GHC.Int.$fBitsInt64_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4Ak6,
                       label: GHC.Int.$fBitsInt64_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ak6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Aka; else goto c4Akb;
       c4Aka: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Akb: // global
           I64[Sp - 16] = block_c4Ak3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Al4; else goto c4Ak4;
       u4Al4: // global
           call _c4Ak3(R1) args: 0, res: 0, upd: 0;
       c4Ak4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ak3() //  [R1]
         { info_tbl: [(c4Ak3,
                       label: block_c4Ak3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ak3: // global
           I64[Sp - 8] = block_c4Ak9_info;
           _s4w8I::P64 = R1;
           _s4w8J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w8J::I64;
           P64[Sp + 8] = _s4w8I::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Al3; else goto c4Akd;
       u4Al3: // global
           call _c4Ak9(R1) args: 0, res: 0, upd: 0;
       c4Akd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ak9() //  [R1]
         { info_tbl: [(c4Ak9,
                       label: block_c4Ak9_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ak9: // global
           _s4w8P::I64 = -I64[R1 + 7] & 63;
           if (_s4w8P::I64 != 0) goto u4Al1; else goto c4AkX;
       u4Al1: // global
           I64[Sp + 16] = _s4w8P::I64;
           Sp = Sp + 8;
           call _c4Akv() args: 0, res: 0, upd: 0;
       c4AkX: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Akv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Akv: // global
           Hp = Hp + 16;
           _s4w8P::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4AkU; else goto c4AkT;
       c4AkU: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4Aku_info;
           R1 = _s4w8P::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4AkT: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4w8Q::I64 = I64[Sp];
           I64[Hp] = (_s4w8Q::I64 << _s4w8P::I64) | (_s4w8Q::I64 >> 64 - _s4w8P::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Aku() //  [R1]
         { info_tbl: [(c4Aku,
                       label: block_c4Aku_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aku: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4Akv() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.763015989 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt64_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt64_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt64_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4AlJ,
                       label: GHC.Int.$fBitsInt64_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AlJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4AlN; else goto c4AlO;
       c4AlN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AlO: // global
           I64[Sp - 16] = block_c4AlG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Amk; else goto c4AlH;
       u4Amk: // global
           call _c4AlG(R1) args: 0, res: 0, upd: 0;
       c4AlH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AlG() //  [R1]
         { info_tbl: [(c4AlG,
                       label: block_c4AlG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AlG: // global
           I64[Sp - 8] = block_c4AlM_info;
           _s4w8Y::P64 = R1;
           _s4w8Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w8Z::I64;
           P64[Sp + 8] = _s4w8Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Amj; else goto c4AlQ;
       u4Amj: // global
           call _c4AlM(R1) args: 0, res: 0, upd: 0;
       c4AlQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AlM() //  [R1]
         { info_tbl: [(c4AlM,
                       label: block_c4AlM_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AlM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AlW; else goto c4AlV;
       c4AlW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AlV: // global
           _s4w91::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w91::I64, 64)) goto c4Amh; else goto c4Ami;
       c4Amh: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s4w91::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ami: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.771946728 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cclearBit_closure" {
     GHC.Int.$fBitsInt64_$cclearBit_closure:
         const GHC.Int.$fBitsInt64_$cclearBit_info;
 },
 GHC.Int.$fBitsInt64_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4AmO,
                       label: GHC.Int.$fBitsInt64_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AmO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AmS; else goto c4AmT;
       c4AmS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AmT: // global
           I64[Sp - 16] = block_c4AmL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AnD; else goto c4AmM;
       u4AnD: // global
           call _c4AmL(R1) args: 0, res: 0, upd: 0;
       c4AmM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AmL() //  [R1]
         { info_tbl: [(c4AmL,
                       label: block_c4AmL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AmL: // global
           I64[Sp] = block_c4AmR_info;
           _s4w9b::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w9b::I64;
           if (R1 & 7 != 0) goto u4AnC; else goto c4AmV;
       u4AnC: // global
           call _c4AmR(R1) args: 0, res: 0, upd: 0;
       c4AmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AmR() //  [R1]
         { info_tbl: [(c4AmR,
                       label: block_c4AmR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AmR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4An1; else goto c4An0;
       c4An1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4An0: // global
           _s4w9b::I64 = I64[Sp + 8];
           _s4w9d::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w9d::I64, 64)) goto c4Anp; else goto c4AnB;
       c4Anp: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4w9b::I64 & (1 << _s4w9d::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AnB: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4w9b::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.781296387 UTC

[section ""data" . GHC.Int.$fBitsInt64_$csetBit_closure" {
     GHC.Int.$fBitsInt64_$csetBit_closure:
         const GHC.Int.$fBitsInt64_$csetBit_info;
 },
 GHC.Int.$fBitsInt64_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4Aob,
                       label: GHC.Int.$fBitsInt64_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aob: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Aof; else goto c4Aog;
       c4Aof: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Aog: // global
           I64[Sp - 16] = block_c4Ao8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AoM; else goto c4Ao9;
       u4AoM: // global
           call _c4Ao8(R1) args: 0, res: 0, upd: 0;
       c4Ao9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ao8() //  [R1]
         { info_tbl: [(c4Ao8,
                       label: block_c4Ao8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ao8: // global
           I64[Sp - 8] = block_c4Aoe_info;
           _s4w9q::P64 = R1;
           _s4w9r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w9r::I64;
           P64[Sp + 8] = _s4w9q::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AoL; else goto c4Aoi;
       u4AoL: // global
           call _c4Aoe(R1) args: 0, res: 0, upd: 0;
       c4Aoi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Aoe() //  [R1]
         { info_tbl: [(c4Aoe,
                       label: block_c4Aoe_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aoe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Aoo; else goto c4Aon;
       c4Aoo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Aon: // global
           _s4w9t::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w9t::I64, 64)) goto c4AoJ; else goto c4AoK;
       c4AoJ: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s4w9t::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AoK: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.790590918 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateL_closure" {
     GHC.Int.$fBitsInt64_$crotateL_closure:
         const GHC.Int.$fBitsInt64_$crotateL_info;
 },
 GHC.Int.$fBitsInt64_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4Apd,
                       label: GHC.Int.$fBitsInt64_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Apd: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt64_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.794408577 UTC

[section ""data" . GHC.Int.$fBitsInt64_closure" {
     GHC.Int.$fBitsInt64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fBitsInt64_$c.&._closure+2;
         const GHC.Int.$fBitsInt64_$c.|._closure+2;
         const GHC.Int.$fBitsInt64_$cxor_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt64_$cshift_closure+2;
         const GHC.Int.$fBitsInt64_$crotate_closure+2;
         const GHC.Int.$fBitsInt10_closure+1;
         const GHC.Int.$fBitsInt64_$cbit_closure+1;
         const GHC.Int.$fBitsInt64_$csetBit_closure+2;
         const GHC.Int.$fBitsInt64_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt64_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt64_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt64_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt64_$crotateL_closure+2;
         const GHC.Int.$fBitsInt64_$crotateR_closure+2;
         const GHC.Int.$fBitsInt64_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.796755372 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_closure" {
     GHC.Int.$fFiniteBitsInt64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt64_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.799682722 UTC

[section ""data" . GHC.Int.$fReadInt64_go_closure" {
     GHC.Int.$fReadInt64_go_closure:
         const GHC.Int.$fReadInt64_go_info;
 },
 sat_s4w9L_entry() //  [R1]
         { info_tbl: [(c4ApF,
                       label: sat_s4w9L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ApF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ApG; else goto c4ApH;
       c4ApG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ApH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4w9J_entry() //  [R1]
         { info_tbl: [(c4ApP,
                       label: sat_s4w9J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ApP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ApT; else goto c4ApU;
       c4ApT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ApU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4ApM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4ApY; else goto c4ApN;
       u4ApY: // global
           call _c4ApM(R1) args: 0, res: 0, upd: 0;
       c4ApN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4ApM() //  [R1]
         { info_tbl: [(c4ApM,
                       label: block_c4ApM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ApM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ApX; else goto c4ApW;
       c4ApX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4ApW: // global
           _s4w9I::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4w9I::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Int.$fReadInt64_go_entry() //  [R2]
         { info_tbl: [(c4Aq3,
                       label: GHC.Int.$fReadInt64_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aq3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Aq4; else goto c4Aq5;
       c4Aq4: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Aq5: // global
           I64[Sp - 8] = block_c4Apq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Aqf; else goto c4Apr;
       u4Aqf: // global
           call _c4Apq(R1) args: 0, res: 0, upd: 0;
       c4Apr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Apq() //  [R1]
         { info_tbl: [(c4Apq,
                       label: block_c4Apq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Apq: // global
           if (R1 & 7 == 1) goto c4Aq0; else goto c4Aq1;
       c4Aq0: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Aq1: // global
           I64[Sp - 8] = block_c4Apw_info;
           _s4w9D::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4w9D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Aqe; else goto c4Apx;
       u4Aqe: // global
           call _c4Apw(R1) args: 0, res: 0, upd: 0;
       c4Apx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Apw() //  [R1]
         { info_tbl: [(c4Apw,
                       label: block_c4Apw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Apw: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4Aqd; else goto c4Aqc;
       c4Aqd: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Aqc: // global
           _s4w9F::P64 = P64[R1 + 7];
           _s4w9G::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4w9L_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4w9J_info;
           P64[Hp - 48] = _s4w9F::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4w9G::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.814945586 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadsPrec_closure" {
     GHC.Int.$fReadInt64_$creadsPrec_closure:
         const GHC.Int.$fReadInt64_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c4Ar5,
                       label: GHC.Int.$fReadInt64_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ar5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ar9; else goto c4Ara;
       c4Ar9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ara: // global
           I64[Sp - 16] = block_c4Ar3_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4w9N::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4w9N::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ar3() //  [R1]
         { info_tbl: [(c4Ar3,
                       label: block_c4Ar3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ar3: // global
           _s4w9N::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Ar8_info;
           R3 = _s4w9N::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ar8() //  [R1]
         { info_tbl: [(c4Ar8,
                       label: block_c4Ar8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ar8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.8241038 UTC

[section ""data" . GHC.Int.$fReadInt10_closure" {
     GHC.Int.$fReadInt10_closure:
         const GHC.Int.$fReadInt10_info;
         const 0;
 },
 sat_s4w9S_entry() //  [R1, R2]
         { info_tbl: [(c4ArE,
                       label: sat_s4w9S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ArE: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt64_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Int.$fReadInt10_entry() //  [R2, R3]
         { info_tbl: [(c4ArK,
                       label: GHC.Int.$fReadInt10_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ArK: // global
           _s4w9R::P64 = R3;
           _s4w9Q::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4ArL; else goto c4ArM;
       c4ArM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ArO; else goto c4ArN;
       c4ArO: // global
           HpAlloc = 16;
           goto c4ArL;
       c4ArL: // global
           R3 = _s4w9R::P64;
           R2 = _s4w9Q::P64;
           R1 = GHC.Int.$fReadInt10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ArN: // global
           I64[Hp - 8] = sat_s4w9S_info;
           P64[Hp] = _s4w9Q::P64;
           I64[Sp - 8] = block_c4ArH_info;
           R3 = _s4w9R::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ArH() //  [R1]
         { info_tbl: [(c4ArH,
                       label: block_c4ArH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ArH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ArR; else goto c4ArQ;
       c4ArR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ArQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.833139497 UTC

[section ""data" . GHC.Int.$fReadInt9_closure" {
     GHC.Int.$fReadInt9_closure:
         const GHC.Int.$fReadInt9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4Asg_srtd" {
     u4Asg_srtd:
         const S4wm5_srt+504;
         const 70;
         const 1;
         const 32;
 },
 GHC.Int.$fReadInt9_entry() //  [R1]
         { info_tbl: [(c4Asd,
                       label: GHC.Int.$fReadInt9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Asd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4Ase; else goto c4Asf;
       c4Ase: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Asf: // global
           (_c4Asa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Asa::I64 == 0) goto c4Asc; else goto c4Asb;
       c4Asc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Asb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Asa::I64;
           R2 = GHC.Int.$fReadInt10_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.843084955 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadList_closure" {
     GHC.Int.$fReadInt64_$creadList_closure:
         const GHC.Int.$fReadInt64_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadList_entry() //  [R2]
         { info_tbl: [(c4Asy,
                       label: GHC.Int.$fReadInt64_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Asy: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt9_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.849027987 UTC

[section ""data" . GHC.Int.$fReadInt7_closure" {
     GHC.Int.$fReadInt7_closure:
         const GHC.Int.$fReadInt7_info;
         const 0;
 },
 GHC.Int.$fReadInt7_entry() //  [R2, R3]
         { info_tbl: [(c4AsM,
                       label: GHC.Int.$fReadInt7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AsM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4AsN; else goto c4AsO;
       c4AsN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AsO: // global
           I64[Sp - 8] = block_c4AsJ_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt64_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4AsJ() //  [R1]
         { info_tbl: [(c4AsJ,
                       label: block_c4AsJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AsJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AsR; else goto c4AsQ;
       c4AsR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AsQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.859235508 UTC

[section ""data" . GHC.Int.$fReadInt64_closure" {
     GHC.Int.$fReadInt64_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt64_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt64_$creadList_closure+1;
         const GHC.Int.$fReadInt10_closure+2;
         const GHC.Int.$fReadInt7_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.862564973 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquot_closure" {
     GHC.Int.$fIntegralInt64_$cquot_closure:
         const GHC.Int.$fIntegralInt64_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4Atb,
                       label: GHC.Int.$fIntegralInt64_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Atb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Atf; else goto c4Atg;
       c4Atf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Atg: // global
           I64[Sp - 16] = block_c4At8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AtL; else goto c4At9;
       u4AtL: // global
           call _c4At8(R1) args: 0, res: 0, upd: 0;
       c4At9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4At8() //  [R1]
         { info_tbl: [(c4At8,
                       label: block_c4At8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4At8: // global
           I64[Sp] = block_c4Ate_info;
           _s4wa2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wa2::I64;
           if (R1 & 7 != 0) goto u4AtK; else goto c4Ati;
       u4AtK: // global
           call _c4Ate(R1) args: 0, res: 0, upd: 0;
       c4Ati: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ate() //  [R1]
         { info_tbl: [(c4Ate,
                       label: block_c4Ate_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ate: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ato; else goto c4Atn;
       c4Ato: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Atn: // global
           _s4wa2::I64 = I64[Sp + 8];
           _s4wa5::I64 = I64[R1 + 7];
           if (_s4wa5::I64 != (-1)) goto u4AtJ; else goto c4AtH;
       u4AtJ: // global
           if (_s4wa5::I64 != 0) goto c4Atw; else goto c4AtI;
       c4Atw: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4wa2::I64, _s4wa5::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AtI: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4AtH: // global
           if (_s4wa2::I64 == (-9223372036854775808)) goto c4AtG; else goto c4AtF;
       c4AtG: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4AtF: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4wa2::I64, (-1));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.873962833 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$crem_closure" {
     GHC.Int.$fIntegralInt64_$crem_closure:
         const GHC.Int.$fIntegralInt64_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4Aug,
                       label: GHC.Int.$fIntegralInt64_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aug: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Auk; else goto c4Aul;
       c4Auk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Aul: // global
           I64[Sp - 16] = block_c4Aud_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AuG; else goto c4Aue;
       u4AuG: // global
           call _c4Aud(R1) args: 0, res: 0, upd: 0;
       c4Aue: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Aud() //  [R1]
         { info_tbl: [(c4Aud,
                       label: block_c4Aud_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Aud: // global
           I64[Sp] = block_c4Auj_info;
           _s4wae::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wae::I64;
           if (R1 & 7 != 0) goto u4AuF; else goto c4Aun;
       u4AuF: // global
           call _c4Auj(R1) args: 0, res: 0, upd: 0;
       c4Aun: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Auj() //  [R1]
         { info_tbl: [(c4Auj,
                       label: block_c4Auj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Auj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Aut; else goto c4Aus;
       c4Aut: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Aus: // global
           _s4wah::I64 = I64[R1 + 7];
           if (_s4wah::I64 != (-1)) goto u4AuE; else goto c4AuC;
       u4AuE: // global
           if (_s4wah::I64 != 0) goto c4AuB; else goto c4AuD;
       c4AuB: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Rem_W64(I64[Sp + 8], _s4wah::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AuD: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4AuC: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.883748053 UTC

[section ""data" . GHC.Int.$w$cdiv2_closure" {
     GHC.Int.$w$cdiv2_closure:
         const GHC.Int.$w$cdiv2_info;
         const 0;
 },
 GHC.Int.$w$cdiv2_entry() //  [R2, R3]
         { info_tbl: [(c4Av9,
                       label: GHC.Int.$w$cdiv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Av9: // global
           if (R3 == (-1)) goto c4Av7; else goto u4Avi;
       c4Av7: // global
           if (R2 == (-9223372036854775808)) goto c4Avh; else goto c4Avg;
       c4Avh: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4Avg: // global
           R3 = (-1);
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
       u4Avi: // global
           if (R3 == 0) goto c4Av8; else goto c4Av6;
       c4Av8: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4Av6: // global
           R3 = R3;
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.889607583 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdiv_closure" {
     GHC.Int.$fIntegralInt64_$cdiv_closure:
         const GHC.Int.$fIntegralInt64_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4Avv,
                       label: GHC.Int.$fIntegralInt64_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Avv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AvI; else goto c4AvJ;
       c4AvI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AvJ: // global
           I64[Sp - 16] = block_c4Avs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AvQ; else goto c4Avt;
       u4AvQ: // global
           call _c4Avs(R1) args: 0, res: 0, upd: 0;
       c4Avt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Avs() //  [R1]
         { info_tbl: [(c4Avs,
                       label: block_c4Avs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Avs: // global
           I64[Sp] = block_c4Avy_info;
           _s4was::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4was::I64;
           if (R1 & 7 != 0) goto u4AvP; else goto c4Avz;
       u4AvP: // global
           call _c4Avy(R1) args: 0, res: 0, upd: 0;
       c4Avz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Avy() //  [R1]
         { info_tbl: [(c4Avy,
                       label: block_c4Avy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Avy: // global
           _s4was::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4AvD_info;
           R3 = I64[R1 + 7];
           R2 = _s4was::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4AvD() //  [R1]
         { info_tbl: [(c4AvD,
                       label: block_c4AvD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AvD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AvO; else goto c4AvN;
       c4AvO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4AvN: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.900812536 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cmod_closure" {
     GHC.Int.$fIntegralInt64_$cmod_closure:
         const GHC.Int.$fIntegralInt64_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4Awj,
                       label: GHC.Int.$fIntegralInt64_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Awj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Awn; else goto c4Awo;
       c4Awn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Awo: // global
           I64[Sp - 16] = block_c4Awg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AwL; else goto c4Awh;
       u4AwL: // global
           call _c4Awg(R1) args: 0, res: 0, upd: 0;
       c4Awh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Awg() //  [R1]
         { info_tbl: [(c4Awg,
                       label: block_c4Awg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Awg: // global
           I64[Sp] = block_c4Awm_info;
           _s4waz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4waz::I64;
           if (R1 & 7 != 0) goto u4AwK; else goto c4Awq;
       u4AwK: // global
           call _c4Awm(R1) args: 0, res: 0, upd: 0;
       c4Awq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Awm() //  [R1]
         { info_tbl: [(c4Awm,
                       label: block_c4Awm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Awm: // global
           _s4waC::I64 = I64[R1 + 7];
           if (_s4waC::I64 != (-1)) goto u4AwJ; else goto c4AwH;
       u4AwJ: // global
           if (_s4waC::I64 != 0) goto c4AwD; else goto c4AwI;
       c4AwD: // global
           _s4waz::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4Awx_info;
           R3 = _s4waC::I64;
           R2 = _s4waz::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4AwI: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4AwH: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Awx() //  [R1]
         { info_tbl: [(c4Awx,
                       label: block_c4Awx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Awx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AwG; else goto c4AwF;
       c4AwG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4AwF: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.91372434 UTC

[section ""data" . lvl9_r4kPA_closure" {
     lvl9_r4kPA_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt10_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.917839708 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquotRem_closure" {
     GHC.Int.$fIntegralInt64_$cquotRem_closure:
         const GHC.Int.$fIntegralInt64_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4Axg,
                       label: GHC.Int.$fIntegralInt64_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Axg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Axk; else goto c4Axl;
       c4Axk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Axl: // global
           I64[Sp - 16] = block_c4Axd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AxO; else goto c4Axe;
       u4AxO: // global
           call _c4Axd(R1) args: 0, res: 0, upd: 0;
       c4Axe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Axd() //  [R1]
         { info_tbl: [(c4Axd,
                       label: block_c4Axd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Axd: // global
           I64[Sp] = block_c4Axj_info;
           _s4waI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4waI::I64;
           if (R1 & 7 != 0) goto u4AxN; else goto c4Axn;
       u4AxN: // global
           call _c4Axj(R1) args: 0, res: 0, upd: 0;
       c4Axn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Axj() //  [R1]
         { info_tbl: [(c4Axj,
                       label: block_c4Axj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Axj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4Axt; else goto c4Axs;
       c4Axt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Axs: // global
           _s4waI::I64 = I64[Sp + 8];
           _s4waL::I64 = I64[R1 + 7];
           if (_s4waL::I64 != (-1)) goto u4AxM; else goto c4AxK;
       u4AxM: // global
           if (_s4waL::I64 != 0) goto c4AxA; else goto c4AxL;
       c4AxA: // global
           (_s4waN::I64, _s4waO::I64) = call MO_S_QuotRem W64(_s4waI::I64, _s4waL::I64);
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4waO::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4waN::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AxL: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4AxK: // global
           if (_s4waI::I64 == (-9223372036854775808)) goto c4AxJ; else goto c4AxI;
       c4AxJ: // global
           Hp = Hp - 56;
           R1 = lvl9_r4kPA_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AxI: // global
           (_s4waT::I64, _s4waU::I64) = call MO_S_QuotRem W64(_s4waI::I64, (-1));
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4waU::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4waT::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.93647493 UTC

[section ""data" . GHC.Int.$w$cdivMod2_closure" {
     GHC.Int.$w$cdivMod2_closure:
         const GHC.Int.$w$cdivMod2_info;
         const 0;
 },
 GHC.Int.$w$cdivMod2_entry() //  [R2, R3]
         { info_tbl: [(c4Ayr,
                       label: GHC.Int.$w$cdivMod2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ayr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Ays; else goto c4Ayt;
       c4Ays: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ayt: // global
           if (R3 == 0) goto c4Ayq; else goto c4Ayp;
       c4Ayq: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4Ayp: // global
           if (R3 == (-1)) goto c4AAg; else goto u4AAh;
       c4AAg: // global
           if (R2 == (-9223372036854775808)) goto c4AAf; else goto u4AAi;
       c4AAf: // global
           R2 = GHC.Int.$fBitsInt10_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4AAi: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4AAk;
       u4AAh: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4AAk;
       u4AAk: // global
           call _c4Ayy() args: 0, res: 0, upd: 0;
     }
 },
 _c4Ayy() //  []
         { info_tbl: [(c4Ayy,
                       label: block_c4Ayy_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ayy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4AyC; else goto c4AyB;
       c4AyC: // global
           HpAlloc = 32;
           I64[Sp] = block_c4Ayy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4AyB: // global
           _s4waY::I64 = I64[Sp + 8];
           _s4wb0::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4waY::I64, 0)) goto c4Azd; else goto c4AA6;
       c4Azd: // global
           if (%MO_S_Ge_W64(_s4waY::I64, 0)) goto c4AyM; else goto c4Azb;
       c4AyM: // global
           (_s4wb5::I64, _s4wb6::I64) = call MO_S_QuotRem W64(_s4waY::I64, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wb6::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wb5::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4Azb: // global
           if (%MO_S_Le_W64(_s4wb0::I64, 0)) goto c4AyU; else goto c4Aza;
       c4AyU: // global
           (_s4wbb::I64, _s4wbc::I64) = call MO_S_QuotRem W64(_s4waY::I64, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wbc::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbb::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4Aza: // global
           (_s4wbh::I64, _s4wbi::I64) = call MO_S_QuotRem W64(_s4waY::I64 + 1, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wbi::I64 + _s4wb0::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbh::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4AA6: // global
           if (%MO_S_Ge_W64(_s4wb0::I64, 0)) goto c4AzP; else goto c4AA5;
       c4AzP: // global
           if (%MO_S_Ge_W64(_s4waY::I64, 0)) goto c4Azo; else goto c4AzN;
       c4Azo: // global
           (_s4wbr::I64, _s4wbs::I64) = call MO_S_QuotRem W64(_s4waY::I64, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wbs::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbr::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4AzN: // global
           if (%MO_S_Le_W64(_s4wb0::I64, 0)) goto c4Azw; else goto c4AzM;
       c4Azw: // global
           (_s4wbx::I64, _s4wby::I64) = call MO_S_QuotRem W64(_s4waY::I64, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wby::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbx::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4AzM: // global
           (_s4wbD::I64, _s4wbE::I64) = call MO_S_QuotRem W64(_s4waY::I64 + 1, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wbE::I64 + _s4wb0::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbD::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4AA5: // global
           (_s4wbM::I64, _s4wbN::I64) = call MO_S_QuotRem W64(_s4waY::I64 - 1, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wbN::I64 + _s4wb0::I64 + 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbM::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.954151251 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdivMod_closure" {
     GHC.Int.$fIntegralInt64_$cdivMod_closure:
         const GHC.Int.$fIntegralInt64_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4ABa,
                       label: GHC.Int.$fIntegralInt64_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ABa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ABl; else goto c4ABm;
       c4ABl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ABm: // global
           I64[Sp - 16] = block_c4AB7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ABt; else goto c4AB8;
       u4ABt: // global
           call _c4AB7(R1) args: 0, res: 0, upd: 0;
       c4AB8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AB7() //  [R1]
         { info_tbl: [(c4AB7,
                       label: block_c4AB7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AB7: // global
           I64[Sp] = block_c4ABd_info;
           _s4wbZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wbZ::I64;
           if (R1 & 7 != 0) goto u4ABs; else goto c4ABe;
       u4ABs: // global
           call _c4ABd(R1) args: 0, res: 0, upd: 0;
       c4ABe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ABd() //  [R1]
         { info_tbl: [(c4ABd,
                       label: block_c4ABd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ABd: // global
           _s4wbZ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4ABi_info;
           R3 = I64[R1 + 7];
           R2 = _s4wbZ::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ABi() //  [R1, R2]
         { info_tbl: [(c4ABi,
                       label: block_c4ABi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ABi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ABr; else goto c4ABq;
       c4ABr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ABq: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.967609911 UTC

[section ""data" . GHC.Int.$fIxInt64_$crange_closure" {
     GHC.Int.$fIxInt64_$crange_closure:
         const GHC.Int.$fIxInt64_$crange_info;
 },
 GHC.Int.$fIxInt64_$crange_entry() //  [R2]
         { info_tbl: [(c4ABW,
                       label: GHC.Int.$fIxInt64_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ABW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ABX; else goto c4ABY;
       c4ABX: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ABY: // global
           I64[Sp - 8] = block_c4ABT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AC2; else goto c4ABU;
       u4AC2: // global
           call _c4ABT(R1) args: 0, res: 0, upd: 0;
       c4ABU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ABT() //  [R1]
         { info_tbl: [(c4ABT,
                       label: block_c4ABT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ABT: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.973671372 UTC

[section ""data" . GHC.Int.$fRealInt64_$ctoRational_closure" {
     GHC.Int.$fRealInt64_$ctoRational_closure:
         const GHC.Int.$fRealInt64_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt64_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4ACk,
                       label: GHC.Int.$fRealInt64_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ACk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ACy; else goto c4ACz;
       c4ACy: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ACz: // global
           I64[Sp - 8] = block_c4ACh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ACG; else goto c4ACi;
       u4ACG: // global
           call _c4ACh(R1) args: 0, res: 0, upd: 0;
       c4ACi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ACh() //  [R1]
         { info_tbl: [(c4ACh,
                       label: block_c4ACh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ACh: // global
           I64[Sp] = block_c4ACn_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ACn() //  [R1]
         { info_tbl: [(c4ACn,
                       label: block_c4ACn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ACn: // global
           I64[Sp] = block_c4ACr_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ACr() //  [R1]
         { info_tbl: [(c4ACr,
                       label: block_c4ACr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ACr: // global
           I64[Sp] = block_c4ACv_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ACv() //  [R1, R2]
         { info_tbl: [(c4ACv,
                       label: block_c4ACv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ACv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ACF; else goto c4ACE;
       c4ACF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ACE: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.9849909 UTC

[section ""data" . GHC.Int.$fRealInt64_closure" {
     GHC.Int.$fRealInt64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt64_closure+1;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fRealInt64_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.98678438 UTC

[section ""data" . GHC.Int.$fIntegralInt64_closure" {
     GHC.Int.$fIntegralInt64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt64_closure+1;
         const GHC.Int.$fEnumInt64_closure+1;
         const GHC.Int.$fIntegralInt64_$cquot_closure+2;
         const GHC.Int.$fIntegralInt64_$crem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt64_$cmod_closure+2;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt64_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.989282102 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt64_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt64_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt64_$cunsafeIndex_entry() //  [R2, R3]
         { info_tbl: [(c4ADe,
                       label: GHC.Int.$fIxInt64_$cunsafeIndex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ADe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ADv; else goto c4ADw;
       c4ADv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ADw: // global
           I64[Sp - 16] = block_c4ADb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ADD; else goto c4ADc;
       u4ADD: // global
           call _c4ADb(R1) args: 0, res: 0, upd: 0;
       c4ADc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ADb() //  [R1]
         { info_tbl: [(c4ADb,
                       label: block_c4ADb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ADb: // global
           I64[Sp] = block_c4ADh_info;
           _s4wck::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4wck::P64;
           if (R1 & 7 != 0) goto u4ADC; else goto c4ADi;
       u4ADC: // global
           call _c4ADh(R1) args: 0, res: 0, upd: 0;
       c4ADi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ADh() //  [R1]
         { info_tbl: [(c4ADh,
                       label: block_c4ADh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ADh: // global
           I64[Sp] = block_c4ADm_info;
           _s4wcn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wcn::I64;
           if (R1 & 7 != 0) goto u4ADE; else goto c4ADn;
       u4ADE: // global
           call _c4ADm(R1) args: 0, res: 0, upd: 0;
       c4ADn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ADm() //  [R1]
         { info_tbl: [(c4ADm,
                       label: block_c4ADm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ADm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ADB; else goto c4ADA;
       c4ADB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ADA: // global
           _s4wcq::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4wcq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:26.999309736 UTC

[section ""data" . GHC.Int.$fIxInt64_$crangeSize_closure" {
     GHC.Int.$fIxInt64_$crangeSize_closure:
         const GHC.Int.$fIxInt64_$crangeSize_info;
 },
 GHC.Int.$fIxInt64_$crangeSize_entry() //  [R2]
         { info_tbl: [(c4AEa,
                       label: GHC.Int.$fIxInt64_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AEa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AEj; else goto c4AEk;
       c4AEj: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AEk: // global
           I64[Sp - 8] = block_c4AE7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AEJ; else goto c4AE8;
       u4AEJ: // global
           call _c4AE7(R1) args: 0, res: 0, upd: 0;
       c4AE8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AE7() //  [R1]
         { info_tbl: [(c4AE7,
                       label: block_c4AE7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AE7: // global
           I64[Sp - 8] = block_c4AEd_info;
           _s4wcu::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4wcu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AEI; else goto c4AEe;
       u4AEI: // global
           call _c4AEd(R1) args: 0, res: 0, upd: 0;
       c4AEe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AEd() //  [R1]
         { info_tbl: [(c4AEd,
                       label: block_c4AEd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AEd: // global
           I64[Sp] = block_c4AEi_info;
           _s4wcw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wcw::I64;
           if (R1 & 7 != 0) goto u4AEK; else goto c4AEn;
       u4AEK: // global
           call _c4AEi(R1) args: 0, res: 0, upd: 0;
       c4AEn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AEi() //  [R1]
         { info_tbl: [(c4AEi,
                       label: block_c4AEi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AEi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AEt; else goto c4AEs;
       c4AEt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AEs: // global
           _s4wcw::I64 = I64[Sp + 8];
           _s4wcy::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4wcw::I64,
                            _s4wcy::I64)) goto c4AEx; else goto c4AEH;
       c4AEx: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AEH: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4wcy::I64 - _s4wcw::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.010276325 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt64_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt64_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(c4AFi,
                       label: GHC.Int.$fIxInt64_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AFi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AFC; else goto c4AFD;
       c4AFC: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AFD: // global
           I64[Sp - 8] = block_c4AFf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AFK; else goto c4AFg;
       u4AFK: // global
           call _c4AFf(R1) args: 0, res: 0, upd: 0;
       c4AFg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AFf() //  [R1]
         { info_tbl: [(c4AFf,
                       label: block_c4AFf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AFf: // global
           I64[Sp - 8] = block_c4AFl_info;
           _s4wcE::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4wcE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AFJ; else goto c4AFm;
       u4AFJ: // global
           call _c4AFl(R1) args: 0, res: 0, upd: 0;
       c4AFm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AFl() //  [R1]
         { info_tbl: [(c4AFl,
                       label: block_c4AFl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AFl: // global
           I64[Sp] = block_c4AFq_info;
           _s4wcH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wcH::I64;
           if (R1 & 7 != 0) goto u4AFL; else goto c4AFr;
       u4AFL: // global
           call _c4AFq(R1) args: 0, res: 0, upd: 0;
       c4AFr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AFq() //  [R1]
         { info_tbl: [(c4AFq,
                       label: block_c4AFq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AFq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AFI; else goto c4AFH;
       c4AFI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AFH: // global
           _s4wcL::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4wcL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.020765341 UTC

[section ""data" . GHC.Int.$fIxInt64_$cindex_closure" {
     GHC.Int.$fIxInt64_$cindex_closure:
         const GHC.Int.$fIxInt64_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt64_$cindex_entry() //  [R2, R3]
         { info_tbl: [(c4AGi,
                       label: GHC.Int.$fIxInt64_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AGi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4AGr; else goto c4AGs;
       c4AGr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AGs: // global
           I64[Sp - 16] = block_c4AGf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AH1; else goto c4AGg;
       u4AH1: // global
           call _c4AGf(R1) args: 0, res: 0, upd: 0;
       c4AGg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AGf() //  [R1]
         { info_tbl: [(c4AGf,
                       label: block_c4AGf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AGf: // global
           I64[Sp - 8] = block_c4AGl_info;
           _s4wcQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4wcQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AH0; else goto c4AGm;
       u4AH0: // global
           call _c4AGl(R1) args: 0, res: 0, upd: 0;
       c4AGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AGl() //  [R1]
         { info_tbl: [(c4AGl,
                       label: block_c4AGl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AGl: // global
           I64[Sp] = block_c4AGq_info;
           _s4wcS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4wcS::I64;
           if (R1 & 7 != 0) goto u4AH2; else goto c4AGv;
       u4AH2: // global
           call _c4AGq(R1) args: 0, res: 0, upd: 0;
       c4AGv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AGq() //  [R1]
         { info_tbl: [(c4AGq,
                       label: block_c4AGq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AGq: // global
           _s4wcU::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4wcU::I64)) goto c4AGD; else goto c4AGH;
       c4AGD: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4AGH: // global
           I64[Sp] = block_c4AGG_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wcU::I64;
           if (R1 & 7 != 0) goto u4AH3; else goto c4AGI;
       u4AH3: // global
           call _c4AGG(R1) args: 0, res: 0, upd: 0;
       c4AGI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AGG() //  [R1]
         { info_tbl: [(c4AGG,
                       label: block_c4AGG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AGG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AGO; else goto c4AGN;
       c4AGO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AGN: // global
           _s4wcU::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4wcU::I64,
                            I64[R1 + 7])) goto c4AGS; else goto c4AGZ;
       c4AGS: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4AGZ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4wcU::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.033596238 UTC

[section ""data" . GHC.Int.$fIxInt64_closure" {
     GHC.Int.$fIxInt64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fIxInt64_$crange_closure+1;
         const GHC.Int.$fIxInt64_$cindex_closure+2;
         const GHC.Int.$fIxInt64_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt64_$cinRange_closure+2;
         const GHC.Int.$fIxInt64_$crangeSize_closure+1;
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.036098657 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowsPrec_closure" {
     GHC.Int.$fShowInt64_$cshowsPrec_closure:
         const GHC.Int.$fShowInt64_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt64_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c4AHH,
                       label: GHC.Int.$fShowInt64_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AHH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4AHS; else goto c4AHT;
       c4AHS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AHT: // global
           I64[Sp - 24] = block_c4AHE_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4AI0; else goto c4AHF;
       u4AI0: // global
           call _c4AHE(R1) args: 0, res: 0, upd: 0;
       c4AHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AHE() //  [R1]
         { info_tbl: [(c4AHE,
                       label: block_c4AHE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AHE: // global
           I64[Sp] = block_c4AHK_info;
           _s4wd4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wd4::I64;
           if (R1 & 7 != 0) goto u4AHZ; else goto c4AHL;
       u4AHZ: // global
           call _c4AHK(R1) args: 0, res: 0, upd: 0;
       c4AHL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AHK() //  [R1]
         { info_tbl: [(c4AHK,
                       label: block_c4AHK_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AHK: // global
           _s4wd2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4AHP_info;
           R4 = _s4wd2::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4AHP() //  [R1, R2]
         { info_tbl: [(c4AHP,
                       label: block_c4AHP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AHP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4AHY; else goto c4AHX;
       c4AHY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4AHX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.046730685 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshow_closure" {
     GHC.Int.$fShowInt64_$cshow_closure:
         const GHC.Int.$fShowInt64_$cshow_info;
 },
 GHC.Int.$fShowInt64_$cshow_entry() //  [R2]
         { info_tbl: [(c4AIt,
                       label: GHC.Int.$fShowInt64_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AIt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4AIz; else goto c4AIA;
       c4AIz: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AIA: // global
           I64[Sp - 8] = block_c4AIq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AIF; else goto c4AIr;
       u4AIF: // global
           call _c4AIq(R1) args: 0, res: 0, upd: 0;
       c4AIr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AIq() //  [R1]
         { info_tbl: [(c4AIq,
                       label: block_c4AIq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AIq: // global
           I64[Sp] = block_c4AIw_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4AIw() //  [R1, R2]
         { info_tbl: [(c4AIw,
                       label: block_c4AIw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AIw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4AIE; else goto c4AID;
       c4AIE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4AID: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.054624322 UTC

[section ""data" . GHC.Int.$fShowInt3_closure" {
     GHC.Int.$fShowInt3_closure:
         const GHC.Int.$fShowInt3_info;
 },
 GHC.Int.$fShowInt3_entry() //  [R2, R3]
         { info_tbl: [(c4AJ4,
                       label: GHC.Int.$fShowInt3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AJ4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AJa; else goto c4AJb;
       c4AJa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AJb: // global
           I64[Sp - 16] = block_c4AJ1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AJg; else goto c4AJ2;
       u4AJg: // global
           call _c4AJ1(R1) args: 0, res: 0, upd: 0;
       c4AJ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4AJ1() //  [R1]
         { info_tbl: [(c4AJ1,
                       label: block_c4AJ1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AJ1: // global
           _s4wdh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4AJ7_info;
           R4 = _s4wdh::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4AJ7() //  [R1, R2]
         { info_tbl: [(c4AJ7,
                       label: block_c4AJ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AJ7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4AJf; else goto c4AJe;
       c4AJf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4AJe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.063435024 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowList_closure" {
     GHC.Int.$fShowInt64_$cshowList_closure:
         const GHC.Int.$fShowInt64_$cshowList_info;
 },
 GHC.Int.$fShowInt64_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4AJB,
                       label: GHC.Int.$fShowInt64_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AJB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt3_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.067079711 UTC

[section ""data" . GHC.Int.$fShowInt64_closure" {
     GHC.Int.$fShowInt64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt64_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt64_$cshow_closure+1;
         const GHC.Int.$fShowInt64_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.069153176 UTC

[section ""data" . GHC.Int.uncheckedIShiftL64#_closure" {
     GHC.Int.uncheckedIShiftL64#_closure:
         const GHC.Int.uncheckedIShiftL64#_info;
 },
 GHC.Int.uncheckedIShiftL64#_entry() //  [R2, R3]
         { info_tbl: [(c4AJO,
                       label: GHC.Int.uncheckedIShiftL64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AJO: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.072797434 UTC

[section ""data" . GHC.Int.uncheckedIShiftRA64#_closure" {
     GHC.Int.uncheckedIShiftRA64#_closure:
         const GHC.Int.uncheckedIShiftRA64#_info;
 },
 GHC.Int.uncheckedIShiftRA64#_entry() //  [R2, R3]
         { info_tbl: [(c4AK2,
                       label: GHC.Int.uncheckedIShiftRA64#_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AK2: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.076649513 UTC

[section ""cstring" . GHC.Int.$trModule4_bytes" {
     GHC.Int.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.078495602 UTC

[section ""data" . GHC.Int.$trModule3_closure" {
     GHC.Int.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.080341325 UTC

[section ""cstring" . GHC.Int.$trModule2_bytes" {
     GHC.Int.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.082695819 UTC

[section ""data" . GHC.Int.$trModule1_closure" {
     GHC.Int.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.084430508 UTC

[section ""data" . GHC.Int.$trModule_closure" {
     GHC.Int.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Int.$trModule3_closure+1;
         const GHC.Int.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.086242711 UTC

[section ""data" . $krep_r4kPB_closure" {
     $krep_r4kPB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.087974258 UTC

[section ""data" . GHC.Int.$tcInt7_closure" {
     GHC.Int.$tcInt7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt9_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.089783414 UTC

[section ""data" . GHC.Int.$tcInt8_closure" {
     GHC.Int.$tcInt8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt7_closure+1;
         const GHC.Types.krep$*_closure;
         const 1422706860619545536;
         const 2126344328513082648;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.091645906 UTC

[section ""data" . $krep1_r4kPC_closure" {
     $krep1_r4kPC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.093431951 UTC

[section ""data" . GHC.Int.$tc'I8#1_closure" {
     GHC.Int.$tc'I8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep1_r4kPC_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.095216282 UTC

[section ""cstring" . GHC.Int.$tc'I8#3_bytes" {
     GHC.Int.$tc'I8#3_bytes:
         I8[] [39,73,56,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.096867526 UTC

[section ""data" . GHC.Int.$tc'I8#2_closure" {
     GHC.Int.$tc'I8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I8#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.098706087 UTC

[section ""data" . GHC.Int.$tc'I8#_closure" {
     GHC.Int.$tc'I8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I8#2_closure+1;
         const GHC.Int.$tc'I8#1_closure+4;
         const 5349338056284818619;
         const 13298037281129101406;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.101065503 UTC

[section ""data" . GHC.Int.$tcInt1_closure" {
     GHC.Int.$tcInt1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.103003605 UTC

[section ""data" . GHC.Int.$tcInt16_closure" {
     GHC.Int.$tcInt16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16329117591681623238;
         const 13363230803330610095;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.10481836 UTC

[section ""data" . $krep2_r4kPD_closure" {
     $krep2_r4kPD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.10668199 UTC

[section ""data" . GHC.Int.$tc'I16#1_closure" {
     GHC.Int.$tc'I16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep2_r4kPD_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.108468053 UTC

[section ""cstring" . GHC.Int.$tc'I16#3_bytes" {
     GHC.Int.$tc'I16#3_bytes:
         I8[] [39,73,49,54,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.110589318 UTC

[section ""data" . GHC.Int.$tc'I16#2_closure" {
     GHC.Int.$tc'I16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I16#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.112342051 UTC

[section ""data" . GHC.Int.$tc'I16#_closure" {
     GHC.Int.$tc'I16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I16#2_closure+1;
         const GHC.Int.$tc'I16#1_closure+4;
         const 1077432500071562197;
         const 13676251251348512601;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.114353086 UTC

[section ""data" . GHC.Int.$tcInt3_closure" {
     GHC.Int.$tcInt3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.116179481 UTC

[section ""data" . GHC.Int.$tcInt32_closure" {
     GHC.Int.$tcInt32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt3_closure+1;
         const GHC.Types.krep$*_closure;
         const 5115671124548181797;
         const 6203735229629729265;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.118673969 UTC

[section ""data" . $krep3_r4kPE_closure" {
     $krep3_r4kPE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.12044073 UTC

[section ""data" . GHC.Int.$tc'I32#1_closure" {
     GHC.Int.$tc'I32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep3_r4kPE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.122216789 UTC

[section ""cstring" . GHC.Int.$tc'I32#3_bytes" {
     GHC.Int.$tc'I32#3_bytes:
         I8[] [39,73,51,50,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.123936078 UTC

[section ""data" . GHC.Int.$tc'I32#2_closure" {
     GHC.Int.$tc'I32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I32#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.126558502 UTC

[section ""data" . GHC.Int.$tc'I32#_closure" {
     GHC.Int.$tc'I32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I32#2_closure+1;
         const GHC.Int.$tc'I32#1_closure+4;
         const 14037617528454219662;
         const 2752255350980319305;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.128505037 UTC

[section ""data" . GHC.Int.$tcInt5_closure" {
     GHC.Int.$tcInt5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.130311234 UTC

[section ""data" . GHC.Int.$tcInt64_closure" {
     GHC.Int.$tcInt64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt5_closure+1;
         const GHC.Types.krep$*_closure;
         const 15049343324344240059;
         const 14445320765379163718;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.132232407 UTC

[section ""data" . $krep4_r4kPF_closure" {
     $krep4_r4kPF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.134115698 UTC

[section ""data" . GHC.Int.$tc'I64#1_closure" {
     GHC.Int.$tc'I64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep4_r4kPF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.136462545 UTC

[section ""cstring" . GHC.Int.$tc'I64#3_bytes" {
     GHC.Int.$tc'I64#3_bytes:
         I8[] [39,73,54,52,35]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.138215611 UTC

[section ""data" . GHC.Int.$tc'I64#2_closure" {
     GHC.Int.$tc'I64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I64#3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.139965213 UTC

[section ""data" . GHC.Int.$tc'I64#_closure" {
     GHC.Int.$tc'I64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I64#2_closure+1;
         const GHC.Int.$tc'I64#1_closure+4;
         const 7755385358338959724;
         const 8520529638322167079;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.142297907 UTC

[section ""data" . GHC.Int.I8#_closure" {
     GHC.Int.I8#_closure:
         const GHC.Int.I8#_info;
 },
 GHC.Int.I8#_entry() //  [R2]
         { info_tbl: [(c4AKO,
                       label: GHC.Int.I8#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AKO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AKS; else goto c4AKR;
       c4AKS: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AKR: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.146306514 UTC

[section ""data" . GHC.Int.I16#_closure" {
     GHC.Int.I16#_closure:
         const GHC.Int.I16#_info;
 },
 GHC.Int.I16#_entry() //  [R2]
         { info_tbl: [(c4AL4,
                       label: GHC.Int.I16#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AL4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AL8; else goto c4AL7;
       c4AL8: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AL7: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.15047911 UTC

[section ""data" . GHC.Int.I32#_closure" {
     GHC.Int.I32#_closure:
         const GHC.Int.I32#_info;
 },
 GHC.Int.I32#_entry() //  [R2]
         { info_tbl: [(c4ALk,
                       label: GHC.Int.I32#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ALk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ALo; else goto c4ALn;
       c4ALo: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ALn: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.155809762 UTC

[section ""data" . GHC.Int.I64#_closure" {
     GHC.Int.I64#_closure:
         const GHC.Int.I64#_info;
 },
 GHC.Int.I64#_entry() //  [R2]
         { info_tbl: [(c4ALA,
                       label: GHC.Int.I64#_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ALA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ALE; else goto c4ALD;
       c4ALE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ALD: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.159834564 UTC

[GHC.Int.I8#_con_entry() //  [R1]
         { info_tbl: [(c4ALL,
                       label: GHC.Int.I8#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,56,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ALL: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.163254184 UTC

[GHC.Int.I16#_con_entry() //  [R1]
         { info_tbl: [(c4ALS,
                       label: GHC.Int.I16#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,49,54,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ALS: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.166638991 UTC

[GHC.Int.I32#_con_entry() //  [R1]
         { info_tbl: [(c4ALZ,
                       label: GHC.Int.I32#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,51,50,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ALZ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.169987853 UTC

[GHC.Int.I64#_con_entry() //  [R1]
         { info_tbl: [(c4AM6,
                       label: GHC.Int.I64#_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,73,110,116,46,73,54,52,35]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4AM6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.173362448 UTC

[section ""relreadonly" . S4wm5_srt" {
     S4wm5_srt:
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt8_$cpred_closure;
         const GHC.Int.$fEnumInt7_closure;
         const GHC.Int.$fEnumInt8_$csucc_closure;
         const GHC.Int.$fEnumInt9_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl_r4kPr_closure;
         const GHC.Int.$wlvl2_closure;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum2_closure;
         const GHC.Int.$w$cenumFromThenTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Int.$wgo3_closure;
         const GHC.Int.$fEnumInt8_go_closure;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure;
         const GHC.Int.$fEnumInt8_closure;
         const GHC.Int.$fEnumInt16_$cpred_closure;
         const GHC.Int.$fEnumInt1_closure;
         const GHC.Int.$fEnumInt16_$csucc_closure;
         const GHC.Int.$fEnumInt2_closure;
         const lvl2_r4kPt_closure;
         const GHC.Int.$wlvl_closure;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum_closure;
         const GHC.Int.$w$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$wgo_closure;
         const GHC.Int.$fEnumInt16_go_closure;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure;
         const GHC.Int.$fEnumInt16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt32_$cpred_closure;
         const GHC.Int.$fEnumInt3_closure;
         const GHC.Int.$fEnumInt32_$csucc_closure;
         const GHC.Int.$fEnumInt4_closure;
         const lvl4_r4kPv_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Int.$wlvl1_closure;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum1_closure;
         const GHC.Int.$w$cenumFromTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$wgo1_closure;
         const GHC.Int.$fEnumInt32_go_closure;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure;
         const GHC.Int.$w$cenumFromThenTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt32_closure;
         const GHC.Int.$fEnumInt64_$cpred_closure;
         const GHC.Int.$fEnumInt5_closure;
         const GHC.Int.$fEnumInt64_$csucc_closure;
         const GHC.Int.$fEnumInt6_closure;
         const GHC.Int.$fEnumInt64_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Int.$fReadInt8_$creadsPrec_closure;
         const GHC.Int.$fReadInt13_closure;
         const GHC.Read.list_closure;
         const GHC.Int.$fReadInt12_closure;
         const GHC.Int.$fReadInt11_closure;
         const GHC.Int.$fReadInt8_$creadList_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fIntegralInt8_$cquot_closure;
         const GHC.Int.$fIntegralInt8_$crem_closure;
         const GHC.Int.$w$cdiv3_closure;
         const GHC.Int.$fIntegralInt8_$cdiv_closure;
         const GHC.Int.$fIntegralInt8_$cmod_closure;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure;
         const lvl6_r4kPx_closure;
         const GHC.Int.$w$cdivMod3_closure;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure;
         const sat_s4vTi_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Int.$fRealInt8_$ctoRational_closure;
         const GHC.Int.$fIxInt8_$crange_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fIxInt8_$cindex_closure;
         const GHC.Int.$fReadInt16_$creadsPrec_closure;
         const GHC.Int.$fReadInt3_closure;
         const GHC.Int.$fReadInt2_closure;
         const GHC.Int.$fReadInt1_closure;
         const GHC.Int.$fReadInt16_$creadList_closure;
         const GHC.Int.$fIntegralInt16_$cquot_closure;
         const GHC.Int.$fIntegralInt16_$crem_closure;
         const GHC.Int.$w$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cmod_closure;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure;
         const lvl7_r4kPy_closure;
         const GHC.Int.$w$cdivMod_closure;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure;
         const GHC.Int.$fRealInt16_$ctoRational_closure;
         const GHC.Int.$fIxInt16_$crange_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$fIxInt16_$cindex_closure;
         const GHC.Int.$fReadInt32_$creadsPrec_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Int.$fReadInt6_closure;
         const GHC.Int.$fReadInt5_closure;
         const GHC.Int.$fReadInt4_closure;
         const GHC.Int.$fReadInt32_$creadList_closure;
         const GHC.Int.$fIntegralInt32_$cquot_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Int.$fIntegralInt32_$crem_closure;
         const GHC.Int.$w$cdiv1_closure;
         const GHC.Int.$fIntegralInt32_$cdiv_closure;
         const GHC.Int.$fIntegralInt32_$cmod_closure;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure;
         const lvl8_r4kPz_closure;
         const GHC.Int.$w$cdivMod1_closure;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure;
         const GHC.Int.$fRealInt32_$ctoRational_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Int.$fIxInt32_$crange_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$fIxInt32_$cindex_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fReadInt64_$creadsPrec_closure;
         const GHC.Int.$fReadInt10_closure;
         const GHC.Int.$fReadInt9_closure;
         const GHC.Int.$fReadInt7_closure;
         const GHC.Int.$fReadInt64_$creadList_closure;
         const GHC.Int.$fIntegralInt64_$cquot_closure;
         const GHC.Int.$fIntegralInt64_$crem_closure;
         const GHC.Int.$fIntegralInt64_$cdiv_closure;
         const GHC.Int.$w$cdiv2_closure;
         const GHC.Int.$fIntegralInt64_$cmod_closure;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure;
         const lvl9_r4kPA_closure;
         const GHC.Int.$w$cdivMod2_closure;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure;
         const GHC.Int.$fRealInt64_$ctoRational_closure;
         const GHC.Int.$fIxInt64_$cindex_closure;
 }]

