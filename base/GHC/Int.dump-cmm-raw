
==================== Raw Cmm ====================
2018-03-16 15:59:10.070724733 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:59:10.073344238 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cfromEnum_closure" {
     GHC.Int.$fEnumInt8_$cfromEnum_closure:
         const GHC.Int.$fEnumInt8_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt8_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c4rfC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rfG; else goto c4rfH;
       c4rfG: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rfH: // global
           I64[Sp - 8] = block_c4rfz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rfL; else goto c4rfA;
       u4rfL: // global
           call _c4rfz(R1) args: 0, res: 0, upd: 0;
       c4rfA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cfromEnum_info" {
     GHC.Int.$fEnumInt8_$cfromEnum_info:
         const GHC.Int.$fEnumInt8_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4rfz() //  [R1]
         { []
         }
     {offset
       c4rfz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rfK; else goto c4rfJ;
       c4rfK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rfJ: // global
           _s4kPJ::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rfz_info" {
     block_c4rfz_info:
         const _c4rfz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.080495882 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cfromEnum_closure" {
     GHC.Int.$fEnumInt16_$cfromEnum_closure:
         const GHC.Int.$fEnumInt16_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt16_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c4rg3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rg7; else goto c4rg8;
       c4rg7: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rg8: // global
           I64[Sp - 8] = block_c4rg0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rgc; else goto c4rg1;
       u4rgc: // global
           call _c4rg0(R1) args: 0, res: 0, upd: 0;
       c4rg1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cfromEnum_info" {
     GHC.Int.$fEnumInt16_$cfromEnum_info:
         const GHC.Int.$fEnumInt16_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4rg0() //  [R1]
         { []
         }
     {offset
       c4rg0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rgb; else goto c4rga;
       c4rgb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rga: // global
           _s4kPM::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPM::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rg0_info" {
     block_c4rg0_info:
         const _c4rg0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.086847548 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cfromEnum_closure" {
     GHC.Int.$fEnumInt32_$cfromEnum_closure:
         const GHC.Int.$fEnumInt32_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt32_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c4rgu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rgy; else goto c4rgz;
       c4rgy: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rgz: // global
           I64[Sp - 8] = block_c4rgr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rgD; else goto c4rgs;
       u4rgD: // global
           call _c4rgr(R1) args: 0, res: 0, upd: 0;
       c4rgs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cfromEnum_info" {
     GHC.Int.$fEnumInt32_$cfromEnum_info:
         const GHC.Int.$fEnumInt32_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4rgr() //  [R1]
         { []
         }
     {offset
       c4rgr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rgC; else goto c4rgB;
       c4rgC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rgB: // global
           _s4kPP::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rgr_info" {
     block_c4rgr_info:
         const _c4rgr;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.093077559 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cfromEnum_closure" {
     GHC.Int.$fEnumInt64_$cfromEnum_closure:
         const GHC.Int.$fEnumInt64_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt64_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c4rgV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rgZ; else goto c4rh0;
       c4rgZ: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rh0: // global
           I64[Sp - 8] = block_c4rgS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rh4; else goto c4rgT;
       u4rh4: // global
           call _c4rgS(R1) args: 0, res: 0, upd: 0;
       c4rgT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cfromEnum_info" {
     GHC.Int.$fEnumInt64_$cfromEnum_info:
         const GHC.Int.$fEnumInt64_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4rgS() //  [R1]
         { []
         }
     {offset
       c4rgS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rh3; else goto c4rh2;
       c4rh3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rh2: // global
           _s4kPS::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4kPS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rgS_info" {
     block_c4rgS_info:
         const _c4rgS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.099753261 UTC

[section ""data" . GHC.Int.$fEnumInt64_$ctoEnum_closure" {
     GHC.Int.$fEnumInt64_$ctoEnum_closure:
         const GHC.Int.$fEnumInt64_$ctoEnum_info;
 },
 GHC.Int.$fEnumInt64_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c4rhm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rhq; else goto c4rhr;
       c4rhq: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rhr: // global
           I64[Sp - 8] = block_c4rhj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rhv; else goto c4rhk;
       u4rhv: // global
           call _c4rhj(R1) args: 0, res: 0, upd: 0;
       c4rhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$ctoEnum_info" {
     GHC.Int.$fEnumInt64_$ctoEnum_info:
         const GHC.Int.$fEnumInt64_$ctoEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4rhj() //  [R1]
         { []
         }
     {offset
       c4rhj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rhu; else goto c4rht;
       c4rhu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rht: // global
           _s4kPV::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kPV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rhj_info" {
     block_c4rhj_info:
         const _c4rhj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.110429769 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo2_closure" {
     GHC.Int.$w$cenumFromThenTo2_closure:
         const GHC.Int.$w$cenumFromThenTo2_info;
 },
 sat_s4kQ9_entry() //  [R1]
         { []
         }
     {offset
       c4rie: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rif; else goto c4rig;
       c4rif: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rig: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kQ4_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kQ9_info" {
     sat_s4kQ9_info:
         const sat_s4kQ9_entry;
         const 8589934593;
         const 15;
 },
 go_dn_s4kQ4_entry() //  [R1, R2]
         { []
         }
     {offset
       c4rik: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4rio; else goto c4rin;
       c4rio: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rin: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4rii; else goto c4rij;
       c4rii: // global
           _s4kQ2::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQ9_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQ2::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rij: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rit::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rit::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s4kQ4_info" {
     go_dn_s4kQ4_info:
         const go_dn_s4kQ4_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_s4kQb_entry() //  [R1]
         { []
         }
     {offset
       c4riu: // global
           _s4kQb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4riv; else goto c4riw;
       c4riw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4riy; else goto c4rix;
       c4riy: // global
           HpAlloc = 24;
           goto c4riv;
       c4riv: // global
           R1 = _s4kQb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rix: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kQb::P64;
           _s4kPX::I64 = I64[_s4kQb::P64 + 24];
           _s4kQ2::I64 = _s4kPX::I64 - I64[_s4kQb::P64 + 16];
           _s4kQ3::I64 = I64[_s4kQb::P64 + 32] - _s4kQ2::I64;
           I64[Hp - 16] = go_dn_s4kQ4_info;
           I64[Hp - 8] = _s4kQ2::I64;
           I64[Hp] = _s4kQ3::I64;
           R2 = _s4kPX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kQ4_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kQb_info" {
     sat_s4kQb_info:
         const sat_s4kQb_entry;
         const 12884901888;
         const 15;
 },
 sat_s4kQn_entry() //  [R1]
         { []
         }
     {offset
       c4rj1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rj2; else goto c4rj3;
       c4rj2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rj3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kQi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kQn_info" {
     sat_s4kQn_info:
         const sat_s4kQn_entry;
         const 8589934593;
         const 15;
 },
 go_up_s4kQi_entry() //  [R1, R2]
         { []
         }
     {offset
       c4rj7: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4rjb; else goto c4rja;
       c4rjb: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rja: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4rj5; else goto c4rj6;
       c4rj5: // global
           _s4kQg::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQn_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQg::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rj6: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rjg::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rjg::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s4kQi_info" {
     go_up_s4kQi_info:
         const go_up_s4kQi_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_s4kQp_entry() //  [R1]
         { []
         }
     {offset
       c4rjh: // global
           _s4kQp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rji; else goto c4rjj;
       c4rjj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rjl; else goto c4rjk;
       c4rjl: // global
           HpAlloc = 24;
           goto c4rji;
       c4rji: // global
           R1 = _s4kQp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rjk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kQp::P64;
           _s4kPX::I64 = I64[_s4kQp::P64 + 24];
           _s4kQg::I64 = _s4kPX::I64 - I64[_s4kQp::P64 + 16];
           _s4kQh::I64 = I64[_s4kQp::P64 + 32] - _s4kQg::I64;
           I64[Hp - 16] = go_up_s4kQi_info;
           I64[Hp - 8] = _s4kQg::I64;
           I64[Hp] = _s4kQh::I64;
           R2 = _s4kPX::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kQi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kQp_info" {
     sat_s4kQp_info:
         const sat_s4kQp_entry;
         const 12884901888;
         const 15;
 },
 GHC.Int.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4rjp: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4rjt; else goto c4rjs;
       c4rjt: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rjs: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4rjn; else goto c4rjo;
       c4rjn: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4rjx; else goto c4rjH;
       c4rjx: // global
           I64[Hp - 72] = sat_s4kQb_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rjH: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4rjU; else goto c4rjF;
       c4rjF: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rjD::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rjD::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rjo: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4rjL; else goto c4rjV;
       c4rjL: // global
           I64[Hp - 72] = sat_s4kQp_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rjV: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4rjU; else goto c4rjT;
       c4rjU: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rjT: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rjR::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rjR::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromThenTo2_info" {
     GHC.Int.$w$cenumFromThenTo2_info:
         const GHC.Int.$w$cenumFromThenTo2_entry;
         const 0;
         const 14;
         const 12884901904;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.130225201 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4rkW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rl5; else goto c4rl6;
       c4rl5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rl6: // global
           I64[Sp - 24] = block_c4rkT_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rlf; else goto c4rkU;
       u4rlf: // global
           call _c4rkT(R1) args: 0, res: 0, upd: 0;
       c4rkU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cenumFromThenTo_info" {
     GHC.Int.$fEnumInt64_$cenumFromThenTo_info:
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c4rkT() //  [R1]
         { []
         }
     {offset
       c4rkT: // global
           I64[Sp] = block_c4rkZ_info;
           _s4kQw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQw::I64;
           if (R1 & 7 != 0) goto u4rle; else goto c4rl0;
       u4rle: // global
           call _c4rkZ(R1) args: 0, res: 0, upd: 0;
       c4rl0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rkT_info" {
     block_c4rkT_info:
         const _c4rkT;
         const 2;
         const 30;
 },
 _c4rkZ() //  [R1]
         { []
         }
     {offset
       c4rkZ: // global
           I64[Sp] = block_c4rl4_info;
           _s4kQy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kQy::I64;
           if (R1 & 7 != 0) goto u4rlg; else goto c4rl9;
       u4rlg: // global
           call _c4rl4(R1) args: 0, res: 0, upd: 0;
       c4rl9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rkZ_info" {
     block_c4rkZ_info:
         const _c4rkZ;
         const 66;
         const 30;
 },
 _c4rl4() //  [R1]
         { []
         }
     {offset
       c4rl4: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo2_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rl4_info" {
     block_c4rl4_info:
         const _c4rl4;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.140758982 UTC

[section ""data" . GHC.Int.$w$cenumFromTo2_closure" {
     GHC.Int.$w$cenumFromTo2_closure:
         const GHC.Int.$w$cenumFromTo2_info;
 },
 sat_s4kQJ_entry() //  [R1]
         { []
         }
     {offset
       c4rlT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rlU; else goto c4rlV;
       c4rlU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rlV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kQF::I64 = I64[R1 + 32];
           if (_s4kQF::I64 == I64[R1 + 24]) goto c4rlS; else goto c4rlR;
       c4rlS: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4rlR: // global
           R2 = _s4kQF::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kQE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kQJ_info" {
     sat_s4kQJ_info:
         const sat_s4kQJ_entry;
         const 8589934593;
         const 15;
 },
 go_s4kQE_entry() //  [R1, R2]
         { []
         }
     {offset
       c4rm0: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4rm4; else goto c4rm3;
       c4rm4: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rm3: // global
           _s4kQC::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4kQJ_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4kQC::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s4kQE_info" {
     go_s4kQE_info:
         const go_s4kQE_entry;
         const 4294967296;
         const 10;
         const 4294967300;
 },
 GHC.Int.$w$cenumFromTo2_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rm8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rmc; else goto c4rmb;
       c4rmc: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rmb: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4rm6; else goto c4rm7;
       c4rm6: // global
           I64[Hp - 8] = go_s4kQE_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kQE_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4rm7: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromTo2_info" {
     GHC.Int.$w$cenumFromTo2_info:
         const GHC.Int.$w$cenumFromTo2_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.149104894 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rmA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rmE; else goto c4rmF;
       c4rmE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rmF: // global
           I64[Sp - 16] = block_c4rmx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rmN; else goto c4rmy;
       u4rmN: // global
           call _c4rmx(R1) args: 0, res: 0, upd: 0;
       c4rmy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cenumFromTo_info" {
     GHC.Int.$fEnumInt64_$cenumFromTo_info:
         const GHC.Int.$fEnumInt64_$cenumFromTo_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4rmx() //  [R1]
         { []
         }
     {offset
       c4rmx: // global
           I64[Sp] = block_c4rmD_info;
           _s4kQN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQN::I64;
           if (R1 & 7 != 0) goto u4rmM; else goto c4rmH;
       u4rmM: // global
           call _c4rmD(R1) args: 0, res: 0, upd: 0;
       c4rmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rmx_info" {
     block_c4rmx_info:
         const _c4rmx;
         const 1;
         const 30;
 },
 _c4rmD() //  [R1]
         { []
         }
     {offset
       c4rmD: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rmD_info" {
     block_c4rmD_info:
         const _c4rmD;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.156156239 UTC

[section ""cstring" . GHC.Int.$tcInt9_bytes" {
     GHC.Int.$tcInt9_bytes:
         I8[] [73,110,116,56]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.159180093 UTC

[section ""data" . GHC.Int.$fEnumInt7_closure" {
     GHC.Int.$fEnumInt7_closure:
         const GHC.Int.$fEnumInt7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt7_entry() //  [R1]
         { []
         }
     {offset
       c4rna: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rnb; else goto c4rnc;
       c4rnb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rnc: // global
           (_c4rn5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rn5::I64 == 0) goto c4rn7; else goto c4rn6;
       c4rn7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rn6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rn5::I64;
           I64[Sp - 24] = block_c4rn8_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt7_info" {
     GHC.Int.$fEnumInt7_info:
         const GHC.Int.$fEnumInt7_entry;
         const 0;
         const 4294967317;
         const S4lDl_srt;
 },
 _c4rn8() //  [R1]
         { []
         }
     {offset
       c4rn8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4rn8_info" {
     block_c4rn8_info:
         const _c4rn8;
         const 0;
         const 4294967326;
         const S4lDl_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.166188163 UTC

[section ""data" . GHC.Int.$fEnumInt9_closure" {
     GHC.Int.$fEnumInt9_closure:
         const GHC.Int.$fEnumInt9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt9_entry() //  [R1]
         { []
         }
     {offset
       c4rny: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rnz; else goto c4rnA;
       c4rnz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rnA: // global
           (_c4rnt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rnt::I64 == 0) goto c4rnv; else goto c4rnu;
       c4rnv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rnu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rnt::I64;
           I64[Sp - 24] = block_c4rnw_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt9_info" {
     GHC.Int.$fEnumInt9_info:
         const GHC.Int.$fEnumInt9_entry;
         const 0;
         const 4294967317;
         const S4lDl_srt+8;
 },
 _c4rnw() //  [R1]
         { []
         }
     {offset
       c4rnw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4rnw_info" {
     block_c4rnw_info:
         const _c4rnw;
         const 0;
         const 4294967326;
         const S4lDl_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.174304008 UTC

[section ""data" . GHC.Int.neInt8_closure" {
     GHC.Int.neInt8_closure:
         const GHC.Int.neInt8_info;
 },
 GHC.Int.neInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rnV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rnZ; else goto c4ro0;
       c4rnZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ro0: // global
           I64[Sp - 16] = block_c4rnS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ro9; else goto c4rnT;
       u4ro9: // global
           call _c4rnS(R1) args: 0, res: 0, upd: 0;
       c4rnT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.neInt8_info" {
     GHC.Int.neInt8_info:
         const GHC.Int.neInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4rnS() //  [R1]
         { []
         }
     {offset
       c4rnS: // global
           I64[Sp] = block_c4rnY_info;
           _s4kQV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kQV::I64;
           if (R1 & 7 != 0) goto u4ro8; else goto c4ro2;
       u4ro8: // global
           call _c4rnY(R1) args: 0, res: 0, upd: 0;
       c4ro2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rnS_info" {
     block_c4rnS_info:
         const _c4rnS;
         const 1;
         const 30;
 },
 _c4rnY() //  [R1]
         { []
         }
     {offset
       c4rnY: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rnY_info" {
     block_c4rnY_info:
         const _c4rnY;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.182921295 UTC

[section ""data" . lvl_r4kPr_closure" {
     lvl_r4kPr_closure:
         const lvl_r4kPr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r4kPr_entry() //  [R1]
         { []
         }
     {offset
       c4rox: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4roy; else goto c4roz;
       c4roy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4roz: // global
           (_c4rou::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rou::I64 == 0) goto c4row; else goto c4rov;
       c4row: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rov: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rou::I64;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_r4kPr_info" {
     lvl_r4kPr_info:
         const lvl_r4kPr_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.186889014 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cminBound_closure" {
     GHC.Int.$fBoundedInt8_$cminBound_closure:
         const GHC.Int.I8#_con_info;
         const (-128);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.18976157 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cpred_closure" {
     GHC.Int.$fEnumInt8_$cpred_closure:
         const GHC.Int.$fEnumInt8_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c4roP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4roQ; else goto c4roR;
       c4roQ: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4roR: // global
           I64[Sp - 8] = block_c4roM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rp9; else goto c4roN;
       u4rp9: // global
           call _c4roM(R1) args: 0, res: 0, upd: 0;
       c4roN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cpred_info" {
     GHC.Int.$fEnumInt8_$cpred_info:
         const GHC.Int.$fEnumInt8_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+16;
 },
 _c4roM() //  [R1]
         { []
         }
     {offset
       c4roM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4roW; else goto c4roV;
       c4roW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4roV: // global
           _s4kR2::I64 = I64[R1 + 7];
           if (_s4kR2::I64 != (-128)) goto c4rp7; else goto c4rp8;
       c4rp7: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4kR2::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rp8: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4roM_info" {
     block_c4roM_info:
         const _c4roM;
         const 0;
         const 4294967326;
         const S4lDl_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.195049268 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt8_$cmaxBound_closure:
         const GHC.Int.I8#_con_info;
         const 127;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.196827943 UTC

[section ""data" . GHC.Int.$fBoundedInt8_closure" {
     GHC.Int.$fBoundedInt8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt8_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.199906295 UTC

[section ""data" . GHC.Int.$fEnumInt8_$csucc_closure" {
     GHC.Int.$fEnumInt8_$csucc_closure:
         const GHC.Int.$fEnumInt8_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c4rpw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rpx; else goto c4rpy;
       c4rpx: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rpy: // global
           I64[Sp - 8] = block_c4rpt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rpQ; else goto c4rpu;
       u4rpQ: // global
           call _c4rpt(R1) args: 0, res: 0, upd: 0;
       c4rpu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$csucc_info" {
     GHC.Int.$fEnumInt8_$csucc_info:
         const GHC.Int.$fEnumInt8_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+32;
 },
 _c4rpt() //  [R1]
         { []
         }
     {offset
       c4rpt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rpD; else goto c4rpC;
       c4rpD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rpC: // global
           _s4kR8::I64 = I64[R1 + 7];
           if (_s4kR8::I64 != 127) goto c4rpO; else goto c4rpP;
       c4rpO: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4kR8::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rpP: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rpt_info" {
     block_c4rpt_info:
         const _c4rpt;
         const 0;
         const 4294967326;
         const S4lDl_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.207608625 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowsPrec_closure" {
     GHC.Int.$fShowInt8_$cshowsPrec_closure:
         const GHC.Int.$fShowInt8_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt8_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4rqb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rqm; else goto c4rqn;
       c4rqm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rqn: // global
           I64[Sp - 24] = block_c4rq8_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rqu; else goto c4rq9;
       u4rqu: // global
           call _c4rq8(R1) args: 0, res: 0, upd: 0;
       c4rq9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt8_$cshowsPrec_info" {
     GHC.Int.$fShowInt8_$cshowsPrec_info:
         const GHC.Int.$fShowInt8_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c4rq8() //  [R1]
         { []
         }
     {offset
       c4rq8: // global
           I64[Sp] = block_c4rqe_info;
           _s4kRf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kRf::I64;
           if (R1 & 7 != 0) goto u4rqt; else goto c4rqf;
       u4rqt: // global
           call _c4rqe(R1) args: 0, res: 0, upd: 0;
       c4rqf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rq8_info" {
     block_c4rq8_info:
         const _c4rq8;
         const 2;
         const 30;
 },
 _c4rqe() //  [R1]
         { []
         }
     {offset
       c4rqe: // global
           _s4kRd::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4rqj_info;
           R4 = _s4kRd::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rqe_info" {
     block_c4rqe_info:
         const _c4rqe;
         const 66;
         const 30;
 },
 _c4rqj() //  [R1, R2]
         { []
         }
     {offset
       c4rqj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rqs; else goto c4rqr;
       c4rqs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rqr: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rqj_info" {
     block_c4rqj_info:
         const _c4rqj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.216896598 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshow_closure" {
     GHC.Int.$fShowInt8_$cshow_closure:
         const GHC.Int.$fShowInt8_$cshow_info;
 },
 GHC.Int.$fShowInt8_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c4rqT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rqZ; else goto c4rr0;
       c4rqZ: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rr0: // global
           I64[Sp - 8] = block_c4rqQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rr5; else goto c4rqR;
       u4rr5: // global
           call _c4rqQ(R1) args: 0, res: 0, upd: 0;
       c4rqR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt8_$cshow_info" {
     GHC.Int.$fShowInt8_$cshow_info:
         const GHC.Int.$fShowInt8_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4rqQ() //  [R1]
         { []
         }
     {offset
       c4rqQ: // global
           I64[Sp] = block_c4rqW_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rqQ_info" {
     block_c4rqQ_info:
         const _c4rqQ;
         const 0;
         const 30;
 },
 _c4rqW() //  [R1, R2]
         { []
         }
     {offset
       c4rqW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rr4; else goto c4rr3;
       c4rr4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rr3: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rqW_info" {
     block_c4rqW_info:
         const _c4rqW;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.225569376 UTC

[section ""data" . GHC.Int.$fShowInt4_closure" {
     GHC.Int.$fShowInt4_closure:
         const GHC.Int.$fShowInt4_info;
 },
 GHC.Int.$fShowInt4_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rrq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rrw; else goto c4rrx;
       c4rrw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rrx: // global
           I64[Sp - 16] = block_c4rrn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rrC; else goto c4rro;
       u4rrC: // global
           call _c4rrn(R1) args: 0, res: 0, upd: 0;
       c4rro: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt4_info" {
     GHC.Int.$fShowInt4_info:
         const GHC.Int.$fShowInt4_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4rrn() //  [R1]
         { []
         }
     {offset
       c4rrn: // global
           _s4kRs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4rrt_info;
           R4 = _s4kRs::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rrn_info" {
     block_c4rrn_info:
         const _c4rrn;
         const 1;
         const 30;
 },
 _c4rrt() //  [R1, R2]
         { []
         }
     {offset
       c4rrt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rrB; else goto c4rrA;
       c4rrB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rrA: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rrt_info" {
     block_c4rrt_info:
         const _c4rrt;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.232803833 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowList_closure" {
     GHC.Int.$fShowInt8_$cshowList_closure:
         const GHC.Int.$fShowInt8_$cshowList_info;
 },
 GHC.Int.$fShowInt8_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rrU: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt8_$cshowList_info" {
     GHC.Int.$fShowInt8_$cshowList_info:
         const GHC.Int.$fShowInt8_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.236030119 UTC

[section ""data" . GHC.Int.$fShowInt8_closure" {
     GHC.Int.$fShowInt8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt8_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt8_$cshow_closure+1;
         const GHC.Int.$fShowInt8_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.238362546 UTC

[section ""data" . GHC.Int.$wlvl2_closure" {
     GHC.Int.$wlvl2_closure:
         const GHC.Int.$wlvl2_info;
         const 0;
 },
 GHC.Int.$wlvl2_entry() //  [R2]
         { []
         }
     {offset
       c4rs6: // global
           R6 = GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl_r4kPr_closure;
           R2 = GHC.Int.$fShowInt8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wlvl2_info" {
     GHC.Int.$wlvl2_info:
         const GHC.Int.$wlvl2_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S4lDl_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.242998985 UTC

[section ""data" . GHC.Int.$w$ctoEnum2_closure" {
     GHC.Int.$w$ctoEnum2_closure:
         const GHC.Int.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum2_entry() //  [R2]
         { []
         }
     {offset
       c4rsm: // global
           _s4kRB::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-128))) goto c4rsu; else goto c4rsl;
       c4rsl: // global
           if (%MO_S_Gt_W64(_s4kRB::I64, 127)) goto c4rsu; else goto c4rsv;
       c4rsu: // global
           R2 = _s4kRB::I64;
           call GHC.Int.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c4rsv: // global
           R1 = _s4kRB::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$ctoEnum2_info" {
     GHC.Int.$w$ctoEnum2_info:
         const GHC.Int.$w$ctoEnum2_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S4lDl_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.247340808 UTC

[section ""data" . GHC.Int.$fEnumInt8_$ctoEnum_closure" {
     GHC.Int.$fEnumInt8_$ctoEnum_closure:
         const GHC.Int.$fEnumInt8_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c4rsI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rsQ; else goto c4rsR;
       c4rsQ: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rsR: // global
           I64[Sp - 8] = block_c4rsF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rsW; else goto c4rsG;
       u4rsW: // global
           call _c4rsF(R1) args: 0, res: 0, upd: 0;
       c4rsG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$ctoEnum_info" {
     GHC.Int.$fEnumInt8_$ctoEnum_info:
         const GHC.Int.$fEnumInt8_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+72;
 },
 _c4rsF() //  [R1]
         { []
         }
     {offset
       c4rsF: // global
           I64[Sp] = block_c4rsL_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rsF_info" {
     block_c4rsF_info:
         const _c4rsF;
         const 0;
         const 4294967326;
         const S4lDl_srt+80;
 },
 _c4rsL() //  [R1]
         { []
         }
     {offset
       c4rsL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rsV; else goto c4rsU;
       c4rsV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4rsU: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rsL_info" {
     block_c4rsL_info:
         const _c4rsL;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.265938181 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo3_closure" {
     GHC.Int.$w$cenumFromThenTo3_closure:
         const GHC.Int.$w$cenumFromThenTo3_info;
         const 0;
 },
 sat_s4kS1_entry() //  [R1]
         { []
         }
     {offset
       c4rtI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rtJ; else goto c4rtK;
       c4rtJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rtK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kRU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kS1_info" {
     sat_s4kS1_info:
         const sat_s4kS1_entry;
         const 8589934593;
         const 4294967311;
         const S4lDl_srt+64;
 },
 sat_s4kRZ_entry() //  [R1]
         { []
         }
     {offset
       c4rtU: // global
           _s4kRZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rtV; else goto c4rtW;
       c4rtW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rtY; else goto c4rtX;
       c4rtY: // global
           HpAlloc = 16;
           goto c4rtV;
       c4rtV: // global
           R1 = _s4kRZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rtX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kRZ::P64;
           _s4kRV::I64 = I64[_s4kRZ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRV::I64, (-128))) goto c4ru4; else goto c4rtT;
       c4rtT: // global
           if (%MO_S_Gt_W64(_s4kRV::I64, 127)) goto c4ru4; else goto c4ru8;
       c4ru4: // global
           Hp = Hp - 16;
           R2 = _s4kRV::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4ru8: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kRZ_info" {
     sat_s4kRZ_info:
         const sat_s4kRZ_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+64;
 },
 sat_s4kS4_entry() //  [R1]
         { []
         }
     {offset
       c4ruj: // global
           _s4kS4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ruk; else goto c4rul;
       c4rul: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4run; else goto c4rum;
       c4run: // global
           HpAlloc = 16;
           goto c4ruk;
       c4ruk: // global
           R1 = _s4kS4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rum: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS4::P64;
           _s4kRV::I64 = I64[_s4kS4::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRV::I64, (-128))) goto c4rut; else goto c4rui;
       c4rui: // global
           if (%MO_S_Gt_W64(_s4kRV::I64, 127)) goto c4rut; else goto c4rux;
       c4rut: // global
           Hp = Hp - 16;
           R2 = _s4kRV::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rux: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRV::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kS4_info" {
     sat_s4kS4_info:
         const sat_s4kS4_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+64;
 },
 go_dn_s4kRU_entry() //  [R1, R2]
         { []
         }
     {offset
       c4ruB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4ruF; else goto c4ruE;
       c4ruF: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ruE: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4ruz; else goto c4ruA;
       c4ruz: // global
           _s4kRS::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kS1_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kRS::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kRZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ruA: // global
           I64[Hp - 80] = sat_s4kS4_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4ruH::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4ruH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s4kRU_info" {
     go_dn_s4kRU_info:
         const go_dn_s4kRU_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4lDl_srt+64;
 },
 sat_s4kS5_entry() //  [R1]
         { []
         }
     {offset
       c4ruI: // global
           _s4kS5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ruJ; else goto c4ruK;
       c4ruK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ruM; else goto c4ruL;
       c4ruM: // global
           HpAlloc = 24;
           goto c4ruJ;
       c4ruJ: // global
           R1 = _s4kS5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ruL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS5::P64;
           _s4kRL::I64 = I64[_s4kS5::P64 + 24];
           _s4kRS::I64 = _s4kRL::I64 - I64[_s4kS5::P64 + 16];
           _s4kRT::I64 = I64[_s4kS5::P64 + 32] - _s4kRS::I64;
           I64[Hp - 16] = go_dn_s4kRU_info;
           I64[Hp - 8] = _s4kRS::I64;
           I64[Hp] = _s4kRT::I64;
           R2 = _s4kRL::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kRU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kS5_info" {
     sat_s4kS5_info:
         const sat_s4kS5_entry;
         const 12884901888;
         const 4294967311;
         const S4lDl_srt+64;
 },
 sat_s4kRR_entry() //  [R1]
         { []
         }
     {offset
       c4ruW: // global
           _s4kRR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4ruX; else goto c4ruY;
       c4ruY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rv0; else goto c4ruZ;
       c4rv0: // global
           HpAlloc = 16;
           goto c4ruX;
       c4ruX: // global
           R1 = _s4kRR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ruZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kRR::P64;
           _s4kRK::I64 = I64[_s4kRR::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4rv6; else goto c4ruV;
       c4ruV: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4rv6; else goto c4rva;
       c4rv6: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rva: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kRR_info" {
     sat_s4kRR_info:
         const sat_s4kRR_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+64;
 },
 sat_s4kS9_entry() //  [R1]
         { []
         }
     {offset
       c4rvo: // global
           _s4kS9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rvp; else goto c4rvq;
       c4rvq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rvs; else goto c4rvr;
       c4rvs: // global
           HpAlloc = 16;
           goto c4rvp;
       c4rvp: // global
           R1 = _s4kS9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rvr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kS9::P64;
           _s4kRK::I64 = I64[_s4kS9::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4rvy; else goto c4rvn;
       c4rvn: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4rvy; else goto c4rvC;
       c4rvy: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rvC: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kS9_info" {
     sat_s4kS9_info:
         const sat_s4kS9_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+64;
 },
 sat_s4kSn_entry() //  [R1]
         { []
         }
     {offset
       c4rw5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rw6; else goto c4rw7;
       c4rw6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rw7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kSg_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kSn_info" {
     sat_s4kSn_info:
         const sat_s4kSn_entry;
         const 8589934593;
         const 4294967311;
         const S4lDl_srt+64;
 },
 sat_s4kSl_entry() //  [R1]
         { []
         }
     {offset
       c4rwh: // global
           _s4kSl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rwi; else goto c4rwj;
       c4rwj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rwl; else goto c4rwk;
       c4rwl: // global
           HpAlloc = 16;
           goto c4rwi;
       c4rwi: // global
           R1 = _s4kSl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rwk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSl::P64;
           _s4kSh::I64 = I64[_s4kSl::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSh::I64, (-128))) goto c4rwr; else goto c4rwg;
       c4rwg: // global
           if (%MO_S_Gt_W64(_s4kSh::I64, 127)) goto c4rwr; else goto c4rwv;
       c4rwr: // global
           Hp = Hp - 16;
           R2 = _s4kSh::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rwv: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSh::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kSl_info" {
     sat_s4kSl_info:
         const sat_s4kSl_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+64;
 },
 sat_s4kSq_entry() //  [R1]
         { []
         }
     {offset
       c4rwG: // global
           _s4kSq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rwH; else goto c4rwI;
       c4rwI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rwK; else goto c4rwJ;
       c4rwK: // global
           HpAlloc = 16;
           goto c4rwH;
       c4rwH: // global
           R1 = _s4kSq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rwJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSq::P64;
           _s4kSh::I64 = I64[_s4kSq::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSh::I64, (-128))) goto c4rwQ; else goto c4rwF;
       c4rwF: // global
           if (%MO_S_Gt_W64(_s4kSh::I64, 127)) goto c4rwQ; else goto c4rwU;
       c4rwQ: // global
           Hp = Hp - 16;
           R2 = _s4kSh::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rwU: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSh::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kSq_info" {
     sat_s4kSq_info:
         const sat_s4kSq_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+64;
 },
 go_up_s4kSg_entry() //  [R1, R2]
         { []
         }
     {offset
       c4rwY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rx2; else goto c4rx1;
       c4rx2: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rx1: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4rwW; else goto c4rwX;
       c4rwW: // global
           _s4kSe::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kSn_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kSe::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kSl_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rwX: // global
           I64[Hp - 80] = sat_s4kSq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rx4::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rx4::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s4kSg_info" {
     go_up_s4kSg_info:
         const go_up_s4kSg_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4lDl_srt+64;
 },
 sat_s4kSr_entry() //  [R1]
         { []
         }
     {offset
       c4rx5: // global
           _s4kSr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rx6; else goto c4rx7;
       c4rx7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rx9; else goto c4rx8;
       c4rx9: // global
           HpAlloc = 24;
           goto c4rx6;
       c4rx6: // global
           R1 = _s4kSr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rx8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSr::P64;
           _s4kRL::I64 = I64[_s4kSr::P64 + 24];
           _s4kSe::I64 = _s4kRL::I64 - I64[_s4kSr::P64 + 16];
           _s4kSf::I64 = I64[_s4kSr::P64 + 32] - _s4kSe::I64;
           I64[Hp - 16] = go_up_s4kSg_info;
           I64[Hp - 8] = _s4kSe::I64;
           I64[Hp] = _s4kSf::I64;
           R2 = _s4kRL::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kSg_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kSr_info" {
     sat_s4kSr_info:
         const sat_s4kSr_entry;
         const 12884901888;
         const 4294967311;
         const S4lDl_srt+64;
 },
 sat_s4kSd_entry() //  [R1]
         { []
         }
     {offset
       c4rxj: // global
           _s4kSd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rxk; else goto c4rxl;
       c4rxl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rxn; else goto c4rxm;
       c4rxn: // global
           HpAlloc = 16;
           goto c4rxk;
       c4rxk: // global
           R1 = _s4kSd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rxm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSd::P64;
           _s4kRK::I64 = I64[_s4kSd::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4rxt; else goto c4rxi;
       c4rxi: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4rxt; else goto c4rxx;
       c4rxt: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rxx: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kSd_info" {
     sat_s4kSd_info:
         const sat_s4kSd_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+64;
 },
 sat_s4kSv_entry() //  [R1]
         { []
         }
     {offset
       c4rxL: // global
           _s4kSv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rxM; else goto c4rxN;
       c4rxN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rxP; else goto c4rxO;
       c4rxP: // global
           HpAlloc = 16;
           goto c4rxM;
       c4rxM: // global
           R1 = _s4kSv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rxO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSv::P64;
           _s4kRK::I64 = I64[_s4kSv::P64 + 16];
           if (%MO_S_Lt_W64(_s4kRK::I64, (-128))) goto c4rxV; else goto c4rxK;
       c4rxK: // global
           if (%MO_S_Gt_W64(_s4kRK::I64, 127)) goto c4rxV; else goto c4rxZ;
       c4rxV: // global
           Hp = Hp - 16;
           R2 = _s4kRK::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rxZ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kRK::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kSv_info" {
     sat_s4kSv_info:
         const sat_s4kSv_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+64;
 },
 GHC.Int.$w$cenumFromThenTo3_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4ry3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4ry7; else goto c4ry6;
       c4ry7: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ry6: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4ry1; else goto c4ry2;
       c4ry1: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4rya; else goto c4ryf;
       c4rya: // global
           I64[Hp - 80] = sat_s4kS5_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kRR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ryf: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4rym; else goto c4ryd;
       c4ryd: // global
           I64[Hp - 80] = sat_s4kS9_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4ryb::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4ryb::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ry2: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4ryi; else goto c4ryn;
       c4ryi: // global
           I64[Hp - 80] = sat_s4kSr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kSd_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ryn: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4rym; else goto c4ryl;
       c4rym: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ryl: // global
           I64[Hp - 80] = sat_s4kSv_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4ryj::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4ryj::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromThenTo3_info" {
     GHC.Int.$w$cenumFromThenTo3_info:
         const GHC.Int.$w$cenumFromThenTo3_entry;
         const 0;
         const 38654705678;
         const 12884901904;
         const S4lDl_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.307023516 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4rA2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rAb; else goto c4rAc;
       c4rAb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rAc: // global
           I64[Sp - 24] = block_c4rzZ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rAl; else goto c4rA0;
       u4rAl: // global
           call _c4rzZ(R1) args: 0, res: 0, upd: 0;
       c4rA0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cenumFromThenTo_info" {
     GHC.Int.$fEnumInt8_$cenumFromThenTo_info:
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S4lDl_srt+88;
 },
 _c4rzZ() //  [R1]
         { []
         }
     {offset
       c4rzZ: // global
           I64[Sp] = block_c4rA5_info;
           _s4kSA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kSA::I64;
           if (R1 & 7 != 0) goto u4rAk; else goto c4rA6;
       u4rAk: // global
           call _c4rA5(R1) args: 0, res: 0, upd: 0;
       c4rA6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rzZ_info" {
     block_c4rzZ_info:
         const _c4rzZ;
         const 2;
         const 4294967326;
         const S4lDl_srt+88;
 },
 _c4rA5() //  [R1]
         { []
         }
     {offset
       c4rA5: // global
           I64[Sp] = block_c4rAa_info;
           _s4kSC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kSC::I64;
           if (R1 & 7 != 0) goto u4rAm; else goto c4rAf;
       u4rAm: // global
           call _c4rAa(R1) args: 0, res: 0, upd: 0;
       c4rAf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rA5_info" {
     block_c4rA5_info:
         const _c4rA5;
         const 66;
         const 4294967326;
         const S4lDl_srt+88;
 },
 _c4rAa() //  [R1]
         { []
         }
     {offset
       c4rAa: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo3_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rAa_info" {
     block_c4rAa_info:
         const _c4rAa;
         const 194;
         const 4294967326;
         const S4lDl_srt+88;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.318369876 UTC

[section ""data" . GHC.Int.$w$cenumFromTo3_closure" {
     GHC.Int.$w$cenumFromTo3_closure:
         const GHC.Int.$w$cenumFromTo3_info;
         const 0;
 },
 sat_s4kSP_entry() //  [R1]
         { []
         }
     {offset
       c4rAZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rB0; else goto c4rB1;
       c4rB0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rB1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kSJ::I64 = I64[R1 + 32];
           if (_s4kSJ::I64 == I64[R1 + 24]) goto c4rAY; else goto c4rAX;
       c4rAY: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4rAX: // global
           R2 = _s4kSJ::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kSI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kSP_info" {
     sat_s4kSP_info:
         const sat_s4kSP_entry;
         const 8589934593;
         const 4294967311;
         const S4lDl_srt+64;
 },
 sat_s4kSM_entry() //  [R1]
         { []
         }
     {offset
       c4rBd: // global
           _s4kSM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rBe; else goto c4rBf;
       c4rBf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rBh; else goto c4rBg;
       c4rBh: // global
           HpAlloc = 16;
           goto c4rBe;
       c4rBe: // global
           R1 = _s4kSM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rBg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSM::P64;
           _s4kSJ::I64 = I64[_s4kSM::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSJ::I64, (-128))) goto c4rBn; else goto c4rBc;
       c4rBc: // global
           if (%MO_S_Gt_W64(_s4kSJ::I64, 127)) goto c4rBn; else goto c4rBr;
       c4rBn: // global
           Hp = Hp - 16;
           R2 = _s4kSJ::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rBr: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSJ::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kSM_info" {
     sat_s4kSM_info:
         const sat_s4kSM_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+64;
 },
 go_s4kSI_entry() //  [R1, R2]
         { []
         }
     {offset
       c4rBt: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rBx; else goto c4rBw;
       c4rBx: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rBw: // global
           _s4kSG::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kSP_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kSG::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kSM_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s4kSI_info" {
     go_s4kSI_info:
         const go_s4kSI_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S4lDl_srt+64;
 },
 GHC.Int.$w$cenumFromTo3_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rBB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rBF; else goto c4rBE;
       c4rBF: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rBE: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4rBz; else goto c4rBA;
       c4rBz: // global
           I64[Hp - 8] = go_s4kSI_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kSI_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4rBA: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromTo3_info" {
     GHC.Int.$w$cenumFromTo3_info:
         const GHC.Int.$w$cenumFromTo3_entry;
         const 0;
         const 141733920782;
         const 8589934604;
         const S4lDl_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.329785756 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rC8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rCc; else goto c4rCd;
       c4rCc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rCd: // global
           I64[Sp - 16] = block_c4rC5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rCl; else goto c4rC6;
       u4rCl: // global
           call _c4rC5(R1) args: 0, res: 0, upd: 0;
       c4rC6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cenumFromTo_info" {
     GHC.Int.$fEnumInt8_$cenumFromTo_info:
         const GHC.Int.$fEnumInt8_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+104;
 },
 _c4rC5() //  [R1]
         { []
         }
     {offset
       c4rC5: // global
           I64[Sp] = block_c4rCb_info;
           _s4kST::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kST::I64;
           if (R1 & 7 != 0) goto u4rCk; else goto c4rCf;
       u4rCk: // global
           call _c4rCb(R1) args: 0, res: 0, upd: 0;
       c4rCf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rC5_info" {
     block_c4rC5_info:
         const _c4rC5;
         const 1;
         const 4294967326;
         const S4lDl_srt+104;
 },
 _c4rCb() //  [R1]
         { []
         }
     {offset
       c4rCb: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo3_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rCb_info" {
     block_c4rCb_info:
         const _c4rCb;
         const 65;
         const 4294967326;
         const S4lDl_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.339837934 UTC

[section ""data" . GHC.Int.$wgo3_closure" {
     GHC.Int.$wgo3_closure:
         const GHC.Int.$wgo3_info;
         const 0;
 },
 sat_s4kT5_entry() //  [R1]
         { []
         }
     {offset
       c4rCL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rCM; else goto c4rCX;
       c4rCM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rCX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kT0::I64 = I64[R1 + 16];
           if (_s4kT0::I64 != 127) goto c4rCJ; else goto c4rCK;
       c4rCJ: // global
           I64[Sp - 24] = block_c4rCR_info;
           R2 = _s4kT0::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 24;
       c4rCK: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kT5_info" {
     sat_s4kT5_info:
         const sat_s4kT5_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+120;
 },
 _c4rCR() //  [R1, R2]
         { []
         }
     {offset
       c4rCR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rCW; else goto c4rCV;
       c4rCW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4rCV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4rCR_info" {
     block_c4rCR_info:
         const _c4rCR;
         const 0;
         const 30;
 },
 sat_s4kSZ_entry() //  [R1]
         { []
         }
     {offset
       c4rD7: // global
           _s4kSZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rD8; else goto c4rD9;
       c4rD9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rDb; else goto c4rDa;
       c4rDb: // global
           HpAlloc = 16;
           goto c4rD8;
       c4rD8: // global
           R1 = _s4kSZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rDa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kSZ::P64;
           _s4kSW::I64 = I64[_s4kSZ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kSW::I64, (-128))) goto c4rDh; else goto c4rD6;
       c4rD6: // global
           if (%MO_S_Gt_W64(_s4kSW::I64, 127)) goto c4rDh; else goto c4rDl;
       c4rDh: // global
           Hp = Hp - 16;
           R2 = _s4kSW::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4rDl: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kSW::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kSZ_info" {
     sat_s4kSZ_info:
         const sat_s4kSZ_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+64;
 },
 GHC.Int.$wgo3_entry() //  [R2]
         { []
         }
     {offset
       c4rDm: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4rDq; else goto c4rDp;
       c4rDq: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rDp: // global
           I64[Hp - 40] = sat_s4kT5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kSZ_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wgo3_info" {
     GHC.Int.$wgo3_info:
         const GHC.Int.$wgo3_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const S4lDl_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.350171727 UTC

[section ""data" . GHC.Int.$fEnumInt8_go_closure" {
     GHC.Int.$fEnumInt8_go_closure:
         const GHC.Int.$fEnumInt8_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_go_entry() //  [R2]
         { []
         }
     {offset
       c4rDR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rDS; else goto c4rDT;
       c4rDS: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rDT: // global
           I64[Sp - 8] = block_c4rDO_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_go_info" {
     GHC.Int.$fEnumInt8_go_info:
         const GHC.Int.$fEnumInt8_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S4lDl_srt+120;
 },
 _c4rDO() //  [R1, R2]
         { []
         }
     {offset
       c4rDO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rDW; else goto c4rDV;
       c4rDW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rDV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rDO_info" {
     block_c4rDO_info:
         const _c4rDO;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.357414834 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFrom_closure" {
     GHC.Int.$fEnumInt8_$cenumFrom_closure:
         const GHC.Int.$fEnumInt8_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c4rEd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rEe; else goto c4rEf;
       c4rEe: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rEf: // global
           I64[Sp - 8] = block_c4rEa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rEo; else goto c4rEb;
       u4rEo: // global
           call _c4rEa(R1) args: 0, res: 0, upd: 0;
       c4rEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cenumFrom_info" {
     GHC.Int.$fEnumInt8_$cenumFrom_info:
         const GHC.Int.$fEnumInt8_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+128;
 },
 _c4rEa() //  [R1]
         { []
         }
     {offset
       c4rEa: // global
           _s4kTc::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kTc::I64, 127)) goto c4rEm; else goto c4rEn;
       c4rEm: // global
           R2 = _s4kTc::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_go_entry(R2) args: 8, res: 0, upd: 8;
       c4rEn: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rEa_info" {
     block_c4rEa_info:
         const _c4rEa;
         const 0;
         const 4294967326;
         const S4lDl_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.364822619 UTC

[section ""data" . GHC.Int.$fEnumInt8_closure" {
     GHC.Int.$fEnumInt8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt8_$csucc_closure+1;
         const GHC.Int.$fEnumInt8_$cpred_closure+1;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt8_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rED: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt8_closure+1;
           R2 = GHC.Int.$fEnumInt8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cenumFromThen_info" {
     GHC.Int.$fEnumInt8_$cenumFromThen_info:
         const GHC.Int.$fEnumInt8_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S4lDl_srt+144;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.369095659 UTC

[section ""cstring" . GHC.Int.$tcInt2_bytes" {
     GHC.Int.$tcInt2_bytes:
         I8[] [73,110,116,49,54]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.372336459 UTC

[section ""data" . GHC.Int.$fEnumInt1_closure" {
     GHC.Int.$fEnumInt1_closure:
         const GHC.Int.$fEnumInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt1_entry() //  [R1]
         { []
         }
     {offset
       c4rEU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rEV; else goto c4rEW;
       c4rEV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rEW: // global
           (_c4rEP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rEP::I64 == 0) goto c4rER; else goto c4rEQ;
       c4rER: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rEQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rEP::I64;
           I64[Sp - 24] = block_c4rES_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt1_info" {
     GHC.Int.$fEnumInt1_info:
         const GHC.Int.$fEnumInt1_entry;
         const 0;
         const 4294967317;
         const S4lDl_srt;
 },
 _c4rES() //  [R1]
         { []
         }
     {offset
       c4rES: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4rES_info" {
     block_c4rES_info:
         const _c4rES;
         const 0;
         const 4294967326;
         const S4lDl_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.378315248 UTC

[section ""data" . GHC.Int.$fEnumInt2_closure" {
     GHC.Int.$fEnumInt2_closure:
         const GHC.Int.$fEnumInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt2_entry() //  [R1]
         { []
         }
     {offset
       c4rFi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rFj; else goto c4rFk;
       c4rFj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rFk: // global
           (_c4rFd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rFd::I64 == 0) goto c4rFf; else goto c4rFe;
       c4rFf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rFe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rFd::I64;
           I64[Sp - 24] = block_c4rFg_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt2_info" {
     GHC.Int.$fEnumInt2_info:
         const GHC.Int.$fEnumInt2_entry;
         const 0;
         const 4294967317;
         const S4lDl_srt+8;
 },
 _c4rFg() //  [R1]
         { []
         }
     {offset
       c4rFg: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4rFg_info" {
     block_c4rFg_info:
         const _c4rFg;
         const 0;
         const 4294967326;
         const S4lDl_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.385060923 UTC

[section ""data" . GHC.Int.neInt16_closure" {
     GHC.Int.neInt16_closure:
         const GHC.Int.neInt16_info;
 },
 GHC.Int.neInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rFF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rFJ; else goto c4rFK;
       c4rFJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rFK: // global
           I64[Sp - 16] = block_c4rFC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rFT; else goto c4rFD;
       u4rFT: // global
           call _c4rFC(R1) args: 0, res: 0, upd: 0;
       c4rFD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.neInt16_info" {
     GHC.Int.neInt16_info:
         const GHC.Int.neInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4rFC() //  [R1]
         { []
         }
     {offset
       c4rFC: // global
           I64[Sp] = block_c4rFI_info;
           _s4kTj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kTj::I64;
           if (R1 & 7 != 0) goto u4rFS; else goto c4rFM;
       u4rFS: // global
           call _c4rFI(R1) args: 0, res: 0, upd: 0;
       c4rFM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rFC_info" {
     block_c4rFC_info:
         const _c4rFC;
         const 1;
         const 30;
 },
 _c4rFI() //  [R1]
         { []
         }
     {offset
       c4rFI: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rFI_info" {
     block_c4rFI_info:
         const _c4rFI;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.392978103 UTC

[section ""data" . lvl2_r4kPt_closure" {
     lvl2_r4kPt_closure:
         const lvl2_r4kPt_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r4kPt_entry() //  [R1]
         { []
         }
     {offset
       c4rGh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rGi; else goto c4rGj;
       c4rGi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rGj: // global
           (_c4rGe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rGe::I64 == 0) goto c4rGg; else goto c4rGf;
       c4rGg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rGf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rGe::I64;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl2_r4kPt_info" {
     lvl2_r4kPt_info:
         const lvl2_r4kPt_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.396589075 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cminBound_closure" {
     GHC.Int.$fBoundedInt16_$cminBound_closure:
         const GHC.Int.I16#_con_info;
         const (-32768);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.399567199 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cpred_closure" {
     GHC.Int.$fEnumInt16_$cpred_closure:
         const GHC.Int.$fEnumInt16_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c4rGz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rGA; else goto c4rGB;
       c4rGA: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rGB: // global
           I64[Sp - 8] = block_c4rGw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rGT; else goto c4rGx;
       u4rGT: // global
           call _c4rGw(R1) args: 0, res: 0, upd: 0;
       c4rGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cpred_info" {
     GHC.Int.$fEnumInt16_$cpred_info:
         const GHC.Int.$fEnumInt16_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+152;
 },
 _c4rGw() //  [R1]
         { []
         }
     {offset
       c4rGw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rGG; else goto c4rGF;
       c4rGG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rGF: // global
           _s4kTq::I64 = I64[R1 + 7];
           if (_s4kTq::I64 != (-32768)) goto c4rGR; else goto c4rGS;
       c4rGR: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4kTq::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rGS: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rGw_info" {
     block_c4rGw_info:
         const _c4rGw;
         const 0;
         const 4294967326;
         const S4lDl_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.404948071 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt16_$cmaxBound_closure:
         const GHC.Int.I16#_con_info;
         const 32767;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.407292903 UTC

[section ""data" . GHC.Int.$fBoundedInt16_closure" {
     GHC.Int.$fBoundedInt16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt16_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.4104125 UTC

[section ""data" . GHC.Int.$fEnumInt16_$csucc_closure" {
     GHC.Int.$fEnumInt16_$csucc_closure:
         const GHC.Int.$fEnumInt16_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c4rHg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rHh; else goto c4rHi;
       c4rHh: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rHi: // global
           I64[Sp - 8] = block_c4rHd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rHA; else goto c4rHe;
       u4rHA: // global
           call _c4rHd(R1) args: 0, res: 0, upd: 0;
       c4rHe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$csucc_info" {
     GHC.Int.$fEnumInt16_$csucc_info:
         const GHC.Int.$fEnumInt16_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+168;
 },
 _c4rHd() //  [R1]
         { []
         }
     {offset
       c4rHd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rHn; else goto c4rHm;
       c4rHn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rHm: // global
           _s4kTw::I64 = I64[R1 + 7];
           if (_s4kTw::I64 != 32767) goto c4rHy; else goto c4rHz;
       c4rHy: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4kTw::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rHz: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rHd_info" {
     block_c4rHd_info:
         const _c4rHd;
         const 0;
         const 4294967326;
         const S4lDl_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.418553946 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowsPrec_closure" {
     GHC.Int.$fShowInt16_$cshowsPrec_closure:
         const GHC.Int.$fShowInt16_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt16_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4rHV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rI6; else goto c4rI7;
       c4rI6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rI7: // global
           I64[Sp - 24] = block_c4rHS_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rIe; else goto c4rHT;
       u4rIe: // global
           call _c4rHS(R1) args: 0, res: 0, upd: 0;
       c4rHT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt16_$cshowsPrec_info" {
     GHC.Int.$fShowInt16_$cshowsPrec_info:
         const GHC.Int.$fShowInt16_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c4rHS() //  [R1]
         { []
         }
     {offset
       c4rHS: // global
           I64[Sp] = block_c4rHY_info;
           _s4kTD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kTD::I64;
           if (R1 & 7 != 0) goto u4rId; else goto c4rHZ;
       u4rId: // global
           call _c4rHY(R1) args: 0, res: 0, upd: 0;
       c4rHZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rHS_info" {
     block_c4rHS_info:
         const _c4rHS;
         const 2;
         const 30;
 },
 _c4rHY() //  [R1]
         { []
         }
     {offset
       c4rHY: // global
           _s4kTB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4rI3_info;
           R4 = _s4kTB::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rHY_info" {
     block_c4rHY_info:
         const _c4rHY;
         const 66;
         const 30;
 },
 _c4rI3() //  [R1, R2]
         { []
         }
     {offset
       c4rI3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rIc; else goto c4rIb;
       c4rIc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rIb: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rI3_info" {
     block_c4rI3_info:
         const _c4rI3;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.428132797 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshow_closure" {
     GHC.Int.$fShowInt16_$cshow_closure:
         const GHC.Int.$fShowInt16_$cshow_info;
 },
 GHC.Int.$fShowInt16_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c4rID: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rIJ; else goto c4rIK;
       c4rIJ: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rIK: // global
           I64[Sp - 8] = block_c4rIA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rIP; else goto c4rIB;
       u4rIP: // global
           call _c4rIA(R1) args: 0, res: 0, upd: 0;
       c4rIB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt16_$cshow_info" {
     GHC.Int.$fShowInt16_$cshow_info:
         const GHC.Int.$fShowInt16_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4rIA() //  [R1]
         { []
         }
     {offset
       c4rIA: // global
           I64[Sp] = block_c4rIG_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rIA_info" {
     block_c4rIA_info:
         const _c4rIA;
         const 0;
         const 30;
 },
 _c4rIG() //  [R1, R2]
         { []
         }
     {offset
       c4rIG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rIO; else goto c4rIN;
       c4rIO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rIN: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rIG_info" {
     block_c4rIG_info:
         const _c4rIG;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.43638983 UTC

[section ""data" . GHC.Int.$fShowInt1_closure" {
     GHC.Int.$fShowInt1_closure:
         const GHC.Int.$fShowInt1_info;
 },
 GHC.Int.$fShowInt1_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rJa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rJg; else goto c4rJh;
       c4rJg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rJh: // global
           I64[Sp - 16] = block_c4rJ7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rJm; else goto c4rJ8;
       u4rJm: // global
           call _c4rJ7(R1) args: 0, res: 0, upd: 0;
       c4rJ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt1_info" {
     GHC.Int.$fShowInt1_info:
         const GHC.Int.$fShowInt1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4rJ7() //  [R1]
         { []
         }
     {offset
       c4rJ7: // global
           _s4kTQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4rJd_info;
           R4 = _s4kTQ::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rJ7_info" {
     block_c4rJ7_info:
         const _c4rJ7;
         const 1;
         const 30;
 },
 _c4rJd() //  [R1, R2]
         { []
         }
     {offset
       c4rJd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rJl; else goto c4rJk;
       c4rJl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rJk: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rJd_info" {
     block_c4rJd_info:
         const _c4rJd;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.443533659 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowList_closure" {
     GHC.Int.$fShowInt16_$cshowList_closure:
         const GHC.Int.$fShowInt16_$cshowList_info;
 },
 GHC.Int.$fShowInt16_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rJE: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt16_$cshowList_info" {
     GHC.Int.$fShowInt16_$cshowList_info:
         const GHC.Int.$fShowInt16_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.447381964 UTC

[section ""data" . GHC.Int.$fShowInt16_closure" {
     GHC.Int.$fShowInt16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt16_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt16_$cshow_closure+1;
         const GHC.Int.$fShowInt16_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.449751515 UTC

[section ""data" . GHC.Int.$wlvl_closure" {
     GHC.Int.$wlvl_closure:
         const GHC.Int.$wlvl_info;
         const 0;
 },
 GHC.Int.$wlvl_entry() //  [R2]
         { []
         }
     {offset
       c4rJQ: // global
           R6 = GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r4kPt_closure;
           R2 = GHC.Int.$fShowInt16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wlvl_info" {
     GHC.Int.$wlvl_info:
         const GHC.Int.$wlvl_entry;
         const 0;
         const 562954248388622;
         const 4294967300;
         const S4lDl_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.454938631 UTC

[section ""data" . GHC.Int.$w$ctoEnum_closure" {
     GHC.Int.$w$ctoEnum_closure:
         const GHC.Int.$w$ctoEnum_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c4rK6: // global
           _s4kTZ::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-32768))) goto c4rKe; else goto c4rK5;
       c4rK5: // global
           if (%MO_S_Gt_W64(_s4kTZ::I64, 32767)) goto c4rKe; else goto c4rKf;
       c4rKe: // global
           R2 = _s4kTZ::I64;
           call GHC.Int.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c4rKf: // global
           R1 = _s4kTZ::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$ctoEnum_info" {
     GHC.Int.$w$ctoEnum_info:
         const GHC.Int.$w$ctoEnum_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S4lDl_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.459660679 UTC

[section ""data" . GHC.Int.$fEnumInt16_$ctoEnum_closure" {
     GHC.Int.$fEnumInt16_$ctoEnum_closure:
         const GHC.Int.$fEnumInt16_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c4rKs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rKA; else goto c4rKB;
       c4rKA: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rKB: // global
           I64[Sp - 8] = block_c4rKp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rKG; else goto c4rKq;
       u4rKG: // global
           call _c4rKp(R1) args: 0, res: 0, upd: 0;
       c4rKq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$ctoEnum_info" {
     GHC.Int.$fEnumInt16_$ctoEnum_info:
         const GHC.Int.$fEnumInt16_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+200;
 },
 _c4rKp() //  [R1]
         { []
         }
     {offset
       c4rKp: // global
           I64[Sp] = block_c4rKv_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rKp_info" {
     block_c4rKp_info:
         const _c4rKp;
         const 0;
         const 4294967326;
         const S4lDl_srt+208;
 },
 _c4rKv() //  [R1]
         { []
         }
     {offset
       c4rKv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rKF; else goto c4rKE;
       c4rKF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4rKE: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rKv_info" {
     block_c4rKv_info:
         const _c4rKv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.485138315 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo_closure" {
     GHC.Int.$w$cenumFromThenTo_closure:
         const GHC.Int.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s4kUp_entry() //  [R1]
         { []
         }
     {offset
       c4rLs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rLt; else goto c4rLu;
       c4rLt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rLu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kUi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUp_info" {
     sat_s4kUp_info:
         const sat_s4kUp_entry;
         const 8589934593;
         const 4294967311;
         const S4lDl_srt+192;
 },
 sat_s4kUn_entry() //  [R1]
         { []
         }
     {offset
       c4rLE: // global
           _s4kUn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rLF; else goto c4rLG;
       c4rLG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rLI; else goto c4rLH;
       c4rLI: // global
           HpAlloc = 16;
           goto c4rLF;
       c4rLF: // global
           R1 = _s4kUn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rLH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUn::P64;
           _s4kUj::I64 = I64[_s4kUn::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUj::I64,
                            (-32768))) goto c4rLO; else goto c4rLD;
       c4rLD: // global
           if (%MO_S_Gt_W64(_s4kUj::I64, 32767)) goto c4rLO; else goto c4rLS;
       c4rLO: // global
           Hp = Hp - 16;
           R2 = _s4kUj::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rLS: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUn_info" {
     sat_s4kUn_info:
         const sat_s4kUn_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+192;
 },
 sat_s4kUs_entry() //  [R1]
         { []
         }
     {offset
       c4rM3: // global
           _s4kUs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rM4; else goto c4rM5;
       c4rM5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rM7; else goto c4rM6;
       c4rM7: // global
           HpAlloc = 16;
           goto c4rM4;
       c4rM4: // global
           R1 = _s4kUs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rM6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUs::P64;
           _s4kUj::I64 = I64[_s4kUs::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUj::I64,
                            (-32768))) goto c4rMd; else goto c4rM2;
       c4rM2: // global
           if (%MO_S_Gt_W64(_s4kUj::I64, 32767)) goto c4rMd; else goto c4rMh;
       c4rMd: // global
           Hp = Hp - 16;
           R2 = _s4kUj::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rMh: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUs_info" {
     sat_s4kUs_info:
         const sat_s4kUs_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+192;
 },
 go_dn_s4kUi_entry() //  [R1, R2]
         { []
         }
     {offset
       c4rMl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rMp; else goto c4rMo;
       c4rMp: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rMo: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4rMj; else goto c4rMk;
       c4rMj: // global
           _s4kUg::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kUp_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kUg::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kUn_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rMk: // global
           I64[Hp - 80] = sat_s4kUs_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rMr::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rMr::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s4kUi_info" {
     go_dn_s4kUi_info:
         const go_dn_s4kUi_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4lDl_srt+192;
 },
 sat_s4kUt_entry() //  [R1]
         { []
         }
     {offset
       c4rMs: // global
           _s4kUt::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rMt; else goto c4rMu;
       c4rMu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rMw; else goto c4rMv;
       c4rMw: // global
           HpAlloc = 24;
           goto c4rMt;
       c4rMt: // global
           R1 = _s4kUt::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rMv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUt::P64;
           _s4kU9::I64 = I64[_s4kUt::P64 + 24];
           _s4kUg::I64 = _s4kU9::I64 - I64[_s4kUt::P64 + 16];
           _s4kUh::I64 = I64[_s4kUt::P64 + 32] - _s4kUg::I64;
           I64[Hp - 16] = go_dn_s4kUi_info;
           I64[Hp - 8] = _s4kUg::I64;
           I64[Hp] = _s4kUh::I64;
           R2 = _s4kU9::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kUi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUt_info" {
     sat_s4kUt_info:
         const sat_s4kUt_entry;
         const 12884901888;
         const 4294967311;
         const S4lDl_srt+192;
 },
 sat_s4kUf_entry() //  [R1]
         { []
         }
     {offset
       c4rMG: // global
           _s4kUf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rMH; else goto c4rMI;
       c4rMI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rMK; else goto c4rMJ;
       c4rMK: // global
           HpAlloc = 16;
           goto c4rMH;
       c4rMH: // global
           R1 = _s4kUf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rMJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUf::P64;
           _s4kU8::I64 = I64[_s4kUf::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4rMQ; else goto c4rMF;
       c4rMF: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4rMQ; else goto c4rMU;
       c4rMQ: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rMU: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUf_info" {
     sat_s4kUf_info:
         const sat_s4kUf_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+192;
 },
 sat_s4kUx_entry() //  [R1]
         { []
         }
     {offset
       c4rN8: // global
           _s4kUx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rN9; else goto c4rNa;
       c4rNa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rNc; else goto c4rNb;
       c4rNc: // global
           HpAlloc = 16;
           goto c4rN9;
       c4rN9: // global
           R1 = _s4kUx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rNb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUx::P64;
           _s4kU8::I64 = I64[_s4kUx::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4rNi; else goto c4rN7;
       c4rN7: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4rNi; else goto c4rNm;
       c4rNi: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rNm: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUx_info" {
     sat_s4kUx_info:
         const sat_s4kUx_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+192;
 },
 sat_s4kUL_entry() //  [R1]
         { []
         }
     {offset
       c4rNP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rNQ; else goto c4rNR;
       c4rNQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rNR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kUE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUL_info" {
     sat_s4kUL_info:
         const sat_s4kUL_entry;
         const 8589934593;
         const 4294967311;
         const S4lDl_srt+192;
 },
 sat_s4kUJ_entry() //  [R1]
         { []
         }
     {offset
       c4rO1: // global
           _s4kUJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rO2; else goto c4rO3;
       c4rO3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rO5; else goto c4rO4;
       c4rO5: // global
           HpAlloc = 16;
           goto c4rO2;
       c4rO2: // global
           R1 = _s4kUJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rO4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUJ::P64;
           _s4kUF::I64 = I64[_s4kUJ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUF::I64,
                            (-32768))) goto c4rOb; else goto c4rO0;
       c4rO0: // global
           if (%MO_S_Gt_W64(_s4kUF::I64, 32767)) goto c4rOb; else goto c4rOf;
       c4rOb: // global
           Hp = Hp - 16;
           R2 = _s4kUF::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rOf: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUF::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUJ_info" {
     sat_s4kUJ_info:
         const sat_s4kUJ_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+192;
 },
 sat_s4kUO_entry() //  [R1]
         { []
         }
     {offset
       c4rOq: // global
           _s4kUO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rOr; else goto c4rOs;
       c4rOs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rOu; else goto c4rOt;
       c4rOu: // global
           HpAlloc = 16;
           goto c4rOr;
       c4rOr: // global
           R1 = _s4kUO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rOt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUO::P64;
           _s4kUF::I64 = I64[_s4kUO::P64 + 16];
           if (%MO_S_Lt_W64(_s4kUF::I64,
                            (-32768))) goto c4rOA; else goto c4rOp;
       c4rOp: // global
           if (%MO_S_Gt_W64(_s4kUF::I64, 32767)) goto c4rOA; else goto c4rOE;
       c4rOA: // global
           Hp = Hp - 16;
           R2 = _s4kUF::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rOE: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kUF::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUO_info" {
     sat_s4kUO_info:
         const sat_s4kUO_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+192;
 },
 go_up_s4kUE_entry() //  [R1, R2]
         { []
         }
     {offset
       c4rOI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rOM; else goto c4rOL;
       c4rOM: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rOL: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4rOG; else goto c4rOH;
       c4rOG: // global
           _s4kUC::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kUL_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kUC::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kUJ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rOH: // global
           I64[Hp - 80] = sat_s4kUO_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rOO::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rOO::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s4kUE_info" {
     go_up_s4kUE_info:
         const go_up_s4kUE_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4lDl_srt+192;
 },
 sat_s4kUP_entry() //  [R1]
         { []
         }
     {offset
       c4rOP: // global
           _s4kUP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rOQ; else goto c4rOR;
       c4rOR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rOT; else goto c4rOS;
       c4rOT: // global
           HpAlloc = 24;
           goto c4rOQ;
       c4rOQ: // global
           R1 = _s4kUP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rOS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUP::P64;
           _s4kU9::I64 = I64[_s4kUP::P64 + 24];
           _s4kUC::I64 = _s4kU9::I64 - I64[_s4kUP::P64 + 16];
           _s4kUD::I64 = I64[_s4kUP::P64 + 32] - _s4kUC::I64;
           I64[Hp - 16] = go_up_s4kUE_info;
           I64[Hp - 8] = _s4kUC::I64;
           I64[Hp] = _s4kUD::I64;
           R2 = _s4kU9::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kUE_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUP_info" {
     sat_s4kUP_info:
         const sat_s4kUP_entry;
         const 12884901888;
         const 4294967311;
         const S4lDl_srt+192;
 },
 sat_s4kUB_entry() //  [R1]
         { []
         }
     {offset
       c4rP3: // global
           _s4kUB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rP4; else goto c4rP5;
       c4rP5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rP7; else goto c4rP6;
       c4rP7: // global
           HpAlloc = 16;
           goto c4rP4;
       c4rP4: // global
           R1 = _s4kUB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rP6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUB::P64;
           _s4kU8::I64 = I64[_s4kUB::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4rPd; else goto c4rP2;
       c4rP2: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4rPd; else goto c4rPh;
       c4rPd: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rPh: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUB_info" {
     sat_s4kUB_info:
         const sat_s4kUB_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+192;
 },
 sat_s4kUT_entry() //  [R1]
         { []
         }
     {offset
       c4rPv: // global
           _s4kUT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rPw; else goto c4rPx;
       c4rPx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rPz; else goto c4rPy;
       c4rPz: // global
           HpAlloc = 16;
           goto c4rPw;
       c4rPw: // global
           R1 = _s4kUT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rPy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kUT::P64;
           _s4kU8::I64 = I64[_s4kUT::P64 + 16];
           if (%MO_S_Lt_W64(_s4kU8::I64,
                            (-32768))) goto c4rPF; else goto c4rPu;
       c4rPu: // global
           if (%MO_S_Gt_W64(_s4kU8::I64, 32767)) goto c4rPF; else goto c4rPJ;
       c4rPF: // global
           Hp = Hp - 16;
           R2 = _s4kU8::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rPJ: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kU8::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kUT_info" {
     sat_s4kUT_info:
         const sat_s4kUT_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+192;
 },
 GHC.Int.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4rPN: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rPR; else goto c4rPQ;
       c4rPR: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rPQ: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4rPL; else goto c4rPM;
       c4rPL: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4rPU; else goto c4rPZ;
       c4rPU: // global
           I64[Hp - 80] = sat_s4kUt_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kUf_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rPZ: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4rQ6; else goto c4rPX;
       c4rPX: // global
           I64[Hp - 80] = sat_s4kUx_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rPV::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rPV::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rPM: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4rQ2; else goto c4rQ7;
       c4rQ2: // global
           I64[Hp - 80] = sat_s4kUP_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kUB_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rQ7: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4rQ6; else goto c4rQ5;
       c4rQ6: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rQ5: // global
           I64[Hp - 80] = sat_s4kUT_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4rQ3::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4rQ3::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromThenTo_info" {
     GHC.Int.$w$cenumFromThenTo_info:
         const GHC.Int.$w$cenumFromThenTo_entry;
         const 0;
         const 38654705678;
         const 12884901904;
         const S4lDl_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.523782531 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4rRM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rRV; else goto c4rRW;
       c4rRV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rRW: // global
           I64[Sp - 24] = block_c4rRJ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rS5; else goto c4rRK;
       u4rS5: // global
           call _c4rRJ(R1) args: 0, res: 0, upd: 0;
       c4rRK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cenumFromThenTo_info" {
     GHC.Int.$fEnumInt16_$cenumFromThenTo_info:
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S4lDl_srt+216;
 },
 _c4rRJ() //  [R1]
         { []
         }
     {offset
       c4rRJ: // global
           I64[Sp] = block_c4rRP_info;
           _s4kUY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kUY::I64;
           if (R1 & 7 != 0) goto u4rS4; else goto c4rRQ;
       u4rS4: // global
           call _c4rRP(R1) args: 0, res: 0, upd: 0;
       c4rRQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rRJ_info" {
     block_c4rRJ_info:
         const _c4rRJ;
         const 2;
         const 4294967326;
         const S4lDl_srt+216;
 },
 _c4rRP() //  [R1]
         { []
         }
     {offset
       c4rRP: // global
           I64[Sp] = block_c4rRU_info;
           _s4kV0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kV0::I64;
           if (R1 & 7 != 0) goto u4rS6; else goto c4rRZ;
       u4rS6: // global
           call _c4rRU(R1) args: 0, res: 0, upd: 0;
       c4rRZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rRP_info" {
     block_c4rRP_info:
         const _c4rRP;
         const 66;
         const 4294967326;
         const S4lDl_srt+216;
 },
 _c4rRU() //  [R1]
         { []
         }
     {offset
       c4rRU: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rRU_info" {
     block_c4rRU_info:
         const _c4rRU;
         const 194;
         const 4294967326;
         const S4lDl_srt+216;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.535045363 UTC

[section ""data" . GHC.Int.$w$cenumFromTo_closure" {
     GHC.Int.$w$cenumFromTo_closure:
         const GHC.Int.$w$cenumFromTo_info;
         const 0;
 },
 sat_s4kVd_entry() //  [R1]
         { []
         }
     {offset
       c4rSJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rSK; else goto c4rSL;
       c4rSK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rSL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kV7::I64 = I64[R1 + 32];
           if (_s4kV7::I64 == I64[R1 + 24]) goto c4rSI; else goto c4rSH;
       c4rSI: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4rSH: // global
           R2 = _s4kV7::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kV6_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kVd_info" {
     sat_s4kVd_info:
         const sat_s4kVd_entry;
         const 8589934593;
         const 4294967311;
         const S4lDl_srt+192;
 },
 sat_s4kVa_entry() //  [R1]
         { []
         }
     {offset
       c4rSX: // global
           _s4kVa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rSY; else goto c4rSZ;
       c4rSZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rT1; else goto c4rT0;
       c4rT1: // global
           HpAlloc = 16;
           goto c4rSY;
       c4rSY: // global
           R1 = _s4kVa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rT0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kVa::P64;
           _s4kV7::I64 = I64[_s4kVa::P64 + 16];
           if (%MO_S_Lt_W64(_s4kV7::I64,
                            (-32768))) goto c4rT7; else goto c4rSW;
       c4rSW: // global
           if (%MO_S_Gt_W64(_s4kV7::I64, 32767)) goto c4rT7; else goto c4rTb;
       c4rT7: // global
           Hp = Hp - 16;
           R2 = _s4kV7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rTb: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kV7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kVa_info" {
     sat_s4kVa_info:
         const sat_s4kVa_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+192;
 },
 go_s4kV6_entry() //  [R1, R2]
         { []
         }
     {offset
       c4rTd: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4rTh; else goto c4rTg;
       c4rTh: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rTg: // global
           _s4kV4::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kVd_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kV4::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kVa_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s4kV6_info" {
     go_s4kV6_info:
         const go_s4kV6_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S4lDl_srt+192;
 },
 GHC.Int.$w$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rTl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rTp; else goto c4rTo;
       c4rTp: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rTo: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4rTj; else goto c4rTk;
       c4rTj: // global
           I64[Hp - 8] = go_s4kV6_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kV6_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4rTk: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromTo_info" {
     GHC.Int.$w$cenumFromTo_info:
         const GHC.Int.$w$cenumFromTo_entry;
         const 0;
         const 141733920782;
         const 8589934604;
         const S4lDl_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.546310273 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rTS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rTW; else goto c4rTX;
       c4rTW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rTX: // global
           I64[Sp - 16] = block_c4rTP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rU5; else goto c4rTQ;
       u4rU5: // global
           call _c4rTP(R1) args: 0, res: 0, upd: 0;
       c4rTQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cenumFromTo_info" {
     GHC.Int.$fEnumInt16_$cenumFromTo_info:
         const GHC.Int.$fEnumInt16_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+232;
 },
 _c4rTP() //  [R1]
         { []
         }
     {offset
       c4rTP: // global
           I64[Sp] = block_c4rTV_info;
           _s4kVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kVh::I64;
           if (R1 & 7 != 0) goto u4rU4; else goto c4rTZ;
       u4rU4: // global
           call _c4rTV(R1) args: 0, res: 0, upd: 0;
       c4rTZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rTP_info" {
     block_c4rTP_info:
         const _c4rTP;
         const 1;
         const 4294967326;
         const S4lDl_srt+232;
 },
 _c4rTV() //  [R1]
         { []
         }
     {offset
       c4rTV: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rTV_info" {
     block_c4rTV_info:
         const _c4rTV;
         const 65;
         const 4294967326;
         const S4lDl_srt+232;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.555713683 UTC

[section ""data" . GHC.Int.$wgo_closure" {
     GHC.Int.$wgo_closure:
         const GHC.Int.$wgo_info;
         const 0;
 },
 sat_s4kVt_entry() //  [R1]
         { []
         }
     {offset
       c4rUv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rUw; else goto c4rUH;
       c4rUw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rUH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kVo::I64 = I64[R1 + 16];
           if (_s4kVo::I64 != 32767) goto c4rUt; else goto c4rUu;
       c4rUt: // global
           I64[Sp - 24] = block_c4rUB_info;
           R2 = _s4kVo::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c4rUu: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kVt_info" {
     sat_s4kVt_info:
         const sat_s4kVt_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+248;
 },
 _c4rUB() //  [R1, R2]
         { []
         }
     {offset
       c4rUB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rUG; else goto c4rUF;
       c4rUG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4rUF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4rUB_info" {
     block_c4rUB_info:
         const _c4rUB;
         const 0;
         const 30;
 },
 sat_s4kVn_entry() //  [R1]
         { []
         }
     {offset
       c4rUR: // global
           _s4kVn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4rUS; else goto c4rUT;
       c4rUT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rUV; else goto c4rUU;
       c4rUV: // global
           HpAlloc = 16;
           goto c4rUS;
       c4rUS: // global
           R1 = _s4kVn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rUU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kVn::P64;
           _s4kVk::I64 = I64[_s4kVn::P64 + 16];
           if (%MO_S_Lt_W64(_s4kVk::I64,
                            (-32768))) goto c4rV1; else goto c4rUQ;
       c4rUQ: // global
           if (%MO_S_Gt_W64(_s4kVk::I64, 32767)) goto c4rV1; else goto c4rV5;
       c4rV1: // global
           Hp = Hp - 16;
           R2 = _s4kVk::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4rV5: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4kVk::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kVn_info" {
     sat_s4kVn_info:
         const sat_s4kVn_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+192;
 },
 GHC.Int.$wgo_entry() //  [R2]
         { []
         }
     {offset
       c4rV6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4rVa; else goto c4rV9;
       c4rVa: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rV9: // global
           I64[Hp - 40] = sat_s4kVt_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kVn_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wgo_info" {
     GHC.Int.$wgo_info:
         const GHC.Int.$wgo_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const S4lDl_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.566872424 UTC

[section ""data" . GHC.Int.$fEnumInt16_go_closure" {
     GHC.Int.$fEnumInt16_go_closure:
         const GHC.Int.$fEnumInt16_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_go_entry() //  [R2]
         { []
         }
     {offset
       c4rVB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rVC; else goto c4rVD;
       c4rVC: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rVD: // global
           I64[Sp - 8] = block_c4rVy_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_go_info" {
     GHC.Int.$fEnumInt16_go_info:
         const GHC.Int.$fEnumInt16_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S4lDl_srt+248;
 },
 _c4rVy() //  [R1, R2]
         { []
         }
     {offset
       c4rVy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rVG; else goto c4rVF;
       c4rVG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rVF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rVy_info" {
     block_c4rVy_info:
         const _c4rVy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.572998183 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFrom_closure" {
     GHC.Int.$fEnumInt16_$cenumFrom_closure:
         const GHC.Int.$fEnumInt16_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c4rVX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rVY; else goto c4rVZ;
       c4rVY: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rVZ: // global
           I64[Sp - 8] = block_c4rVU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rW8; else goto c4rVV;
       u4rW8: // global
           call _c4rVU(R1) args: 0, res: 0, upd: 0;
       c4rVV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cenumFrom_info" {
     GHC.Int.$fEnumInt16_$cenumFrom_info:
         const GHC.Int.$fEnumInt16_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+256;
 },
 _c4rVU() //  [R1]
         { []
         }
     {offset
       c4rVU: // global
           _s4kVA::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kVA::I64, 32767)) goto c4rW6; else goto c4rW7;
       c4rW6: // global
           R2 = _s4kVA::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_go_entry(R2) args: 8, res: 0, upd: 8;
       c4rW7: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rVU_info" {
     block_c4rVU_info:
         const _c4rVU;
         const 0;
         const 4294967326;
         const S4lDl_srt+256;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.578889908 UTC

[section ""data" . GHC.Int.$fEnumInt16_closure" {
     GHC.Int.$fEnumInt16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt16_$csucc_closure+1;
         const GHC.Int.$fEnumInt16_$cpred_closure+1;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt16_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rWn: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt16_closure+1;
           R2 = GHC.Int.$fEnumInt16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cenumFromThen_info" {
     GHC.Int.$fEnumInt16_$cenumFromThen_info:
         const GHC.Int.$fEnumInt16_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S4lDl_srt+272;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.583471351 UTC

[section ""cstring" . GHC.Int.$tcInt4_bytes" {
     GHC.Int.$tcInt4_bytes:
         I8[] [73,110,116,51,50]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.586134544 UTC

[section ""data" . GHC.Int.$fEnumInt3_closure" {
     GHC.Int.$fEnumInt3_closure:
         const GHC.Int.$fEnumInt3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt3_entry() //  [R1]
         { []
         }
     {offset
       c4rWE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rWF; else goto c4rWG;
       c4rWF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rWG: // global
           (_c4rWz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rWz::I64 == 0) goto c4rWB; else goto c4rWA;
       c4rWB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rWA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rWz::I64;
           I64[Sp - 24] = block_c4rWC_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt3_info" {
     GHC.Int.$fEnumInt3_info:
         const GHC.Int.$fEnumInt3_entry;
         const 0;
         const 4294967317;
         const S4lDl_srt+280;
 },
 _c4rWC() //  [R1]
         { []
         }
     {offset
       c4rWC: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4rWC_info" {
     block_c4rWC_info:
         const _c4rWC;
         const 0;
         const 4294967326;
         const S4lDl_srt+280;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.592153801 UTC

[section ""data" . GHC.Int.$fEnumInt4_closure" {
     GHC.Int.$fEnumInt4_closure:
         const GHC.Int.$fEnumInt4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt4_entry() //  [R1]
         { []
         }
     {offset
       c4rX2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rX3; else goto c4rX4;
       c4rX3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rX4: // global
           (_c4rWX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rWX::I64 == 0) goto c4rWZ; else goto c4rWY;
       c4rWZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rWY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rWX::I64;
           I64[Sp - 24] = block_c4rX0_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt4_info" {
     GHC.Int.$fEnumInt4_info:
         const GHC.Int.$fEnumInt4_entry;
         const 0;
         const 4294967317;
         const S4lDl_srt+288;
 },
 _c4rX0() //  [R1]
         { []
         }
     {offset
       c4rX0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4rX0_info" {
     block_c4rX0_info:
         const _c4rX0;
         const 0;
         const 4294967326;
         const S4lDl_srt+288;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.598512524 UTC

[section ""data" . GHC.Int.neInt32_closure" {
     GHC.Int.neInt32_closure:
         const GHC.Int.neInt32_info;
 },
 GHC.Int.neInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4rXp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rXt; else goto c4rXu;
       c4rXt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rXu: // global
           I64[Sp - 16] = block_c4rXm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4rXD; else goto c4rXn;
       u4rXD: // global
           call _c4rXm(R1) args: 0, res: 0, upd: 0;
       c4rXn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.neInt32_info" {
     GHC.Int.neInt32_info:
         const GHC.Int.neInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4rXm() //  [R1]
         { []
         }
     {offset
       c4rXm: // global
           I64[Sp] = block_c4rXs_info;
           _s4kVH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kVH::I64;
           if (R1 & 7 != 0) goto u4rXC; else goto c4rXw;
       u4rXC: // global
           call _c4rXs(R1) args: 0, res: 0, upd: 0;
       c4rXw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rXm_info" {
     block_c4rXm_info:
         const _c4rXm;
         const 1;
         const 30;
 },
 _c4rXs() //  [R1]
         { []
         }
     {offset
       c4rXs: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rXs_info" {
     block_c4rXs_info:
         const _c4rXs;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.608584727 UTC

[section ""data" . lvl4_r4kPv_closure" {
     lvl4_r4kPv_closure:
         const lvl4_r4kPv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r4kPv_entry() //  [R1]
         { []
         }
     {offset
       c4rY1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4rY2; else goto c4rY3;
       c4rY2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4rY3: // global
           (_c4rXY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4rXY::I64 == 0) goto c4rY0; else goto c4rXZ;
       c4rY0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4rXZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4rXY::I64;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl4_r4kPv_info" {
     lvl4_r4kPv_info:
         const lvl4_r4kPv_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.614220141 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cminBound_closure" {
     GHC.Int.$fBoundedInt32_$cminBound_closure:
         const GHC.Int.I32#_con_info;
         const (-2147483648);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.618732894 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cpred_closure" {
     GHC.Int.$fEnumInt32_$cpred_closure:
         const GHC.Int.$fEnumInt32_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c4rYj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rYk; else goto c4rYl;
       c4rYk: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rYl: // global
           I64[Sp - 8] = block_c4rYg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rYD; else goto c4rYh;
       u4rYD: // global
           call _c4rYg(R1) args: 0, res: 0, upd: 0;
       c4rYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cpred_info" {
     GHC.Int.$fEnumInt32_$cpred_info:
         const GHC.Int.$fEnumInt32_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+296;
 },
 _c4rYg() //  [R1]
         { []
         }
     {offset
       c4rYg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rYq; else goto c4rYp;
       c4rYq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rYp: // global
           _s4kVO::I64 = I64[R1 + 7];
           if (_s4kVO::I64 != (-2147483648)) goto c4rYB; else goto c4rYC;
       c4rYB: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4kVO::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rYC: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rYg_info" {
     block_c4rYg_info:
         const _c4rYg;
         const 0;
         const 4294967326;
         const S4lDl_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.627620562 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt32_$cmaxBound_closure:
         const GHC.Int.I32#_con_info;
         const 2147483647;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.631306641 UTC

[section ""data" . GHC.Int.$fBoundedInt32_closure" {
     GHC.Int.$fBoundedInt32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt32_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.636094082 UTC

[section ""data" . GHC.Int.$fEnumInt32_$csucc_closure" {
     GHC.Int.$fEnumInt32_$csucc_closure:
         const GHC.Int.$fEnumInt32_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c4rZ0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4rZ1; else goto c4rZ2;
       c4rZ1: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4rZ2: // global
           I64[Sp - 8] = block_c4rYX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4rZk; else goto c4rYY;
       u4rZk: // global
           call _c4rYX(R1) args: 0, res: 0, upd: 0;
       c4rYY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$csucc_info" {
     GHC.Int.$fEnumInt32_$csucc_info:
         const GHC.Int.$fEnumInt32_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+312;
 },
 _c4rYX() //  [R1]
         { []
         }
     {offset
       c4rYX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4rZ7; else goto c4rZ6;
       c4rZ7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4rZ6: // global
           _s4kVU::I64 = I64[R1 + 7];
           if (_s4kVU::I64 != 2147483647) goto c4rZi; else goto c4rZj;
       c4rZi: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4kVU::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4rZj: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rYX_info" {
     block_c4rYX_info:
         const _c4rYX;
         const 0;
         const 4294967326;
         const S4lDl_srt+320;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.646615116 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowsPrec_closure" {
     GHC.Int.$fShowInt32_$cshowsPrec_closure:
         const GHC.Int.$fShowInt32_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt32_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4rZF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4rZQ; else goto c4rZR;
       c4rZQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4rZR: // global
           I64[Sp - 24] = block_c4rZC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4rZY; else goto c4rZD;
       u4rZY: // global
           call _c4rZC(R1) args: 0, res: 0, upd: 0;
       c4rZD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt32_$cshowsPrec_info" {
     GHC.Int.$fShowInt32_$cshowsPrec_info:
         const GHC.Int.$fShowInt32_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c4rZC() //  [R1]
         { []
         }
     {offset
       c4rZC: // global
           I64[Sp] = block_c4rZI_info;
           _s4kW1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kW1::I64;
           if (R1 & 7 != 0) goto u4rZX; else goto c4rZJ;
       u4rZX: // global
           call _c4rZI(R1) args: 0, res: 0, upd: 0;
       c4rZJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rZC_info" {
     block_c4rZC_info:
         const _c4rZC;
         const 2;
         const 30;
 },
 _c4rZI() //  [R1]
         { []
         }
     {offset
       c4rZI: // global
           _s4kVZ::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4rZN_info;
           R4 = _s4kVZ::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rZI_info" {
     block_c4rZI_info:
         const _c4rZI;
         const 66;
         const 30;
 },
 _c4rZN() //  [R1, R2]
         { []
         }
     {offset
       c4rZN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4rZW; else goto c4rZV;
       c4rZW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4rZV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4rZN_info" {
     block_c4rZN_info:
         const _c4rZN;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.656554822 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshow_closure" {
     GHC.Int.$fShowInt32_$cshow_closure:
         const GHC.Int.$fShowInt32_$cshow_info;
 },
 GHC.Int.$fShowInt32_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c4s0n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4s0t; else goto c4s0u;
       c4s0t: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s0u: // global
           I64[Sp - 8] = block_c4s0k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4s0z; else goto c4s0l;
       u4s0z: // global
           call _c4s0k(R1) args: 0, res: 0, upd: 0;
       c4s0l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt32_$cshow_info" {
     GHC.Int.$fShowInt32_$cshow_info:
         const GHC.Int.$fShowInt32_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4s0k() //  [R1]
         { []
         }
     {offset
       c4s0k: // global
           I64[Sp] = block_c4s0q_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4s0k_info" {
     block_c4s0k_info:
         const _c4s0k;
         const 0;
         const 30;
 },
 _c4s0q() //  [R1, R2]
         { []
         }
     {offset
       c4s0q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4s0y; else goto c4s0x;
       c4s0y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4s0x: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4s0q_info" {
     block_c4s0q_info:
         const _c4s0q;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.664461592 UTC

[section ""data" . GHC.Int.$fShowInt2_closure" {
     GHC.Int.$fShowInt2_closure:
         const GHC.Int.$fShowInt2_info;
 },
 GHC.Int.$fShowInt2_entry() //  [R2, R3]
         { []
         }
     {offset
       c4s0U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4s10; else goto c4s11;
       c4s10: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4s11: // global
           I64[Sp - 16] = block_c4s0R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4s16; else goto c4s0S;
       u4s16: // global
           call _c4s0R(R1) args: 0, res: 0, upd: 0;
       c4s0S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt2_info" {
     GHC.Int.$fShowInt2_info:
         const GHC.Int.$fShowInt2_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4s0R() //  [R1]
         { []
         }
     {offset
       c4s0R: // global
           _s4kWe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4s0X_info;
           R4 = _s4kWe::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4s0R_info" {
     block_c4s0R_info:
         const _c4s0R;
         const 1;
         const 30;
 },
 _c4s0X() //  [R1, R2]
         { []
         }
     {offset
       c4s0X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4s15; else goto c4s14;
       c4s15: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4s14: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4s0X_info" {
     block_c4s0X_info:
         const _c4s0X;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.671858392 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowList_closure" {
     GHC.Int.$fShowInt32_$cshowList_closure:
         const GHC.Int.$fShowInt32_$cshowList_info;
 },
 GHC.Int.$fShowInt32_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c4s1o: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt32_$cshowList_info" {
     GHC.Int.$fShowInt32_$cshowList_info:
         const GHC.Int.$fShowInt32_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.675724875 UTC

[section ""data" . GHC.Int.$fShowInt32_closure" {
     GHC.Int.$fShowInt32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt32_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt32_$cshow_closure+1;
         const GHC.Int.$fShowInt32_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.678898962 UTC

[section ""data" . GHC.Int.$wlvl1_closure" {
     GHC.Int.$wlvl1_closure:
         const GHC.Int.$wlvl1_info;
         const 0;
 },
 GHC.Int.$wlvl1_entry() //  [R2]
         { []
         }
     {offset
       c4s1A: // global
           R6 = GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r4kPv_closure;
           R2 = GHC.Int.$fShowInt32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wlvl1_info" {
     GHC.Int.$wlvl1_info:
         const GHC.Int.$wlvl1_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S4lDl_srt+328;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.683009391 UTC

[section ""data" . GHC.Int.$w$ctoEnum1_closure" {
     GHC.Int.$w$ctoEnum1_closure:
         const GHC.Int.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum1_entry() //  [R2]
         { []
         }
     {offset
       c4s1Q: // global
           _s4kWn::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-2147483648))) goto c4s1Y; else goto c4s1P;
       c4s1P: // global
           if (%MO_S_Gt_W64(_s4kWn::I64,
                            2147483647)) goto c4s1Y; else goto c4s1Z;
       c4s1Y: // global
           R2 = _s4kWn::I64;
           call GHC.Int.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c4s1Z: // global
           R1 = _s4kWn::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$ctoEnum1_info" {
     GHC.Int.$w$ctoEnum1_info:
         const GHC.Int.$w$ctoEnum1_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S4lDl_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.68843855 UTC

[section ""data" . GHC.Int.$fEnumInt32_$ctoEnum_closure" {
     GHC.Int.$fEnumInt32_$ctoEnum_closure:
         const GHC.Int.$fEnumInt32_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c4s2c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4s2k; else goto c4s2l;
       c4s2k: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s2l: // global
           I64[Sp - 8] = block_c4s29_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4s2q; else goto c4s2a;
       u4s2q: // global
           call _c4s29(R1) args: 0, res: 0, upd: 0;
       c4s2a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$ctoEnum_info" {
     GHC.Int.$fEnumInt32_$ctoEnum_info:
         const GHC.Int.$fEnumInt32_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+352;
 },
 _c4s29() //  [R1]
         { []
         }
     {offset
       c4s29: // global
           I64[Sp] = block_c4s2f_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4s29_info" {
     block_c4s29_info:
         const _c4s29;
         const 0;
         const 4294967326;
         const S4lDl_srt+360;
 },
 _c4s2f() //  [R1]
         { []
         }
     {offset
       c4s2f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s2p; else goto c4s2o;
       c4s2p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4s2o: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4s2f_info" {
     block_c4s2f_info:
         const _c4s2f;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.698837033 UTC

[section ""data" . GHC.Int.$w$cenumFromTo1_closure" {
     GHC.Int.$w$cenumFromTo1_closure:
         const GHC.Int.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s4kWG_entry() //  [R1]
         { []
         }
     {offset
       c4s2Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4s30; else goto c4s31;
       c4s30: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s31: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kWA::I64 = I64[R1 + 32];
           if (_s4kWA::I64 == I64[R1 + 24]) goto c4s2Y; else goto c4s2X;
       c4s2Y: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4s2X: // global
           R2 = _s4kWA::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4kWz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kWG_info" {
     sat_s4kWG_info:
         const sat_s4kWG_entry;
         const 8589934593;
         const 4294967311;
         const S4lDl_srt+344;
 },
 sat_s4kWD_entry() //  [R1]
         { []
         }
     {offset
       c4s3d: // global
           _s4kWD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s3e; else goto c4s3f;
       c4s3f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s3h; else goto c4s3g;
       c4s3h: // global
           HpAlloc = 16;
           goto c4s3e;
       c4s3e: // global
           R1 = _s4kWD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s3g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kWD::P64;
           _s4kWA::I64 = I64[_s4kWD::P64 + 16];
           if (%MO_S_Lt_W64(_s4kWA::I64,
                            (-2147483648))) goto c4s3n; else goto c4s3c;
       c4s3c: // global
           if (%MO_S_Gt_W64(_s4kWA::I64,
                            2147483647)) goto c4s3n; else goto c4s3r;
       c4s3n: // global
           Hp = Hp - 16;
           R2 = _s4kWA::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s3r: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kWA::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kWD_info" {
     sat_s4kWD_info:
         const sat_s4kWD_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+344;
 },
 go_s4kWz_entry() //  [R1, R2]
         { []
         }
     {offset
       c4s3t: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4s3x; else goto c4s3w;
       c4s3x: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s3w: // global
           _s4kWx::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kWG_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kWx::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kWD_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s4kWz_info" {
     go_s4kWz_info:
         const go_s4kWz_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S4lDl_srt+344;
 },
 GHC.Int.$w$cenumFromTo1_entry() //  [R2, R3]
         { []
         }
     {offset
       c4s3B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s3F; else goto c4s3E;
       c4s3F: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4s3E: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4s3z; else goto c4s3A;
       c4s3z: // global
           I64[Hp - 8] = go_s4kWz_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4kWz_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4s3A: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromTo1_info" {
     GHC.Int.$w$cenumFromTo1_info:
         const GHC.Int.$w$cenumFromTo1_entry;
         const 0;
         const 38654705678;
         const 8589934604;
         const S4lDl_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.709701329 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c4s48: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4s4c; else goto c4s4d;
       c4s4c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4s4d: // global
           I64[Sp - 16] = block_c4s45_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4s4l; else goto c4s46;
       u4s4l: // global
           call _c4s45(R1) args: 0, res: 0, upd: 0;
       c4s46: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cenumFromTo_info" {
     GHC.Int.$fEnumInt32_$cenumFromTo_info:
         const GHC.Int.$fEnumInt32_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+368;
 },
 _c4s45() //  [R1]
         { []
         }
     {offset
       c4s45: // global
           I64[Sp] = block_c4s4b_info;
           _s4kWK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kWK::I64;
           if (R1 & 7 != 0) goto u4s4k; else goto c4s4f;
       u4s4k: // global
           call _c4s4b(R1) args: 0, res: 0, upd: 0;
       c4s4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4s45_info" {
     block_c4s45_info:
         const _c4s45;
         const 1;
         const 4294967326;
         const S4lDl_srt+368;
 },
 _c4s4b() //  [R1]
         { []
         }
     {offset
       c4s4b: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4s4b_info" {
     block_c4s4b_info:
         const _c4s4b;
         const 65;
         const 4294967326;
         const S4lDl_srt+368;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.720037918 UTC

[section ""data" . GHC.Int.$wgo1_closure" {
     GHC.Int.$wgo1_closure:
         const GHC.Int.$wgo1_info;
         const 0;
 },
 sat_s4kWW_entry() //  [R1]
         { []
         }
     {offset
       c4s4L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4s4M; else goto c4s4X;
       c4s4M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s4X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kWR::I64 = I64[R1 + 16];
           if (_s4kWR::I64 != 2147483647) goto c4s4J; else goto c4s4K;
       c4s4J: // global
           I64[Sp - 24] = block_c4s4R_info;
           R2 = _s4kWR::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c4s4K: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kWW_info" {
     sat_s4kWW_info:
         const sat_s4kWW_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+384;
 },
 _c4s4R() //  [R1, R2]
         { []
         }
     {offset
       c4s4R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4s4W; else goto c4s4V;
       c4s4W: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4s4V: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4s4R_info" {
     block_c4s4R_info:
         const _c4s4R;
         const 0;
         const 30;
 },
 sat_s4kWQ_entry() //  [R1]
         { []
         }
     {offset
       c4s57: // global
           _s4kWQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s58; else goto c4s59;
       c4s59: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s5b; else goto c4s5a;
       c4s5b: // global
           HpAlloc = 16;
           goto c4s58;
       c4s58: // global
           R1 = _s4kWQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s5a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kWQ::P64;
           _s4kWN::I64 = I64[_s4kWQ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kWN::I64,
                            (-2147483648))) goto c4s5h; else goto c4s56;
       c4s56: // global
           if (%MO_S_Gt_W64(_s4kWN::I64,
                            2147483647)) goto c4s5h; else goto c4s5l;
       c4s5h: // global
           Hp = Hp - 16;
           R2 = _s4kWN::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s5l: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kWN::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kWQ_info" {
     sat_s4kWQ_info:
         const sat_s4kWQ_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+344;
 },
 GHC.Int.$wgo1_entry() //  [R2]
         { []
         }
     {offset
       c4s5m: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4s5q; else goto c4s5p;
       c4s5q: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s5p: // global
           I64[Hp - 40] = sat_s4kWW_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4kWQ_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wgo1_info" {
     GHC.Int.$wgo1_info:
         const GHC.Int.$wgo1_entry;
         const 0;
         const 141733920782;
         const 4294967300;
         const S4lDl_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.730887799 UTC

[section ""data" . GHC.Int.$fEnumInt32_go_closure" {
     GHC.Int.$fEnumInt32_go_closure:
         const GHC.Int.$fEnumInt32_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_go_entry() //  [R2]
         { []
         }
     {offset
       c4s5R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4s5S; else goto c4s5T;
       c4s5S: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s5T: // global
           I64[Sp - 8] = block_c4s5O_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_go_info" {
     GHC.Int.$fEnumInt32_go_info:
         const GHC.Int.$fEnumInt32_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S4lDl_srt+384;
 },
 _c4s5O() //  [R1, R2]
         { []
         }
     {offset
       c4s5O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4s5W; else goto c4s5V;
       c4s5W: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4s5V: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4s5O_info" {
     block_c4s5O_info:
         const _c4s5O;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.739580008 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFrom_closure" {
     GHC.Int.$fEnumInt32_$cenumFrom_closure:
         const GHC.Int.$fEnumInt32_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c4s6d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4s6e; else goto c4s6f;
       c4s6e: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s6f: // global
           I64[Sp - 8] = block_c4s6a_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4s6o; else goto c4s6b;
       u4s6o: // global
           call _c4s6a(R1) args: 0, res: 0, upd: 0;
       c4s6b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cenumFrom_info" {
     GHC.Int.$fEnumInt32_$cenumFrom_info:
         const GHC.Int.$fEnumInt32_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+392;
 },
 _c4s6a() //  [R1]
         { []
         }
     {offset
       c4s6a: // global
           _s4kX3::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4kX3::I64,
                            2147483647)) goto c4s6m; else goto c4s6n;
       c4s6m: // global
           R2 = _s4kX3::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_go_entry(R2) args: 8, res: 0, upd: 8;
       c4s6n: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4s6a_info" {
     block_c4s6a_info:
         const _c4s6a;
         const 0;
         const 4294967326;
         const S4lDl_srt+392;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.756754968 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo1_closure" {
     GHC.Int.$w$cenumFromThenTo1_closure:
         const GHC.Int.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s4kXm_entry() //  [R1]
         { []
         }
     {offset
       c4s77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4s78; else goto c4s79;
       c4s78: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s79: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4kXf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXm_info" {
     sat_s4kXm_info:
         const sat_s4kXm_entry;
         const 8589934593;
         const 4294967311;
         const S4lDl_srt+344;
 },
 sat_s4kXk_entry() //  [R1]
         { []
         }
     {offset
       c4s7j: // global
           _s4kXk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s7k; else goto c4s7l;
       c4s7l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s7n; else goto c4s7m;
       c4s7n: // global
           HpAlloc = 16;
           goto c4s7k;
       c4s7k: // global
           R1 = _s4kXk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s7m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXk::P64;
           _s4kXg::I64 = I64[_s4kXk::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXg::I64,
                            (-2147483648))) goto c4s7t; else goto c4s7i;
       c4s7i: // global
           if (%MO_S_Gt_W64(_s4kXg::I64,
                            2147483647)) goto c4s7t; else goto c4s7x;
       c4s7t: // global
           Hp = Hp - 16;
           R2 = _s4kXg::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s7x: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXg::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXk_info" {
     sat_s4kXk_info:
         const sat_s4kXk_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+344;
 },
 sat_s4kXp_entry() //  [R1]
         { []
         }
     {offset
       c4s7I: // global
           _s4kXp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s7J; else goto c4s7K;
       c4s7K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s7M; else goto c4s7L;
       c4s7M: // global
           HpAlloc = 16;
           goto c4s7J;
       c4s7J: // global
           R1 = _s4kXp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s7L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXp::P64;
           _s4kXg::I64 = I64[_s4kXp::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXg::I64,
                            (-2147483648))) goto c4s7S; else goto c4s7H;
       c4s7H: // global
           if (%MO_S_Gt_W64(_s4kXg::I64,
                            2147483647)) goto c4s7S; else goto c4s7W;
       c4s7S: // global
           Hp = Hp - 16;
           R2 = _s4kXg::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s7W: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXg::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXp_info" {
     sat_s4kXp_info:
         const sat_s4kXp_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+344;
 },
 go_dn_s4kXf_entry() //  [R1, R2]
         { []
         }
     {offset
       c4s80: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4s84; else goto c4s83;
       c4s84: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4s83: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4s7Y; else goto c4s7Z;
       c4s7Y: // global
           _s4kXd::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kXm_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kXd::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kXk_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4s7Z: // global
           I64[Hp - 80] = sat_s4kXp_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4s86::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4s86::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s4kXf_info" {
     go_dn_s4kXf_info:
         const go_dn_s4kXf_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4lDl_srt+344;
 },
 sat_s4kXq_entry() //  [R1]
         { []
         }
     {offset
       c4s87: // global
           _s4kXq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s88; else goto c4s89;
       c4s89: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4s8b; else goto c4s8a;
       c4s8b: // global
           HpAlloc = 24;
           goto c4s88;
       c4s88: // global
           R1 = _s4kXq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s8a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXq::P64;
           _s4kX6::I64 = I64[_s4kXq::P64 + 24];
           _s4kXd::I64 = _s4kX6::I64 - I64[_s4kXq::P64 + 16];
           _s4kXe::I64 = I64[_s4kXq::P64 + 32] - _s4kXd::I64;
           I64[Hp - 16] = go_dn_s4kXf_info;
           I64[Hp - 8] = _s4kXd::I64;
           I64[Hp] = _s4kXe::I64;
           R2 = _s4kX6::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4kXf_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXq_info" {
     sat_s4kXq_info:
         const sat_s4kXq_entry;
         const 12884901888;
         const 4294967311;
         const S4lDl_srt+344;
 },
 sat_s4kXc_entry() //  [R1]
         { []
         }
     {offset
       c4s8l: // global
           _s4kXc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s8m; else goto c4s8n;
       c4s8n: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s8p; else goto c4s8o;
       c4s8p: // global
           HpAlloc = 16;
           goto c4s8m;
       c4s8m: // global
           R1 = _s4kXc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s8o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXc::P64;
           _s4kX5::I64 = I64[_s4kXc::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4s8v; else goto c4s8k;
       c4s8k: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4s8v; else goto c4s8z;
       c4s8v: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s8z: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXc_info" {
     sat_s4kXc_info:
         const sat_s4kXc_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+344;
 },
 sat_s4kXu_entry() //  [R1]
         { []
         }
     {offset
       c4s8N: // global
           _s4kXu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s8O; else goto c4s8P;
       c4s8P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s8R; else goto c4s8Q;
       c4s8R: // global
           HpAlloc = 16;
           goto c4s8O;
       c4s8O: // global
           R1 = _s4kXu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s8Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXu::P64;
           _s4kX5::I64 = I64[_s4kXu::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4s8X; else goto c4s8M;
       c4s8M: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4s8X; else goto c4s91;
       c4s8X: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s91: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXu_info" {
     sat_s4kXu_info:
         const sat_s4kXu_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+344;
 },
 sat_s4kXI_entry() //  [R1]
         { []
         }
     {offset
       c4s9u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4s9v; else goto c4s9w;
       c4s9v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s9w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4kXB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXI_info" {
     sat_s4kXI_info:
         const sat_s4kXI_entry;
         const 8589934593;
         const 4294967311;
         const S4lDl_srt+344;
 },
 sat_s4kXG_entry() //  [R1]
         { []
         }
     {offset
       c4s9G: // global
           _s4kXG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4s9H; else goto c4s9I;
       c4s9I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4s9K; else goto c4s9J;
       c4s9K: // global
           HpAlloc = 16;
           goto c4s9H;
       c4s9H: // global
           R1 = _s4kXG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4s9J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXG::P64;
           _s4kXC::I64 = I64[_s4kXG::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXC::I64,
                            (-2147483648))) goto c4s9Q; else goto c4s9F;
       c4s9F: // global
           if (%MO_S_Gt_W64(_s4kXC::I64,
                            2147483647)) goto c4s9Q; else goto c4s9U;
       c4s9Q: // global
           Hp = Hp - 16;
           R2 = _s4kXC::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4s9U: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXG_info" {
     sat_s4kXG_info:
         const sat_s4kXG_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+344;
 },
 sat_s4kXL_entry() //  [R1]
         { []
         }
     {offset
       c4sa5: // global
           _s4kXL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4sa6; else goto c4sa7;
       c4sa7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sa9; else goto c4sa8;
       c4sa9: // global
           HpAlloc = 16;
           goto c4sa6;
       c4sa6: // global
           R1 = _s4kXL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4sa8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXL::P64;
           _s4kXC::I64 = I64[_s4kXL::P64 + 16];
           if (%MO_S_Lt_W64(_s4kXC::I64,
                            (-2147483648))) goto c4saf; else goto c4sa4;
       c4sa4: // global
           if (%MO_S_Gt_W64(_s4kXC::I64,
                            2147483647)) goto c4saf; else goto c4saj;
       c4saf: // global
           Hp = Hp - 16;
           R2 = _s4kXC::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4saj: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kXC::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXL_info" {
     sat_s4kXL_info:
         const sat_s4kXL_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+344;
 },
 go_up_s4kXB_entry() //  [R1, R2]
         { []
         }
     {offset
       c4san: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4sar; else goto c4saq;
       c4sar: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4saq: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4sal; else goto c4sam;
       c4sal: // global
           _s4kXz::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4kXI_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4kXz::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4kXG_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sam: // global
           I64[Hp - 80] = sat_s4kXL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4sat::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4sat::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s4kXB_info" {
     go_up_s4kXB_info:
         const go_up_s4kXB_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4lDl_srt+344;
 },
 sat_s4kXM_entry() //  [R1]
         { []
         }
     {offset
       c4sau: // global
           _s4kXM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4sav; else goto c4saw;
       c4saw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4say; else goto c4sax;
       c4say: // global
           HpAlloc = 24;
           goto c4sav;
       c4sav: // global
           R1 = _s4kXM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4sax: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXM::P64;
           _s4kX6::I64 = I64[_s4kXM::P64 + 24];
           _s4kXz::I64 = _s4kX6::I64 - I64[_s4kXM::P64 + 16];
           _s4kXA::I64 = I64[_s4kXM::P64 + 32] - _s4kXz::I64;
           I64[Hp - 16] = go_up_s4kXB_info;
           I64[Hp - 8] = _s4kXz::I64;
           I64[Hp] = _s4kXA::I64;
           R2 = _s4kX6::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4kXB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXM_info" {
     sat_s4kXM_info:
         const sat_s4kXM_entry;
         const 12884901888;
         const 4294967311;
         const S4lDl_srt+344;
 },
 sat_s4kXy_entry() //  [R1]
         { []
         }
     {offset
       c4saI: // global
           _s4kXy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4saJ; else goto c4saK;
       c4saK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4saM; else goto c4saL;
       c4saM: // global
           HpAlloc = 16;
           goto c4saJ;
       c4saJ: // global
           R1 = _s4kXy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4saL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXy::P64;
           _s4kX5::I64 = I64[_s4kXy::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4saS; else goto c4saH;
       c4saH: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4saS; else goto c4saW;
       c4saS: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4saW: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXy_info" {
     sat_s4kXy_info:
         const sat_s4kXy_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+344;
 },
 sat_s4kXQ_entry() //  [R1]
         { []
         }
     {offset
       c4sba: // global
           _s4kXQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4sbb; else goto c4sbc;
       c4sbc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sbe; else goto c4sbd;
       c4sbe: // global
           HpAlloc = 16;
           goto c4sbb;
       c4sbb: // global
           R1 = _s4kXQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4sbd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4kXQ::P64;
           _s4kX5::I64 = I64[_s4kXQ::P64 + 16];
           if (%MO_S_Lt_W64(_s4kX5::I64,
                            (-2147483648))) goto c4sbk; else goto c4sb9;
       c4sb9: // global
           if (%MO_S_Gt_W64(_s4kX5::I64,
                            2147483647)) goto c4sbk; else goto c4sbo;
       c4sbk: // global
           Hp = Hp - 16;
           R2 = _s4kX5::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4sbo: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4kX5::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kXQ_info" {
     sat_s4kXQ_info:
         const sat_s4kXQ_entry;
         const 4294967296;
         const 4294967313;
         const S4lDl_srt+344;
 },
 GHC.Int.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4sbs: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4sbw; else goto c4sbv;
       c4sbw: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sbv: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4sbq; else goto c4sbr;
       c4sbq: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4sbz; else goto c4sbE;
       c4sbz: // global
           I64[Hp - 80] = sat_s4kXq_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kXc_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sbE: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4sbL; else goto c4sbC;
       c4sbC: // global
           I64[Hp - 80] = sat_s4kXu_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4sbA::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4sbA::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sbr: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4sbH; else goto c4sbM;
       c4sbH: // global
           I64[Hp - 80] = sat_s4kXM_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4kXy_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sbM: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4sbL; else goto c4sbK;
       c4sbL: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sbK: // global
           I64[Hp - 80] = sat_s4kXQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4sbI::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4sbI::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromThenTo1_info" {
     GHC.Int.$w$cenumFromThenTo1_info:
         const GHC.Int.$w$cenumFromThenTo1_entry;
         const 0;
         const 1103806595086;
         const 12884901904;
         const S4lDl_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.796370246 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4sdr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sdA; else goto c4sdB;
       c4sdA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sdB: // global
           I64[Sp - 24] = block_c4sdo_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4sdK; else goto c4sdp;
       u4sdK: // global
           call _c4sdo(R1) args: 0, res: 0, upd: 0;
       c4sdp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cenumFromThenTo_info" {
     GHC.Int.$fEnumInt32_$cenumFromThenTo_info:
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S4lDl_srt+408;
 },
 _c4sdo() //  [R1]
         { []
         }
     {offset
       c4sdo: // global
           I64[Sp] = block_c4sdu_info;
           _s4kXV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kXV::I64;
           if (R1 & 7 != 0) goto u4sdJ; else goto c4sdv;
       u4sdJ: // global
           call _c4sdu(R1) args: 0, res: 0, upd: 0;
       c4sdv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sdo_info" {
     block_c4sdo_info:
         const _c4sdo;
         const 2;
         const 4294967326;
         const S4lDl_srt+408;
 },
 _c4sdu() //  [R1]
         { []
         }
     {offset
       c4sdu: // global
           I64[Sp] = block_c4sdz_info;
           _s4kXX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4kXX::I64;
           if (R1 & 7 != 0) goto u4sdL; else goto c4sdE;
       u4sdL: // global
           call _c4sdz(R1) args: 0, res: 0, upd: 0;
       c4sdE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sdu_info" {
     block_c4sdu_info:
         const _c4sdu;
         const 66;
         const 4294967326;
         const S4lDl_srt+408;
 },
 _c4sdz() //  [R1]
         { []
         }
     {offset
       c4sdz: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sdz_info" {
     block_c4sdz_info:
         const _c4sdz;
         const 194;
         const 4294967326;
         const S4lDl_srt+408;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.805792174 UTC

[section ""data" . GHC.Int.$fEnumInt32_closure" {
     GHC.Int.$fEnumInt32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt32_$csucc_closure+1;
         const GHC.Int.$fEnumInt32_$cpred_closure+1;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt32_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c4se7: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt32_closure+1;
           R2 = GHC.Int.$fEnumInt32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cenumFromThen_info" {
     GHC.Int.$fEnumInt32_$cenumFromThen_info:
         const GHC.Int.$fEnumInt32_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S4lDl_srt+424;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.809869949 UTC

[section ""cstring" . GHC.Int.$tcInt6_bytes" {
     GHC.Int.$tcInt6_bytes:
         I8[] [73,110,116,54,52]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.812530576 UTC

[section ""data" . GHC.Int.$fEnumInt5_closure" {
     GHC.Int.$fEnumInt5_closure:
         const GHC.Int.$fEnumInt5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt5_entry() //  [R1]
         { []
         }
     {offset
       c4seo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sep; else goto c4seq;
       c4sep: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4seq: // global
           (_c4sej::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4sej::I64 == 0) goto c4sel; else goto c4sek;
       c4sel: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4sek: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4sej::I64;
           I64[Sp - 24] = block_c4sem_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt5_info" {
     GHC.Int.$fEnumInt5_info:
         const GHC.Int.$fEnumInt5_entry;
         const 0;
         const 4294967317;
         const S4lDl_srt+280;
 },
 _c4sem() //  [R1]
         { []
         }
     {offset
       c4sem: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4sem_info" {
     block_c4sem_info:
         const _c4sem;
         const 0;
         const 4294967326;
         const S4lDl_srt+280;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.819805324 UTC

[section ""data" . GHC.Int.$fEnumInt6_closure" {
     GHC.Int.$fEnumInt6_closure:
         const GHC.Int.$fEnumInt6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt6_entry() //  [R1]
         { []
         }
     {offset
       c4seM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4seN; else goto c4seO;
       c4seN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4seO: // global
           (_c4seH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4seH::I64 == 0) goto c4seJ; else goto c4seI;
       c4seJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4seI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4seH::I64;
           I64[Sp - 24] = block_c4seK_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt6_info" {
     GHC.Int.$fEnumInt6_info:
         const GHC.Int.$fEnumInt6_entry;
         const 0;
         const 4294967317;
         const S4lDl_srt+288;
 },
 _c4seK() //  [R1]
         { []
         }
     {offset
       c4seK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4seK_info" {
     block_c4seK_info:
         const _c4seK;
         const 0;
         const 4294967326;
         const S4lDl_srt+288;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.826157311 UTC

[section ""data" . GHC.Int.neInt64_closure" {
     GHC.Int.neInt64_closure:
         const GHC.Int.neInt64_info;
 },
 GHC.Int.neInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sf9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sfd; else goto c4sfe;
       c4sfd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sfe: // global
           I64[Sp - 16] = block_c4sf6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sfn; else goto c4sf7;
       u4sfn: // global
           call _c4sf6(R1) args: 0, res: 0, upd: 0;
       c4sf7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.neInt64_info" {
     GHC.Int.neInt64_info:
         const GHC.Int.neInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sf6() //  [R1]
         { []
         }
     {offset
       c4sf6: // global
           I64[Sp] = block_c4sfc_info;
           _s4kY5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kY5::I64;
           if (R1 & 7 != 0) goto u4sfm; else goto c4sfg;
       u4sfm: // global
           call _c4sfc(R1) args: 0, res: 0, upd: 0;
       c4sfg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sf6_info" {
     block_c4sf6_info:
         const _c4sf6;
         const 1;
         const 30;
 },
 _c4sfc() //  [R1]
         { []
         }
     {offset
       c4sfc: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sfc_info" {
     block_c4sfc_info:
         const _c4sfc;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.832796002 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cminBound_closure" {
     GHC.Int.$fBoundedInt64_$cminBound_closure:
         const GHC.Int.I64#_con_info;
         const (-9223372036854775808);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.836355791 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cpred_closure" {
     GHC.Int.$fEnumInt64_$cpred_closure:
         const GHC.Int.$fEnumInt64_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c4sfN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sfO; else goto c4sfP;
       c4sfO: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sfP: // global
           I64[Sp - 8] = block_c4sfK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sg4; else goto c4sfL;
       u4sg4: // global
           call _c4sfK(R1) args: 0, res: 0, upd: 0;
       c4sfL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cpred_info" {
     GHC.Int.$fEnumInt64_$cpred_info:
         const GHC.Int.$fEnumInt64_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+432;
 },
 _c4sfK() //  [R1]
         { []
         }
     {offset
       c4sfK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sfU; else goto c4sfT;
       c4sfU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sfT: // global
           _s4kYc::I64 = I64[R1 + 7];
           if (_s4kYc::I64 != (-9223372036854775808)) goto c4sg2; else goto c4sg3;
       c4sg2: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kYc::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sg3: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sfK_info" {
     block_c4sfK_info:
         const _c4sfK;
         const 0;
         const 4294967326;
         const S4lDl_srt+440;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.842292618 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt64_$cmaxBound_closure:
         const GHC.Int.I64#_con_info;
         const 9223372036854775807;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.844051174 UTC

[section ""data" . GHC.Int.$fBoundedInt64_closure" {
     GHC.Int.$fBoundedInt64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt64_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.847051077 UTC

[section ""data" . GHC.Int.$fEnumInt64_$csucc_closure" {
     GHC.Int.$fEnumInt64_$csucc_closure:
         const GHC.Int.$fEnumInt64_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c4sgr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sgs; else goto c4sgt;
       c4sgs: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sgt: // global
           I64[Sp - 8] = block_c4sgo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sgI; else goto c4sgp;
       u4sgI: // global
           call _c4sgo(R1) args: 0, res: 0, upd: 0;
       c4sgp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$csucc_info" {
     GHC.Int.$fEnumInt64_$csucc_info:
         const GHC.Int.$fEnumInt64_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+448;
 },
 _c4sgo() //  [R1]
         { []
         }
     {offset
       c4sgo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sgy; else goto c4sgx;
       c4sgy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sgx: // global
           _s4kYh::I64 = I64[R1 + 7];
           if (_s4kYh::I64 != 9223372036854775807) goto c4sgG; else goto c4sgH;
       c4sgG: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4kYh::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sgH: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sgo_info" {
     block_c4sgo_info:
         const _c4sgo;
         const 0;
         const 4294967326;
         const S4lDl_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.855229719 UTC

[section ""data" . GHC.Int.$wgo2_closure" {
     GHC.Int.$wgo2_closure:
         const GHC.Int.$wgo2_info;
 },
 sat_s4kYq_entry() //  [R1]
         { []
         }
     {offset
       c4sh8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sh9; else goto c4shk;
       c4sh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4shk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4kYl::I64 = I64[R1 + 16];
           if (_s4kYl::I64 != 9223372036854775807) goto c4sh6; else goto c4sh7;
       c4sh6: // global
           I64[Sp - 24] = block_c4she_info;
           R2 = _s4kYl::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c4sh7: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4kYq_info" {
     sat_s4kYq_info:
         const sat_s4kYq_entry;
         const 4294967296;
         const 17;
 },
 _c4she() //  [R1, R2]
         { []
         }
     {offset
       c4she: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4shj; else goto c4shi;
       c4shj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4shi: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4she_info" {
     block_c4she_info:
         const _c4she;
         const 0;
         const 30;
 },
 GHC.Int.$wgo2_entry() //  [R2]
         { []
         }
     {offset
       c4shm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4shq; else goto c4shp;
       c4shq: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Int.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4shp: // global
           I64[Hp - 32] = sat_s4kYq_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R2 = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wgo2_info" {
     GHC.Int.$wgo2_info:
         const GHC.Int.$wgo2_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.863887431 UTC

[section ""data" . GHC.Int.$fEnumInt64_go_closure" {
     GHC.Int.$fEnumInt64_go_closure:
         const GHC.Int.$fEnumInt64_go_info;
 },
 GHC.Int.$fEnumInt64_go_entry() //  [R2]
         { []
         }
     {offset
       c4shN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4shO; else goto c4shP;
       c4shO: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4shP: // global
           I64[Sp - 8] = block_c4shK_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_go_info" {
     GHC.Int.$fEnumInt64_go_info:
         const GHC.Int.$fEnumInt64_go_entry;
         const 0;
         const 14;
         const 4294967300;
 },
 _c4shK() //  [R1, R2]
         { []
         }
     {offset
       c4shK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4shS; else goto c4shR;
       c4shS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4shR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4shK_info" {
     block_c4shK_info:
         const _c4shK;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.870084782 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFrom_closure" {
     GHC.Int.$fEnumInt64_$cenumFrom_closure:
         const GHC.Int.$fEnumInt64_$cenumFrom_info;
 },
 GHC.Int.$fEnumInt64_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c4si9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sia; else goto c4sib;
       c4sia: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sib: // global
           I64[Sp - 8] = block_c4si6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sif; else goto c4si7;
       u4sif: // global
           call _c4si6(R1) args: 0, res: 0, upd: 0;
       c4si7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cenumFrom_info" {
     GHC.Int.$fEnumInt64_$cenumFrom_info:
         const GHC.Int.$fEnumInt64_$cenumFrom_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4si6() //  [R1]
         { []
         }
     {offset
       c4si6: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4si6_info" {
     block_c4si6_info:
         const _c4si6;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.875529297 UTC

[section ""data" . GHC.Int.$fEnumInt64_closure" {
     GHC.Int.$fEnumInt64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt64_$csucc_closure+1;
         const GHC.Int.$fEnumInt64_$cpred_closure+1;
         const GHC.Int.$fEnumInt64_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt64_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sit: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt64_closure+1;
           R2 = GHC.Int.$fEnumInt64_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cenumFromThen_info" {
     GHC.Int.$fEnumInt64_$cenumFromThen_info:
         const GHC.Int.$fEnumInt64_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S4lDl_srt+464;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.880938601 UTC

[section ""data" . GHC.Int.$fNumInt8_$cfromInteger_closure" {
     GHC.Int.$fNumInt8_$cfromInteger_closure:
         const GHC.Int.$fNumInt8_$cfromInteger_info;
 },
 GHC.Int.$fNumInt8_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c4siH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4siO; else goto c4siP;
       c4siO: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4siP: // global
           I64[Sp - 8] = block_c4siF_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$cfromInteger_info" {
     GHC.Int.$fNumInt8_$cfromInteger_info:
         const GHC.Int.$fNumInt8_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4siF() //  [R1]
         { []
         }
     {offset
       c4siF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4siS; else goto c4siR;
       c4siS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4siR: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4siF_info" {
     block_c4siF_info:
         const _c4siF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.887155752 UTC

[section ""data" . GHC.Int.$fNumInt8_$cnegate_closure" {
     GHC.Int.$fNumInt8_$cnegate_closure:
         const GHC.Int.$fNumInt8_$cnegate_info;
 },
 GHC.Int.$fNumInt8_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c4sjb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sjl; else goto c4sjm;
       c4sjl: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sjm: // global
           I64[Sp - 8] = block_c4sj8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sjq; else goto c4sj9;
       u4sjq: // global
           call _c4sj8(R1) args: 0, res: 0, upd: 0;
       c4sj9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$cnegate_info" {
     GHC.Int.$fNumInt8_$cnegate_info:
         const GHC.Int.$fNumInt8_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sj8() //  [R1]
         { []
         }
     {offset
       c4sj8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sjp; else goto c4sjo;
       c4sjp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sjo: // global
           _s4kYF::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYF::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sj8_info" {
     block_c4sj8_info:
         const _c4sj8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.893661424 UTC

[section ""data" . GHC.Int.$fNumInt8_$c*_closure" {
     GHC.Int.$fNumInt8_$c*_closure:
         const GHC.Int.$fNumInt8_$c*_info;
 },
 GHC.Int.$fNumInt8_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sjJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sjY; else goto c4sjZ;
       c4sjY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sjZ: // global
           I64[Sp - 16] = block_c4sjG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sk5; else goto c4sjH;
       u4sk5: // global
           call _c4sjG(R1) args: 0, res: 0, upd: 0;
       c4sjH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$c*_info" {
     GHC.Int.$fNumInt8_$c*_info:
         const GHC.Int.$fNumInt8_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sjG() //  [R1]
         { []
         }
     {offset
       c4sjG: // global
           I64[Sp] = block_c4sjM_info;
           _s4kYJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYJ::I64;
           if (R1 & 7 != 0) goto u4sk4; else goto c4sjN;
       u4sk4: // global
           call _c4sjM(R1) args: 0, res: 0, upd: 0;
       c4sjN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sjG_info" {
     block_c4sjG_info:
         const _c4sjG;
         const 1;
         const 30;
 },
 _c4sjM() //  [R1]
         { []
         }
     {offset
       c4sjM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sk3; else goto c4sk2;
       c4sk3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sk2: // global
           _s4kYN::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYN::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sjM_info" {
     block_c4sjM_info:
         const _c4sjM;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.906524502 UTC

[section ""data" . GHC.Int.$fNumInt8_$c-_closure" {
     GHC.Int.$fNumInt8_$c-_closure:
         const GHC.Int.$fNumInt8_$c-_info;
 },
 GHC.Int.$fNumInt8_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4skJ; else goto c4skK;
       c4skJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4skK: // global
           I64[Sp - 16] = block_c4skr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4skQ; else goto c4sks;
       u4skQ: // global
           call _c4skr(R1) args: 0, res: 0, upd: 0;
       c4sks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$c-_info" {
     GHC.Int.$fNumInt8_$c-_info:
         const GHC.Int.$fNumInt8_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4skr() //  [R1]
         { []
         }
     {offset
       c4skr: // global
           I64[Sp] = block_c4skx_info;
           _s4kYR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYR::I64;
           if (R1 & 7 != 0) goto u4skP; else goto c4sky;
       u4skP: // global
           call _c4skx(R1) args: 0, res: 0, upd: 0;
       c4sky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4skr_info" {
     block_c4skr_info:
         const _c4skr;
         const 1;
         const 30;
 },
 _c4skx() //  [R1]
         { []
         }
     {offset
       c4skx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4skO; else goto c4skN;
       c4skO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4skN: // global
           _s4kYV::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kYV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4skx_info" {
     block_c4skx_info:
         const _c4skx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.918398787 UTC

[section ""data" . GHC.Int.$fNumInt8_$c+_closure" {
     GHC.Int.$fNumInt8_$c+_closure:
         const GHC.Int.$fNumInt8_$c+_info;
 },
 GHC.Int.$fNumInt8_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c4slf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4slu; else goto c4slv;
       c4slu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4slv: // global
           I64[Sp - 16] = block_c4slc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4slB; else goto c4sld;
       u4slB: // global
           call _c4slc(R1) args: 0, res: 0, upd: 0;
       c4sld: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$c+_info" {
     GHC.Int.$fNumInt8_$c+_info:
         const GHC.Int.$fNumInt8_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4slc() //  [R1]
         { []
         }
     {offset
       c4slc: // global
           I64[Sp] = block_c4sli_info;
           _s4kYZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kYZ::I64;
           if (R1 & 7 != 0) goto u4slA; else goto c4slj;
       u4slA: // global
           call _c4sli(R1) args: 0, res: 0, upd: 0;
       c4slj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4slc_info" {
     block_c4slc_info:
         const _c4slc;
         const 1;
         const 30;
 },
 _c4sli() //  [R1]
         { []
         }
     {offset
       c4sli: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4slz; else goto c4sly;
       c4slz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sly: // global
           _s4kZ3::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZ3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sli_info" {
     block_c4sli_info:
         const _c4sli;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.930105741 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt8_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt8_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt8_$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c4sm0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sm1; else goto c4sm2;
       c4sm1: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sm2: // global
           I64[Sp - 8] = block_c4slX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sm6; else goto c4slY;
       u4sm6: // global
           call _c4slX(R1) args: 0, res: 0, upd: 0;
       c4slY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$ctoInteger_info" {
     GHC.Int.$fIntegralInt8_$ctoInteger_info:
         const GHC.Int.$fIntegralInt8_$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4slX() //  [R1]
         { []
         }
     {offset
       c4slX: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4slX_info" {
     block_c4slX_info:
         const _c4slX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.935642136 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cpopCount_closure" {
     GHC.Int.$fBitsInt8_$cpopCount_closure:
         const GHC.Int.$fBitsInt8_$cpopCount_info;
 },
 GHC.Int.$fBitsInt8_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c4smn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4smB; else goto c4smC;
       c4smB: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4smC: // global
           I64[Sp - 8] = block_c4smk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4smG; else goto c4sml;
       u4smG: // global
           call _c4smk(R1) args: 0, res: 0, upd: 0;
       c4sml: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cpopCount_info" {
     GHC.Int.$fBitsInt8_$cpopCount_info:
         const GHC.Int.$fBitsInt8_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4smk() //  [R1]
         { []
         }
     {offset
       c4smk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4smF; else goto c4smE;
       c4smF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4smE: // global
           (_c4smt::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4smt::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4smk_info" {
     block_c4smk_info:
         const _c4smk;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.942008072 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4smY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sna; else goto c4snb;
       c4sna: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4snb: // global
           I64[Sp - 16] = block_c4smV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4snh; else goto c4smW;
       u4snh: // global
           call _c4smV(R1) args: 0, res: 0, upd: 0;
       c4smW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cunsafeShiftR_info" {
     GHC.Int.$fBitsInt8_$cunsafeShiftR_info:
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4smV() //  [R1]
         { []
         }
     {offset
       c4smV: // global
           I64[Sp] = block_c4sn1_info;
           _s4kZg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZg::I64;
           if (R1 & 7 != 0) goto u4sng; else goto c4sn2;
       u4sng: // global
           call _c4sn1(R1) args: 0, res: 0, upd: 0;
       c4sn2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4smV_info" {
     block_c4smV_info:
         const _c4smV;
         const 1;
         const 30;
 },
 _c4sn1() //  [R1]
         { []
         }
     {offset
       c4sn1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4snf; else goto c4sne;
       c4snf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sne: // global
           _s4kZj::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sn1_info" {
     block_c4sn1_info:
         const _c4sn1;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.949070784 UTC

[section ""data" . GHC.Int.$fBitsInt13_closure" {
     GHC.Int.$fBitsInt13_closure:
         const GHC.Int.I8#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.950650381 UTC

[section ""data" . GHC.Int.$fNumInt9_closure" {
     GHC.Int.$fNumInt9_closure:
         const GHC.Int.I8#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.954219706 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftR_closure" {
     GHC.Int.$fBitsInt8_$cshiftR_closure:
         const GHC.Int.$fBitsInt8_$cshiftR_info;
 },
 GHC.Int.$fBitsInt8_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4snG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4snK; else goto c4snL;
       c4snK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4snL: // global
           I64[Sp - 16] = block_c4snD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sob; else goto c4snE;
       u4sob: // global
           call _c4snD(R1) args: 0, res: 0, upd: 0;
       c4snE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cshiftR_info" {
     GHC.Int.$fBitsInt8_$cshiftR_info:
         const GHC.Int.$fBitsInt8_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4snD() //  [R1]
         { []
         }
     {offset
       c4snD: // global
           I64[Sp] = block_c4snJ_info;
           _s4kZn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZn::I64;
           if (R1 & 7 != 0) goto u4soa; else goto c4snN;
       u4soa: // global
           call _c4snJ(R1) args: 0, res: 0, upd: 0;
       c4snN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4snD_info" {
     block_c4snD_info:
         const _c4snD;
         const 1;
         const 30;
 },
 _c4snJ() //  [R1]
         { []
         }
     {offset
       c4snJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4snT; else goto c4snS;
       c4snT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4snS: // global
           _s4kZn::I64 = I64[Sp + 8];
           _s4kZp::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4kZp::I64, 64)) goto c4so2; else goto c4so9;
       c4so2: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4kZn::I64, _s4kZp::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4so9: // global
           if (%MO_S_Ge_W64(_s4kZn::I64, 0)) goto c4so7; else goto c4so8;
       c4so7: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4so8: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4snJ_info" {
     block_c4snJ_info:
         const _c4snJ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.962511092 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4soA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4soP; else goto c4soQ;
       c4soP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4soQ: // global
           I64[Sp - 16] = block_c4sox_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4soW; else goto c4soy;
       u4soW: // global
           call _c4sox(R1) args: 0, res: 0, upd: 0;
       c4soy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cunsafeShiftL_info" {
     GHC.Int.$fBitsInt8_$cunsafeShiftL_info:
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sox() //  [R1]
         { []
         }
     {offset
       c4sox: // global
           I64[Sp] = block_c4soD_info;
           _s4kZw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZw::I64;
           if (R1 & 7 != 0) goto u4soV; else goto c4soE;
       u4soV: // global
           call _c4soD(R1) args: 0, res: 0, upd: 0;
       c4soE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sox_info" {
     block_c4sox_info:
         const _c4sox;
         const 1;
         const 30;
 },
 _c4soD() //  [R1]
         { []
         }
     {offset
       c4soD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4soU; else goto c4soT;
       c4soU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4soT: // global
           _s4kZA::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4kZA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4soD_info" {
     block_c4soD_info:
         const _c4soD;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.971795556 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftL_closure" {
     GHC.Int.$fBitsInt8_$cshiftL_closure:
         const GHC.Int.$fBitsInt8_$cshiftL_info;
 },
 GHC.Int.$fBitsInt8_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4spk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4spo; else goto c4spp;
       c4spo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4spp: // global
           I64[Sp - 16] = block_c4sph_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4spM; else goto c4spi;
       u4spM: // global
           call _c4sph(R1) args: 0, res: 0, upd: 0;
       c4spi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cshiftL_info" {
     GHC.Int.$fBitsInt8_$cshiftL_info:
         const GHC.Int.$fBitsInt8_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sph() //  [R1]
         { []
         }
     {offset
       c4sph: // global
           I64[Sp] = block_c4spn_info;
           _s4kZE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4kZE::I64;
           if (R1 & 7 != 0) goto u4spL; else goto c4spr;
       u4spL: // global
           call _c4spn(R1) args: 0, res: 0, upd: 0;
       c4spr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sph_info" {
     block_c4sph_info:
         const _c4sph;
         const 1;
         const 30;
 },
 _c4spn() //  [R1]
         { []
         }
     {offset
       c4spn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4spx; else goto c4spw;
       c4spx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4spw: // global
           _s4kZG::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4kZG::I64, 64)) goto c4spJ; else goto c4spK;
       c4spJ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << _s4kZG::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4spK: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4spn_info" {
     block_c4spn_info:
         const _c4spn;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.979190677 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cisSigned_closure" {
     GHC.Int.$fBitsInt8_$cisSigned_closure:
         const GHC.Int.$fBitsInt8_$cisSigned_info;
 },
 GHC.Int.$fBitsInt8_$cisSigned_entry() //  []
         { []
         }
     {offset
       c4sq9: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cisSigned_info" {
     GHC.Int.$fBitsInt8_$cisSigned_info:
         const GHC.Int.$fBitsInt8_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.984317968 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotate_closure" {
     GHC.Int.$fBitsInt8_$crotate_closure:
         const GHC.Int.$fBitsInt8_$crotate_info;
 },
 GHC.Int.$fBitsInt8_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sqo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sqs; else goto c4sqt;
       c4sqs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sqt: // global
           I64[Sp - 16] = block_c4sql_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4srp; else goto c4sqm;
       u4srp: // global
           call _c4sql(R1) args: 0, res: 0, upd: 0;
       c4sqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$crotate_info" {
     GHC.Int.$fBitsInt8_$crotate_info:
         const GHC.Int.$fBitsInt8_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sql() //  [R1]
         { []
         }
     {offset
       c4sql: // global
           I64[Sp - 8] = block_c4sqr_info;
           _s4kZN::P64 = R1;
           _s4kZO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4kZO::I64;
           P64[Sp + 8] = _s4kZN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sro; else goto c4sqv;
       u4sro: // global
           call _c4sqr(R1) args: 0, res: 0, upd: 0;
       c4sqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sql_info" {
     block_c4sql_info:
         const _c4sql;
         const 1;
         const 30;
 },
 _c4sqr() //  [R1]
         { []
         }
     {offset
       c4sqr: // global
           _s4kZT::I64 = I64[R1 + 7] & 7;
           if (_s4kZT::I64 != 0) goto u4srm; else goto c4sri;
       u4srm: // global
           I64[Sp + 16] = _s4kZT::I64;
           Sp = Sp + 8;
           call _c4sqK() args: 0, res: 0, upd: 0;
       c4sri: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sqr_info" {
     block_c4sqr_info:
         const _c4sqr;
         const 66;
         const 30;
 },
 _c4sqK() //  []
         { []
         }
     {offset
       c4sqK: // global
           Hp = Hp + 16;
           _s4kZT::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4srf; else goto c4sre;
       c4srf: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4sqJ_info;
           R1 = _s4kZT::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4sre: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4kZU::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4kZU::I64 << _s4kZT::I64) | (_s4kZU::I64 >> 8 - _s4kZT::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4sqJ() //  [R1]
         { []
         }
     {offset
       c4sqJ: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4sqK() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4sqJ_info" {
     block_c4sqJ_info:
         const _c4sqJ;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:10.995752957 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshift_closure" {
     GHC.Int.$fBitsInt8_$cshift_closure:
         const GHC.Int.$fBitsInt8_$cshift_info;
 },
 GHC.Int.$fBitsInt8_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ss2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ss6; else goto c4ss7;
       c4ss6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ss7: // global
           I64[Sp - 16] = block_c4srZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ssU; else goto c4ss0;
       u4ssU: // global
           call _c4srZ(R1) args: 0, res: 0, upd: 0;
       c4ss0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cshift_info" {
     GHC.Int.$fBitsInt8_$cshift_info:
         const GHC.Int.$fBitsInt8_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4srZ() //  [R1]
         { []
         }
     {offset
       c4srZ: // global
           I64[Sp] = block_c4ss5_info;
           _s4l05::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l05::I64;
           if (R1 & 7 != 0) goto u4ssT; else goto c4ss9;
       u4ssT: // global
           call _c4ss5(R1) args: 0, res: 0, upd: 0;
       c4ss9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4srZ_info" {
     block_c4srZ_info:
         const _c4srZ;
         const 1;
         const 30;
 },
 _c4ss5() //  [R1]
         { []
         }
     {offset
       c4ss5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ssf; else goto c4sse;
       c4ssf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sse: // global
           _s4l05::I64 = I64[Sp + 8];
           _s4l07::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l07::I64, 0)) goto c4ssD; else goto c4ssS;
       c4ssD: // global
           _s4l09::I64 = -_s4l07::I64;
           if (%MO_S_Lt_W64(_s4l09::I64, 64)) goto c4ssu; else goto c4ssB;
       c4ssu: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l05::I64, _s4l09::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ssB: // global
           if (%MO_S_Ge_W64(_s4l05::I64, 0)) goto c4ssR; else goto c4ssA;
       c4ssA: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ssS: // global
           if (%MO_S_Ge_W64(_s4l07::I64, 64)) goto c4ssR; else goto c4ssQ;
       c4ssR: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ssQ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4l05::I64 << _s4l07::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ss5_info" {
     block_c4ss5_info:
         const _c4ss5;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.004201116 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplement_closure" {
     GHC.Int.$fBitsInt8_$ccomplement_closure:
         const GHC.Int.$fBitsInt8_$ccomplement_info;
 },
 GHC.Int.$fBitsInt8_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c4stn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4stA; else goto c4stB;
       c4stA: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4stB: // global
           I64[Sp - 8] = block_c4stk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4stF; else goto c4stl;
       u4stF: // global
           call _c4stk(R1) args: 0, res: 0, upd: 0;
       c4stl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$ccomplement_info" {
     GHC.Int.$fBitsInt8_$ccomplement_info:
         const GHC.Int.$fBitsInt8_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4stk() //  [R1]
         { []
         }
     {offset
       c4stk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4stE; else goto c4stD;
       c4stE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4stD: // global
           _s4l0l::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4stk_info" {
     block_c4stk_info:
         const _c4stk;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.010779216 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cxor_closure" {
     GHC.Int.$fBitsInt8_$cxor_closure:
         const GHC.Int.$fBitsInt8_$cxor_info;
 },
 GHC.Int.$fBitsInt8_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c4stX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sui; else goto c4suj;
       c4sui: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4suj: // global
           I64[Sp - 16] = block_c4stU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sup; else goto c4stV;
       u4sup: // global
           call _c4stU(R1) args: 0, res: 0, upd: 0;
       c4stV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cxor_info" {
     GHC.Int.$fBitsInt8_$cxor_info:
         const GHC.Int.$fBitsInt8_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4stU() //  [R1]
         { []
         }
     {offset
       c4stU: // global
           I64[Sp] = block_c4su0_info;
           _s4l0p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0p::I64;
           if (R1 & 7 != 0) goto u4suo; else goto c4su1;
       u4suo: // global
           call _c4su0(R1) args: 0, res: 0, upd: 0;
       c4su1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4stU_info" {
     block_c4stU_info:
         const _c4stU;
         const 1;
         const 30;
 },
 _c4su0() //  [R1]
         { []
         }
     {offset
       c4su0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sun; else goto c4sum;
       c4sun: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sum: // global
           _s4l0v::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0v::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4su0_info" {
     block_c4su0_info:
         const _c4su0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.018665859 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.|._closure" {
     GHC.Int.$fBitsInt8_$c.|._closure:
         const GHC.Int.$fBitsInt8_$c.|._info;
 },
 GHC.Int.$fBitsInt8_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c4suN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sv8; else goto c4sv9;
       c4sv8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sv9: // global
           I64[Sp - 16] = block_c4suK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4svf; else goto c4suL;
       u4svf: // global
           call _c4suK(R1) args: 0, res: 0, upd: 0;
       c4suL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$c.|._info" {
     GHC.Int.$fBitsInt8_$c.|._info:
         const GHC.Int.$fBitsInt8_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4suK() //  [R1]
         { []
         }
     {offset
       c4suK: // global
           I64[Sp] = block_c4suQ_info;
           _s4l0z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0z::I64;
           if (R1 & 7 != 0) goto u4sve; else goto c4suR;
       u4sve: // global
           call _c4suQ(R1) args: 0, res: 0, upd: 0;
       c4suR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4suK_info" {
     block_c4suK_info:
         const _c4suK;
         const 1;
         const 30;
 },
 _c4suQ() //  [R1]
         { []
         }
     {offset
       c4suQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4svd; else goto c4svc;
       c4svd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4svc: // global
           _s4l0F::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0F::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4suQ_info" {
     block_c4suQ_info:
         const _c4suQ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.027516443 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.&._closure" {
     GHC.Int.$fBitsInt8_$c.&._closure:
         const GHC.Int.$fBitsInt8_$c.&._info;
 },
 GHC.Int.$fBitsInt8_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c4svD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4svY; else goto c4svZ;
       c4svY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4svZ: // global
           I64[Sp - 16] = block_c4svA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sw5; else goto c4svB;
       u4sw5: // global
           call _c4svA(R1) args: 0, res: 0, upd: 0;
       c4svB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$c.&._info" {
     GHC.Int.$fBitsInt8_$c.&._info:
         const GHC.Int.$fBitsInt8_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4svA() //  [R1]
         { []
         }
     {offset
       c4svA: // global
           I64[Sp] = block_c4svG_info;
           _s4l0J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l0J::I64;
           if (R1 & 7 != 0) goto u4sw4; else goto c4svH;
       u4sw4: // global
           call _c4svG(R1) args: 0, res: 0, upd: 0;
       c4svH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4svA_info" {
     block_c4svA_info:
         const _c4svA;
         const 1;
         const 30;
 },
 _c4svG() //  [R1]
         { []
         }
     {offset
       c4svG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sw3; else goto c4sw2;
       c4sw3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sw2: // global
           _s4l0P::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4l0P::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4svG_info" {
     block_c4svG_info:
         const _c4svG;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.035114587 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4swt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4swH; else goto c4swI;
       c4swH: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4swI: // global
           I64[Sp - 8] = block_c4swq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4swM; else goto c4swr;
       u4swM: // global
           call _c4swq(R1) args: 0, res: 0, upd: 0;
       c4swr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info" {
     GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info:
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4swq() //  [R1]
         { []
         }
     {offset
       c4swq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4swL; else goto c4swK;
       c4swL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4swK: // global
           (_c4swz::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4swz::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4swq_info" {
     block_c4swq_info:
         const _c4swq;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.041326106 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4sx6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sxk; else goto c4sxl;
       c4sxk: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sxl: // global
           I64[Sp - 8] = block_c4sx3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sxp; else goto c4sx4;
       u4sxp: // global
           call _c4sx3(R1) args: 0, res: 0, upd: 0;
       c4sx4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info" {
     GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info:
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sx3() //  [R1]
         { []
         }
     {offset
       c4sx3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sxo; else goto c4sxn;
       c4sxo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sxn: // global
           (_c4sxc::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4sxc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sx3_info" {
     block_c4sx3_info:
         const _c4sx3;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.04759628 UTC

[section ""data" . GHC.Int.$fBitsInt11_closure" {
     GHC.Int.$fBitsInt11_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.049695087 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt8_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt8_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c4sxH: // global
           R1 = GHC.Int.$fBitsInt11_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cfiniteBitSize_info" {
     GHC.Int.$fBitsInt8_$cfiniteBitSize_info:
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.053750414 UTC

[section ""data" . GHC.Int.$fNumInt16_$cfromInteger_closure" {
     GHC.Int.$fNumInt16_$cfromInteger_closure:
         const GHC.Int.$fNumInt16_$cfromInteger_info;
 },
 GHC.Int.$fNumInt16_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c4sxV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sy2; else goto c4sy3;
       c4sy2: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sy3: // global
           I64[Sp - 8] = block_c4sxT_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$cfromInteger_info" {
     GHC.Int.$fNumInt16_$cfromInteger_info:
         const GHC.Int.$fNumInt16_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sxT() //  [R1]
         { []
         }
     {offset
       c4sxT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sy6; else goto c4sy5;
       c4sy6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4sy5: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sxT_info" {
     block_c4sxT_info:
         const _c4sxT;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.059734443 UTC

[section ""data" . GHC.Int.$fNumInt16_$cnegate_closure" {
     GHC.Int.$fNumInt16_$cnegate_closure:
         const GHC.Int.$fNumInt16_$cnegate_info;
 },
 GHC.Int.$fNumInt16_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c4syp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4syz; else goto c4syA;
       c4syz: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4syA: // global
           I64[Sp - 8] = block_c4sym_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4syE; else goto c4syn;
       u4syE: // global
           call _c4sym(R1) args: 0, res: 0, upd: 0;
       c4syn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$cnegate_info" {
     GHC.Int.$fNumInt16_$cnegate_info:
         const GHC.Int.$fNumInt16_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sym() //  [R1]
         { []
         }
     {offset
       c4sym: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4syD; else goto c4syC;
       c4syD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4syC: // global
           _s4l1a::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1a::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sym_info" {
     block_c4sym_info:
         const _c4sym;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.067261214 UTC

[section ""data" . GHC.Int.$fNumInt16_$c*_closure" {
     GHC.Int.$fNumInt16_$c*_closure:
         const GHC.Int.$fNumInt16_$c*_info;
 },
 GHC.Int.$fNumInt16_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c4syX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4szc; else goto c4szd;
       c4szc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4szd: // global
           I64[Sp - 16] = block_c4syU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4szj; else goto c4syV;
       u4szj: // global
           call _c4syU(R1) args: 0, res: 0, upd: 0;
       c4syV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$c*_info" {
     GHC.Int.$fNumInt16_$c*_info:
         const GHC.Int.$fNumInt16_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4syU() //  [R1]
         { []
         }
     {offset
       c4syU: // global
           I64[Sp] = block_c4sz0_info;
           _s4l1e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1e::I64;
           if (R1 & 7 != 0) goto u4szi; else goto c4sz1;
       u4szi: // global
           call _c4sz0(R1) args: 0, res: 0, upd: 0;
       c4sz1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4syU_info" {
     block_c4syU_info:
         const _c4syU;
         const 1;
         const 30;
 },
 _c4sz0() //  [R1]
         { []
         }
     {offset
       c4sz0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4szh; else goto c4szg;
       c4szh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4szg: // global
           _s4l1i::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1i::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sz0_info" {
     block_c4sz0_info:
         const _c4sz0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.075236316 UTC

[section ""data" . GHC.Int.$fNumInt16_$c-_closure" {
     GHC.Int.$fNumInt16_$c-_closure:
         const GHC.Int.$fNumInt16_$c-_info;
 },
 GHC.Int.$fNumInt16_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c4szI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4szX; else goto c4szY;
       c4szX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4szY: // global
           I64[Sp - 16] = block_c4szF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sA4; else goto c4szG;
       u4sA4: // global
           call _c4szF(R1) args: 0, res: 0, upd: 0;
       c4szG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$c-_info" {
     GHC.Int.$fNumInt16_$c-_info:
         const GHC.Int.$fNumInt16_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4szF() //  [R1]
         { []
         }
     {offset
       c4szF: // global
           I64[Sp] = block_c4szL_info;
           _s4l1m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1m::I64;
           if (R1 & 7 != 0) goto u4sA3; else goto c4szM;
       u4sA3: // global
           call _c4szL(R1) args: 0, res: 0, upd: 0;
       c4szM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4szF_info" {
     block_c4szF_info:
         const _c4szF;
         const 1;
         const 30;
 },
 _c4szL() //  [R1]
         { []
         }
     {offset
       c4szL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sA2; else goto c4sA1;
       c4sA2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sA1: // global
           _s4l1q::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4szL_info" {
     block_c4szL_info:
         const _c4szL;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.084468554 UTC

[section ""data" . GHC.Int.$fNumInt16_$c+_closure" {
     GHC.Int.$fNumInt16_$c+_closure:
         const GHC.Int.$fNumInt16_$c+_info;
 },
 GHC.Int.$fNumInt16_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sAt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sAI; else goto c4sAJ;
       c4sAI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sAJ: // global
           I64[Sp - 16] = block_c4sAq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sAP; else goto c4sAr;
       u4sAP: // global
           call _c4sAq(R1) args: 0, res: 0, upd: 0;
       c4sAr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$c+_info" {
     GHC.Int.$fNumInt16_$c+_info:
         const GHC.Int.$fNumInt16_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sAq() //  [R1]
         { []
         }
     {offset
       c4sAq: // global
           I64[Sp] = block_c4sAw_info;
           _s4l1u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1u::I64;
           if (R1 & 7 != 0) goto u4sAO; else goto c4sAx;
       u4sAO: // global
           call _c4sAw(R1) args: 0, res: 0, upd: 0;
       c4sAx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sAq_info" {
     block_c4sAq_info:
         const _c4sAq;
         const 1;
         const 30;
 },
 _c4sAw() //  [R1]
         { []
         }
     {offset
       c4sAw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sAN; else goto c4sAM;
       c4sAN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sAM: // global
           _s4l1y::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1y::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sAw_info" {
     block_c4sAw_info:
         const _c4sAw;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.091780645 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt16_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt16_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt16_$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c4sBe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sBf; else goto c4sBg;
       c4sBf: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sBg: // global
           I64[Sp - 8] = block_c4sBb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sBk; else goto c4sBc;
       u4sBk: // global
           call _c4sBb(R1) args: 0, res: 0, upd: 0;
       c4sBc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$ctoInteger_info" {
     GHC.Int.$fIntegralInt16_$ctoInteger_info:
         const GHC.Int.$fIntegralInt16_$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sBb() //  [R1]
         { []
         }
     {offset
       c4sBb: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sBb_info" {
     block_c4sBb_info:
         const _c4sBb;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.097748309 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cpopCount_closure" {
     GHC.Int.$fBitsInt16_$cpopCount_closure:
         const GHC.Int.$fBitsInt16_$cpopCount_info;
 },
 GHC.Int.$fBitsInt16_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c4sBB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sBP; else goto c4sBQ;
       c4sBP: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sBQ: // global
           I64[Sp - 8] = block_c4sBy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sBU; else goto c4sBz;
       u4sBU: // global
           call _c4sBy(R1) args: 0, res: 0, upd: 0;
       c4sBz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cpopCount_info" {
     GHC.Int.$fBitsInt16_$cpopCount_info:
         const GHC.Int.$fBitsInt16_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sBy() //  [R1]
         { []
         }
     {offset
       c4sBy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sBT; else goto c4sBS;
       c4sBT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sBS: // global
           (_c4sBH::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4sBH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sBy_info" {
     block_c4sBy_info:
         const _c4sBy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.104816807 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sCc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sCo; else goto c4sCp;
       c4sCo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sCp: // global
           I64[Sp - 16] = block_c4sC9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sCv; else goto c4sCa;
       u4sCv: // global
           call _c4sC9(R1) args: 0, res: 0, upd: 0;
       c4sCa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cunsafeShiftR_info" {
     GHC.Int.$fBitsInt16_$cunsafeShiftR_info:
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sC9() //  [R1]
         { []
         }
     {offset
       c4sC9: // global
           I64[Sp] = block_c4sCf_info;
           _s4l1L::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1L::I64;
           if (R1 & 7 != 0) goto u4sCu; else goto c4sCg;
       u4sCu: // global
           call _c4sCf(R1) args: 0, res: 0, upd: 0;
       c4sCg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sC9_info" {
     block_c4sC9_info:
         const _c4sC9;
         const 1;
         const 30;
 },
 _c4sCf() //  [R1]
         { []
         }
     {offset
       c4sCf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sCt; else goto c4sCs;
       c4sCt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sCs: // global
           _s4l1O::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l1O::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sCf_info" {
     block_c4sCf_info:
         const _c4sCf;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.111761364 UTC

[section ""data" . GHC.Int.$fBitsInt3_closure" {
     GHC.Int.$fBitsInt3_closure:
         const GHC.Int.I16#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.113423263 UTC

[section ""data" . GHC.Int.$fNumInt2_closure" {
     GHC.Int.$fNumInt2_closure:
         const GHC.Int.I16#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.116812263 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftR_closure" {
     GHC.Int.$fBitsInt16_$cshiftR_closure:
         const GHC.Int.$fBitsInt16_$cshiftR_info;
 },
 GHC.Int.$fBitsInt16_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sCU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sCY; else goto c4sCZ;
       c4sCY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sCZ: // global
           I64[Sp - 16] = block_c4sCR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sDp; else goto c4sCS;
       u4sDp: // global
           call _c4sCR(R1) args: 0, res: 0, upd: 0;
       c4sCS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cshiftR_info" {
     GHC.Int.$fBitsInt16_$cshiftR_info:
         const GHC.Int.$fBitsInt16_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sCR() //  [R1]
         { []
         }
     {offset
       c4sCR: // global
           I64[Sp] = block_c4sCX_info;
           _s4l1S::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l1S::I64;
           if (R1 & 7 != 0) goto u4sDo; else goto c4sD1;
       u4sDo: // global
           call _c4sCX(R1) args: 0, res: 0, upd: 0;
       c4sD1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sCR_info" {
     block_c4sCR_info:
         const _c4sCR;
         const 1;
         const 30;
 },
 _c4sCX() //  [R1]
         { []
         }
     {offset
       c4sCX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sD7; else goto c4sD6;
       c4sD7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sD6: // global
           _s4l1S::I64 = I64[Sp + 8];
           _s4l1U::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l1U::I64, 64)) goto c4sDg; else goto c4sDn;
       c4sDg: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l1S::I64, _s4l1U::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sDn: // global
           if (%MO_S_Ge_W64(_s4l1S::I64, 0)) goto c4sDl; else goto c4sDm;
       c4sDl: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sDm: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sCX_info" {
     block_c4sCX_info:
         const _c4sCX;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.126453965 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sDO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sE3; else goto c4sE4;
       c4sE3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sE4: // global
           I64[Sp - 16] = block_c4sDL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sEa; else goto c4sDM;
       u4sEa: // global
           call _c4sDL(R1) args: 0, res: 0, upd: 0;
       c4sDM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cunsafeShiftL_info" {
     GHC.Int.$fBitsInt16_$cunsafeShiftL_info:
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sDL() //  [R1]
         { []
         }
     {offset
       c4sDL: // global
           I64[Sp] = block_c4sDR_info;
           _s4l21::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l21::I64;
           if (R1 & 7 != 0) goto u4sE9; else goto c4sDS;
       u4sE9: // global
           call _c4sDR(R1) args: 0, res: 0, upd: 0;
       c4sDS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sDL_info" {
     block_c4sDL_info:
         const _c4sDL;
         const 1;
         const 30;
 },
 _c4sDR() //  [R1]
         { []
         }
     {offset
       c4sDR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sE8; else goto c4sE7;
       c4sE8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sE7: // global
           _s4l25::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l25::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sDR_info" {
     block_c4sDR_info:
         const _c4sDR;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.135619945 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftL_closure" {
     GHC.Int.$fBitsInt16_$cshiftL_closure:
         const GHC.Int.$fBitsInt16_$cshiftL_info;
 },
 GHC.Int.$fBitsInt16_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sEy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sEC; else goto c4sED;
       c4sEC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sED: // global
           I64[Sp - 16] = block_c4sEv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sF0; else goto c4sEw;
       u4sF0: // global
           call _c4sEv(R1) args: 0, res: 0, upd: 0;
       c4sEw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cshiftL_info" {
     GHC.Int.$fBitsInt16_$cshiftL_info:
         const GHC.Int.$fBitsInt16_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sEv() //  [R1]
         { []
         }
     {offset
       c4sEv: // global
           I64[Sp] = block_c4sEB_info;
           _s4l29::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l29::I64;
           if (R1 & 7 != 0) goto u4sEZ; else goto c4sEF;
       u4sEZ: // global
           call _c4sEB(R1) args: 0, res: 0, upd: 0;
       c4sEF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sEv_info" {
     block_c4sEv_info:
         const _c4sEv;
         const 1;
         const 30;
 },
 _c4sEB() //  [R1]
         { []
         }
     {offset
       c4sEB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sEL; else goto c4sEK;
       c4sEL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sEK: // global
           _s4l2b::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l2b::I64, 64)) goto c4sEX; else goto c4sEY;
       c4sEX: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << _s4l2b::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sEY: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sEB_info" {
     block_c4sEB_info:
         const _c4sEB;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.143588071 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cisSigned_closure" {
     GHC.Int.$fBitsInt16_$cisSigned_closure:
         const GHC.Int.$fBitsInt16_$cisSigned_info;
 },
 GHC.Int.$fBitsInt16_$cisSigned_entry() //  []
         { []
         }
     {offset
       c4sFn: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cisSigned_info" {
     GHC.Int.$fBitsInt16_$cisSigned_info:
         const GHC.Int.$fBitsInt16_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.148820064 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotate_closure" {
     GHC.Int.$fBitsInt16_$crotate_closure:
         const GHC.Int.$fBitsInt16_$crotate_info;
 },
 GHC.Int.$fBitsInt16_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sFC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sFG; else goto c4sFH;
       c4sFG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sFH: // global
           I64[Sp - 16] = block_c4sFz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sGD; else goto c4sFA;
       u4sGD: // global
           call _c4sFz(R1) args: 0, res: 0, upd: 0;
       c4sFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$crotate_info" {
     GHC.Int.$fBitsInt16_$crotate_info:
         const GHC.Int.$fBitsInt16_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sFz() //  [R1]
         { []
         }
     {offset
       c4sFz: // global
           I64[Sp - 8] = block_c4sFF_info;
           _s4l2i::P64 = R1;
           _s4l2j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l2j::I64;
           P64[Sp + 8] = _s4l2i::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sGC; else goto c4sFJ;
       u4sGC: // global
           call _c4sFF(R1) args: 0, res: 0, upd: 0;
       c4sFJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sFz_info" {
     block_c4sFz_info:
         const _c4sFz;
         const 1;
         const 30;
 },
 _c4sFF() //  [R1]
         { []
         }
     {offset
       c4sFF: // global
           _s4l2o::I64 = I64[R1 + 7] & 15;
           if (_s4l2o::I64 != 0) goto u4sGA; else goto c4sGw;
       u4sGA: // global
           I64[Sp + 16] = _s4l2o::I64;
           Sp = Sp + 8;
           call _c4sFY() args: 0, res: 0, upd: 0;
       c4sGw: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sFF_info" {
     block_c4sFF_info:
         const _c4sFF;
         const 66;
         const 30;
 },
 _c4sFY() //  []
         { []
         }
     {offset
       c4sFY: // global
           Hp = Hp + 16;
           _s4l2o::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4sGt; else goto c4sGs;
       c4sGt: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4sFX_info;
           R1 = _s4l2o::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4sGs: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4l2p::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4l2p::I64 << _s4l2o::I64) | (_s4l2p::I64 >> 16 - _s4l2o::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4sFX() //  [R1]
         { []
         }
     {offset
       c4sFX: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4sFY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4sFX_info" {
     block_c4sFX_info:
         const _c4sFX;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.160547545 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshift_closure" {
     GHC.Int.$fBitsInt16_$cshift_closure:
         const GHC.Int.$fBitsInt16_$cshift_info;
 },
 GHC.Int.$fBitsInt16_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sHg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sHk; else goto c4sHl;
       c4sHk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sHl: // global
           I64[Sp - 16] = block_c4sHd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sI8; else goto c4sHe;
       u4sI8: // global
           call _c4sHd(R1) args: 0, res: 0, upd: 0;
       c4sHe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cshift_info" {
     GHC.Int.$fBitsInt16_$cshift_info:
         const GHC.Int.$fBitsInt16_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sHd() //  [R1]
         { []
         }
     {offset
       c4sHd: // global
           I64[Sp] = block_c4sHj_info;
           _s4l2A::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l2A::I64;
           if (R1 & 7 != 0) goto u4sI7; else goto c4sHn;
       u4sI7: // global
           call _c4sHj(R1) args: 0, res: 0, upd: 0;
       c4sHn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sHd_info" {
     block_c4sHd_info:
         const _c4sHd;
         const 1;
         const 30;
 },
 _c4sHj() //  [R1]
         { []
         }
     {offset
       c4sHj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sHt; else goto c4sHs;
       c4sHt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sHs: // global
           _s4l2A::I64 = I64[Sp + 8];
           _s4l2C::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l2C::I64, 0)) goto c4sHR; else goto c4sI6;
       c4sHR: // global
           _s4l2E::I64 = -_s4l2C::I64;
           if (%MO_S_Lt_W64(_s4l2E::I64, 64)) goto c4sHI; else goto c4sHP;
       c4sHI: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l2A::I64, _s4l2E::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sHP: // global
           if (%MO_S_Ge_W64(_s4l2A::I64, 0)) goto c4sI5; else goto c4sHO;
       c4sHO: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sI6: // global
           if (%MO_S_Ge_W64(_s4l2C::I64, 64)) goto c4sI5; else goto c4sI4;
       c4sI5: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sI4: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4l2A::I64 << _s4l2C::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sHj_info" {
     block_c4sHj_info:
         const _c4sHj;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.170717452 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplement_closure" {
     GHC.Int.$fBitsInt16_$ccomplement_closure:
         const GHC.Int.$fBitsInt16_$ccomplement_info;
 },
 GHC.Int.$fBitsInt16_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c4sIB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sIO; else goto c4sIP;
       c4sIO: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sIP: // global
           I64[Sp - 8] = block_c4sIy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sIT; else goto c4sIz;
       u4sIT: // global
           call _c4sIy(R1) args: 0, res: 0, upd: 0;
       c4sIz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$ccomplement_info" {
     GHC.Int.$fBitsInt16_$ccomplement_info:
         const GHC.Int.$fBitsInt16_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sIy() //  [R1]
         { []
         }
     {offset
       c4sIy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sIS; else goto c4sIR;
       c4sIS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sIR: // global
           _s4l2Q::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l2Q::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sIy_info" {
     block_c4sIy_info:
         const _c4sIy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.177231902 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cxor_closure" {
     GHC.Int.$fBitsInt16_$cxor_closure:
         const GHC.Int.$fBitsInt16_$cxor_info;
 },
 GHC.Int.$fBitsInt16_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sJb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sJw; else goto c4sJx;
       c4sJw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sJx: // global
           I64[Sp - 16] = block_c4sJ8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sJD; else goto c4sJ9;
       u4sJD: // global
           call _c4sJ8(R1) args: 0, res: 0, upd: 0;
       c4sJ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cxor_info" {
     GHC.Int.$fBitsInt16_$cxor_info:
         const GHC.Int.$fBitsInt16_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sJ8() //  [R1]
         { []
         }
     {offset
       c4sJ8: // global
           I64[Sp] = block_c4sJe_info;
           _s4l2U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l2U::I64;
           if (R1 & 7 != 0) goto u4sJC; else goto c4sJf;
       u4sJC: // global
           call _c4sJe(R1) args: 0, res: 0, upd: 0;
       c4sJf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sJ8_info" {
     block_c4sJ8_info:
         const _c4sJ8;
         const 1;
         const 30;
 },
 _c4sJe() //  [R1]
         { []
         }
     {offset
       c4sJe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sJB; else goto c4sJA;
       c4sJB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sJA: // global
           _s4l30::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l30::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sJe_info" {
     block_c4sJe_info:
         const _c4sJe;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.186384274 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.|._closure" {
     GHC.Int.$fBitsInt16_$c.|._closure:
         const GHC.Int.$fBitsInt16_$c.|._info;
 },
 GHC.Int.$fBitsInt16_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c4sK1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sKm; else goto c4sKn;
       c4sKm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sKn: // global
           I64[Sp - 16] = block_c4sJY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sKt; else goto c4sJZ;
       u4sKt: // global
           call _c4sJY(R1) args: 0, res: 0, upd: 0;
       c4sJZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$c.|._info" {
     GHC.Int.$fBitsInt16_$c.|._info:
         const GHC.Int.$fBitsInt16_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sJY() //  [R1]
         { []
         }
     {offset
       c4sJY: // global
           I64[Sp] = block_c4sK4_info;
           _s4l34::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l34::I64;
           if (R1 & 7 != 0) goto u4sKs; else goto c4sK5;
       u4sKs: // global
           call _c4sK4(R1) args: 0, res: 0, upd: 0;
       c4sK5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sJY_info" {
     block_c4sJY_info:
         const _c4sJY;
         const 1;
         const 30;
 },
 _c4sK4() //  [R1]
         { []
         }
     {offset
       c4sK4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sKr; else goto c4sKq;
       c4sKr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sKq: // global
           _s4l3a::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l3a::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sK4_info" {
     block_c4sK4_info:
         const _c4sK4;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.194576361 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.&._closure" {
     GHC.Int.$fBitsInt16_$c.&._closure:
         const GHC.Int.$fBitsInt16_$c.&._info;
 },
 GHC.Int.$fBitsInt16_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c4sKR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sLc; else goto c4sLd;
       c4sLc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sLd: // global
           I64[Sp - 16] = block_c4sKO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sLj; else goto c4sKP;
       u4sLj: // global
           call _c4sKO(R1) args: 0, res: 0, upd: 0;
       c4sKP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$c.&._info" {
     GHC.Int.$fBitsInt16_$c.&._info:
         const GHC.Int.$fBitsInt16_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sKO() //  [R1]
         { []
         }
     {offset
       c4sKO: // global
           I64[Sp] = block_c4sKU_info;
           _s4l3e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3e::I64;
           if (R1 & 7 != 0) goto u4sLi; else goto c4sKV;
       u4sLi: // global
           call _c4sKU(R1) args: 0, res: 0, upd: 0;
       c4sKV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sKO_info" {
     block_c4sKO_info:
         const _c4sKO;
         const 1;
         const 30;
 },
 _c4sKU() //  [R1]
         { []
         }
     {offset
       c4sKU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sLh; else goto c4sLg;
       c4sLh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sLg: // global
           _s4l3k::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4l3k::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sKU_info" {
     block_c4sKU_info:
         const _c4sKU;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.202940654 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4sLH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sLV; else goto c4sLW;
       c4sLV: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sLW: // global
           I64[Sp - 8] = block_c4sLE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sM0; else goto c4sLF;
       u4sM0: // global
           call _c4sLE(R1) args: 0, res: 0, upd: 0;
       c4sLF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info" {
     GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info:
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sLE() //  [R1]
         { []
         }
     {offset
       c4sLE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sLZ; else goto c4sLY;
       c4sLZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sLY: // global
           (_c4sLN::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4sLN::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sLE_info" {
     block_c4sLE_info:
         const _c4sLE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.212140354 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4sMk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sMy; else goto c4sMz;
       c4sMy: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sMz: // global
           I64[Sp - 8] = block_c4sMh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sMD; else goto c4sMi;
       u4sMD: // global
           call _c4sMh(R1) args: 0, res: 0, upd: 0;
       c4sMi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info" {
     GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info:
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sMh() //  [R1]
         { []
         }
     {offset
       c4sMh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sMC; else goto c4sMB;
       c4sMC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sMB: // global
           (_c4sMq::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4sMq::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sMh_info" {
     block_c4sMh_info:
         const _c4sMh;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.218811064 UTC

[section ""data" . GHC.Int.$fBitsInt1_closure" {
     GHC.Int.$fBitsInt1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.220966673 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt16_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt16_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c4sMV: // global
           R1 = GHC.Int.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cfiniteBitSize_info" {
     GHC.Int.$fBitsInt16_$cfiniteBitSize_info:
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.22584423 UTC

[section ""data" . GHC.Int.$fNumInt32_$cfromInteger_closure" {
     GHC.Int.$fNumInt32_$cfromInteger_closure:
         const GHC.Int.$fNumInt32_$cfromInteger_info;
 },
 GHC.Int.$fNumInt32_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c4sN9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sNg; else goto c4sNh;
       c4sNg: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sNh: // global
           I64[Sp - 8] = block_c4sN7_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$cfromInteger_info" {
     GHC.Int.$fNumInt32_$cfromInteger_info:
         const GHC.Int.$fNumInt32_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sN7() //  [R1]
         { []
         }
     {offset
       c4sN7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sNk; else goto c4sNj;
       c4sNk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4sNj: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sN7_info" {
     block_c4sN7_info:
         const _c4sN7;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.23206845 UTC

[section ""data" . GHC.Int.$fNumInt32_$cnegate_closure" {
     GHC.Int.$fNumInt32_$cnegate_closure:
         const GHC.Int.$fNumInt32_$cnegate_info;
 },
 GHC.Int.$fNumInt32_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c4sNC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sNM; else goto c4sNN;
       c4sNM: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sNN: // global
           I64[Sp - 8] = block_c4sNz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sNR; else goto c4sNA;
       u4sNR: // global
           call _c4sNz(R1) args: 0, res: 0, upd: 0;
       c4sNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$cnegate_info" {
     GHC.Int.$fNumInt32_$cnegate_info:
         const GHC.Int.$fNumInt32_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sNz() //  [R1]
         { []
         }
     {offset
       c4sNz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sNQ; else goto c4sNP;
       c4sNQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sNP: // global
           _s4l3F::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3F::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sNz_info" {
     block_c4sNz_info:
         const _c4sNz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.23873465 UTC

[section ""data" . GHC.Int.$fNumInt32_$c*_closure" {
     GHC.Int.$fNumInt32_$c*_closure:
         const GHC.Int.$fNumInt32_$c*_info;
 },
 GHC.Int.$fNumInt32_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sOa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sOp; else goto c4sOq;
       c4sOp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sOq: // global
           I64[Sp - 16] = block_c4sO7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sOw; else goto c4sO8;
       u4sOw: // global
           call _c4sO7(R1) args: 0, res: 0, upd: 0;
       c4sO8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$c*_info" {
     GHC.Int.$fNumInt32_$c*_info:
         const GHC.Int.$fNumInt32_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sO7() //  [R1]
         { []
         }
     {offset
       c4sO7: // global
           I64[Sp] = block_c4sOd_info;
           _s4l3J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3J::I64;
           if (R1 & 7 != 0) goto u4sOv; else goto c4sOe;
       u4sOv: // global
           call _c4sOd(R1) args: 0, res: 0, upd: 0;
       c4sOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sO7_info" {
     block_c4sO7_info:
         const _c4sO7;
         const 1;
         const 30;
 },
 _c4sOd() //  [R1]
         { []
         }
     {offset
       c4sOd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sOu; else goto c4sOt;
       c4sOu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sOt: // global
           _s4l3N::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3N::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sOd_info" {
     block_c4sOd_info:
         const _c4sOd;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.249310706 UTC

[section ""data" . GHC.Int.$fNumInt32_$c-_closure" {
     GHC.Int.$fNumInt32_$c-_closure:
         const GHC.Int.$fNumInt32_$c-_info;
 },
 GHC.Int.$fNumInt32_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sOV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sPa; else goto c4sPb;
       c4sPa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sPb: // global
           I64[Sp - 16] = block_c4sOS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sPh; else goto c4sOT;
       u4sPh: // global
           call _c4sOS(R1) args: 0, res: 0, upd: 0;
       c4sOT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$c-_info" {
     GHC.Int.$fNumInt32_$c-_info:
         const GHC.Int.$fNumInt32_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sOS() //  [R1]
         { []
         }
     {offset
       c4sOS: // global
           I64[Sp] = block_c4sOY_info;
           _s4l3R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3R::I64;
           if (R1 & 7 != 0) goto u4sPg; else goto c4sOZ;
       u4sPg: // global
           call _c4sOY(R1) args: 0, res: 0, upd: 0;
       c4sOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sOS_info" {
     block_c4sOS_info:
         const _c4sOS;
         const 1;
         const 30;
 },
 _c4sOY() //  [R1]
         { []
         }
     {offset
       c4sOY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sPf; else goto c4sPe;
       c4sPf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sPe: // global
           _s4l3V::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l3V::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sOY_info" {
     block_c4sOY_info:
         const _c4sOY;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.257829109 UTC

[section ""data" . GHC.Int.$fNumInt32_$c+_closure" {
     GHC.Int.$fNumInt32_$c+_closure:
         const GHC.Int.$fNumInt32_$c+_info;
 },
 GHC.Int.$fNumInt32_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sPG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sPV; else goto c4sPW;
       c4sPV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sPW: // global
           I64[Sp - 16] = block_c4sPD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sQ2; else goto c4sPE;
       u4sQ2: // global
           call _c4sPD(R1) args: 0, res: 0, upd: 0;
       c4sPE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$c+_info" {
     GHC.Int.$fNumInt32_$c+_info:
         const GHC.Int.$fNumInt32_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sPD() //  [R1]
         { []
         }
     {offset
       c4sPD: // global
           I64[Sp] = block_c4sPJ_info;
           _s4l3Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l3Z::I64;
           if (R1 & 7 != 0) goto u4sQ1; else goto c4sPK;
       u4sQ1: // global
           call _c4sPJ(R1) args: 0, res: 0, upd: 0;
       c4sPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sPD_info" {
     block_c4sPD_info:
         const _c4sPD;
         const 1;
         const 30;
 },
 _c4sPJ() //  [R1]
         { []
         }
     {offset
       c4sPJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sQ0; else goto c4sPZ;
       c4sQ0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sPZ: // global
           _s4l43::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l43::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sPJ_info" {
     block_c4sPJ_info:
         const _c4sPJ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.266105847 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt32_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt32_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt32_$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c4sQr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sQs; else goto c4sQt;
       c4sQs: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sQt: // global
           I64[Sp - 8] = block_c4sQo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sQx; else goto c4sQp;
       u4sQx: // global
           call _c4sQo(R1) args: 0, res: 0, upd: 0;
       c4sQp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$ctoInteger_info" {
     GHC.Int.$fIntegralInt32_$ctoInteger_info:
         const GHC.Int.$fIntegralInt32_$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sQo() //  [R1]
         { []
         }
     {offset
       c4sQo: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sQo_info" {
     block_c4sQo_info:
         const _c4sQo;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.272307404 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cpopCount_closure" {
     GHC.Int.$fBitsInt32_$cpopCount_closure:
         const GHC.Int.$fBitsInt32_$cpopCount_info;
 },
 GHC.Int.$fBitsInt32_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c4sQO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sR2; else goto c4sR3;
       c4sR2: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sR3: // global
           I64[Sp - 8] = block_c4sQL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sR7; else goto c4sQM;
       u4sR7: // global
           call _c4sQL(R1) args: 0, res: 0, upd: 0;
       c4sQM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cpopCount_info" {
     GHC.Int.$fBitsInt32_$cpopCount_info:
         const GHC.Int.$fBitsInt32_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sQL() //  [R1]
         { []
         }
     {offset
       c4sQL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sR6; else goto c4sR5;
       c4sR6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sR5: // global
           (_c4sQU::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4sQU::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sQL_info" {
     block_c4sQL_info:
         const _c4sQL;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.278916981 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sRp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sRB; else goto c4sRC;
       c4sRB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sRC: // global
           I64[Sp - 16] = block_c4sRm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sRI; else goto c4sRn;
       u4sRI: // global
           call _c4sRm(R1) args: 0, res: 0, upd: 0;
       c4sRn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cunsafeShiftR_info" {
     GHC.Int.$fBitsInt32_$cunsafeShiftR_info:
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sRm() //  [R1]
         { []
         }
     {offset
       c4sRm: // global
           I64[Sp] = block_c4sRs_info;
           _s4l4g::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4g::I64;
           if (R1 & 7 != 0) goto u4sRH; else goto c4sRt;
       u4sRH: // global
           call _c4sRs(R1) args: 0, res: 0, upd: 0;
       c4sRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sRm_info" {
     block_c4sRm_info:
         const _c4sRm;
         const 1;
         const 30;
 },
 _c4sRs() //  [R1]
         { []
         }
     {offset
       c4sRs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sRG; else goto c4sRF;
       c4sRG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sRF: // global
           _s4l4j::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l4j::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sRs_info" {
     block_c4sRs_info:
         const _c4sRs;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.286301013 UTC

[section ""data" . GHC.Int.$fBitsInt6_closure" {
     GHC.Int.$fBitsInt6_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.287854474 UTC

[section ""data" . GHC.Int.$fNumInt4_closure" {
     GHC.Int.$fNumInt4_closure:
         const GHC.Int.I32#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.29137581 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftR_closure" {
     GHC.Int.$fBitsInt32_$cshiftR_closure:
         const GHC.Int.$fBitsInt32_$cshiftR_info;
 },
 GHC.Int.$fBitsInt32_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sS7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sSb; else goto c4sSc;
       c4sSb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sSc: // global
           I64[Sp - 16] = block_c4sS4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sSC; else goto c4sS5;
       u4sSC: // global
           call _c4sS4(R1) args: 0, res: 0, upd: 0;
       c4sS5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cshiftR_info" {
     GHC.Int.$fBitsInt32_$cshiftR_info:
         const GHC.Int.$fBitsInt32_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sS4() //  [R1]
         { []
         }
     {offset
       c4sS4: // global
           I64[Sp] = block_c4sSa_info;
           _s4l4n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4n::I64;
           if (R1 & 7 != 0) goto u4sSB; else goto c4sSe;
       u4sSB: // global
           call _c4sSa(R1) args: 0, res: 0, upd: 0;
       c4sSe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sS4_info" {
     block_c4sS4_info:
         const _c4sS4;
         const 1;
         const 30;
 },
 _c4sSa() //  [R1]
         { []
         }
     {offset
       c4sSa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sSk; else goto c4sSj;
       c4sSk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sSj: // global
           _s4l4n::I64 = I64[Sp + 8];
           _s4l4p::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l4p::I64, 64)) goto c4sSt; else goto c4sSA;
       c4sSt: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l4n::I64, _s4l4p::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sSA: // global
           if (%MO_S_Ge_W64(_s4l4n::I64, 0)) goto c4sSy; else goto c4sSz;
       c4sSy: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sSz: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sSa_info" {
     block_c4sSa_info:
         const _c4sSa;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.300856228 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sT1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sTg; else goto c4sTh;
       c4sTg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sTh: // global
           I64[Sp - 16] = block_c4sSY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sTn; else goto c4sSZ;
       u4sTn: // global
           call _c4sSY(R1) args: 0, res: 0, upd: 0;
       c4sSZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cunsafeShiftL_info" {
     GHC.Int.$fBitsInt32_$cunsafeShiftL_info:
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sSY() //  [R1]
         { []
         }
     {offset
       c4sSY: // global
           I64[Sp] = block_c4sT4_info;
           _s4l4w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4w::I64;
           if (R1 & 7 != 0) goto u4sTm; else goto c4sT5;
       u4sTm: // global
           call _c4sT4(R1) args: 0, res: 0, upd: 0;
       c4sT5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sSY_info" {
     block_c4sSY_info:
         const _c4sSY;
         const 1;
         const 30;
 },
 _c4sT4() //  [R1]
         { []
         }
     {offset
       c4sT4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sTl; else goto c4sTk;
       c4sTl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sTk: // global
           _s4l4A::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l4A::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sT4_info" {
     block_c4sT4_info:
         const _c4sT4;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.310342869 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftL_closure" {
     GHC.Int.$fBitsInt32_$cshiftL_closure:
         const GHC.Int.$fBitsInt32_$cshiftL_info;
 },
 GHC.Int.$fBitsInt32_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sTK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sTO; else goto c4sTP;
       c4sTO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sTP: // global
           I64[Sp - 16] = block_c4sTH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sUc; else goto c4sTI;
       u4sUc: // global
           call _c4sTH(R1) args: 0, res: 0, upd: 0;
       c4sTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cshiftL_info" {
     GHC.Int.$fBitsInt32_$cshiftL_info:
         const GHC.Int.$fBitsInt32_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sTH() //  [R1]
         { []
         }
     {offset
       c4sTH: // global
           I64[Sp] = block_c4sTN_info;
           _s4l4E::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l4E::I64;
           if (R1 & 7 != 0) goto u4sUb; else goto c4sTR;
       u4sUb: // global
           call _c4sTN(R1) args: 0, res: 0, upd: 0;
       c4sTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sTH_info" {
     block_c4sTH_info:
         const _c4sTH;
         const 1;
         const 30;
 },
 _c4sTN() //  [R1]
         { []
         }
     {offset
       c4sTN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sTX; else goto c4sTW;
       c4sTX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sTW: // global
           _s4l4G::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l4G::I64, 64)) goto c4sU9; else goto c4sUa;
       c4sU9: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << _s4l4G::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sUa: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sTN_info" {
     block_c4sTN_info:
         const _c4sTN;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.318026174 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cisSigned_closure" {
     GHC.Int.$fBitsInt32_$cisSigned_closure:
         const GHC.Int.$fBitsInt32_$cisSigned_info;
 },
 GHC.Int.$fBitsInt32_$cisSigned_entry() //  []
         { []
         }
     {offset
       c4sUy: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cisSigned_info" {
     GHC.Int.$fBitsInt32_$cisSigned_info:
         const GHC.Int.$fBitsInt32_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.32320193 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotate_closure" {
     GHC.Int.$fBitsInt32_$crotate_closure:
         const GHC.Int.$fBitsInt32_$crotate_info;
 },
 GHC.Int.$fBitsInt32_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sUN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4sUR; else goto c4sUS;
       c4sUR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sUS: // global
           I64[Sp - 16] = block_c4sUK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sVO; else goto c4sUL;
       u4sVO: // global
           call _c4sUK(R1) args: 0, res: 0, upd: 0;
       c4sUL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$crotate_info" {
     GHC.Int.$fBitsInt32_$crotate_info:
         const GHC.Int.$fBitsInt32_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sUK() //  [R1]
         { []
         }
     {offset
       c4sUK: // global
           I64[Sp - 8] = block_c4sUQ_info;
           _s4l4N::P64 = R1;
           _s4l4O::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l4O::I64;
           P64[Sp + 8] = _s4l4N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sVN; else goto c4sUU;
       u4sVN: // global
           call _c4sUQ(R1) args: 0, res: 0, upd: 0;
       c4sUU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sUK_info" {
     block_c4sUK_info:
         const _c4sUK;
         const 1;
         const 30;
 },
 _c4sUQ() //  [R1]
         { []
         }
     {offset
       c4sUQ: // global
           _s4l4T::I64 = I64[R1 + 7] & 31;
           if (_s4l4T::I64 != 0) goto u4sVL; else goto c4sVH;
       u4sVL: // global
           I64[Sp + 16] = _s4l4T::I64;
           Sp = Sp + 8;
           call _c4sV9() args: 0, res: 0, upd: 0;
       c4sVH: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sUQ_info" {
     block_c4sUQ_info:
         const _c4sUQ;
         const 66;
         const 30;
 },
 _c4sV9() //  []
         { []
         }
     {offset
       c4sV9: // global
           Hp = Hp + 16;
           _s4l4T::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4sVE; else goto c4sVD;
       c4sVE: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4sV8_info;
           R1 = _s4l4T::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4sVD: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4l4U::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4l4U::I64 << _s4l4T::I64) | (_s4l4U::I64 >> 32 - _s4l4T::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4sV8() //  [R1]
         { []
         }
     {offset
       c4sV8: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4sV9() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4sV8_info" {
     block_c4sV8_info:
         const _c4sV8;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.335296823 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshift_closure" {
     GHC.Int.$fBitsInt32_$cshift_closure:
         const GHC.Int.$fBitsInt32_$cshift_info;
 },
 GHC.Int.$fBitsInt32_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sWr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sWv; else goto c4sWw;
       c4sWv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sWw: // global
           I64[Sp - 16] = block_c4sWo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sXj; else goto c4sWp;
       u4sXj: // global
           call _c4sWo(R1) args: 0, res: 0, upd: 0;
       c4sWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cshift_info" {
     GHC.Int.$fBitsInt32_$cshift_info:
         const GHC.Int.$fBitsInt32_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sWo() //  [R1]
         { []
         }
     {offset
       c4sWo: // global
           I64[Sp] = block_c4sWu_info;
           _s4l55::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l55::I64;
           if (R1 & 7 != 0) goto u4sXi; else goto c4sWy;
       u4sXi: // global
           call _c4sWu(R1) args: 0, res: 0, upd: 0;
       c4sWy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sWo_info" {
     block_c4sWo_info:
         const _c4sWo;
         const 1;
         const 30;
 },
 _c4sWu() //  [R1]
         { []
         }
     {offset
       c4sWu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sWE; else goto c4sWD;
       c4sWE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sWD: // global
           _s4l55::I64 = I64[Sp + 8];
           _s4l57::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l57::I64, 0)) goto c4sX2; else goto c4sXh;
       c4sX2: // global
           _s4l59::I64 = -_s4l57::I64;
           if (%MO_S_Lt_W64(_s4l59::I64, 64)) goto c4sWT; else goto c4sX0;
       c4sWT: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l55::I64, _s4l59::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sX0: // global
           if (%MO_S_Ge_W64(_s4l55::I64, 0)) goto c4sXg; else goto c4sWZ;
       c4sWZ: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sXh: // global
           if (%MO_S_Ge_W64(_s4l57::I64, 64)) goto c4sXg; else goto c4sXf;
       c4sXg: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4sXf: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4l55::I64 << _s4l57::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sWu_info" {
     block_c4sWu_info:
         const _c4sWu;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.344564187 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplement_closure" {
     GHC.Int.$fBitsInt32_$ccomplement_closure:
         const GHC.Int.$fBitsInt32_$ccomplement_info;
 },
 GHC.Int.$fBitsInt32_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c4sXL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4sXY; else goto c4sXZ;
       c4sXY: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4sXZ: // global
           I64[Sp - 8] = block_c4sXI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4sY3; else goto c4sXJ;
       u4sY3: // global
           call _c4sXI(R1) args: 0, res: 0, upd: 0;
       c4sXJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$ccomplement_info" {
     GHC.Int.$fBitsInt32_$ccomplement_info:
         const GHC.Int.$fBitsInt32_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4sXI() //  [R1]
         { []
         }
     {offset
       c4sXI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sY2; else goto c4sY1;
       c4sY2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sY1: // global
           _s4l5l::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sXI_info" {
     block_c4sXI_info:
         const _c4sXI;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.350936123 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cxor_closure" {
     GHC.Int.$fBitsInt32_$cxor_closure:
         const GHC.Int.$fBitsInt32_$cxor_info;
 },
 GHC.Int.$fBitsInt32_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c4sYl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sYG; else goto c4sYH;
       c4sYG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sYH: // global
           I64[Sp - 16] = block_c4sYi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sYN; else goto c4sYj;
       u4sYN: // global
           call _c4sYi(R1) args: 0, res: 0, upd: 0;
       c4sYj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cxor_info" {
     GHC.Int.$fBitsInt32_$cxor_info:
         const GHC.Int.$fBitsInt32_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sYi() //  [R1]
         { []
         }
     {offset
       c4sYi: // global
           I64[Sp] = block_c4sYo_info;
           _s4l5p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5p::I64;
           if (R1 & 7 != 0) goto u4sYM; else goto c4sYp;
       u4sYM: // global
           call _c4sYo(R1) args: 0, res: 0, upd: 0;
       c4sYp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sYi_info" {
     block_c4sYi_info:
         const _c4sYi;
         const 1;
         const 30;
 },
 _c4sYo() //  [R1]
         { []
         }
     {offset
       c4sYo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sYL; else goto c4sYK;
       c4sYL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sYK: // global
           _s4l5v::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5v::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sYo_info" {
     block_c4sYo_info:
         const _c4sYo;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.35975717 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.|._closure" {
     GHC.Int.$fBitsInt32_$c.|._closure:
         const GHC.Int.$fBitsInt32_$c.|._info;
 },
 GHC.Int.$fBitsInt32_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c4sZb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4sZw; else goto c4sZx;
       c4sZw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4sZx: // global
           I64[Sp - 16] = block_c4sZ8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4sZD; else goto c4sZ9;
       u4sZD: // global
           call _c4sZ8(R1) args: 0, res: 0, upd: 0;
       c4sZ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$c.|._info" {
     GHC.Int.$fBitsInt32_$c.|._info:
         const GHC.Int.$fBitsInt32_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sZ8() //  [R1]
         { []
         }
     {offset
       c4sZ8: // global
           I64[Sp] = block_c4sZe_info;
           _s4l5z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5z::I64;
           if (R1 & 7 != 0) goto u4sZC; else goto c4sZf;
       u4sZC: // global
           call _c4sZe(R1) args: 0, res: 0, upd: 0;
       c4sZf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sZ8_info" {
     block_c4sZ8_info:
         const _c4sZ8;
         const 1;
         const 30;
 },
 _c4sZe() //  [R1]
         { []
         }
     {offset
       c4sZe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4sZB; else goto c4sZA;
       c4sZB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4sZA: // global
           _s4l5F::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5F::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sZe_info" {
     block_c4sZe_info:
         const _c4sZe;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.368701645 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.&._closure" {
     GHC.Int.$fBitsInt32_$c.&._closure:
         const GHC.Int.$fBitsInt32_$c.&._info;
 },
 GHC.Int.$fBitsInt32_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c4t01: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t0m; else goto c4t0n;
       c4t0m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t0n: // global
           I64[Sp - 16] = block_c4sZY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t0t; else goto c4sZZ;
       u4t0t: // global
           call _c4sZY(R1) args: 0, res: 0, upd: 0;
       c4sZZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$c.&._info" {
     GHC.Int.$fBitsInt32_$c.&._info:
         const GHC.Int.$fBitsInt32_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4sZY() //  [R1]
         { []
         }
     {offset
       c4sZY: // global
           I64[Sp] = block_c4t04_info;
           _s4l5J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l5J::I64;
           if (R1 & 7 != 0) goto u4t0s; else goto c4t05;
       u4t0s: // global
           call _c4t04(R1) args: 0, res: 0, upd: 0;
       c4t05: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4sZY_info" {
     block_c4sZY_info:
         const _c4sZY;
         const 1;
         const 30;
 },
 _c4t04() //  [R1]
         { []
         }
     {offset
       c4t04: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t0r; else goto c4t0q;
       c4t0r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t0q: // global
           _s4l5P::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4l5P::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t04_info" {
     block_c4t04_info:
         const _c4t04;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.376793803 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4t0R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t15; else goto c4t16;
       c4t15: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t16: // global
           I64[Sp - 8] = block_c4t0O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4t1a; else goto c4t0P;
       u4t1a: // global
           call _c4t0O(R1) args: 0, res: 0, upd: 0;
       c4t0P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info" {
     GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info:
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4t0O() //  [R1]
         { []
         }
     {offset
       c4t0O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t19; else goto c4t18;
       c4t19: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t18: // global
           (_c4t0X::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4t0X::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t0O_info" {
     block_c4t0O_info:
         const _c4t0O;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.384417233 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4t1u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t1I; else goto c4t1J;
       c4t1I: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t1J: // global
           I64[Sp - 8] = block_c4t1r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4t1N; else goto c4t1s;
       u4t1N: // global
           call _c4t1r(R1) args: 0, res: 0, upd: 0;
       c4t1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info" {
     GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info:
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4t1r() //  [R1]
         { []
         }
     {offset
       c4t1r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t1M; else goto c4t1L;
       c4t1M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t1L: // global
           (_c4t1A::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4t1A::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t1r_info" {
     block_c4t1r_info:
         const _c4t1r;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.389668592 UTC

[section ""data" . GHC.Int.$fBitsInt4_closure" {
     GHC.Int.$fBitsInt4_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.391815645 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt32_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt32_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c4t25: // global
           R1 = GHC.Int.$fBitsInt4_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cfiniteBitSize_info" {
     GHC.Int.$fBitsInt32_$cfiniteBitSize_info:
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.396009785 UTC

[section ""data" . GHC.Int.$fNumInt64_$cfromInteger_closure" {
     GHC.Int.$fNumInt64_$cfromInteger_closure:
         const GHC.Int.$fNumInt64_$cfromInteger_info;
 },
 GHC.Int.$fNumInt64_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c4t2j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t2n; else goto c4t2o;
       c4t2n: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t2o: // global
           I64[Sp - 8] = block_c4t2h_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$cfromInteger_info" {
     GHC.Int.$fNumInt64_$cfromInteger_info:
         const GHC.Int.$fNumInt64_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4t2h() //  [R1]
         { []
         }
     {offset
       c4t2h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t2r; else goto c4t2q;
       c4t2r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4t2q: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t2h_info" {
     block_c4t2h_info:
         const _c4t2h;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.402284556 UTC

[section ""data" . GHC.Int.$fNumInt64_$cnegate_closure" {
     GHC.Int.$fNumInt64_$cnegate_closure:
         const GHC.Int.$fNumInt64_$cnegate_info;
 },
 GHC.Int.$fNumInt64_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c4t2I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t2P; else goto c4t2Q;
       c4t2P: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t2Q: // global
           I64[Sp - 8] = block_c4t2F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4t2U; else goto c4t2G;
       u4t2U: // global
           call _c4t2F(R1) args: 0, res: 0, upd: 0;
       c4t2G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$cnegate_info" {
     GHC.Int.$fNumInt64_$cnegate_info:
         const GHC.Int.$fNumInt64_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4t2F() //  [R1]
         { []
         }
     {offset
       c4t2F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t2T; else goto c4t2S;
       c4t2T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t2S: // global
           _s4l68::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l68::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t2F_info" {
     block_c4t2F_info:
         const _c4t2F;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.41053417 UTC

[section ""data" . GHC.Int.$fNumInt64_$c*_closure" {
     GHC.Int.$fNumInt64_$c*_closure:
         const GHC.Int.$fNumInt64_$c*_info;
 },
 GHC.Int.$fNumInt64_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c4t3c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t3o; else goto c4t3p;
       c4t3o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t3p: // global
           I64[Sp - 16] = block_c4t39_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t3v; else goto c4t3a;
       u4t3v: // global
           call _c4t39(R1) args: 0, res: 0, upd: 0;
       c4t3a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$c*_info" {
     GHC.Int.$fNumInt64_$c*_info:
         const GHC.Int.$fNumInt64_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4t39() //  [R1]
         { []
         }
     {offset
       c4t39: // global
           I64[Sp] = block_c4t3f_info;
           _s4l6c::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6c::I64;
           if (R1 & 7 != 0) goto u4t3u; else goto c4t3g;
       u4t3u: // global
           call _c4t3f(R1) args: 0, res: 0, upd: 0;
       c4t3g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t39_info" {
     block_c4t39_info:
         const _c4t39;
         const 1;
         const 30;
 },
 _c4t3f() //  [R1]
         { []
         }
     {offset
       c4t3f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t3t; else goto c4t3s;
       c4t3t: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t3s: // global
           _s4l6f::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6f::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t3f_info" {
     block_c4t3f_info:
         const _c4t3f;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.419068624 UTC

[section ""data" . GHC.Int.$fNumInt64_$c-_closure" {
     GHC.Int.$fNumInt64_$c-_closure:
         const GHC.Int.$fNumInt64_$c-_info;
 },
 GHC.Int.$fNumInt64_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c4t3T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t45; else goto c4t46;
       c4t45: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t46: // global
           I64[Sp - 16] = block_c4t3Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t4c; else goto c4t3R;
       u4t4c: // global
           call _c4t3Q(R1) args: 0, res: 0, upd: 0;
       c4t3R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$c-_info" {
     GHC.Int.$fNumInt64_$c-_info:
         const GHC.Int.$fNumInt64_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4t3Q() //  [R1]
         { []
         }
     {offset
       c4t3Q: // global
           I64[Sp] = block_c4t3W_info;
           _s4l6j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6j::I64;
           if (R1 & 7 != 0) goto u4t4b; else goto c4t3X;
       u4t4b: // global
           call _c4t3W(R1) args: 0, res: 0, upd: 0;
       c4t3X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t3Q_info" {
     block_c4t3Q_info:
         const _c4t3Q;
         const 1;
         const 30;
 },
 _c4t3W() //  [R1]
         { []
         }
     {offset
       c4t3W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t4a; else goto c4t49;
       c4t4a: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t49: // global
           _s4l6m::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6m::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t3W_info" {
     block_c4t3W_info:
         const _c4t3W;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.428278702 UTC

[section ""data" . GHC.Int.$fNumInt64_$c+_closure" {
     GHC.Int.$fNumInt64_$c+_closure:
         const GHC.Int.$fNumInt64_$c+_info;
 },
 GHC.Int.$fNumInt64_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c4t4A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t4M; else goto c4t4N;
       c4t4M: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t4N: // global
           I64[Sp - 16] = block_c4t4x_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t4T; else goto c4t4y;
       u4t4T: // global
           call _c4t4x(R1) args: 0, res: 0, upd: 0;
       c4t4y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$c+_info" {
     GHC.Int.$fNumInt64_$c+_info:
         const GHC.Int.$fNumInt64_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4t4x() //  [R1]
         { []
         }
     {offset
       c4t4x: // global
           I64[Sp] = block_c4t4D_info;
           _s4l6q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6q::I64;
           if (R1 & 7 != 0) goto u4t4S; else goto c4t4E;
       u4t4S: // global
           call _c4t4D(R1) args: 0, res: 0, upd: 0;
       c4t4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t4x_info" {
     block_c4t4x_info:
         const _c4t4x;
         const 1;
         const 30;
 },
 _c4t4D() //  [R1]
         { []
         }
     {offset
       c4t4D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t4R; else goto c4t4Q;
       c4t4R: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t4Q: // global
           _s4l6t::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t4D_info" {
     block_c4t4D_info:
         const _c4t4D;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.435619155 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt64_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt64_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt64_$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c4t5h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t5i; else goto c4t5j;
       c4t5i: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t5j: // global
           I64[Sp - 8] = block_c4t5e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4t5n; else goto c4t5f;
       u4t5n: // global
           call _c4t5e(R1) args: 0, res: 0, upd: 0;
       c4t5f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$ctoInteger_info" {
     GHC.Int.$fIntegralInt64_$ctoInteger_info:
         const GHC.Int.$fIntegralInt64_$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4t5e() //  [R1]
         { []
         }
     {offset
       c4t5e: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t5e_info" {
     block_c4t5e_info:
         const _c4t5e;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.441598102 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cpopCount_closure" {
     GHC.Int.$fBitsInt64_$cpopCount_closure:
         const GHC.Int.$fBitsInt64_$cpopCount_info;
 },
 GHC.Int.$fBitsInt64_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c4t5E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4t5S; else goto c4t5T;
       c4t5S: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4t5T: // global
           I64[Sp - 8] = block_c4t5B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4t5X; else goto c4t5C;
       u4t5X: // global
           call _c4t5B(R1) args: 0, res: 0, upd: 0;
       c4t5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cpopCount_info" {
     GHC.Int.$fBitsInt64_$cpopCount_info:
         const GHC.Int.$fBitsInt64_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4t5B() //  [R1]
         { []
         }
     {offset
       c4t5B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t5W; else goto c4t5V;
       c4t5W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t5V: // global
           (_c4t5K::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4t5K::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t5B_info" {
     block_c4t5B_info:
         const _c4t5B;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.448586241 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4t6f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t6r; else goto c4t6s;
       c4t6r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t6s: // global
           I64[Sp - 16] = block_c4t6c_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t6y; else goto c4t6d;
       u4t6y: // global
           call _c4t6c(R1) args: 0, res: 0, upd: 0;
       c4t6d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cunsafeShiftR_info" {
     GHC.Int.$fBitsInt64_$cunsafeShiftR_info:
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4t6c() //  [R1]
         { []
         }
     {offset
       c4t6c: // global
           I64[Sp] = block_c4t6i_info;
           _s4l6G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6G::I64;
           if (R1 & 7 != 0) goto u4t6x; else goto c4t6j;
       u4t6x: // global
           call _c4t6i(R1) args: 0, res: 0, upd: 0;
       c4t6j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t6c_info" {
     block_c4t6c_info:
         const _c4t6c;
         const 1;
         const 30;
 },
 _c4t6i() //  [R1]
         { []
         }
     {offset
       c4t6i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t6w; else goto c4t6v;
       c4t6w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t6v: // global
           _s4l6J::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6J::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t6i_info" {
     block_c4t6i_info:
         const _c4t6i;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.456909208 UTC

[section ""data" . GHC.Int.$fBitsInt10_closure" {
     GHC.Int.$fBitsInt10_closure:
         const GHC.Int.I64#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.459740457 UTC

[section ""data" . GHC.Int.$fNumInt6_closure" {
     GHC.Int.$fNumInt6_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.465215575 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftR_closure" {
     GHC.Int.$fBitsInt64_$cshiftR_closure:
         const GHC.Int.$fBitsInt64_$cshiftR_info;
 },
 GHC.Int.$fBitsInt64_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4t6X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t71; else goto c4t72;
       c4t71: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t72: // global
           I64[Sp - 16] = block_c4t6U_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t7s; else goto c4t6V;
       u4t7s: // global
           call _c4t6U(R1) args: 0, res: 0, upd: 0;
       c4t6V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cshiftR_info" {
     GHC.Int.$fBitsInt64_$cshiftR_info:
         const GHC.Int.$fBitsInt64_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4t6U() //  [R1]
         { []
         }
     {offset
       c4t6U: // global
           I64[Sp] = block_c4t70_info;
           _s4l6N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6N::I64;
           if (R1 & 7 != 0) goto u4t7r; else goto c4t74;
       u4t7r: // global
           call _c4t70(R1) args: 0, res: 0, upd: 0;
       c4t74: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t6U_info" {
     block_c4t6U_info:
         const _c4t6U;
         const 1;
         const 30;
 },
 _c4t70() //  [R1]
         { []
         }
     {offset
       c4t70: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t7a; else goto c4t79;
       c4t7a: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t79: // global
           _s4l6N::I64 = I64[Sp + 8];
           _s4l6P::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l6P::I64, 64)) goto c4t7j; else goto c4t7q;
       c4t7j: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l6N::I64, _s4l6P::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4t7q: // global
           if (%MO_S_Ge_W64(_s4l6N::I64, 0)) goto c4t7o; else goto c4t7p;
       c4t7o: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4t7p: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t70_info" {
     block_c4t70_info:
         const _c4t70;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.478937909 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4t7R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t83; else goto c4t84;
       c4t83: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t84: // global
           I64[Sp - 16] = block_c4t7O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t8a; else goto c4t7P;
       u4t8a: // global
           call _c4t7O(R1) args: 0, res: 0, upd: 0;
       c4t7P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cunsafeShiftL_info" {
     GHC.Int.$fBitsInt64_$cunsafeShiftL_info:
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4t7O() //  [R1]
         { []
         }
     {offset
       c4t7O: // global
           I64[Sp] = block_c4t7U_info;
           _s4l6W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l6W::I64;
           if (R1 & 7 != 0) goto u4t89; else goto c4t7V;
       u4t89: // global
           call _c4t7U(R1) args: 0, res: 0, upd: 0;
       c4t7V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t7O_info" {
     block_c4t7O_info:
         const _c4t7O;
         const 1;
         const 30;
 },
 _c4t7U() //  [R1]
         { []
         }
     {offset
       c4t7U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t88; else goto c4t87;
       c4t88: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t87: // global
           _s4l6Z::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l6Z::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t7U_info" {
     block_c4t7U_info:
         const _c4t7U;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.492154061 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftL_closure" {
     GHC.Int.$fBitsInt64_$cshiftL_closure:
         const GHC.Int.$fBitsInt64_$cshiftL_info;
 },
 GHC.Int.$fBitsInt64_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4t8x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4t8B; else goto c4t8C;
       c4t8B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t8C: // global
           I64[Sp - 16] = block_c4t8u_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4t8W; else goto c4t8v;
       u4t8W: // global
           call _c4t8u(R1) args: 0, res: 0, upd: 0;
       c4t8v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cshiftL_info" {
     GHC.Int.$fBitsInt64_$cshiftL_info:
         const GHC.Int.$fBitsInt64_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4t8u() //  [R1]
         { []
         }
     {offset
       c4t8u: // global
           I64[Sp] = block_c4t8A_info;
           _s4l73::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l73::I64;
           if (R1 & 7 != 0) goto u4t8V; else goto c4t8E;
       u4t8V: // global
           call _c4t8A(R1) args: 0, res: 0, upd: 0;
       c4t8E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t8u_info" {
     block_c4t8u_info:
         const _c4t8u;
         const 1;
         const 30;
 },
 _c4t8A() //  [R1]
         { []
         }
     {offset
       c4t8A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4t8K; else goto c4t8J;
       c4t8K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4t8J: // global
           _s4l75::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l75::I64, 64)) goto c4t8T; else goto c4t8U;
       c4t8T: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s4l75::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4t8U: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t8A_info" {
     block_c4t8A_info:
         const _c4t8A;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.504501663 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cisSigned_closure" {
     GHC.Int.$fBitsInt64_$cisSigned_closure:
         const GHC.Int.$fBitsInt64_$cisSigned_info;
 },
 GHC.Int.$fBitsInt64_$cisSigned_entry() //  []
         { []
         }
     {offset
       c4t9h: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cisSigned_info" {
     GHC.Int.$fBitsInt64_$cisSigned_info:
         const GHC.Int.$fBitsInt64_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.512749147 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotate_closure" {
     GHC.Int.$fBitsInt64_$crotate_closure:
         const GHC.Int.$fBitsInt64_$crotate_info;
 },
 GHC.Int.$fBitsInt64_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c4t9w: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4t9A; else goto c4t9B;
       c4t9A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4t9B: // global
           I64[Sp - 16] = block_c4t9t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tar; else goto c4t9u;
       u4tar: // global
           call _c4t9t(R1) args: 0, res: 0, upd: 0;
       c4t9u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$crotate_info" {
     GHC.Int.$fBitsInt64_$crotate_info:
         const GHC.Int.$fBitsInt64_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4t9t() //  [R1]
         { []
         }
     {offset
       c4t9t: // global
           I64[Sp - 8] = block_c4t9z_info;
           _s4l7b::P64 = R1;
           _s4l7c::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l7c::I64;
           P64[Sp + 8] = _s4l7b::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4taq; else goto c4t9D;
       u4taq: // global
           call _c4t9z(R1) args: 0, res: 0, upd: 0;
       c4t9D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t9t_info" {
     block_c4t9t_info:
         const _c4t9t;
         const 1;
         const 30;
 },
 _c4t9z() //  [R1]
         { []
         }
     {offset
       c4t9z: // global
           _s4l7h::I64 = I64[R1 + 7] & 63;
           if (_s4l7h::I64 != 0) goto u4tao; else goto c4tak;
       u4tao: // global
           I64[Sp + 16] = _s4l7h::I64;
           Sp = Sp + 8;
           call _c4t9S() args: 0, res: 0, upd: 0;
       c4tak: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4t9z_info" {
     block_c4t9z_info:
         const _c4t9z;
         const 66;
         const 30;
 },
 _c4t9S() //  []
         { []
         }
     {offset
       c4t9S: // global
           Hp = Hp + 16;
           _s4l7h::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4tah; else goto c4tag;
       c4tah: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4t9R_info;
           R1 = _s4l7h::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4tag: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4l7i::I64 = I64[Sp];
           I64[Hp] = (_s4l7i::I64 << _s4l7h::I64) | (_s4l7i::I64 >> 64 - _s4l7h::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4t9R() //  [R1]
         { []
         }
     {offset
       c4t9R: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4t9S() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4t9R_info" {
     block_c4t9R_info:
         const _c4t9R;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.5303361 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshift_closure" {
     GHC.Int.$fBitsInt64_$cshift_closure:
         const GHC.Int.$fBitsInt64_$cshift_info;
 },
 GHC.Int.$fBitsInt64_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tb2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tb6; else goto c4tb7;
       c4tb6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tb7: // global
           I64[Sp - 16] = block_c4taZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tbR; else goto c4tb0;
       u4tbR: // global
           call _c4taZ(R1) args: 0, res: 0, upd: 0;
       c4tb0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cshift_info" {
     GHC.Int.$fBitsInt64_$cshift_info:
         const GHC.Int.$fBitsInt64_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4taZ() //  [R1]
         { []
         }
     {offset
       c4taZ: // global
           I64[Sp] = block_c4tb5_info;
           _s4l7r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7r::I64;
           if (R1 & 7 != 0) goto u4tbQ; else goto c4tb9;
       u4tbQ: // global
           call _c4tb5(R1) args: 0, res: 0, upd: 0;
       c4tb9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4taZ_info" {
     block_c4taZ_info:
         const _c4taZ;
         const 1;
         const 30;
 },
 _c4tb5() //  [R1]
         { []
         }
     {offset
       c4tb5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tbf; else goto c4tbe;
       c4tbf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tbe: // global
           _s4l7r::I64 = I64[Sp + 8];
           _s4l7t::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l7t::I64, 0)) goto c4tbD; else goto c4tbP;
       c4tbD: // global
           _s4l7v::I64 = -_s4l7t::I64;
           if (%MO_S_Lt_W64(_s4l7v::I64, 64)) goto c4tbu; else goto c4tbB;
       c4tbu: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4l7r::I64, _s4l7v::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tbB: // global
           if (%MO_S_Ge_W64(_s4l7r::I64, 0)) goto c4tbO; else goto c4tbA;
       c4tbA: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tbP: // global
           if (%MO_S_Ge_W64(_s4l7t::I64, 64)) goto c4tbO; else goto c4tbN;
       c4tbO: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tbN: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7r::I64 << _s4l7t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tb5_info" {
     block_c4tb5_info:
         const _c4tb5;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.54339758 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplement_closure" {
     GHC.Int.$fBitsInt64_$ccomplement_closure:
         const GHC.Int.$fBitsInt64_$ccomplement_info;
 },
 GHC.Int.$fBitsInt64_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c4tci: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tcv; else goto c4tcw;
       c4tcv: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tcw: // global
           I64[Sp - 8] = block_c4tcf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tcA; else goto c4tcg;
       u4tcA: // global
           call _c4tcf(R1) args: 0, res: 0, upd: 0;
       c4tcg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$ccomplement_info" {
     GHC.Int.$fBitsInt64_$ccomplement_info:
         const GHC.Int.$fBitsInt64_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4tcf() //  [R1]
         { []
         }
     {offset
       c4tcf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tcz; else goto c4tcy;
       c4tcz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tcy: // global
           _s4l7G::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7G::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tcf_info" {
     block_c4tcf_info:
         const _c4tcf;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.554016852 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cxor_closure" {
     GHC.Int.$fBitsInt64_$cxor_closure:
         const GHC.Int.$fBitsInt64_$cxor_info;
 },
 GHC.Int.$fBitsInt64_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tcT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tde; else goto c4tdf;
       c4tde: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tdf: // global
           I64[Sp - 16] = block_c4tcQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tdl; else goto c4tcR;
       u4tdl: // global
           call _c4tcQ(R1) args: 0, res: 0, upd: 0;
       c4tcR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cxor_info" {
     GHC.Int.$fBitsInt64_$cxor_info:
         const GHC.Int.$fBitsInt64_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tcQ() //  [R1]
         { []
         }
     {offset
       c4tcQ: // global
           I64[Sp] = block_c4tcW_info;
           _s4l7K::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7K::I64;
           if (R1 & 7 != 0) goto u4tdk; else goto c4tcX;
       u4tdk: // global
           call _c4tcW(R1) args: 0, res: 0, upd: 0;
       c4tcX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tcQ_info" {
     block_c4tcQ_info:
         const _c4tcQ;
         const 1;
         const 30;
 },
 _c4tcW() //  [R1]
         { []
         }
     {offset
       c4tcW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tdj; else goto c4tdi;
       c4tdj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tdi: // global
           _s4l7Q::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l7Q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tcW_info" {
     block_c4tcW_info:
         const _c4tcW;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.566001866 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.|._closure" {
     GHC.Int.$fBitsInt64_$c.|._closure:
         const GHC.Int.$fBitsInt64_$c.|._info;
 },
 GHC.Int.$fBitsInt64_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c4tdJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4te4; else goto c4te5;
       c4te4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4te5: // global
           I64[Sp - 16] = block_c4tdG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4teb; else goto c4tdH;
       u4teb: // global
           call _c4tdG(R1) args: 0, res: 0, upd: 0;
       c4tdH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$c.|._info" {
     GHC.Int.$fBitsInt64_$c.|._info:
         const GHC.Int.$fBitsInt64_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tdG() //  [R1]
         { []
         }
     {offset
       c4tdG: // global
           I64[Sp] = block_c4tdM_info;
           _s4l7U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l7U::I64;
           if (R1 & 7 != 0) goto u4tea; else goto c4tdN;
       u4tea: // global
           call _c4tdM(R1) args: 0, res: 0, upd: 0;
       c4tdN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tdG_info" {
     block_c4tdG_info:
         const _c4tdG;
         const 1;
         const 30;
 },
 _c4tdM() //  [R1]
         { []
         }
     {offset
       c4tdM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4te9; else goto c4te8;
       c4te9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4te8: // global
           _s4l80::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l80::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tdM_info" {
     block_c4tdM_info:
         const _c4tdM;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.575960242 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.&._closure" {
     GHC.Int.$fBitsInt64_$c.&._closure:
         const GHC.Int.$fBitsInt64_$c.&._info;
 },
 GHC.Int.$fBitsInt64_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c4tez: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4teU; else goto c4teV;
       c4teU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4teV: // global
           I64[Sp - 16] = block_c4tew_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tf1; else goto c4tex;
       u4tf1: // global
           call _c4tew(R1) args: 0, res: 0, upd: 0;
       c4tex: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$c.&._info" {
     GHC.Int.$fBitsInt64_$c.&._info:
         const GHC.Int.$fBitsInt64_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tew() //  [R1]
         { []
         }
     {offset
       c4tew: // global
           I64[Sp] = block_c4teC_info;
           _s4l84::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l84::I64;
           if (R1 & 7 != 0) goto u4tf0; else goto c4teD;
       u4tf0: // global
           call _c4teC(R1) args: 0, res: 0, upd: 0;
       c4teD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tew_info" {
     block_c4tew_info:
         const _c4tew;
         const 1;
         const 30;
 },
 _c4teC() //  [R1]
         { []
         }
     {offset
       c4teC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4teZ; else goto c4teY;
       c4teZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4teY: // global
           _s4l8a::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4l8a::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4teC_info" {
     block_c4teC_info:
         const _c4teC;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.586347013 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4tfp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tfD; else goto c4tfE;
       c4tfD: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tfE: // global
           I64[Sp - 8] = block_c4tfm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tfI; else goto c4tfn;
       u4tfI: // global
           call _c4tfm(R1) args: 0, res: 0, upd: 0;
       c4tfn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info" {
     GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info:
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4tfm() //  [R1]
         { []
         }
     {offset
       c4tfm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tfH; else goto c4tfG;
       c4tfH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tfG: // global
           (_c4tfv::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4tfv::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tfm_info" {
     block_c4tfm_info:
         const _c4tfm;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.592597991 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4tg2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tgg; else goto c4tgh;
       c4tgg: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tgh: // global
           I64[Sp - 8] = block_c4tfZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tgl; else goto c4tg0;
       u4tgl: // global
           call _c4tfZ(R1) args: 0, res: 0, upd: 0;
       c4tg0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info" {
     GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info:
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4tfZ() //  [R1]
         { []
         }
     {offset
       c4tfZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tgk; else goto c4tgj;
       c4tgk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tgj: // global
           (_c4tg8::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4tg8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tfZ_info" {
     block_c4tfZ_info:
         const _c4tfZ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.598313879 UTC

[section ""data" . GHC.Int.$fBitsInt7_closure" {
     GHC.Int.$fBitsInt7_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.601203762 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt64_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt64_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c4tgD: // global
           R1 = GHC.Int.$fBitsInt7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cfiniteBitSize_info" {
     GHC.Int.$fBitsInt64_$cfiniteBitSize_info:
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.606565922 UTC

[section ""data" . GHC.Int.eqInt8_closure" {
     GHC.Int.eqInt8_closure:
         const GHC.Int.eqInt8_info;
 },
 GHC.Int.eqInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tgS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tgW; else goto c4tgX;
       c4tgW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tgX: // global
           I64[Sp - 16] = block_c4tgP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4th6; else goto c4tgQ;
       u4th6: // global
           call _c4tgP(R1) args: 0, res: 0, upd: 0;
       c4tgQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.eqInt8_info" {
     GHC.Int.eqInt8_info:
         const GHC.Int.eqInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tgP() //  [R1]
         { []
         }
     {offset
       c4tgP: // global
           I64[Sp] = block_c4tgV_info;
           _s4l8r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8r::I64;
           if (R1 & 7 != 0) goto u4th5; else goto c4tgZ;
       u4th5: // global
           call _c4tgV(R1) args: 0, res: 0, upd: 0;
       c4tgZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tgP_info" {
     block_c4tgP_info:
         const _c4tgP;
         const 1;
         const 30;
 },
 _c4tgV() //  [R1]
         { []
         }
     {offset
       c4tgV: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tgV_info" {
     block_c4tgV_info:
         const _c4tgV;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.613878258 UTC

[section ""data" . GHC.Int.$fEqInt8_closure" {
     GHC.Int.$fEqInt8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt8_closure+2;
         const GHC.Int.neInt8_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.616989401 UTC

[section ""data" . GHC.Int.gtInt8_closure" {
     GHC.Int.gtInt8_closure:
         const GHC.Int.gtInt8_info;
 },
 GHC.Int.gtInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4thw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4thA; else goto c4thB;
       c4thA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4thB: // global
           I64[Sp - 16] = block_c4tht_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4thK; else goto c4thu;
       u4thK: // global
           call _c4tht(R1) args: 0, res: 0, upd: 0;
       c4thu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.gtInt8_info" {
     GHC.Int.gtInt8_info:
         const GHC.Int.gtInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tht() //  [R1]
         { []
         }
     {offset
       c4tht: // global
           I64[Sp] = block_c4thz_info;
           _s4l8y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8y::I64;
           if (R1 & 7 != 0) goto u4thJ; else goto c4thD;
       u4thJ: // global
           call _c4thz(R1) args: 0, res: 0, upd: 0;
       c4thD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tht_info" {
     block_c4tht_info:
         const _c4tht;
         const 1;
         const 30;
 },
 _c4thz() //  [R1]
         { []
         }
     {offset
       c4thz: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4thz_info" {
     block_c4thz_info:
         const _c4thz;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.6268244 UTC

[section ""data" . GHC.Int.geInt8_closure" {
     GHC.Int.geInt8_closure:
         const GHC.Int.geInt8_info;
 },
 GHC.Int.geInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ti9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tid; else goto c4tie;
       c4tid: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tie: // global
           I64[Sp - 16] = block_c4ti6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tin; else goto c4ti7;
       u4tin: // global
           call _c4ti6(R1) args: 0, res: 0, upd: 0;
       c4ti7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.geInt8_info" {
     GHC.Int.geInt8_info:
         const GHC.Int.geInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4ti6() //  [R1]
         { []
         }
     {offset
       c4ti6: // global
           I64[Sp] = block_c4tic_info;
           _s4l8F::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8F::I64;
           if (R1 & 7 != 0) goto u4tim; else goto c4tig;
       u4tim: // global
           call _c4tic(R1) args: 0, res: 0, upd: 0;
       c4tig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ti6_info" {
     block_c4ti6_info:
         const _c4ti6;
         const 1;
         const 30;
 },
 _c4tic() //  [R1]
         { []
         }
     {offset
       c4tic: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tic_info" {
     block_c4tic_info:
         const _c4tic;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.638773831 UTC

[section ""data" . GHC.Int.ltInt8_closure" {
     GHC.Int.ltInt8_closure:
         const GHC.Int.ltInt8_info;
 },
 GHC.Int.ltInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tiM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tiQ; else goto c4tiR;
       c4tiQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tiR: // global
           I64[Sp - 16] = block_c4tiJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tj0; else goto c4tiK;
       u4tj0: // global
           call _c4tiJ(R1) args: 0, res: 0, upd: 0;
       c4tiK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.ltInt8_info" {
     GHC.Int.ltInt8_info:
         const GHC.Int.ltInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tiJ() //  [R1]
         { []
         }
     {offset
       c4tiJ: // global
           I64[Sp] = block_c4tiP_info;
           _s4l8M::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8M::I64;
           if (R1 & 7 != 0) goto u4tiZ; else goto c4tiT;
       u4tiZ: // global
           call _c4tiP(R1) args: 0, res: 0, upd: 0;
       c4tiT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tiJ_info" {
     block_c4tiJ_info:
         const _c4tiJ;
         const 1;
         const 30;
 },
 _c4tiP() //  [R1]
         { []
         }
     {offset
       c4tiP: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tiP_info" {
     block_c4tiP_info:
         const _c4tiP;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.651184736 UTC

[section ""data" . GHC.Int.leInt8_closure" {
     GHC.Int.leInt8_closure:
         const GHC.Int.leInt8_info;
 },
 GHC.Int.leInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tjp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tjt; else goto c4tju;
       c4tjt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tju: // global
           I64[Sp - 16] = block_c4tjm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tjD; else goto c4tjn;
       u4tjD: // global
           call _c4tjm(R1) args: 0, res: 0, upd: 0;
       c4tjn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.leInt8_info" {
     GHC.Int.leInt8_info:
         const GHC.Int.leInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tjm() //  [R1]
         { []
         }
     {offset
       c4tjm: // global
           I64[Sp] = block_c4tjs_info;
           _s4l8T::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l8T::I64;
           if (R1 & 7 != 0) goto u4tjC; else goto c4tjw;
       u4tjC: // global
           call _c4tjs(R1) args: 0, res: 0, upd: 0;
       c4tjw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tjm_info" {
     block_c4tjm_info:
         const _c4tjm;
         const 1;
         const 30;
 },
 _c4tjs() //  [R1]
         { []
         }
     {offset
       c4tjs: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tjs_info" {
     block_c4tjs_info:
         const _c4tjs;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.661574672 UTC

[section ""data" . GHC.Int.$fOrdInt8_$ccompare_closure" {
     GHC.Int.$fOrdInt8_$ccompare_closure:
         const GHC.Int.$fOrdInt8_$ccompare_info;
 },
 GHC.Int.$fOrdInt8_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tk2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tk6; else goto c4tk7;
       c4tk6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tk7: // global
           I64[Sp - 16] = block_c4tjZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tkq; else goto c4tk0;
       u4tkq: // global
           call _c4tjZ(R1) args: 0, res: 0, upd: 0;
       c4tk0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt8_$ccompare_info" {
     GHC.Int.$fOrdInt8_$ccompare_info:
         const GHC.Int.$fOrdInt8_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tjZ() //  [R1]
         { []
         }
     {offset
       c4tjZ: // global
           I64[Sp] = block_c4tk5_info;
           _s4l90::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l90::I64;
           if (R1 & 7 != 0) goto u4tkp; else goto c4tk9;
       u4tkp: // global
           call _c4tk5(R1) args: 0, res: 0, upd: 0;
       c4tk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tjZ_info" {
     block_c4tjZ_info:
         const _c4tjZ;
         const 1;
         const 30;
 },
 _c4tk5() //  [R1]
         { []
         }
     {offset
       c4tk5: // global
           _s4l90::I64 = I64[Sp + 8];
           _s4l92::I64 = I64[R1 + 7];
           if (_s4l90::I64 == _s4l92::I64) goto c4tko; else goto c4tkn;
       c4tko: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tkn: // global
           if (%MO_S_Gt_W64(_s4l90::I64,
                            _s4l92::I64)) goto c4tkk; else goto c4tkl;
       c4tkk: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tkl: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tk5_info" {
     block_c4tk5_info:
         const _c4tk5;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.671550521 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmax_closure" {
     GHC.Int.$fOrdInt8_$cmax_closure:
         const GHC.Int.$fOrdInt8_$cmax_info;
 },
 GHC.Int.$fOrdInt8_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tkO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tkS; else goto c4tkT;
       c4tkS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tkT: // global
           I64[Sp - 16] = block_c4tkL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tl6; else goto c4tkM;
       u4tl6: // global
           call _c4tkL(R1) args: 0, res: 0, upd: 0;
       c4tkM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt8_$cmax_info" {
     GHC.Int.$fOrdInt8_$cmax_info:
         const GHC.Int.$fOrdInt8_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tkL() //  [R1]
         { []
         }
     {offset
       c4tkL: // global
           I64[Sp - 8] = block_c4tkR_info;
           _s4l97::P64 = R1;
           _s4l98::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l98::I64;
           P64[Sp + 8] = _s4l97::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tl5; else goto c4tkV;
       u4tl5: // global
           call _c4tkR(R1) args: 0, res: 0, upd: 0;
       c4tkV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tkL_info" {
     block_c4tkL_info:
         const _c4tkL;
         const 1;
         const 30;
 },
 _c4tkR() //  [R1]
         { []
         }
     {offset
       c4tkR: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4tl3; else goto c4tl4;
       c4tl3: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tl4: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tkR_info" {
     block_c4tkR_info:
         const _c4tkR;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.681057107 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmin_closure" {
     GHC.Int.$fOrdInt8_$cmin_closure:
         const GHC.Int.$fOrdInt8_$cmin_info;
 },
 GHC.Int.$fOrdInt8_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tlw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tlA; else goto c4tlB;
       c4tlA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tlB: // global
           I64[Sp - 16] = block_c4tlt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tlO; else goto c4tlu;
       u4tlO: // global
           call _c4tlt(R1) args: 0, res: 0, upd: 0;
       c4tlu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt8_$cmin_info" {
     GHC.Int.$fOrdInt8_$cmin_info:
         const GHC.Int.$fOrdInt8_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tlt() //  [R1]
         { []
         }
     {offset
       c4tlt: // global
           I64[Sp - 8] = block_c4tlz_info;
           _s4l9e::P64 = R1;
           _s4l9f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4l9f::I64;
           P64[Sp + 8] = _s4l9e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tlN; else goto c4tlD;
       u4tlN: // global
           call _c4tlz(R1) args: 0, res: 0, upd: 0;
       c4tlD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tlt_info" {
     block_c4tlt_info:
         const _c4tlt;
         const 1;
         const 30;
 },
 _c4tlz() //  [R1]
         { []
         }
     {offset
       c4tlz: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4tlL; else goto c4tlM;
       c4tlL: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tlM: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tlz_info" {
     block_c4tlz_info:
         const _c4tlz;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.688152621 UTC

[section ""data" . GHC.Int.$fOrdInt8_closure" {
     GHC.Int.$fOrdInt8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fOrdInt8_$ccompare_closure+2;
         const GHC.Int.ltInt8_closure+2;
         const GHC.Int.leInt8_closure+2;
         const GHC.Int.gtInt8_closure+2;
         const GHC.Int.geInt8_closure+2;
         const GHC.Int.$fOrdInt8_$cmax_closure+2;
         const GHC.Int.$fOrdInt8_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.692662011 UTC

[section ""data" . GHC.Int.$fIxInt8_$cinRange_closure" {
     GHC.Int.$fIxInt8_$cinRange_closure:
         const GHC.Int.$fIxInt8_$cinRange_info;
 },
 GHC.Int.$fIxInt8_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tmf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tmo; else goto c4tmp;
       c4tmo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tmp: // global
           I64[Sp - 16] = block_c4tmc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tmM; else goto c4tmd;
       u4tmM: // global
           call _c4tmc(R1) args: 0, res: 0, upd: 0;
       c4tmd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$cinRange_info" {
     GHC.Int.$fIxInt8_$cinRange_info:
         const GHC.Int.$fIxInt8_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tmc() //  [R1]
         { []
         }
     {offset
       c4tmc: // global
           I64[Sp - 8] = block_c4tmi_info;
           _s4l9n::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4l9n::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tmL; else goto c4tmj;
       u4tmL: // global
           call _c4tmi(R1) args: 0, res: 0, upd: 0;
       c4tmj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tmc_info" {
     block_c4tmc_info:
         const _c4tmc;
         const 1;
         const 30;
 },
 _c4tmi() //  [R1]
         { []
         }
     {offset
       c4tmi: // global
           I64[Sp] = block_c4tmn_info;
           _s4l9p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4l9p::I64;
           if (R1 & 7 != 0) goto u4tmN; else goto c4tms;
       u4tmN: // global
           call _c4tmn(R1) args: 0, res: 0, upd: 0;
       c4tms: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tmi_info" {
     block_c4tmi_info:
         const _c4tmi;
         const 2;
         const 30;
 },
 _c4tmn() //  [R1]
         { []
         }
     {offset
       c4tmn: // global
           _s4l9r::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4l9r::I64)) goto c4tmA; else goto c4tmE;
       c4tmA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tmE: // global
           _s4l9n::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4tmD_info;
           R1 = _s4l9n::P64;
           I64[Sp + 16] = _s4l9r::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4tmO; else goto c4tmF;
       u4tmO: // global
           call _c4tmD(R1) args: 0, res: 0, upd: 0;
       c4tmF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tmn_info" {
     block_c4tmn_info:
         const _c4tmn;
         const 130;
         const 30;
 },
 _c4tmD() //  [R1]
         { []
         }
     {offset
       c4tmD: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tmD_info" {
     block_c4tmD_info:
         const _c4tmD;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.70325542 UTC

[section ""data" . GHC.Int.$fNumInt7_closure" {
     GHC.Int.$fNumInt7_closure:
         const GHC.Int.I8#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.706358177 UTC

[section ""data" . GHC.Int.$fNumInt8_$csignum_closure" {
     GHC.Int.$fNumInt8_$csignum_closure:
         const GHC.Int.$fNumInt8_$csignum_info;
 },
 GHC.Int.$fNumInt8_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c4tnn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tno; else goto c4tnp;
       c4tno: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tnp: // global
           I64[Sp - 8] = block_c4tnk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tnD; else goto c4tnl;
       u4tnD: // global
           call _c4tnk(R1) args: 0, res: 0, upd: 0;
       c4tnl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$csignum_info" {
     GHC.Int.$fNumInt8_$csignum_info:
         const GHC.Int.$fNumInt8_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4tnk() //  [R1]
         { []
         }
     {offset
       c4tnk: // global
           _s4l9y::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4l9y::I64, 0)) goto c4tnB; else goto c4tnC;
       c4tnB: // global
           if (_s4l9y::I64 == 0) goto c4tnz; else goto c4tny;
       c4tnz: // global
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tny: // global
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tnC: // global
           R1 = GHC.Int.$fNumInt7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tnk_info" {
     block_c4tnk_info:
         const _c4tnk;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.713967146 UTC

[section ""data" . GHC.Int.$fNumInt8_$cabs_closure" {
     GHC.Int.$fNumInt8_$cabs_closure:
         const GHC.Int.$fNumInt8_$cabs_info;
 },
 GHC.Int.$fNumInt8_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c4tnX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tnY; else goto c4tnZ;
       c4tnY: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tnZ: // global
           I64[Sp - 8] = block_c4tnU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4toi; else goto c4tnV;
       u4toi: // global
           call _c4tnU(R1) args: 0, res: 0, upd: 0;
       c4tnV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$cabs_info" {
     GHC.Int.$fNumInt8_$cabs_info:
         const GHC.Int.$fNumInt8_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4tnU() //  [R1]
         { []
         }
     {offset
       c4tnU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4to4; else goto c4to3;
       c4to4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4to3: // global
           _s4l9D::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l9D::I64, 0)) goto c4tog; else goto c4toh;
       c4tog: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-_s4l9D::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4toh: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tnU_info" {
     block_c4tnU_info:
         const _c4tnU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.720174872 UTC

[section ""data" . GHC.Int.$fNumInt8_closure" {
     GHC.Int.$fNumInt8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt8_$c+_closure+2;
         const GHC.Int.$fNumInt8_$c-_closure+2;
         const GHC.Int.$fNumInt8_$c*_closure+2;
         const GHC.Int.$fNumInt8_$cnegate_closure+1;
         const GHC.Int.$fNumInt8_$cabs_closure+1;
         const GHC.Int.$fNumInt8_$csignum_closure+1;
         const GHC.Int.$fNumInt8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.722311205 UTC

[section ""data" . GHC.Int.$fBitsInt12_closure" {
     GHC.Int.$fBitsInt12_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt11_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.724425858 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt8_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c4toD: // global
           R1 = GHC.Int.$fBitsInt12_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cbitSizeMaybe_info" {
     GHC.Int.$fBitsInt8_$cbitSizeMaybe_info:
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.731813992 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbit_closure" {
     GHC.Int.$fBitsInt8_$cbit_closure:
         const GHC.Int.$fBitsInt8_$cbit_info;
 },
 GHC.Int.$fBitsInt8_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c4toS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4toT; else goto c4toU;
       c4toT: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4toU: // global
           I64[Sp - 8] = block_c4toP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tpd; else goto c4toQ;
       u4tpd: // global
           call _c4toP(R1) args: 0, res: 0, upd: 0;
       c4toQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cbit_info" {
     GHC.Int.$fBitsInt8_$cbit_info:
         const GHC.Int.$fBitsInt8_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4toP() //  [R1]
         { []
         }
     {offset
       c4toP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4toZ; else goto c4toY;
       c4toZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4toY: // global
           _s4l9K::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4l9K::I64, 64)) goto c4tpb; else goto c4tpc;
       c4tpb: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4l9K::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tpc: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4toP_info" {
     block_c4toP_info:
         const _c4toP;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.743396722 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ctestBit_closure" {
     GHC.Int.$fBitsInt8_$ctestBit_closure:
         const GHC.Int.$fBitsInt8_$ctestBit_info;
 },
 GHC.Int.$fBitsInt8_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tpz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tpD; else goto c4tpE;
       c4tpD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tpE: // global
           I64[Sp - 16] = block_c4tpw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tqm; else goto c4tpx;
       u4tqm: // global
           call _c4tpw(R1) args: 0, res: 0, upd: 0;
       c4tpx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$ctestBit_info" {
     GHC.Int.$fBitsInt8_$ctestBit_info:
         const GHC.Int.$fBitsInt8_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tpw() //  [R1]
         { []
         }
     {offset
       c4tpw: // global
           I64[Sp] = block_c4tpC_info;
           _s4l9R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4l9R::I64;
           if (R1 & 7 != 0) goto u4tql; else goto c4tpG;
       u4tql: // global
           call _c4tpC(R1) args: 0, res: 0, upd: 0;
       c4tpG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tpw_info" {
     block_c4tpw_info:
         const _c4tpw;
         const 1;
         const 30;
 },
 _c4tpC() //  [R1]
         { []
         }
     {offset
       c4tpC: // global
           _s4l9T::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4l9T::I64, 64)) goto c4tqk; else goto c4tqj;
       c4tqj: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4l9T::I64)) == 0) goto c4tqk; else goto c4tq8;
       c4tqk: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tq8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tpC_info" {
     block_c4tpC_info:
         const _c4tpC;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.752991861 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateR_closure" {
     GHC.Int.$fBitsInt8_$crotateR_closure:
         const GHC.Int.$fBitsInt8_$crotateR_info;
 },
 GHC.Int.$fBitsInt8_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tqO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tqS; else goto c4tqT;
       c4tqS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tqT: // global
           I64[Sp - 16] = block_c4tqL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4trS; else goto c4tqM;
       u4trS: // global
           call _c4tqL(R1) args: 0, res: 0, upd: 0;
       c4tqM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$crotateR_info" {
     GHC.Int.$fBitsInt8_$crotateR_info:
         const GHC.Int.$fBitsInt8_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tqL() //  [R1]
         { []
         }
     {offset
       c4tqL: // global
           I64[Sp - 8] = block_c4tqR_info;
           _s4la3::P64 = R1;
           _s4la4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4la4::I64;
           P64[Sp + 8] = _s4la3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4trR; else goto c4tqV;
       u4trR: // global
           call _c4tqR(R1) args: 0, res: 0, upd: 0;
       c4tqV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tqL_info" {
     block_c4tqL_info:
         const _c4tqL;
         const 1;
         const 30;
 },
 _c4tqR() //  [R1]
         { []
         }
     {offset
       c4tqR: // global
           _s4laa::I64 = -I64[R1 + 7] & 7;
           if (_s4laa::I64 != 0) goto u4trP; else goto c4trL;
       u4trP: // global
           I64[Sp + 16] = _s4laa::I64;
           Sp = Sp + 8;
           call _c4trd() args: 0, res: 0, upd: 0;
       c4trL: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tqR_info" {
     block_c4tqR_info:
         const _c4tqR;
         const 66;
         const 30;
 },
 _c4trd() //  []
         { []
         }
     {offset
       c4trd: // global
           Hp = Hp + 16;
           _s4laa::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4trI; else goto c4trH;
       c4trI: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4trc_info;
           R1 = _s4laa::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4trH: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4lab::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4lab::I64 << _s4laa::I64) | (_s4lab::I64 >> 8 - _s4laa::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4trc() //  [R1]
         { []
         }
     {offset
       c4trc: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4trd() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4trc_info" {
     block_c4trc_info:
         const _c4trc;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.766824802 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt8_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt8_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt8_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tsv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tsz; else goto c4tsA;
       c4tsz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tsA: // global
           I64[Sp - 16] = block_c4tss_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tt9; else goto c4tst;
       u4tt9: // global
           call _c4tss(R1) args: 0, res: 0, upd: 0;
       c4tst: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$ccomplementBit_info" {
     GHC.Int.$fBitsInt8_$ccomplementBit_info:
         const GHC.Int.$fBitsInt8_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tss() //  [R1]
         { []
         }
     {offset
       c4tss: // global
           I64[Sp - 8] = block_c4tsy_info;
           _s4lal::P64 = R1;
           _s4lam::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lam::I64;
           P64[Sp + 8] = _s4lal::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tt8; else goto c4tsC;
       u4tt8: // global
           call _c4tsy(R1) args: 0, res: 0, upd: 0;
       c4tsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tss_info" {
     block_c4tss_info:
         const _c4tss;
         const 1;
         const 30;
 },
 _c4tsy() //  [R1]
         { []
         }
     {offset
       c4tsy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tsI; else goto c4tsH;
       c4tsI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tsH: // global
           _s4lao::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lao::I64, 64)) goto c4tt6; else goto c4tt7;
       c4tt6: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4lao::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tt7: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tsy_info" {
     block_c4tsy_info:
         const _c4tsy;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.776569011 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cclearBit_closure" {
     GHC.Int.$fBitsInt8_$cclearBit_closure:
         const GHC.Int.$fBitsInt8_$cclearBit_info;
 },
 GHC.Int.$fBitsInt8_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ttC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ttG; else goto c4ttH;
       c4ttG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ttH: // global
           I64[Sp - 16] = block_c4ttz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tuu; else goto c4ttA;
       u4tuu: // global
           call _c4ttz(R1) args: 0, res: 0, upd: 0;
       c4ttA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cclearBit_info" {
     GHC.Int.$fBitsInt8_$cclearBit_info:
         const GHC.Int.$fBitsInt8_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4ttz() //  [R1]
         { []
         }
     {offset
       c4ttz: // global
           I64[Sp] = block_c4ttF_info;
           _s4laz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4laz::I64;
           if (R1 & 7 != 0) goto u4tut; else goto c4ttJ;
       u4tut: // global
           call _c4ttF(R1) args: 0, res: 0, upd: 0;
       c4ttJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ttz_info" {
     block_c4ttz_info:
         const _c4ttz;
         const 1;
         const 30;
 },
 _c4ttF() //  [R1]
         { []
         }
     {offset
       c4ttF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ttP; else goto c4ttO;
       c4ttP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ttO: // global
           _s4laz::I64 = I64[Sp + 8];
           _s4laB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4laB::I64, 64)) goto c4tug; else goto c4tus;
       c4tug: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4laz::I64 & ~%MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4laB::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tus: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4laz::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ttF_info" {
     block_c4ttF_info:
         const _c4ttF;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.787340366 UTC

[section ""data" . GHC.Int.$fBitsInt8_$csetBit_closure" {
     GHC.Int.$fBitsInt8_$csetBit_closure:
         const GHC.Int.$fBitsInt8_$csetBit_info;
 },
 GHC.Int.$fBitsInt8_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tuY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tv2; else goto c4tv3;
       c4tv2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tv3: // global
           I64[Sp - 16] = block_c4tuV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tvC; else goto c4tuW;
       u4tvC: // global
           call _c4tuV(R1) args: 0, res: 0, upd: 0;
       c4tuW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$csetBit_info" {
     GHC.Int.$fBitsInt8_$csetBit_info:
         const GHC.Int.$fBitsInt8_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tuV() //  [R1]
         { []
         }
     {offset
       c4tuV: // global
           I64[Sp - 8] = block_c4tv1_info;
           _s4laP::P64 = R1;
           _s4laQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4laQ::I64;
           P64[Sp + 8] = _s4laP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tvB; else goto c4tv5;
       u4tvB: // global
           call _c4tv1(R1) args: 0, res: 0, upd: 0;
       c4tv5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tuV_info" {
     block_c4tuV_info:
         const _c4tuV;
         const 1;
         const 30;
 },
 _c4tv1() //  [R1]
         { []
         }
     {offset
       c4tv1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tvb; else goto c4tva;
       c4tvb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tva: // global
           _s4laS::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4laS::I64, 64)) goto c4tvz; else goto c4tvA;
       c4tvz: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4laS::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tvA: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tv1_info" {
     block_c4tv1_info:
         const _c4tv1;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.794916888 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateL_closure" {
     GHC.Int.$fBitsInt8_$crotateL_closure:
         const GHC.Int.$fBitsInt8_$crotateL_info;
 },
 GHC.Int.$fBitsInt8_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tw2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt8_$crotate_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$crotateL_info" {
     GHC.Int.$fBitsInt8_$crotateL_info:
         const GHC.Int.$fBitsInt8_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.798340235 UTC

[section ""data" . GHC.Int.$fBitsInt8_closure" {
     GHC.Int.$fBitsInt8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fBitsInt8_$c.&._closure+2;
         const GHC.Int.$fBitsInt8_$c.|._closure+2;
         const GHC.Int.$fBitsInt8_$cxor_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt8_$cshift_closure+2;
         const GHC.Int.$fBitsInt8_$crotate_closure+2;
         const GHC.Int.$fBitsInt13_closure+1;
         const GHC.Int.$fBitsInt8_$cbit_closure+1;
         const GHC.Int.$fBitsInt8_$csetBit_closure+2;
         const GHC.Int.$fBitsInt8_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt8_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt8_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt8_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt8_$crotateL_closure+2;
         const GHC.Int.$fBitsInt8_$crotateR_closure+2;
         const GHC.Int.$fBitsInt8_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.801017975 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_closure" {
     GHC.Int.$fFiniteBitsInt8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt8_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.80573965 UTC

[section ""data" . GHC.Int.$fReadInt8_go_closure" {
     GHC.Int.$fReadInt8_go_closure:
         const GHC.Int.$fReadInt8_go_info;
 },
 sat_s4lbc_entry() //  [R1]
         { []
         }
     {offset
       c4twu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4twv; else goto c4tww;
       c4twv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4tww: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4lbc_info" {
     sat_s4lbc_info:
         const sat_s4lbc_entry;
         const 1;
         const 16;
 },
 sat_s4lba_entry() //  [R1]
         { []
         }
     {offset
       c4twE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4twL; else goto c4twM;
       c4twL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4twM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4twB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4twQ; else goto c4twC;
       u4twQ: // global
           call _c4twB(R1) args: 0, res: 0, upd: 0;
       c4twC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4lba_info" {
     sat_s4lba_info:
         const sat_s4lba_entry;
         const 1;
         const 16;
 },
 _c4twB() //  [R1]
         { []
         }
     {offset
       c4twB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4twP; else goto c4twO;
       c4twP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4twO: // global
           _s4lb9::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4lb9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4twB_info" {
     block_c4twB_info:
         const _c4twB;
         const 0;
         const 30;
 },
 GHC.Int.$fReadInt8_go_entry() //  [R2]
         { []
         }
     {offset
       c4twV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4twW; else goto c4twX;
       c4twW: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4twX: // global
           I64[Sp - 8] = block_c4twf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tx7; else goto c4twg;
       u4tx7: // global
           call _c4twf(R1) args: 0, res: 0, upd: 0;
       c4twg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt8_go_info" {
     GHC.Int.$fReadInt8_go_info:
         const GHC.Int.$fReadInt8_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4twf() //  [R1]
         { []
         }
     {offset
       c4twf: // global
           if (R1 & 7 == 1) goto c4twS; else goto c4twT;
       c4twS: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4twT: // global
           I64[Sp - 8] = block_c4twl_info;
           _s4lb3::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lb3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tx6; else goto c4twm;
       u4tx6: // global
           call _c4twl(R1) args: 0, res: 0, upd: 0;
       c4twm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4twf_info" {
     block_c4twf_info:
         const _c4twf;
         const 0;
         const 30;
 },
 _c4twl() //  [R1]
         { []
         }
     {offset
       c4twl: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4tx5; else goto c4tx4;
       c4tx5: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tx4: // global
           _s4lb5::P64 = P64[R1 + 7];
           _s4lb6::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lbc_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lba_info;
           P64[Hp - 48] = _s4lb5::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lb6::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4twl_info" {
     block_c4twl_info:
         const _c4twl;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.82065162 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadsPrec_closure" {
     GHC.Int.$fReadInt8_$creadsPrec_closure:
         const GHC.Int.$fReadInt8_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c4txN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4txR; else goto c4txS;
       c4txR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4txS: // global
           I64[Sp - 16] = block_c4txL_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lbe::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lbe::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt8_$creadsPrec_info" {
     GHC.Int.$fReadInt8_$creadsPrec_info:
         const GHC.Int.$fReadInt8_$creadsPrec_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const S4lDl_srt+472;
 },
 _c4txL() //  [R1]
         { []
         }
     {offset
       c4txL: // global
           _s4lbe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4txQ_info;
           R3 = _s4lbe::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4txL_info" {
     block_c4txL_info:
         const _c4txL;
         const 1;
         const 30;
 },
 _c4txQ() //  [R1]
         { []
         }
     {offset
       c4txQ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4txQ_info" {
     block_c4txQ_info:
         const _c4txQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.830166668 UTC

[section ""data" . GHC.Int.$fReadInt13_closure" {
     GHC.Int.$fReadInt13_closure:
         const GHC.Int.$fReadInt13_info;
         const 0;
 },
 sat_s4lbj_entry() //  [R1, R2]
         { []
         }
     {offset
       c4tyi: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt8_$creadsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s4lbj_info" {
     sat_s4lbj_info:
         const sat_s4lbj_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S4lDl_srt+488;
 },
 GHC.Int.$fReadInt13_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tyo: // global
           _s4lbi::P64 = R3;
           _s4lbh::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4typ; else goto c4tyq;
       c4tyq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tys; else goto c4tyr;
       c4tys: // global
           HpAlloc = 16;
           goto c4typ;
       c4typ: // global
           R3 = _s4lbi::P64;
           R2 = _s4lbh::P64;
           R1 = GHC.Int.$fReadInt13_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tyr: // global
           I64[Hp - 8] = sat_s4lbj_info;
           P64[Hp] = _s4lbh::P64;
           I64[Sp - 8] = block_c4tyl_info;
           R3 = _s4lbi::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt13_info" {
     GHC.Int.$fReadInt13_info:
         const GHC.Int.$fReadInt13_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+488;
 },
 _c4tyl() //  [R1]
         { []
         }
     {offset
       c4tyl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tyv; else goto c4tyu;
       c4tyv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tyu: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tyl_info" {
     block_c4tyl_info:
         const _c4tyl;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.840799544 UTC

[section ""data" . GHC.Int.$fIxInt1_closure" {
     GHC.Int.$fIxInt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.844789372 UTC

[section ""data" . GHC.Int.$fReadInt12_closure" {
     GHC.Int.$fReadInt12_closure:
         const GHC.Int.$fReadInt12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt12_entry() //  [R1]
         { []
         }
     {offset
       c4tyP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4tyQ; else goto c4tyR;
       c4tyQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4tyR: // global
           (_c4tyM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4tyM::I64 == 0) goto c4tyO; else goto c4tyN;
       c4tyO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4tyN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4tyM::I64;
           R2 = GHC.Int.$fReadInt13_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt12_info" {
     GHC.Int.$fReadInt12_info:
         const GHC.Int.$fReadInt12_entry;
         const 0;
         const 12884901909;
         const S4lDl_srt+496;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.852220591 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadList_closure" {
     GHC.Int.$fReadInt8_$creadList_closure:
         const GHC.Int.$fReadInt8_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadList_entry() //  [R2]
         { []
         }
     {offset
       c4tz3: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt8_$creadList_info" {
     GHC.Int.$fReadInt8_$creadList_info:
         const GHC.Int.$fReadInt8_$creadList_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S4lDl_srt+512;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.859191113 UTC

[section ""data" . GHC.Int.$fReadInt11_closure" {
     GHC.Int.$fReadInt11_closure:
         const GHC.Int.$fReadInt11_info;
         const 0;
 },
 GHC.Int.$fReadInt11_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tzh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tzi; else goto c4tzj;
       c4tzi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tzj: // global
           I64[Sp - 8] = block_c4tze_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt8_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt11_info" {
     GHC.Int.$fReadInt11_info:
         const GHC.Int.$fReadInt11_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+520;
 },
 _c4tze() //  [R1]
         { []
         }
     {offset
       c4tze: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tzm; else goto c4tzl;
       c4tzm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tzl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tze_info" {
     block_c4tze_info:
         const _c4tze;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.866969767 UTC

[section ""data" . GHC.Int.$fReadInt8_closure" {
     GHC.Int.$fReadInt8_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt8_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt8_$creadList_closure+1;
         const GHC.Int.$fReadInt13_closure+2;
         const GHC.Int.$fReadInt11_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.872733083 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquot_closure" {
     GHC.Int.$fIntegralInt8_$cquot_closure:
         const GHC.Int.$fIntegralInt8_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tzE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tzI; else goto c4tzJ;
       c4tzI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tzJ: // global
           I64[Sp - 16] = block_c4tzB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tAk; else goto c4tzC;
       u4tAk: // global
           call _c4tzB(R1) args: 0, res: 0, upd: 0;
       c4tzC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$cquot_info" {
     GHC.Int.$fIntegralInt8_$cquot_info:
         const GHC.Int.$fIntegralInt8_$cquot_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const S4lDl_srt+536;
 },
 _c4tzB() //  [R1]
         { []
         }
     {offset
       c4tzB: // global
           I64[Sp] = block_c4tzH_info;
           _s4lbt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbt::I64;
           if (R1 & 7 != 0) goto u4tAj; else goto c4tzL;
       u4tAj: // global
           call _c4tzH(R1) args: 0, res: 0, upd: 0;
       c4tzL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tzB_info" {
     block_c4tzB_info:
         const _c4tzB;
         const 1;
         const 12884901918;
         const S4lDl_srt+536;
 },
 _c4tzH() //  [R1]
         { []
         }
     {offset
       c4tzH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tzR; else goto c4tzQ;
       c4tzR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tzQ: // global
           _s4lbt::I64 = I64[Sp + 8];
           _s4lbw::I64 = I64[R1 + 7];
           if (_s4lbw::I64 != (-1)) goto u4tAi; else goto c4tAg;
       u4tAi: // global
           if (_s4lbw::I64 != 0) goto c4tA2; else goto c4tAh;
       c4tA2: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4lbt::I64,
                                                                          _s4lbw::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tAh: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tAg: // global
           if (_s4lbt::I64 == (-128)) goto c4tAf; else goto c4tAe;
       c4tAf: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tAe: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4lbt::I64,
                                                                          (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tzH_info" {
     block_c4tzH_info:
         const _c4tzH;
         const 65;
         const 12884901918;
         const S4lDl_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.887705874 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$crem_closure" {
     GHC.Int.$fIntegralInt8_$crem_closure:
         const GHC.Int.$fIntegralInt8_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tAM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tAQ; else goto c4tAR;
       c4tAQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tAR: // global
           I64[Sp - 16] = block_c4tAJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tBd; else goto c4tAK;
       u4tBd: // global
           call _c4tAJ(R1) args: 0, res: 0, upd: 0;
       c4tAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$crem_info" {
     GHC.Int.$fIntegralInt8_$crem_info:
         const GHC.Int.$fIntegralInt8_$crem_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const S4lDl_srt+536;
 },
 _c4tAJ() //  [R1]
         { []
         }
     {offset
       c4tAJ: // global
           I64[Sp] = block_c4tAP_info;
           _s4lbH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbH::I64;
           if (R1 & 7 != 0) goto u4tBc; else goto c4tAT;
       u4tBc: // global
           call _c4tAP(R1) args: 0, res: 0, upd: 0;
       c4tAT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tAJ_info" {
     block_c4tAJ_info:
         const _c4tAJ;
         const 1;
         const 4294967326;
         const S4lDl_srt+536;
 },
 _c4tAP() //  [R1]
         { []
         }
     {offset
       c4tAP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tAZ; else goto c4tAY;
       c4tAZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tAY: // global
           _s4lbK::I64 = I64[R1 + 7];
           if (_s4lbK::I64 != 0) goto c4tBa; else goto c4tBb;
       c4tBa: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Rem_W64(I64[Sp + 8],
                                                                         _s4lbK::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tBb: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tAP_info" {
     block_c4tAP_info:
         const _c4tAP;
         const 65;
         const 4294967326;
         const S4lDl_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.899722455 UTC

[section ""data" . GHC.Int.$w$cdiv3_closure" {
     GHC.Int.$w$cdiv3_closure:
         const GHC.Int.$w$cdiv3_info;
         const 0;
 },
 GHC.Int.$w$cdiv3_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tBD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tBE; else goto c4tBF;
       c4tBE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tBF: // global
           if (R3 == (-1)) goto c4tBB; else goto u4tBZ;
       c4tBB: // global
           if (R2 == (-128)) goto c4tBY; else goto c4tBW;
       c4tBY: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tBW: // global
           I64[Sp - 8] = block_c4tBQ_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4tBZ: // global
           if (R3 == 0) goto c4tBC; else goto c4tBA;
       c4tBC: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tBA: // global
           I64[Sp - 8] = block_c4tBH_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdiv3_info" {
     GHC.Int.$w$cdiv3_info:
         const GHC.Int.$w$cdiv3_entry;
         const 0;
         const 81604378638;
         const 8589934604;
         const S4lDl_srt+536;
 },
 _c4tBQ() //  [R1]
         { []
         }
     {offset
       c4tBQ: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tBQ_info" {
     block_c4tBQ_info:
         const _c4tBQ;
         const 0;
         const 30;
 },
 _c4tBH() //  [R1]
         { []
         }
     {offset
       c4tBH: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tBH_info" {
     block_c4tBH_info:
         const _c4tBH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.911955638 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdiv_closure" {
     GHC.Int.$fIntegralInt8_$cdiv_closure:
         const GHC.Int.$fIntegralInt8_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tCm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tCz; else goto c4tCA;
       c4tCz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tCA: // global
           I64[Sp - 16] = block_c4tCj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tCH; else goto c4tCk;
       u4tCH: // global
           call _c4tCj(R1) args: 0, res: 0, upd: 0;
       c4tCk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$cdiv_info" {
     GHC.Int.$fIntegralInt8_$cdiv_info:
         const GHC.Int.$fIntegralInt8_$cdiv_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+568;
 },
 _c4tCj() //  [R1]
         { []
         }
     {offset
       c4tCj: // global
           I64[Sp] = block_c4tCp_info;
           _s4lbY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lbY::I64;
           if (R1 & 7 != 0) goto u4tCG; else goto c4tCq;
       u4tCG: // global
           call _c4tCp(R1) args: 0, res: 0, upd: 0;
       c4tCq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tCj_info" {
     block_c4tCj_info:
         const _c4tCj;
         const 1;
         const 4294967326;
         const S4lDl_srt+568;
 },
 _c4tCp() //  [R1]
         { []
         }
     {offset
       c4tCp: // global
           _s4lbY::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4tCu_info;
           R3 = I64[R1 + 7];
           R2 = _s4lbY::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tCp_info" {
     block_c4tCp_info:
         const _c4tCp;
         const 65;
         const 4294967326;
         const S4lDl_srt+568;
 },
 _c4tCu() //  [R1]
         { []
         }
     {offset
       c4tCu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tCF; else goto c4tCE;
       c4tCF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4tCE: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tCu_info" {
     block_c4tCu_info:
         const _c4tCu;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.926242375 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cmod_closure" {
     GHC.Int.$fIntegralInt8_$cmod_closure:
         const GHC.Int.$fIntegralInt8_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cmod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tD6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tDa; else goto c4tDb;
       c4tDa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tDb: // global
           I64[Sp - 16] = block_c4tD3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tDz; else goto c4tD4;
       u4tDz: // global
           call _c4tD3(R1) args: 0, res: 0, upd: 0;
       c4tD4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$cmod_info" {
     GHC.Int.$fIntegralInt8_$cmod_info:
         const GHC.Int.$fIntegralInt8_$cmod_entry;
         const 0;
         const 279172874254;
         const 8589934607;
         const S4lDl_srt+536;
 },
 _c4tD3() //  [R1]
         { []
         }
     {offset
       c4tD3: // global
           I64[Sp] = block_c4tD9_info;
           _s4lc5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lc5::I64;
           if (R1 & 7 != 0) goto u4tDy; else goto c4tDd;
       u4tDy: // global
           call _c4tD9(R1) args: 0, res: 0, upd: 0;
       c4tDd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tD3_info" {
     block_c4tD3_info:
         const _c4tD3;
         const 1;
         const 4294967326;
         const S4lDl_srt+536;
 },
 _c4tD9() //  [R1]
         { []
         }
     {offset
       c4tD9: // global
           _s4lc8::I64 = I64[R1 + 7];
           if (_s4lc8::I64 != 0) goto c4tDt; else goto c4tDx;
       c4tDt: // global
           _s4lc5::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4tDk_info;
           R3 = _s4lc8::I64;
           R2 = _s4lc5::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4tDx: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tD9_info" {
     block_c4tD9_info:
         const _c4tD9;
         const 65;
         const 4294967326;
         const S4lDl_srt+536;
 },
 _c4tDk() //  [R1]
         { []
         }
     {offset
       c4tDk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tDw; else goto c4tDv;
       c4tDw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4tDv: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tDk_info" {
     block_c4tDk_info:
         const _c4tDk;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.93877998 UTC

[section ""data" . lvl6_r4kPx_closure" {
     lvl6_r4kPx_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt13_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.944382355 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquotRem_closure" {
     GHC.Int.$fIntegralInt8_$cquotRem_closure:
         const GHC.Int.$fIntegralInt8_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tE1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tE5; else goto c4tE6;
       c4tE5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tE6: // global
           I64[Sp - 16] = block_c4tDY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tEL; else goto c4tDZ;
       u4tEL: // global
           call _c4tDY(R1) args: 0, res: 0, upd: 0;
       c4tDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$cquotRem_info" {
     GHC.Int.$fIntegralInt8_$cquotRem_info:
         const GHC.Int.$fIntegralInt8_$cquotRem_entry;
         const 0;
         const 1653562408974;
         const 8589934607;
         const S4lDl_srt+536;
 },
 _c4tDY() //  [R1]
         { []
         }
     {offset
       c4tDY: // global
           I64[Sp] = block_c4tE4_info;
           _s4lcf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lcf::I64;
           if (R1 & 7 != 0) goto u4tEK; else goto c4tE8;
       u4tEK: // global
           call _c4tE4(R1) args: 0, res: 0, upd: 0;
       c4tE8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tDY_info" {
     block_c4tDY_info:
         const _c4tDY;
         const 1;
         const 1103806595102;
         const S4lDl_srt+536;
 },
 _c4tE4() //  [R1]
         { []
         }
     {offset
       c4tE4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4tEe; else goto c4tEd;
       c4tEe: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tEd: // global
           _s4lcf::I64 = I64[Sp + 8];
           _s4lci::I64 = I64[R1 + 7];
           if (_s4lci::I64 != (-1)) goto u4tEJ; else goto c4tEH;
       u4tEJ: // global
           if (_s4lci::I64 != 0) goto c4tEr; else goto c4tEI;
       c4tEr: // global
           (_s4lck::I64, _s4lcl::I64) = call MO_S_QuotRem W64(_s4lcf::I64, _s4lci::I64);
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcl::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lck::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tEI: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tEH: // global
           if (_s4lcf::I64 == (-128)) goto c4tEG; else goto c4tEF;
       c4tEG: // global
           Hp = Hp - 56;
           R1 = lvl6_r4kPx_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tEF: // global
           (_s4lcs::I64, _s4lct::I64) = call MO_S_QuotRem W64(_s4lcf::I64, (-1));
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lct::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcs::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tE4_info" {
     block_c4tE4_info:
         const _c4tE4;
         const 65;
         const 1103806595102;
         const S4lDl_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.962170842 UTC

[section ""data" . GHC.Int.$w$cdivMod3_closure" {
     GHC.Int.$w$cdivMod3_closure:
         const GHC.Int.$w$cdivMod3_info;
         const 0;
 },
 GHC.Int.$w$cdivMod3_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tFn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tFo; else goto c4tFp;
       c4tFo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tFp: // global
           if (R3 == 0) goto c4tFm; else goto c4tFl;
       c4tFm: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4tFl: // global
           if (R3 == (-1)) goto c4tHS; else goto u4tHT;
       c4tHS: // global
           if (R2 == (-128)) goto c4tHR; else goto u4tHU;
       c4tHR: // global
           R2 = GHC.Int.$fBitsInt13_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4tHU: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4tHW;
       u4tHT: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4tHW;
       u4tHW: // global
           call _c4tFu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdivMod3_info" {
     GHC.Int.$w$cdivMod3_info:
         const GHC.Int.$w$cdivMod3_entry;
         const 0;
         const 2211908157454;
         const 8589934604;
         const S4lDl_srt+536;
 },
 _c4tFu() //  []
         { []
         }
     {offset
       c4tFu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4tFy; else goto c4tFx;
       c4tFy: // global
           HpAlloc = 32;
           I64[Sp] = block_c4tFu_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4tFx: // global
           _s4lcz::I64 = I64[Sp + 8];
           _s4lcB::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lcz::I64, 0)) goto c4tGr; else goto c4tHI;
       c4tGr: // global
           if (%MO_S_Ge_W64(_s4lcz::I64, 0)) goto c4tFO; else goto c4tGp;
       c4tFO: // global
           (_s4lcG::I64, _s4lcH::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcH::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcG::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tGp: // global
           if (%MO_S_Le_W64(_s4lcB::I64, 0)) goto c4tG2; else goto c4tGo;
       c4tG2: // global
           (_s4lcO::I64, _s4lcP::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcP::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcO::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tGo: // global
           (_s4lcW::I64, _s4lcX::I64) = call MO_S_QuotRem W64(_s4lcz::I64 + 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcX::I64 + _s4lcB::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4lcW::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tHI: // global
           if (%MO_S_Ge_W64(_s4lcB::I64, 0)) goto c4tHl; else goto c4tHH;
       c4tHl: // global
           if (%MO_S_Ge_W64(_s4lcz::I64, 0)) goto c4tGI; else goto c4tHj;
       c4tGI: // global
           (_s4ld8::I64, _s4ld9::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ld9::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ld8::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tHj: // global
           if (%MO_S_Le_W64(_s4lcB::I64, 0)) goto c4tGW; else goto c4tHi;
       c4tGW: // global
           (_s4ldg::I64, _s4ldh::I64) = call MO_S_QuotRem W64(_s4lcz::I64, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldh::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldg::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tHi: // global
           (_s4ldo::I64, _s4ldp::I64) = call MO_S_QuotRem W64(_s4lcz::I64 + 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldp::I64 + _s4lcB::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldo::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4tHH: // global
           (_s4ldz::I64, _s4ldA::I64) = call MO_S_QuotRem W64(_s4lcz::I64 - 1, _s4lcB::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldA::I64 + _s4lcB::I64 + 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4ldz::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tFu_info" {
     block_c4tFu_info:
         const _c4tFu;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.976613209 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdivMod_closure" {
     GHC.Int.$fIntegralInt8_$cdivMod_closure:
         const GHC.Int.$fIntegralInt8_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tIS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tJ3; else goto c4tJ4;
       c4tJ3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tJ4: // global
           I64[Sp - 16] = block_c4tIP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tJb; else goto c4tIQ;
       u4tJb: // global
           call _c4tIP(R1) args: 0, res: 0, upd: 0;
       c4tIQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$cdivMod_info" {
     GHC.Int.$fIntegralInt8_$cdivMod_info:
         const GHC.Int.$fIntegralInt8_$cdivMod_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+608;
 },
 _c4tIP() //  [R1]
         { []
         }
     {offset
       c4tIP: // global
           I64[Sp] = block_c4tIV_info;
           _s4ldO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ldO::I64;
           if (R1 & 7 != 0) goto u4tJa; else goto c4tIW;
       u4tJa: // global
           call _c4tIV(R1) args: 0, res: 0, upd: 0;
       c4tIW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tIP_info" {
     block_c4tIP_info:
         const _c4tIP;
         const 1;
         const 4294967326;
         const S4lDl_srt+608;
 },
 _c4tIV() //  [R1]
         { []
         }
     {offset
       c4tIV: // global
           _s4ldO::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4tJ0_info;
           R3 = I64[R1 + 7];
           R2 = _s4ldO::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tIV_info" {
     block_c4tIV_info:
         const _c4tIV;
         const 65;
         const 4294967326;
         const S4lDl_srt+608;
 },
 _c4tJ0() //  [R1, R2]
         { []
         }
     {offset
       c4tJ0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4tJ9; else goto c4tJ8;
       c4tJ9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4tJ8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tJ0_info" {
     block_c4tJ0_info:
         const _c4tJ0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.987967752 UTC

[section ""data" . sat_s4ldU_closure" {
     sat_s4ldU_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.991040127 UTC

[section ""data" . sat_s4ldV_closure" {
     sat_s4ldV_closure:
         const :_con_info;
         const sat_s4ldU_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:11.99439907 UTC

[section ""data" . GHC.Int.$fRealInt1_closure" {
     GHC.Int.$fRealInt1_closure:
         const GHC.Int.$fRealInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fRealInt1_entry() //  [R1]
         { []
         }
     {offset
       c4tJB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tJC; else goto c4tJD;
       c4tJC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4tJD: // global
           (_c4tJy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4tJy::I64 == 0) goto c4tJA; else goto c4tJz;
       c4tJA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4tJz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4tJy::I64;
           R3 = sat_s4ldV_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fRealInt1_info" {
     GHC.Int.$fRealInt1_info:
         const GHC.Int.$fRealInt1_entry;
         const 0;
         const 4294967317;
         const S4lDl_srt+624;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.00224932 UTC

[section ""data" . GHC.Int.$fRealInt8_$ctoRational_closure" {
     GHC.Int.$fRealInt8_$ctoRational_closure:
         const GHC.Int.$fRealInt8_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt8_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c4tJS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tK6; else goto c4tK7;
       c4tK6: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tK7: // global
           I64[Sp - 8] = block_c4tJP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tKe; else goto c4tJQ;
       u4tKe: // global
           call _c4tJP(R1) args: 0, res: 0, upd: 0;
       c4tJQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fRealInt8_$ctoRational_info" {
     GHC.Int.$fRealInt8_$ctoRational_info:
         const GHC.Int.$fRealInt8_$ctoRational_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S4lDl_srt+632;
 },
 _c4tJP() //  [R1]
         { []
         }
     {offset
       c4tJP: // global
           I64[Sp] = block_c4tJV_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tJP_info" {
     block_c4tJP_info:
         const _c4tJP;
         const 0;
         const 30064771102;
         const S4lDl_srt+632;
 },
 _c4tJV() //  [R1]
         { []
         }
     {offset
       c4tJV: // global
           I64[Sp] = block_c4tJZ_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tJV_info" {
     block_c4tJV_info:
         const _c4tJV;
         const 0;
         const 30064771102;
         const S4lDl_srt+632;
 },
 _c4tJZ() //  [R1]
         { []
         }
     {offset
       c4tJZ: // global
           I64[Sp] = block_c4tK3_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tJZ_info" {
     block_c4tJZ_info:
         const _c4tJZ;
         const 0;
         const 12884901918;
         const S4lDl_srt+640;
 },
 _c4tK3() //  [R1, R2]
         { []
         }
     {offset
       c4tK3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4tKd; else goto c4tKc;
       c4tKd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4tKc: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tK3_info" {
     block_c4tK3_info:
         const _c4tK3;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.015108498 UTC

[section ""data" . GHC.Int.$fRealInt8_closure" {
     GHC.Int.$fRealInt8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt8_closure+1;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fRealInt8_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.021824958 UTC

[section ""data" . GHC.Int.$fIntegralInt8_closure" {
     GHC.Int.$fIntegralInt8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt8_closure+1;
         const GHC.Int.$fEnumInt8_closure+1;
         const GHC.Int.$fIntegralInt8_$cquot_closure+2;
         const GHC.Int.$fIntegralInt8_$crem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt8_$cmod_closure+2;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt8_$ctoInteger_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.026821722 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt8_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt8_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt8_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tKH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tKY; else goto c4tKZ;
       c4tKY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tKZ: // global
           I64[Sp - 16] = block_c4tKE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tL6; else goto c4tKF;
       u4tL6: // global
           call _c4tKE(R1) args: 0, res: 0, upd: 0;
       c4tKF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$cunsafeIndex_info" {
     GHC.Int.$fIxInt8_$cunsafeIndex_info:
         const GHC.Int.$fIxInt8_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tKE() //  [R1]
         { []
         }
     {offset
       c4tKE: // global
           I64[Sp] = block_c4tKK_info;
           _s4le7::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4le7::P64;
           if (R1 & 7 != 0) goto u4tL5; else goto c4tKL;
       u4tL5: // global
           call _c4tKK(R1) args: 0, res: 0, upd: 0;
       c4tKL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tKE_info" {
     block_c4tKE_info:
         const _c4tKE;
         const 1;
         const 30;
 },
 _c4tKK() //  [R1]
         { []
         }
     {offset
       c4tKK: // global
           I64[Sp] = block_c4tKP_info;
           _s4lea::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lea::I64;
           if (R1 & 7 != 0) goto u4tL7; else goto c4tKQ;
       u4tL7: // global
           call _c4tKP(R1) args: 0, res: 0, upd: 0;
       c4tKQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tKK_info" {
     block_c4tKK_info:
         const _c4tKK;
         const 1;
         const 30;
 },
 _c4tKP() //  [R1]
         { []
         }
     {offset
       c4tKP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tL4; else goto c4tL3;
       c4tL4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tL3: // global
           _s4led::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4led::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tKP_info" {
     block_c4tKP_info:
         const _c4tKP;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.037697859 UTC

[section ""data" . GHC.Int.$fIxInt8_$crange_closure" {
     GHC.Int.$fIxInt8_$crange_closure:
         const GHC.Int.$fIxInt8_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$crange_entry() //  [R2]
         { []
         }
     {offset
       c4tLz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tLA; else goto c4tLB;
       c4tLA: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tLB: // global
           I64[Sp - 8] = block_c4tLw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tLF; else goto c4tLx;
       u4tLF: // global
           call _c4tLw(R1) args: 0, res: 0, upd: 0;
       c4tLx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$crange_info" {
     GHC.Int.$fIxInt8_$crange_info:
         const GHC.Int.$fIxInt8_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+664;
 },
 _c4tLw() //  [R1]
         { []
         }
     {offset
       c4tLw: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_$cenumFromTo_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tLw_info" {
     block_c4tLw_info:
         const _c4tLw;
         const 0;
         const 4294967326;
         const S4lDl_srt+672;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.045671309 UTC

[section ""data" . GHC.Int.$fIxInt8_$crangeSize_closure" {
     GHC.Int.$fIxInt8_$crangeSize_closure:
         const GHC.Int.$fIxInt8_$crangeSize_info;
 },
 GHC.Int.$fIxInt8_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4tLW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tM5; else goto c4tM6;
       c4tM5: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tM6: // global
           I64[Sp - 8] = block_c4tLT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tMv; else goto c4tLU;
       u4tMv: // global
           call _c4tLT(R1) args: 0, res: 0, upd: 0;
       c4tLU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$crangeSize_info" {
     GHC.Int.$fIxInt8_$crangeSize_info:
         const GHC.Int.$fIxInt8_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4tLT() //  [R1]
         { []
         }
     {offset
       c4tLT: // global
           I64[Sp - 8] = block_c4tLZ_info;
           _s4lel::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lel::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tMu; else goto c4tM0;
       u4tMu: // global
           call _c4tLZ(R1) args: 0, res: 0, upd: 0;
       c4tM0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tLT_info" {
     block_c4tLT_info:
         const _c4tLT;
         const 0;
         const 30;
 },
 _c4tLZ() //  [R1]
         { []
         }
     {offset
       c4tLZ: // global
           I64[Sp] = block_c4tM4_info;
           _s4len::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4len::I64;
           if (R1 & 7 != 0) goto u4tMw; else goto c4tM9;
       u4tMw: // global
           call _c4tM4(R1) args: 0, res: 0, upd: 0;
       c4tM9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tLZ_info" {
     block_c4tLZ_info:
         const _c4tLZ;
         const 1;
         const 30;
 },
 _c4tM4() //  [R1]
         { []
         }
     {offset
       c4tM4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tMf; else goto c4tMe;
       c4tMf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tMe: // global
           _s4len::I64 = I64[Sp + 8];
           _s4lep::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4len::I64,
                            _s4lep::I64)) goto c4tMj; else goto c4tMt;
       c4tMj: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tMt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lep::I64 - _s4len::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tM4_info" {
     block_c4tM4_info:
         const _c4tM4;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.058748883 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt8_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt8_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4tN0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tNk; else goto c4tNl;
       c4tNk: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tNl: // global
           I64[Sp - 8] = block_c4tMX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tNs; else goto c4tMY;
       u4tNs: // global
           call _c4tMX(R1) args: 0, res: 0, upd: 0;
       c4tMY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$cunsafeRangeSize_info" {
     GHC.Int.$fIxInt8_$cunsafeRangeSize_info:
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4tMX() //  [R1]
         { []
         }
     {offset
       c4tMX: // global
           I64[Sp - 8] = block_c4tN3_info;
           _s4lev::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lev::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tNr; else goto c4tN4;
       u4tNr: // global
           call _c4tN3(R1) args: 0, res: 0, upd: 0;
       c4tN4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tMX_info" {
     block_c4tMX_info:
         const _c4tMX;
         const 0;
         const 30;
 },
 _c4tN3() //  [R1]
         { []
         }
     {offset
       c4tN3: // global
           I64[Sp] = block_c4tN8_info;
           _s4ley::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ley::I64;
           if (R1 & 7 != 0) goto u4tNt; else goto c4tN9;
       u4tNt: // global
           call _c4tN8(R1) args: 0, res: 0, upd: 0;
       c4tN9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tN3_info" {
     block_c4tN3_info:
         const _c4tN3;
         const 1;
         const 30;
 },
 _c4tN8() //  [R1]
         { []
         }
     {offset
       c4tN8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tNq; else goto c4tNp;
       c4tNq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tNp: // global
           _s4leC::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4leC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tN8_info" {
     block_c4tN8_info:
         const _c4tN8;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.072169919 UTC

[section ""data" . GHC.Int.$fIxInt8_$cindex_closure" {
     GHC.Int.$fIxInt8_$cindex_closure:
         const GHC.Int.$fIxInt8_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tNW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tO5; else goto c4tO6;
       c4tO5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tO6: // global
           I64[Sp - 16] = block_c4tNT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tOF; else goto c4tNU;
       u4tOF: // global
           call _c4tNT(R1) args: 0, res: 0, upd: 0;
       c4tNU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$cindex_info" {
     GHC.Int.$fIxInt8_$cindex_info:
         const GHC.Int.$fIxInt8_$cindex_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+680;
 },
 _c4tNT() //  [R1]
         { []
         }
     {offset
       c4tNT: // global
           I64[Sp - 8] = block_c4tNZ_info;
           _s4leH::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4leH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tOE; else goto c4tO0;
       u4tOE: // global
           call _c4tNZ(R1) args: 0, res: 0, upd: 0;
       c4tO0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tNT_info" {
     block_c4tNT_info:
         const _c4tNT;
         const 1;
         const 4294967326;
         const S4lDl_srt+680;
 },
 _c4tNZ() //  [R1]
         { []
         }
     {offset
       c4tNZ: // global
           I64[Sp] = block_c4tO4_info;
           _s4leJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4leJ::I64;
           if (R1 & 7 != 0) goto u4tOG; else goto c4tO9;
       u4tOG: // global
           call _c4tO4(R1) args: 0, res: 0, upd: 0;
       c4tO9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tNZ_info" {
     block_c4tNZ_info:
         const _c4tNZ;
         const 2;
         const 4294967326;
         const S4lDl_srt+680;
 },
 _c4tO4() //  [R1]
         { []
         }
     {offset
       c4tO4: // global
           _s4leL::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4leL::I64)) goto c4tOh; else goto c4tOl;
       c4tOh: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tOl: // global
           I64[Sp] = block_c4tOk_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4leL::I64;
           if (R1 & 7 != 0) goto u4tOH; else goto c4tOm;
       u4tOH: // global
           call _c4tOk(R1) args: 0, res: 0, upd: 0;
       c4tOm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tO4_info" {
     block_c4tO4_info:
         const _c4tO4;
         const 130;
         const 4294967326;
         const S4lDl_srt+680;
 },
 _c4tOk() //  [R1]
         { []
         }
     {offset
       c4tOk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tOs; else goto c4tOr;
       c4tOs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tOr: // global
           _s4leL::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4leL::I64,
                            I64[R1 + 7])) goto c4tOw; else goto c4tOD;
       c4tOw: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tOD: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4leL::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tOk_info" {
     block_c4tOk_info:
         const _c4tOk;
         const 194;
         const 4294967326;
         const S4lDl_srt+680;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.083895992 UTC

[section ""data" . GHC.Int.$fIxInt8_closure" {
     GHC.Int.$fIxInt8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fIxInt8_$crange_closure+1;
         const GHC.Int.$fIxInt8_$cindex_closure+2;
         const GHC.Int.$fIxInt8_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt8_$cinRange_closure+2;
         const GHC.Int.$fIxInt8_$crangeSize_closure+1;
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.087395637 UTC

[section ""data" . GHC.Int.eqInt16_closure" {
     GHC.Int.eqInt16_closure:
         const GHC.Int.eqInt16_info;
 },
 GHC.Int.eqInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tPg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tPk; else goto c4tPl;
       c4tPk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tPl: // global
           I64[Sp - 16] = block_c4tPd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tPu; else goto c4tPe;
       u4tPu: // global
           call _c4tPd(R1) args: 0, res: 0, upd: 0;
       c4tPe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.eqInt16_info" {
     GHC.Int.eqInt16_info:
         const GHC.Int.eqInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tPd() //  [R1]
         { []
         }
     {offset
       c4tPd: // global
           I64[Sp] = block_c4tPj_info;
           _s4leU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4leU::I64;
           if (R1 & 7 != 0) goto u4tPt; else goto c4tPn;
       u4tPt: // global
           call _c4tPj(R1) args: 0, res: 0, upd: 0;
       c4tPn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tPd_info" {
     block_c4tPd_info:
         const _c4tPd;
         const 1;
         const 30;
 },
 _c4tPj() //  [R1]
         { []
         }
     {offset
       c4tPj: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tPj_info" {
     block_c4tPj_info:
         const _c4tPj;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.097309116 UTC

[section ""data" . GHC.Int.$fEqInt16_closure" {
     GHC.Int.$fEqInt16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt16_closure+2;
         const GHC.Int.neInt16_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.102166452 UTC

[section ""data" . GHC.Int.gtInt16_closure" {
     GHC.Int.gtInt16_closure:
         const GHC.Int.gtInt16_info;
 },
 GHC.Int.gtInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tPU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tPY; else goto c4tPZ;
       c4tPY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tPZ: // global
           I64[Sp - 16] = block_c4tPR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tQ8; else goto c4tPS;
       u4tQ8: // global
           call _c4tPR(R1) args: 0, res: 0, upd: 0;
       c4tPS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.gtInt16_info" {
     GHC.Int.gtInt16_info:
         const GHC.Int.gtInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tPR() //  [R1]
         { []
         }
     {offset
       c4tPR: // global
           I64[Sp] = block_c4tPX_info;
           _s4lf1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lf1::I64;
           if (R1 & 7 != 0) goto u4tQ7; else goto c4tQ1;
       u4tQ7: // global
           call _c4tPX(R1) args: 0, res: 0, upd: 0;
       c4tQ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tPR_info" {
     block_c4tPR_info:
         const _c4tPR;
         const 1;
         const 30;
 },
 _c4tPX() //  [R1]
         { []
         }
     {offset
       c4tPX: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tPX_info" {
     block_c4tPX_info:
         const _c4tPX;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.111998942 UTC

[section ""data" . GHC.Int.geInt16_closure" {
     GHC.Int.geInt16_closure:
         const GHC.Int.geInt16_info;
 },
 GHC.Int.geInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tQx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tQB; else goto c4tQC;
       c4tQB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tQC: // global
           I64[Sp - 16] = block_c4tQu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tQL; else goto c4tQv;
       u4tQL: // global
           call _c4tQu(R1) args: 0, res: 0, upd: 0;
       c4tQv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.geInt16_info" {
     GHC.Int.geInt16_info:
         const GHC.Int.geInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tQu() //  [R1]
         { []
         }
     {offset
       c4tQu: // global
           I64[Sp] = block_c4tQA_info;
           _s4lf8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lf8::I64;
           if (R1 & 7 != 0) goto u4tQK; else goto c4tQE;
       u4tQK: // global
           call _c4tQA(R1) args: 0, res: 0, upd: 0;
       c4tQE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tQu_info" {
     block_c4tQu_info:
         const _c4tQu;
         const 1;
         const 30;
 },
 _c4tQA() //  [R1]
         { []
         }
     {offset
       c4tQA: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tQA_info" {
     block_c4tQA_info:
         const _c4tQA;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.123066763 UTC

[section ""data" . GHC.Int.ltInt16_closure" {
     GHC.Int.ltInt16_closure:
         const GHC.Int.ltInt16_info;
 },
 GHC.Int.ltInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tRa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tRe; else goto c4tRf;
       c4tRe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tRf: // global
           I64[Sp - 16] = block_c4tR7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tRo; else goto c4tR8;
       u4tRo: // global
           call _c4tR7(R1) args: 0, res: 0, upd: 0;
       c4tR8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.ltInt16_info" {
     GHC.Int.ltInt16_info:
         const GHC.Int.ltInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tR7() //  [R1]
         { []
         }
     {offset
       c4tR7: // global
           I64[Sp] = block_c4tRd_info;
           _s4lff::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lff::I64;
           if (R1 & 7 != 0) goto u4tRn; else goto c4tRh;
       u4tRn: // global
           call _c4tRd(R1) args: 0, res: 0, upd: 0;
       c4tRh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tR7_info" {
     block_c4tR7_info:
         const _c4tR7;
         const 1;
         const 30;
 },
 _c4tRd() //  [R1]
         { []
         }
     {offset
       c4tRd: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tRd_info" {
     block_c4tRd_info:
         const _c4tRd;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.131266137 UTC

[section ""data" . GHC.Int.leInt16_closure" {
     GHC.Int.leInt16_closure:
         const GHC.Int.leInt16_info;
 },
 GHC.Int.leInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tRN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tRR; else goto c4tRS;
       c4tRR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tRS: // global
           I64[Sp - 16] = block_c4tRK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tS1; else goto c4tRL;
       u4tS1: // global
           call _c4tRK(R1) args: 0, res: 0, upd: 0;
       c4tRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.leInt16_info" {
     GHC.Int.leInt16_info:
         const GHC.Int.leInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tRK() //  [R1]
         { []
         }
     {offset
       c4tRK: // global
           I64[Sp] = block_c4tRQ_info;
           _s4lfm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lfm::I64;
           if (R1 & 7 != 0) goto u4tS0; else goto c4tRU;
       u4tS0: // global
           call _c4tRQ(R1) args: 0, res: 0, upd: 0;
       c4tRU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tRK_info" {
     block_c4tRK_info:
         const _c4tRK;
         const 1;
         const 30;
 },
 _c4tRQ() //  [R1]
         { []
         }
     {offset
       c4tRQ: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tRQ_info" {
     block_c4tRQ_info:
         const _c4tRQ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.140725894 UTC

[section ""data" . GHC.Int.$fOrdInt16_$ccompare_closure" {
     GHC.Int.$fOrdInt16_$ccompare_closure:
         const GHC.Int.$fOrdInt16_$ccompare_info;
 },
 GHC.Int.$fOrdInt16_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tSq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tSu; else goto c4tSv;
       c4tSu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tSv: // global
           I64[Sp - 16] = block_c4tSn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tSO; else goto c4tSo;
       u4tSO: // global
           call _c4tSn(R1) args: 0, res: 0, upd: 0;
       c4tSo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt16_$ccompare_info" {
     GHC.Int.$fOrdInt16_$ccompare_info:
         const GHC.Int.$fOrdInt16_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tSn() //  [R1]
         { []
         }
     {offset
       c4tSn: // global
           I64[Sp] = block_c4tSt_info;
           _s4lft::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lft::I64;
           if (R1 & 7 != 0) goto u4tSN; else goto c4tSx;
       u4tSN: // global
           call _c4tSt(R1) args: 0, res: 0, upd: 0;
       c4tSx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tSn_info" {
     block_c4tSn_info:
         const _c4tSn;
         const 1;
         const 30;
 },
 _c4tSt() //  [R1]
         { []
         }
     {offset
       c4tSt: // global
           _s4lft::I64 = I64[Sp + 8];
           _s4lfv::I64 = I64[R1 + 7];
           if (_s4lft::I64 == _s4lfv::I64) goto c4tSM; else goto c4tSL;
       c4tSM: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tSL: // global
           if (%MO_S_Gt_W64(_s4lft::I64,
                            _s4lfv::I64)) goto c4tSI; else goto c4tSJ;
       c4tSI: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tSJ: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tSt_info" {
     block_c4tSt_info:
         const _c4tSt;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.151184194 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmax_closure" {
     GHC.Int.$fOrdInt16_$cmax_closure:
         const GHC.Int.$fOrdInt16_$cmax_info;
 },
 GHC.Int.$fOrdInt16_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tTc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tTg; else goto c4tTh;
       c4tTg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tTh: // global
           I64[Sp - 16] = block_c4tT9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tTu; else goto c4tTa;
       u4tTu: // global
           call _c4tT9(R1) args: 0, res: 0, upd: 0;
       c4tTa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt16_$cmax_info" {
     GHC.Int.$fOrdInt16_$cmax_info:
         const GHC.Int.$fOrdInt16_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tT9() //  [R1]
         { []
         }
     {offset
       c4tT9: // global
           I64[Sp - 8] = block_c4tTf_info;
           _s4lfA::P64 = R1;
           _s4lfB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lfB::I64;
           P64[Sp + 8] = _s4lfA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tTt; else goto c4tTj;
       u4tTt: // global
           call _c4tTf(R1) args: 0, res: 0, upd: 0;
       c4tTj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tT9_info" {
     block_c4tT9_info:
         const _c4tT9;
         const 1;
         const 30;
 },
 _c4tTf() //  [R1]
         { []
         }
     {offset
       c4tTf: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4tTr; else goto c4tTs;
       c4tTr: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tTs: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tTf_info" {
     block_c4tTf_info:
         const _c4tTf;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.161432914 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmin_closure" {
     GHC.Int.$fOrdInt16_$cmin_closure:
         const GHC.Int.$fOrdInt16_$cmin_info;
 },
 GHC.Int.$fOrdInt16_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tTU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tTY; else goto c4tTZ;
       c4tTY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tTZ: // global
           I64[Sp - 16] = block_c4tTR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tUc; else goto c4tTS;
       u4tUc: // global
           call _c4tTR(R1) args: 0, res: 0, upd: 0;
       c4tTS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt16_$cmin_info" {
     GHC.Int.$fOrdInt16_$cmin_info:
         const GHC.Int.$fOrdInt16_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tTR() //  [R1]
         { []
         }
     {offset
       c4tTR: // global
           I64[Sp - 8] = block_c4tTX_info;
           _s4lfH::P64 = R1;
           _s4lfI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lfI::I64;
           P64[Sp + 8] = _s4lfH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tUb; else goto c4tU1;
       u4tUb: // global
           call _c4tTX(R1) args: 0, res: 0, upd: 0;
       c4tU1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tTR_info" {
     block_c4tTR_info:
         const _c4tTR;
         const 1;
         const 30;
 },
 _c4tTX() //  [R1]
         { []
         }
     {offset
       c4tTX: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4tU9; else goto c4tUa;
       c4tU9: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4tUa: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tTX_info" {
     block_c4tTX_info:
         const _c4tTX;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.169019496 UTC

[section ""data" . GHC.Int.$fOrdInt16_closure" {
     GHC.Int.$fOrdInt16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fOrdInt16_$ccompare_closure+2;
         const GHC.Int.ltInt16_closure+2;
         const GHC.Int.leInt16_closure+2;
         const GHC.Int.gtInt16_closure+2;
         const GHC.Int.geInt16_closure+2;
         const GHC.Int.$fOrdInt16_$cmax_closure+2;
         const GHC.Int.$fOrdInt16_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.173567237 UTC

[section ""data" . GHC.Int.$fIxInt16_$cinRange_closure" {
     GHC.Int.$fIxInt16_$cinRange_closure:
         const GHC.Int.$fIxInt16_$cinRange_info;
 },
 GHC.Int.$fIxInt16_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tUD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tUM; else goto c4tUN;
       c4tUM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tUN: // global
           I64[Sp - 16] = block_c4tUA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tVa; else goto c4tUB;
       u4tVa: // global
           call _c4tUA(R1) args: 0, res: 0, upd: 0;
       c4tUB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$cinRange_info" {
     GHC.Int.$fIxInt16_$cinRange_info:
         const GHC.Int.$fIxInt16_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tUA() //  [R1]
         { []
         }
     {offset
       c4tUA: // global
           I64[Sp - 8] = block_c4tUG_info;
           _s4lfQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lfQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tV9; else goto c4tUH;
       u4tV9: // global
           call _c4tUG(R1) args: 0, res: 0, upd: 0;
       c4tUH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tUA_info" {
     block_c4tUA_info:
         const _c4tUA;
         const 1;
         const 30;
 },
 _c4tUG() //  [R1]
         { []
         }
     {offset
       c4tUG: // global
           I64[Sp] = block_c4tUL_info;
           _s4lfS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lfS::I64;
           if (R1 & 7 != 0) goto u4tVb; else goto c4tUQ;
       u4tVb: // global
           call _c4tUL(R1) args: 0, res: 0, upd: 0;
       c4tUQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tUG_info" {
     block_c4tUG_info:
         const _c4tUG;
         const 2;
         const 30;
 },
 _c4tUL() //  [R1]
         { []
         }
     {offset
       c4tUL: // global
           _s4lfU::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lfU::I64)) goto c4tUY; else goto c4tV2;
       c4tUY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tV2: // global
           _s4lfQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4tV1_info;
           R1 = _s4lfQ::P64;
           I64[Sp + 16] = _s4lfU::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4tVc; else goto c4tV3;
       u4tVc: // global
           call _c4tV1(R1) args: 0, res: 0, upd: 0;
       c4tV3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tUL_info" {
     block_c4tUL_info:
         const _c4tUL;
         const 130;
         const 30;
 },
 _c4tV1() //  [R1]
         { []
         }
     {offset
       c4tV1: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tV1_info" {
     block_c4tV1_info:
         const _c4tV1;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.185599452 UTC

[section ""data" . GHC.Int.$fNumInt1_closure" {
     GHC.Int.$fNumInt1_closure:
         const GHC.Int.I16#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.188730349 UTC

[section ""data" . GHC.Int.$fNumInt16_$csignum_closure" {
     GHC.Int.$fNumInt16_$csignum_closure:
         const GHC.Int.$fNumInt16_$csignum_info;
 },
 GHC.Int.$fNumInt16_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c4tVL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tVM; else goto c4tVN;
       c4tVM: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tVN: // global
           I64[Sp - 8] = block_c4tVI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tW1; else goto c4tVJ;
       u4tW1: // global
           call _c4tVI(R1) args: 0, res: 0, upd: 0;
       c4tVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$csignum_info" {
     GHC.Int.$fNumInt16_$csignum_info:
         const GHC.Int.$fNumInt16_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4tVI() //  [R1]
         { []
         }
     {offset
       c4tVI: // global
           _s4lg1::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lg1::I64, 0)) goto c4tVZ; else goto c4tW0;
       c4tVZ: // global
           if (_s4lg1::I64 == 0) goto c4tVX; else goto c4tVW;
       c4tVX: // global
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tVW: // global
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tW0: // global
           R1 = GHC.Int.$fNumInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tVI_info" {
     block_c4tVI_info:
         const _c4tVI;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.195560057 UTC

[section ""data" . GHC.Int.$fNumInt16_$cabs_closure" {
     GHC.Int.$fNumInt16_$cabs_closure:
         const GHC.Int.$fNumInt16_$cabs_info;
 },
 GHC.Int.$fNumInt16_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c4tWl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tWm; else goto c4tWn;
       c4tWm: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tWn: // global
           I64[Sp - 8] = block_c4tWi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tWG; else goto c4tWj;
       u4tWG: // global
           call _c4tWi(R1) args: 0, res: 0, upd: 0;
       c4tWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$cabs_info" {
     GHC.Int.$fNumInt16_$cabs_info:
         const GHC.Int.$fNumInt16_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4tWi() //  [R1]
         { []
         }
     {offset
       c4tWi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tWs; else goto c4tWr;
       c4tWs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tWr: // global
           _s4lg6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lg6::I64, 0)) goto c4tWE; else goto c4tWF;
       c4tWE: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-_s4lg6::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tWF: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tWi_info" {
     block_c4tWi_info:
         const _c4tWi;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.201988819 UTC

[section ""data" . GHC.Int.$fNumInt16_closure" {
     GHC.Int.$fNumInt16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt16_$c+_closure+2;
         const GHC.Int.$fNumInt16_$c-_closure+2;
         const GHC.Int.$fNumInt16_$c*_closure+2;
         const GHC.Int.$fNumInt16_$cnegate_closure+1;
         const GHC.Int.$fNumInt16_$cabs_closure+1;
         const GHC.Int.$fNumInt16_$csignum_closure+1;
         const GHC.Int.$fNumInt16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.204132117 UTC

[section ""data" . GHC.Int.$fBitsInt2_closure" {
     GHC.Int.$fBitsInt2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.20728546 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt16_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c4tX1: // global
           R1 = GHC.Int.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cbitSizeMaybe_info" {
     GHC.Int.$fBitsInt16_$cbitSizeMaybe_info:
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.213635413 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbit_closure" {
     GHC.Int.$fBitsInt16_$cbit_closure:
         const GHC.Int.$fBitsInt16_$cbit_info;
 },
 GHC.Int.$fBitsInt16_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c4tXg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4tXh; else goto c4tXi;
       c4tXh: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4tXi: // global
           I64[Sp - 8] = block_c4tXd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4tXB; else goto c4tXe;
       u4tXB: // global
           call _c4tXd(R1) args: 0, res: 0, upd: 0;
       c4tXe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cbit_info" {
     GHC.Int.$fBitsInt16_$cbit_info:
         const GHC.Int.$fBitsInt16_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4tXd() //  [R1]
         { []
         }
     {offset
       c4tXd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4tXn; else goto c4tXm;
       c4tXn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4tXm: // global
           _s4lgd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lgd::I64, 64)) goto c4tXz; else goto c4tXA;
       c4tXz: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgd::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tXA: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tXd_info" {
     block_c4tXd_info:
         const _c4tXd;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.222098716 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ctestBit_closure" {
     GHC.Int.$fBitsInt16_$ctestBit_closure:
         const GHC.Int.$fBitsInt16_$ctestBit_info;
 },
 GHC.Int.$fBitsInt16_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tXX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4tY1; else goto c4tY2;
       c4tY1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tY2: // global
           I64[Sp - 16] = block_c4tXU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4tYK; else goto c4tXV;
       u4tYK: // global
           call _c4tXU(R1) args: 0, res: 0, upd: 0;
       c4tXV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$ctestBit_info" {
     GHC.Int.$fBitsInt16_$ctestBit_info:
         const GHC.Int.$fBitsInt16_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tXU() //  [R1]
         { []
         }
     {offset
       c4tXU: // global
           I64[Sp] = block_c4tY0_info;
           _s4lgk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lgk::I64;
           if (R1 & 7 != 0) goto u4tYJ; else goto c4tY4;
       u4tYJ: // global
           call _c4tY0(R1) args: 0, res: 0, upd: 0;
       c4tY4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tXU_info" {
     block_c4tXU_info:
         const _c4tXU;
         const 1;
         const 30;
 },
 _c4tY0() //  [R1]
         { []
         }
     {offset
       c4tY0: // global
           _s4lgm::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4lgm::I64, 64)) goto c4tYI; else goto c4tYH;
       c4tYH: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgm::I64)) == 0) goto c4tYI; else goto c4tYw;
       c4tYI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4tYw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tY0_info" {
     block_c4tY0_info:
         const _c4tY0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.231732057 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateR_closure" {
     GHC.Int.$fBitsInt16_$crotateR_closure:
         const GHC.Int.$fBitsInt16_$crotateR_info;
 },
 GHC.Int.$fBitsInt16_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4tZc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4tZg; else goto c4tZh;
       c4tZg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4tZh: // global
           I64[Sp - 16] = block_c4tZ9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u0g; else goto c4tZa;
       u4u0g: // global
           call _c4tZ9(R1) args: 0, res: 0, upd: 0;
       c4tZa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$crotateR_info" {
     GHC.Int.$fBitsInt16_$crotateR_info:
         const GHC.Int.$fBitsInt16_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4tZ9() //  [R1]
         { []
         }
     {offset
       c4tZ9: // global
           I64[Sp - 8] = block_c4tZf_info;
           _s4lgw::P64 = R1;
           _s4lgx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lgx::I64;
           P64[Sp + 8] = _s4lgw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4u0f; else goto c4tZj;
       u4u0f: // global
           call _c4tZf(R1) args: 0, res: 0, upd: 0;
       c4tZj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tZ9_info" {
     block_c4tZ9_info:
         const _c4tZ9;
         const 1;
         const 30;
 },
 _c4tZf() //  [R1]
         { []
         }
     {offset
       c4tZf: // global
           _s4lgD::I64 = -I64[R1 + 7] & 15;
           if (_s4lgD::I64 != 0) goto u4u0d; else goto c4u09;
       u4u0d: // global
           I64[Sp + 16] = _s4lgD::I64;
           Sp = Sp + 8;
           call _c4tZB() args: 0, res: 0, upd: 0;
       c4u09: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4tZf_info" {
     block_c4tZf_info:
         const _c4tZf;
         const 66;
         const 30;
 },
 _c4tZB() //  []
         { []
         }
     {offset
       c4tZB: // global
           Hp = Hp + 16;
           _s4lgD::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4u06; else goto c4u05;
       c4u06: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4tZA_info;
           R1 = _s4lgD::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4u05: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4lgE::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4lgE::I64 << _s4lgD::I64) | (_s4lgE::I64 >> 16 - _s4lgD::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4tZA() //  [R1]
         { []
         }
     {offset
       c4tZA: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4tZB() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4tZA_info" {
     block_c4tZA_info:
         const _c4tZA;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.244421378 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt16_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt16_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt16_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4u0T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4u0X; else goto c4u0Y;
       c4u0X: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u0Y: // global
           I64[Sp - 16] = block_c4u0Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u1x; else goto c4u0R;
       u4u1x: // global
           call _c4u0Q(R1) args: 0, res: 0, upd: 0;
       c4u0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$ccomplementBit_info" {
     GHC.Int.$fBitsInt16_$ccomplementBit_info:
         const GHC.Int.$fBitsInt16_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4u0Q() //  [R1]
         { []
         }
     {offset
       c4u0Q: // global
           I64[Sp - 8] = block_c4u0W_info;
           _s4lgO::P64 = R1;
           _s4lgP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lgP::I64;
           P64[Sp + 8] = _s4lgO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4u1w; else goto c4u10;
       u4u1w: // global
           call _c4u0W(R1) args: 0, res: 0, upd: 0;
       c4u10: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u0Q_info" {
     block_c4u0Q_info:
         const _c4u0Q;
         const 1;
         const 30;
 },
 _c4u0W() //  [R1]
         { []
         }
     {offset
       c4u0W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u16; else goto c4u15;
       c4u16: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u15: // global
           _s4lgR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lgR::I64, 64)) goto c4u1u; else goto c4u1v;
       c4u1u: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lgR::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u1v: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u0W_info" {
     block_c4u0W_info:
         const _c4u0W;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.254831085 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cclearBit_closure" {
     GHC.Int.$fBitsInt16_$cclearBit_closure:
         const GHC.Int.$fBitsInt16_$cclearBit_info;
 },
 GHC.Int.$fBitsInt16_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4u20: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u24; else goto c4u25;
       c4u24: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u25: // global
           I64[Sp - 16] = block_c4u1X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u2S; else goto c4u1Y;
       u4u2S: // global
           call _c4u1X(R1) args: 0, res: 0, upd: 0;
       c4u1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cclearBit_info" {
     GHC.Int.$fBitsInt16_$cclearBit_info:
         const GHC.Int.$fBitsInt16_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4u1X() //  [R1]
         { []
         }
     {offset
       c4u1X: // global
           I64[Sp] = block_c4u23_info;
           _s4lh2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lh2::I64;
           if (R1 & 7 != 0) goto u4u2R; else goto c4u27;
       u4u2R: // global
           call _c4u23(R1) args: 0, res: 0, upd: 0;
       c4u27: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u1X_info" {
     block_c4u1X_info:
         const _c4u1X;
         const 1;
         const 30;
 },
 _c4u23() //  [R1]
         { []
         }
     {offset
       c4u23: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u2d; else goto c4u2c;
       c4u2d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u2c: // global
           _s4lh2::I64 = I64[Sp + 8];
           _s4lh4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lh4::I64, 64)) goto c4u2E; else goto c4u2Q;
       c4u2E: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lh2::I64 & ~%MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lh4::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u2Q: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lh2::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u23_info" {
     block_c4u23_info:
         const _c4u23;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.266780417 UTC

[section ""data" . GHC.Int.$fBitsInt16_$csetBit_closure" {
     GHC.Int.$fBitsInt16_$csetBit_closure:
         const GHC.Int.$fBitsInt16_$csetBit_info;
 },
 GHC.Int.$fBitsInt16_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4u3m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4u3q; else goto c4u3r;
       c4u3q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u3r: // global
           I64[Sp - 16] = block_c4u3j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u40; else goto c4u3k;
       u4u40: // global
           call _c4u3j(R1) args: 0, res: 0, upd: 0;
       c4u3k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$csetBit_info" {
     GHC.Int.$fBitsInt16_$csetBit_info:
         const GHC.Int.$fBitsInt16_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4u3j() //  [R1]
         { []
         }
     {offset
       c4u3j: // global
           I64[Sp - 8] = block_c4u3p_info;
           _s4lhi::P64 = R1;
           _s4lhj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lhj::I64;
           P64[Sp + 8] = _s4lhi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4u3Z; else goto c4u3t;
       u4u3Z: // global
           call _c4u3p(R1) args: 0, res: 0, upd: 0;
       c4u3t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u3j_info" {
     block_c4u3j_info:
         const _c4u3j;
         const 1;
         const 30;
 },
 _c4u3p() //  [R1]
         { []
         }
     {offset
       c4u3p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u3z; else goto c4u3y;
       c4u3z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u3y: // global
           _s4lhl::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lhl::I64, 64)) goto c4u3X; else goto c4u3Y;
       c4u3X: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4lhl::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u3Y: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u3p_info" {
     block_c4u3p_info:
         const _c4u3p;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.274393526 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateL_closure" {
     GHC.Int.$fBitsInt16_$crotateL_closure:
         const GHC.Int.$fBitsInt16_$crotateL_info;
 },
 GHC.Int.$fBitsInt16_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4u4q: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt16_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$crotateL_info" {
     GHC.Int.$fBitsInt16_$crotateL_info:
         const GHC.Int.$fBitsInt16_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.278554124 UTC

[section ""data" . GHC.Int.$fBitsInt16_closure" {
     GHC.Int.$fBitsInt16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fBitsInt16_$c.&._closure+2;
         const GHC.Int.$fBitsInt16_$c.|._closure+2;
         const GHC.Int.$fBitsInt16_$cxor_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt16_$cshift_closure+2;
         const GHC.Int.$fBitsInt16_$crotate_closure+2;
         const GHC.Int.$fBitsInt3_closure+1;
         const GHC.Int.$fBitsInt16_$cbit_closure+1;
         const GHC.Int.$fBitsInt16_$csetBit_closure+2;
         const GHC.Int.$fBitsInt16_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt16_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt16_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt16_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt16_$crotateL_closure+2;
         const GHC.Int.$fBitsInt16_$crotateR_closure+2;
         const GHC.Int.$fBitsInt16_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.280934679 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_closure" {
     GHC.Int.$fFiniteBitsInt16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt16_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.286641259 UTC

[section ""data" . GHC.Int.$fReadInt16_go_closure" {
     GHC.Int.$fReadInt16_go_closure:
         const GHC.Int.$fReadInt16_go_info;
 },
 sat_s4lhF_entry() //  [R1]
         { []
         }
     {offset
       c4u4S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u4T; else goto c4u4U;
       c4u4T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4u4U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4lhF_info" {
     sat_s4lhF_info:
         const sat_s4lhF_entry;
         const 1;
         const 16;
 },
 sat_s4lhD_entry() //  [R1]
         { []
         }
     {offset
       c4u52: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4u59; else goto c4u5a;
       c4u59: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4u5a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4u4Z_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4u5e; else goto c4u50;
       u4u5e: // global
           call _c4u4Z(R1) args: 0, res: 0, upd: 0;
       c4u50: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4lhD_info" {
     sat_s4lhD_info:
         const sat_s4lhD_entry;
         const 1;
         const 16;
 },
 _c4u4Z() //  [R1]
         { []
         }
     {offset
       c4u4Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u5d; else goto c4u5c;
       c4u5d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4u5c: // global
           _s4lhC::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4lhC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4u4Z_info" {
     block_c4u4Z_info:
         const _c4u4Z;
         const 0;
         const 30;
 },
 GHC.Int.$fReadInt16_go_entry() //  [R2]
         { []
         }
     {offset
       c4u5j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u5k; else goto c4u5l;
       c4u5k: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4u5l: // global
           I64[Sp - 8] = block_c4u4D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4u5v; else goto c4u4E;
       u4u5v: // global
           call _c4u4D(R1) args: 0, res: 0, upd: 0;
       c4u4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt16_go_info" {
     GHC.Int.$fReadInt16_go_info:
         const GHC.Int.$fReadInt16_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4u4D() //  [R1]
         { []
         }
     {offset
       c4u4D: // global
           if (R1 & 7 == 1) goto c4u5g; else goto c4u5h;
       c4u5g: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u5h: // global
           I64[Sp - 8] = block_c4u4J_info;
           _s4lhw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lhw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4u5u; else goto c4u4K;
       u4u5u: // global
           call _c4u4J(R1) args: 0, res: 0, upd: 0;
       c4u4K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u4D_info" {
     block_c4u4D_info:
         const _c4u4D;
         const 0;
         const 30;
 },
 _c4u4J() //  [R1]
         { []
         }
     {offset
       c4u4J: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4u5t; else goto c4u5s;
       c4u5t: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u5s: // global
           _s4lhy::P64 = P64[R1 + 7];
           _s4lhz::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lhF_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lhD_info;
           P64[Hp - 48] = _s4lhy::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lhz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u4J_info" {
     block_c4u4J_info:
         const _c4u4J;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.304002515 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadsPrec_closure" {
     GHC.Int.$fReadInt16_$creadsPrec_closure:
         const GHC.Int.$fReadInt16_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c4u6b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u6f; else goto c4u6g;
       c4u6f: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u6g: // global
           I64[Sp - 16] = block_c4u69_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lhH::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lhH::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt16_$creadsPrec_info" {
     GHC.Int.$fReadInt16_$creadsPrec_info:
         const GHC.Int.$fReadInt16_$creadsPrec_entry;
         const 0;
         const 1152921517491748878;
         const 8589934607;
         const S4lDl_srt+472;
 },
 _c4u69() //  [R1]
         { []
         }
     {offset
       c4u69: // global
           _s4lhH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4u6e_info;
           R3 = _s4lhH::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u69_info" {
     block_c4u69_info:
         const _c4u69;
         const 1;
         const 30;
 },
 _c4u6e() //  [R1]
         { []
         }
     {offset
       c4u6e: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u6e_info" {
     block_c4u6e_info:
         const _c4u6e;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.313823965 UTC

[section ""data" . GHC.Int.$fReadInt3_closure" {
     GHC.Int.$fReadInt3_closure:
         const GHC.Int.$fReadInt3_info;
         const 0;
 },
 sat_s4lhM_entry() //  [R1, R2]
         { []
         }
     {offset
       c4u6G: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt16_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s4lhM_info" {
     sat_s4lhM_info:
         const sat_s4lhM_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S4lDl_srt+696;
 },
 GHC.Int.$fReadInt3_entry() //  [R2, R3]
         { []
         }
     {offset
       c4u6M: // global
           _s4lhL::P64 = R3;
           _s4lhK::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4u6N; else goto c4u6O;
       c4u6O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u6Q; else goto c4u6P;
       c4u6Q: // global
           HpAlloc = 16;
           goto c4u6N;
       c4u6N: // global
           R3 = _s4lhL::P64;
           R2 = _s4lhK::P64;
           R1 = GHC.Int.$fReadInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u6P: // global
           I64[Hp - 8] = sat_s4lhM_info;
           P64[Hp] = _s4lhK::P64;
           I64[Sp - 8] = block_c4u6J_info;
           R3 = _s4lhL::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt3_info" {
     GHC.Int.$fReadInt3_info:
         const GHC.Int.$fReadInt3_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+696;
 },
 _c4u6J() //  [R1]
         { []
         }
     {offset
       c4u6J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u6T; else goto c4u6S;
       c4u6T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u6S: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u6J_info" {
     block_c4u6J_info:
         const _c4u6J;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.323560412 UTC

[section ""data" . GHC.Int.$fReadInt2_closure" {
     GHC.Int.$fReadInt2_closure:
         const GHC.Int.$fReadInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt2_entry() //  [R1]
         { []
         }
     {offset
       c4u7c: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4u7d; else goto c4u7e;
       c4u7d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4u7e: // global
           (_c4u79::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4u79::I64 == 0) goto c4u7b; else goto c4u7a;
       c4u7b: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4u7a: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4u79::I64;
           R2 = GHC.Int.$fReadInt3_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt2_info" {
     GHC.Int.$fReadInt2_info:
         const GHC.Int.$fReadInt2_entry;
         const 0;
         const 144115192370823189;
         const S4lDl_srt+504;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.3284808 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadList_closure" {
     GHC.Int.$fReadInt16_$creadList_closure:
         const GHC.Int.$fReadInt16_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadList_entry() //  [R2]
         { []
         }
     {offset
       c4u7q: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt2_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt16_$creadList_info" {
     GHC.Int.$fReadInt16_$creadList_info:
         const GHC.Int.$fReadInt16_$creadList_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S4lDl_srt+712;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.333415822 UTC

[section ""data" . GHC.Int.$fReadInt1_closure" {
     GHC.Int.$fReadInt1_closure:
         const GHC.Int.$fReadInt1_info;
         const 0;
 },
 GHC.Int.$fReadInt1_entry() //  [R2, R3]
         { []
         }
     {offset
       c4u7E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4u7F; else goto c4u7G;
       c4u7F: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u7G: // global
           I64[Sp - 8] = block_c4u7B_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt16_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt1_info" {
     GHC.Int.$fReadInt1_info:
         const GHC.Int.$fReadInt1_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+720;
 },
 _c4u7B() //  [R1]
         { []
         }
     {offset
       c4u7B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u7J; else goto c4u7I;
       c4u7J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u7I: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u7B_info" {
     block_c4u7B_info:
         const _c4u7B;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.33917748 UTC

[section ""data" . GHC.Int.$fReadInt16_closure" {
     GHC.Int.$fReadInt16_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt16_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt16_$creadList_closure+1;
         const GHC.Int.$fReadInt3_closure+2;
         const GHC.Int.$fReadInt1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.343022255 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquot_closure" {
     GHC.Int.$fIntegralInt16_$cquot_closure:
         const GHC.Int.$fIntegralInt16_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c4u81: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u85; else goto c4u86;
       c4u85: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u86: // global
           I64[Sp - 16] = block_c4u7Y_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u8H; else goto c4u7Z;
       u4u8H: // global
           call _c4u7Y(R1) args: 0, res: 0, upd: 0;
       c4u7Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$cquot_info" {
     GHC.Int.$fIntegralInt16_$cquot_info:
         const GHC.Int.$fIntegralInt16_$cquot_entry;
         const 0;
         const 144115200960757774;
         const 8589934607;
         const S4lDl_srt+536;
 },
 _c4u7Y() //  [R1]
         { []
         }
     {offset
       c4u7Y: // global
           I64[Sp] = block_c4u84_info;
           _s4lhW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lhW::I64;
           if (R1 & 7 != 0) goto u4u8G; else goto c4u88;
       u4u8G: // global
           call _c4u84(R1) args: 0, res: 0, upd: 0;
       c4u88: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u7Y_info" {
     block_c4u7Y_info:
         const _c4u7Y;
         const 1;
         const 12884901918;
         const S4lDl_srt+536;
 },
 _c4u84() //  [R1]
         { []
         }
     {offset
       c4u84: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u8e; else goto c4u8d;
       c4u8e: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u8d: // global
           _s4lhW::I64 = I64[Sp + 8];
           _s4lhZ::I64 = I64[R1 + 7];
           if (_s4lhZ::I64 != (-1)) goto u4u8F; else goto c4u8D;
       u4u8F: // global
           if (_s4lhZ::I64 != 0) goto c4u8p; else goto c4u8E;
       c4u8p: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4lhW::I64,
                                                                            _s4lhZ::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u8E: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4u8D: // global
           if (_s4lhW::I64 == (-32768)) goto c4u8C; else goto c4u8B;
       c4u8C: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4u8B: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4lhW::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u84_info" {
     block_c4u84_info:
         const _c4u84;
         const 65;
         const 12884901918;
         const S4lDl_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.35315033 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$crem_closure" {
     GHC.Int.$fIntegralInt16_$crem_closure:
         const GHC.Int.$fIntegralInt16_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4u99: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4u9d; else goto c4u9e;
       c4u9d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4u9e: // global
           I64[Sp - 16] = block_c4u96_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4u9A; else goto c4u97;
       u4u9A: // global
           call _c4u96(R1) args: 0, res: 0, upd: 0;
       c4u97: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$crem_info" {
     GHC.Int.$fIntegralInt16_$crem_info:
         const GHC.Int.$fIntegralInt16_$crem_entry;
         const 0;
         const 288230380446679054;
         const 8589934607;
         const S4lDl_srt+536;
 },
 _c4u96() //  [R1]
         { []
         }
     {offset
       c4u96: // global
           I64[Sp] = block_c4u9c_info;
           _s4lia::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lia::I64;
           if (R1 & 7 != 0) goto u4u9z; else goto c4u9g;
       u4u9z: // global
           call _c4u9c(R1) args: 0, res: 0, upd: 0;
       c4u9g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u96_info" {
     block_c4u96_info:
         const _c4u96;
         const 1;
         const 4294967326;
         const S4lDl_srt+536;
 },
 _c4u9c() //  [R1]
         { []
         }
     {offset
       c4u9c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4u9m; else goto c4u9l;
       c4u9m: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4u9l: // global
           _s4lid::I64 = I64[R1 + 7];
           if (_s4lid::I64 != 0) goto c4u9x; else goto c4u9y;
       c4u9x: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4lid::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4u9y: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4u9c_info" {
     block_c4u9c_info:
         const _c4u9c;
         const 65;
         const 4294967326;
         const S4lDl_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.362552366 UTC

[section ""data" . GHC.Int.$w$cdiv_closure" {
     GHC.Int.$w$cdiv_closure:
         const GHC.Int.$w$cdiv_info;
         const 0;
 },
 GHC.Int.$w$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ua0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ua1; else goto c4ua2;
       c4ua1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ua2: // global
           if (R3 == (-1)) goto c4u9Y; else goto u4uam;
       c4u9Y: // global
           if (R2 == (-32768)) goto c4ual; else goto c4uaj;
       c4ual: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uaj: // global
           I64[Sp - 8] = block_c4uad_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4uam: // global
           if (R3 == 0) goto c4u9Z; else goto c4u9X;
       c4u9Z: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4u9X: // global
           I64[Sp - 8] = block_c4ua4_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdiv_info" {
     GHC.Int.$w$cdiv_info:
         const GHC.Int.$w$cdiv_entry;
         const 0;
         const 576460765188325390;
         const 8589934604;
         const S4lDl_srt+536;
 },
 _c4uad() //  [R1]
         { []
         }
     {offset
       c4uad: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uad_info" {
     block_c4uad_info:
         const _c4uad;
         const 0;
         const 30;
 },
 _c4ua4() //  [R1]
         { []
         }
     {offset
       c4ua4: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ua4_info" {
     block_c4ua4_info:
         const _c4ua4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.371918914 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdiv_closure" {
     GHC.Int.$fIntegralInt16_$cdiv_closure:
         const GHC.Int.$fIntegralInt16_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uaJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uaW; else goto c4uaX;
       c4uaW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uaX: // global
           I64[Sp - 16] = block_c4uaG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ub4; else goto c4uaH;
       u4ub4: // global
           call _c4uaG(R1) args: 0, res: 0, upd: 0;
       c4uaH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$cdiv_info" {
     GHC.Int.$fIntegralInt16_$cdiv_info:
         const GHC.Int.$fIntegralInt16_$cdiv_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+752;
 },
 _c4uaG() //  [R1]
         { []
         }
     {offset
       c4uaG: // global
           I64[Sp] = block_c4uaM_info;
           _s4lir::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lir::I64;
           if (R1 & 7 != 0) goto u4ub3; else goto c4uaN;
       u4ub3: // global
           call _c4uaM(R1) args: 0, res: 0, upd: 0;
       c4uaN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uaG_info" {
     block_c4uaG_info:
         const _c4uaG;
         const 1;
         const 4294967326;
         const S4lDl_srt+752;
 },
 _c4uaM() //  [R1]
         { []
         }
     {offset
       c4uaM: // global
           _s4lir::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4uaR_info;
           R3 = I64[R1 + 7];
           R2 = _s4lir::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uaM_info" {
     block_c4uaM_info:
         const _c4uaM;
         const 65;
         const 4294967326;
         const S4lDl_srt+752;
 },
 _c4uaR() //  [R1]
         { []
         }
     {offset
       c4uaR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ub2; else goto c4ub1;
       c4ub2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ub1: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uaR_info" {
     block_c4uaR_info:
         const _c4uaR;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.384860501 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cmod_closure" {
     GHC.Int.$fIntegralInt16_$cmod_closure:
         const GHC.Int.$fIntegralInt16_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cmod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ubt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ubx; else goto c4uby;
       c4ubx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uby: // global
           I64[Sp - 16] = block_c4ubq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ubW; else goto c4ubr;
       u4ubW: // global
           call _c4ubq(R1) args: 0, res: 0, upd: 0;
       c4ubr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$cmod_info" {
     GHC.Int.$fIntegralInt16_$cmod_info:
         const GHC.Int.$fIntegralInt16_$cmod_entry;
         const 0;
         const 2305843013508661262;
         const 8589934607;
         const S4lDl_srt+536;
 },
 _c4ubq() //  [R1]
         { []
         }
     {offset
       c4ubq: // global
           I64[Sp] = block_c4ubw_info;
           _s4liy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4liy::I64;
           if (R1 & 7 != 0) goto u4ubV; else goto c4ubA;
       u4ubV: // global
           call _c4ubw(R1) args: 0, res: 0, upd: 0;
       c4ubA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ubq_info" {
     block_c4ubq_info:
         const _c4ubq;
         const 1;
         const 4294967326;
         const S4lDl_srt+536;
 },
 _c4ubw() //  [R1]
         { []
         }
     {offset
       c4ubw: // global
           _s4liB::I64 = I64[R1 + 7];
           if (_s4liB::I64 != 0) goto c4ubQ; else goto c4ubU;
       c4ubQ: // global
           _s4liy::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4ubH_info;
           R3 = _s4liB::I64;
           R2 = _s4liy::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4ubU: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ubw_info" {
     block_c4ubw_info:
         const _c4ubw;
         const 65;
         const 4294967326;
         const S4lDl_srt+536;
 },
 _c4ubH() //  [R1]
         { []
         }
     {offset
       c4ubH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ubT; else goto c4ubS;
       c4ubT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ubS: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ubH_info" {
     block_c4ubH_info:
         const _c4ubH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.397739867 UTC

[section ""data" . lvl7_r4kPy_closure" {
     lvl7_r4kPy_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt3_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.401943623 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquotRem_closure" {
     GHC.Int.$fIntegralInt16_$cquotRem_closure:
         const GHC.Int.$fIntegralInt16_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uco: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ucs; else goto c4uct;
       c4ucs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uct: // global
           I64[Sp - 16] = block_c4ucl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ud8; else goto c4ucm;
       u4ud8: // global
           call _c4ucl(R1) args: 0, res: 0, upd: 0;
       c4ucm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$cquotRem_info" {
     GHC.Int.$fIntegralInt16_$cquotRem_info:
         const GHC.Int.$fIntegralInt16_$cquotRem_entry;
         const 0;
         const 13835058059577131022;
         const 8589934607;
         const S4lDl_srt+536;
 },
 _c4ucl() //  [R1]
         { []
         }
     {offset
       c4ucl: // global
           I64[Sp] = block_c4ucr_info;
           _s4liI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4liI::I64;
           if (R1 & 7 != 0) goto u4ud7; else goto c4ucv;
       u4ud7: // global
           call _c4ucr(R1) args: 0, res: 0, upd: 0;
       c4ucv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ucl_info" {
     block_c4ucl_info:
         const _c4ucl;
         const 1;
         const 9223372041149743134;
         const S4lDl_srt+536;
 },
 _c4ucr() //  [R1]
         { []
         }
     {offset
       c4ucr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4ucB; else goto c4ucA;
       c4ucB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ucA: // global
           _s4liI::I64 = I64[Sp + 8];
           _s4liL::I64 = I64[R1 + 7];
           if (_s4liL::I64 != (-1)) goto u4ud6; else goto c4ud4;
       u4ud6: // global
           if (_s4liL::I64 != 0) goto c4ucO; else goto c4ud5;
       c4ucO: // global
           (_s4liN::I64, _s4liO::I64) = call MO_S_QuotRem W64(_s4liI::I64, _s4liL::I64);
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liO::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liN::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ud5: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4ud4: // global
           if (_s4liI::I64 == (-32768)) goto c4ud3; else goto c4ud2;
       c4ud3: // global
           Hp = Hp - 56;
           R1 = lvl7_r4kPy_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ud2: // global
           (_s4liV::I64, _s4liW::I64) = call MO_S_QuotRem W64(_s4liI::I64, (-1));
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liW::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4liV::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ucr_info" {
     block_c4ucr_info:
         const _c4ucr;
         const 65;
         const 9223372041149743134;
         const S4lDl_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.41494983 UTC

[section ""data" . GHC.Int.$w$cdivMod_closure" {
     GHC.Int.$w$cdivMod_closure:
         const GHC.Int.$w$cdivMod_info;
         const 0;
 },
 section ""relreadonly" . u4ugk_srtd" {
     u4ugk_srtd:
         const S4lDl_srt+536;
         const 33;
         const 4294967299;
 },
 GHC.Int.$w$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4udK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4udL; else goto c4udM;
       c4udL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4udM: // global
           if (R3 == 0) goto c4udJ; else goto c4udI;
       c4udJ: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4udI: // global
           if (R3 == (-1)) goto c4ugf; else goto u4ugg;
       c4ugf: // global
           if (R2 == (-32768)) goto c4uge; else goto u4ugh;
       c4uge: // global
           R2 = GHC.Int.$fBitsInt3_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4ugh: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4ugj;
       u4ugg: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4ugj;
       u4ugj: // global
           call _c4udR() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdivMod_info" {
     GHC.Int.$w$cdivMod_info:
         const GHC.Int.$w$cdivMod_entry;
         const 0;
         const 18446744069414584334;
         const 8589934604;
         const u4ugk_srtd;
 },
 _c4udR() //  []
         { []
         }
     {offset
       c4udR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4udV; else goto c4udU;
       c4udV: // global
           HpAlloc = 32;
           I64[Sp] = block_c4udR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4udU: // global
           _s4lj2::I64 = I64[Sp + 8];
           _s4lj4::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lj2::I64, 0)) goto c4ueO; else goto c4ug5;
       c4ueO: // global
           if (%MO_S_Ge_W64(_s4lj2::I64, 0)) goto c4ueb; else goto c4ueM;
       c4ueb: // global
           (_s4lj9::I64, _s4lja::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lja::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lj9::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ueM: // global
           if (%MO_S_Le_W64(_s4lj4::I64, 0)) goto c4uep; else goto c4ueL;
       c4uep: // global
           (_s4ljh::I64, _s4lji::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lji::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljh::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ueL: // global
           (_s4ljp::I64, _s4ljq::I64) = call MO_S_QuotRem W64(_s4lj2::I64 + 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljq::I64 + _s4lj4::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljp::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ug5: // global
           if (%MO_S_Ge_W64(_s4lj4::I64, 0)) goto c4ufI; else goto c4ug4;
       c4ufI: // global
           if (%MO_S_Ge_W64(_s4lj2::I64, 0)) goto c4uf5; else goto c4ufG;
       c4uf5: // global
           (_s4ljB::I64, _s4ljC::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljC::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljB::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ufG: // global
           if (%MO_S_Le_W64(_s4lj4::I64, 0)) goto c4ufj; else goto c4ufF;
       c4ufj: // global
           (_s4ljJ::I64, _s4ljK::I64) = call MO_S_QuotRem W64(_s4lj2::I64, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljK::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljJ::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ufF: // global
           (_s4ljR::I64, _s4ljS::I64) = call MO_S_QuotRem W64(_s4lj2::I64 + 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljS::I64 + _s4lj4::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4ljR::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4ug4: // global
           (_s4lk2::I64, _s4lk3::I64) = call MO_S_QuotRem W64(_s4lj2::I64 - 1, _s4lj4::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lk3::I64 + _s4lj4::I64 + 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4lk2::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4udR_info" {
     block_c4udR_info:
         const _c4udR;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.427065545 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdivMod_closure" {
     GHC.Int.$fIntegralInt16_$cdivMod_closure:
         const GHC.Int.$fIntegralInt16_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uhh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uhs; else goto c4uht;
       c4uhs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uht: // global
           I64[Sp - 16] = block_c4uhe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uhA; else goto c4uhf;
       u4uhA: // global
           call _c4uhe(R1) args: 0, res: 0, upd: 0;
       c4uhf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$cdivMod_info" {
     GHC.Int.$fIntegralInt16_$cdivMod_info:
         const GHC.Int.$fIntegralInt16_$cdivMod_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+792;
 },
 _c4uhe() //  [R1]
         { []
         }
     {offset
       c4uhe: // global
           I64[Sp] = block_c4uhk_info;
           _s4lkh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkh::I64;
           if (R1 & 7 != 0) goto u4uhz; else goto c4uhl;
       u4uhz: // global
           call _c4uhk(R1) args: 0, res: 0, upd: 0;
       c4uhl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uhe_info" {
     block_c4uhe_info:
         const _c4uhe;
         const 1;
         const 4294967326;
         const S4lDl_srt+792;
 },
 _c4uhk() //  [R1]
         { []
         }
     {offset
       c4uhk: // global
           _s4lkh::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4uhp_info;
           R3 = I64[R1 + 7];
           R2 = _s4lkh::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uhk_info" {
     block_c4uhk_info:
         const _c4uhk;
         const 65;
         const 4294967326;
         const S4lDl_srt+792;
 },
 _c4uhp() //  [R1, R2]
         { []
         }
     {offset
       c4uhp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4uhy; else goto c4uhx;
       c4uhy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4uhx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uhp_info" {
     block_c4uhp_info:
         const _c4uhp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.438516873 UTC

[section ""data" . GHC.Int.$fRealInt16_$ctoRational_closure" {
     GHC.Int.$fRealInt16_$ctoRational_closure:
         const GHC.Int.$fRealInt16_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt16_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c4uhZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uid; else goto c4uie;
       c4uid: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uie: // global
           I64[Sp - 8] = block_c4uhW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uil; else goto c4uhX;
       u4uil: // global
           call _c4uhW(R1) args: 0, res: 0, upd: 0;
       c4uhX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fRealInt16_$ctoRational_info" {
     GHC.Int.$fRealInt16_$ctoRational_info:
         const GHC.Int.$fRealInt16_$ctoRational_entry;
         const 0;
         const 18014428574253070;
         const 4294967301;
         const S4lDl_srt+632;
 },
 _c4uhW() //  [R1]
         { []
         }
     {offset
       c4uhW: // global
           I64[Sp] = block_c4ui2_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uhW_info" {
     block_c4uhW_info:
         const _c4uhW;
         const 0;
         const 30064771102;
         const S4lDl_srt+632;
 },
 _c4ui2() //  [R1]
         { []
         }
     {offset
       c4ui2: // global
           I64[Sp] = block_c4ui6_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ui2_info" {
     block_c4ui2_info:
         const _c4ui2;
         const 0;
         const 30064771102;
         const S4lDl_srt+632;
 },
 _c4ui6() //  [R1]
         { []
         }
     {offset
       c4ui6: // global
           I64[Sp] = block_c4uia_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ui6_info" {
     block_c4ui6_info:
         const _c4ui6;
         const 0;
         const 12884901918;
         const S4lDl_srt+640;
 },
 _c4uia() //  [R1, R2]
         { []
         }
     {offset
       c4uia: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4uik; else goto c4uij;
       c4uik: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4uij: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uia_info" {
     block_c4uia_info:
         const _c4uia;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.449198744 UTC

[section ""data" . GHC.Int.$fRealInt16_closure" {
     GHC.Int.$fRealInt16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt16_closure+1;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fRealInt16_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.451460241 UTC

[section ""data" . GHC.Int.$fIntegralInt16_closure" {
     GHC.Int.$fIntegralInt16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt16_closure+1;
         const GHC.Int.$fEnumInt16_closure+1;
         const GHC.Int.$fIntegralInt16_$cquot_closure+2;
         const GHC.Int.$fIntegralInt16_$crem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt16_$cmod_closure+2;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt16_$ctoInteger_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.455755747 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt16_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt16_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt16_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uiO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uj5; else goto c4uj6;
       c4uj5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uj6: // global
           I64[Sp - 16] = block_c4uiL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ujd; else goto c4uiM;
       u4ujd: // global
           call _c4uiL(R1) args: 0, res: 0, upd: 0;
       c4uiM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$cunsafeIndex_info" {
     GHC.Int.$fIxInt16_$cunsafeIndex_info:
         const GHC.Int.$fIxInt16_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uiL() //  [R1]
         { []
         }
     {offset
       c4uiL: // global
           I64[Sp] = block_c4uiR_info;
           _s4lky::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lky::P64;
           if (R1 & 7 != 0) goto u4ujc; else goto c4uiS;
       u4ujc: // global
           call _c4uiR(R1) args: 0, res: 0, upd: 0;
       c4uiS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uiL_info" {
     block_c4uiL_info:
         const _c4uiL;
         const 1;
         const 30;
 },
 _c4uiR() //  [R1]
         { []
         }
     {offset
       c4uiR: // global
           I64[Sp] = block_c4uiW_info;
           _s4lkB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkB::I64;
           if (R1 & 7 != 0) goto u4uje; else goto c4uiX;
       u4uje: // global
           call _c4uiW(R1) args: 0, res: 0, upd: 0;
       c4uiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uiR_info" {
     block_c4uiR_info:
         const _c4uiR;
         const 1;
         const 30;
 },
 _c4uiW() //  [R1]
         { []
         }
     {offset
       c4uiW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ujb; else goto c4uja;
       c4ujb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uja: // global
           _s4lkE::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lkE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uiW_info" {
     block_c4uiW_info:
         const _c4uiW;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.467707128 UTC

[section ""data" . GHC.Int.$fIxInt16_$crange_closure" {
     GHC.Int.$fIxInt16_$crange_closure:
         const GHC.Int.$fIxInt16_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$crange_entry() //  [R2]
         { []
         }
     {offset
       c4ujG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ujH; else goto c4ujI;
       c4ujH: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ujI: // global
           I64[Sp - 8] = block_c4ujD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ujM; else goto c4ujE;
       u4ujM: // global
           call _c4ujD(R1) args: 0, res: 0, upd: 0;
       c4ujE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$crange_info" {
     GHC.Int.$fIxInt16_$crange_info:
         const GHC.Int.$fIxInt16_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+816;
 },
 _c4ujD() //  [R1]
         { []
         }
     {offset
       c4ujD: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ujD_info" {
     block_c4ujD_info:
         const _c4ujD;
         const 0;
         const 4294967326;
         const S4lDl_srt+824;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.475393662 UTC

[section ""data" . GHC.Int.$fIxInt16_$crangeSize_closure" {
     GHC.Int.$fIxInt16_$crangeSize_closure:
         const GHC.Int.$fIxInt16_$crangeSize_info;
 },
 GHC.Int.$fIxInt16_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4uk3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ukc; else goto c4ukd;
       c4ukc: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ukd: // global
           I64[Sp - 8] = block_c4uk0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ukC; else goto c4uk1;
       u4ukC: // global
           call _c4uk0(R1) args: 0, res: 0, upd: 0;
       c4uk1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$crangeSize_info" {
     GHC.Int.$fIxInt16_$crangeSize_info:
         const GHC.Int.$fIxInt16_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4uk0() //  [R1]
         { []
         }
     {offset
       c4uk0: // global
           I64[Sp - 8] = block_c4uk6_info;
           _s4lkM::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lkM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ukB; else goto c4uk7;
       u4ukB: // global
           call _c4uk6(R1) args: 0, res: 0, upd: 0;
       c4uk7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uk0_info" {
     block_c4uk0_info:
         const _c4uk0;
         const 0;
         const 30;
 },
 _c4uk6() //  [R1]
         { []
         }
     {offset
       c4uk6: // global
           I64[Sp] = block_c4ukb_info;
           _s4lkO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkO::I64;
           if (R1 & 7 != 0) goto u4ukD; else goto c4ukg;
       u4ukD: // global
           call _c4ukb(R1) args: 0, res: 0, upd: 0;
       c4ukg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uk6_info" {
     block_c4uk6_info:
         const _c4uk6;
         const 1;
         const 30;
 },
 _c4ukb() //  [R1]
         { []
         }
     {offset
       c4ukb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ukm; else goto c4ukl;
       c4ukm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ukl: // global
           _s4lkO::I64 = I64[Sp + 8];
           _s4lkQ::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lkO::I64,
                            _s4lkQ::I64)) goto c4ukq; else goto c4ukA;
       c4ukq: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ukA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lkQ::I64 - _s4lkO::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ukb_info" {
     block_c4ukb_info:
         const _c4ukb;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.487073039 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt16_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt16_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4ul7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ulr; else goto c4uls;
       c4ulr: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uls: // global
           I64[Sp - 8] = block_c4ul4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ulz; else goto c4ul5;
       u4ulz: // global
           call _c4ul4(R1) args: 0, res: 0, upd: 0;
       c4ul5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$cunsafeRangeSize_info" {
     GHC.Int.$fIxInt16_$cunsafeRangeSize_info:
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4ul4() //  [R1]
         { []
         }
     {offset
       c4ul4: // global
           I64[Sp - 8] = block_c4ula_info;
           _s4lkW::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lkW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uly; else goto c4ulb;
       u4uly: // global
           call _c4ula(R1) args: 0, res: 0, upd: 0;
       c4ulb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ul4_info" {
     block_c4ul4_info:
         const _c4ul4;
         const 0;
         const 30;
 },
 _c4ula() //  [R1]
         { []
         }
     {offset
       c4ula: // global
           I64[Sp] = block_c4ulf_info;
           _s4lkZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lkZ::I64;
           if (R1 & 7 != 0) goto u4ulA; else goto c4ulg;
       u4ulA: // global
           call _c4ulf(R1) args: 0, res: 0, upd: 0;
       c4ulg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ula_info" {
     block_c4ula_info:
         const _c4ula;
         const 1;
         const 30;
 },
 _c4ulf() //  [R1]
         { []
         }
     {offset
       c4ulf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ulx; else goto c4ulw;
       c4ulx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ulw: // global
           _s4ll3::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4ll3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ulf_info" {
     block_c4ulf_info:
         const _c4ulf;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.501832884 UTC

[section ""data" . GHC.Int.$fIxInt16_$cindex_closure" {
     GHC.Int.$fIxInt16_$cindex_closure:
         const GHC.Int.$fIxInt16_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4um3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4umc; else goto c4umd;
       c4umc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4umd: // global
           I64[Sp - 16] = block_c4um0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4umM; else goto c4um1;
       u4umM: // global
           call _c4um0(R1) args: 0, res: 0, upd: 0;
       c4um1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$cindex_info" {
     GHC.Int.$fIxInt16_$cindex_info:
         const GHC.Int.$fIxInt16_$cindex_entry;
         const 0;
         const 2251804108652558;
         const 8589934607;
         const S4lDl_srt+680;
 },
 _c4um0() //  [R1]
         { []
         }
     {offset
       c4um0: // global
           I64[Sp - 8] = block_c4um6_info;
           _s4ll8::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4ll8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4umL; else goto c4um7;
       u4umL: // global
           call _c4um6(R1) args: 0, res: 0, upd: 0;
       c4um7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4um0_info" {
     block_c4um0_info:
         const _c4um0;
         const 1;
         const 4294967326;
         const S4lDl_srt+680;
 },
 _c4um6() //  [R1]
         { []
         }
     {offset
       c4um6: // global
           I64[Sp] = block_c4umb_info;
           _s4lla::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lla::I64;
           if (R1 & 7 != 0) goto u4umN; else goto c4umg;
       u4umN: // global
           call _c4umb(R1) args: 0, res: 0, upd: 0;
       c4umg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4um6_info" {
     block_c4um6_info:
         const _c4um6;
         const 2;
         const 4294967326;
         const S4lDl_srt+680;
 },
 _c4umb() //  [R1]
         { []
         }
     {offset
       c4umb: // global
           _s4llc::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4llc::I64)) goto c4umo; else goto c4ums;
       c4umo: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ums: // global
           I64[Sp] = block_c4umr_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llc::I64;
           if (R1 & 7 != 0) goto u4umO; else goto c4umt;
       u4umO: // global
           call _c4umr(R1) args: 0, res: 0, upd: 0;
       c4umt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4umb_info" {
     block_c4umb_info:
         const _c4umb;
         const 130;
         const 4294967326;
         const S4lDl_srt+680;
 },
 _c4umr() //  [R1]
         { []
         }
     {offset
       c4umr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4umz; else goto c4umy;
       c4umz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4umy: // global
           _s4llc::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4llc::I64,
                            I64[R1 + 7])) goto c4umD; else goto c4umK;
       c4umD: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4umK: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4llc::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4umr_info" {
     block_c4umr_info:
         const _c4umr;
         const 194;
         const 4294967326;
         const S4lDl_srt+680;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.51981101 UTC

[section ""data" . GHC.Int.$fIxInt16_closure" {
     GHC.Int.$fIxInt16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fIxInt16_$crange_closure+1;
         const GHC.Int.$fIxInt16_$cindex_closure+2;
         const GHC.Int.$fIxInt16_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt16_$cinRange_closure+2;
         const GHC.Int.$fIxInt16_$crangeSize_closure+1;
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.524680483 UTC

[section ""data" . GHC.Int.eqInt32_closure" {
     GHC.Int.eqInt32_closure:
         const GHC.Int.eqInt32_info;
 },
 GHC.Int.eqInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4unn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4unr; else goto c4uns;
       c4unr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uns: // global
           I64[Sp - 16] = block_c4unk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4unB; else goto c4unl;
       u4unB: // global
           call _c4unk(R1) args: 0, res: 0, upd: 0;
       c4unl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.eqInt32_info" {
     GHC.Int.eqInt32_info:
         const GHC.Int.eqInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4unk() //  [R1]
         { []
         }
     {offset
       c4unk: // global
           I64[Sp] = block_c4unq_info;
           _s4lll::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lll::I64;
           if (R1 & 7 != 0) goto u4unA; else goto c4unu;
       u4unA: // global
           call _c4unq(R1) args: 0, res: 0, upd: 0;
       c4unu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4unk_info" {
     block_c4unk_info:
         const _c4unk;
         const 1;
         const 30;
 },
 _c4unq() //  [R1]
         { []
         }
     {offset
       c4unq: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4unq_info" {
     block_c4unq_info:
         const _c4unq;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.535638671 UTC

[section ""data" . GHC.Int.$fEqInt32_closure" {
     GHC.Int.$fEqInt32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt32_closure+2;
         const GHC.Int.neInt32_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.539681978 UTC

[section ""data" . GHC.Int.gtInt32_closure" {
     GHC.Int.gtInt32_closure:
         const GHC.Int.gtInt32_info;
 },
 GHC.Int.gtInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uo1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uo5; else goto c4uo6;
       c4uo5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uo6: // global
           I64[Sp - 16] = block_c4unY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uof; else goto c4unZ;
       u4uof: // global
           call _c4unY(R1) args: 0, res: 0, upd: 0;
       c4unZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.gtInt32_info" {
     GHC.Int.gtInt32_info:
         const GHC.Int.gtInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4unY() //  [R1]
         { []
         }
     {offset
       c4unY: // global
           I64[Sp] = block_c4uo4_info;
           _s4lls::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lls::I64;
           if (R1 & 7 != 0) goto u4uoe; else goto c4uo8;
       u4uoe: // global
           call _c4uo4(R1) args: 0, res: 0, upd: 0;
       c4uo8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4unY_info" {
     block_c4unY_info:
         const _c4unY;
         const 1;
         const 30;
 },
 _c4uo4() //  [R1]
         { []
         }
     {offset
       c4uo4: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uo4_info" {
     block_c4uo4_info:
         const _c4uo4;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.549950387 UTC

[section ""data" . GHC.Int.geInt32_closure" {
     GHC.Int.geInt32_closure:
         const GHC.Int.geInt32_info;
 },
 GHC.Int.geInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uoE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uoI; else goto c4uoJ;
       c4uoI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uoJ: // global
           I64[Sp - 16] = block_c4uoB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uoS; else goto c4uoC;
       u4uoS: // global
           call _c4uoB(R1) args: 0, res: 0, upd: 0;
       c4uoC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.geInt32_info" {
     GHC.Int.geInt32_info:
         const GHC.Int.geInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uoB() //  [R1]
         { []
         }
     {offset
       c4uoB: // global
           I64[Sp] = block_c4uoH_info;
           _s4llz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llz::I64;
           if (R1 & 7 != 0) goto u4uoR; else goto c4uoL;
       u4uoR: // global
           call _c4uoH(R1) args: 0, res: 0, upd: 0;
       c4uoL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uoB_info" {
     block_c4uoB_info:
         const _c4uoB;
         const 1;
         const 30;
 },
 _c4uoH() //  [R1]
         { []
         }
     {offset
       c4uoH: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uoH_info" {
     block_c4uoH_info:
         const _c4uoH;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.5611321 UTC

[section ""data" . GHC.Int.ltInt32_closure" {
     GHC.Int.ltInt32_closure:
         const GHC.Int.ltInt32_info;
 },
 GHC.Int.ltInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uph: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4upl; else goto c4upm;
       c4upl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4upm: // global
           I64[Sp - 16] = block_c4upe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4upv; else goto c4upf;
       u4upv: // global
           call _c4upe(R1) args: 0, res: 0, upd: 0;
       c4upf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.ltInt32_info" {
     GHC.Int.ltInt32_info:
         const GHC.Int.ltInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4upe() //  [R1]
         { []
         }
     {offset
       c4upe: // global
           I64[Sp] = block_c4upk_info;
           _s4llG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llG::I64;
           if (R1 & 7 != 0) goto u4upu; else goto c4upo;
       u4upu: // global
           call _c4upk(R1) args: 0, res: 0, upd: 0;
       c4upo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4upe_info" {
     block_c4upe_info:
         const _c4upe;
         const 1;
         const 30;
 },
 _c4upk() //  [R1]
         { []
         }
     {offset
       c4upk: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4upk_info" {
     block_c4upk_info:
         const _c4upk;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.572273883 UTC

[section ""data" . GHC.Int.leInt32_closure" {
     GHC.Int.leInt32_closure:
         const GHC.Int.leInt32_info;
 },
 GHC.Int.leInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4upU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4upY; else goto c4upZ;
       c4upY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4upZ: // global
           I64[Sp - 16] = block_c4upR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uq8; else goto c4upS;
       u4uq8: // global
           call _c4upR(R1) args: 0, res: 0, upd: 0;
       c4upS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.leInt32_info" {
     GHC.Int.leInt32_info:
         const GHC.Int.leInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4upR() //  [R1]
         { []
         }
     {offset
       c4upR: // global
           I64[Sp] = block_c4upX_info;
           _s4llN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llN::I64;
           if (R1 & 7 != 0) goto u4uq7; else goto c4uq1;
       u4uq7: // global
           call _c4upX(R1) args: 0, res: 0, upd: 0;
       c4uq1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4upR_info" {
     block_c4upR_info:
         const _c4upR;
         const 1;
         const 30;
 },
 _c4upX() //  [R1]
         { []
         }
     {offset
       c4upX: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4upX_info" {
     block_c4upX_info:
         const _c4upX;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.583815289 UTC

[section ""data" . GHC.Int.$fOrdInt32_$ccompare_closure" {
     GHC.Int.$fOrdInt32_$ccompare_closure:
         const GHC.Int.$fOrdInt32_$ccompare_info;
 },
 GHC.Int.$fOrdInt32_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uqx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uqB; else goto c4uqC;
       c4uqB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uqC: // global
           I64[Sp - 16] = block_c4uqu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uqV; else goto c4uqv;
       u4uqV: // global
           call _c4uqu(R1) args: 0, res: 0, upd: 0;
       c4uqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt32_$ccompare_info" {
     GHC.Int.$fOrdInt32_$ccompare_info:
         const GHC.Int.$fOrdInt32_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uqu() //  [R1]
         { []
         }
     {offset
       c4uqu: // global
           I64[Sp] = block_c4uqA_info;
           _s4llU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4llU::I64;
           if (R1 & 7 != 0) goto u4uqU; else goto c4uqE;
       u4uqU: // global
           call _c4uqA(R1) args: 0, res: 0, upd: 0;
       c4uqE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uqu_info" {
     block_c4uqu_info:
         const _c4uqu;
         const 1;
         const 30;
 },
 _c4uqA() //  [R1]
         { []
         }
     {offset
       c4uqA: // global
           _s4llU::I64 = I64[Sp + 8];
           _s4llW::I64 = I64[R1 + 7];
           if (_s4llU::I64 == _s4llW::I64) goto c4uqT; else goto c4uqS;
       c4uqT: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uqS: // global
           if (%MO_S_Gt_W64(_s4llU::I64,
                            _s4llW::I64)) goto c4uqP; else goto c4uqQ;
       c4uqP: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uqQ: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uqA_info" {
     block_c4uqA_info:
         const _c4uqA;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.593214945 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmax_closure" {
     GHC.Int.$fOrdInt32_$cmax_closure:
         const GHC.Int.$fOrdInt32_$cmax_info;
 },
 GHC.Int.$fOrdInt32_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c4urj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4urn; else goto c4uro;
       c4urn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uro: // global
           I64[Sp - 16] = block_c4urg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4urB; else goto c4urh;
       u4urB: // global
           call _c4urg(R1) args: 0, res: 0, upd: 0;
       c4urh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt32_$cmax_info" {
     GHC.Int.$fOrdInt32_$cmax_info:
         const GHC.Int.$fOrdInt32_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4urg() //  [R1]
         { []
         }
     {offset
       c4urg: // global
           I64[Sp - 8] = block_c4urm_info;
           _s4lm1::P64 = R1;
           _s4lm2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lm2::I64;
           P64[Sp + 8] = _s4lm1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4urA; else goto c4urq;
       u4urA: // global
           call _c4urm(R1) args: 0, res: 0, upd: 0;
       c4urq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4urg_info" {
     block_c4urg_info:
         const _c4urg;
         const 1;
         const 30;
 },
 _c4urm() //  [R1]
         { []
         }
     {offset
       c4urm: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4ury; else goto c4urz;
       c4ury: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4urz: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4urm_info" {
     block_c4urm_info:
         const _c4urm;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.602022238 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmin_closure" {
     GHC.Int.$fOrdInt32_$cmin_closure:
         const GHC.Int.$fOrdInt32_$cmin_info;
 },
 GHC.Int.$fOrdInt32_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c4us1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4us5; else goto c4us6;
       c4us5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4us6: // global
           I64[Sp - 16] = block_c4urY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4usj; else goto c4urZ;
       u4usj: // global
           call _c4urY(R1) args: 0, res: 0, upd: 0;
       c4urZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt32_$cmin_info" {
     GHC.Int.$fOrdInt32_$cmin_info:
         const GHC.Int.$fOrdInt32_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4urY() //  [R1]
         { []
         }
     {offset
       c4urY: // global
           I64[Sp - 8] = block_c4us4_info;
           _s4lm8::P64 = R1;
           _s4lm9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lm9::I64;
           P64[Sp + 8] = _s4lm8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4usi; else goto c4us8;
       u4usi: // global
           call _c4us4(R1) args: 0, res: 0, upd: 0;
       c4us8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4urY_info" {
     block_c4urY_info:
         const _c4urY;
         const 1;
         const 30;
 },
 _c4us4() //  [R1]
         { []
         }
     {offset
       c4us4: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4usg; else goto c4ush;
       c4usg: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ush: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4us4_info" {
     block_c4us4_info:
         const _c4us4;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.609755477 UTC

[section ""data" . GHC.Int.$fOrdInt32_closure" {
     GHC.Int.$fOrdInt32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fOrdInt32_$ccompare_closure+2;
         const GHC.Int.ltInt32_closure+2;
         const GHC.Int.leInt32_closure+2;
         const GHC.Int.gtInt32_closure+2;
         const GHC.Int.geInt32_closure+2;
         const GHC.Int.$fOrdInt32_$cmax_closure+2;
         const GHC.Int.$fOrdInt32_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.613888879 UTC

[section ""data" . GHC.Int.$fIxInt32_$cinRange_closure" {
     GHC.Int.$fIxInt32_$cinRange_closure:
         const GHC.Int.$fIxInt32_$cinRange_info;
 },
 GHC.Int.$fIxInt32_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c4usK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4usT; else goto c4usU;
       c4usT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4usU: // global
           I64[Sp - 16] = block_c4usH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uth; else goto c4usI;
       u4uth: // global
           call _c4usH(R1) args: 0, res: 0, upd: 0;
       c4usI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$cinRange_info" {
     GHC.Int.$fIxInt32_$cinRange_info:
         const GHC.Int.$fIxInt32_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4usH() //  [R1]
         { []
         }
     {offset
       c4usH: // global
           I64[Sp - 8] = block_c4usN_info;
           _s4lmh::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lmh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4utg; else goto c4usO;
       u4utg: // global
           call _c4usN(R1) args: 0, res: 0, upd: 0;
       c4usO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4usH_info" {
     block_c4usH_info:
         const _c4usH;
         const 1;
         const 30;
 },
 _c4usN() //  [R1]
         { []
         }
     {offset
       c4usN: // global
           I64[Sp] = block_c4usS_info;
           _s4lmj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lmj::I64;
           if (R1 & 7 != 0) goto u4uti; else goto c4usX;
       u4uti: // global
           call _c4usS(R1) args: 0, res: 0, upd: 0;
       c4usX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4usN_info" {
     block_c4usN_info:
         const _c4usN;
         const 2;
         const 30;
 },
 _c4usS() //  [R1]
         { []
         }
     {offset
       c4usS: // global
           _s4lml::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lml::I64)) goto c4ut5; else goto c4ut9;
       c4ut5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ut9: // global
           _s4lmh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4ut8_info;
           R1 = _s4lmh::P64;
           I64[Sp + 16] = _s4lml::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4utj; else goto c4uta;
       u4utj: // global
           call _c4ut8(R1) args: 0, res: 0, upd: 0;
       c4uta: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4usS_info" {
     block_c4usS_info:
         const _c4usS;
         const 130;
         const 30;
 },
 _c4ut8() //  [R1]
         { []
         }
     {offset
       c4ut8: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ut8_info" {
     block_c4ut8_info:
         const _c4ut8;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.624991766 UTC

[section ""data" . GHC.Int.$fNumInt3_closure" {
     GHC.Int.$fNumInt3_closure:
         const GHC.Int.I32#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.62826483 UTC

[section ""data" . GHC.Int.$fNumInt32_$csignum_closure" {
     GHC.Int.$fNumInt32_$csignum_closure:
         const GHC.Int.$fNumInt32_$csignum_info;
 },
 GHC.Int.$fNumInt32_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c4utS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4utT; else goto c4utU;
       c4utT: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4utU: // global
           I64[Sp - 8] = block_c4utP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uu8; else goto c4utQ;
       u4uu8: // global
           call _c4utP(R1) args: 0, res: 0, upd: 0;
       c4utQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$csignum_info" {
     GHC.Int.$fNumInt32_$csignum_info:
         const GHC.Int.$fNumInt32_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4utP() //  [R1]
         { []
         }
     {offset
       c4utP: // global
           _s4lms::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lms::I64, 0)) goto c4uu6; else goto c4uu7;
       c4uu6: // global
           if (_s4lms::I64 == 0) goto c4uu4; else goto c4uu3;
       c4uu4: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uu3: // global
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uu7: // global
           R1 = GHC.Int.$fNumInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4utP_info" {
     block_c4utP_info:
         const _c4utP;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.634890527 UTC

[section ""data" . GHC.Int.$fNumInt32_$cabs_closure" {
     GHC.Int.$fNumInt32_$cabs_closure:
         const GHC.Int.$fNumInt32_$cabs_info;
 },
 GHC.Int.$fNumInt32_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c4uus: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uut; else goto c4uuu;
       c4uut: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uuu: // global
           I64[Sp - 8] = block_c4uup_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uuN; else goto c4uuq;
       u4uuN: // global
           call _c4uup(R1) args: 0, res: 0, upd: 0;
       c4uuq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$cabs_info" {
     GHC.Int.$fNumInt32_$cabs_info:
         const GHC.Int.$fNumInt32_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4uup() //  [R1]
         { []
         }
     {offset
       c4uup: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uuz; else goto c4uuy;
       c4uuz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uuy: // global
           _s4lmx::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lmx::I64, 0)) goto c4uuL; else goto c4uuM;
       c4uuL: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-_s4lmx::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uuM: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uup_info" {
     block_c4uup_info:
         const _c4uup;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.641814122 UTC

[section ""data" . GHC.Int.$fNumInt32_closure" {
     GHC.Int.$fNumInt32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt32_$c+_closure+2;
         const GHC.Int.$fNumInt32_$c-_closure+2;
         const GHC.Int.$fNumInt32_$c*_closure+2;
         const GHC.Int.$fNumInt32_$cnegate_closure+1;
         const GHC.Int.$fNumInt32_$cabs_closure+1;
         const GHC.Int.$fNumInt32_$csignum_closure+1;
         const GHC.Int.$fNumInt32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.643622097 UTC

[section ""data" . GHC.Int.$fBitsInt5_closure" {
     GHC.Int.$fBitsInt5_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt4_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.646241163 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt32_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c4uv8: // global
           R1 = GHC.Int.$fBitsInt5_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cbitSizeMaybe_info" {
     GHC.Int.$fBitsInt32_$cbitSizeMaybe_info:
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.650697662 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbit_closure" {
     GHC.Int.$fBitsInt32_$cbit_closure:
         const GHC.Int.$fBitsInt32_$cbit_info;
 },
 GHC.Int.$fBitsInt32_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c4uvn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uvo; else goto c4uvp;
       c4uvo: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uvp: // global
           I64[Sp - 8] = block_c4uvk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uvI; else goto c4uvl;
       u4uvI: // global
           call _c4uvk(R1) args: 0, res: 0, upd: 0;
       c4uvl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cbit_info" {
     GHC.Int.$fBitsInt32_$cbit_info:
         const GHC.Int.$fBitsInt32_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4uvk() //  [R1]
         { []
         }
     {offset
       c4uvk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uvu; else goto c4uvt;
       c4uvu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uvt: // global
           _s4lmE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lmE::I64, 64)) goto c4uvG; else goto c4uvH;
       c4uvG: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lmE::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uvH: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uvk_info" {
     block_c4uvk_info:
         const _c4uvk;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.657860981 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ctestBit_closure" {
     GHC.Int.$fBitsInt32_$ctestBit_closure:
         const GHC.Int.$fBitsInt32_$ctestBit_info;
 },
 GHC.Int.$fBitsInt32_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uw3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uw7; else goto c4uw8;
       c4uw7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uw8: // global
           I64[Sp - 16] = block_c4uw0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uwQ; else goto c4uw1;
       u4uwQ: // global
           call _c4uw0(R1) args: 0, res: 0, upd: 0;
       c4uw1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$ctestBit_info" {
     GHC.Int.$fBitsInt32_$ctestBit_info:
         const GHC.Int.$fBitsInt32_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uw0() //  [R1]
         { []
         }
     {offset
       c4uw0: // global
           I64[Sp] = block_c4uw6_info;
           _s4lmL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lmL::I64;
           if (R1 & 7 != 0) goto u4uwP; else goto c4uwa;
       u4uwP: // global
           call _c4uw6(R1) args: 0, res: 0, upd: 0;
       c4uwa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uw0_info" {
     block_c4uw0_info:
         const _c4uw0;
         const 1;
         const 30;
 },
 _c4uw6() //  [R1]
         { []
         }
     {offset
       c4uw6: // global
           _s4lmN::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4lmN::I64, 64)) goto c4uwO; else goto c4uwN;
       c4uwN: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lmN::I64)) == 0) goto c4uwO; else goto c4uwC;
       c4uwO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uwC: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uw6_info" {
     block_c4uw6_info:
         const _c4uw6;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.667954594 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateR_closure" {
     GHC.Int.$fBitsInt32_$crotateR_closure:
         const GHC.Int.$fBitsInt32_$crotateR_info;
 },
 GHC.Int.$fBitsInt32_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uxh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uxl; else goto c4uxm;
       c4uxl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uxm: // global
           I64[Sp - 16] = block_c4uxe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uyl; else goto c4uxf;
       u4uyl: // global
           call _c4uxe(R1) args: 0, res: 0, upd: 0;
       c4uxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$crotateR_info" {
     GHC.Int.$fBitsInt32_$crotateR_info:
         const GHC.Int.$fBitsInt32_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uxe() //  [R1]
         { []
         }
     {offset
       c4uxe: // global
           I64[Sp - 8] = block_c4uxk_info;
           _s4lmX::P64 = R1;
           _s4lmY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lmY::I64;
           P64[Sp + 8] = _s4lmX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uyk; else goto c4uxo;
       u4uyk: // global
           call _c4uxk(R1) args: 0, res: 0, upd: 0;
       c4uxo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uxe_info" {
     block_c4uxe_info:
         const _c4uxe;
         const 1;
         const 30;
 },
 _c4uxk() //  [R1]
         { []
         }
     {offset
       c4uxk: // global
           _s4ln4::I64 = -I64[R1 + 7] & 31;
           if (_s4ln4::I64 != 0) goto u4uyi; else goto c4uye;
       u4uyi: // global
           I64[Sp + 16] = _s4ln4::I64;
           Sp = Sp + 8;
           call _c4uxG() args: 0, res: 0, upd: 0;
       c4uye: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uxk_info" {
     block_c4uxk_info:
         const _c4uxk;
         const 66;
         const 30;
 },
 _c4uxG() //  []
         { []
         }
     {offset
       c4uxG: // global
           Hp = Hp + 16;
           _s4ln4::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4uyb; else goto c4uya;
       c4uyb: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4uxF_info;
           R1 = _s4ln4::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4uya: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4ln5::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4ln5::I64 << _s4ln4::I64) | (_s4ln5::I64 >> 32 - _s4ln4::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4uxF() //  [R1]
         { []
         }
     {offset
       c4uxF: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4uxG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4uxF_info" {
     block_c4uxF_info:
         const _c4uxF;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.680343815 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt32_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt32_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt32_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uyY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uz2; else goto c4uz3;
       c4uz2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uz3: // global
           I64[Sp - 16] = block_c4uyV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uzC; else goto c4uyW;
       u4uzC: // global
           call _c4uyV(R1) args: 0, res: 0, upd: 0;
       c4uyW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$ccomplementBit_info" {
     GHC.Int.$fBitsInt32_$ccomplementBit_info:
         const GHC.Int.$fBitsInt32_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uyV() //  [R1]
         { []
         }
     {offset
       c4uyV: // global
           I64[Sp - 8] = block_c4uz1_info;
           _s4lnf::P64 = R1;
           _s4lng::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lng::I64;
           P64[Sp + 8] = _s4lnf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uzB; else goto c4uz5;
       u4uzB: // global
           call _c4uz1(R1) args: 0, res: 0, upd: 0;
       c4uz5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uyV_info" {
     block_c4uyV_info:
         const _c4uyV;
         const 1;
         const 30;
 },
 _c4uz1() //  [R1]
         { []
         }
     {offset
       c4uz1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uzb; else goto c4uza;
       c4uzb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uza: // global
           _s4lni::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lni::I64, 64)) goto c4uzz; else goto c4uzA;
       c4uzz: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lni::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uzA: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uz1_info" {
     block_c4uz1_info:
         const _c4uz1;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.689427904 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cclearBit_closure" {
     GHC.Int.$fBitsInt32_$cclearBit_closure:
         const GHC.Int.$fBitsInt32_$cclearBit_info;
 },
 GHC.Int.$fBitsInt32_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uA4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uA8; else goto c4uA9;
       c4uA8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uA9: // global
           I64[Sp - 16] = block_c4uA1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uAW; else goto c4uA2;
       u4uAW: // global
           call _c4uA1(R1) args: 0, res: 0, upd: 0;
       c4uA2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cclearBit_info" {
     GHC.Int.$fBitsInt32_$cclearBit_info:
         const GHC.Int.$fBitsInt32_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uA1() //  [R1]
         { []
         }
     {offset
       c4uA1: // global
           I64[Sp] = block_c4uA7_info;
           _s4lnt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lnt::I64;
           if (R1 & 7 != 0) goto u4uAV; else goto c4uAb;
       u4uAV: // global
           call _c4uA7(R1) args: 0, res: 0, upd: 0;
       c4uAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uA1_info" {
     block_c4uA1_info:
         const _c4uA1;
         const 1;
         const 30;
 },
 _c4uA7() //  [R1]
         { []
         }
     {offset
       c4uA7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uAh; else goto c4uAg;
       c4uAh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uAg: // global
           _s4lnt::I64 = I64[Sp + 8];
           _s4lnv::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lnv::I64, 64)) goto c4uAI; else goto c4uAU;
       c4uAI: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lnt::I64 & ~%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lnv::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uAU: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lnt::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uA7_info" {
     block_c4uA7_info:
         const _c4uA7;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.69842957 UTC

[section ""data" . GHC.Int.$fBitsInt32_$csetBit_closure" {
     GHC.Int.$fBitsInt32_$csetBit_closure:
         const GHC.Int.$fBitsInt32_$csetBit_info;
 },
 GHC.Int.$fBitsInt32_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uBp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uBt; else goto c4uBu;
       c4uBt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uBu: // global
           I64[Sp - 16] = block_c4uBm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uC3; else goto c4uBn;
       u4uC3: // global
           call _c4uBm(R1) args: 0, res: 0, upd: 0;
       c4uBn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$csetBit_info" {
     GHC.Int.$fBitsInt32_$csetBit_info:
         const GHC.Int.$fBitsInt32_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uBm() //  [R1]
         { []
         }
     {offset
       c4uBm: // global
           I64[Sp - 8] = block_c4uBs_info;
           _s4lnJ::P64 = R1;
           _s4lnK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lnK::I64;
           P64[Sp + 8] = _s4lnJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uC2; else goto c4uBw;
       u4uC2: // global
           call _c4uBs(R1) args: 0, res: 0, upd: 0;
       c4uBw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uBm_info" {
     block_c4uBm_info:
         const _c4uBm;
         const 1;
         const 30;
 },
 _c4uBs() //  [R1]
         { []
         }
     {offset
       c4uBs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uBC; else goto c4uBB;
       c4uBC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uBB: // global
           _s4lnM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lnM::I64, 64)) goto c4uC0; else goto c4uC1;
       c4uC0: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4lnM::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uC1: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uBs_info" {
     block_c4uBs_info:
         const _c4uBs;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.707841045 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateL_closure" {
     GHC.Int.$fBitsInt32_$crotateL_closure:
         const GHC.Int.$fBitsInt32_$crotateL_info;
 },
 GHC.Int.$fBitsInt32_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uCs: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt32_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$crotateL_info" {
     GHC.Int.$fBitsInt32_$crotateL_info:
         const GHC.Int.$fBitsInt32_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.712988307 UTC

[section ""data" . GHC.Int.$fBitsInt32_closure" {
     GHC.Int.$fBitsInt32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fBitsInt32_$c.&._closure+2;
         const GHC.Int.$fBitsInt32_$c.|._closure+2;
         const GHC.Int.$fBitsInt32_$cxor_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt32_$cshift_closure+2;
         const GHC.Int.$fBitsInt32_$crotate_closure+2;
         const GHC.Int.$fBitsInt6_closure+1;
         const GHC.Int.$fBitsInt32_$cbit_closure+1;
         const GHC.Int.$fBitsInt32_$csetBit_closure+2;
         const GHC.Int.$fBitsInt32_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt32_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt32_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt32_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt32_$crotateL_closure+2;
         const GHC.Int.$fBitsInt32_$crotateR_closure+2;
         const GHC.Int.$fBitsInt32_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.71569803 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_closure" {
     GHC.Int.$fFiniteBitsInt32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt32_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.722319811 UTC

[section ""data" . GHC.Int.$fReadInt32_go_closure" {
     GHC.Int.$fReadInt32_go_closure:
         const GHC.Int.$fReadInt32_go_info;
 },
 sat_s4lo6_entry() //  [R1]
         { []
         }
     {offset
       c4uCU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uCV; else goto c4uCW;
       c4uCV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4uCW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4lo6_info" {
     sat_s4lo6_info:
         const sat_s4lo6_entry;
         const 1;
         const 16;
 },
 sat_s4lo4_entry() //  [R1]
         { []
         }
     {offset
       c4uD4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uDb; else goto c4uDc;
       c4uDb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4uDc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4uD1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4uDg; else goto c4uD2;
       u4uDg: // global
           call _c4uD1(R1) args: 0, res: 0, upd: 0;
       c4uD2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4lo4_info" {
     sat_s4lo4_info:
         const sat_s4lo4_entry;
         const 1;
         const 16;
 },
 _c4uD1() //  [R1]
         { []
         }
     {offset
       c4uD1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uDf; else goto c4uDe;
       c4uDf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4uDe: // global
           _s4lo3::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4lo3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4uD1_info" {
     block_c4uD1_info:
         const _c4uD1;
         const 0;
         const 30;
 },
 GHC.Int.$fReadInt32_go_entry() //  [R2]
         { []
         }
     {offset
       c4uDl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uDm; else goto c4uDn;
       c4uDm: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uDn: // global
           I64[Sp - 8] = block_c4uCF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uDx; else goto c4uCG;
       u4uDx: // global
           call _c4uCF(R1) args: 0, res: 0, upd: 0;
       c4uCG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt32_go_info" {
     GHC.Int.$fReadInt32_go_info:
         const GHC.Int.$fReadInt32_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4uCF() //  [R1]
         { []
         }
     {offset
       c4uCF: // global
           if (R1 & 7 == 1) goto c4uDi; else goto c4uDj;
       c4uDi: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uDj: // global
           I64[Sp - 8] = block_c4uCL_info;
           _s4lnX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lnX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uDw; else goto c4uCM;
       u4uDw: // global
           call _c4uCL(R1) args: 0, res: 0, upd: 0;
       c4uCM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uCF_info" {
     block_c4uCF_info:
         const _c4uCF;
         const 0;
         const 30;
 },
 _c4uCL() //  [R1]
         { []
         }
     {offset
       c4uCL: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4uDv; else goto c4uDu;
       c4uDv: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uDu: // global
           _s4lnZ::P64 = P64[R1 + 7];
           _s4lo0::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4lo6_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lo4_info;
           P64[Hp - 48] = _s4lnZ::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4lo0::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uCL_info" {
     block_c4uCL_info:
         const _c4uCL;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.736075135 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadsPrec_closure" {
     GHC.Int.$fReadInt32_$creadsPrec_closure:
         const GHC.Int.$fReadInt32_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uEd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uEh; else goto c4uEi;
       c4uEh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uEi: // global
           I64[Sp - 16] = block_c4uEb_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4lo8::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4lo8::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt32_$creadsPrec_info" {
     GHC.Int.$fReadInt32_$creadsPrec_info:
         const GHC.Int.$fReadInt32_$creadsPrec_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const S4lDl_srt+840;
 },
 _c4uEb() //  [R1]
         { []
         }
     {offset
       c4uEb: // global
           _s4lo8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4uEg_info;
           R3 = _s4lo8::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uEb_info" {
     block_c4uEb_info:
         const _c4uEb;
         const 1;
         const 30;
 },
 _c4uEg() //  [R1]
         { []
         }
     {offset
       c4uEg: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uEg_info" {
     block_c4uEg_info:
         const _c4uEg;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.744612577 UTC

[section ""data" . GHC.Int.$fReadInt6_closure" {
     GHC.Int.$fReadInt6_closure:
         const GHC.Int.$fReadInt6_info;
         const 0;
 },
 sat_s4lod_entry() //  [R1, R2]
         { []
         }
     {offset
       c4uEI: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt32_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s4lod_info" {
     sat_s4lod_info:
         const sat_s4lod_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S4lDl_srt+840;
 },
 GHC.Int.$fReadInt6_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uEO: // global
           _s4loc::P64 = R3;
           _s4lob::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4uEP; else goto c4uEQ;
       c4uEQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uES; else goto c4uER;
       c4uES: // global
           HpAlloc = 16;
           goto c4uEP;
       c4uEP: // global
           R3 = _s4loc::P64;
           R2 = _s4lob::P64;
           R1 = GHC.Int.$fReadInt6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uER: // global
           I64[Hp - 8] = sat_s4lod_info;
           P64[Hp] = _s4lob::P64;
           I64[Sp - 8] = block_c4uEL_info;
           R3 = _s4loc::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt6_info" {
     GHC.Int.$fReadInt6_info:
         const GHC.Int.$fReadInt6_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const S4lDl_srt+840;
 },
 _c4uEL() //  [R1]
         { []
         }
     {offset
       c4uEL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uEV; else goto c4uEU;
       c4uEV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uEU: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uEL_info" {
     block_c4uEL_info:
         const _c4uEL;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.753853243 UTC

[section ""data" . GHC.Int.$fReadInt5_closure" {
     GHC.Int.$fReadInt5_closure:
         const GHC.Int.$fReadInt5_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4uFh_srtd" {
     u4uFh_srtd:
         const S4lDl_srt+504;
         const 46;
         const 35184372088833;
 },
 GHC.Int.$fReadInt5_entry() //  [R1]
         { []
         }
     {offset
       c4uFe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4uFf; else goto c4uFg;
       c4uFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4uFg: // global
           (_c4uFb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4uFb::I64 == 0) goto c4uFd; else goto c4uFc;
       c4uFd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4uFc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4uFb::I64;
           R2 = GHC.Int.$fReadInt6_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt5_info" {
     GHC.Int.$fReadInt5_info:
         const GHC.Int.$fReadInt5_entry;
         const 0;
         const 18446744069414584341;
         const u4uFh_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.759499077 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadList_closure" {
     GHC.Int.$fReadInt32_$creadList_closure:
         const GHC.Int.$fReadInt32_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadList_entry() //  [R2]
         { []
         }
     {offset
       c4uFu: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt5_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt32_$creadList_info" {
     GHC.Int.$fReadInt32_$creadList_info:
         const GHC.Int.$fReadInt32_$creadList_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S4lDl_srt+872;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.76761987 UTC

[section ""data" . GHC.Int.$fReadInt4_closure" {
     GHC.Int.$fReadInt4_closure:
         const GHC.Int.$fReadInt4_info;
         const 0;
 },
 GHC.Int.$fReadInt4_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uFI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uFJ; else goto c4uFK;
       c4uFJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uFK: // global
           I64[Sp - 8] = block_c4uFF_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt32_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt4_info" {
     GHC.Int.$fReadInt4_info:
         const GHC.Int.$fReadInt4_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+880;
 },
 _c4uFF() //  [R1]
         { []
         }
     {offset
       c4uFF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uFN; else goto c4uFM;
       c4uFN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uFM: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uFF_info" {
     block_c4uFF_info:
         const _c4uFF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.77575398 UTC

[section ""data" . GHC.Int.$fReadInt32_closure" {
     GHC.Int.$fReadInt32_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt32_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt32_$creadList_closure+1;
         const GHC.Int.$fReadInt6_closure+2;
         const GHC.Int.$fReadInt4_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.78166179 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquot_closure" {
     GHC.Int.$fIntegralInt32_$cquot_closure:
         const GHC.Int.$fIntegralInt32_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uG5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uG9; else goto c4uGa;
       c4uG9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uGa: // global
           I64[Sp - 16] = block_c4uG2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uGL; else goto c4uG3;
       u4uGL: // global
           call _c4uG2(R1) args: 0, res: 0, upd: 0;
       c4uG3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$cquot_info" {
     GHC.Int.$fIntegralInt32_$cquot_info:
         const GHC.Int.$fIntegralInt32_$cquot_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const S4lDl_srt+896;
 },
 _c4uG2() //  [R1]
         { []
         }
     {offset
       c4uG2: // global
           I64[Sp] = block_c4uG8_info;
           _s4lon::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lon::I64;
           if (R1 & 7 != 0) goto u4uGK; else goto c4uGc;
       u4uGK: // global
           call _c4uG8(R1) args: 0, res: 0, upd: 0;
       c4uGc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uG2_info" {
     block_c4uG2_info:
         const _c4uG2;
         const 1;
         const 12884901918;
         const S4lDl_srt+904;
 },
 _c4uG8() //  [R1]
         { []
         }
     {offset
       c4uG8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uGi; else goto c4uGh;
       c4uGi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uGh: // global
           _s4lon::I64 = I64[Sp + 8];
           _s4loq::I64 = I64[R1 + 7];
           if (_s4loq::I64 != (-1)) goto u4uGJ; else goto c4uGH;
       u4uGJ: // global
           if (_s4loq::I64 != 0) goto c4uGt; else goto c4uGI;
       c4uGt: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4lon::I64,
                                                                            _s4loq::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uGI: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uGH: // global
           if (_s4lon::I64 == (-2147483648)) goto c4uGG; else goto c4uGF;
       c4uGG: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uGF: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4lon::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uG8_info" {
     block_c4uG8_info:
         const _c4uG8;
         const 65;
         const 12884901918;
         const S4lDl_srt+904;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.798231759 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$crem_closure" {
     GHC.Int.$fIntegralInt32_$crem_closure:
         const GHC.Int.$fIntegralInt32_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uHb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uHf; else goto c4uHg;
       c4uHf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uHg: // global
           I64[Sp - 16] = block_c4uH8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uHE; else goto c4uH9;
       u4uHE: // global
           call _c4uH8(R1) args: 0, res: 0, upd: 0;
       c4uH9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$crem_info" {
     GHC.Int.$fIntegralInt32_$crem_info:
         const GHC.Int.$fIntegralInt32_$crem_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+912;
 },
 _c4uH8() //  [R1]
         { []
         }
     {offset
       c4uH8: // global
           I64[Sp] = block_c4uHe_info;
           _s4loB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loB::I64;
           if (R1 & 7 != 0) goto u4uHD; else goto c4uHi;
       u4uHD: // global
           call _c4uHe(R1) args: 0, res: 0, upd: 0;
       c4uHi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uH8_info" {
     block_c4uH8_info:
         const _c4uH8;
         const 1;
         const 4294967326;
         const S4lDl_srt+912;
 },
 _c4uHe() //  [R1]
         { []
         }
     {offset
       c4uHe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uHo; else goto c4uHn;
       c4uHo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uHn: // global
           _s4loE::I64 = I64[R1 + 7];
           if (_s4loE::I64 != (-1)) goto u4uHC; else goto c4uHA;
       u4uHC: // global
           if (_s4loE::I64 != 0) goto c4uHz; else goto c4uHB;
       c4uHz: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4loE::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uHB: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uHA: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uHe_info" {
     block_c4uHe_info:
         const _c4uHe;
         const 65;
         const 4294967326;
         const S4lDl_srt+912;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.811768988 UTC

[section ""data" . GHC.Int.$w$cdiv1_closure" {
     GHC.Int.$w$cdiv1_closure:
         const GHC.Int.$w$cdiv1_info;
         const 0;
 },
 GHC.Int.$w$cdiv1_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uI4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uI5; else goto c4uI6;
       c4uI5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uI6: // global
           if (R3 == (-1)) goto c4uI2; else goto u4uIq;
       c4uI2: // global
           if (R2 == (-2147483648)) goto c4uIp; else goto c4uIn;
       c4uIp: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uIn: // global
           I64[Sp - 8] = block_c4uIh_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4uIq: // global
           if (R3 == 0) goto c4uI3; else goto c4uI1;
       c4uI3: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uI1: // global
           I64[Sp - 8] = block_c4uI8_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdiv1_info" {
     GHC.Int.$w$cdiv1_info:
         const GHC.Int.$w$cdiv1_entry;
         const 0;
         const 47244640270;
         const 8589934604;
         const S4lDl_srt+904;
 },
 _c4uIh() //  [R1]
         { []
         }
     {offset
       c4uIh: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uIh_info" {
     block_c4uIh_info:
         const _c4uIh;
         const 0;
         const 30;
 },
 _c4uI8() //  [R1]
         { []
         }
     {offset
       c4uI8: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uI8_info" {
     block_c4uI8_info:
         const _c4uI8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.825100799 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdiv_closure" {
     GHC.Int.$fIntegralInt32_$cdiv_closure:
         const GHC.Int.$fIntegralInt32_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uIL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uIY; else goto c4uIZ;
       c4uIY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uIZ: // global
           I64[Sp - 16] = block_c4uII_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uJ6; else goto c4uIJ;
       u4uJ6: // global
           call _c4uII(R1) args: 0, res: 0, upd: 0;
       c4uIJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$cdiv_info" {
     GHC.Int.$fIntegralInt32_$cdiv_info:
         const GHC.Int.$fIntegralInt32_$cdiv_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+928;
 },
 _c4uII() //  [R1]
         { []
         }
     {offset
       c4uII: // global
           I64[Sp] = block_c4uIO_info;
           _s4loS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loS::I64;
           if (R1 & 7 != 0) goto u4uJ5; else goto c4uIP;
       u4uJ5: // global
           call _c4uIO(R1) args: 0, res: 0, upd: 0;
       c4uIP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uII_info" {
     block_c4uII_info:
         const _c4uII;
         const 1;
         const 4294967326;
         const S4lDl_srt+928;
 },
 _c4uIO() //  [R1]
         { []
         }
     {offset
       c4uIO: // global
           _s4loS::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4uIT_info;
           R3 = I64[R1 + 7];
           R2 = _s4loS::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uIO_info" {
     block_c4uIO_info:
         const _c4uIO;
         const 65;
         const 4294967326;
         const S4lDl_srt+928;
 },
 _c4uIT() //  [R1]
         { []
         }
     {offset
       c4uIT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uJ4; else goto c4uJ3;
       c4uJ4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4uJ3: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uIT_info" {
     block_c4uIT_info:
         const _c4uIT;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.84003525 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cmod_closure" {
     GHC.Int.$fIntegralInt32_$cmod_closure:
         const GHC.Int.$fIntegralInt32_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cmod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uJv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uJz; else goto c4uJA;
       c4uJz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uJA: // global
           I64[Sp - 16] = block_c4uJs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uK0; else goto c4uJt;
       u4uK0: // global
           call _c4uJs(R1) args: 0, res: 0, upd: 0;
       c4uJt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$cmod_info" {
     GHC.Int.$fIntegralInt32_$cmod_info:
         const GHC.Int.$fIntegralInt32_$cmod_entry;
         const 0;
         const 73014444046;
         const 8589934607;
         const S4lDl_srt+912;
 },
 _c4uJs() //  [R1]
         { []
         }
     {offset
       c4uJs: // global
           I64[Sp] = block_c4uJy_info;
           _s4loZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4loZ::I64;
           if (R1 & 7 != 0) goto u4uJZ; else goto c4uJC;
       u4uJZ: // global
           call _c4uJy(R1) args: 0, res: 0, upd: 0;
       c4uJC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uJs_info" {
     block_c4uJs_info:
         const _c4uJs;
         const 1;
         const 4294967326;
         const S4lDl_srt+912;
 },
 _c4uJy() //  [R1]
         { []
         }
     {offset
       c4uJy: // global
           _s4lp2::I64 = I64[R1 + 7];
           if (_s4lp2::I64 != (-1)) goto u4uJY; else goto c4uJW;
       u4uJY: // global
           if (_s4lp2::I64 != 0) goto c4uJS; else goto c4uJX;
       c4uJS: // global
           _s4loZ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4uJJ_info;
           R3 = _s4lp2::I64;
           R2 = _s4loZ::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4uJX: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uJW: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uJy_info" {
     block_c4uJy_info:
         const _c4uJy;
         const 65;
         const 4294967326;
         const S4lDl_srt+912;
 },
 _c4uJJ() //  [R1]
         { []
         }
     {offset
       c4uJJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uJV; else goto c4uJU;
       c4uJV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4uJU: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uJJ_info" {
     block_c4uJJ_info:
         const _c4uJJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.853772089 UTC

[section ""data" . lvl8_r4kPz_closure" {
     lvl8_r4kPz_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt6_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.860232921 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquotRem_closure" {
     GHC.Int.$fIntegralInt32_$cquotRem_closure:
         const GHC.Int.$fIntegralInt32_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uKs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uKw; else goto c4uKx;
       c4uKw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uKx: // global
           I64[Sp - 16] = block_c4uKp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uLc; else goto c4uKq;
       u4uLc: // global
           call _c4uKp(R1) args: 0, res: 0, upd: 0;
       c4uKq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$cquotRem_info" {
     GHC.Int.$fIntegralInt32_$cquotRem_info:
         const GHC.Int.$fIntegralInt32_$cquotRem_entry;
         const 0;
         const 416611827726;
         const 8589934607;
         const S4lDl_srt+912;
 },
 _c4uKp() //  [R1]
         { []
         }
     {offset
       c4uKp: // global
           I64[Sp] = block_c4uKv_info;
           _s4lp9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lp9::I64;
           if (R1 & 7 != 0) goto u4uLb; else goto c4uKz;
       u4uLb: // global
           call _c4uKv(R1) args: 0, res: 0, upd: 0;
       c4uKz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uKp_info" {
     block_c4uKp_info:
         const _c4uKp;
         const 1;
         const 279172874270;
         const S4lDl_srt+912;
 },
 _c4uKv() //  [R1]
         { []
         }
     {offset
       c4uKv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4uKF; else goto c4uKE;
       c4uKF: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uKE: // global
           _s4lp9::I64 = I64[Sp + 8];
           _s4lpc::I64 = I64[R1 + 7];
           if (_s4lpc::I64 != (-1)) goto u4uLa; else goto c4uL8;
       u4uLa: // global
           if (_s4lpc::I64 != 0) goto c4uKS; else goto c4uL9;
       c4uKS: // global
           (_s4lpe::I64, _s4lpf::I64) = call MO_S_QuotRem W64(_s4lp9::I64, _s4lpc::I64);
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpf::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpe::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uL9: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uL8: // global
           if (_s4lp9::I64 == (-2147483648)) goto c4uL7; else goto c4uL6;
       c4uL7: // global
           Hp = Hp - 56;
           R1 = lvl8_r4kPz_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uL6: // global
           (_s4lpm::I64, _s4lpn::I64) = call MO_S_QuotRem W64(_s4lp9::I64, (-1));
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpn::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpm::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uKv_info" {
     block_c4uKv_info:
         const _c4uKv;
         const 65;
         const 279172874270;
         const S4lDl_srt+912;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.87979399 UTC

[section ""data" . GHC.Int.$w$cdivMod1_closure" {
     GHC.Int.$w$cdivMod1_closure:
         const GHC.Int.$w$cdivMod1_info;
         const 0;
 },
 GHC.Int.$w$cdivMod1_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uLK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uLL; else goto c4uLM;
       c4uLL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uLM: // global
           if (R3 == 0) goto c4uLJ; else goto c4uLI;
       c4uLJ: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4uLI: // global
           if (R3 == (-1)) goto c4uOf; else goto u4uOg;
       c4uOf: // global
           if (R2 == (-2147483648)) goto c4uOe; else goto u4uOh;
       c4uOe: // global
           R2 = GHC.Int.$fBitsInt6_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4uOh: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4uOj;
       u4uOg: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4uOj;
       u4uOj: // global
           call _c4uLR() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdivMod1_info" {
     GHC.Int.$w$cdivMod1_info:
         const GHC.Int.$w$cdivMod1_entry;
         const 0;
         const 1112396529678;
         const 8589934604;
         const S4lDl_srt+904;
 },
 _c4uLR() //  []
         { []
         }
     {offset
       c4uLR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4uLV; else goto c4uLU;
       c4uLV: // global
           HpAlloc = 32;
           I64[Sp] = block_c4uLR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4uLU: // global
           _s4lpt::I64 = I64[Sp + 8];
           _s4lpv::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lpt::I64, 0)) goto c4uMO; else goto c4uO5;
       c4uMO: // global
           if (%MO_S_Ge_W64(_s4lpt::I64, 0)) goto c4uMb; else goto c4uMM;
       c4uMb: // global
           (_s4lpA::I64, _s4lpB::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpB::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpA::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uMM: // global
           if (%MO_S_Le_W64(_s4lpv::I64, 0)) goto c4uMp; else goto c4uML;
       c4uMp: // global
           (_s4lpI::I64, _s4lpJ::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpJ::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpI::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uML: // global
           (_s4lpQ::I64, _s4lpR::I64) = call MO_S_QuotRem W64(_s4lpt::I64 + 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpR::I64 + _s4lpv::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lpQ::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uO5: // global
           if (%MO_S_Ge_W64(_s4lpv::I64, 0)) goto c4uNI; else goto c4uO4;
       c4uNI: // global
           if (%MO_S_Ge_W64(_s4lpt::I64, 0)) goto c4uN5; else goto c4uNG;
       c4uN5: // global
           (_s4lq2::I64, _s4lq3::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lq3::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lq2::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uNG: // global
           if (%MO_S_Le_W64(_s4lpv::I64, 0)) goto c4uNj; else goto c4uNF;
       c4uNj: // global
           (_s4lqa::I64, _s4lqb::I64) = call MO_S_QuotRem W64(_s4lpt::I64, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqb::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqa::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uNF: // global
           (_s4lqi::I64, _s4lqj::I64) = call MO_S_QuotRem W64(_s4lpt::I64 + 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqj::I64 + _s4lpv::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqi::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4uO4: // global
           (_s4lqt::I64, _s4lqu::I64) = call MO_S_QuotRem W64(_s4lpt::I64 - 1, _s4lpv::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqu::I64 + _s4lpv::I64 + 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4lqt::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uLR_info" {
     block_c4uLR_info:
         const _c4uLR;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.890369838 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdivMod_closure" {
     GHC.Int.$fIntegralInt32_$cdivMod_closure:
         const GHC.Int.$fIntegralInt32_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uP7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uPi; else goto c4uPj;
       c4uPi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uPj: // global
           I64[Sp - 16] = block_c4uP4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uPq; else goto c4uP5;
       u4uPq: // global
           call _c4uP4(R1) args: 0, res: 0, upd: 0;
       c4uP5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$cdivMod_info" {
     GHC.Int.$fIntegralInt32_$cdivMod_info:
         const GHC.Int.$fIntegralInt32_$cdivMod_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+968;
 },
 _c4uP4() //  [R1]
         { []
         }
     {offset
       c4uP4: // global
           I64[Sp] = block_c4uPa_info;
           _s4lqI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lqI::I64;
           if (R1 & 7 != 0) goto u4uPp; else goto c4uPb;
       u4uPp: // global
           call _c4uPa(R1) args: 0, res: 0, upd: 0;
       c4uPb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uP4_info" {
     block_c4uP4_info:
         const _c4uP4;
         const 1;
         const 4294967326;
         const S4lDl_srt+968;
 },
 _c4uPa() //  [R1]
         { []
         }
     {offset
       c4uPa: // global
           _s4lqI::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4uPf_info;
           R3 = I64[R1 + 7];
           R2 = _s4lqI::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uPa_info" {
     block_c4uPa_info:
         const _c4uPa;
         const 65;
         const 4294967326;
         const S4lDl_srt+968;
 },
 _c4uPf() //  [R1, R2]
         { []
         }
     {offset
       c4uPf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4uPo; else goto c4uPn;
       c4uPo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4uPn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uPf_info" {
     block_c4uPf_info:
         const _c4uPf;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.900823648 UTC

[section ""data" . GHC.Int.$fRealInt32_$ctoRational_closure" {
     GHC.Int.$fRealInt32_$ctoRational_closure:
         const GHC.Int.$fRealInt32_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt32_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c4uPP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uQ3; else goto c4uQ4;
       c4uQ3: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uQ4: // global
           I64[Sp - 8] = block_c4uPM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uQb; else goto c4uPN;
       u4uQb: // global
           call _c4uPM(R1) args: 0, res: 0, upd: 0;
       c4uPN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fRealInt32_$ctoRational_info" {
     GHC.Int.$fRealInt32_$ctoRational_info:
         const GHC.Int.$fRealInt32_$ctoRational_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S4lDl_srt+984;
 },
 _c4uPM() //  [R1]
         { []
         }
     {offset
       c4uPM: // global
           I64[Sp] = block_c4uPS_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uPM_info" {
     block_c4uPM_info:
         const _c4uPM;
         const 0;
         const 30064771102;
         const S4lDl_srt+992;
 },
 _c4uPS() //  [R1]
         { []
         }
     {offset
       c4uPS: // global
           I64[Sp] = block_c4uPW_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uPS_info" {
     block_c4uPS_info:
         const _c4uPS;
         const 0;
         const 30064771102;
         const S4lDl_srt+992;
 },
 _c4uPW() //  [R1]
         { []
         }
     {offset
       c4uPW: // global
           I64[Sp] = block_c4uQ0_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uPW_info" {
     block_c4uPW_info:
         const _c4uPW;
         const 0;
         const 12884901918;
         const S4lDl_srt+992;
 },
 _c4uQ0() //  [R1, R2]
         { []
         }
     {offset
       c4uQ0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4uQa; else goto c4uQ9;
       c4uQa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4uQ9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uQ0_info" {
     block_c4uQ0_info:
         const _c4uQ0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.910564913 UTC

[section ""data" . GHC.Int.$fRealInt32_closure" {
     GHC.Int.$fRealInt32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt32_closure+1;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fRealInt32_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.912474739 UTC

[section ""data" . GHC.Int.$fIntegralInt32_closure" {
     GHC.Int.$fIntegralInt32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt32_closure+1;
         const GHC.Int.$fEnumInt32_closure+1;
         const GHC.Int.$fIntegralInt32_$cquot_closure+2;
         const GHC.Int.$fIntegralInt32_$crem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt32_$cmod_closure+2;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt32_$ctoInteger_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.915918108 UTC

[section ""data" . GHC.Int.$fIxInt32_$crange_closure" {
     GHC.Int.$fIxInt32_$crange_closure:
         const GHC.Int.$fIxInt32_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$crange_entry() //  [R2]
         { []
         }
     {offset
       c4uQE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4uQF; else goto c4uQG;
       c4uQF: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uQG: // global
           I64[Sp - 8] = block_c4uQB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uQK; else goto c4uQC;
       u4uQK: // global
           call _c4uQB(R1) args: 0, res: 0, upd: 0;
       c4uQC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$crange_info" {
     GHC.Int.$fIxInt32_$crange_info:
         const GHC.Int.$fIxInt32_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4lDl_srt+1016;
 },
 _c4uQB() //  [R1]
         { []
         }
     {offset
       c4uQB: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uQB_info" {
     block_c4uQB_info:
         const _c4uQB;
         const 0;
         const 4294967326;
         const S4lDl_srt+1024;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.922577042 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt32_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt32_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt32_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uR1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uRi; else goto c4uRj;
       c4uRi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uRj: // global
           I64[Sp - 16] = block_c4uQY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uRq; else goto c4uQZ;
       u4uRq: // global
           call _c4uQY(R1) args: 0, res: 0, upd: 0;
       c4uQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$cunsafeIndex_info" {
     GHC.Int.$fIxInt32_$cunsafeIndex_info:
         const GHC.Int.$fIxInt32_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uQY() //  [R1]
         { []
         }
     {offset
       c4uQY: // global
           I64[Sp] = block_c4uR4_info;
           _s4lr3::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lr3::P64;
           if (R1 & 7 != 0) goto u4uRp; else goto c4uR5;
       u4uRp: // global
           call _c4uR4(R1) args: 0, res: 0, upd: 0;
       c4uR5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uQY_info" {
     block_c4uQY_info:
         const _c4uQY;
         const 1;
         const 30;
 },
 _c4uR4() //  [R1]
         { []
         }
     {offset
       c4uR4: // global
           I64[Sp] = block_c4uR9_info;
           _s4lr6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lr6::I64;
           if (R1 & 7 != 0) goto u4uRr; else goto c4uRa;
       u4uRr: // global
           call _c4uR9(R1) args: 0, res: 0, upd: 0;
       c4uRa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uR4_info" {
     block_c4uR4_info:
         const _c4uR4;
         const 1;
         const 30;
 },
 _c4uR9() //  [R1]
         { []
         }
     {offset
       c4uR9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uRo; else goto c4uRn;
       c4uRo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uRn: // global
           _s4lr9::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lr9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uR9_info" {
     block_c4uR9_info:
         const _c4uR9;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.933202977 UTC

[section ""data" . GHC.Int.$fIxInt32_$crangeSize_closure" {
     GHC.Int.$fIxInt32_$crangeSize_closure:
         const GHC.Int.$fIxInt32_$crangeSize_info;
 },
 GHC.Int.$fIxInt32_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4uRT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uS2; else goto c4uS3;
       c4uS2: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uS3: // global
           I64[Sp - 8] = block_c4uRQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uSs; else goto c4uRR;
       u4uSs: // global
           call _c4uRQ(R1) args: 0, res: 0, upd: 0;
       c4uRR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$crangeSize_info" {
     GHC.Int.$fIxInt32_$crangeSize_info:
         const GHC.Int.$fIxInt32_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4uRQ() //  [R1]
         { []
         }
     {offset
       c4uRQ: // global
           I64[Sp - 8] = block_c4uRW_info;
           _s4lrd::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lrd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uSr; else goto c4uRX;
       u4uSr: // global
           call _c4uRW(R1) args: 0, res: 0, upd: 0;
       c4uRX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uRQ_info" {
     block_c4uRQ_info:
         const _c4uRQ;
         const 0;
         const 30;
 },
 _c4uRW() //  [R1]
         { []
         }
     {offset
       c4uRW: // global
           I64[Sp] = block_c4uS1_info;
           _s4lrf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrf::I64;
           if (R1 & 7 != 0) goto u4uSt; else goto c4uS6;
       u4uSt: // global
           call _c4uS1(R1) args: 0, res: 0, upd: 0;
       c4uS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uRW_info" {
     block_c4uRW_info:
         const _c4uRW;
         const 1;
         const 30;
 },
 _c4uS1() //  [R1]
         { []
         }
     {offset
       c4uS1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uSc; else goto c4uSb;
       c4uSc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uSb: // global
           _s4lrf::I64 = I64[Sp + 8];
           _s4lrh::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lrf::I64,
                            _s4lrh::I64)) goto c4uSg; else goto c4uSq;
       c4uSg: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uSq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lrh::I64 - _s4lrf::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uS1_info" {
     block_c4uS1_info:
         const _c4uS1;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.944585849 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt32_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt32_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4uSX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uTh; else goto c4uTi;
       c4uTh: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4uTi: // global
           I64[Sp - 8] = block_c4uSU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uTp; else goto c4uSV;
       u4uTp: // global
           call _c4uSU(R1) args: 0, res: 0, upd: 0;
       c4uSV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$cunsafeRangeSize_info" {
     GHC.Int.$fIxInt32_$cunsafeRangeSize_info:
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4uSU() //  [R1]
         { []
         }
     {offset
       c4uSU: // global
           I64[Sp - 8] = block_c4uT0_info;
           _s4lrn::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lrn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uTo; else goto c4uT1;
       u4uTo: // global
           call _c4uT0(R1) args: 0, res: 0, upd: 0;
       c4uT1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uSU_info" {
     block_c4uSU_info:
         const _c4uSU;
         const 0;
         const 30;
 },
 _c4uT0() //  [R1]
         { []
         }
     {offset
       c4uT0: // global
           I64[Sp] = block_c4uT5_info;
           _s4lrq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrq::I64;
           if (R1 & 7 != 0) goto u4uTq; else goto c4uT6;
       u4uTq: // global
           call _c4uT5(R1) args: 0, res: 0, upd: 0;
       c4uT6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uT0_info" {
     block_c4uT0_info:
         const _c4uT0;
         const 1;
         const 30;
 },
 _c4uT5() //  [R1]
         { []
         }
     {offset
       c4uT5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uTn; else goto c4uTm;
       c4uTn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uTm: // global
           _s4lru::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lru::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uT5_info" {
     block_c4uT5_info:
         const _c4uT5;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.956253595 UTC

[section ""data" . GHC.Int.$fIxInt32_$cindex_closure" {
     GHC.Int.$fIxInt32_$cindex_closure:
         const GHC.Int.$fIxInt32_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uTT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uU2; else goto c4uU3;
       c4uU2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uU3: // global
           I64[Sp - 16] = block_c4uTQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uUC; else goto c4uTR;
       u4uUC: // global
           call _c4uTQ(R1) args: 0, res: 0, upd: 0;
       c4uTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$cindex_info" {
     GHC.Int.$fIxInt32_$cindex_info:
         const GHC.Int.$fIxInt32_$cindex_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+1032;
 },
 _c4uTQ() //  [R1]
         { []
         }
     {offset
       c4uTQ: // global
           I64[Sp - 8] = block_c4uTW_info;
           _s4lrz::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lrz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uUB; else goto c4uTX;
       u4uUB: // global
           call _c4uTW(R1) args: 0, res: 0, upd: 0;
       c4uTX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uTQ_info" {
     block_c4uTQ_info:
         const _c4uTQ;
         const 1;
         const 4294967326;
         const S4lDl_srt+1040;
 },
 _c4uTW() //  [R1]
         { []
         }
     {offset
       c4uTW: // global
           I64[Sp] = block_c4uU1_info;
           _s4lrB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lrB::I64;
           if (R1 & 7 != 0) goto u4uUD; else goto c4uU6;
       u4uUD: // global
           call _c4uU1(R1) args: 0, res: 0, upd: 0;
       c4uU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uTW_info" {
     block_c4uTW_info:
         const _c4uTW;
         const 2;
         const 4294967326;
         const S4lDl_srt+1040;
 },
 _c4uU1() //  [R1]
         { []
         }
     {offset
       c4uU1: // global
           _s4lrD::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lrD::I64)) goto c4uUe; else goto c4uUi;
       c4uUe: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4uUi: // global
           I64[Sp] = block_c4uUh_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrD::I64;
           if (R1 & 7 != 0) goto u4uUE; else goto c4uUj;
       u4uUE: // global
           call _c4uUh(R1) args: 0, res: 0, upd: 0;
       c4uUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uU1_info" {
     block_c4uU1_info:
         const _c4uU1;
         const 130;
         const 4294967326;
         const S4lDl_srt+1040;
 },
 _c4uUh() //  [R1]
         { []
         }
     {offset
       c4uUh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4uUp; else goto c4uUo;
       c4uUp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4uUo: // global
           _s4lrD::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4lrD::I64,
                            I64[R1 + 7])) goto c4uUt; else goto c4uUA;
       c4uUt: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4uUA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lrD::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uUh_info" {
     block_c4uUh_info:
         const _c4uUh;
         const 194;
         const 4294967326;
         const S4lDl_srt+1040;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.966817561 UTC

[section ""data" . GHC.Int.$fIxInt32_closure" {
     GHC.Int.$fIxInt32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fIxInt32_$crange_closure+1;
         const GHC.Int.$fIxInt32_$cindex_closure+2;
         const GHC.Int.$fIxInt32_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt32_$cinRange_closure+2;
         const GHC.Int.$fIxInt32_$crangeSize_closure+1;
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.970485943 UTC

[section ""data" . GHC.Int.eqInt64_closure" {
     GHC.Int.eqInt64_closure:
         const GHC.Int.eqInt64_info;
 },
 GHC.Int.eqInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uVd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uVh; else goto c4uVi;
       c4uVh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uVi: // global
           I64[Sp - 16] = block_c4uVa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uVr; else goto c4uVb;
       u4uVr: // global
           call _c4uVa(R1) args: 0, res: 0, upd: 0;
       c4uVb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.eqInt64_info" {
     GHC.Int.eqInt64_info:
         const GHC.Int.eqInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uVa() //  [R1]
         { []
         }
     {offset
       c4uVa: // global
           I64[Sp] = block_c4uVg_info;
           _s4lrM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrM::I64;
           if (R1 & 7 != 0) goto u4uVq; else goto c4uVk;
       u4uVq: // global
           call _c4uVg(R1) args: 0, res: 0, upd: 0;
       c4uVk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uVa_info" {
     block_c4uVa_info:
         const _c4uVa;
         const 1;
         const 30;
 },
 _c4uVg() //  [R1]
         { []
         }
     {offset
       c4uVg: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uVg_info" {
     block_c4uVg_info:
         const _c4uVg;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.97773776 UTC

[section ""data" . GHC.Int.$fEqInt64_closure" {
     GHC.Int.$fEqInt64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt64_closure+2;
         const GHC.Int.neInt64_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.980628997 UTC

[section ""data" . GHC.Int.gtInt64_closure" {
     GHC.Int.gtInt64_closure:
         const GHC.Int.gtInt64_info;
 },
 GHC.Int.gtInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uVR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uVV; else goto c4uVW;
       c4uVV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uVW: // global
           I64[Sp - 16] = block_c4uVO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uW5; else goto c4uVP;
       u4uW5: // global
           call _c4uVO(R1) args: 0, res: 0, upd: 0;
       c4uVP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.gtInt64_info" {
     GHC.Int.gtInt64_info:
         const GHC.Int.gtInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uVO() //  [R1]
         { []
         }
     {offset
       c4uVO: // global
           I64[Sp] = block_c4uVU_info;
           _s4lrT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lrT::I64;
           if (R1 & 7 != 0) goto u4uW4; else goto c4uVY;
       u4uW4: // global
           call _c4uVU(R1) args: 0, res: 0, upd: 0;
       c4uVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uVO_info" {
     block_c4uVO_info:
         const _c4uVO;
         const 1;
         const 30;
 },
 _c4uVU() //  [R1]
         { []
         }
     {offset
       c4uVU: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uVU_info" {
     block_c4uVU_info:
         const _c4uVU;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.988858586 UTC

[section ""data" . GHC.Int.geInt64_closure" {
     GHC.Int.geInt64_closure:
         const GHC.Int.geInt64_info;
 },
 GHC.Int.geInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uWu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uWy; else goto c4uWz;
       c4uWy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uWz: // global
           I64[Sp - 16] = block_c4uWr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uWI; else goto c4uWs;
       u4uWI: // global
           call _c4uWr(R1) args: 0, res: 0, upd: 0;
       c4uWs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.geInt64_info" {
     GHC.Int.geInt64_info:
         const GHC.Int.geInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uWr() //  [R1]
         { []
         }
     {offset
       c4uWr: // global
           I64[Sp] = block_c4uWx_info;
           _s4ls0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ls0::I64;
           if (R1 & 7 != 0) goto u4uWH; else goto c4uWB;
       u4uWH: // global
           call _c4uWx(R1) args: 0, res: 0, upd: 0;
       c4uWB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uWr_info" {
     block_c4uWr_info:
         const _c4uWr;
         const 1;
         const 30;
 },
 _c4uWx() //  [R1]
         { []
         }
     {offset
       c4uWx: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uWx_info" {
     block_c4uWx_info:
         const _c4uWx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:12.997494778 UTC

[section ""data" . GHC.Int.ltInt64_closure" {
     GHC.Int.ltInt64_closure:
         const GHC.Int.ltInt64_info;
 },
 GHC.Int.ltInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uX7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uXb; else goto c4uXc;
       c4uXb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uXc: // global
           I64[Sp - 16] = block_c4uX4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uXl; else goto c4uX5;
       u4uXl: // global
           call _c4uX4(R1) args: 0, res: 0, upd: 0;
       c4uX5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.ltInt64_info" {
     GHC.Int.ltInt64_info:
         const GHC.Int.ltInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uX4() //  [R1]
         { []
         }
     {offset
       c4uX4: // global
           I64[Sp] = block_c4uXa_info;
           _s4ls7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ls7::I64;
           if (R1 & 7 != 0) goto u4uXk; else goto c4uXe;
       u4uXk: // global
           call _c4uXa(R1) args: 0, res: 0, upd: 0;
       c4uXe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uX4_info" {
     block_c4uX4_info:
         const _c4uX4;
         const 1;
         const 30;
 },
 _c4uXa() //  [R1]
         { []
         }
     {offset
       c4uXa: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uXa_info" {
     block_c4uXa_info:
         const _c4uXa;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.005207013 UTC

[section ""data" . GHC.Int.leInt64_closure" {
     GHC.Int.leInt64_closure:
         const GHC.Int.leInt64_info;
 },
 GHC.Int.leInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uXK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uXO; else goto c4uXP;
       c4uXO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uXP: // global
           I64[Sp - 16] = block_c4uXH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uXY; else goto c4uXI;
       u4uXY: // global
           call _c4uXH(R1) args: 0, res: 0, upd: 0;
       c4uXI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.leInt64_info" {
     GHC.Int.leInt64_info:
         const GHC.Int.leInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uXH() //  [R1]
         { []
         }
     {offset
       c4uXH: // global
           I64[Sp] = block_c4uXN_info;
           _s4lse::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lse::I64;
           if (R1 & 7 != 0) goto u4uXX; else goto c4uXR;
       u4uXX: // global
           call _c4uXN(R1) args: 0, res: 0, upd: 0;
       c4uXR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uXH_info" {
     block_c4uXH_info:
         const _c4uXH;
         const 1;
         const 30;
 },
 _c4uXN() //  [R1]
         { []
         }
     {offset
       c4uXN: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uXN_info" {
     block_c4uXN_info:
         const _c4uXN;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.013828665 UTC

[section ""data" . GHC.Int.$fOrdInt64_$ccompare_closure" {
     GHC.Int.$fOrdInt64_$ccompare_closure:
         const GHC.Int.$fOrdInt64_$ccompare_info;
 },
 GHC.Int.$fOrdInt64_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uYn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4uYr; else goto c4uYs;
       c4uYr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uYs: // global
           I64[Sp - 16] = block_c4uYk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uYL; else goto c4uYl;
       u4uYL: // global
           call _c4uYk(R1) args: 0, res: 0, upd: 0;
       c4uYl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt64_$ccompare_info" {
     GHC.Int.$fOrdInt64_$ccompare_info:
         const GHC.Int.$fOrdInt64_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uYk() //  [R1]
         { []
         }
     {offset
       c4uYk: // global
           I64[Sp] = block_c4uYq_info;
           _s4lsl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lsl::I64;
           if (R1 & 7 != 0) goto u4uYK; else goto c4uYu;
       u4uYK: // global
           call _c4uYq(R1) args: 0, res: 0, upd: 0;
       c4uYu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uYk_info" {
     block_c4uYk_info:
         const _c4uYk;
         const 1;
         const 30;
 },
 _c4uYq() //  [R1]
         { []
         }
     {offset
       c4uYq: // global
           _s4lsl::I64 = I64[Sp + 8];
           _s4lsn::I64 = I64[R1 + 7];
           if (_s4lsl::I64 == _s4lsn::I64) goto c4uYJ; else goto c4uYI;
       c4uYJ: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uYI: // global
           if (%MO_S_Gt_W64(_s4lsl::I64,
                            _s4lsn::I64)) goto c4uYF; else goto c4uYG;
       c4uYF: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4uYG: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uYq_info" {
     block_c4uYq_info:
         const _c4uYq;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.022647261 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmax_closure" {
     GHC.Int.$fOrdInt64_$cmax_closure:
         const GHC.Int.$fOrdInt64_$cmax_info;
 },
 GHC.Int.$fOrdInt64_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uZ9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uZd; else goto c4uZe;
       c4uZd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uZe: // global
           I64[Sp - 16] = block_c4uZ6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4uZr; else goto c4uZ7;
       u4uZr: // global
           call _c4uZ6(R1) args: 0, res: 0, upd: 0;
       c4uZ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt64_$cmax_info" {
     GHC.Int.$fOrdInt64_$cmax_info:
         const GHC.Int.$fOrdInt64_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uZ6() //  [R1]
         { []
         }
     {offset
       c4uZ6: // global
           I64[Sp - 8] = block_c4uZc_info;
           _s4lss::P64 = R1;
           _s4lst::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lst::I64;
           P64[Sp + 8] = _s4lss::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4uZq; else goto c4uZg;
       u4uZq: // global
           call _c4uZc(R1) args: 0, res: 0, upd: 0;
       c4uZg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uZ6_info" {
     block_c4uZ6_info:
         const _c4uZ6;
         const 1;
         const 30;
 },
 _c4uZc() //  [R1]
         { []
         }
     {offset
       c4uZc: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4uZo; else goto c4uZp;
       c4uZo: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4uZp: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uZc_info" {
     block_c4uZc_info:
         const _c4uZc;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.031468786 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmin_closure" {
     GHC.Int.$fOrdInt64_$cmin_closure:
         const GHC.Int.$fOrdInt64_$cmin_info;
 },
 GHC.Int.$fOrdInt64_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c4uZR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4uZV; else goto c4uZW;
       c4uZV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4uZW: // global
           I64[Sp - 16] = block_c4uZO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v09; else goto c4uZP;
       u4v09: // global
           call _c4uZO(R1) args: 0, res: 0, upd: 0;
       c4uZP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt64_$cmin_info" {
     GHC.Int.$fOrdInt64_$cmin_info:
         const GHC.Int.$fOrdInt64_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4uZO() //  [R1]
         { []
         }
     {offset
       c4uZO: // global
           I64[Sp - 8] = block_c4uZU_info;
           _s4lsz::P64 = R1;
           _s4lsA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lsA::I64;
           P64[Sp + 8] = _s4lsz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v08; else goto c4uZY;
       u4v08: // global
           call _c4uZU(R1) args: 0, res: 0, upd: 0;
       c4uZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uZO_info" {
     block_c4uZO_info:
         const _c4uZO;
         const 1;
         const 30;
 },
 _c4uZU() //  [R1]
         { []
         }
     {offset
       c4uZU: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4v06; else goto c4v07;
       c4v06: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4v07: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4uZU_info" {
     block_c4uZU_info:
         const _c4uZU;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.041474676 UTC

[section ""data" . GHC.Int.$fOrdInt64_closure" {
     GHC.Int.$fOrdInt64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fOrdInt64_$ccompare_closure+2;
         const GHC.Int.ltInt64_closure+2;
         const GHC.Int.leInt64_closure+2;
         const GHC.Int.gtInt64_closure+2;
         const GHC.Int.geInt64_closure+2;
         const GHC.Int.$fOrdInt64_$cmax_closure+2;
         const GHC.Int.$fOrdInt64_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.047398301 UTC

[section ""data" . GHC.Int.$fIxInt64_$cinRange_closure" {
     GHC.Int.$fIxInt64_$cinRange_closure:
         const GHC.Int.$fIxInt64_$cinRange_info;
 },
 GHC.Int.$fIxInt64_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c4v0A: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4v0J; else goto c4v0K;
       c4v0J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v0K: // global
           I64[Sp - 16] = block_c4v0x_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v17; else goto c4v0y;
       u4v17: // global
           call _c4v0x(R1) args: 0, res: 0, upd: 0;
       c4v0y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$cinRange_info" {
     GHC.Int.$fIxInt64_$cinRange_info:
         const GHC.Int.$fIxInt64_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4v0x() //  [R1]
         { []
         }
     {offset
       c4v0x: // global
           I64[Sp - 8] = block_c4v0D_info;
           _s4lsI::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lsI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v16; else goto c4v0E;
       u4v16: // global
           call _c4v0D(R1) args: 0, res: 0, upd: 0;
       c4v0E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v0x_info" {
     block_c4v0x_info:
         const _c4v0x;
         const 1;
         const 30;
 },
 _c4v0D() //  [R1]
         { []
         }
     {offset
       c4v0D: // global
           I64[Sp] = block_c4v0I_info;
           _s4lsK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lsK::I64;
           if (R1 & 7 != 0) goto u4v18; else goto c4v0N;
       u4v18: // global
           call _c4v0I(R1) args: 0, res: 0, upd: 0;
       c4v0N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v0D_info" {
     block_c4v0D_info:
         const _c4v0D;
         const 2;
         const 30;
 },
 _c4v0I() //  [R1]
         { []
         }
     {offset
       c4v0I: // global
           _s4lsM::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lsM::I64)) goto c4v0V; else goto c4v0Z;
       c4v0V: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v0Z: // global
           _s4lsI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4v0Y_info;
           R1 = _s4lsI::P64;
           I64[Sp + 16] = _s4lsM::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4v19; else goto c4v10;
       u4v19: // global
           call _c4v0Y(R1) args: 0, res: 0, upd: 0;
       c4v10: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v0I_info" {
     block_c4v0I_info:
         const _c4v0I;
         const 130;
         const 30;
 },
 _c4v0Y() //  [R1]
         { []
         }
     {offset
       c4v0Y: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v0Y_info" {
     block_c4v0Y_info:
         const _c4v0Y;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.063652701 UTC

[section ""data" . GHC.Int.$fNumInt5_closure" {
     GHC.Int.$fNumInt5_closure:
         const GHC.Int.I64#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.067871285 UTC

[section ""data" . GHC.Int.$fNumInt64_$csignum_closure" {
     GHC.Int.$fNumInt64_$csignum_closure:
         const GHC.Int.$fNumInt64_$csignum_info;
 },
 GHC.Int.$fNumInt64_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c4v1I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4v1J; else goto c4v1K;
       c4v1J: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4v1K: // global
           I64[Sp - 8] = block_c4v1F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v1Y; else goto c4v1G;
       u4v1Y: // global
           call _c4v1F(R1) args: 0, res: 0, upd: 0;
       c4v1G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$csignum_info" {
     GHC.Int.$fNumInt64_$csignum_info:
         const GHC.Int.$fNumInt64_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4v1F() //  [R1]
         { []
         }
     {offset
       c4v1F: // global
           _s4lsT::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4lsT::I64, 0)) goto c4v1W; else goto c4v1X;
       c4v1W: // global
           if (_s4lsT::I64 == 0) goto c4v1U; else goto c4v1T;
       c4v1U: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v1T: // global
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v1X: // global
           R1 = GHC.Int.$fNumInt5_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v1F_info" {
     block_c4v1F_info:
         const _c4v1F;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.078294404 UTC

[section ""data" . GHC.Int.$fNumInt64_$cabs_closure" {
     GHC.Int.$fNumInt64_$cabs_closure:
         const GHC.Int.$fNumInt64_$cabs_info;
 },
 GHC.Int.$fNumInt64_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c4v2i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4v2j; else goto c4v2k;
       c4v2j: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4v2k: // global
           I64[Sp - 8] = block_c4v2f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v2A; else goto c4v2g;
       u4v2A: // global
           call _c4v2f(R1) args: 0, res: 0, upd: 0;
       c4v2g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$cabs_info" {
     GHC.Int.$fNumInt64_$cabs_info:
         const GHC.Int.$fNumInt64_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4v2f() //  [R1]
         { []
         }
     {offset
       c4v2f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4v2p; else goto c4v2o;
       c4v2p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4v2o: // global
           _s4lsY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lsY::I64, 0)) goto c4v2y; else goto c4v2z;
       c4v2y: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = -_s4lsY::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v2z: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v2f_info" {
     block_c4v2f_info:
         const _c4v2f;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.087792438 UTC

[section ""data" . GHC.Int.$fNumInt64_closure" {
     GHC.Int.$fNumInt64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt64_$c+_closure+2;
         const GHC.Int.$fNumInt64_$c-_closure+2;
         const GHC.Int.$fNumInt64_$c*_closure+2;
         const GHC.Int.$fNumInt64_$cnegate_closure+1;
         const GHC.Int.$fNumInt64_$cabs_closure+1;
         const GHC.Int.$fNumInt64_$csignum_closure+1;
         const GHC.Int.$fNumInt64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.090529423 UTC

[section ""data" . GHC.Int.$fBitsInt9_closure" {
     GHC.Int.$fBitsInt9_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt7_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.093863042 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt64_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c4v2U: // global
           R1 = GHC.Int.$fBitsInt9_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cbitSizeMaybe_info" {
     GHC.Int.$fBitsInt64_$cbitSizeMaybe_info:
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.100200701 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbit_closure" {
     GHC.Int.$fBitsInt64_$cbit_closure:
         const GHC.Int.$fBitsInt64_$cbit_info;
 },
 GHC.Int.$fBitsInt64_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c4v39: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4v3a; else goto c4v3b;
       c4v3a: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4v3b: // global
           I64[Sp - 8] = block_c4v36_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v3r; else goto c4v37;
       u4v3r: // global
           call _c4v36(R1) args: 0, res: 0, upd: 0;
       c4v37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cbit_info" {
     GHC.Int.$fBitsInt64_$cbit_info:
         const GHC.Int.$fBitsInt64_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4v36() //  [R1]
         { []
         }
     {offset
       c4v36: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4v3g; else goto c4v3f;
       c4v3g: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4v3f: // global
           _s4lt4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lt4::I64, 64)) goto c4v3p; else goto c4v3q;
       c4v3p: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = 1 << _s4lt4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v3q: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v36_info" {
     block_c4v36_info:
         const _c4v36;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.112151067 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ctestBit_closure" {
     GHC.Int.$fBitsInt64_$ctestBit_closure:
         const GHC.Int.$fBitsInt64_$ctestBit_info;
 },
 GHC.Int.$fBitsInt64_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4v3L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4v3P; else goto c4v3Q;
       c4v3P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v3Q: // global
           I64[Sp - 16] = block_c4v3I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v4v; else goto c4v3J;
       u4v4v: // global
           call _c4v3I(R1) args: 0, res: 0, upd: 0;
       c4v3J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$ctestBit_info" {
     GHC.Int.$fBitsInt64_$ctestBit_info:
         const GHC.Int.$fBitsInt64_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4v3I() //  [R1]
         { []
         }
     {offset
       c4v3I: // global
           I64[Sp] = block_c4v3O_info;
           _s4lta::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lta::I64;
           if (R1 & 7 != 0) goto u4v4u; else goto c4v3S;
       u4v4u: // global
           call _c4v3O(R1) args: 0, res: 0, upd: 0;
       c4v3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v3I_info" {
     block_c4v3I_info:
         const _c4v3I;
         const 1;
         const 30;
 },
 _c4v3O() //  [R1]
         { []
         }
     {offset
       c4v3O: // global
           _s4ltc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4ltc::I64, 64)) goto c4v4t; else goto c4v4s;
       c4v4s: // global
           if (I64[Sp + 8] & (1 << _s4ltc::I64) == 0) goto c4v4t; else goto c4v4h;
       c4v4t: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v4h: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v3O_info" {
     block_c4v3O_info:
         const _c4v3O;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.126204878 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateR_closure" {
     GHC.Int.$fBitsInt64_$crotateR_closure:
         const GHC.Int.$fBitsInt64_$crotateR_info;
 },
 GHC.Int.$fBitsInt64_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4v4V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4v4Z; else goto c4v50;
       c4v4Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v50: // global
           I64[Sp - 16] = block_c4v4S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v5T; else goto c4v4T;
       u4v5T: // global
           call _c4v4S(R1) args: 0, res: 0, upd: 0;
       c4v4T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$crotateR_info" {
     GHC.Int.$fBitsInt64_$crotateR_info:
         const GHC.Int.$fBitsInt64_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4v4S() //  [R1]
         { []
         }
     {offset
       c4v4S: // global
           I64[Sp - 8] = block_c4v4Y_info;
           _s4ltl::P64 = R1;
           _s4ltm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4ltm::I64;
           P64[Sp + 8] = _s4ltl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v5S; else goto c4v52;
       u4v5S: // global
           call _c4v4Y(R1) args: 0, res: 0, upd: 0;
       c4v52: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v4S_info" {
     block_c4v4S_info:
         const _c4v4S;
         const 1;
         const 30;
 },
 _c4v4Y() //  [R1]
         { []
         }
     {offset
       c4v4Y: // global
           _s4lts::I64 = -I64[R1 + 7] & 63;
           if (_s4lts::I64 != 0) goto u4v5Q; else goto c4v5M;
       u4v5Q: // global
           I64[Sp + 16] = _s4lts::I64;
           Sp = Sp + 8;
           call _c4v5k() args: 0, res: 0, upd: 0;
       c4v5M: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v4Y_info" {
     block_c4v4Y_info:
         const _c4v4Y;
         const 66;
         const 30;
 },
 _c4v5k() //  []
         { []
         }
     {offset
       c4v5k: // global
           Hp = Hp + 16;
           _s4lts::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4v5J; else goto c4v5I;
       c4v5J: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4v5j_info;
           R1 = _s4lts::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4v5I: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4ltt::I64 = I64[Sp];
           I64[Hp] = (_s4ltt::I64 << _s4lts::I64) | (_s4ltt::I64 >> 64 - _s4lts::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4v5j() //  [R1]
         { []
         }
     {offset
       c4v5j: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4v5k() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4v5j_info" {
     block_c4v5j_info:
         const _c4v5j;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.144526735 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt64_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt64_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt64_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4v6u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4v6y; else goto c4v6z;
       c4v6y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v6z: // global
           I64[Sp - 16] = block_c4v6r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v75; else goto c4v6s;
       u4v75: // global
           call _c4v6r(R1) args: 0, res: 0, upd: 0;
       c4v6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$ccomplementBit_info" {
     GHC.Int.$fBitsInt64_$ccomplementBit_info:
         const GHC.Int.$fBitsInt64_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4v6r() //  [R1]
         { []
         }
     {offset
       c4v6r: // global
           I64[Sp - 8] = block_c4v6x_info;
           _s4ltB::P64 = R1;
           _s4ltC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4ltC::I64;
           P64[Sp + 8] = _s4ltB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v74; else goto c4v6B;
       u4v74: // global
           call _c4v6x(R1) args: 0, res: 0, upd: 0;
       c4v6B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v6r_info" {
     block_c4v6r_info:
         const _c4v6r;
         const 1;
         const 30;
 },
 _c4v6x() //  [R1]
         { []
         }
     {offset
       c4v6x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4v6H; else goto c4v6G;
       c4v6H: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4v6G: // global
           _s4ltE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4ltE::I64, 64)) goto c4v72; else goto c4v73;
       c4v72: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s4ltE::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v73: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v6x_info" {
     block_c4v6x_info:
         const _c4v6x;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.158738369 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cclearBit_closure" {
     GHC.Int.$fBitsInt64_$cclearBit_closure:
         const GHC.Int.$fBitsInt64_$cclearBit_info;
 },
 GHC.Int.$fBitsInt64_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4v7w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4v7A; else goto c4v7B;
       c4v7A: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v7B: // global
           I64[Sp - 16] = block_c4v7t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v8l; else goto c4v7u;
       u4v8l: // global
           call _c4v7t(R1) args: 0, res: 0, upd: 0;
       c4v7u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cclearBit_info" {
     GHC.Int.$fBitsInt64_$cclearBit_info:
         const GHC.Int.$fBitsInt64_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4v7t() //  [R1]
         { []
         }
     {offset
       c4v7t: // global
           I64[Sp] = block_c4v7z_info;
           _s4ltO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ltO::I64;
           if (R1 & 7 != 0) goto u4v8k; else goto c4v7D;
       u4v8k: // global
           call _c4v7z(R1) args: 0, res: 0, upd: 0;
       c4v7D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v7t_info" {
     block_c4v7t_info:
         const _c4v7t;
         const 1;
         const 30;
 },
 _c4v7z() //  [R1]
         { []
         }
     {offset
       c4v7z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4v7J; else goto c4v7I;
       c4v7J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4v7I: // global
           _s4ltO::I64 = I64[Sp + 8];
           _s4ltQ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4ltQ::I64, 64)) goto c4v87; else goto c4v8j;
       c4v87: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4ltO::I64 & (1 << _s4ltQ::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v8j: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4ltO::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v7z_info" {
     block_c4v7z_info:
         const _c4v7z;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.173471209 UTC

[section ""data" . GHC.Int.$fBitsInt64_$csetBit_closure" {
     GHC.Int.$fBitsInt64_$csetBit_closure:
         const GHC.Int.$fBitsInt64_$csetBit_info;
 },
 GHC.Int.$fBitsInt64_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4v8P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4v8T; else goto c4v8U;
       c4v8T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4v8U: // global
           I64[Sp - 16] = block_c4v8M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4v9q; else goto c4v8N;
       u4v9q: // global
           call _c4v8M(R1) args: 0, res: 0, upd: 0;
       c4v8N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$csetBit_info" {
     GHC.Int.$fBitsInt64_$csetBit_info:
         const GHC.Int.$fBitsInt64_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4v8M() //  [R1]
         { []
         }
     {offset
       c4v8M: // global
           I64[Sp - 8] = block_c4v8S_info;
           _s4lu3::P64 = R1;
           _s4lu4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4lu4::I64;
           P64[Sp + 8] = _s4lu3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4v9p; else goto c4v8W;
       u4v9p: // global
           call _c4v8S(R1) args: 0, res: 0, upd: 0;
       c4v8W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v8M_info" {
     block_c4v8M_info:
         const _c4v8M;
         const 1;
         const 30;
 },
 _c4v8S() //  [R1]
         { []
         }
     {offset
       c4v8S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4v92; else goto c4v91;
       c4v92: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4v91: // global
           _s4lu6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4lu6::I64, 64)) goto c4v9n; else goto c4v9o;
       c4v9n: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s4lu6::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4v9o: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4v8S_info" {
     block_c4v8S_info:
         const _c4v8S;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.185338688 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateL_closure" {
     GHC.Int.$fBitsInt64_$crotateL_closure:
         const GHC.Int.$fBitsInt64_$crotateL_info;
 },
 GHC.Int.$fBitsInt64_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4v9O: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt64_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$crotateL_info" {
     GHC.Int.$fBitsInt64_$crotateL_info:
         const GHC.Int.$fBitsInt64_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.19065573 UTC

[section ""data" . GHC.Int.$fBitsInt64_closure" {
     GHC.Int.$fBitsInt64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fBitsInt64_$c.&._closure+2;
         const GHC.Int.$fBitsInt64_$c.|._closure+2;
         const GHC.Int.$fBitsInt64_$cxor_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt64_$cshift_closure+2;
         const GHC.Int.$fBitsInt64_$crotate_closure+2;
         const GHC.Int.$fBitsInt10_closure+1;
         const GHC.Int.$fBitsInt64_$cbit_closure+1;
         const GHC.Int.$fBitsInt64_$csetBit_closure+2;
         const GHC.Int.$fBitsInt64_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt64_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt64_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt64_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt64_$crotateL_closure+2;
         const GHC.Int.$fBitsInt64_$crotateR_closure+2;
         const GHC.Int.$fBitsInt64_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.194893902 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_closure" {
     GHC.Int.$fFiniteBitsInt64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt64_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.202367679 UTC

[section ""data" . GHC.Int.$fReadInt64_go_closure" {
     GHC.Int.$fReadInt64_go_closure:
         const GHC.Int.$fReadInt64_go_info;
 },
 sat_s4luo_entry() //  [R1]
         { []
         }
     {offset
       c4vag: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vah; else goto c4vai;
       c4vah: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vai: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4luo_info" {
     sat_s4luo_info:
         const sat_s4luo_entry;
         const 1;
         const 16;
 },
 sat_s4lum_entry() //  [R1]
         { []
         }
     {offset
       c4vaq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4vau; else goto c4vav;
       c4vau: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vav: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4van_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4vaz; else goto c4vao;
       u4vaz: // global
           call _c4van(R1) args: 0, res: 0, upd: 0;
       c4vao: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4lum_info" {
     sat_s4lum_info:
         const sat_s4lum_entry;
         const 1;
         const 16;
 },
 _c4van() //  [R1]
         { []
         }
     {offset
       c4van: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vay; else goto c4vax;
       c4vay: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4vax: // global
           _s4lul::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lul::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4van_info" {
     block_c4van_info:
         const _c4van;
         const 0;
         const 30;
 },
 GHC.Int.$fReadInt64_go_entry() //  [R2]
         { []
         }
     {offset
       c4vaE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vaF; else goto c4vaG;
       c4vaF: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vaG: // global
           I64[Sp - 8] = block_c4va1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vaQ; else goto c4va2;
       u4vaQ: // global
           call _c4va1(R1) args: 0, res: 0, upd: 0;
       c4va2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt64_go_info" {
     GHC.Int.$fReadInt64_go_info:
         const GHC.Int.$fReadInt64_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4va1() //  [R1]
         { []
         }
     {offset
       c4va1: // global
           if (R1 & 7 == 1) goto c4vaB; else goto c4vaC;
       c4vaB: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4vaC: // global
           I64[Sp - 8] = block_c4va7_info;
           _s4lug::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4lug::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vaP; else goto c4va8;
       u4vaP: // global
           call _c4va7(R1) args: 0, res: 0, upd: 0;
       c4va8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4va1_info" {
     block_c4va1_info:
         const _c4va1;
         const 0;
         const 30;
 },
 _c4va7() //  [R1]
         { []
         }
     {offset
       c4va7: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4vaO; else goto c4vaN;
       c4vaO: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vaN: // global
           _s4lui::P64 = P64[R1 + 7];
           _s4luj::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4luo_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4lum_info;
           P64[Hp - 48] = _s4lui::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4luj::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4va7_info" {
     block_c4va7_info:
         const _c4va7;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.223946615 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadsPrec_closure" {
     GHC.Int.$fReadInt64_$creadsPrec_closure:
         const GHC.Int.$fReadInt64_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vbv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vbz; else goto c4vbA;
       c4vbz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vbA: // global
           I64[Sp - 16] = block_c4vbt_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4luq::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4luq::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt64_$creadsPrec_info" {
     GHC.Int.$fReadInt64_$creadsPrec_info:
         const GHC.Int.$fReadInt64_$creadsPrec_entry;
         const 0;
         const 144115200960757774;
         const 8589934607;
         const S4lDl_srt+848;
 },
 _c4vbt() //  [R1]
         { []
         }
     {offset
       c4vbt: // global
           _s4luq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4vby_info;
           R3 = _s4luq::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vbt_info" {
     block_c4vbt_info:
         const _c4vbt;
         const 1;
         const 30;
 },
 _c4vby() //  [R1]
         { []
         }
     {offset
       c4vby: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vby_info" {
     block_c4vby_info:
         const _c4vby;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.232197223 UTC

[section ""data" . GHC.Int.$fReadInt10_closure" {
     GHC.Int.$fReadInt10_closure:
         const GHC.Int.$fReadInt10_info;
         const 0;
 },
 sat_s4luv_entry() //  [R1, R2]
         { []
         }
     {offset
       c4vc0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt64_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s4luv_info" {
     sat_s4luv_info:
         const sat_s4luv_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S4lDl_srt+1048;
 },
 GHC.Int.$fReadInt10_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vc6: // global
           _s4luu::P64 = R3;
           _s4lut::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4vc7; else goto c4vc8;
       c4vc8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vca; else goto c4vc9;
       c4vca: // global
           HpAlloc = 16;
           goto c4vc7;
       c4vc7: // global
           R3 = _s4luu::P64;
           R2 = _s4lut::P64;
           R1 = GHC.Int.$fReadInt10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vc9: // global
           I64[Hp - 8] = sat_s4luv_info;
           P64[Hp] = _s4lut::P64;
           I64[Sp - 8] = block_c4vc3_info;
           R3 = _s4luu::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt10_info" {
     GHC.Int.$fReadInt10_info:
         const GHC.Int.$fReadInt10_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+1048;
 },
 _c4vc3() //  [R1]
         { []
         }
     {offset
       c4vc3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vcd; else goto c4vcc;
       c4vcd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vcc: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vc3_info" {
     block_c4vc3_info:
         const _c4vc3;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.240290044 UTC

[section ""data" . GHC.Int.$fReadInt9_closure" {
     GHC.Int.$fReadInt9_closure:
         const GHC.Int.$fReadInt9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4vcz_srtd" {
     u4vcz_srtd:
         const S4lDl_srt+504;
         const 70;
         const 1;
         const 32;
 },
 GHC.Int.$fReadInt9_entry() //  [R1]
         { []
         }
     {offset
       c4vcw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4vcx; else goto c4vcy;
       c4vcx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4vcy: // global
           (_c4vct::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4vct::I64 == 0) goto c4vcv; else goto c4vcu;
       c4vcv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4vcu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4vct::I64;
           R2 = GHC.Int.$fReadInt10_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt9_info" {
     GHC.Int.$fReadInt9_info:
         const GHC.Int.$fReadInt9_entry;
         const 0;
         const 18446744069414584341;
         const u4vcz_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.24849839 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadList_closure" {
     GHC.Int.$fReadInt64_$creadList_closure:
         const GHC.Int.$fReadInt64_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadList_entry() //  [R2]
         { []
         }
     {offset
       c4vcM: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt9_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt64_$creadList_info" {
     GHC.Int.$fReadInt64_$creadList_info:
         const GHC.Int.$fReadInt64_$creadList_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S4lDl_srt+1064;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.253643039 UTC

[section ""data" . GHC.Int.$fReadInt7_closure" {
     GHC.Int.$fReadInt7_closure:
         const GHC.Int.$fReadInt7_info;
         const 0;
 },
 GHC.Int.$fReadInt7_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vd0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vd1; else goto c4vd2;
       c4vd1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vd2: // global
           I64[Sp - 8] = block_c4vcX_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt64_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt7_info" {
     GHC.Int.$fReadInt7_info:
         const GHC.Int.$fReadInt7_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+1072;
 },
 _c4vcX() //  [R1]
         { []
         }
     {offset
       c4vcX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vd5; else goto c4vd4;
       c4vd5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vd4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vcX_info" {
     block_c4vcX_info:
         const _c4vcX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.259004973 UTC

[section ""data" . GHC.Int.$fReadInt64_closure" {
     GHC.Int.$fReadInt64_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt64_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt64_$creadList_closure+1;
         const GHC.Int.$fReadInt10_closure+2;
         const GHC.Int.$fReadInt7_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.26302727 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquot_closure" {
     GHC.Int.$fIntegralInt64_$cquot_closure:
         const GHC.Int.$fIntegralInt64_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vdn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vdr; else goto c4vds;
       c4vdr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vds: // global
           I64[Sp - 16] = block_c4vdk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vdX; else goto c4vdl;
       u4vdX: // global
           call _c4vdk(R1) args: 0, res: 0, upd: 0;
       c4vdl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$cquot_info" {
     GHC.Int.$fIntegralInt64_$cquot_info:
         const GHC.Int.$fIntegralInt64_$cquot_entry;
         const 0;
         const 36028809903865870;
         const 8589934607;
         const S4lDl_srt+904;
 },
 _c4vdk() //  [R1]
         { []
         }
     {offset
       c4vdk: // global
           I64[Sp] = block_c4vdq_info;
           _s4luF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4luF::I64;
           if (R1 & 7 != 0) goto u4vdW; else goto c4vdu;
       u4vdW: // global
           call _c4vdq(R1) args: 0, res: 0, upd: 0;
       c4vdu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vdk_info" {
     block_c4vdk_info:
         const _c4vdk;
         const 1;
         const 12884901918;
         const S4lDl_srt+904;
 },
 _c4vdq() //  [R1]
         { []
         }
     {offset
       c4vdq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vdA; else goto c4vdz;
       c4vdA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vdz: // global
           _s4luF::I64 = I64[Sp + 8];
           _s4luI::I64 = I64[R1 + 7];
           if (_s4luI::I64 != (-1)) goto u4vdV; else goto c4vdT;
       u4vdV: // global
           if (_s4luI::I64 != 0) goto c4vdI; else goto c4vdU;
       c4vdI: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4luF::I64, _s4luI::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4vdU: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vdT: // global
           if (_s4luF::I64 == (-9223372036854775808)) goto c4vdS; else goto c4vdR;
       c4vdS: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vdR: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4luF::I64, (-1));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vdq_info" {
     block_c4vdq_info:
         const _c4vdq;
         const 65;
         const 12884901918;
         const S4lDl_srt+904;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.273456872 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$crem_closure" {
     GHC.Int.$fIntegralInt64_$crem_closure:
         const GHC.Int.$fIntegralInt64_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4veo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ves; else goto c4vet;
       c4ves: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vet: // global
           I64[Sp - 16] = block_c4vel_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4veO; else goto c4vem;
       u4veO: // global
           call _c4vel(R1) args: 0, res: 0, upd: 0;
       c4vem: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$crem_info" {
     GHC.Int.$fIntegralInt64_$crem_info:
         const GHC.Int.$fIntegralInt64_$crem_entry;
         const 0;
         const 36028801313931278;
         const 8589934607;
         const S4lDl_srt+912;
 },
 _c4vel() //  [R1]
         { []
         }
     {offset
       c4vel: // global
           I64[Sp] = block_c4ver_info;
           _s4luR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4luR::I64;
           if (R1 & 7 != 0) goto u4veN; else goto c4vev;
       u4veN: // global
           call _c4ver(R1) args: 0, res: 0, upd: 0;
       c4vev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vel_info" {
     block_c4vel_info:
         const _c4vel;
         const 1;
         const 4294967326;
         const S4lDl_srt+912;
 },
 _c4ver() //  [R1]
         { []
         }
     {offset
       c4ver: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4veB; else goto c4veA;
       c4veB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4veA: // global
           _s4luU::I64 = I64[R1 + 7];
           if (_s4luU::I64 != (-1)) goto u4veM; else goto c4veK;
       u4veM: // global
           if (_s4luU::I64 != 0) goto c4veJ; else goto c4veL;
       c4veJ: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Rem_W64(I64[Sp + 8], _s4luU::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4veL: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4veK: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ver_info" {
     block_c4ver_info:
         const _c4ver;
         const 65;
         const 4294967326;
         const S4lDl_srt+912;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.282469986 UTC

[section ""data" . GHC.Int.$w$cdiv2_closure" {
     GHC.Int.$w$cdiv2_closure:
         const GHC.Int.$w$cdiv2_info;
         const 0;
 },
 GHC.Int.$w$cdiv2_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vfe: // global
           if (R3 == (-1)) goto c4vfc; else goto u4vfn;
       c4vfc: // global
           if (R2 == (-9223372036854775808)) goto c4vfm; else goto c4vfl;
       c4vfm: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vfl: // global
           R3 = (-1);
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
       u4vfn: // global
           if (R3 == 0) goto c4vfd; else goto c4vfb;
       c4vfd: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vfb: // global
           R3 = R3;
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdiv2_info" {
     GHC.Int.$w$cdiv2_info:
         const GHC.Int.$w$cdiv2_entry;
         const 0;
         const 12884901902;
         const 8589934604;
         const S4lDl_srt+904;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.288397349 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdiv_closure" {
     GHC.Int.$fIntegralInt64_$cdiv_closure:
         const GHC.Int.$fIntegralInt64_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vfA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vfN; else goto c4vfO;
       c4vfN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vfO: // global
           I64[Sp - 16] = block_c4vfx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vfV; else goto c4vfy;
       u4vfV: // global
           call _c4vfx(R1) args: 0, res: 0, upd: 0;
       c4vfy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$cdiv_info" {
     GHC.Int.$fIntegralInt64_$cdiv_info:
         const GHC.Int.$fIntegralInt64_$cdiv_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+1104;
 },
 _c4vfx() //  [R1]
         { []
         }
     {offset
       c4vfx: // global
           I64[Sp] = block_c4vfD_info;
           _s4lv5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lv5::I64;
           if (R1 & 7 != 0) goto u4vfU; else goto c4vfE;
       u4vfU: // global
           call _c4vfD(R1) args: 0, res: 0, upd: 0;
       c4vfE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vfx_info" {
     block_c4vfx_info:
         const _c4vfx;
         const 1;
         const 4294967326;
         const S4lDl_srt+1112;
 },
 _c4vfD() //  [R1]
         { []
         }
     {offset
       c4vfD: // global
           _s4lv5::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4vfI_info;
           R3 = I64[R1 + 7];
           R2 = _s4lv5::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vfD_info" {
     block_c4vfD_info:
         const _c4vfD;
         const 65;
         const 4294967326;
         const S4lDl_srt+1112;
 },
 _c4vfI() //  [R1]
         { []
         }
     {offset
       c4vfI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vfT; else goto c4vfS;
       c4vfT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4vfS: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vfI_info" {
     block_c4vfI_info:
         const _c4vfI;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.299205782 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cmod_closure" {
     GHC.Int.$fIntegralInt64_$cmod_closure:
         const GHC.Int.$fIntegralInt64_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cmod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vgk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vgo; else goto c4vgp;
       c4vgo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vgp: // global
           I64[Sp - 16] = block_c4vgh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vgM; else goto c4vgi;
       u4vgM: // global
           call _c4vgh(R1) args: 0, res: 0, upd: 0;
       c4vgi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$cmod_info" {
     GHC.Int.$fIntegralInt64_$cmod_info:
         const GHC.Int.$fIntegralInt64_$cmod_entry;
         const 0;
         const 288230380446679054;
         const 8589934607;
         const S4lDl_srt+912;
 },
 _c4vgh() //  [R1]
         { []
         }
     {offset
       c4vgh: // global
           I64[Sp] = block_c4vgn_info;
           _s4lvc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lvc::I64;
           if (R1 & 7 != 0) goto u4vgL; else goto c4vgr;
       u4vgL: // global
           call _c4vgn(R1) args: 0, res: 0, upd: 0;
       c4vgr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vgh_info" {
     block_c4vgh_info:
         const _c4vgh;
         const 1;
         const 4294967326;
         const S4lDl_srt+912;
 },
 _c4vgn() //  [R1]
         { []
         }
     {offset
       c4vgn: // global
           _s4lvf::I64 = I64[R1 + 7];
           if (_s4lvf::I64 != (-1)) goto u4vgK; else goto c4vgI;
       u4vgK: // global
           if (_s4lvf::I64 != 0) goto c4vgE; else goto c4vgJ;
       c4vgE: // global
           _s4lvc::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4vgy_info;
           R3 = _s4lvf::I64;
           R2 = _s4lvc::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4vgJ: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vgI: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vgn_info" {
     block_c4vgn_info:
         const _c4vgn;
         const 65;
         const 4294967326;
         const S4lDl_srt+912;
 },
 _c4vgy() //  [R1]
         { []
         }
     {offset
       c4vgy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vgH; else goto c4vgG;
       c4vgH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4vgG: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vgy_info" {
     block_c4vgy_info:
         const _c4vgy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.312394655 UTC

[section ""data" . lvl9_r4kPA_closure" {
     lvl9_r4kPA_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt10_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.318690051 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquotRem_closure" {
     GHC.Int.$fIntegralInt64_$cquotRem_closure:
         const GHC.Int.$fIntegralInt64_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vhd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vhh; else goto c4vhi;
       c4vhh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vhi: // global
           I64[Sp - 16] = block_c4vha_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vhL; else goto c4vhb;
       u4vhL: // global
           call _c4vha(R1) args: 0, res: 0, upd: 0;
       c4vhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$cquotRem_info" {
     GHC.Int.$fIntegralInt64_$cquotRem_info:
         const GHC.Int.$fIntegralInt64_$cquotRem_entry;
         const 0;
         const 1729382261205237774;
         const 8589934607;
         const S4lDl_srt+912;
 },
 _c4vha() //  [R1]
         { []
         }
     {offset
       c4vha: // global
           I64[Sp] = block_c4vhg_info;
           _s4lvl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lvl::I64;
           if (R1 & 7 != 0) goto u4vhK; else goto c4vhk;
       u4vhK: // global
           call _c4vhg(R1) args: 0, res: 0, upd: 0;
       c4vhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vha_info" {
     block_c4vha_info:
         const _c4vha;
         const 1;
         const 1152921508901814302;
         const S4lDl_srt+912;
 },
 _c4vhg() //  [R1]
         { []
         }
     {offset
       c4vhg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4vhq; else goto c4vhp;
       c4vhq: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vhp: // global
           _s4lvl::I64 = I64[Sp + 8];
           _s4lvo::I64 = I64[R1 + 7];
           if (_s4lvo::I64 != (-1)) goto u4vhJ; else goto c4vhH;
       u4vhJ: // global
           if (_s4lvo::I64 != 0) goto c4vhx; else goto c4vhI;
       c4vhx: // global
           (_s4lvq::I64, _s4lvr::I64) = call MO_S_QuotRem W64(_s4lvl::I64, _s4lvo::I64);
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4lvr::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4lvq::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4vhI: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vhH: // global
           if (_s4lvl::I64 == (-9223372036854775808)) goto c4vhG; else goto c4vhF;
       c4vhG: // global
           Hp = Hp - 56;
           R1 = lvl9_r4kPA_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4vhF: // global
           (_s4lvw::I64, _s4lvx::I64) = call MO_S_QuotRem W64(_s4lvl::I64, (-1));
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4lvx::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4lvw::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vhg_info" {
     block_c4vhg_info:
         const _c4vhg;
         const 65;
         const 1152921508901814302;
         const S4lDl_srt+912;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.337213852 UTC

[section ""data" . GHC.Int.$w$cdivMod2_closure" {
     GHC.Int.$w$cdivMod2_closure:
         const GHC.Int.$w$cdivMod2_info;
         const 0;
 },
 GHC.Int.$w$cdivMod2_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vig: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4vih; else goto c4vii;
       c4vih: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vii: // global
           if (R3 == 0) goto c4vif; else goto c4vie;
       c4vif: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4vie: // global
           if (R3 == (-1)) goto c4vk5; else goto u4vk6;
       c4vk5: // global
           if (R2 == (-9223372036854775808)) goto c4vk4; else goto u4vk7;
       c4vk4: // global
           R2 = GHC.Int.$fBitsInt10_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4vk7: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4vk9;
       u4vk6: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4vk9;
       u4vk9: // global
           call _c4vin() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdivMod2_info" {
     GHC.Int.$w$cdivMod2_info:
         const GHC.Int.$w$cdivMod2_entry;
         const 0;
         const 4611686031312289806;
         const 8589934604;
         const S4lDl_srt+904;
 },
 _c4vin() //  []
         { []
         }
     {offset
       c4vin: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4vir; else goto c4viq;
       c4vir: // global
           HpAlloc = 32;
           I64[Sp] = block_c4vin_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4viq: // global
           _s4lvB::I64 = I64[Sp + 8];
           _s4lvD::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4lvB::I64, 0)) goto c4vj2; else goto c4vjV;
       c4vj2: // global
           if (%MO_S_Ge_W64(_s4lvB::I64, 0)) goto c4viB; else goto c4vj0;
       c4viB: // global
           (_s4lvI::I64, _s4lvJ::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvJ::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvI::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vj0: // global
           if (%MO_S_Le_W64(_s4lvD::I64, 0)) goto c4viJ; else goto c4viZ;
       c4viJ: // global
           (_s4lvO::I64, _s4lvP::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvP::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvO::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4viZ: // global
           (_s4lvU::I64, _s4lvV::I64) = call MO_S_QuotRem W64(_s4lvB::I64 + 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lvV::I64 + _s4lvD::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lvU::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vjV: // global
           if (%MO_S_Ge_W64(_s4lvD::I64, 0)) goto c4vjE; else goto c4vjU;
       c4vjE: // global
           if (%MO_S_Ge_W64(_s4lvB::I64, 0)) goto c4vjd; else goto c4vjC;
       c4vjd: // global
           (_s4lw4::I64, _s4lw5::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lw5::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lw4::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vjC: // global
           if (%MO_S_Le_W64(_s4lvD::I64, 0)) goto c4vjl; else goto c4vjB;
       c4vjl: // global
           (_s4lwa::I64, _s4lwb::I64) = call MO_S_QuotRem W64(_s4lvB::I64, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwb::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwa::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vjB: // global
           (_s4lwg::I64, _s4lwh::I64) = call MO_S_QuotRem W64(_s4lvB::I64 + 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwh::I64 + _s4lvD::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwg::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4vjU: // global
           (_s4lwp::I64, _s4lwq::I64) = call MO_S_QuotRem W64(_s4lvB::I64 - 1, _s4lvD::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4lwq::I64 + _s4lvD::I64 + 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4lwp::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vin_info" {
     block_c4vin_info:
         const _c4vin;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.352874442 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdivMod_closure" {
     GHC.Int.$fIntegralInt64_$cdivMod_closure:
         const GHC.Int.$fIntegralInt64_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vkK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vkV; else goto c4vkW;
       c4vkV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vkW: // global
           I64[Sp - 16] = block_c4vkH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vl3; else goto c4vkI;
       u4vl3: // global
           call _c4vkH(R1) args: 0, res: 0, upd: 0;
       c4vkI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$cdivMod_info" {
     GHC.Int.$fIntegralInt64_$cdivMod_info:
         const GHC.Int.$fIntegralInt64_$cdivMod_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4lDl_srt+1144;
 },
 _c4vkH() //  [R1]
         { []
         }
     {offset
       c4vkH: // global
           I64[Sp] = block_c4vkN_info;
           _s4lwC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lwC::I64;
           if (R1 & 7 != 0) goto u4vl2; else goto c4vkO;
       u4vl2: // global
           call _c4vkN(R1) args: 0, res: 0, upd: 0;
       c4vkO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vkH_info" {
     block_c4vkH_info:
         const _c4vkH;
         const 1;
         const 4294967326;
         const S4lDl_srt+1144;
 },
 _c4vkN() //  [R1]
         { []
         }
     {offset
       c4vkN: // global
           _s4lwC::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4vkS_info;
           R3 = I64[R1 + 7];
           R2 = _s4lwC::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vkN_info" {
     block_c4vkN_info:
         const _c4vkN;
         const 65;
         const 4294967326;
         const S4lDl_srt+1144;
 },
 _c4vkS() //  [R1, R2]
         { []
         }
     {offset
       c4vkS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4vl1; else goto c4vl0;
       c4vl1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4vl0: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vkS_info" {
     block_c4vkS_info:
         const _c4vkS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.366972372 UTC

[section ""data" . GHC.Int.$fIxInt64_$crange_closure" {
     GHC.Int.$fIxInt64_$crange_closure:
         const GHC.Int.$fIxInt64_$crange_info;
 },
 GHC.Int.$fIxInt64_$crange_entry() //  [R2]
         { []
         }
     {offset
       c4vls: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vlt; else goto c4vlu;
       c4vlt: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vlu: // global
           I64[Sp - 8] = block_c4vlp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vly; else goto c4vlq;
       u4vly: // global
           call _c4vlp(R1) args: 0, res: 0, upd: 0;
       c4vlq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$crange_info" {
     GHC.Int.$fIxInt64_$crange_info:
         const GHC.Int.$fIxInt64_$crange_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4vlp() //  [R1]
         { []
         }
     {offset
       c4vlp: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vlp_info" {
     block_c4vlp_info:
         const _c4vlp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.373871732 UTC

[section ""data" . GHC.Int.$fRealInt64_$ctoRational_closure" {
     GHC.Int.$fRealInt64_$ctoRational_closure:
         const GHC.Int.$fRealInt64_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt64_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c4vlP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vm3; else goto c4vm4;
       c4vm3: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vm4: // global
           I64[Sp - 8] = block_c4vlM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vmb; else goto c4vlN;
       u4vmb: // global
           call _c4vlM(R1) args: 0, res: 0, upd: 0;
       c4vlN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fRealInt64_$ctoRational_info" {
     GHC.Int.$fRealInt64_$ctoRational_info:
         const GHC.Int.$fRealInt64_$ctoRational_entry;
         const 0;
         const 9007229319512078;
         const 4294967301;
         const S4lDl_srt+992;
 },
 _c4vlM() //  [R1]
         { []
         }
     {offset
       c4vlM: // global
           I64[Sp] = block_c4vlS_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vlM_info" {
     block_c4vlM_info:
         const _c4vlM;
         const 0;
         const 30064771102;
         const S4lDl_srt+992;
 },
 _c4vlS() //  [R1]
         { []
         }
     {offset
       c4vlS: // global
           I64[Sp] = block_c4vlW_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vlS_info" {
     block_c4vlS_info:
         const _c4vlS;
         const 0;
         const 30064771102;
         const S4lDl_srt+992;
 },
 _c4vlW() //  [R1]
         { []
         }
     {offset
       c4vlW: // global
           I64[Sp] = block_c4vm0_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vlW_info" {
     block_c4vlW_info:
         const _c4vlW;
         const 0;
         const 12884901918;
         const S4lDl_srt+992;
 },
 _c4vm0() //  [R1, R2]
         { []
         }
     {offset
       c4vm0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4vma; else goto c4vm9;
       c4vma: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4vm9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vm0_info" {
     block_c4vm0_info:
         const _c4vm0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.384944367 UTC

[section ""data" . GHC.Int.$fRealInt64_closure" {
     GHC.Int.$fRealInt64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt64_closure+1;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fRealInt64_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.387840327 UTC

[section ""data" . GHC.Int.$fIntegralInt64_closure" {
     GHC.Int.$fIntegralInt64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt64_closure+1;
         const GHC.Int.$fEnumInt64_closure+1;
         const GHC.Int.$fIntegralInt64_$cquot_closure+2;
         const GHC.Int.$fIntegralInt64_$crem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt64_$cmod_closure+2;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt64_$ctoInteger_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.393443918 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt64_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt64_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt64_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vmE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vmV; else goto c4vmW;
       c4vmV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vmW: // global
           I64[Sp - 16] = block_c4vmB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vn3; else goto c4vmC;
       u4vn3: // global
           call _c4vmB(R1) args: 0, res: 0, upd: 0;
       c4vmC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$cunsafeIndex_info" {
     GHC.Int.$fIxInt64_$cunsafeIndex_info:
         const GHC.Int.$fIxInt64_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4vmB() //  [R1]
         { []
         }
     {offset
       c4vmB: // global
           I64[Sp] = block_c4vmH_info;
           _s4lwX::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4lwX::P64;
           if (R1 & 7 != 0) goto u4vn2; else goto c4vmI;
       u4vn2: // global
           call _c4vmH(R1) args: 0, res: 0, upd: 0;
       c4vmI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vmB_info" {
     block_c4vmB_info:
         const _c4vmB;
         const 1;
         const 30;
 },
 _c4vmH() //  [R1]
         { []
         }
     {offset
       c4vmH: // global
           I64[Sp] = block_c4vmM_info;
           _s4lx0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lx0::I64;
           if (R1 & 7 != 0) goto u4vn4; else goto c4vmN;
       u4vn4: // global
           call _c4vmM(R1) args: 0, res: 0, upd: 0;
       c4vmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vmH_info" {
     block_c4vmH_info:
         const _c4vmH;
         const 1;
         const 30;
 },
 _c4vmM() //  [R1]
         { []
         }
     {offset
       c4vmM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vn1; else goto c4vn0;
       c4vn1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vn0: // global
           _s4lx3::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lx3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vmM_info" {
     block_c4vmM_info:
         const _c4vmM;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.407420342 UTC

[section ""data" . GHC.Int.$fIxInt64_$crangeSize_closure" {
     GHC.Int.$fIxInt64_$crangeSize_closure:
         const GHC.Int.$fIxInt64_$crangeSize_info;
 },
 GHC.Int.$fIxInt64_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4vnw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vnF; else goto c4vnG;
       c4vnF: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vnG: // global
           I64[Sp - 8] = block_c4vnt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vo5; else goto c4vnu;
       u4vo5: // global
           call _c4vnt(R1) args: 0, res: 0, upd: 0;
       c4vnu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$crangeSize_info" {
     GHC.Int.$fIxInt64_$crangeSize_info:
         const GHC.Int.$fIxInt64_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4vnt() //  [R1]
         { []
         }
     {offset
       c4vnt: // global
           I64[Sp - 8] = block_c4vnz_info;
           _s4lx7::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lx7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vo4; else goto c4vnA;
       u4vo4: // global
           call _c4vnz(R1) args: 0, res: 0, upd: 0;
       c4vnA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vnt_info" {
     block_c4vnt_info:
         const _c4vnt;
         const 0;
         const 30;
 },
 _c4vnz() //  [R1]
         { []
         }
     {offset
       c4vnz: // global
           I64[Sp] = block_c4vnE_info;
           _s4lx9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lx9::I64;
           if (R1 & 7 != 0) goto u4vo6; else goto c4vnJ;
       u4vo6: // global
           call _c4vnE(R1) args: 0, res: 0, upd: 0;
       c4vnJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vnz_info" {
     block_c4vnz_info:
         const _c4vnz;
         const 1;
         const 30;
 },
 _c4vnE() //  [R1]
         { []
         }
     {offset
       c4vnE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vnP; else goto c4vnO;
       c4vnP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vnO: // global
           _s4lx9::I64 = I64[Sp + 8];
           _s4lxb::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4lx9::I64,
                            _s4lxb::I64)) goto c4vnT; else goto c4vo3;
       c4vnT: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4vo3: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxb::I64 - _s4lx9::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vnE_info" {
     block_c4vnE_info:
         const _c4vnE;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.420365995 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt64_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt64_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4voA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4voU; else goto c4voV;
       c4voU: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4voV: // global
           I64[Sp - 8] = block_c4vox_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vp2; else goto c4voy;
       u4vp2: // global
           call _c4vox(R1) args: 0, res: 0, upd: 0;
       c4voy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$cunsafeRangeSize_info" {
     GHC.Int.$fIxInt64_$cunsafeRangeSize_info:
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4vox() //  [R1]
         { []
         }
     {offset
       c4vox: // global
           I64[Sp - 8] = block_c4voD_info;
           _s4lxh::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4lxh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vp1; else goto c4voE;
       u4vp1: // global
           call _c4voD(R1) args: 0, res: 0, upd: 0;
       c4voE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vox_info" {
     block_c4vox_info:
         const _c4vox;
         const 0;
         const 30;
 },
 _c4voD() //  [R1]
         { []
         }
     {offset
       c4voD: // global
           I64[Sp] = block_c4voI_info;
           _s4lxk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxk::I64;
           if (R1 & 7 != 0) goto u4vp3; else goto c4voJ;
       u4vp3: // global
           call _c4voI(R1) args: 0, res: 0, upd: 0;
       c4voJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4voD_info" {
     block_c4voD_info:
         const _c4voD;
         const 1;
         const 30;
 },
 _c4voI() //  [R1]
         { []
         }
     {offset
       c4voI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vp0; else goto c4voZ;
       c4vp0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4voZ: // global
           _s4lxo::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxo::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4voI_info" {
     block_c4voI_info:
         const _c4voI;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.434510995 UTC

[section ""data" . GHC.Int.$fIxInt64_$cindex_closure" {
     GHC.Int.$fIxInt64_$cindex_closure:
         const GHC.Int.$fIxInt64_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt64_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vpw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4vpF; else goto c4vpG;
       c4vpF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vpG: // global
           I64[Sp - 16] = block_c4vpt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vqf; else goto c4vpu;
       u4vqf: // global
           call _c4vpt(R1) args: 0, res: 0, upd: 0;
       c4vpu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$cindex_info" {
     GHC.Int.$fIxInt64_$cindex_info:
         const GHC.Int.$fIxInt64_$cindex_entry;
         const 0;
         const 281479271677966;
         const 8589934607;
         const S4lDl_srt+1040;
 },
 _c4vpt() //  [R1]
         { []
         }
     {offset
       c4vpt: // global
           I64[Sp - 8] = block_c4vpz_info;
           _s4lxt::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4lxt::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vqe; else goto c4vpA;
       u4vqe: // global
           call _c4vpz(R1) args: 0, res: 0, upd: 0;
       c4vpA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vpt_info" {
     block_c4vpt_info:
         const _c4vpt;
         const 1;
         const 4294967326;
         const S4lDl_srt+1040;
 },
 _c4vpz() //  [R1]
         { []
         }
     {offset
       c4vpz: // global
           I64[Sp] = block_c4vpE_info;
           _s4lxv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4lxv::I64;
           if (R1 & 7 != 0) goto u4vqg; else goto c4vpJ;
       u4vqg: // global
           call _c4vpE(R1) args: 0, res: 0, upd: 0;
       c4vpJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vpz_info" {
     block_c4vpz_info:
         const _c4vpz;
         const 2;
         const 4294967326;
         const S4lDl_srt+1040;
 },
 _c4vpE() //  [R1]
         { []
         }
     {offset
       c4vpE: // global
           _s4lxx::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4lxx::I64)) goto c4vpR; else goto c4vpV;
       c4vpR: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4vpV: // global
           I64[Sp] = block_c4vpU_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxx::I64;
           if (R1 & 7 != 0) goto u4vqh; else goto c4vpW;
       u4vqh: // global
           call _c4vpU(R1) args: 0, res: 0, upd: 0;
       c4vpW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vpE_info" {
     block_c4vpE_info:
         const _c4vpE;
         const 130;
         const 4294967326;
         const S4lDl_srt+1040;
 },
 _c4vpU() //  [R1]
         { []
         }
     {offset
       c4vpU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vq2; else goto c4vq1;
       c4vq2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4vq1: // global
           _s4lxx::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4lxx::I64,
                            I64[R1 + 7])) goto c4vq6; else goto c4vqd;
       c4vq6: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4vqd: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4lxx::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vpU_info" {
     block_c4vpU_info:
         const _c4vpU;
         const 194;
         const 4294967326;
         const S4lDl_srt+1040;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.445349481 UTC

[section ""data" . GHC.Int.$fIxInt64_closure" {
     GHC.Int.$fIxInt64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fIxInt64_$crange_closure+1;
         const GHC.Int.$fIxInt64_$cindex_closure+2;
         const GHC.Int.$fIxInt64_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt64_$cinRange_closure+2;
         const GHC.Int.$fIxInt64_$crangeSize_closure+1;
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.449005373 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowsPrec_closure" {
     GHC.Int.$fShowInt64_$cshowsPrec_closure:
         const GHC.Int.$fShowInt64_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt64_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4vqQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4vr1; else goto c4vr2;
       c4vr1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vr2: // global
           I64[Sp - 24] = block_c4vqN_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4vr9; else goto c4vqO;
       u4vr9: // global
           call _c4vqN(R1) args: 0, res: 0, upd: 0;
       c4vqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt64_$cshowsPrec_info" {
     GHC.Int.$fShowInt64_$cshowsPrec_info:
         const GHC.Int.$fShowInt64_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c4vqN() //  [R1]
         { []
         }
     {offset
       c4vqN: // global
           I64[Sp] = block_c4vqT_info;
           _s4lxH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4lxH::I64;
           if (R1 & 7 != 0) goto u4vr8; else goto c4vqU;
       u4vr8: // global
           call _c4vqT(R1) args: 0, res: 0, upd: 0;
       c4vqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vqN_info" {
     block_c4vqN_info:
         const _c4vqN;
         const 2;
         const 30;
 },
 _c4vqT() //  [R1]
         { []
         }
     {offset
       c4vqT: // global
           _s4lxF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4vqY_info;
           R4 = _s4lxF::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vqT_info" {
     block_c4vqT_info:
         const _c4vqT;
         const 66;
         const 30;
 },
 _c4vqY() //  [R1, R2]
         { []
         }
     {offset
       c4vqY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4vr7; else goto c4vr6;
       c4vr7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4vr6: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vqY_info" {
     block_c4vqY_info:
         const _c4vqY;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.460881623 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshow_closure" {
     GHC.Int.$fShowInt64_$cshow_closure:
         const GHC.Int.$fShowInt64_$cshow_info;
 },
 GHC.Int.$fShowInt64_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c4vry: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4vrE; else goto c4vrF;
       c4vrE: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vrF: // global
           I64[Sp - 8] = block_c4vrv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4vrK; else goto c4vrw;
       u4vrK: // global
           call _c4vrv(R1) args: 0, res: 0, upd: 0;
       c4vrw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt64_$cshow_info" {
     GHC.Int.$fShowInt64_$cshow_info:
         const GHC.Int.$fShowInt64_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4vrv() //  [R1]
         { []
         }
     {offset
       c4vrv: // global
           I64[Sp] = block_c4vrB_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vrv_info" {
     block_c4vrv_info:
         const _c4vrv;
         const 0;
         const 30;
 },
 _c4vrB() //  [R1, R2]
         { []
         }
     {offset
       c4vrB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4vrJ; else goto c4vrI;
       c4vrJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4vrI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vrB_info" {
     block_c4vrB_info:
         const _c4vrB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.470101 UTC

[section ""data" . GHC.Int.$fShowInt3_closure" {
     GHC.Int.$fShowInt3_closure:
         const GHC.Int.$fShowInt3_info;
 },
 GHC.Int.$fShowInt3_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vs5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4vsb; else goto c4vsc;
       c4vsb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4vsc: // global
           I64[Sp - 16] = block_c4vs2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4vsh; else goto c4vs3;
       u4vsh: // global
           call _c4vs2(R1) args: 0, res: 0, upd: 0;
       c4vs3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt3_info" {
     GHC.Int.$fShowInt3_info:
         const GHC.Int.$fShowInt3_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4vs2() //  [R1]
         { []
         }
     {offset
       c4vs2: // global
           _s4lxU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4vs8_info;
           R4 = _s4lxU::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vs2_info" {
     block_c4vs2_info:
         const _c4vs2;
         const 1;
         const 30;
 },
 _c4vs8() //  [R1, R2]
         { []
         }
     {offset
       c4vs8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4vsg; else goto c4vsf;
       c4vsg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4vsf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4vs8_info" {
     block_c4vs8_info:
         const _c4vs8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.478081233 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowList_closure" {
     GHC.Int.$fShowInt64_$cshowList_closure:
         const GHC.Int.$fShowInt64_$cshowList_info;
 },
 GHC.Int.$fShowInt64_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vsz: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt3_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt64_$cshowList_info" {
     GHC.Int.$fShowInt64_$cshowList_info:
         const GHC.Int.$fShowInt64_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.482338534 UTC

[section ""data" . GHC.Int.$fShowInt64_closure" {
     GHC.Int.$fShowInt64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt64_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt64_$cshow_closure+1;
         const GHC.Int.$fShowInt64_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.484758377 UTC

[section ""data" . GHC.Int.uncheckedIShiftL64#_closure" {
     GHC.Int.uncheckedIShiftL64#_closure:
         const GHC.Int.uncheckedIShiftL64#_info;
 },
 GHC.Int.uncheckedIShiftL64#_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vsM: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.uncheckedIShiftL64#_info" {
     GHC.Int.uncheckedIShiftL64#_info:
         const GHC.Int.uncheckedIShiftL64#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.49037866 UTC

[section ""data" . GHC.Int.uncheckedIShiftRA64#_closure" {
     GHC.Int.uncheckedIShiftRA64#_closure:
         const GHC.Int.uncheckedIShiftRA64#_info;
 },
 GHC.Int.uncheckedIShiftRA64#_entry() //  [R2, R3]
         { []
         }
     {offset
       c4vt0: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.uncheckedIShiftRA64#_info" {
     GHC.Int.uncheckedIShiftRA64#_info:
         const GHC.Int.uncheckedIShiftRA64#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.49524306 UTC

[section ""cstring" . GHC.Int.$trModule4_bytes" {
     GHC.Int.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.497059595 UTC

[section ""data" . GHC.Int.$trModule3_closure" {
     GHC.Int.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.498891205 UTC

[section ""cstring" . GHC.Int.$trModule2_bytes" {
     GHC.Int.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.500430743 UTC

[section ""data" . GHC.Int.$trModule1_closure" {
     GHC.Int.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.502176432 UTC

[section ""data" . GHC.Int.$trModule_closure" {
     GHC.Int.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Int.$trModule3_closure+1;
         const GHC.Int.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.503967461 UTC

[section ""data" . $krep_r4kPB_closure" {
     $krep_r4kPB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.505915731 UTC

[section ""data" . GHC.Int.$tcInt7_closure" {
     GHC.Int.$tcInt7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt9_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.507842268 UTC

[section ""data" . GHC.Int.$tcInt8_closure" {
     GHC.Int.$tcInt8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt7_closure+1;
         const GHC.Types.krep$*_closure;
         const 1422706860619545536;
         const 2126344328513082648;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.510226186 UTC

[section ""data" . $krep1_r4kPC_closure" {
     $krep1_r4kPC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.513662475 UTC

[section ""data" . GHC.Int.$tc'I8#1_closure" {
     GHC.Int.$tc'I8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep1_r4kPC_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.51623208 UTC

[section ""cstring" . GHC.Int.$tc'I8#3_bytes" {
     GHC.Int.$tc'I8#3_bytes:
         I8[] [39,73,56,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.518277954 UTC

[section ""data" . GHC.Int.$tc'I8#2_closure" {
     GHC.Int.$tc'I8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I8#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.520159789 UTC

[section ""data" . GHC.Int.$tc'I8#_closure" {
     GHC.Int.$tc'I8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I8#2_closure+1;
         const GHC.Int.$tc'I8#1_closure+4;
         const 5349338056284818619;
         const 13298037281129101406;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.522059435 UTC

[section ""data" . GHC.Int.$tcInt1_closure" {
     GHC.Int.$tcInt1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.523884113 UTC

[section ""data" . GHC.Int.$tcInt16_closure" {
     GHC.Int.$tcInt16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16329117591681623238;
         const 13363230803330610095;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.526339636 UTC

[section ""data" . $krep2_r4kPD_closure" {
     $krep2_r4kPD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.528339344 UTC

[section ""data" . GHC.Int.$tc'I16#1_closure" {
     GHC.Int.$tc'I16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep2_r4kPD_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.53077529 UTC

[section ""cstring" . GHC.Int.$tc'I16#3_bytes" {
     GHC.Int.$tc'I16#3_bytes:
         I8[] [39,73,49,54,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.533000892 UTC

[section ""data" . GHC.Int.$tc'I16#2_closure" {
     GHC.Int.$tc'I16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I16#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.534934513 UTC

[section ""data" . GHC.Int.$tc'I16#_closure" {
     GHC.Int.$tc'I16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I16#2_closure+1;
         const GHC.Int.$tc'I16#1_closure+4;
         const 1077432500071562197;
         const 13676251251348512601;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.536963615 UTC

[section ""data" . GHC.Int.$tcInt3_closure" {
     GHC.Int.$tcInt3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.539199976 UTC

[section ""data" . GHC.Int.$tcInt32_closure" {
     GHC.Int.$tcInt32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt3_closure+1;
         const GHC.Types.krep$*_closure;
         const 5115671124548181797;
         const 6203735229629729265;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.541058439 UTC

[section ""data" . $krep3_r4kPE_closure" {
     $krep3_r4kPE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.543407532 UTC

[section ""data" . GHC.Int.$tc'I32#1_closure" {
     GHC.Int.$tc'I32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep3_r4kPE_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.546002731 UTC

[section ""cstring" . GHC.Int.$tc'I32#3_bytes" {
     GHC.Int.$tc'I32#3_bytes:
         I8[] [39,73,51,50,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.549189255 UTC

[section ""data" . GHC.Int.$tc'I32#2_closure" {
     GHC.Int.$tc'I32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I32#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.551833283 UTC

[section ""data" . GHC.Int.$tc'I32#_closure" {
     GHC.Int.$tc'I32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I32#2_closure+1;
         const GHC.Int.$tc'I32#1_closure+4;
         const 14037617528454219662;
         const 2752255350980319305;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.554623694 UTC

[section ""data" . GHC.Int.$tcInt5_closure" {
     GHC.Int.$tcInt5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt6_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.557231208 UTC

[section ""data" . GHC.Int.$tcInt64_closure" {
     GHC.Int.$tcInt64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt5_closure+1;
         const GHC.Types.krep$*_closure;
         const 15049343324344240059;
         const 14445320765379163718;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.559930588 UTC

[section ""data" . $krep4_r4kPF_closure" {
     $krep4_r4kPF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.564161797 UTC

[section ""data" . GHC.Int.$tc'I64#1_closure" {
     GHC.Int.$tc'I64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep4_r4kPF_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.56628206 UTC

[section ""cstring" . GHC.Int.$tc'I64#3_bytes" {
     GHC.Int.$tc'I64#3_bytes:
         I8[] [39,73,54,52,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.567993561 UTC

[section ""data" . GHC.Int.$tc'I64#2_closure" {
     GHC.Int.$tc'I64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I64#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.569893789 UTC

[section ""data" . GHC.Int.$tc'I64#_closure" {
     GHC.Int.$tc'I64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I64#2_closure+1;
         const GHC.Int.$tc'I64#1_closure+4;
         const 7755385358338959724;
         const 8520529638322167079;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.572914422 UTC

[section ""data" . GHC.Int.I8#_closure" {
     GHC.Int.I8#_closure:
         const GHC.Int.I8#_info;
 },
 GHC.Int.I8#_entry() //  [R2]
         { []
         }
     {offset
       c4vtM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vtQ; else goto c4vtP;
       c4vtQ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vtP: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I8#_info" {
     GHC.Int.I8#_info:
         const GHC.Int.I8#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.577017011 UTC

[section ""data" . GHC.Int.I16#_closure" {
     GHC.Int.I16#_closure:
         const GHC.Int.I16#_info;
 },
 GHC.Int.I16#_entry() //  [R2]
         { []
         }
     {offset
       c4vu1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vu5; else goto c4vu4;
       c4vu5: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vu4: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I16#_info" {
     GHC.Int.I16#_info:
         const GHC.Int.I16#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.581552992 UTC

[section ""data" . GHC.Int.I32#_closure" {
     GHC.Int.I32#_closure:
         const GHC.Int.I32#_info;
 },
 GHC.Int.I32#_entry() //  [R2]
         { []
         }
     {offset
       c4vug: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vuk; else goto c4vuj;
       c4vuk: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vuj: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I32#_info" {
     GHC.Int.I32#_info:
         const GHC.Int.I32#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.585737629 UTC

[section ""data" . GHC.Int.I64#_closure" {
     GHC.Int.I64#_closure:
         const GHC.Int.I64#_info;
 },
 GHC.Int.I64#_entry() //  [R2]
         { []
         }
     {offset
       c4vuv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4vuz; else goto c4vuy;
       c4vuz: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4vuy: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I64#_info" {
     GHC.Int.I64#_info:
         const GHC.Int.I64#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.590410168 UTC

[section ""cstring" . i4rfo_str" {
     i4rfo_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,110,116,46,73,56,35]
 },
 GHC.Int.I8#_con_entry() //  [R1]
         { []
         }
     {offset
       c4vuF: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I8#_con_info" {
     GHC.Int.I8#_con_info:
         const GHC.Int.I8#_con_entry;
         const 4294967296;
         const 3;
         const i4rfo_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.593768956 UTC

[section ""cstring" . i4rfq_str" {
     i4rfq_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,110,116,46,73,49,54,35]
 },
 GHC.Int.I16#_con_entry() //  [R1]
         { []
         }
     {offset
       c4vuL: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I16#_con_info" {
     GHC.Int.I16#_con_info:
         const GHC.Int.I16#_con_entry;
         const 4294967296;
         const 3;
         const i4rfq_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.597150155 UTC

[section ""cstring" . i4rfs_str" {
     i4rfs_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,110,116,46,73,51,50,35]
 },
 GHC.Int.I32#_con_entry() //  [R1]
         { []
         }
     {offset
       c4vuR: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I32#_con_info" {
     GHC.Int.I32#_con_info:
         const GHC.Int.I32#_con_entry;
         const 4294967296;
         const 3;
         const i4rfs_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.600555492 UTC

[section ""cstring" . i4rfu_str" {
     i4rfu_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,110,116,46,73,54,52,35]
 },
 GHC.Int.I64#_con_entry() //  [R1]
         { []
         }
     {offset
       c4vuX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I64#_con_info" {
     GHC.Int.I64#_con_info:
         const GHC.Int.I64#_con_entry;
         const 4294967296;
         const 3;
         const i4rfu_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:13.604803869 UTC

[section ""relreadonly" . S4lDl_srt" {
     S4lDl_srt:
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt8_$cpred_closure;
         const GHC.Int.$fEnumInt7_closure;
         const GHC.Int.$fEnumInt8_$csucc_closure;
         const GHC.Int.$fEnumInt9_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl_r4kPr_closure;
         const GHC.Int.$wlvl2_closure;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum2_closure;
         const GHC.Int.$w$cenumFromThenTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Int.$wgo3_closure;
         const GHC.Int.$fEnumInt8_go_closure;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure;
         const GHC.Int.$fEnumInt8_closure;
         const GHC.Int.$fEnumInt16_$cpred_closure;
         const GHC.Int.$fEnumInt1_closure;
         const GHC.Int.$fEnumInt16_$csucc_closure;
         const GHC.Int.$fEnumInt2_closure;
         const lvl2_r4kPt_closure;
         const GHC.Int.$wlvl_closure;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum_closure;
         const GHC.Int.$w$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$wgo_closure;
         const GHC.Int.$fEnumInt16_go_closure;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure;
         const GHC.Int.$fEnumInt16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt32_$cpred_closure;
         const GHC.Int.$fEnumInt3_closure;
         const GHC.Int.$fEnumInt32_$csucc_closure;
         const GHC.Int.$fEnumInt4_closure;
         const lvl4_r4kPv_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Int.$wlvl1_closure;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum1_closure;
         const GHC.Int.$w$cenumFromTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$wgo1_closure;
         const GHC.Int.$fEnumInt32_go_closure;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure;
         const GHC.Int.$w$cenumFromThenTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt32_closure;
         const GHC.Int.$fEnumInt64_$cpred_closure;
         const GHC.Int.$fEnumInt5_closure;
         const GHC.Int.$fEnumInt64_$csucc_closure;
         const GHC.Int.$fEnumInt6_closure;
         const GHC.Int.$fEnumInt64_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Int.$fReadInt8_$creadsPrec_closure;
         const GHC.Int.$fReadInt13_closure;
         const GHC.Read.list_closure;
         const GHC.Int.$fReadInt12_closure;
         const GHC.Int.$fReadInt11_closure;
         const GHC.Int.$fReadInt8_$creadList_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fIntegralInt8_$cquot_closure;
         const GHC.Int.$fIntegralInt8_$crem_closure;
         const GHC.Int.$w$cdiv3_closure;
         const GHC.Int.$fIntegralInt8_$cdiv_closure;
         const GHC.Int.$fIntegralInt8_$cmod_closure;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure;
         const lvl6_r4kPx_closure;
         const GHC.Int.$w$cdivMod3_closure;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure;
         const sat_s4ldV_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Int.$fRealInt8_$ctoRational_closure;
         const GHC.Int.$fIxInt8_$crange_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fIxInt8_$cindex_closure;
         const GHC.Int.$fReadInt16_$creadsPrec_closure;
         const GHC.Int.$fReadInt3_closure;
         const GHC.Int.$fReadInt2_closure;
         const GHC.Int.$fReadInt1_closure;
         const GHC.Int.$fReadInt16_$creadList_closure;
         const GHC.Int.$fIntegralInt16_$cquot_closure;
         const GHC.Int.$fIntegralInt16_$crem_closure;
         const GHC.Int.$w$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cmod_closure;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure;
         const lvl7_r4kPy_closure;
         const GHC.Int.$w$cdivMod_closure;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure;
         const GHC.Int.$fRealInt16_$ctoRational_closure;
         const GHC.Int.$fIxInt16_$crange_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$fIxInt16_$cindex_closure;
         const GHC.Int.$fReadInt32_$creadsPrec_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Int.$fReadInt6_closure;
         const GHC.Int.$fReadInt5_closure;
         const GHC.Int.$fReadInt4_closure;
         const GHC.Int.$fReadInt32_$creadList_closure;
         const GHC.Int.$fIntegralInt32_$cquot_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Int.$fIntegralInt32_$crem_closure;
         const GHC.Int.$w$cdiv1_closure;
         const GHC.Int.$fIntegralInt32_$cdiv_closure;
         const GHC.Int.$fIntegralInt32_$cmod_closure;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure;
         const lvl8_r4kPz_closure;
         const GHC.Int.$w$cdivMod1_closure;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure;
         const GHC.Int.$fRealInt32_$ctoRational_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Int.$fIxInt32_$crange_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$fIxInt32_$cindex_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fReadInt64_$creadsPrec_closure;
         const GHC.Int.$fReadInt10_closure;
         const GHC.Int.$fReadInt9_closure;
         const GHC.Int.$fReadInt7_closure;
         const GHC.Int.$fReadInt64_$creadList_closure;
         const GHC.Int.$fIntegralInt64_$cquot_closure;
         const GHC.Int.$fIntegralInt64_$crem_closure;
         const GHC.Int.$fIntegralInt64_$cdiv_closure;
         const GHC.Int.$w$cdiv2_closure;
         const GHC.Int.$fIntegralInt64_$cmod_closure;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure;
         const lvl9_r4kPA_closure;
         const GHC.Int.$w$cdivMod2_closure;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure;
         const GHC.Int.$fRealInt64_$ctoRational_closure;
         const GHC.Int.$fIxInt64_$cindex_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:23.930908481 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:59:23.933043448 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cfromEnum_closure" {
     GHC.Int.$fEnumInt8_$cfromEnum_closure:
         const GHC.Int.$fEnumInt8_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt8_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c4wdw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wdA; else goto c4wdB;
       c4wdA: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wdB: // global
           I64[Sp - 8] = block_c4wdt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wdF; else goto c4wdu;
       u4wdF: // global
           call _c4wdt(R1) args: 0, res: 0, upd: 0;
       c4wdu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cfromEnum_info" {
     GHC.Int.$fEnumInt8_$cfromEnum_info:
         const GHC.Int.$fEnumInt8_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4wdt() //  [R1]
         { []
         }
     {offset
       c4wdt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wdE; else goto c4wdD;
       c4wdE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wdD: // global
           _s4vv6::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vv6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wdt_info" {
     block_c4wdt_info:
         const _c4wdt;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:23.939463148 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cfromEnum_closure" {
     GHC.Int.$fEnumInt16_$cfromEnum_closure:
         const GHC.Int.$fEnumInt16_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt16_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c4wdZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4we3; else goto c4we4;
       c4we3: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4we4: // global
           I64[Sp - 8] = block_c4wdW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4we8; else goto c4wdX;
       u4we8: // global
           call _c4wdW(R1) args: 0, res: 0, upd: 0;
       c4wdX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cfromEnum_info" {
     GHC.Int.$fEnumInt16_$cfromEnum_info:
         const GHC.Int.$fEnumInt16_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4wdW() //  [R1]
         { []
         }
     {offset
       c4wdW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4we7; else goto c4we6;
       c4we7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4we6: // global
           _s4vv9::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vv9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wdW_info" {
     block_c4wdW_info:
         const _c4wdW;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:23.948823604 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cfromEnum_closure" {
     GHC.Int.$fEnumInt32_$cfromEnum_closure:
         const GHC.Int.$fEnumInt32_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt32_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c4wes: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wew; else goto c4wex;
       c4wew: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wex: // global
           I64[Sp - 8] = block_c4wep_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4weB; else goto c4weq;
       u4weB: // global
           call _c4wep(R1) args: 0, res: 0, upd: 0;
       c4weq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cfromEnum_info" {
     GHC.Int.$fEnumInt32_$cfromEnum_info:
         const GHC.Int.$fEnumInt32_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4wep() //  [R1]
         { []
         }
     {offset
       c4wep: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4weA; else goto c4wez;
       c4weA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wez: // global
           _s4vvc::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vvc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wep_info" {
     block_c4wep_info:
         const _c4wep;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:23.955091577 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cfromEnum_closure" {
     GHC.Int.$fEnumInt64_$cfromEnum_closure:
         const GHC.Int.$fEnumInt64_$cfromEnum_info;
 },
 GHC.Int.$fEnumInt64_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       c4weV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4weZ; else goto c4wf0;
       c4weZ: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wf0: // global
           I64[Sp - 8] = block_c4weS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wf4; else goto c4weT;
       u4wf4: // global
           call _c4weS(R1) args: 0, res: 0, upd: 0;
       c4weT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cfromEnum_info" {
     GHC.Int.$fEnumInt64_$cfromEnum_info:
         const GHC.Int.$fEnumInt64_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4weS() //  [R1]
         { []
         }
     {offset
       c4weS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wf3; else goto c4wf2;
       c4wf3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wf2: // global
           _s4vvf::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vvf::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4weS_info" {
     block_c4weS_info:
         const _c4weS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:23.961377779 UTC

[section ""data" . GHC.Int.$fEnumInt64_$ctoEnum_closure" {
     GHC.Int.$fEnumInt64_$ctoEnum_closure:
         const GHC.Int.$fEnumInt64_$ctoEnum_info;
 },
 GHC.Int.$fEnumInt64_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c4wfo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wfs; else goto c4wft;
       c4wfs: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wft: // global
           I64[Sp - 8] = block_c4wfl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wfx; else goto c4wfm;
       u4wfx: // global
           call _c4wfl(R1) args: 0, res: 0, upd: 0;
       c4wfm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$ctoEnum_info" {
     GHC.Int.$fEnumInt64_$ctoEnum_info:
         const GHC.Int.$fEnumInt64_$ctoEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4wfl() //  [R1]
         { []
         }
     {offset
       c4wfl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wfw; else goto c4wfv;
       c4wfw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wfv: // global
           _s4vvi::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vvi::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wfl_info" {
     block_c4wfl_info:
         const _c4wfl;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:23.972647589 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo2_closure" {
     GHC.Int.$w$cenumFromThenTo2_closure:
         const GHC.Int.$w$cenumFromThenTo2_info;
 },
 sat_s4vvw_entry() //  [R1]
         { []
         }
     {offset
       c4wgi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wgj; else goto c4wgk;
       c4wgj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wgk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4vvr_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vvw_info" {
     sat_s4vvw_info:
         const sat_s4vvw_entry;
         const 8589934593;
         const 15;
 },
 go_dn_s4vvr_entry() //  [R1, R2]
         { []
         }
     {offset
       c4wgo: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4wgs; else goto c4wgr;
       c4wgs: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wgr: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4wgm; else goto c4wgn;
       c4wgm: // global
           _s4vvp::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4vvw_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4vvp::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wgn: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wgx::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wgx::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s4vvr_info" {
     go_dn_s4vvr_info:
         const go_dn_s4vvr_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_s4vvy_entry() //  [R1]
         { []
         }
     {offset
       c4wgy: // global
           _s4vvy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wgz; else goto c4wgA;
       c4wgA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wgC; else goto c4wgB;
       c4wgC: // global
           HpAlloc = 24;
           goto c4wgz;
       c4wgz: // global
           R1 = _s4vvy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wgB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vvy::P64;
           _s4vvk::I64 = I64[_s4vvy::P64 + 24];
           _s4vvp::I64 = _s4vvk::I64 - I64[_s4vvy::P64 + 16];
           _s4vvq::I64 = I64[_s4vvy::P64 + 32] - _s4vvp::I64;
           I64[Hp - 16] = go_dn_s4vvr_info;
           I64[Hp - 8] = _s4vvp::I64;
           I64[Hp] = _s4vvq::I64;
           R2 = _s4vvk::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4vvr_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vvy_info" {
     sat_s4vvy_info:
         const sat_s4vvy_entry;
         const 12884901888;
         const 15;
 },
 sat_s4vvK_entry() //  [R1]
         { []
         }
     {offset
       c4wh5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wh6; else goto c4wh7;
       c4wh6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wh7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4vvF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vvK_info" {
     sat_s4vvK_info:
         const sat_s4vvK_entry;
         const 8589934593;
         const 15;
 },
 go_up_s4vvF_entry() //  [R1, R2]
         { []
         }
     {offset
       c4whb: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4whf; else goto c4whe;
       c4whf: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4whe: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4wh9; else goto c4wha;
       c4wh9: // global
           _s4vvD::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4vvK_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4vvD::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wha: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4whk::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4whk::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s4vvF_info" {
     go_up_s4vvF_info:
         const go_up_s4vvF_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_s4vvM_entry() //  [R1]
         { []
         }
     {offset
       c4whl: // global
           _s4vvM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4whm; else goto c4whn;
       c4whn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4whp; else goto c4who;
       c4whp: // global
           HpAlloc = 24;
           goto c4whm;
       c4whm: // global
           R1 = _s4vvM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4who: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vvM::P64;
           _s4vvk::I64 = I64[_s4vvM::P64 + 24];
           _s4vvD::I64 = _s4vvk::I64 - I64[_s4vvM::P64 + 16];
           _s4vvE::I64 = I64[_s4vvM::P64 + 32] - _s4vvD::I64;
           I64[Hp - 16] = go_up_s4vvF_info;
           I64[Hp - 8] = _s4vvD::I64;
           I64[Hp] = _s4vvE::I64;
           R2 = _s4vvk::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4vvF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vvM_info" {
     sat_s4vvM_info:
         const sat_s4vvM_entry;
         const 12884901888;
         const 15;
 },
 GHC.Int.$w$cenumFromThenTo2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4wht: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4whx; else goto c4whw;
       c4whx: // global
           HpAlloc = 80;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4whw: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4whr; else goto c4whs;
       c4whr: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4whB; else goto c4whL;
       c4whB: // global
           I64[Hp - 72] = sat_s4vvy_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4whL: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4whY; else goto c4whJ;
       c4whJ: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4whH::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4whH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4whs: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4whP; else goto c4whZ;
       c4whP: // global
           I64[Hp - 72] = sat_s4vvM_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = R3;
           I64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4whZ: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4whY; else goto c4whX;
       c4whY: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4whX: // global
           I64[Hp - 72] = GHC.Int.I64#_con_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4whV::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4whV::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromThenTo2_info" {
     GHC.Int.$w$cenumFromThenTo2_info:
         const GHC.Int.$w$cenumFromThenTo2_entry;
         const 0;
         const 14;
         const 12884901904;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:23.992507174 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4wjz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wjI; else goto c4wjJ;
       c4wjI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wjJ: // global
           I64[Sp - 24] = block_c4wjw_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4wjS; else goto c4wjx;
       u4wjS: // global
           call _c4wjw(R1) args: 0, res: 0, upd: 0;
       c4wjx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cenumFromThenTo_info" {
     GHC.Int.$fEnumInt64_$cenumFromThenTo_info:
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c4wjw() //  [R1]
         { []
         }
     {offset
       c4wjw: // global
           I64[Sp] = block_c4wjC_info;
           _s4vvT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vvT::I64;
           if (R1 & 7 != 0) goto u4wjR; else goto c4wjD;
       u4wjR: // global
           call _c4wjC(R1) args: 0, res: 0, upd: 0;
       c4wjD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wjw_info" {
     block_c4wjw_info:
         const _c4wjw;
         const 2;
         const 30;
 },
 _c4wjC() //  [R1]
         { []
         }
     {offset
       c4wjC: // global
           I64[Sp] = block_c4wjH_info;
           _s4vvV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vvV::I64;
           if (R1 & 7 != 0) goto u4wjT; else goto c4wjM;
       u4wjT: // global
           call _c4wjH(R1) args: 0, res: 0, upd: 0;
       c4wjM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wjC_info" {
     block_c4wjC_info:
         const _c4wjC;
         const 66;
         const 30;
 },
 _c4wjH() //  [R1]
         { []
         }
     {offset
       c4wjH: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo2_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wjH_info" {
     block_c4wjH_info:
         const _c4wjH;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.002334386 UTC

[section ""data" . GHC.Int.$w$cenumFromTo2_closure" {
     GHC.Int.$w$cenumFromTo2_closure:
         const GHC.Int.$w$cenumFromTo2_info;
 },
 sat_s4vw6_entry() //  [R1]
         { []
         }
     {offset
       c4wkz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wkA; else goto c4wkB;
       c4wkA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wkB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vw2::I64 = I64[R1 + 32];
           if (_s4vw2::I64 == I64[R1 + 24]) goto c4wky; else goto c4wkx;
       c4wky: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4wkx: // global
           R2 = _s4vw2::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4vw1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vw6_info" {
     sat_s4vw6_info:
         const sat_s4vw6_entry;
         const 8589934593;
         const 15;
 },
 go_s4vw1_entry() //  [R1, R2]
         { []
         }
     {offset
       c4wkG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c4wkK; else goto c4wkJ;
       c4wkK: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wkJ: // global
           _s4vvZ::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_s4vw6_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _s4vvZ::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s4vw1_info" {
     go_s4vw1_info:
         const go_s4vw1_entry;
         const 4294967296;
         const 10;
         const 4294967300;
 },
 GHC.Int.$w$cenumFromTo2_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wkO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wkS; else goto c4wkR;
       c4wkS: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wkR: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4wkM; else goto c4wkN;
       c4wkM: // global
           I64[Hp - 8] = go_s4vw1_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4vw1_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4wkN: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromTo2_info" {
     GHC.Int.$w$cenumFromTo2_info:
         const GHC.Int.$w$cenumFromTo2_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.010702175 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt64_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt64_$cenumFromTo_info;
 },
 GHC.Int.$fEnumInt64_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wln: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wlr; else goto c4wls;
       c4wlr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wls: // global
           I64[Sp - 16] = block_c4wlk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wlA; else goto c4wll;
       u4wlA: // global
           call _c4wlk(R1) args: 0, res: 0, upd: 0;
       c4wll: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cenumFromTo_info" {
     GHC.Int.$fEnumInt64_$cenumFromTo_info:
         const GHC.Int.$fEnumInt64_$cenumFromTo_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4wlk() //  [R1]
         { []
         }
     {offset
       c4wlk: // global
           I64[Sp] = block_c4wlq_info;
           _s4vwa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vwa::I64;
           if (R1 & 7 != 0) goto u4wlz; else goto c4wlu;
       u4wlz: // global
           call _c4wlq(R1) args: 0, res: 0, upd: 0;
       c4wlu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wlk_info" {
     block_c4wlk_info:
         const _c4wlk;
         const 1;
         const 30;
 },
 _c4wlq() //  [R1]
         { []
         }
     {offset
       c4wlq: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wlq_info" {
     block_c4wlq_info:
         const _c4wlq;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.017825416 UTC

[section ""cstring" . GHC.Int.$tcInt9_bytes" {
     GHC.Int.$tcInt9_bytes:
         I8[] [73,110,116,56]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.020283447 UTC

[section ""data" . GHC.Int.$fEnumInt7_closure" {
     GHC.Int.$fEnumInt7_closure:
         const GHC.Int.$fEnumInt7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt7_entry() //  [R1]
         { []
         }
     {offset
       c4wlZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wm0; else goto c4wm1;
       c4wm0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wm1: // global
           (_c4wlU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wlU::I64 == 0) goto c4wlW; else goto c4wlV;
       c4wlW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wlV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wlU::I64;
           I64[Sp - 24] = block_c4wlX_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt7_info" {
     GHC.Int.$fEnumInt7_info:
         const GHC.Int.$fEnumInt7_entry;
         const 0;
         const 4294967317;
         const S4wm5_srt;
 },
 _c4wlX() //  [R1]
         { []
         }
     {offset
       c4wlX: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4wlX_info" {
     block_c4wlX_info:
         const _c4wlX;
         const 0;
         const 4294967326;
         const S4wm5_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.026189985 UTC

[section ""data" . GHC.Int.$fEnumInt9_closure" {
     GHC.Int.$fEnumInt9_closure:
         const GHC.Int.$fEnumInt9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt9_entry() //  [R1]
         { []
         }
     {offset
       c4wmq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wmr; else goto c4wms;
       c4wmr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wms: // global
           (_c4wml::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wml::I64 == 0) goto c4wmn; else goto c4wmm;
       c4wmn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wmm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wml::I64;
           I64[Sp - 24] = block_c4wmo_info;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt9_info" {
     GHC.Int.$fEnumInt9_info:
         const GHC.Int.$fEnumInt9_entry;
         const 0;
         const 4294967317;
         const S4wm5_srt+8;
 },
 _c4wmo() //  [R1]
         { []
         }
     {offset
       c4wmo: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4wmo_info" {
     block_c4wmo_info:
         const _c4wmo;
         const 0;
         const 4294967326;
         const S4wm5_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.032509114 UTC

[section ""data" . GHC.Int.neInt8_closure" {
     GHC.Int.neInt8_closure:
         const GHC.Int.neInt8_info;
 },
 GHC.Int.neInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wmP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wmT; else goto c4wmU;
       c4wmT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wmU: // global
           I64[Sp - 16] = block_c4wmM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wn3; else goto c4wmN;
       u4wn3: // global
           call _c4wmM(R1) args: 0, res: 0, upd: 0;
       c4wmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.neInt8_info" {
     GHC.Int.neInt8_info:
         const GHC.Int.neInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4wmM() //  [R1]
         { []
         }
     {offset
       c4wmM: // global
           I64[Sp] = block_c4wmS_info;
           _s4vwi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vwi::I64;
           if (R1 & 7 != 0) goto u4wn2; else goto c4wmW;
       u4wn2: // global
           call _c4wmS(R1) args: 0, res: 0, upd: 0;
       c4wmW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wmM_info" {
     block_c4wmM_info:
         const _c4wmM;
         const 1;
         const 30;
 },
 _c4wmS() //  [R1]
         { []
         }
     {offset
       c4wmS: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wmS_info" {
     block_c4wmS_info:
         const _c4wmS;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.04034399 UTC

[section ""data" . lvl_r4kPr_closure" {
     lvl_r4kPr_closure:
         const lvl_r4kPr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_r4kPr_entry() //  [R1]
         { []
         }
     {offset
       c4wnu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wnv; else goto c4wnw;
       c4wnv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wnw: // global
           (_c4wnr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wnr::I64 == 0) goto c4wnt; else goto c4wns;
       c4wnt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wns: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wnr::I64;
           R2 = GHC.Int.$tcInt9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_r4kPr_info" {
     lvl_r4kPr_info:
         const lvl_r4kPr_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.043952864 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cminBound_closure" {
     GHC.Int.$fBoundedInt8_$cminBound_closure:
         const GHC.Int.I8#_con_info;
         const (-128);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.046938512 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cpred_closure" {
     GHC.Int.$fEnumInt8_$cpred_closure:
         const GHC.Int.$fEnumInt8_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c4wnN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wnO; else goto c4wnP;
       c4wnO: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wnP: // global
           I64[Sp - 8] = block_c4wnK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wo7; else goto c4wnL;
       u4wo7: // global
           call _c4wnK(R1) args: 0, res: 0, upd: 0;
       c4wnL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cpred_info" {
     GHC.Int.$fEnumInt8_$cpred_info:
         const GHC.Int.$fEnumInt8_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+16;
 },
 _c4wnK() //  [R1]
         { []
         }
     {offset
       c4wnK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wnU; else goto c4wnT;
       c4wnU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wnT: // global
           _s4vwp::I64 = I64[R1 + 7];
           if (_s4vwp::I64 != (-128)) goto c4wo5; else goto c4wo6;
       c4wo5: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vwp::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wo6: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wnK_info" {
     block_c4wnK_info:
         const _c4wnK;
         const 0;
         const 4294967326;
         const S4wm5_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.052960617 UTC

[section ""data" . GHC.Int.$fBoundedInt8_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt8_$cmaxBound_closure:
         const GHC.Int.I8#_con_info;
         const 127;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.054857628 UTC

[section ""data" . GHC.Int.$fBoundedInt8_closure" {
     GHC.Int.$fBoundedInt8_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt8_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.058392324 UTC

[section ""data" . GHC.Int.$fEnumInt8_$csucc_closure" {
     GHC.Int.$fEnumInt8_$csucc_closure:
         const GHC.Int.$fEnumInt8_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c4wow: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wox; else goto c4woy;
       c4wox: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4woy: // global
           I64[Sp - 8] = block_c4wot_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4woQ; else goto c4wou;
       u4woQ: // global
           call _c4wot(R1) args: 0, res: 0, upd: 0;
       c4wou: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$csucc_info" {
     GHC.Int.$fEnumInt8_$csucc_info:
         const GHC.Int.$fEnumInt8_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+32;
 },
 _c4wot() //  [R1]
         { []
         }
     {offset
       c4wot: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4woD; else goto c4woC;
       c4woD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4woC: // global
           _s4vwv::I64 = I64[R1 + 7];
           if (_s4vwv::I64 != 127) goto c4woO; else goto c4woP;
       c4woO: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vwv::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4woP: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wot_info" {
     block_c4wot_info:
         const _c4wot;
         const 0;
         const 4294967326;
         const S4wm5_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.066147995 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowsPrec_closure" {
     GHC.Int.$fShowInt8_$cshowsPrec_closure:
         const GHC.Int.$fShowInt8_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt8_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4wpd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wpo; else goto c4wpp;
       c4wpo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wpp: // global
           I64[Sp - 24] = block_c4wpa_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4wpw; else goto c4wpb;
       u4wpw: // global
           call _c4wpa(R1) args: 0, res: 0, upd: 0;
       c4wpb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt8_$cshowsPrec_info" {
     GHC.Int.$fShowInt8_$cshowsPrec_info:
         const GHC.Int.$fShowInt8_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c4wpa() //  [R1]
         { []
         }
     {offset
       c4wpa: // global
           I64[Sp] = block_c4wpg_info;
           _s4vwC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vwC::I64;
           if (R1 & 7 != 0) goto u4wpv; else goto c4wph;
       u4wpv: // global
           call _c4wpg(R1) args: 0, res: 0, upd: 0;
       c4wph: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wpa_info" {
     block_c4wpa_info:
         const _c4wpa;
         const 2;
         const 30;
 },
 _c4wpg() //  [R1]
         { []
         }
     {offset
       c4wpg: // global
           _s4vwA::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4wpl_info;
           R4 = _s4vwA::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wpg_info" {
     block_c4wpg_info:
         const _c4wpg;
         const 66;
         const 30;
 },
 _c4wpl() //  [R1, R2]
         { []
         }
     {offset
       c4wpl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wpu; else goto c4wpt;
       c4wpu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wpt: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wpl_info" {
     block_c4wpl_info:
         const _c4wpl;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.075797878 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshow_closure" {
     GHC.Int.$fShowInt8_$cshow_closure:
         const GHC.Int.$fShowInt8_$cshow_info;
 },
 GHC.Int.$fShowInt8_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c4wpZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wq5; else goto c4wq6;
       c4wq5: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt8_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wq6: // global
           I64[Sp - 8] = block_c4wpW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wqb; else goto c4wpX;
       u4wqb: // global
           call _c4wpW(R1) args: 0, res: 0, upd: 0;
       c4wpX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt8_$cshow_info" {
     GHC.Int.$fShowInt8_$cshow_info:
         const GHC.Int.$fShowInt8_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4wpW() //  [R1]
         { []
         }
     {offset
       c4wpW: // global
           I64[Sp] = block_c4wq2_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wpW_info" {
     block_c4wpW_info:
         const _c4wpW;
         const 0;
         const 30;
 },
 _c4wq2() //  [R1, R2]
         { []
         }
     {offset
       c4wq2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wqa; else goto c4wq9;
       c4wqa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wq9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wq2_info" {
     block_c4wq2_info:
         const _c4wq2;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.084451209 UTC

[section ""data" . GHC.Int.$fShowInt4_closure" {
     GHC.Int.$fShowInt4_closure:
         const GHC.Int.$fShowInt4_info;
 },
 GHC.Int.$fShowInt4_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wqA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wqG; else goto c4wqH;
       c4wqG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wqH: // global
           I64[Sp - 16] = block_c4wqx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wqM; else goto c4wqy;
       u4wqM: // global
           call _c4wqx(R1) args: 0, res: 0, upd: 0;
       c4wqy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt4_info" {
     GHC.Int.$fShowInt4_info:
         const GHC.Int.$fShowInt4_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4wqx() //  [R1]
         { []
         }
     {offset
       c4wqx: // global
           _s4vwP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4wqD_info;
           R4 = _s4vwP::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wqx_info" {
     block_c4wqx_info:
         const _c4wqx;
         const 1;
         const 30;
 },
 _c4wqD() //  [R1, R2]
         { []
         }
     {offset
       c4wqD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wqL; else goto c4wqK;
       c4wqL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wqK: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wqD_info" {
     block_c4wqD_info:
         const _c4wqD;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.091692906 UTC

[section ""data" . GHC.Int.$fShowInt8_$cshowList_closure" {
     GHC.Int.$fShowInt8_$cshowList_closure:
         const GHC.Int.$fShowInt8_$cshowList_info;
 },
 GHC.Int.$fShowInt8_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wr7: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt4_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt8_$cshowList_info" {
     GHC.Int.$fShowInt8_$cshowList_info:
         const GHC.Int.$fShowInt8_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.095049028 UTC

[section ""data" . GHC.Int.$fShowInt8_closure" {
     GHC.Int.$fShowInt8_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt8_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt8_$cshow_closure+1;
         const GHC.Int.$fShowInt8_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.0974619 UTC

[section ""data" . GHC.Int.$wlvl2_closure" {
     GHC.Int.$wlvl2_closure:
         const GHC.Int.$wlvl2_info;
         const 0;
 },
 GHC.Int.$wlvl2_entry() //  [R2]
         { []
         }
     {offset
       c4wrj: // global
           R6 = GHC.Int.$fBoundedInt8_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt8_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl_r4kPr_closure;
           R2 = GHC.Int.$fShowInt8_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wlvl2_info" {
     GHC.Int.$wlvl2_info:
         const GHC.Int.$wlvl2_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S4wm5_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.102264619 UTC

[section ""data" . GHC.Int.$w$ctoEnum2_closure" {
     GHC.Int.$w$ctoEnum2_closure:
         const GHC.Int.$w$ctoEnum2_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum2_entry() //  [R2]
         { []
         }
     {offset
       c4wrz: // global
           _s4vwY::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-128))) goto c4wrH; else goto c4wry;
       c4wry: // global
           if (%MO_S_Gt_W64(_s4vwY::I64, 127)) goto c4wrH; else goto c4wrI;
       c4wrH: // global
           R2 = _s4vwY::I64;
           call GHC.Int.$wlvl2_entry(R2) args: 8, res: 0, upd: 8;
       c4wrI: // global
           R1 = _s4vwY::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$ctoEnum2_info" {
     GHC.Int.$w$ctoEnum2_info:
         const GHC.Int.$w$ctoEnum2_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S4wm5_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.106991302 UTC

[section ""data" . GHC.Int.$fEnumInt8_$ctoEnum_closure" {
     GHC.Int.$fEnumInt8_$ctoEnum_closure:
         const GHC.Int.$fEnumInt8_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c4wrV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ws3; else goto c4ws4;
       c4ws3: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ws4: // global
           I64[Sp - 8] = block_c4wrS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ws9; else goto c4wrT;
       u4ws9: // global
           call _c4wrS(R1) args: 0, res: 0, upd: 0;
       c4wrT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$ctoEnum_info" {
     GHC.Int.$fEnumInt8_$ctoEnum_info:
         const GHC.Int.$fEnumInt8_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+72;
 },
 _c4wrS() //  [R1]
         { []
         }
     {offset
       c4wrS: // global
           I64[Sp] = block_c4wrY_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wrS_info" {
     block_c4wrS_info:
         const _c4wrS;
         const 0;
         const 4294967326;
         const S4wm5_srt+80;
 },
 _c4wrY() //  [R1]
         { []
         }
     {offset
       c4wrY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ws8; else goto c4ws7;
       c4ws8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ws7: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wrY_info" {
     block_c4wrY_info:
         const _c4wrY;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.125863047 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo3_closure" {
     GHC.Int.$w$cenumFromThenTo3_closure:
         const GHC.Int.$w$cenumFromThenTo3_info;
         const 0;
 },
 sat_s4vxo_entry() //  [R1]
         { []
         }
     {offset
       c4wsY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wsZ; else goto c4wt0;
       c4wsZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wt0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4vxh_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxo_info" {
     sat_s4vxo_info:
         const sat_s4vxo_entry;
         const 8589934593;
         const 4294967311;
         const S4wm5_srt+64;
 },
 sat_s4vxm_entry() //  [R1]
         { []
         }
     {offset
       c4wta: // global
           _s4vxm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wtb; else goto c4wtc;
       c4wtc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wte; else goto c4wtd;
       c4wte: // global
           HpAlloc = 16;
           goto c4wtb;
       c4wtb: // global
           R1 = _s4vxm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wtd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxm::P64;
           _s4vxi::I64 = I64[_s4vxm::P64 + 16];
           if (%MO_S_Lt_W64(_s4vxi::I64, (-128))) goto c4wtk; else goto c4wt9;
       c4wt9: // global
           if (%MO_S_Gt_W64(_s4vxi::I64, 127)) goto c4wtk; else goto c4wto;
       c4wtk: // global
           Hp = Hp - 16;
           R2 = _s4vxi::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wto: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vxi::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxm_info" {
     sat_s4vxm_info:
         const sat_s4vxm_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+64;
 },
 sat_s4vxr_entry() //  [R1]
         { []
         }
     {offset
       c4wtz: // global
           _s4vxr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wtA; else goto c4wtB;
       c4wtB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wtD; else goto c4wtC;
       c4wtD: // global
           HpAlloc = 16;
           goto c4wtA;
       c4wtA: // global
           R1 = _s4vxr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wtC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxr::P64;
           _s4vxi::I64 = I64[_s4vxr::P64 + 16];
           if (%MO_S_Lt_W64(_s4vxi::I64, (-128))) goto c4wtJ; else goto c4wty;
       c4wty: // global
           if (%MO_S_Gt_W64(_s4vxi::I64, 127)) goto c4wtJ; else goto c4wtN;
       c4wtJ: // global
           Hp = Hp - 16;
           R2 = _s4vxi::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wtN: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vxi::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxr_info" {
     sat_s4vxr_info:
         const sat_s4vxr_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+64;
 },
 go_dn_s4vxh_entry() //  [R1, R2]
         { []
         }
     {offset
       c4wtR: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wtV; else goto c4wtU;
       c4wtV: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wtU: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4wtP; else goto c4wtQ;
       c4wtP: // global
           _s4vxf::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vxo_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vxf::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vxm_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wtQ: // global
           I64[Hp - 80] = sat_s4vxr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wtX::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wtX::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s4vxh_info" {
     go_dn_s4vxh_info:
         const go_dn_s4vxh_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4wm5_srt+64;
 },
 sat_s4vxs_entry() //  [R1]
         { []
         }
     {offset
       c4wtY: // global
           _s4vxs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wtZ; else goto c4wu0;
       c4wu0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wu2; else goto c4wu1;
       c4wu2: // global
           HpAlloc = 24;
           goto c4wtZ;
       c4wtZ: // global
           R1 = _s4vxs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wu1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxs::P64;
           _s4vx8::I64 = I64[_s4vxs::P64 + 24];
           _s4vxf::I64 = _s4vx8::I64 - I64[_s4vxs::P64 + 16];
           _s4vxg::I64 = I64[_s4vxs::P64 + 32] - _s4vxf::I64;
           I64[Hp - 16] = go_dn_s4vxh_info;
           I64[Hp - 8] = _s4vxf::I64;
           I64[Hp] = _s4vxg::I64;
           R2 = _s4vx8::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4vxh_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxs_info" {
     sat_s4vxs_info:
         const sat_s4vxs_entry;
         const 12884901888;
         const 4294967311;
         const S4wm5_srt+64;
 },
 sat_s4vxe_entry() //  [R1]
         { []
         }
     {offset
       c4wuc: // global
           _s4vxe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wud; else goto c4wue;
       c4wue: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wug; else goto c4wuf;
       c4wug: // global
           HpAlloc = 16;
           goto c4wud;
       c4wud: // global
           R1 = _s4vxe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wuf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxe::P64;
           _s4vx7::I64 = I64[_s4vxe::P64 + 16];
           if (%MO_S_Lt_W64(_s4vx7::I64, (-128))) goto c4wum; else goto c4wub;
       c4wub: // global
           if (%MO_S_Gt_W64(_s4vx7::I64, 127)) goto c4wum; else goto c4wuq;
       c4wum: // global
           Hp = Hp - 16;
           R2 = _s4vx7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wuq: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vx7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxe_info" {
     sat_s4vxe_info:
         const sat_s4vxe_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+64;
 },
 sat_s4vxw_entry() //  [R1]
         { []
         }
     {offset
       c4wuE: // global
           _s4vxw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wuF; else goto c4wuG;
       c4wuG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wuI; else goto c4wuH;
       c4wuI: // global
           HpAlloc = 16;
           goto c4wuF;
       c4wuF: // global
           R1 = _s4vxw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wuH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxw::P64;
           _s4vx7::I64 = I64[_s4vxw::P64 + 16];
           if (%MO_S_Lt_W64(_s4vx7::I64, (-128))) goto c4wuO; else goto c4wuD;
       c4wuD: // global
           if (%MO_S_Gt_W64(_s4vx7::I64, 127)) goto c4wuO; else goto c4wuS;
       c4wuO: // global
           Hp = Hp - 16;
           R2 = _s4vx7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wuS: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vx7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxw_info" {
     sat_s4vxw_info:
         const sat_s4vxw_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+64;
 },
 sat_s4vxK_entry() //  [R1]
         { []
         }
     {offset
       c4wvl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wvm; else goto c4wvn;
       c4wvm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wvn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4vxD_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxK_info" {
     sat_s4vxK_info:
         const sat_s4vxK_entry;
         const 8589934593;
         const 4294967311;
         const S4wm5_srt+64;
 },
 sat_s4vxI_entry() //  [R1]
         { []
         }
     {offset
       c4wvx: // global
           _s4vxI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wvy; else goto c4wvz;
       c4wvz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wvB; else goto c4wvA;
       c4wvB: // global
           HpAlloc = 16;
           goto c4wvy;
       c4wvy: // global
           R1 = _s4vxI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wvA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxI::P64;
           _s4vxE::I64 = I64[_s4vxI::P64 + 16];
           if (%MO_S_Lt_W64(_s4vxE::I64, (-128))) goto c4wvH; else goto c4wvw;
       c4wvw: // global
           if (%MO_S_Gt_W64(_s4vxE::I64, 127)) goto c4wvH; else goto c4wvL;
       c4wvH: // global
           Hp = Hp - 16;
           R2 = _s4vxE::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wvL: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vxE::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxI_info" {
     sat_s4vxI_info:
         const sat_s4vxI_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+64;
 },
 sat_s4vxN_entry() //  [R1]
         { []
         }
     {offset
       c4wvW: // global
           _s4vxN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wvX; else goto c4wvY;
       c4wvY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ww0; else goto c4wvZ;
       c4ww0: // global
           HpAlloc = 16;
           goto c4wvX;
       c4wvX: // global
           R1 = _s4vxN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wvZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxN::P64;
           _s4vxE::I64 = I64[_s4vxN::P64 + 16];
           if (%MO_S_Lt_W64(_s4vxE::I64, (-128))) goto c4ww6; else goto c4wvV;
       c4wvV: // global
           if (%MO_S_Gt_W64(_s4vxE::I64, 127)) goto c4ww6; else goto c4wwa;
       c4ww6: // global
           Hp = Hp - 16;
           R2 = _s4vxE::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wwa: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vxE::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxN_info" {
     sat_s4vxN_info:
         const sat_s4vxN_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+64;
 },
 go_up_s4vxD_entry() //  [R1, R2]
         { []
         }
     {offset
       c4wwe: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wwi; else goto c4wwh;
       c4wwi: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wwh: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4wwc; else goto c4wwd;
       c4wwc: // global
           _s4vxB::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vxK_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vxB::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vxI_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wwd: // global
           I64[Hp - 80] = sat_s4vxN_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wwk::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wwk::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s4vxD_info" {
     go_up_s4vxD_info:
         const go_up_s4vxD_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4wm5_srt+64;
 },
 sat_s4vxO_entry() //  [R1]
         { []
         }
     {offset
       c4wwl: // global
           _s4vxO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wwm; else goto c4wwn;
       c4wwn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wwp; else goto c4wwo;
       c4wwp: // global
           HpAlloc = 24;
           goto c4wwm;
       c4wwm: // global
           R1 = _s4vxO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wwo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxO::P64;
           _s4vx8::I64 = I64[_s4vxO::P64 + 24];
           _s4vxB::I64 = _s4vx8::I64 - I64[_s4vxO::P64 + 16];
           _s4vxC::I64 = I64[_s4vxO::P64 + 32] - _s4vxB::I64;
           I64[Hp - 16] = go_up_s4vxD_info;
           I64[Hp - 8] = _s4vxB::I64;
           I64[Hp] = _s4vxC::I64;
           R2 = _s4vx8::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4vxD_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxO_info" {
     sat_s4vxO_info:
         const sat_s4vxO_entry;
         const 12884901888;
         const 4294967311;
         const S4wm5_srt+64;
 },
 sat_s4vxA_entry() //  [R1]
         { []
         }
     {offset
       c4wwz: // global
           _s4vxA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wwA; else goto c4wwB;
       c4wwB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wwD; else goto c4wwC;
       c4wwD: // global
           HpAlloc = 16;
           goto c4wwA;
       c4wwA: // global
           R1 = _s4vxA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wwC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxA::P64;
           _s4vx7::I64 = I64[_s4vxA::P64 + 16];
           if (%MO_S_Lt_W64(_s4vx7::I64, (-128))) goto c4wwJ; else goto c4wwy;
       c4wwy: // global
           if (%MO_S_Gt_W64(_s4vx7::I64, 127)) goto c4wwJ; else goto c4wwN;
       c4wwJ: // global
           Hp = Hp - 16;
           R2 = _s4vx7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wwN: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vx7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxA_info" {
     sat_s4vxA_info:
         const sat_s4vxA_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+64;
 },
 sat_s4vxS_entry() //  [R1]
         { []
         }
     {offset
       c4wx1: // global
           _s4vxS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wx2; else goto c4wx3;
       c4wx3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wx5; else goto c4wx4;
       c4wx5: // global
           HpAlloc = 16;
           goto c4wx2;
       c4wx2: // global
           R1 = _s4vxS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wx4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vxS::P64;
           _s4vx7::I64 = I64[_s4vxS::P64 + 16];
           if (%MO_S_Lt_W64(_s4vx7::I64, (-128))) goto c4wxb; else goto c4wx0;
       c4wx0: // global
           if (%MO_S_Gt_W64(_s4vx7::I64, 127)) goto c4wxb; else goto c4wxf;
       c4wxb: // global
           Hp = Hp - 16;
           R2 = _s4vx7::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wxf: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vx7::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vxS_info" {
     sat_s4vxS_info:
         const sat_s4vxS_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+64;
 },
 GHC.Int.$w$cenumFromThenTo3_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4wxj: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wxn; else goto c4wxm;
       c4wxn: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wxm: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4wxh; else goto c4wxi;
       c4wxh: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4wxq; else goto c4wxv;
       c4wxq: // global
           I64[Hp - 80] = sat_s4vxs_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vxe_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wxv: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4wxC; else goto c4wxt;
       c4wxt: // global
           I64[Hp - 80] = sat_s4vxw_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wxr::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wxr::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wxi: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4wxy; else goto c4wxD;
       c4wxy: // global
           I64[Hp - 80] = sat_s4vxO_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vxA_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wxD: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4wxC; else goto c4wxB;
       c4wxC: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wxB: // global
           I64[Hp - 80] = sat_s4vxS_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wxz::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wxz::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromThenTo3_info" {
     GHC.Int.$w$cenumFromThenTo3_info:
         const GHC.Int.$w$cenumFromThenTo3_entry;
         const 0;
         const 38654705678;
         const 12884901904;
         const S4wm5_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.161892764 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4wA7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wAg; else goto c4wAh;
       c4wAg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wAh: // global
           I64[Sp - 24] = block_c4wA4_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4wAq; else goto c4wA5;
       u4wAq: // global
           call _c4wA4(R1) args: 0, res: 0, upd: 0;
       c4wA5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cenumFromThenTo_info" {
     GHC.Int.$fEnumInt8_$cenumFromThenTo_info:
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S4wm5_srt+88;
 },
 _c4wA4() //  [R1]
         { []
         }
     {offset
       c4wA4: // global
           I64[Sp] = block_c4wAa_info;
           _s4vxX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vxX::I64;
           if (R1 & 7 != 0) goto u4wAp; else goto c4wAb;
       u4wAp: // global
           call _c4wAa(R1) args: 0, res: 0, upd: 0;
       c4wAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wA4_info" {
     block_c4wA4_info:
         const _c4wA4;
         const 2;
         const 4294967326;
         const S4wm5_srt+88;
 },
 _c4wAa() //  [R1]
         { []
         }
     {offset
       c4wAa: // global
           I64[Sp] = block_c4wAf_info;
           _s4vxZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vxZ::I64;
           if (R1 & 7 != 0) goto u4wAr; else goto c4wAk;
       u4wAr: // global
           call _c4wAf(R1) args: 0, res: 0, upd: 0;
       c4wAk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wAa_info" {
     block_c4wAa_info:
         const _c4wAa;
         const 66;
         const 4294967326;
         const S4wm5_srt+88;
 },
 _c4wAf() //  [R1]
         { []
         }
     {offset
       c4wAf: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo3_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wAf_info" {
     block_c4wAf_info:
         const _c4wAf;
         const 194;
         const 4294967326;
         const S4wm5_srt+88;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.173452653 UTC

[section ""data" . GHC.Int.$w$cenumFromTo3_closure" {
     GHC.Int.$w$cenumFromTo3_closure:
         const GHC.Int.$w$cenumFromTo3_info;
         const 0;
 },
 sat_s4vyc_entry() //  [R1]
         { []
         }
     {offset
       c4wB7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wB8; else goto c4wB9;
       c4wB8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wB9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vy6::I64 = I64[R1 + 32];
           if (_s4vy6::I64 == I64[R1 + 24]) goto c4wB6; else goto c4wB5;
       c4wB6: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4wB5: // global
           R2 = _s4vy6::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4vy5_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vyc_info" {
     sat_s4vyc_info:
         const sat_s4vyc_entry;
         const 8589934593;
         const 4294967311;
         const S4wm5_srt+64;
 },
 sat_s4vy9_entry() //  [R1]
         { []
         }
     {offset
       c4wBl: // global
           _s4vy9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wBm; else goto c4wBn;
       c4wBn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wBp; else goto c4wBo;
       c4wBp: // global
           HpAlloc = 16;
           goto c4wBm;
       c4wBm: // global
           R1 = _s4vy9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wBo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vy9::P64;
           _s4vy6::I64 = I64[_s4vy9::P64 + 16];
           if (%MO_S_Lt_W64(_s4vy6::I64, (-128))) goto c4wBv; else goto c4wBk;
       c4wBk: // global
           if (%MO_S_Gt_W64(_s4vy6::I64, 127)) goto c4wBv; else goto c4wBz;
       c4wBv: // global
           Hp = Hp - 16;
           R2 = _s4vy6::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wBz: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vy6::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vy9_info" {
     sat_s4vy9_info:
         const sat_s4vy9_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+64;
 },
 go_s4vy5_entry() //  [R1, R2]
         { []
         }
     {offset
       c4wBB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wBF; else goto c4wBE;
       c4wBF: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wBE: // global
           _s4vy3::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vyc_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vy3::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vy9_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s4vy5_info" {
     go_s4vy5_info:
         const go_s4vy5_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S4wm5_srt+64;
 },
 GHC.Int.$w$cenumFromTo3_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wBJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wBN; else goto c4wBM;
       c4wBN: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wBM: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4wBH; else goto c4wBI;
       c4wBH: // global
           I64[Hp - 8] = go_s4vy5_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4vy5_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4wBI: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromTo3_info" {
     GHC.Int.$w$cenumFromTo3_info:
         const GHC.Int.$w$cenumFromTo3_entry;
         const 0;
         const 141733920782;
         const 8589934604;
         const S4wm5_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.184441769 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt8_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt8_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wCp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wCt; else goto c4wCu;
       c4wCt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wCu: // global
           I64[Sp - 16] = block_c4wCm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wCC; else goto c4wCn;
       u4wCC: // global
           call _c4wCm(R1) args: 0, res: 0, upd: 0;
       c4wCn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cenumFromTo_info" {
     GHC.Int.$fEnumInt8_$cenumFromTo_info:
         const GHC.Int.$fEnumInt8_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+104;
 },
 _c4wCm() //  [R1]
         { []
         }
     {offset
       c4wCm: // global
           I64[Sp] = block_c4wCs_info;
           _s4vyg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vyg::I64;
           if (R1 & 7 != 0) goto u4wCB; else goto c4wCw;
       u4wCB: // global
           call _c4wCs(R1) args: 0, res: 0, upd: 0;
       c4wCw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wCm_info" {
     block_c4wCm_info:
         const _c4wCm;
         const 1;
         const 4294967326;
         const S4wm5_srt+104;
 },
 _c4wCs() //  [R1]
         { []
         }
     {offset
       c4wCs: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo3_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wCs_info" {
     block_c4wCs_info:
         const _c4wCs;
         const 65;
         const 4294967326;
         const S4wm5_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.194164185 UTC

[section ""data" . GHC.Int.$wgo3_closure" {
     GHC.Int.$wgo3_closure:
         const GHC.Int.$wgo3_info;
         const 0;
 },
 sat_s4vys_entry() //  [R1]
         { []
         }
     {offset
       c4wD4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wD5; else goto c4wDg;
       c4wD5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wDg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vyn::I64 = I64[R1 + 16];
           if (_s4vyn::I64 != 127) goto c4wD2; else goto c4wD3;
       c4wD2: // global
           I64[Sp - 24] = block_c4wDa_info;
           R2 = _s4vyn::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 24;
       c4wD3: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vys_info" {
     sat_s4vys_info:
         const sat_s4vys_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+120;
 },
 _c4wDa() //  [R1, R2]
         { []
         }
     {offset
       c4wDa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wDf; else goto c4wDe;
       c4wDf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4wDe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4wDa_info" {
     block_c4wDa_info:
         const _c4wDa;
         const 0;
         const 30;
 },
 sat_s4vym_entry() //  [R1]
         { []
         }
     {offset
       c4wDq: // global
           _s4vym::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wDr; else goto c4wDs;
       c4wDs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wDu; else goto c4wDt;
       c4wDu: // global
           HpAlloc = 16;
           goto c4wDr;
       c4wDr: // global
           R1 = _s4vym::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wDt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vym::P64;
           _s4vyj::I64 = I64[_s4vym::P64 + 16];
           if (%MO_S_Lt_W64(_s4vyj::I64, (-128))) goto c4wDA; else goto c4wDp;
       c4wDp: // global
           if (%MO_S_Gt_W64(_s4vyj::I64, 127)) goto c4wDA; else goto c4wDE;
       c4wDA: // global
           Hp = Hp - 16;
           R2 = _s4vyj::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl2_entry(R2) args: 24, res: 0, upd: 24;
       c4wDE: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vyj::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vym_info" {
     sat_s4vym_info:
         const sat_s4vym_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+64;
 },
 GHC.Int.$wgo3_entry() //  [R2]
         { []
         }
     {offset
       c4wDF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4wDJ; else goto c4wDI;
       c4wDJ: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wDI: // global
           I64[Hp - 40] = sat_s4vys_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4vym_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wgo3_info" {
     GHC.Int.$wgo3_info:
         const GHC.Int.$wgo3_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const S4wm5_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.204734568 UTC

[section ""data" . GHC.Int.$fEnumInt8_go_closure" {
     GHC.Int.$fEnumInt8_go_closure:
         const GHC.Int.$fEnumInt8_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_go_entry() //  [R2]
         { []
         }
     {offset
       c4wEi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wEj; else goto c4wEk;
       c4wEj: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wEk: // global
           I64[Sp - 8] = block_c4wEf_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo3_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_go_info" {
     GHC.Int.$fEnumInt8_go_info:
         const GHC.Int.$fEnumInt8_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S4wm5_srt+120;
 },
 _c4wEf() //  [R1, R2]
         { []
         }
     {offset
       c4wEf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wEn; else goto c4wEm;
       c4wEn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wEm: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wEf_info" {
     block_c4wEf_info:
         const _c4wEf;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.21147042 UTC

[section ""data" . GHC.Int.$fEnumInt8_$cenumFrom_closure" {
     GHC.Int.$fEnumInt8_$cenumFrom_closure:
         const GHC.Int.$fEnumInt8_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c4wEG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wEH; else goto c4wEI;
       c4wEH: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt8_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wEI: // global
           I64[Sp - 8] = block_c4wED_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wER; else goto c4wEE;
       u4wER: // global
           call _c4wED(R1) args: 0, res: 0, upd: 0;
       c4wEE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cenumFrom_info" {
     GHC.Int.$fEnumInt8_$cenumFrom_info:
         const GHC.Int.$fEnumInt8_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+128;
 },
 _c4wED() //  [R1]
         { []
         }
     {offset
       c4wED: // global
           _s4vyz::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4vyz::I64, 127)) goto c4wEP; else goto c4wEQ;
       c4wEP: // global
           R2 = _s4vyz::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_go_entry(R2) args: 8, res: 0, upd: 8;
       c4wEQ: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wED_info" {
     block_c4wED_info:
         const _c4wED;
         const 0;
         const 4294967326;
         const S4wm5_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.217188962 UTC

[section ""data" . GHC.Int.$fEnumInt8_closure" {
     GHC.Int.$fEnumInt8_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt8_$csucc_closure+1;
         const GHC.Int.$fEnumInt8_$cpred_closure+1;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt8_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt8_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt8_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt8_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt8_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wF8: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt8_closure+1;
           R2 = GHC.Int.$fEnumInt8_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt8_$cenumFromThen_info" {
     GHC.Int.$fEnumInt8_$cenumFromThen_info:
         const GHC.Int.$fEnumInt8_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S4wm5_srt+144;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.221426731 UTC

[section ""cstring" . GHC.Int.$tcInt2_bytes" {
     GHC.Int.$tcInt2_bytes:
         I8[] [73,110,116,49,54]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.224099877 UTC

[section ""data" . GHC.Int.$fEnumInt1_closure" {
     GHC.Int.$fEnumInt1_closure:
         const GHC.Int.$fEnumInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt1_entry() //  [R1]
         { []
         }
     {offset
       c4wFp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wFq; else goto c4wFr;
       c4wFq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wFr: // global
           (_c4wFk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wFk::I64 == 0) goto c4wFm; else goto c4wFl;
       c4wFm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wFl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wFk::I64;
           I64[Sp - 24] = block_c4wFn_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt1_info" {
     GHC.Int.$fEnumInt1_info:
         const GHC.Int.$fEnumInt1_entry;
         const 0;
         const 4294967317;
         const S4wm5_srt;
 },
 _c4wFn() //  [R1]
         { []
         }
     {offset
       c4wFn: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4wFn_info" {
     block_c4wFn_info:
         const _c4wFn;
         const 0;
         const 4294967326;
         const S4wm5_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.23104239 UTC

[section ""data" . GHC.Int.$fEnumInt2_closure" {
     GHC.Int.$fEnumInt2_closure:
         const GHC.Int.$fEnumInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt2_entry() //  [R1]
         { []
         }
     {offset
       c4wFP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wFQ; else goto c4wFR;
       c4wFQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wFR: // global
           (_c4wFK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wFK::I64 == 0) goto c4wFM; else goto c4wFL;
       c4wFM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wFL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wFK::I64;
           I64[Sp - 24] = block_c4wFN_info;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt2_info" {
     GHC.Int.$fEnumInt2_info:
         const GHC.Int.$fEnumInt2_entry;
         const 0;
         const 4294967317;
         const S4wm5_srt+8;
 },
 _c4wFN() //  [R1]
         { []
         }
     {offset
       c4wFN: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4wFN_info" {
     block_c4wFN_info:
         const _c4wFN;
         const 0;
         const 4294967326;
         const S4wm5_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.237428783 UTC

[section ""data" . GHC.Int.neInt16_closure" {
     GHC.Int.neInt16_closure:
         const GHC.Int.neInt16_info;
 },
 GHC.Int.neInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wGe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wGi; else goto c4wGj;
       c4wGi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wGj: // global
           I64[Sp - 16] = block_c4wGb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wGs; else goto c4wGc;
       u4wGs: // global
           call _c4wGb(R1) args: 0, res: 0, upd: 0;
       c4wGc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.neInt16_info" {
     GHC.Int.neInt16_info:
         const GHC.Int.neInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4wGb() //  [R1]
         { []
         }
     {offset
       c4wGb: // global
           I64[Sp] = block_c4wGh_info;
           _s4vyG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vyG::I64;
           if (R1 & 7 != 0) goto u4wGr; else goto c4wGl;
       u4wGr: // global
           call _c4wGh(R1) args: 0, res: 0, upd: 0;
       c4wGl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wGb_info" {
     block_c4wGb_info:
         const _c4wGb;
         const 1;
         const 30;
 },
 _c4wGh() //  [R1]
         { []
         }
     {offset
       c4wGh: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wGh_info" {
     block_c4wGh_info:
         const _c4wGh;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.245022786 UTC

[section ""data" . lvl2_r4kPt_closure" {
     lvl2_r4kPt_closure:
         const lvl2_r4kPt_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r4kPt_entry() //  [R1]
         { []
         }
     {offset
       c4wGT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wGU; else goto c4wGV;
       c4wGU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wGV: // global
           (_c4wGQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wGQ::I64 == 0) goto c4wGS; else goto c4wGR;
       c4wGS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wGR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wGQ::I64;
           R2 = GHC.Int.$tcInt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl2_r4kPt_info" {
     lvl2_r4kPt_info:
         const lvl2_r4kPt_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.249507247 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cminBound_closure" {
     GHC.Int.$fBoundedInt16_$cminBound_closure:
         const GHC.Int.I16#_con_info;
         const (-32768);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.252971568 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cpred_closure" {
     GHC.Int.$fEnumInt16_$cpred_closure:
         const GHC.Int.$fEnumInt16_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c4wHc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wHd; else goto c4wHe;
       c4wHd: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wHe: // global
           I64[Sp - 8] = block_c4wH9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wHw; else goto c4wHa;
       u4wHw: // global
           call _c4wH9(R1) args: 0, res: 0, upd: 0;
       c4wHa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cpred_info" {
     GHC.Int.$fEnumInt16_$cpred_info:
         const GHC.Int.$fEnumInt16_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+152;
 },
 _c4wH9() //  [R1]
         { []
         }
     {offset
       c4wH9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wHj; else goto c4wHi;
       c4wHj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wHi: // global
           _s4vyN::I64 = I64[R1 + 7];
           if (_s4vyN::I64 != (-32768)) goto c4wHu; else goto c4wHv;
       c4wHu: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vyN::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wHv: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wH9_info" {
     block_c4wH9_info:
         const _c4wH9;
         const 0;
         const 4294967326;
         const S4wm5_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.258472561 UTC

[section ""data" . GHC.Int.$fBoundedInt16_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt16_$cmaxBound_closure:
         const GHC.Int.I16#_con_info;
         const 32767;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.260229605 UTC

[section ""data" . GHC.Int.$fBoundedInt16_closure" {
     GHC.Int.$fBoundedInt16_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt16_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.263370638 UTC

[section ""data" . GHC.Int.$fEnumInt16_$csucc_closure" {
     GHC.Int.$fEnumInt16_$csucc_closure:
         const GHC.Int.$fEnumInt16_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c4wHV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wHW; else goto c4wHX;
       c4wHW: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wHX: // global
           I64[Sp - 8] = block_c4wHS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wIf; else goto c4wHT;
       u4wIf: // global
           call _c4wHS(R1) args: 0, res: 0, upd: 0;
       c4wHT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$csucc_info" {
     GHC.Int.$fEnumInt16_$csucc_info:
         const GHC.Int.$fEnumInt16_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+168;
 },
 _c4wHS() //  [R1]
         { []
         }
     {offset
       c4wHS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wI2; else goto c4wI1;
       c4wI2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4wI1: // global
           _s4vyT::I64 = I64[R1 + 7];
           if (_s4vyT::I64 != 32767) goto c4wId; else goto c4wIe;
       c4wId: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vyT::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wIe: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wHS_info" {
     block_c4wHS_info:
         const _c4wHS;
         const 0;
         const 4294967326;
         const S4wm5_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.27132281 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowsPrec_closure" {
     GHC.Int.$fShowInt16_$cshowsPrec_closure:
         const GHC.Int.$fShowInt16_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt16_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4wIC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wIN; else goto c4wIO;
       c4wIN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wIO: // global
           I64[Sp - 24] = block_c4wIz_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4wIV; else goto c4wIA;
       u4wIV: // global
           call _c4wIz(R1) args: 0, res: 0, upd: 0;
       c4wIA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt16_$cshowsPrec_info" {
     GHC.Int.$fShowInt16_$cshowsPrec_info:
         const GHC.Int.$fShowInt16_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c4wIz() //  [R1]
         { []
         }
     {offset
       c4wIz: // global
           I64[Sp] = block_c4wIF_info;
           _s4vz0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vz0::I64;
           if (R1 & 7 != 0) goto u4wIU; else goto c4wIG;
       u4wIU: // global
           call _c4wIF(R1) args: 0, res: 0, upd: 0;
       c4wIG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wIz_info" {
     block_c4wIz_info:
         const _c4wIz;
         const 2;
         const 30;
 },
 _c4wIF() //  [R1]
         { []
         }
     {offset
       c4wIF: // global
           _s4vyY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4wIK_info;
           R4 = _s4vyY::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wIF_info" {
     block_c4wIF_info:
         const _c4wIF;
         const 66;
         const 30;
 },
 _c4wIK() //  [R1, R2]
         { []
         }
     {offset
       c4wIK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wIT; else goto c4wIS;
       c4wIT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wIS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wIK_info" {
     block_c4wIK_info:
         const _c4wIK;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.281742451 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshow_closure" {
     GHC.Int.$fShowInt16_$cshow_closure:
         const GHC.Int.$fShowInt16_$cshow_info;
 },
 GHC.Int.$fShowInt16_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c4wJo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wJu; else goto c4wJv;
       c4wJu: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt16_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wJv: // global
           I64[Sp - 8] = block_c4wJl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wJA; else goto c4wJm;
       u4wJA: // global
           call _c4wJl(R1) args: 0, res: 0, upd: 0;
       c4wJm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt16_$cshow_info" {
     GHC.Int.$fShowInt16_$cshow_info:
         const GHC.Int.$fShowInt16_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4wJl() //  [R1]
         { []
         }
     {offset
       c4wJl: // global
           I64[Sp] = block_c4wJr_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wJl_info" {
     block_c4wJl_info:
         const _c4wJl;
         const 0;
         const 30;
 },
 _c4wJr() //  [R1, R2]
         { []
         }
     {offset
       c4wJr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wJz; else goto c4wJy;
       c4wJz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wJy: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wJr_info" {
     block_c4wJr_info:
         const _c4wJr;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.289874864 UTC

[section ""data" . GHC.Int.$fShowInt1_closure" {
     GHC.Int.$fShowInt1_closure:
         const GHC.Int.$fShowInt1_info;
 },
 GHC.Int.$fShowInt1_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wJZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wK5; else goto c4wK6;
       c4wK5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wK6: // global
           I64[Sp - 16] = block_c4wJW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wKb; else goto c4wJX;
       u4wKb: // global
           call _c4wJW(R1) args: 0, res: 0, upd: 0;
       c4wJX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt1_info" {
     GHC.Int.$fShowInt1_info:
         const GHC.Int.$fShowInt1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4wJW() //  [R1]
         { []
         }
     {offset
       c4wJW: // global
           _s4vzd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4wK2_info;
           R4 = _s4vzd::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wJW_info" {
     block_c4wJW_info:
         const _c4wJW;
         const 1;
         const 30;
 },
 _c4wK2() //  [R1, R2]
         { []
         }
     {offset
       c4wK2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wKa; else goto c4wK9;
       c4wKa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wK9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wK2_info" {
     block_c4wK2_info:
         const _c4wK2;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.297876194 UTC

[section ""data" . GHC.Int.$fShowInt16_$cshowList_closure" {
     GHC.Int.$fShowInt16_$cshowList_closure:
         const GHC.Int.$fShowInt16_$cshowList_info;
 },
 GHC.Int.$fShowInt16_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wKw: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt16_$cshowList_info" {
     GHC.Int.$fShowInt16_$cshowList_info:
         const GHC.Int.$fShowInt16_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.301079034 UTC

[section ""data" . GHC.Int.$fShowInt16_closure" {
     GHC.Int.$fShowInt16_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt16_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt16_$cshow_closure+1;
         const GHC.Int.$fShowInt16_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.303758321 UTC

[section ""data" . GHC.Int.$wlvl_closure" {
     GHC.Int.$wlvl_closure:
         const GHC.Int.$wlvl_info;
         const 0;
 },
 GHC.Int.$wlvl_entry() //  [R2]
         { []
         }
     {offset
       c4wKI: // global
           R6 = GHC.Int.$fBoundedInt16_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt16_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl2_r4kPt_closure;
           R2 = GHC.Int.$fShowInt16_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wlvl_info" {
     GHC.Int.$wlvl_info:
         const GHC.Int.$wlvl_entry;
         const 0;
         const 562954248388622;
         const 4294967300;
         const S4wm5_srt+48;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.307789141 UTC

[section ""data" . GHC.Int.$w$ctoEnum_closure" {
     GHC.Int.$w$ctoEnum_closure:
         const GHC.Int.$w$ctoEnum_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c4wKY: // global
           _s4vzm::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-32768))) goto c4wL6; else goto c4wKX;
       c4wKX: // global
           if (%MO_S_Gt_W64(_s4vzm::I64, 32767)) goto c4wL6; else goto c4wL7;
       c4wL6: // global
           R2 = _s4vzm::I64;
           call GHC.Int.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c4wL7: // global
           R1 = _s4vzm::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$ctoEnum_info" {
     GHC.Int.$w$ctoEnum_info:
         const GHC.Int.$w$ctoEnum_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S4wm5_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.313305778 UTC

[section ""data" . GHC.Int.$fEnumInt16_$ctoEnum_closure" {
     GHC.Int.$fEnumInt16_$ctoEnum_closure:
         const GHC.Int.$fEnumInt16_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c4wLk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wLs; else goto c4wLt;
       c4wLs: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wLt: // global
           I64[Sp - 8] = block_c4wLh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wLy; else goto c4wLi;
       u4wLy: // global
           call _c4wLh(R1) args: 0, res: 0, upd: 0;
       c4wLi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$ctoEnum_info" {
     GHC.Int.$fEnumInt16_$ctoEnum_info:
         const GHC.Int.$fEnumInt16_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+200;
 },
 _c4wLh() //  [R1]
         { []
         }
     {offset
       c4wLh: // global
           I64[Sp] = block_c4wLn_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wLh_info" {
     block_c4wLh_info:
         const _c4wLh;
         const 0;
         const 4294967326;
         const S4wm5_srt+208;
 },
 _c4wLn() //  [R1]
         { []
         }
     {offset
       c4wLn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wLx; else goto c4wLw;
       c4wLx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4wLw: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wLn_info" {
     block_c4wLn_info:
         const _c4wLn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.341130811 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo_closure" {
     GHC.Int.$w$cenumFromThenTo_closure:
         const GHC.Int.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s4vzM_entry() //  [R1]
         { []
         }
     {offset
       c4wMn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wMo; else goto c4wMp;
       c4wMo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wMp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4vzF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vzM_info" {
     sat_s4vzM_info:
         const sat_s4vzM_entry;
         const 8589934593;
         const 4294967311;
         const S4wm5_srt+192;
 },
 sat_s4vzK_entry() //  [R1]
         { []
         }
     {offset
       c4wMz: // global
           _s4vzK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wMA; else goto c4wMB;
       c4wMB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wMD; else goto c4wMC;
       c4wMD: // global
           HpAlloc = 16;
           goto c4wMA;
       c4wMA: // global
           R1 = _s4vzK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wMC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzK::P64;
           _s4vzG::I64 = I64[_s4vzK::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzG::I64,
                            (-32768))) goto c4wMJ; else goto c4wMy;
       c4wMy: // global
           if (%MO_S_Gt_W64(_s4vzG::I64, 32767)) goto c4wMJ; else goto c4wMN;
       c4wMJ: // global
           Hp = Hp - 16;
           R2 = _s4vzG::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wMN: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzG::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vzK_info" {
     sat_s4vzK_info:
         const sat_s4vzK_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+192;
 },
 sat_s4vzP_entry() //  [R1]
         { []
         }
     {offset
       c4wMY: // global
           _s4vzP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wMZ; else goto c4wN0;
       c4wN0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wN2; else goto c4wN1;
       c4wN2: // global
           HpAlloc = 16;
           goto c4wMZ;
       c4wMZ: // global
           R1 = _s4vzP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wN1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzP::P64;
           _s4vzG::I64 = I64[_s4vzP::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzG::I64,
                            (-32768))) goto c4wN8; else goto c4wMX;
       c4wMX: // global
           if (%MO_S_Gt_W64(_s4vzG::I64, 32767)) goto c4wN8; else goto c4wNc;
       c4wN8: // global
           Hp = Hp - 16;
           R2 = _s4vzG::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wNc: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzG::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vzP_info" {
     sat_s4vzP_info:
         const sat_s4vzP_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+192;
 },
 go_dn_s4vzF_entry() //  [R1, R2]
         { []
         }
     {offset
       c4wNg: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wNk; else goto c4wNj;
       c4wNk: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wNj: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4wNe; else goto c4wNf;
       c4wNe: // global
           _s4vzD::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vzM_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vzD::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vzK_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wNf: // global
           I64[Hp - 80] = sat_s4vzP_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wNm::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wNm::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s4vzF_info" {
     go_dn_s4vzF_info:
         const go_dn_s4vzF_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4wm5_srt+192;
 },
 sat_s4vzQ_entry() //  [R1]
         { []
         }
     {offset
       c4wNn: // global
           _s4vzQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wNo; else goto c4wNp;
       c4wNp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wNr; else goto c4wNq;
       c4wNr: // global
           HpAlloc = 24;
           goto c4wNo;
       c4wNo: // global
           R1 = _s4vzQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wNq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzQ::P64;
           _s4vzw::I64 = I64[_s4vzQ::P64 + 24];
           _s4vzD::I64 = _s4vzw::I64 - I64[_s4vzQ::P64 + 16];
           _s4vzE::I64 = I64[_s4vzQ::P64 + 32] - _s4vzD::I64;
           I64[Hp - 16] = go_dn_s4vzF_info;
           I64[Hp - 8] = _s4vzD::I64;
           I64[Hp] = _s4vzE::I64;
           R2 = _s4vzw::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4vzF_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vzQ_info" {
     sat_s4vzQ_info:
         const sat_s4vzQ_entry;
         const 12884901888;
         const 4294967311;
         const S4wm5_srt+192;
 },
 sat_s4vzC_entry() //  [R1]
         { []
         }
     {offset
       c4wNB: // global
           _s4vzC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wNC; else goto c4wND;
       c4wND: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wNF; else goto c4wNE;
       c4wNF: // global
           HpAlloc = 16;
           goto c4wNC;
       c4wNC: // global
           R1 = _s4vzC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wNE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzC::P64;
           _s4vzv::I64 = I64[_s4vzC::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzv::I64,
                            (-32768))) goto c4wNL; else goto c4wNA;
       c4wNA: // global
           if (%MO_S_Gt_W64(_s4vzv::I64, 32767)) goto c4wNL; else goto c4wNP;
       c4wNL: // global
           Hp = Hp - 16;
           R2 = _s4vzv::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wNP: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzv::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vzC_info" {
     sat_s4vzC_info:
         const sat_s4vzC_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+192;
 },
 sat_s4vzU_entry() //  [R1]
         { []
         }
     {offset
       c4wO3: // global
           _s4vzU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wO4; else goto c4wO5;
       c4wO5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wO7; else goto c4wO6;
       c4wO7: // global
           HpAlloc = 16;
           goto c4wO4;
       c4wO4: // global
           R1 = _s4vzU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wO6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzU::P64;
           _s4vzv::I64 = I64[_s4vzU::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzv::I64,
                            (-32768))) goto c4wOd; else goto c4wO2;
       c4wO2: // global
           if (%MO_S_Gt_W64(_s4vzv::I64, 32767)) goto c4wOd; else goto c4wOh;
       c4wOd: // global
           Hp = Hp - 16;
           R2 = _s4vzv::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wOh: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzv::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vzU_info" {
     sat_s4vzU_info:
         const sat_s4vzU_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+192;
 },
 sat_s4vA8_entry() //  [R1]
         { []
         }
     {offset
       c4wOK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wOL; else goto c4wOM;
       c4wOL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wOM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4vA1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vA8_info" {
     sat_s4vA8_info:
         const sat_s4vA8_entry;
         const 8589934593;
         const 4294967311;
         const S4wm5_srt+192;
 },
 sat_s4vA6_entry() //  [R1]
         { []
         }
     {offset
       c4wOW: // global
           _s4vA6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wOX; else goto c4wOY;
       c4wOY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wP0; else goto c4wOZ;
       c4wP0: // global
           HpAlloc = 16;
           goto c4wOX;
       c4wOX: // global
           R1 = _s4vA6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wOZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vA6::P64;
           _s4vA2::I64 = I64[_s4vA6::P64 + 16];
           if (%MO_S_Lt_W64(_s4vA2::I64,
                            (-32768))) goto c4wP6; else goto c4wOV;
       c4wOV: // global
           if (%MO_S_Gt_W64(_s4vA2::I64, 32767)) goto c4wP6; else goto c4wPa;
       c4wP6: // global
           Hp = Hp - 16;
           R2 = _s4vA2::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wPa: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vA2::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vA6_info" {
     sat_s4vA6_info:
         const sat_s4vA6_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+192;
 },
 sat_s4vAb_entry() //  [R1]
         { []
         }
     {offset
       c4wPl: // global
           _s4vAb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wPm; else goto c4wPn;
       c4wPn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wPp; else goto c4wPo;
       c4wPp: // global
           HpAlloc = 16;
           goto c4wPm;
       c4wPm: // global
           R1 = _s4vAb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wPo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vAb::P64;
           _s4vA2::I64 = I64[_s4vAb::P64 + 16];
           if (%MO_S_Lt_W64(_s4vA2::I64,
                            (-32768))) goto c4wPv; else goto c4wPk;
       c4wPk: // global
           if (%MO_S_Gt_W64(_s4vA2::I64, 32767)) goto c4wPv; else goto c4wPz;
       c4wPv: // global
           Hp = Hp - 16;
           R2 = _s4vA2::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wPz: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vA2::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vAb_info" {
     sat_s4vAb_info:
         const sat_s4vAb_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+192;
 },
 go_up_s4vA1_entry() //  [R1, R2]
         { []
         }
     {offset
       c4wPD: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wPH; else goto c4wPG;
       c4wPH: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wPG: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4wPB; else goto c4wPC;
       c4wPB: // global
           _s4vzZ::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vA8_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vzZ::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vA6_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wPC: // global
           I64[Hp - 80] = sat_s4vAb_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wPJ::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wPJ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s4vA1_info" {
     go_up_s4vA1_info:
         const go_up_s4vA1_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4wm5_srt+192;
 },
 sat_s4vAc_entry() //  [R1]
         { []
         }
     {offset
       c4wPK: // global
           _s4vAc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wPL; else goto c4wPM;
       c4wPM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wPO; else goto c4wPN;
       c4wPO: // global
           HpAlloc = 24;
           goto c4wPL;
       c4wPL: // global
           R1 = _s4vAc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wPN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vAc::P64;
           _s4vzw::I64 = I64[_s4vAc::P64 + 24];
           _s4vzZ::I64 = _s4vzw::I64 - I64[_s4vAc::P64 + 16];
           _s4vA0::I64 = I64[_s4vAc::P64 + 32] - _s4vzZ::I64;
           I64[Hp - 16] = go_up_s4vA1_info;
           I64[Hp - 8] = _s4vzZ::I64;
           I64[Hp] = _s4vA0::I64;
           R2 = _s4vzw::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4vA1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vAc_info" {
     sat_s4vAc_info:
         const sat_s4vAc_entry;
         const 12884901888;
         const 4294967311;
         const S4wm5_srt+192;
 },
 sat_s4vzY_entry() //  [R1]
         { []
         }
     {offset
       c4wPY: // global
           _s4vzY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wPZ; else goto c4wQ0;
       c4wQ0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wQ2; else goto c4wQ1;
       c4wQ2: // global
           HpAlloc = 16;
           goto c4wPZ;
       c4wPZ: // global
           R1 = _s4vzY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wQ1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vzY::P64;
           _s4vzv::I64 = I64[_s4vzY::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzv::I64,
                            (-32768))) goto c4wQ8; else goto c4wPX;
       c4wPX: // global
           if (%MO_S_Gt_W64(_s4vzv::I64, 32767)) goto c4wQ8; else goto c4wQc;
       c4wQ8: // global
           Hp = Hp - 16;
           R2 = _s4vzv::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wQc: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzv::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vzY_info" {
     sat_s4vzY_info:
         const sat_s4vzY_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+192;
 },
 sat_s4vAg_entry() //  [R1]
         { []
         }
     {offset
       c4wQq: // global
           _s4vAg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wQr; else goto c4wQs;
       c4wQs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wQu; else goto c4wQt;
       c4wQu: // global
           HpAlloc = 16;
           goto c4wQr;
       c4wQr: // global
           R1 = _s4vAg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wQt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vAg::P64;
           _s4vzv::I64 = I64[_s4vAg::P64 + 16];
           if (%MO_S_Lt_W64(_s4vzv::I64,
                            (-32768))) goto c4wQA; else goto c4wQp;
       c4wQp: // global
           if (%MO_S_Gt_W64(_s4vzv::I64, 32767)) goto c4wQA; else goto c4wQE;
       c4wQA: // global
           Hp = Hp - 16;
           R2 = _s4vzv::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wQE: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vzv::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vAg_info" {
     sat_s4vAg_info:
         const sat_s4vAg_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+192;
 },
 GHC.Int.$w$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4wQI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wQM; else goto c4wQL;
       c4wQM: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wQL: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4wQG; else goto c4wQH;
       c4wQG: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4wQP; else goto c4wQU;
       c4wQP: // global
           I64[Hp - 80] = sat_s4vzQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vzC_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wQU: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4wR1; else goto c4wQS;
       c4wQS: // global
           I64[Hp - 80] = sat_s4vzU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wQQ::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wQQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wQH: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4wQX; else goto c4wR2;
       c4wQX: // global
           I64[Hp - 80] = sat_s4vAc_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vzY_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wR2: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4wR1; else goto c4wR0;
       c4wR1: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4wR0: // global
           I64[Hp - 80] = sat_s4vAg_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4wQY::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4wQY::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromThenTo_info" {
     GHC.Int.$w$cenumFromThenTo_info:
         const GHC.Int.$w$cenumFromThenTo_entry;
         const 0;
         const 38654705678;
         const 12884901904;
         const S4wm5_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.385340582 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4wTw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wTF; else goto c4wTG;
       c4wTF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wTG: // global
           I64[Sp - 24] = block_c4wTt_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4wTP; else goto c4wTu;
       u4wTP: // global
           call _c4wTt(R1) args: 0, res: 0, upd: 0;
       c4wTu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cenumFromThenTo_info" {
     GHC.Int.$fEnumInt16_$cenumFromThenTo_info:
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S4wm5_srt+216;
 },
 _c4wTt() //  [R1]
         { []
         }
     {offset
       c4wTt: // global
           I64[Sp] = block_c4wTz_info;
           _s4vAl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vAl::I64;
           if (R1 & 7 != 0) goto u4wTO; else goto c4wTA;
       u4wTO: // global
           call _c4wTz(R1) args: 0, res: 0, upd: 0;
       c4wTA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wTt_info" {
     block_c4wTt_info:
         const _c4wTt;
         const 2;
         const 4294967326;
         const S4wm5_srt+216;
 },
 _c4wTz() //  [R1]
         { []
         }
     {offset
       c4wTz: // global
           I64[Sp] = block_c4wTE_info;
           _s4vAn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vAn::I64;
           if (R1 & 7 != 0) goto u4wTQ; else goto c4wTJ;
       u4wTQ: // global
           call _c4wTE(R1) args: 0, res: 0, upd: 0;
       c4wTJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wTz_info" {
     block_c4wTz_info:
         const _c4wTz;
         const 66;
         const 4294967326;
         const S4wm5_srt+216;
 },
 _c4wTE() //  [R1]
         { []
         }
     {offset
       c4wTE: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wTE_info" {
     block_c4wTE_info:
         const _c4wTE;
         const 194;
         const 4294967326;
         const S4wm5_srt+216;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.397331444 UTC

[section ""data" . GHC.Int.$w$cenumFromTo_closure" {
     GHC.Int.$w$cenumFromTo_closure:
         const GHC.Int.$w$cenumFromTo_info;
         const 0;
 },
 sat_s4vAA_entry() //  [R1]
         { []
         }
     {offset
       c4wUw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wUx; else goto c4wUy;
       c4wUx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wUy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vAu::I64 = I64[R1 + 32];
           if (_s4vAu::I64 == I64[R1 + 24]) goto c4wUv; else goto c4wUu;
       c4wUv: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4wUu: // global
           R2 = _s4vAu::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4vAt_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vAA_info" {
     sat_s4vAA_info:
         const sat_s4vAA_entry;
         const 8589934593;
         const 4294967311;
         const S4wm5_srt+192;
 },
 sat_s4vAx_entry() //  [R1]
         { []
         }
     {offset
       c4wUK: // global
           _s4vAx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wUL; else goto c4wUM;
       c4wUM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wUO; else goto c4wUN;
       c4wUO: // global
           HpAlloc = 16;
           goto c4wUL;
       c4wUL: // global
           R1 = _s4vAx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wUN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vAx::P64;
           _s4vAu::I64 = I64[_s4vAx::P64 + 16];
           if (%MO_S_Lt_W64(_s4vAu::I64,
                            (-32768))) goto c4wUU; else goto c4wUJ;
       c4wUJ: // global
           if (%MO_S_Gt_W64(_s4vAu::I64, 32767)) goto c4wUU; else goto c4wUY;
       c4wUU: // global
           Hp = Hp - 16;
           R2 = _s4vAu::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wUY: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vAu::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vAx_info" {
     sat_s4vAx_info:
         const sat_s4vAx_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+192;
 },
 go_s4vAt_entry() //  [R1, R2]
         { []
         }
     {offset
       c4wV0: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4wV4; else goto c4wV3;
       c4wV4: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wV3: // global
           _s4vAr::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vAA_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vAr::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vAx_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s4vAt_info" {
     go_s4vAt_info:
         const go_s4vAt_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S4wm5_srt+192;
 },
 GHC.Int.$w$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wV8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wVc; else goto c4wVb;
       c4wVc: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wVb: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4wV6; else goto c4wV7;
       c4wV6: // global
           I64[Hp - 8] = go_s4vAt_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4vAt_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4wV7: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromTo_info" {
     GHC.Int.$w$cenumFromTo_info:
         const GHC.Int.$w$cenumFromTo_entry;
         const 0;
         const 141733920782;
         const 8589934604;
         const S4wm5_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.408066873 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt16_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt16_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wVO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wVS; else goto c4wVT;
       c4wVS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wVT: // global
           I64[Sp - 16] = block_c4wVL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wW1; else goto c4wVM;
       u4wW1: // global
           call _c4wVL(R1) args: 0, res: 0, upd: 0;
       c4wVM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cenumFromTo_info" {
     GHC.Int.$fEnumInt16_$cenumFromTo_info:
         const GHC.Int.$fEnumInt16_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+232;
 },
 _c4wVL() //  [R1]
         { []
         }
     {offset
       c4wVL: // global
           I64[Sp] = block_c4wVR_info;
           _s4vAE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vAE::I64;
           if (R1 & 7 != 0) goto u4wW0; else goto c4wVV;
       u4wW0: // global
           call _c4wVR(R1) args: 0, res: 0, upd: 0;
       c4wVV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wVL_info" {
     block_c4wVL_info:
         const _c4wVL;
         const 1;
         const 4294967326;
         const S4wm5_srt+232;
 },
 _c4wVR() //  [R1]
         { []
         }
     {offset
       c4wVR: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wVR_info" {
     block_c4wVR_info:
         const _c4wVR;
         const 65;
         const 4294967326;
         const S4wm5_srt+232;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.418029523 UTC

[section ""data" . GHC.Int.$wgo_closure" {
     GHC.Int.$wgo_closure:
         const GHC.Int.$wgo_info;
         const 0;
 },
 sat_s4vAQ_entry() //  [R1]
         { []
         }
     {offset
       c4wWt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wWu; else goto c4wWF;
       c4wWu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wWF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vAL::I64 = I64[R1 + 16];
           if (_s4vAL::I64 != 32767) goto c4wWr; else goto c4wWs;
       c4wWr: // global
           I64[Sp - 24] = block_c4wWz_info;
           R2 = _s4vAL::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 24;
       c4wWs: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vAQ_info" {
     sat_s4vAQ_info:
         const sat_s4vAQ_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+248;
 },
 _c4wWz() //  [R1, R2]
         { []
         }
     {offset
       c4wWz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wWE; else goto c4wWD;
       c4wWE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4wWD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4wWz_info" {
     block_c4wWz_info:
         const _c4wWz;
         const 0;
         const 30;
 },
 sat_s4vAK_entry() //  [R1]
         { []
         }
     {offset
       c4wWP: // global
           _s4vAK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4wWQ; else goto c4wWR;
       c4wWR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4wWT; else goto c4wWS;
       c4wWT: // global
           HpAlloc = 16;
           goto c4wWQ;
       c4wWQ: // global
           R1 = _s4vAK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wWS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vAK::P64;
           _s4vAH::I64 = I64[_s4vAK::P64 + 16];
           if (%MO_S_Lt_W64(_s4vAH::I64,
                            (-32768))) goto c4wWZ; else goto c4wWO;
       c4wWO: // global
           if (%MO_S_Gt_W64(_s4vAH::I64, 32767)) goto c4wWZ; else goto c4wX3;
       c4wWZ: // global
           Hp = Hp - 16;
           R2 = _s4vAH::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       c4wX3: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vAH::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vAK_info" {
     sat_s4vAK_info:
         const sat_s4vAK_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+192;
 },
 GHC.Int.$wgo_entry() //  [R2]
         { []
         }
     {offset
       c4wX4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4wX8; else goto c4wX7;
       c4wX8: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wX7: // global
           I64[Hp - 40] = sat_s4vAQ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4vAK_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wgo_info" {
     GHC.Int.$wgo_info:
         const GHC.Int.$wgo_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const S4wm5_srt+192;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.428154305 UTC

[section ""data" . GHC.Int.$fEnumInt16_go_closure" {
     GHC.Int.$fEnumInt16_go_closure:
         const GHC.Int.$fEnumInt16_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_go_entry() //  [R2]
         { []
         }
     {offset
       c4wXH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wXI; else goto c4wXJ;
       c4wXI: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wXJ: // global
           I64[Sp - 8] = block_c4wXE_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_go_info" {
     GHC.Int.$fEnumInt16_go_info:
         const GHC.Int.$fEnumInt16_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S4wm5_srt+248;
 },
 _c4wXE() //  [R1, R2]
         { []
         }
     {offset
       c4wXE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4wXM; else goto c4wXL;
       c4wXM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4wXL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wXE_info" {
     block_c4wXE_info:
         const _c4wXE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.434471252 UTC

[section ""data" . GHC.Int.$fEnumInt16_$cenumFrom_closure" {
     GHC.Int.$fEnumInt16_$cenumFrom_closure:
         const GHC.Int.$fEnumInt16_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c4wY5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4wY6; else goto c4wY7;
       c4wY6: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt16_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4wY7: // global
           I64[Sp - 8] = block_c4wY2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4wYg; else goto c4wY3;
       u4wYg: // global
           call _c4wY2(R1) args: 0, res: 0, upd: 0;
       c4wY3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cenumFrom_info" {
     GHC.Int.$fEnumInt16_$cenumFrom_info:
         const GHC.Int.$fEnumInt16_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+256;
 },
 _c4wY2() //  [R1]
         { []
         }
     {offset
       c4wY2: // global
           _s4vAX::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4vAX::I64, 32767)) goto c4wYe; else goto c4wYf;
       c4wYe: // global
           R2 = _s4vAX::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_go_entry(R2) args: 8, res: 0, upd: 8;
       c4wYf: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wY2_info" {
     block_c4wY2_info:
         const _c4wY2;
         const 0;
         const 4294967326;
         const S4wm5_srt+256;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.440871178 UTC

[section ""data" . GHC.Int.$fEnumInt16_closure" {
     GHC.Int.$fEnumInt16_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt16_$csucc_closure+1;
         const GHC.Int.$fEnumInt16_$cpred_closure+1;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt16_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt16_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt16_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt16_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt16_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wYx: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt16_closure+1;
           R2 = GHC.Int.$fEnumInt16_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt16_$cenumFromThen_info" {
     GHC.Int.$fEnumInt16_$cenumFromThen_info:
         const GHC.Int.$fEnumInt16_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S4wm5_srt+272;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.444753801 UTC

[section ""cstring" . GHC.Int.$tcInt4_bytes" {
     GHC.Int.$tcInt4_bytes:
         I8[] [73,110,116,51,50]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.447400145 UTC

[section ""data" . GHC.Int.$fEnumInt3_closure" {
     GHC.Int.$fEnumInt3_closure:
         const GHC.Int.$fEnumInt3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt3_entry() //  [R1]
         { []
         }
     {offset
       c4wYO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wYP; else goto c4wYQ;
       c4wYP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wYQ: // global
           (_c4wYJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wYJ::I64 == 0) goto c4wYL; else goto c4wYK;
       c4wYL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wYK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wYJ::I64;
           I64[Sp - 24] = block_c4wYM_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt3_info" {
     GHC.Int.$fEnumInt3_info:
         const GHC.Int.$fEnumInt3_entry;
         const 0;
         const 4294967317;
         const S4wm5_srt+280;
 },
 _c4wYM() //  [R1]
         { []
         }
     {offset
       c4wYM: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4wYM_info" {
     block_c4wYM_info:
         const _c4wYM;
         const 0;
         const 4294967326;
         const S4wm5_srt+280;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.453723651 UTC

[section ""data" . GHC.Int.$fEnumInt4_closure" {
     GHC.Int.$fEnumInt4_closure:
         const GHC.Int.$fEnumInt4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt4_entry() //  [R1]
         { []
         }
     {offset
       c4wZe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4wZf; else goto c4wZg;
       c4wZf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4wZg: // global
           (_c4wZ9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4wZ9::I64 == 0) goto c4wZb; else goto c4wZa;
       c4wZb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4wZa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4wZ9::I64;
           I64[Sp - 24] = block_c4wZc_info;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt4_info" {
     GHC.Int.$fEnumInt4_info:
         const GHC.Int.$fEnumInt4_entry;
         const 0;
         const 4294967317;
         const S4wm5_srt+288;
 },
 _c4wZc() //  [R1]
         { []
         }
     {offset
       c4wZc: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4wZc_info" {
     block_c4wZc_info:
         const _c4wZc;
         const 0;
         const 4294967326;
         const S4wm5_srt+288;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.460738945 UTC

[section ""data" . GHC.Int.neInt32_closure" {
     GHC.Int.neInt32_closure:
         const GHC.Int.neInt32_info;
 },
 GHC.Int.neInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4wZD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4wZH; else goto c4wZI;
       c4wZH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4wZI: // global
           I64[Sp - 16] = block_c4wZA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4wZR; else goto c4wZB;
       u4wZR: // global
           call _c4wZA(R1) args: 0, res: 0, upd: 0;
       c4wZB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.neInt32_info" {
     GHC.Int.neInt32_info:
         const GHC.Int.neInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4wZA() //  [R1]
         { []
         }
     {offset
       c4wZA: // global
           I64[Sp] = block_c4wZG_info;
           _s4vB4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vB4::I64;
           if (R1 & 7 != 0) goto u4wZQ; else goto c4wZK;
       u4wZQ: // global
           call _c4wZG(R1) args: 0, res: 0, upd: 0;
       c4wZK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wZA_info" {
     block_c4wZA_info:
         const _c4wZA;
         const 1;
         const 30;
 },
 _c4wZG() //  [R1]
         { []
         }
     {offset
       c4wZG: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4wZG_info" {
     block_c4wZG_info:
         const _c4wZG;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.467959225 UTC

[section ""data" . lvl4_r4kPv_closure" {
     lvl4_r4kPv_closure:
         const lvl4_r4kPv_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r4kPv_entry() //  [R1]
         { []
         }
     {offset
       c4x0i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4x0j; else goto c4x0k;
       c4x0j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4x0k: // global
           (_c4x0f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4x0f::I64 == 0) goto c4x0h; else goto c4x0g;
       c4x0h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4x0g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4x0f::I64;
           R2 = GHC.Int.$tcInt4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl4_r4kPv_info" {
     lvl4_r4kPv_info:
         const lvl4_r4kPv_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.472067599 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cminBound_closure" {
     GHC.Int.$fBoundedInt32_$cminBound_closure:
         const GHC.Int.I32#_con_info;
         const (-2147483648);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.475051218 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cpred_closure" {
     GHC.Int.$fEnumInt32_$cpred_closure:
         const GHC.Int.$fEnumInt32_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c4x0B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x0C; else goto c4x0D;
       c4x0C: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x0D: // global
           I64[Sp - 8] = block_c4x0y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4x0V; else goto c4x0z;
       u4x0V: // global
           call _c4x0y(R1) args: 0, res: 0, upd: 0;
       c4x0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cpred_info" {
     GHC.Int.$fEnumInt32_$cpred_info:
         const GHC.Int.$fEnumInt32_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+296;
 },
 _c4x0y() //  [R1]
         { []
         }
     {offset
       c4x0y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x0I; else goto c4x0H;
       c4x0I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4x0H: // global
           _s4vBb::I64 = I64[R1 + 7];
           if (_s4vBb::I64 != (-2147483648)) goto c4x0T; else goto c4x0U;
       c4x0T: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4vBb::I64 - 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4x0U: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x0y_info" {
     block_c4x0y_info:
         const _c4x0y;
         const 0;
         const 4294967326;
         const S4wm5_srt+304;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.481289714 UTC

[section ""data" . GHC.Int.$fBoundedInt32_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt32_$cmaxBound_closure:
         const GHC.Int.I32#_con_info;
         const 2147483647;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.483051686 UTC

[section ""data" . GHC.Int.$fBoundedInt32_closure" {
     GHC.Int.$fBoundedInt32_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt32_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.486487673 UTC

[section ""data" . GHC.Int.$fEnumInt32_$csucc_closure" {
     GHC.Int.$fEnumInt32_$csucc_closure:
         const GHC.Int.$fEnumInt32_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c4x1k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x1l; else goto c4x1m;
       c4x1l: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x1m: // global
           I64[Sp - 8] = block_c4x1h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4x1E; else goto c4x1i;
       u4x1E: // global
           call _c4x1h(R1) args: 0, res: 0, upd: 0;
       c4x1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$csucc_info" {
     GHC.Int.$fEnumInt32_$csucc_info:
         const GHC.Int.$fEnumInt32_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+312;
 },
 _c4x1h() //  [R1]
         { []
         }
     {offset
       c4x1h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x1r; else goto c4x1q;
       c4x1r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4x1q: // global
           _s4vBh::I64 = I64[R1 + 7];
           if (_s4vBh::I64 != 2147483647) goto c4x1C; else goto c4x1D;
       c4x1C: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4vBh::I64 + 1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4x1D: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x1h_info" {
     block_c4x1h_info:
         const _c4x1h;
         const 0;
         const 4294967326;
         const S4wm5_srt+320;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.493537873 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowsPrec_closure" {
     GHC.Int.$fShowInt32_$cshowsPrec_closure:
         const GHC.Int.$fShowInt32_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt32_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4x21: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4x2c; else goto c4x2d;
       c4x2c: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4x2d: // global
           I64[Sp - 24] = block_c4x1Y_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4x2k; else goto c4x1Z;
       u4x2k: // global
           call _c4x1Y(R1) args: 0, res: 0, upd: 0;
       c4x1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt32_$cshowsPrec_info" {
     GHC.Int.$fShowInt32_$cshowsPrec_info:
         const GHC.Int.$fShowInt32_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c4x1Y() //  [R1]
         { []
         }
     {offset
       c4x1Y: // global
           I64[Sp] = block_c4x24_info;
           _s4vBo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vBo::I64;
           if (R1 & 7 != 0) goto u4x2j; else goto c4x25;
       u4x2j: // global
           call _c4x24(R1) args: 0, res: 0, upd: 0;
       c4x25: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x1Y_info" {
     block_c4x1Y_info:
         const _c4x1Y;
         const 2;
         const 30;
 },
 _c4x24() //  [R1]
         { []
         }
     {offset
       c4x24: // global
           _s4vBm::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4x29_info;
           R4 = _s4vBm::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x24_info" {
     block_c4x24_info:
         const _c4x24;
         const 66;
         const 30;
 },
 _c4x29() //  [R1, R2]
         { []
         }
     {offset
       c4x29: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4x2i; else goto c4x2h;
       c4x2i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4x2h: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x29_info" {
     block_c4x29_info:
         const _c4x29;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.503625109 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshow_closure" {
     GHC.Int.$fShowInt32_$cshow_closure:
         const GHC.Int.$fShowInt32_$cshow_info;
 },
 GHC.Int.$fShowInt32_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c4x2N: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x2T; else goto c4x2U;
       c4x2T: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt32_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x2U: // global
           I64[Sp - 8] = block_c4x2K_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4x2Z; else goto c4x2L;
       u4x2Z: // global
           call _c4x2K(R1) args: 0, res: 0, upd: 0;
       c4x2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt32_$cshow_info" {
     GHC.Int.$fShowInt32_$cshow_info:
         const GHC.Int.$fShowInt32_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4x2K() //  [R1]
         { []
         }
     {offset
       c4x2K: // global
           I64[Sp] = block_c4x2Q_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x2K_info" {
     block_c4x2K_info:
         const _c4x2K;
         const 0;
         const 30;
 },
 _c4x2Q() //  [R1, R2]
         { []
         }
     {offset
       c4x2Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4x2Y; else goto c4x2X;
       c4x2Y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4x2X: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x2Q_info" {
     block_c4x2Q_info:
         const _c4x2Q;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.511848233 UTC

[section ""data" . GHC.Int.$fShowInt2_closure" {
     GHC.Int.$fShowInt2_closure:
         const GHC.Int.$fShowInt2_info;
 },
 GHC.Int.$fShowInt2_entry() //  [R2, R3]
         { []
         }
     {offset
       c4x3o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4x3u; else goto c4x3v;
       c4x3u: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4x3v: // global
           I64[Sp - 16] = block_c4x3l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4x3A; else goto c4x3m;
       u4x3A: // global
           call _c4x3l(R1) args: 0, res: 0, upd: 0;
       c4x3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt2_info" {
     GHC.Int.$fShowInt2_info:
         const GHC.Int.$fShowInt2_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4x3l() //  [R1]
         { []
         }
     {offset
       c4x3l: // global
           _s4vBB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4x3r_info;
           R4 = _s4vBB::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x3l_info" {
     block_c4x3l_info:
         const _c4x3l;
         const 1;
         const 30;
 },
 _c4x3r() //  [R1, R2]
         { []
         }
     {offset
       c4x3r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4x3z; else goto c4x3y;
       c4x3z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4x3y: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x3r_info" {
     block_c4x3r_info:
         const _c4x3r;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.519478795 UTC

[section ""data" . GHC.Int.$fShowInt32_$cshowList_closure" {
     GHC.Int.$fShowInt32_$cshowList_closure:
         const GHC.Int.$fShowInt32_$cshowList_info;
 },
 GHC.Int.$fShowInt32_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c4x3V: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt2_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt32_$cshowList_info" {
     GHC.Int.$fShowInt32_$cshowList_info:
         const GHC.Int.$fShowInt32_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.523244619 UTC

[section ""data" . GHC.Int.$fShowInt32_closure" {
     GHC.Int.$fShowInt32_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt32_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt32_$cshow_closure+1;
         const GHC.Int.$fShowInt32_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.525642153 UTC

[section ""data" . GHC.Int.$wlvl1_closure" {
     GHC.Int.$wlvl1_closure:
         const GHC.Int.$wlvl1_info;
         const 0;
 },
 GHC.Int.$wlvl1_entry() //  [R2]
         { []
         }
     {offset
       c4x47: // global
           R6 = GHC.Int.$fBoundedInt32_$cmaxBound_closure+1;
           R5 = GHC.Int.$fBoundedInt32_$cminBound_closure+1;
           R4 = R2;
           R3 = lvl4_r4kPv_closure;
           R2 = GHC.Int.$fShowInt32_closure+1;
           call GHC.Enum.$wtoEnumError_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wlvl1_info" {
     GHC.Int.$wlvl1_info:
         const GHC.Int.$wlvl1_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S4wm5_srt+328;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.529971245 UTC

[section ""data" . GHC.Int.$w$ctoEnum1_closure" {
     GHC.Int.$w$ctoEnum1_closure:
         const GHC.Int.$w$ctoEnum1_info;
         const 0;
 },
 GHC.Int.$w$ctoEnum1_entry() //  [R2]
         { []
         }
     {offset
       c4x4n: // global
           _s4vBK::I64 = R2;
           if (%MO_S_Lt_W64(R2, (-2147483648))) goto c4x4v; else goto c4x4m;
       c4x4m: // global
           if (%MO_S_Gt_W64(_s4vBK::I64,
                            2147483647)) goto c4x4v; else goto c4x4w;
       c4x4v: // global
           R2 = _s4vBK::I64;
           call GHC.Int.$wlvl1_entry(R2) args: 8, res: 0, upd: 8;
       c4x4w: // global
           R1 = _s4vBK::I64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$ctoEnum1_info" {
     GHC.Int.$w$ctoEnum1_info:
         const GHC.Int.$w$ctoEnum1_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const S4wm5_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.534670507 UTC

[section ""data" . GHC.Int.$fEnumInt32_$ctoEnum_closure" {
     GHC.Int.$fEnumInt32_$ctoEnum_closure:
         const GHC.Int.$fEnumInt32_$ctoEnum_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       c4x4J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x4R; else goto c4x4S;
       c4x4R: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x4S: // global
           I64[Sp - 8] = block_c4x4G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4x4X; else goto c4x4H;
       u4x4X: // global
           call _c4x4G(R1) args: 0, res: 0, upd: 0;
       c4x4H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$ctoEnum_info" {
     GHC.Int.$fEnumInt32_$ctoEnum_info:
         const GHC.Int.$fEnumInt32_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+352;
 },
 _c4x4G() //  [R1]
         { []
         }
     {offset
       c4x4G: // global
           I64[Sp] = block_c4x4M_info;
           R2 = I64[R1 + 7];
           call GHC.Int.$w$ctoEnum1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x4G_info" {
     block_c4x4G_info:
         const _c4x4G;
         const 0;
         const 4294967326;
         const S4wm5_srt+360;
 },
 _c4x4M() //  [R1]
         { []
         }
     {offset
       c4x4M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x4W; else goto c4x4V;
       c4x4W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4x4V: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x4M_info" {
     block_c4x4M_info:
         const _c4x4M;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.544498295 UTC

[section ""data" . GHC.Int.$w$cenumFromTo1_closure" {
     GHC.Int.$w$cenumFromTo1_closure:
         const GHC.Int.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s4vC3_entry() //  [R1]
         { []
         }
     {offset
       c4x5z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4x5A; else goto c4x5B;
       c4x5A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4x5B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vBX::I64 = I64[R1 + 32];
           if (_s4vBX::I64 == I64[R1 + 24]) goto c4x5y; else goto c4x5x;
       c4x5y: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4x5x: // global
           R2 = _s4vBX::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s4vBW_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vC3_info" {
     sat_s4vC3_info:
         const sat_s4vC3_entry;
         const 8589934593;
         const 4294967311;
         const S4wm5_srt+344;
 },
 sat_s4vC0_entry() //  [R1]
         { []
         }
     {offset
       c4x5N: // global
           _s4vC0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4x5O; else goto c4x5P;
       c4x5P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x5R; else goto c4x5Q;
       c4x5R: // global
           HpAlloc = 16;
           goto c4x5O;
       c4x5O: // global
           R1 = _s4vC0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4x5Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vC0::P64;
           _s4vBX::I64 = I64[_s4vC0::P64 + 16];
           if (%MO_S_Lt_W64(_s4vBX::I64,
                            (-2147483648))) goto c4x5X; else goto c4x5M;
       c4x5M: // global
           if (%MO_S_Gt_W64(_s4vBX::I64,
                            2147483647)) goto c4x5X; else goto c4x61;
       c4x5X: // global
           Hp = Hp - 16;
           R2 = _s4vBX::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4x61: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vBX::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vC0_info" {
     sat_s4vC0_info:
         const sat_s4vC0_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+344;
 },
 go_s4vBW_entry() //  [R1, R2]
         { []
         }
     {offset
       c4x63: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4x67; else goto c4x66;
       c4x67: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x66: // global
           _s4vBU::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vC3_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vBU::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vC0_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_s4vBW_info" {
     go_s4vBW_info:
         const go_s4vBW_entry;
         const 4294967296;
         const 4294967306;
         const 4294967300;
         const S4wm5_srt+344;
 },
 GHC.Int.$w$cenumFromTo1_entry() //  [R2, R3]
         { []
         }
     {offset
       c4x6b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x6f; else goto c4x6e;
       c4x6f: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4x6e: // global
           if (%MO_S_Le_W64(R2, R3)) goto c4x69; else goto c4x6a;
       c4x69: // global
           I64[Hp - 8] = go_s4vBW_info;
           I64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s4vBW_entry(R2, R1) args: 8, res: 0, upd: 8;
       c4x6a: // global
           Hp = Hp - 16;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromTo1_info" {
     GHC.Int.$w$cenumFromTo1_info:
         const GHC.Int.$w$cenumFromTo1_entry;
         const 0;
         const 38654705678;
         const 8589934604;
         const S4wm5_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.55568138 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       c4x6R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4x6V; else goto c4x6W;
       c4x6V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4x6W: // global
           I64[Sp - 16] = block_c4x6O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4x74; else goto c4x6P;
       u4x74: // global
           call _c4x6O(R1) args: 0, res: 0, upd: 0;
       c4x6P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cenumFromTo_info" {
     GHC.Int.$fEnumInt32_$cenumFromTo_info:
         const GHC.Int.$fEnumInt32_$cenumFromTo_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+368;
 },
 _c4x6O() //  [R1]
         { []
         }
     {offset
       c4x6O: // global
           I64[Sp] = block_c4x6U_info;
           _s4vC7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vC7::I64;
           if (R1 & 7 != 0) goto u4x73; else goto c4x6Y;
       u4x73: // global
           call _c4x6U(R1) args: 0, res: 0, upd: 0;
       c4x6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x6O_info" {
     block_c4x6O_info:
         const _c4x6O;
         const 1;
         const 4294967326;
         const S4wm5_srt+368;
 },
 _c4x6U() //  [R1]
         { []
         }
     {offset
       c4x6U: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Int.$w$cenumFromTo1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x6U_info" {
     block_c4x6U_info:
         const _c4x6U;
         const 65;
         const 4294967326;
         const S4wm5_srt+368;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.565891477 UTC

[section ""data" . GHC.Int.$wgo1_closure" {
     GHC.Int.$wgo1_closure:
         const GHC.Int.$wgo1_info;
         const 0;
 },
 sat_s4vCj_entry() //  [R1]
         { []
         }
     {offset
       c4x7w: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4x7x; else goto c4x7I;
       c4x7x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4x7I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vCe::I64 = I64[R1 + 16];
           if (_s4vCe::I64 != 2147483647) goto c4x7u; else goto c4x7v;
       c4x7u: // global
           I64[Sp - 24] = block_c4x7C_info;
           R2 = _s4vCe::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 24;
       c4x7v: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vCj_info" {
     sat_s4vCj_info:
         const sat_s4vCj_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+384;
 },
 _c4x7C() //  [R1, R2]
         { []
         }
     {offset
       c4x7C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4x7H; else goto c4x7G;
       c4x7H: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4x7G: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4x7C_info" {
     block_c4x7C_info:
         const _c4x7C;
         const 0;
         const 30;
 },
 sat_s4vCd_entry() //  [R1]
         { []
         }
     {offset
       c4x7S: // global
           _s4vCd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4x7T; else goto c4x7U;
       c4x7U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4x7W; else goto c4x7V;
       c4x7W: // global
           HpAlloc = 16;
           goto c4x7T;
       c4x7T: // global
           R1 = _s4vCd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4x7V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCd::P64;
           _s4vCa::I64 = I64[_s4vCd::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCa::I64,
                            (-2147483648))) goto c4x82; else goto c4x7R;
       c4x7R: // global
           if (%MO_S_Gt_W64(_s4vCa::I64,
                            2147483647)) goto c4x82; else goto c4x86;
       c4x82: // global
           Hp = Hp - 16;
           R2 = _s4vCa::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4x86: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCa::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vCd_info" {
     sat_s4vCd_info:
         const sat_s4vCd_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+344;
 },
 GHC.Int.$wgo1_entry() //  [R2]
         { []
         }
     {offset
       c4x87: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4x8b; else goto c4x8a;
       c4x8b: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.Int.$wgo1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x8a: // global
           I64[Hp - 40] = sat_s4vCj_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s4vCd_info;
           I64[Hp] = R2;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wgo1_info" {
     GHC.Int.$wgo1_info:
         const GHC.Int.$wgo1_entry;
         const 0;
         const 141733920782;
         const 4294967300;
         const S4wm5_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.57602998 UTC

[section ""data" . GHC.Int.$fEnumInt32_go_closure" {
     GHC.Int.$fEnumInt32_go_closure:
         const GHC.Int.$fEnumInt32_go_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_go_entry() //  [R2]
         { []
         }
     {offset
       c4x8K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x8L; else goto c4x8M;
       c4x8L: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x8M: // global
           I64[Sp - 8] = block_c4x8H_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_go_info" {
     GHC.Int.$fEnumInt32_go_info:
         const GHC.Int.$fEnumInt32_go_entry;
         const 0;
         const 12884901902;
         const 4294967300;
         const S4wm5_srt+384;
 },
 _c4x8H() //  [R1, R2]
         { []
         }
     {offset
       c4x8H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4x8P; else goto c4x8O;
       c4x8P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4x8O: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x8H_info" {
     block_c4x8H_info:
         const _c4x8H;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.582816353 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFrom_closure" {
     GHC.Int.$fEnumInt32_$cenumFrom_closure:
         const GHC.Int.$fEnumInt32_$cenumFrom_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c4x98: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4x99; else goto c4x9a;
       c4x99: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4x9a: // global
           I64[Sp - 8] = block_c4x95_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4x9j; else goto c4x96;
       u4x9j: // global
           call _c4x95(R1) args: 0, res: 0, upd: 0;
       c4x96: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cenumFrom_info" {
     GHC.Int.$fEnumInt32_$cenumFrom_info:
         const GHC.Int.$fEnumInt32_$cenumFrom_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+392;
 },
 _c4x95() //  [R1]
         { []
         }
     {offset
       c4x95: // global
           _s4vCq::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4vCq::I64,
                            2147483647)) goto c4x9h; else goto c4x9i;
       c4x9h: // global
           R2 = _s4vCq::I64;
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_go_entry(R2) args: 8, res: 0, upd: 8;
       c4x9i: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4x95_info" {
     block_c4x95_info:
         const _c4x95;
         const 0;
         const 4294967326;
         const S4wm5_srt+392;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.60062944 UTC

[section ""data" . GHC.Int.$w$cenumFromThenTo1_closure" {
     GHC.Int.$w$cenumFromThenTo1_closure:
         const GHC.Int.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s4vCJ_entry() //  [R1]
         { []
         }
     {offset
       c4xa4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xa5; else goto c4xa6;
       c4xa5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xa6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_s4vCC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vCJ_info" {
     sat_s4vCJ_info:
         const sat_s4vCJ_entry;
         const 8589934593;
         const 4294967311;
         const S4wm5_srt+344;
 },
 sat_s4vCH_entry() //  [R1]
         { []
         }
     {offset
       c4xag: // global
           _s4vCH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xah; else goto c4xai;
       c4xai: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xak; else goto c4xaj;
       c4xak: // global
           HpAlloc = 16;
           goto c4xah;
       c4xah: // global
           R1 = _s4vCH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xaj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCH::P64;
           _s4vCD::I64 = I64[_s4vCH::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCD::I64,
                            (-2147483648))) goto c4xaq; else goto c4xaf;
       c4xaf: // global
           if (%MO_S_Gt_W64(_s4vCD::I64,
                            2147483647)) goto c4xaq; else goto c4xau;
       c4xaq: // global
           Hp = Hp - 16;
           R2 = _s4vCD::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xau: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCD::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vCH_info" {
     sat_s4vCH_info:
         const sat_s4vCH_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+344;
 },
 sat_s4vCM_entry() //  [R1]
         { []
         }
     {offset
       c4xaF: // global
           _s4vCM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xaG; else goto c4xaH;
       c4xaH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xaJ; else goto c4xaI;
       c4xaJ: // global
           HpAlloc = 16;
           goto c4xaG;
       c4xaG: // global
           R1 = _s4vCM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xaI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCM::P64;
           _s4vCD::I64 = I64[_s4vCM::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCD::I64,
                            (-2147483648))) goto c4xaP; else goto c4xaE;
       c4xaE: // global
           if (%MO_S_Gt_W64(_s4vCD::I64,
                            2147483647)) goto c4xaP; else goto c4xaT;
       c4xaP: // global
           Hp = Hp - 16;
           R2 = _s4vCD::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xaT: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCD::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vCM_info" {
     sat_s4vCM_info:
         const sat_s4vCM_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+344;
 },
 go_dn_s4vCC_entry() //  [R1, R2]
         { []
         }
     {offset
       c4xaX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4xb1; else goto c4xb0;
       c4xb1: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xb0: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto c4xaV; else goto c4xaW;
       c4xaV: // global
           _s4vCA::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vCJ_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vCA::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vCH_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xaW: // global
           I64[Hp - 80] = sat_s4vCM_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4xb3::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4xb3::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_s4vCC_info" {
     go_dn_s4vCC_info:
         const go_dn_s4vCC_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4wm5_srt+344;
 },
 sat_s4vCN_entry() //  [R1]
         { []
         }
     {offset
       c4xb4: // global
           _s4vCN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xb5; else goto c4xb6;
       c4xb6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4xb8; else goto c4xb7;
       c4xb8: // global
           HpAlloc = 24;
           goto c4xb5;
       c4xb5: // global
           R1 = _s4vCN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xb7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCN::P64;
           _s4vCt::I64 = I64[_s4vCN::P64 + 24];
           _s4vCA::I64 = _s4vCt::I64 - I64[_s4vCN::P64 + 16];
           _s4vCB::I64 = I64[_s4vCN::P64 + 32] - _s4vCA::I64;
           I64[Hp - 16] = go_dn_s4vCC_info;
           I64[Hp - 8] = _s4vCA::I64;
           I64[Hp] = _s4vCB::I64;
           R2 = _s4vCt::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_s4vCC_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vCN_info" {
     sat_s4vCN_info:
         const sat_s4vCN_entry;
         const 12884901888;
         const 4294967311;
         const S4wm5_srt+344;
 },
 sat_s4vCz_entry() //  [R1]
         { []
         }
     {offset
       c4xbi: // global
           _s4vCz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xbj; else goto c4xbk;
       c4xbk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xbm; else goto c4xbl;
       c4xbm: // global
           HpAlloc = 16;
           goto c4xbj;
       c4xbj: // global
           R1 = _s4vCz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xbl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCz::P64;
           _s4vCs::I64 = I64[_s4vCz::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCs::I64,
                            (-2147483648))) goto c4xbs; else goto c4xbh;
       c4xbh: // global
           if (%MO_S_Gt_W64(_s4vCs::I64,
                            2147483647)) goto c4xbs; else goto c4xbw;
       c4xbs: // global
           Hp = Hp - 16;
           R2 = _s4vCs::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xbw: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCs::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vCz_info" {
     sat_s4vCz_info:
         const sat_s4vCz_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+344;
 },
 sat_s4vCR_entry() //  [R1]
         { []
         }
     {offset
       c4xbK: // global
           _s4vCR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xbL; else goto c4xbM;
       c4xbM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xbO; else goto c4xbN;
       c4xbO: // global
           HpAlloc = 16;
           goto c4xbL;
       c4xbL: // global
           R1 = _s4vCR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xbN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCR::P64;
           _s4vCs::I64 = I64[_s4vCR::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCs::I64,
                            (-2147483648))) goto c4xbU; else goto c4xbJ;
       c4xbJ: // global
           if (%MO_S_Gt_W64(_s4vCs::I64,
                            2147483647)) goto c4xbU; else goto c4xbY;
       c4xbU: // global
           Hp = Hp - 16;
           R2 = _s4vCs::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xbY: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCs::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vCR_info" {
     sat_s4vCR_info:
         const sat_s4vCR_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+344;
 },
 sat_s4vD5_entry() //  [R1]
         { []
         }
     {offset
       c4xcr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xcs; else goto c4xct;
       c4xcs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xct: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s4vCY_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vD5_info" {
     sat_s4vD5_info:
         const sat_s4vD5_entry;
         const 8589934593;
         const 4294967311;
         const S4wm5_srt+344;
 },
 sat_s4vD3_entry() //  [R1]
         { []
         }
     {offset
       c4xcD: // global
           _s4vD3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xcE; else goto c4xcF;
       c4xcF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xcH; else goto c4xcG;
       c4xcH: // global
           HpAlloc = 16;
           goto c4xcE;
       c4xcE: // global
           R1 = _s4vD3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xcG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vD3::P64;
           _s4vCZ::I64 = I64[_s4vD3::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCZ::I64,
                            (-2147483648))) goto c4xcN; else goto c4xcC;
       c4xcC: // global
           if (%MO_S_Gt_W64(_s4vCZ::I64,
                            2147483647)) goto c4xcN; else goto c4xcR;
       c4xcN: // global
           Hp = Hp - 16;
           R2 = _s4vCZ::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xcR: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCZ::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vD3_info" {
     sat_s4vD3_info:
         const sat_s4vD3_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+344;
 },
 sat_s4vD8_entry() //  [R1]
         { []
         }
     {offset
       c4xd2: // global
           _s4vD8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xd3; else goto c4xd4;
       c4xd4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xd6; else goto c4xd5;
       c4xd6: // global
           HpAlloc = 16;
           goto c4xd3;
       c4xd3: // global
           R1 = _s4vD8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xd5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vD8::P64;
           _s4vCZ::I64 = I64[_s4vD8::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCZ::I64,
                            (-2147483648))) goto c4xdc; else goto c4xd1;
       c4xd1: // global
           if (%MO_S_Gt_W64(_s4vCZ::I64,
                            2147483647)) goto c4xdc; else goto c4xdg;
       c4xdc: // global
           Hp = Hp - 16;
           R2 = _s4vCZ::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xdg: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCZ::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vD8_info" {
     sat_s4vD8_info:
         const sat_s4vD8_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+344;
 },
 go_up_s4vCY_entry() //  [R1, R2]
         { []
         }
     {offset
       c4xdk: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4xdo; else goto c4xdn;
       c4xdo: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xdn: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto c4xdi; else goto c4xdj;
       c4xdi: // global
           _s4vCW::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_s4vD5_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _s4vCW::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s4vD3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xdj: // global
           I64[Hp - 80] = sat_s4vD8_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4xdq::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4xdq::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_s4vCY_info" {
     go_up_s4vCY_info:
         const go_up_s4vCY_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const S4wm5_srt+344;
 },
 sat_s4vD9_entry() //  [R1]
         { []
         }
     {offset
       c4xdr: // global
           _s4vD9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xds; else goto c4xdt;
       c4xdt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4xdv; else goto c4xdu;
       c4xdv: // global
           HpAlloc = 24;
           goto c4xds;
       c4xds: // global
           R1 = _s4vD9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xdu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vD9::P64;
           _s4vCt::I64 = I64[_s4vD9::P64 + 24];
           _s4vCW::I64 = _s4vCt::I64 - I64[_s4vD9::P64 + 16];
           _s4vCX::I64 = I64[_s4vD9::P64 + 32] - _s4vCW::I64;
           I64[Hp - 16] = go_up_s4vCY_info;
           I64[Hp - 8] = _s4vCW::I64;
           I64[Hp] = _s4vCX::I64;
           R2 = _s4vCt::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_s4vCY_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vD9_info" {
     sat_s4vD9_info:
         const sat_s4vD9_entry;
         const 12884901888;
         const 4294967311;
         const S4wm5_srt+344;
 },
 sat_s4vCV_entry() //  [R1]
         { []
         }
     {offset
       c4xdF: // global
           _s4vCV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xdG; else goto c4xdH;
       c4xdH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xdJ; else goto c4xdI;
       c4xdJ: // global
           HpAlloc = 16;
           goto c4xdG;
       c4xdG: // global
           R1 = _s4vCV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xdI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vCV::P64;
           _s4vCs::I64 = I64[_s4vCV::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCs::I64,
                            (-2147483648))) goto c4xdP; else goto c4xdE;
       c4xdE: // global
           if (%MO_S_Gt_W64(_s4vCs::I64,
                            2147483647)) goto c4xdP; else goto c4xdT;
       c4xdP: // global
           Hp = Hp - 16;
           R2 = _s4vCs::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xdT: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCs::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vCV_info" {
     sat_s4vCV_info:
         const sat_s4vCV_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+344;
 },
 sat_s4vDd_entry() //  [R1]
         { []
         }
     {offset
       c4xe7: // global
           _s4vDd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c4xe8; else goto c4xe9;
       c4xe9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xeb; else goto c4xea;
       c4xeb: // global
           HpAlloc = 16;
           goto c4xe8;
       c4xe8: // global
           R1 = _s4vDd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xea: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s4vDd::P64;
           _s4vCs::I64 = I64[_s4vDd::P64 + 16];
           if (%MO_S_Lt_W64(_s4vCs::I64,
                            (-2147483648))) goto c4xeh; else goto c4xe6;
       c4xe6: // global
           if (%MO_S_Gt_W64(_s4vCs::I64,
                            2147483647)) goto c4xeh; else goto c4xel;
       c4xeh: // global
           Hp = Hp - 16;
           R2 = _s4vCs::I64;
           Sp = Sp - 16;
           call GHC.Int.$wlvl1_entry(R2) args: 24, res: 0, upd: 24;
       c4xel: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vCs::I64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vDd_info" {
     sat_s4vDd_info:
         const sat_s4vDd_entry;
         const 4294967296;
         const 4294967313;
         const S4wm5_srt+344;
 },
 GHC.Int.$w$cenumFromThenTo1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4xep: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c4xet; else goto c4xes;
       c4xet: // global
           HpAlloc = 88;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xes: // global
           if (%MO_S_Lt_W64(R3, R2)) goto c4xen; else goto c4xeo;
       c4xen: // global
           if (%MO_S_Le_W64(R4, R3)) goto c4xew; else goto c4xeB;
       c4xew: // global
           I64[Hp - 80] = sat_s4vCN_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vCz_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xeB: // global
           if (%MO_S_Gt_W64(R4, R2)) goto c4xeI; else goto c4xez;
       c4xez: // global
           I64[Hp - 80] = sat_s4vCR_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4xex::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4xex::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xeo: // global
           if (%MO_S_Ge_W64(R4, R3)) goto c4xeE; else goto c4xeJ;
       c4xeE: // global
           I64[Hp - 80] = sat_s4vD9_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = R3;
           I64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s4vCV_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xeJ: // global
           if (%MO_S_Lt_W64(R4, R2)) goto c4xeI; else goto c4xeH;
       c4xeI: // global
           Hp = Hp - 88;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xeH: // global
           I64[Hp - 80] = sat_s4vDd_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _c4xeF::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _c4xeF::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cenumFromThenTo1_info" {
     GHC.Int.$w$cenumFromThenTo1_info:
         const GHC.Int.$w$cenumFromThenTo1_entry;
         const 0;
         const 1103806595086;
         const 12884901904;
         const S4wm5_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.637043531 UTC

[section ""data" . GHC.Int.$fEnumInt32_$cenumFromThenTo_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThenTo_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThenTo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4xhd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xhm; else goto c4xhn;
       c4xhm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xhn: // global
           I64[Sp - 24] = block_c4xha_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4xhw; else goto c4xhb;
       u4xhw: // global
           call _c4xha(R1) args: 0, res: 0, upd: 0;
       c4xhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cenumFromThenTo_info" {
     GHC.Int.$fEnumInt32_$cenumFromThenTo_info:
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S4wm5_srt+408;
 },
 _c4xha() //  [R1]
         { []
         }
     {offset
       c4xha: // global
           I64[Sp] = block_c4xhg_info;
           _s4vDi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vDi::I64;
           if (R1 & 7 != 0) goto u4xhv; else goto c4xhh;
       u4xhv: // global
           call _c4xhg(R1) args: 0, res: 0, upd: 0;
       c4xhh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xha_info" {
     block_c4xha_info:
         const _c4xha;
         const 2;
         const 4294967326;
         const S4wm5_srt+408;
 },
 _c4xhg() //  [R1]
         { []
         }
     {offset
       c4xhg: // global
           I64[Sp] = block_c4xhl_info;
           _s4vDk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vDk::I64;
           if (R1 & 7 != 0) goto u4xhx; else goto c4xhq;
       u4xhx: // global
           call _c4xhl(R1) args: 0, res: 0, upd: 0;
       c4xhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xhg_info" {
     block_c4xhg_info:
         const _c4xhg;
         const 66;
         const 4294967326;
         const S4wm5_srt+408;
 },
 _c4xhl() //  [R1]
         { []
         }
     {offset
       c4xhl: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Int.$w$cenumFromThenTo1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xhl_info" {
     block_c4xhl_info:
         const _c4xhl;
         const 194;
         const 4294967326;
         const S4wm5_srt+408;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.646726574 UTC

[section ""data" . GHC.Int.$fEnumInt32_closure" {
     GHC.Int.$fEnumInt32_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt32_$csucc_closure+1;
         const GHC.Int.$fEnumInt32_$cpred_closure+1;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt32_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt32_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt32_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt32_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt32_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xhW: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt32_closure+1;
           R2 = GHC.Int.$fEnumInt32_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt32_$cenumFromThen_info" {
     GHC.Int.$fEnumInt32_$cenumFromThen_info:
         const GHC.Int.$fEnumInt32_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S4wm5_srt+424;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.651119758 UTC

[section ""cstring" . GHC.Int.$tcInt6_bytes" {
     GHC.Int.$tcInt6_bytes:
         I8[] [73,110,116,54,52]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.653741099 UTC

[section ""data" . GHC.Int.$fEnumInt5_closure" {
     GHC.Int.$fEnumInt5_closure:
         const GHC.Int.$fEnumInt5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt5_entry() //  [R1]
         { []
         }
     {offset
       c4xid: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xie; else goto c4xif;
       c4xie: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xif: // global
           (_c4xi8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4xi8::I64 == 0) goto c4xia; else goto c4xi9;
       c4xia: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4xi9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4xi8::I64;
           I64[Sp - 24] = block_c4xib_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt5_info" {
     GHC.Int.$fEnumInt5_info:
         const GHC.Int.$fEnumInt5_entry;
         const 0;
         const 4294967317;
         const S4wm5_srt+280;
 },
 _c4xib() //  [R1]
         { []
         }
     {offset
       c4xib: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.predError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4xib_info" {
     block_c4xib_info:
         const _c4xib;
         const 0;
         const 4294967326;
         const S4wm5_srt+280;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.659685223 UTC

[section ""data" . GHC.Int.$fEnumInt6_closure" {
     GHC.Int.$fEnumInt6_closure:
         const GHC.Int.$fEnumInt6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fEnumInt6_entry() //  [R1]
         { []
         }
     {offset
       c4xiD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xiE; else goto c4xiF;
       c4xiE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xiF: // global
           (_c4xiy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4xiy::I64 == 0) goto c4xiA; else goto c4xiz;
       c4xiA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4xiz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4xiy::I64;
           I64[Sp - 24] = block_c4xiB_info;
           R2 = GHC.Int.$tcInt6_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt6_info" {
     GHC.Int.$fEnumInt6_info:
         const GHC.Int.$fEnumInt6_entry;
         const 0;
         const 4294967317;
         const S4wm5_srt+288;
 },
 _c4xiB() //  [R1]
         { []
         }
     {offset
       c4xiB: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Enum.succError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4xiB_info" {
     block_c4xiB_info:
         const _c4xiB;
         const 0;
         const 4294967326;
         const S4wm5_srt+288;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.666912217 UTC

[section ""data" . GHC.Int.neInt64_closure" {
     GHC.Int.neInt64_closure:
         const GHC.Int.neInt64_info;
 },
 GHC.Int.neInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xj2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xj6; else goto c4xj7;
       c4xj6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.neInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xj7: // global
           I64[Sp - 16] = block_c4xiZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xjg; else goto c4xj0;
       u4xjg: // global
           call _c4xiZ(R1) args: 0, res: 0, upd: 0;
       c4xj0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.neInt64_info" {
     GHC.Int.neInt64_info:
         const GHC.Int.neInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xiZ() //  [R1]
         { []
         }
     {offset
       c4xiZ: // global
           I64[Sp] = block_c4xj5_info;
           _s4vDs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vDs::I64;
           if (R1 & 7 != 0) goto u4xjf; else goto c4xj9;
       u4xjf: // global
           call _c4xj5(R1) args: 0, res: 0, upd: 0;
       c4xj9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xiZ_info" {
     block_c4xiZ_info:
         const _c4xiZ;
         const 1;
         const 30;
 },
 _c4xj5() //  [R1]
         { []
         }
     {offset
       c4xj5: // global
           R1 = I64[((I64[Sp + 8] != I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xj5_info" {
     block_c4xj5_info:
         const _c4xj5;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.673720649 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cminBound_closure" {
     GHC.Int.$fBoundedInt64_$cminBound_closure:
         const GHC.Int.I64#_con_info;
         const (-9223372036854775808);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.676652474 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cpred_closure" {
     GHC.Int.$fEnumInt64_$cpred_closure:
         const GHC.Int.$fEnumInt64_$cpred_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cpred_entry() //  [R2]
         { []
         }
     {offset
       c4xjJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xjK; else goto c4xjL;
       c4xjK: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xjL: // global
           I64[Sp - 8] = block_c4xjG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xk0; else goto c4xjH;
       u4xk0: // global
           call _c4xjG(R1) args: 0, res: 0, upd: 0;
       c4xjH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cpred_info" {
     GHC.Int.$fEnumInt64_$cpred_info:
         const GHC.Int.$fEnumInt64_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+432;
 },
 _c4xjG() //  [R1]
         { []
         }
     {offset
       c4xjG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xjQ; else goto c4xjP;
       c4xjQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xjP: // global
           _s4vDz::I64 = I64[R1 + 7];
           if (_s4vDz::I64 != (-9223372036854775808)) goto c4xjY; else goto c4xjZ;
       c4xjY: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vDz::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xjZ: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xjG_info" {
     block_c4xjG_info:
         const _c4xjG;
         const 0;
         const 4294967326;
         const S4wm5_srt+440;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.682085491 UTC

[section ""data" . GHC.Int.$fBoundedInt64_$cmaxBound_closure" {
     GHC.Int.$fBoundedInt64_$cmaxBound_closure:
         const GHC.Int.I64#_con_info;
         const 9223372036854775807;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.683921913 UTC

[section ""data" . GHC.Int.$fBoundedInt64_closure" {
     GHC.Int.$fBoundedInt64_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Int.$fBoundedInt64_$cminBound_closure+1;
         const GHC.Int.$fBoundedInt64_$cmaxBound_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.690665587 UTC

[section ""data" . GHC.Int.$fEnumInt64_$csucc_closure" {
     GHC.Int.$fEnumInt64_$csucc_closure:
         const GHC.Int.$fEnumInt64_$csucc_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$csucc_entry() //  [R2]
         { []
         }
     {offset
       c4xkp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xkq; else goto c4xkr;
       c4xkq: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xkr: // global
           I64[Sp - 8] = block_c4xkm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xkG; else goto c4xkn;
       u4xkG: // global
           call _c4xkm(R1) args: 0, res: 0, upd: 0;
       c4xkn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$csucc_info" {
     GHC.Int.$fEnumInt64_$csucc_info:
         const GHC.Int.$fEnumInt64_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+448;
 },
 _c4xkm() //  [R1]
         { []
         }
     {offset
       c4xkm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xkw; else goto c4xkv;
       c4xkw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xkv: // global
           _s4vDE::I64 = I64[R1 + 7];
           if (_s4vDE::I64 != 9223372036854775807) goto c4xkE; else goto c4xkF;
       c4xkE: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vDE::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xkF: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fEnumInt6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xkm_info" {
     block_c4xkm_info:
         const _c4xkm;
         const 0;
         const 4294967326;
         const S4wm5_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.698540539 UTC

[section ""data" . GHC.Int.$wgo2_closure" {
     GHC.Int.$wgo2_closure:
         const GHC.Int.$wgo2_info;
 },
 sat_s4vDN_entry() //  [R1]
         { []
         }
     {offset
       c4xl8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xl9; else goto c4xlk;
       c4xl9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4xlk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s4vDI::I64 = I64[R1 + 16];
           if (_s4vDI::I64 != 9223372036854775807) goto c4xl6; else goto c4xl7;
       c4xl6: // global
           I64[Sp - 24] = block_c4xle_info;
           R2 = _s4vDI::I64 + 1;
           Sp = Sp - 24;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 24;
       c4xl7: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vDN_info" {
     sat_s4vDN_info:
         const sat_s4vDN_entry;
         const 4294967296;
         const 17;
 },
 _c4xle() //  [R1, R2]
         { []
         }
     {offset
       c4xle: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4xlj; else goto c4xli;
       c4xlj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4xli: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4xle_info" {
     block_c4xle_info:
         const _c4xle;
         const 0;
         const 30;
 },
 GHC.Int.$wgo2_entry() //  [R2]
         { []
         }
     {offset
       c4xlm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4xlq; else goto c4xlp;
       c4xlq: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Int.$wgo2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xlp: // global
           I64[Hp - 32] = sat_s4vDN_info;
           I64[Hp - 16] = R2;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R2 = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$wgo2_info" {
     GHC.Int.$wgo2_info:
         const GHC.Int.$wgo2_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.707213006 UTC

[section ""data" . GHC.Int.$fEnumInt64_go_closure" {
     GHC.Int.$fEnumInt64_go_closure:
         const GHC.Int.$fEnumInt64_go_info;
 },
 GHC.Int.$fEnumInt64_go_entry() //  [R2]
         { []
         }
     {offset
       c4xlT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xlU; else goto c4xlV;
       c4xlU: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xlV: // global
           I64[Sp - 8] = block_c4xlQ_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Int.$wgo2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_go_info" {
     GHC.Int.$fEnumInt64_go_info:
         const GHC.Int.$fEnumInt64_go_entry;
         const 0;
         const 14;
         const 4294967300;
 },
 _c4xlQ() //  [R1, R2]
         { []
         }
     {offset
       c4xlQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4xlY; else goto c4xlX;
       c4xlY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4xlX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xlQ_info" {
     block_c4xlQ_info:
         const _c4xlQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.714030256 UTC

[section ""data" . GHC.Int.$fEnumInt64_$cenumFrom_closure" {
     GHC.Int.$fEnumInt64_$cenumFrom_closure:
         const GHC.Int.$fEnumInt64_$cenumFrom_info;
 },
 GHC.Int.$fEnumInt64_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       c4xmh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xmi; else goto c4xmj;
       c4xmi: // global
           R2 = R2;
           R1 = GHC.Int.$fEnumInt64_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xmj: // global
           I64[Sp - 8] = block_c4xme_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xmn; else goto c4xmf;
       u4xmn: // global
           call _c4xme(R1) args: 0, res: 0, upd: 0;
       c4xmf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cenumFrom_info" {
     GHC.Int.$fEnumInt64_$cenumFrom_info:
         const GHC.Int.$fEnumInt64_$cenumFrom_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xme() //  [R1]
         { []
         }
     {offset
       c4xme: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xme_info" {
     block_c4xme_info:
         const _c4xme;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.719400245 UTC

[section ""data" . GHC.Int.$fEnumInt64_closure" {
     GHC.Int.$fEnumInt64_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Int.$fEnumInt64_$csucc_closure+1;
         const GHC.Int.$fEnumInt64_$cpred_closure+1;
         const GHC.Int.$fEnumInt64_$ctoEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cfromEnum_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFrom_closure+1;
         const GHC.Int.$fEnumInt64_$cenumFromThen_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromTo_closure+2;
         const GHC.Int.$fEnumInt64_$cenumFromThenTo_closure+3;
         const 0;
 },
 section ""data" . GHC.Int.$fEnumInt64_$cenumFromThen_closure" {
     GHC.Int.$fEnumInt64_$cenumFromThen_closure:
         const GHC.Int.$fEnumInt64_$cenumFromThen_info;
         const 0;
 },
 GHC.Int.$fEnumInt64_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xmC: // global
           R5 = R3;
           R4 = R2;
           R3 = GHC.Int.$fBoundedInt64_closure+1;
           R2 = GHC.Int.$fEnumInt64_closure+1;
           call GHC.Enum.boundedEnumFromThen_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fEnumInt64_$cenumFromThen_info" {
     GHC.Int.$fEnumInt64_$cenumFromThen_info:
         const GHC.Int.$fEnumInt64_$cenumFromThen_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S4wm5_srt+464;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.724454093 UTC

[section ""data" . GHC.Int.$fNumInt8_$cfromInteger_closure" {
     GHC.Int.$fNumInt8_$cfromInteger_closure:
         const GHC.Int.$fNumInt8_$cfromInteger_info;
 },
 GHC.Int.$fNumInt8_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c4xmQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xmX; else goto c4xmY;
       c4xmX: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xmY: // global
           I64[Sp - 8] = block_c4xmO_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$cfromInteger_info" {
     GHC.Int.$fNumInt8_$cfromInteger_info:
         const GHC.Int.$fNumInt8_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xmO() //  [R1]
         { []
         }
     {offset
       c4xmO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xn1; else goto c4xn0;
       c4xn1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4xn0: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xmO_info" {
     block_c4xmO_info:
         const _c4xmO;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.731090056 UTC

[section ""data" . GHC.Int.$fNumInt8_$cnegate_closure" {
     GHC.Int.$fNumInt8_$cnegate_closure:
         const GHC.Int.$fNumInt8_$cnegate_info;
 },
 GHC.Int.$fNumInt8_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c4xnm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xnw; else goto c4xnx;
       c4xnw: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xnx: // global
           I64[Sp - 8] = block_c4xnj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xnB; else goto c4xnk;
       u4xnB: // global
           call _c4xnj(R1) args: 0, res: 0, upd: 0;
       c4xnk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$cnegate_info" {
     GHC.Int.$fNumInt8_$cnegate_info:
         const GHC.Int.$fNumInt8_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xnj() //  [R1]
         { []
         }
     {offset
       c4xnj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xnA; else goto c4xnz;
       c4xnA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xnz: // global
           _s4vE2::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vE2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xnj_info" {
     block_c4xnj_info:
         const _c4xnj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.738240174 UTC

[section ""data" . GHC.Int.$fNumInt8_$c*_closure" {
     GHC.Int.$fNumInt8_$c*_closure:
         const GHC.Int.$fNumInt8_$c*_info;
 },
 GHC.Int.$fNumInt8_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xnW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xob; else goto c4xoc;
       c4xob: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xoc: // global
           I64[Sp - 16] = block_c4xnT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xoi; else goto c4xnU;
       u4xoi: // global
           call _c4xnT(R1) args: 0, res: 0, upd: 0;
       c4xnU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$c*_info" {
     GHC.Int.$fNumInt8_$c*_info:
         const GHC.Int.$fNumInt8_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xnT() //  [R1]
         { []
         }
     {offset
       c4xnT: // global
           I64[Sp] = block_c4xnZ_info;
           _s4vE6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vE6::I64;
           if (R1 & 7 != 0) goto u4xoh; else goto c4xo0;
       u4xoh: // global
           call _c4xnZ(R1) args: 0, res: 0, upd: 0;
       c4xo0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xnT_info" {
     block_c4xnT_info:
         const _c4xnT;
         const 1;
         const 30;
 },
 _c4xnZ() //  [R1]
         { []
         }
     {offset
       c4xnZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xog; else goto c4xof;
       c4xog: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xof: // global
           _s4vEa::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vEa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xnZ_info" {
     block_c4xnZ_info:
         const _c4xnZ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.746707213 UTC

[section ""data" . GHC.Int.$fNumInt8_$c-_closure" {
     GHC.Int.$fNumInt8_$c-_closure:
         const GHC.Int.$fNumInt8_$c-_info;
 },
 GHC.Int.$fNumInt8_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xoK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xoZ; else goto c4xp0;
       c4xoZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xp0: // global
           I64[Sp - 16] = block_c4xoH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xp6; else goto c4xoI;
       u4xp6: // global
           call _c4xoH(R1) args: 0, res: 0, upd: 0;
       c4xoI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$c-_info" {
     GHC.Int.$fNumInt8_$c-_info:
         const GHC.Int.$fNumInt8_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xoH() //  [R1]
         { []
         }
     {offset
       c4xoH: // global
           I64[Sp] = block_c4xoN_info;
           _s4vEe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vEe::I64;
           if (R1 & 7 != 0) goto u4xp5; else goto c4xoO;
       u4xp5: // global
           call _c4xoN(R1) args: 0, res: 0, upd: 0;
       c4xoO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xoH_info" {
     block_c4xoH_info:
         const _c4xoH;
         const 1;
         const 30;
 },
 _c4xoN() //  [R1]
         { []
         }
     {offset
       c4xoN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xp4; else goto c4xp3;
       c4xp4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xp3: // global
           _s4vEi::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vEi::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xoN_info" {
     block_c4xoN_info:
         const _c4xoN;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.755435473 UTC

[section ""data" . GHC.Int.$fNumInt8_$c+_closure" {
     GHC.Int.$fNumInt8_$c+_closure:
         const GHC.Int.$fNumInt8_$c+_info;
 },
 GHC.Int.$fNumInt8_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xpy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xpN; else goto c4xpO;
       c4xpN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xpO: // global
           I64[Sp - 16] = block_c4xpv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xpU; else goto c4xpw;
       u4xpU: // global
           call _c4xpv(R1) args: 0, res: 0, upd: 0;
       c4xpw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$c+_info" {
     GHC.Int.$fNumInt8_$c+_info:
         const GHC.Int.$fNumInt8_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xpv() //  [R1]
         { []
         }
     {offset
       c4xpv: // global
           I64[Sp] = block_c4xpB_info;
           _s4vEm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vEm::I64;
           if (R1 & 7 != 0) goto u4xpT; else goto c4xpC;
       u4xpT: // global
           call _c4xpB(R1) args: 0, res: 0, upd: 0;
       c4xpC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xpv_info" {
     block_c4xpv_info:
         const _c4xpv;
         const 1;
         const 30;
 },
 _c4xpB() //  [R1]
         { []
         }
     {offset
       c4xpB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xpS; else goto c4xpR;
       c4xpS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xpR: // global
           _s4vEq::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vEq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xpB_info" {
     block_c4xpB_info:
         const _c4xpB;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.763447395 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt8_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt8_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt8_$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c4xqm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xqn; else goto c4xqo;
       c4xqn: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xqo: // global
           I64[Sp - 8] = block_c4xqj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xqs; else goto c4xqk;
       u4xqs: // global
           call _c4xqj(R1) args: 0, res: 0, upd: 0;
       c4xqk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$ctoInteger_info" {
     GHC.Int.$fIntegralInt8_$ctoInteger_info:
         const GHC.Int.$fIntegralInt8_$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xqj() //  [R1]
         { []
         }
     {offset
       c4xqj: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xqj_info" {
     block_c4xqj_info:
         const _c4xqj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.76944595 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cpopCount_closure" {
     GHC.Int.$fBitsInt8_$cpopCount_closure:
         const GHC.Int.$fBitsInt8_$cpopCount_info;
 },
 GHC.Int.$fBitsInt8_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c4xqK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xqY; else goto c4xqZ;
       c4xqY: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xqZ: // global
           I64[Sp - 8] = block_c4xqH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xr3; else goto c4xqI;
       u4xr3: // global
           call _c4xqH(R1) args: 0, res: 0, upd: 0;
       c4xqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cpopCount_info" {
     GHC.Int.$fBitsInt8_$cpopCount_info:
         const GHC.Int.$fBitsInt8_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xqH() //  [R1]
         { []
         }
     {offset
       c4xqH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xr2; else goto c4xr1;
       c4xr2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xr1: // global
           (_c4xqQ::I64) = call MO_PopCnt W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xqQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xqH_info" {
     block_c4xqH_info:
         const _c4xqH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.776613674 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xrn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xrz; else goto c4xrA;
       c4xrz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xrA: // global
           I64[Sp - 16] = block_c4xrk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xrG; else goto c4xrl;
       u4xrG: // global
           call _c4xrk(R1) args: 0, res: 0, upd: 0;
       c4xrl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cunsafeShiftR_info" {
     GHC.Int.$fBitsInt8_$cunsafeShiftR_info:
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xrk() //  [R1]
         { []
         }
     {offset
       c4xrk: // global
           I64[Sp] = block_c4xrq_info;
           _s4vED::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vED::I64;
           if (R1 & 7 != 0) goto u4xrF; else goto c4xrr;
       u4xrF: // global
           call _c4xrq(R1) args: 0, res: 0, upd: 0;
       c4xrr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xrk_info" {
     block_c4xrk_info:
         const _c4xrk;
         const 1;
         const 30;
 },
 _c4xrq() //  [R1]
         { []
         }
     {offset
       c4xrq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xrE; else goto c4xrD;
       c4xrE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xrD: // global
           _s4vEG::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vEG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xrq_info" {
     block_c4xrq_info:
         const _c4xrq;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.78372342 UTC

[section ""data" . GHC.Int.$fBitsInt13_closure" {
     GHC.Int.$fBitsInt13_closure:
         const GHC.Int.I8#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.785481386 UTC

[section ""data" . GHC.Int.$fNumInt9_closure" {
     GHC.Int.$fNumInt9_closure:
         const GHC.Int.I8#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.78891761 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftR_closure" {
     GHC.Int.$fBitsInt8_$cshiftR_closure:
         const GHC.Int.$fBitsInt8_$cshiftR_info;
 },
 GHC.Int.$fBitsInt8_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xs8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xsc; else goto c4xsd;
       c4xsc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xsd: // global
           I64[Sp - 16] = block_c4xs5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xsD; else goto c4xs6;
       u4xsD: // global
           call _c4xs5(R1) args: 0, res: 0, upd: 0;
       c4xs6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cshiftR_info" {
     GHC.Int.$fBitsInt8_$cshiftR_info:
         const GHC.Int.$fBitsInt8_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xs5() //  [R1]
         { []
         }
     {offset
       c4xs5: // global
           I64[Sp] = block_c4xsb_info;
           _s4vEK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vEK::I64;
           if (R1 & 7 != 0) goto u4xsC; else goto c4xsf;
       u4xsC: // global
           call _c4xsb(R1) args: 0, res: 0, upd: 0;
       c4xsf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xs5_info" {
     block_c4xs5_info:
         const _c4xs5;
         const 1;
         const 30;
 },
 _c4xsb() //  [R1]
         { []
         }
     {offset
       c4xsb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xsl; else goto c4xsk;
       c4xsl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xsk: // global
           _s4vEK::I64 = I64[Sp + 8];
           _s4vEM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vEM::I64, 64)) goto c4xsu; else goto c4xsB;
       c4xsu: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vEK::I64, _s4vEM::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xsB: // global
           if (%MO_S_Ge_W64(_s4vEK::I64, 0)) goto c4xsz; else goto c4xsA;
       c4xsz: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xsA: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xsb_info" {
     block_c4xsb_info:
         const _c4xsb;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.798471844 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt8_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt8_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xt5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xtk; else goto c4xtl;
       c4xtk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xtl: // global
           I64[Sp - 16] = block_c4xt2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xtr; else goto c4xt3;
       u4xtr: // global
           call _c4xt2(R1) args: 0, res: 0, upd: 0;
       c4xt3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cunsafeShiftL_info" {
     GHC.Int.$fBitsInt8_$cunsafeShiftL_info:
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xt2() //  [R1]
         { []
         }
     {offset
       c4xt2: // global
           I64[Sp] = block_c4xt8_info;
           _s4vET::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vET::I64;
           if (R1 & 7 != 0) goto u4xtq; else goto c4xt9;
       u4xtq: // global
           call _c4xt8(R1) args: 0, res: 0, upd: 0;
       c4xt9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xt2_info" {
     block_c4xt2_info:
         const _c4xt2;
         const 1;
         const 30;
 },
 _c4xt8() //  [R1]
         { []
         }
     {offset
       c4xt8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xtp; else goto c4xto;
       c4xtp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xto: // global
           _s4vEX::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vEX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xt8_info" {
     block_c4xt8_info:
         const _c4xt8;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.806983381 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshiftL_closure" {
     GHC.Int.$fBitsInt8_$cshiftL_closure:
         const GHC.Int.$fBitsInt8_$cshiftL_info;
 },
 GHC.Int.$fBitsInt8_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xtS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xtW; else goto c4xtX;
       c4xtW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xtX: // global
           I64[Sp - 16] = block_c4xtP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xuk; else goto c4xtQ;
       u4xuk: // global
           call _c4xtP(R1) args: 0, res: 0, upd: 0;
       c4xtQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cshiftL_info" {
     GHC.Int.$fBitsInt8_$cshiftL_info:
         const GHC.Int.$fBitsInt8_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xtP() //  [R1]
         { []
         }
     {offset
       c4xtP: // global
           I64[Sp] = block_c4xtV_info;
           _s4vF1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vF1::I64;
           if (R1 & 7 != 0) goto u4xuj; else goto c4xtZ;
       u4xuj: // global
           call _c4xtV(R1) args: 0, res: 0, upd: 0;
       c4xtZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xtP_info" {
     block_c4xtP_info:
         const _c4xtP;
         const 1;
         const 30;
 },
 _c4xtV() //  [R1]
         { []
         }
     {offset
       c4xtV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xu5; else goto c4xu4;
       c4xu5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xu4: // global
           _s4vF3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vF3::I64, 64)) goto c4xuh; else goto c4xui;
       c4xuh: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[Sp + 8] << _s4vF3::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xui: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xtV_info" {
     block_c4xtV_info:
         const _c4xtV;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.815315833 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cisSigned_closure" {
     GHC.Int.$fBitsInt8_$cisSigned_closure:
         const GHC.Int.$fBitsInt8_$cisSigned_info;
 },
 GHC.Int.$fBitsInt8_$cisSigned_entry() //  []
         { []
         }
     {offset
       c4xuK: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cisSigned_info" {
     GHC.Int.$fBitsInt8_$cisSigned_info:
         const GHC.Int.$fBitsInt8_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.820571714 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotate_closure" {
     GHC.Int.$fBitsInt8_$crotate_closure:
         const GHC.Int.$fBitsInt8_$crotate_info;
 },
 GHC.Int.$fBitsInt8_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xv0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xv4; else goto c4xv5;
       c4xv4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xv5: // global
           I64[Sp - 16] = block_c4xuX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xw1; else goto c4xuY;
       u4xw1: // global
           call _c4xuX(R1) args: 0, res: 0, upd: 0;
       c4xuY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$crotate_info" {
     GHC.Int.$fBitsInt8_$crotate_info:
         const GHC.Int.$fBitsInt8_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xuX() //  [R1]
         { []
         }
     {offset
       c4xuX: // global
           I64[Sp - 8] = block_c4xv3_info;
           _s4vFa::P64 = R1;
           _s4vFb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vFb::I64;
           P64[Sp + 8] = _s4vFa::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xw0; else goto c4xv7;
       u4xw0: // global
           call _c4xv3(R1) args: 0, res: 0, upd: 0;
       c4xv7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xuX_info" {
     block_c4xuX_info:
         const _c4xuX;
         const 1;
         const 30;
 },
 _c4xv3() //  [R1]
         { []
         }
     {offset
       c4xv3: // global
           _s4vFg::I64 = I64[R1 + 7] & 7;
           if (_s4vFg::I64 != 0) goto u4xvY; else goto c4xvU;
       u4xvY: // global
           I64[Sp + 16] = _s4vFg::I64;
           Sp = Sp + 8;
           call _c4xvm() args: 0, res: 0, upd: 0;
       c4xvU: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xv3_info" {
     block_c4xv3_info:
         const _c4xv3;
         const 66;
         const 30;
 },
 _c4xvm() //  []
         { []
         }
     {offset
       c4xvm: // global
           Hp = Hp + 16;
           _s4vFg::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4xvR; else goto c4xvQ;
       c4xvR: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4xvl_info;
           R1 = _s4vFg::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4xvQ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4vFh::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4vFh::I64 << _s4vFg::I64) | (_s4vFh::I64 >> 8 - _s4vFg::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4xvl() //  [R1]
         { []
         }
     {offset
       c4xvl: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4xvm() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4xvl_info" {
     block_c4xvl_info:
         const _c4xvl;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.832989202 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cshift_closure" {
     GHC.Int.$fBitsInt8_$cshift_closure:
         const GHC.Int.$fBitsInt8_$cshift_info;
 },
 GHC.Int.$fBitsInt8_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xwI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xwM; else goto c4xwN;
       c4xwM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xwN: // global
           I64[Sp - 16] = block_c4xwF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xxA; else goto c4xwG;
       u4xxA: // global
           call _c4xwF(R1) args: 0, res: 0, upd: 0;
       c4xwG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cshift_info" {
     GHC.Int.$fBitsInt8_$cshift_info:
         const GHC.Int.$fBitsInt8_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xwF() //  [R1]
         { []
         }
     {offset
       c4xwF: // global
           I64[Sp] = block_c4xwL_info;
           _s4vFs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vFs::I64;
           if (R1 & 7 != 0) goto u4xxz; else goto c4xwP;
       u4xxz: // global
           call _c4xwL(R1) args: 0, res: 0, upd: 0;
       c4xwP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xwF_info" {
     block_c4xwF_info:
         const _c4xwF;
         const 1;
         const 30;
 },
 _c4xwL() //  [R1]
         { []
         }
     {offset
       c4xwL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xwV; else goto c4xwU;
       c4xwV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xwU: // global
           _s4vFs::I64 = I64[Sp + 8];
           _s4vFu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vFu::I64, 0)) goto c4xxj; else goto c4xxy;
       c4xxj: // global
           _s4vFw::I64 = -_s4vFu::I64;
           if (%MO_S_Lt_W64(_s4vFw::I64, 64)) goto c4xxa; else goto c4xxh;
       c4xxa: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vFs::I64, _s4vFw::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xxh: // global
           if (%MO_S_Ge_W64(_s4vFs::I64, 0)) goto c4xxx; else goto c4xxg;
       c4xxg: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xxy: // global
           if (%MO_S_Ge_W64(_s4vFu::I64, 64)) goto c4xxx; else goto c4xxw;
       c4xxx: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xxw: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vFs::I64 << _s4vFu::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xwL_info" {
     block_c4xwL_info:
         const _c4xwL;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.843180011 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplement_closure" {
     GHC.Int.$fBitsInt8_$ccomplement_closure:
         const GHC.Int.$fBitsInt8_$ccomplement_info;
 },
 GHC.Int.$fBitsInt8_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c4xy7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xyk; else goto c4xyl;
       c4xyk: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xyl: // global
           I64[Sp - 8] = block_c4xy4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xyp; else goto c4xy5;
       u4xyp: // global
           call _c4xy4(R1) args: 0, res: 0, upd: 0;
       c4xy5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$ccomplement_info" {
     GHC.Int.$fBitsInt8_$ccomplement_info:
         const GHC.Int.$fBitsInt8_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xy4() //  [R1]
         { []
         }
     {offset
       c4xy4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xyo; else goto c4xyn;
       c4xyo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xyn: // global
           _s4vFI::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vFI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xy4_info" {
     block_c4xy4_info:
         const _c4xy4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.851043615 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cxor_closure" {
     GHC.Int.$fBitsInt8_$cxor_closure:
         const GHC.Int.$fBitsInt8_$cxor_info;
 },
 GHC.Int.$fBitsInt8_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xyJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xz4; else goto c4xz5;
       c4xz4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xz5: // global
           I64[Sp - 16] = block_c4xyG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xzb; else goto c4xyH;
       u4xzb: // global
           call _c4xyG(R1) args: 0, res: 0, upd: 0;
       c4xyH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cxor_info" {
     GHC.Int.$fBitsInt8_$cxor_info:
         const GHC.Int.$fBitsInt8_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xyG() //  [R1]
         { []
         }
     {offset
       c4xyG: // global
           I64[Sp] = block_c4xyM_info;
           _s4vFM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vFM::I64;
           if (R1 & 7 != 0) goto u4xza; else goto c4xyN;
       u4xza: // global
           call _c4xyM(R1) args: 0, res: 0, upd: 0;
       c4xyN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xyG_info" {
     block_c4xyG_info:
         const _c4xyG;
         const 1;
         const 30;
 },
 _c4xyM() //  [R1]
         { []
         }
     {offset
       c4xyM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xz9; else goto c4xz8;
       c4xz9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xz8: // global
           _s4vFS::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vFS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xyM_info" {
     block_c4xyM_info:
         const _c4xyM;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.860313435 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.|._closure" {
     GHC.Int.$fBitsInt8_$c.|._closure:
         const GHC.Int.$fBitsInt8_$c.|._info;
 },
 GHC.Int.$fBitsInt8_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c4xzC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xzX; else goto c4xzY;
       c4xzX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xzY: // global
           I64[Sp - 16] = block_c4xzz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xA4; else goto c4xzA;
       u4xA4: // global
           call _c4xzz(R1) args: 0, res: 0, upd: 0;
       c4xzA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$c.|._info" {
     GHC.Int.$fBitsInt8_$c.|._info:
         const GHC.Int.$fBitsInt8_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xzz() //  [R1]
         { []
         }
     {offset
       c4xzz: // global
           I64[Sp] = block_c4xzF_info;
           _s4vFW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vFW::I64;
           if (R1 & 7 != 0) goto u4xA3; else goto c4xzG;
       u4xA3: // global
           call _c4xzF(R1) args: 0, res: 0, upd: 0;
       c4xzG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xzz_info" {
     block_c4xzz_info:
         const _c4xzz;
         const 1;
         const 30;
 },
 _c4xzF() //  [R1]
         { []
         }
     {offset
       c4xzF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xA2; else goto c4xA1;
       c4xA2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xA1: // global
           _s4vG2::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vG2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xzF_info" {
     block_c4xzF_info:
         const _c4xzF;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.869395222 UTC

[section ""data" . GHC.Int.$fBitsInt8_$c.&._closure" {
     GHC.Int.$fBitsInt8_$c.&._closure:
         const GHC.Int.$fBitsInt8_$c.&._info;
 },
 GHC.Int.$fBitsInt8_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c4xAv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xAQ; else goto c4xAR;
       c4xAQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xAR: // global
           I64[Sp - 16] = block_c4xAs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xAX; else goto c4xAt;
       u4xAX: // global
           call _c4xAs(R1) args: 0, res: 0, upd: 0;
       c4xAt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$c.&._info" {
     GHC.Int.$fBitsInt8_$c.&._info:
         const GHC.Int.$fBitsInt8_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xAs() //  [R1]
         { []
         }
     {offset
       c4xAs: // global
           I64[Sp] = block_c4xAy_info;
           _s4vG6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vG6::I64;
           if (R1 & 7 != 0) goto u4xAW; else goto c4xAz;
       u4xAW: // global
           call _c4xAy(R1) args: 0, res: 0, upd: 0;
       c4xAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xAs_info" {
     block_c4xAs_info:
         const _c4xAs;
         const 1;
         const 30;
 },
 _c4xAy() //  [R1]
         { []
         }
     {offset
       c4xAy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xAV; else goto c4xAU;
       c4xAV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xAU: // global
           _s4vGc::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vGc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xAy_info" {
     block_c4xAy_info:
         const _c4xAy;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.878183748 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4xBo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xBC; else goto c4xBD;
       c4xBC: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xBD: // global
           I64[Sp - 8] = block_c4xBl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xBH; else goto c4xBm;
       u4xBH: // global
           call _c4xBl(R1) args: 0, res: 0, upd: 0;
       c4xBm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info" {
     GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_info:
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xBl() //  [R1]
         { []
         }
     {offset
       c4xBl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xBG; else goto c4xBF;
       c4xBG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xBF: // global
           (_c4xBu::I64) = call MO_Ctz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xBu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xBl_info" {
     block_c4xBl_info:
         const _c4xBl;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.886327934 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4xC3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xCh; else goto c4xCi;
       c4xCh: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xCi: // global
           I64[Sp - 8] = block_c4xC0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xCm; else goto c4xC1;
       u4xCm: // global
           call _c4xC0(R1) args: 0, res: 0, upd: 0;
       c4xC1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info" {
     GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_info:
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xC0() //  [R1]
         { []
         }
     {offset
       c4xC0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xCl; else goto c4xCk;
       c4xCl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xCk: // global
           (_c4xC9::I64) = call MO_Clz W8(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xC9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xC0_info" {
     block_c4xC0_info:
         const _c4xC0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.892978094 UTC

[section ""data" . GHC.Int.$fBitsInt11_closure" {
     GHC.Int.$fBitsInt11_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.896308698 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt8_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt8_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c4xCG: // global
           R1 = GHC.Int.$fBitsInt11_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cfiniteBitSize_info" {
     GHC.Int.$fBitsInt8_$cfiniteBitSize_info:
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.903112275 UTC

[section ""data" . GHC.Int.$fNumInt16_$cfromInteger_closure" {
     GHC.Int.$fNumInt16_$cfromInteger_closure:
         const GHC.Int.$fNumInt16_$cfromInteger_info;
 },
 GHC.Int.$fNumInt16_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c4xCU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xD1; else goto c4xD2;
       c4xD1: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xD2: // global
           I64[Sp - 8] = block_c4xCS_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$cfromInteger_info" {
     GHC.Int.$fNumInt16_$cfromInteger_info:
         const GHC.Int.$fNumInt16_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xCS() //  [R1]
         { []
         }
     {offset
       c4xCS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xD5; else goto c4xD4;
       c4xD5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4xD4: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xCS_info" {
     block_c4xCS_info:
         const _c4xCS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.914197928 UTC

[section ""data" . GHC.Int.$fNumInt16_$cnegate_closure" {
     GHC.Int.$fNumInt16_$cnegate_closure:
         const GHC.Int.$fNumInt16_$cnegate_info;
 },
 GHC.Int.$fNumInt16_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c4xDq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xDA; else goto c4xDB;
       c4xDA: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xDB: // global
           I64[Sp - 8] = block_c4xDn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xDF; else goto c4xDo;
       u4xDF: // global
           call _c4xDn(R1) args: 0, res: 0, upd: 0;
       c4xDo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$cnegate_info" {
     GHC.Int.$fNumInt16_$cnegate_info:
         const GHC.Int.$fNumInt16_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xDn() //  [R1]
         { []
         }
     {offset
       c4xDn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xDE; else goto c4xDD;
       c4xDE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xDD: // global
           _s4vGx::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vGx::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xDn_info" {
     block_c4xDn_info:
         const _c4xDn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.923656301 UTC

[section ""data" . GHC.Int.$fNumInt16_$c*_closure" {
     GHC.Int.$fNumInt16_$c*_closure:
         const GHC.Int.$fNumInt16_$c*_info;
 },
 GHC.Int.$fNumInt16_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xE0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xEf; else goto c4xEg;
       c4xEf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xEg: // global
           I64[Sp - 16] = block_c4xDX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xEm; else goto c4xDY;
       u4xEm: // global
           call _c4xDX(R1) args: 0, res: 0, upd: 0;
       c4xDY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$c*_info" {
     GHC.Int.$fNumInt16_$c*_info:
         const GHC.Int.$fNumInt16_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xDX() //  [R1]
         { []
         }
     {offset
       c4xDX: // global
           I64[Sp] = block_c4xE3_info;
           _s4vGB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vGB::I64;
           if (R1 & 7 != 0) goto u4xEl; else goto c4xE4;
       u4xEl: // global
           call _c4xE3(R1) args: 0, res: 0, upd: 0;
       c4xE4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xDX_info" {
     block_c4xDX_info:
         const _c4xDX;
         const 1;
         const 30;
 },
 _c4xE3() //  [R1]
         { []
         }
     {offset
       c4xE3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xEk; else goto c4xEj;
       c4xEk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xEj: // global
           _s4vGF::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vGF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xE3_info" {
     block_c4xE3_info:
         const _c4xE3;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.933851253 UTC

[section ""data" . GHC.Int.$fNumInt16_$c-_closure" {
     GHC.Int.$fNumInt16_$c-_closure:
         const GHC.Int.$fNumInt16_$c-_info;
 },
 GHC.Int.$fNumInt16_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xEO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xF3; else goto c4xF4;
       c4xF3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xF4: // global
           I64[Sp - 16] = block_c4xEL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xFa; else goto c4xEM;
       u4xFa: // global
           call _c4xEL(R1) args: 0, res: 0, upd: 0;
       c4xEM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$c-_info" {
     GHC.Int.$fNumInt16_$c-_info:
         const GHC.Int.$fNumInt16_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xEL() //  [R1]
         { []
         }
     {offset
       c4xEL: // global
           I64[Sp] = block_c4xER_info;
           _s4vGJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vGJ::I64;
           if (R1 & 7 != 0) goto u4xF9; else goto c4xES;
       u4xF9: // global
           call _c4xER(R1) args: 0, res: 0, upd: 0;
       c4xES: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xEL_info" {
     block_c4xEL_info:
         const _c4xEL;
         const 1;
         const 30;
 },
 _c4xER() //  [R1]
         { []
         }
     {offset
       c4xER: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xF8; else goto c4xF7;
       c4xF8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xF7: // global
           _s4vGN::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vGN::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xER_info" {
     block_c4xER_info:
         const _c4xER;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.947317311 UTC

[section ""data" . GHC.Int.$fNumInt16_$c+_closure" {
     GHC.Int.$fNumInt16_$c+_closure:
         const GHC.Int.$fNumInt16_$c+_info;
 },
 GHC.Int.$fNumInt16_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xFC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xFR; else goto c4xFS;
       c4xFR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xFS: // global
           I64[Sp - 16] = block_c4xFz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xFY; else goto c4xFA;
       u4xFY: // global
           call _c4xFz(R1) args: 0, res: 0, upd: 0;
       c4xFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$c+_info" {
     GHC.Int.$fNumInt16_$c+_info:
         const GHC.Int.$fNumInt16_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xFz() //  [R1]
         { []
         }
     {offset
       c4xFz: // global
           I64[Sp] = block_c4xFF_info;
           _s4vGR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vGR::I64;
           if (R1 & 7 != 0) goto u4xFX; else goto c4xFG;
       u4xFX: // global
           call _c4xFF(R1) args: 0, res: 0, upd: 0;
       c4xFG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xFz_info" {
     block_c4xFz_info:
         const _c4xFz;
         const 1;
         const 30;
 },
 _c4xFF() //  [R1]
         { []
         }
     {offset
       c4xFF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xFW; else goto c4xFV;
       c4xFW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xFV: // global
           _s4vGV::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vGV::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xFF_info" {
     block_c4xFF_info:
         const _c4xFF;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.959043822 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt16_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt16_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt16_$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c4xGq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xGr; else goto c4xGs;
       c4xGr: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xGs: // global
           I64[Sp - 8] = block_c4xGn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xGw; else goto c4xGo;
       u4xGw: // global
           call _c4xGn(R1) args: 0, res: 0, upd: 0;
       c4xGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$ctoInteger_info" {
     GHC.Int.$fIntegralInt16_$ctoInteger_info:
         const GHC.Int.$fIntegralInt16_$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xGn() //  [R1]
         { []
         }
     {offset
       c4xGn: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xGn_info" {
     block_c4xGn_info:
         const _c4xGn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.969475942 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cpopCount_closure" {
     GHC.Int.$fBitsInt16_$cpopCount_closure:
         const GHC.Int.$fBitsInt16_$cpopCount_info;
 },
 GHC.Int.$fBitsInt16_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c4xGO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xH2; else goto c4xH3;
       c4xH2: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xH3: // global
           I64[Sp - 8] = block_c4xGL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xH7; else goto c4xGM;
       u4xH7: // global
           call _c4xGL(R1) args: 0, res: 0, upd: 0;
       c4xGM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cpopCount_info" {
     GHC.Int.$fBitsInt16_$cpopCount_info:
         const GHC.Int.$fBitsInt16_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xGL() //  [R1]
         { []
         }
     {offset
       c4xGL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xH6; else goto c4xH5;
       c4xH6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xH5: // global
           (_c4xGU::I64) = call MO_PopCnt W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xGU::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xGL_info" {
     block_c4xGL_info:
         const _c4xGL;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.97599394 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xHD; else goto c4xHE;
       c4xHD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xHE: // global
           I64[Sp - 16] = block_c4xHo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xHK; else goto c4xHp;
       u4xHK: // global
           call _c4xHo(R1) args: 0, res: 0, upd: 0;
       c4xHp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cunsafeShiftR_info" {
     GHC.Int.$fBitsInt16_$cunsafeShiftR_info:
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xHo() //  [R1]
         { []
         }
     {offset
       c4xHo: // global
           I64[Sp] = block_c4xHu_info;
           _s4vH8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vH8::I64;
           if (R1 & 7 != 0) goto u4xHJ; else goto c4xHv;
       u4xHJ: // global
           call _c4xHu(R1) args: 0, res: 0, upd: 0;
       c4xHv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xHo_info" {
     block_c4xHo_info:
         const _c4xHo;
         const 1;
         const 30;
 },
 _c4xHu() //  [R1]
         { []
         }
     {offset
       c4xHu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xHI; else goto c4xHH;
       c4xHI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xHH: // global
           _s4vHb::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vHb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xHu_info" {
     block_c4xHu_info:
         const _c4xHu;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.982923272 UTC

[section ""data" . GHC.Int.$fBitsInt3_closure" {
     GHC.Int.$fBitsInt3_closure:
         const GHC.Int.I16#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.985020643 UTC

[section ""data" . GHC.Int.$fNumInt2_closure" {
     GHC.Int.$fNumInt2_closure:
         const GHC.Int.I16#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:24.990883515 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftR_closure" {
     GHC.Int.$fBitsInt16_$cshiftR_closure:
         const GHC.Int.$fBitsInt16_$cshiftR_info;
 },
 GHC.Int.$fBitsInt16_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xIc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xIg; else goto c4xIh;
       c4xIg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xIh: // global
           I64[Sp - 16] = block_c4xI9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xIH; else goto c4xIa;
       u4xIH: // global
           call _c4xI9(R1) args: 0, res: 0, upd: 0;
       c4xIa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cshiftR_info" {
     GHC.Int.$fBitsInt16_$cshiftR_info:
         const GHC.Int.$fBitsInt16_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xI9() //  [R1]
         { []
         }
     {offset
       c4xI9: // global
           I64[Sp] = block_c4xIf_info;
           _s4vHf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vHf::I64;
           if (R1 & 7 != 0) goto u4xIG; else goto c4xIj;
       u4xIG: // global
           call _c4xIf(R1) args: 0, res: 0, upd: 0;
       c4xIj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xI9_info" {
     block_c4xI9_info:
         const _c4xI9;
         const 1;
         const 30;
 },
 _c4xIf() //  [R1]
         { []
         }
     {offset
       c4xIf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xIp; else goto c4xIo;
       c4xIp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xIo: // global
           _s4vHf::I64 = I64[Sp + 8];
           _s4vHh::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vHh::I64, 64)) goto c4xIy; else goto c4xIF;
       c4xIy: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vHf::I64, _s4vHh::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xIF: // global
           if (%MO_S_Ge_W64(_s4vHf::I64, 0)) goto c4xID; else goto c4xIE;
       c4xID: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xIE: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xIf_info" {
     block_c4xIf_info:
         const _c4xIf;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.004850933 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt16_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt16_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xJ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xJo; else goto c4xJp;
       c4xJo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xJp: // global
           I64[Sp - 16] = block_c4xJ6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xJv; else goto c4xJ7;
       u4xJv: // global
           call _c4xJ6(R1) args: 0, res: 0, upd: 0;
       c4xJ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cunsafeShiftL_info" {
     GHC.Int.$fBitsInt16_$cunsafeShiftL_info:
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xJ6() //  [R1]
         { []
         }
     {offset
       c4xJ6: // global
           I64[Sp] = block_c4xJc_info;
           _s4vHo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vHo::I64;
           if (R1 & 7 != 0) goto u4xJu; else goto c4xJd;
       u4xJu: // global
           call _c4xJc(R1) args: 0, res: 0, upd: 0;
       c4xJd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xJ6_info" {
     block_c4xJ6_info:
         const _c4xJ6;
         const 1;
         const 30;
 },
 _c4xJc() //  [R1]
         { []
         }
     {offset
       c4xJc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xJt; else goto c4xJs;
       c4xJt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xJs: // global
           _s4vHs::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vHs::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xJc_info" {
     block_c4xJc_info:
         const _c4xJc;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.01775125 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshiftL_closure" {
     GHC.Int.$fBitsInt16_$cshiftL_closure:
         const GHC.Int.$fBitsInt16_$cshiftL_info;
 },
 GHC.Int.$fBitsInt16_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xJW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xK0; else goto c4xK1;
       c4xK0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xK1: // global
           I64[Sp - 16] = block_c4xJT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xKo; else goto c4xJU;
       u4xKo: // global
           call _c4xJT(R1) args: 0, res: 0, upd: 0;
       c4xJU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cshiftL_info" {
     GHC.Int.$fBitsInt16_$cshiftL_info:
         const GHC.Int.$fBitsInt16_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xJT() //  [R1]
         { []
         }
     {offset
       c4xJT: // global
           I64[Sp] = block_c4xJZ_info;
           _s4vHw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vHw::I64;
           if (R1 & 7 != 0) goto u4xKn; else goto c4xK3;
       u4xKn: // global
           call _c4xJZ(R1) args: 0, res: 0, upd: 0;
       c4xK3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xJT_info" {
     block_c4xJT_info:
         const _c4xJT;
         const 1;
         const 30;
 },
 _c4xJZ() //  [R1]
         { []
         }
     {offset
       c4xJZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xK9; else goto c4xK8;
       c4xK9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xK8: // global
           _s4vHy::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vHy::I64, 64)) goto c4xKl; else goto c4xKm;
       c4xKl: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[Sp + 8] << _s4vHy::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xKm: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xJZ_info" {
     block_c4xJZ_info:
         const _c4xJZ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.027017348 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cisSigned_closure" {
     GHC.Int.$fBitsInt16_$cisSigned_closure:
         const GHC.Int.$fBitsInt16_$cisSigned_info;
 },
 GHC.Int.$fBitsInt16_$cisSigned_entry() //  []
         { []
         }
     {offset
       c4xKO: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cisSigned_info" {
     GHC.Int.$fBitsInt16_$cisSigned_info:
         const GHC.Int.$fBitsInt16_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.0322524 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotate_closure" {
     GHC.Int.$fBitsInt16_$crotate_closure:
         const GHC.Int.$fBitsInt16_$crotate_info;
 },
 GHC.Int.$fBitsInt16_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xL4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4xL8; else goto c4xL9;
       c4xL8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xL9: // global
           I64[Sp - 16] = block_c4xL1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xM5; else goto c4xL2;
       u4xM5: // global
           call _c4xL1(R1) args: 0, res: 0, upd: 0;
       c4xL2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$crotate_info" {
     GHC.Int.$fBitsInt16_$crotate_info:
         const GHC.Int.$fBitsInt16_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xL1() //  [R1]
         { []
         }
     {offset
       c4xL1: // global
           I64[Sp - 8] = block_c4xL7_info;
           _s4vHF::P64 = R1;
           _s4vHG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vHG::I64;
           P64[Sp + 8] = _s4vHF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xM4; else goto c4xLb;
       u4xM4: // global
           call _c4xL7(R1) args: 0, res: 0, upd: 0;
       c4xLb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xL1_info" {
     block_c4xL1_info:
         const _c4xL1;
         const 1;
         const 30;
 },
 _c4xL7() //  [R1]
         { []
         }
     {offset
       c4xL7: // global
           _s4vHL::I64 = I64[R1 + 7] & 15;
           if (_s4vHL::I64 != 0) goto u4xM2; else goto c4xLY;
       u4xM2: // global
           I64[Sp + 16] = _s4vHL::I64;
           Sp = Sp + 8;
           call _c4xLq() args: 0, res: 0, upd: 0;
       c4xLY: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xL7_info" {
     block_c4xL7_info:
         const _c4xL7;
         const 66;
         const 30;
 },
 _c4xLq() //  []
         { []
         }
     {offset
       c4xLq: // global
           Hp = Hp + 16;
           _s4vHL::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4xLV; else goto c4xLU;
       c4xLV: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4xLp_info;
           R1 = _s4vHL::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4xLU: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4vHM::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4vHM::I64 << _s4vHL::I64) | (_s4vHM::I64 >> 16 - _s4vHL::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4xLp() //  [R1]
         { []
         }
     {offset
       c4xLp: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4xLq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4xLp_info" {
     block_c4xLp_info:
         const _c4xLp;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.04384105 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cshift_closure" {
     GHC.Int.$fBitsInt16_$cshift_closure:
         const GHC.Int.$fBitsInt16_$cshift_info;
 },
 GHC.Int.$fBitsInt16_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xMM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xMQ; else goto c4xMR;
       c4xMQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xMR: // global
           I64[Sp - 16] = block_c4xMJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xNE; else goto c4xMK;
       u4xNE: // global
           call _c4xMJ(R1) args: 0, res: 0, upd: 0;
       c4xMK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cshift_info" {
     GHC.Int.$fBitsInt16_$cshift_info:
         const GHC.Int.$fBitsInt16_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xMJ() //  [R1]
         { []
         }
     {offset
       c4xMJ: // global
           I64[Sp] = block_c4xMP_info;
           _s4vHX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vHX::I64;
           if (R1 & 7 != 0) goto u4xND; else goto c4xMT;
       u4xND: // global
           call _c4xMP(R1) args: 0, res: 0, upd: 0;
       c4xMT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xMJ_info" {
     block_c4xMJ_info:
         const _c4xMJ;
         const 1;
         const 30;
 },
 _c4xMP() //  [R1]
         { []
         }
     {offset
       c4xMP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xMZ; else goto c4xMY;
       c4xMZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xMY: // global
           _s4vHX::I64 = I64[Sp + 8];
           _s4vHZ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vHZ::I64, 0)) goto c4xNn; else goto c4xNC;
       c4xNn: // global
           _s4vI1::I64 = -_s4vHZ::I64;
           if (%MO_S_Lt_W64(_s4vI1::I64, 64)) goto c4xNe; else goto c4xNl;
       c4xNe: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vHX::I64, _s4vI1::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xNl: // global
           if (%MO_S_Ge_W64(_s4vHX::I64, 0)) goto c4xNB; else goto c4xNk;
       c4xNk: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xNC: // global
           if (%MO_S_Ge_W64(_s4vHZ::I64, 64)) goto c4xNB; else goto c4xNA;
       c4xNB: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xNA: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vHX::I64 << _s4vHZ::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xMP_info" {
     block_c4xMP_info:
         const _c4xMP;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.053305065 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplement_closure" {
     GHC.Int.$fBitsInt16_$ccomplement_closure:
         const GHC.Int.$fBitsInt16_$ccomplement_info;
 },
 GHC.Int.$fBitsInt16_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c4xOb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xOo; else goto c4xOp;
       c4xOo: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xOp: // global
           I64[Sp - 8] = block_c4xO8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xOt; else goto c4xO9;
       u4xOt: // global
           call _c4xO8(R1) args: 0, res: 0, upd: 0;
       c4xO9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$ccomplement_info" {
     GHC.Int.$fBitsInt16_$ccomplement_info:
         const GHC.Int.$fBitsInt16_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xO8() //  [R1]
         { []
         }
     {offset
       c4xO8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xOs; else goto c4xOr;
       c4xOs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xOr: // global
           _s4vId::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vId::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xO8_info" {
     block_c4xO8_info:
         const _c4xO8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.059895055 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cxor_closure" {
     GHC.Int.$fBitsInt16_$cxor_closure:
         const GHC.Int.$fBitsInt16_$cxor_info;
 },
 GHC.Int.$fBitsInt16_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xON: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xP8; else goto c4xP9;
       c4xP8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xP9: // global
           I64[Sp - 16] = block_c4xOK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xPf; else goto c4xOL;
       u4xPf: // global
           call _c4xOK(R1) args: 0, res: 0, upd: 0;
       c4xOL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cxor_info" {
     GHC.Int.$fBitsInt16_$cxor_info:
         const GHC.Int.$fBitsInt16_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xOK() //  [R1]
         { []
         }
     {offset
       c4xOK: // global
           I64[Sp] = block_c4xOQ_info;
           _s4vIh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vIh::I64;
           if (R1 & 7 != 0) goto u4xPe; else goto c4xOR;
       u4xPe: // global
           call _c4xOQ(R1) args: 0, res: 0, upd: 0;
       c4xOR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xOK_info" {
     block_c4xOK_info:
         const _c4xOK;
         const 1;
         const 30;
 },
 _c4xOQ() //  [R1]
         { []
         }
     {offset
       c4xOQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xPd; else goto c4xPc;
       c4xPd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xPc: // global
           _s4vIn::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vIn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xOQ_info" {
     block_c4xOQ_info:
         const _c4xOQ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.06910047 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.|._closure" {
     GHC.Int.$fBitsInt16_$c.|._closure:
         const GHC.Int.$fBitsInt16_$c.|._info;
 },
 GHC.Int.$fBitsInt16_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c4xPG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xQ1; else goto c4xQ2;
       c4xQ1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xQ2: // global
           I64[Sp - 16] = block_c4xPD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xQ8; else goto c4xPE;
       u4xQ8: // global
           call _c4xPD(R1) args: 0, res: 0, upd: 0;
       c4xPE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$c.|._info" {
     GHC.Int.$fBitsInt16_$c.|._info:
         const GHC.Int.$fBitsInt16_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xPD() //  [R1]
         { []
         }
     {offset
       c4xPD: // global
           I64[Sp] = block_c4xPJ_info;
           _s4vIr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vIr::I64;
           if (R1 & 7 != 0) goto u4xQ7; else goto c4xPK;
       u4xQ7: // global
           call _c4xPJ(R1) args: 0, res: 0, upd: 0;
       c4xPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xPD_info" {
     block_c4xPD_info:
         const _c4xPD;
         const 1;
         const 30;
 },
 _c4xPJ() //  [R1]
         { []
         }
     {offset
       c4xPJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xQ6; else goto c4xQ5;
       c4xQ6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xQ5: // global
           _s4vIx::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vIx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xPJ_info" {
     block_c4xPJ_info:
         const _c4xPJ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.077321382 UTC

[section ""data" . GHC.Int.$fBitsInt16_$c.&._closure" {
     GHC.Int.$fBitsInt16_$c.&._closure:
         const GHC.Int.$fBitsInt16_$c.&._info;
 },
 GHC.Int.$fBitsInt16_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c4xQz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xQU; else goto c4xQV;
       c4xQU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xQV: // global
           I64[Sp - 16] = block_c4xQw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xR1; else goto c4xQx;
       u4xR1: // global
           call _c4xQw(R1) args: 0, res: 0, upd: 0;
       c4xQx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$c.&._info" {
     GHC.Int.$fBitsInt16_$c.&._info:
         const GHC.Int.$fBitsInt16_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xQw() //  [R1]
         { []
         }
     {offset
       c4xQw: // global
           I64[Sp] = block_c4xQC_info;
           _s4vIB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vIB::I64;
           if (R1 & 7 != 0) goto u4xR0; else goto c4xQD;
       u4xR0: // global
           call _c4xQC(R1) args: 0, res: 0, upd: 0;
       c4xQD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xQw_info" {
     block_c4xQw_info:
         const _c4xQw;
         const 1;
         const 30;
 },
 _c4xQC() //  [R1]
         { []
         }
     {offset
       c4xQC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xQZ; else goto c4xQY;
       c4xQZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xQY: // global
           _s4vIH::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vIH::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xQC_info" {
     block_c4xQC_info:
         const _c4xQC;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.085596975 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4xRs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xRG; else goto c4xRH;
       c4xRG: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xRH: // global
           I64[Sp - 8] = block_c4xRp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xRL; else goto c4xRq;
       u4xRL: // global
           call _c4xRp(R1) args: 0, res: 0, upd: 0;
       c4xRq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info" {
     GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_info:
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xRp() //  [R1]
         { []
         }
     {offset
       c4xRp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xRK; else goto c4xRJ;
       c4xRK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xRJ: // global
           (_c4xRy::I64) = call MO_Ctz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xRy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xRp_info" {
     block_c4xRp_info:
         const _c4xRp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.092367968 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4xS7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xSl; else goto c4xSm;
       c4xSl: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xSm: // global
           I64[Sp - 8] = block_c4xS4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xSq; else goto c4xS5;
       u4xSq: // global
           call _c4xS4(R1) args: 0, res: 0, upd: 0;
       c4xS5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info" {
     GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_info:
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xS4() //  [R1]
         { []
         }
     {offset
       c4xS4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xSp; else goto c4xSo;
       c4xSp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xSo: // global
           (_c4xSd::I64) = call MO_Clz W16(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xSd::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xS4_info" {
     block_c4xS4_info:
         const _c4xS4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.097757461 UTC

[section ""data" . GHC.Int.$fBitsInt1_closure" {
     GHC.Int.$fBitsInt1_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.099883328 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt16_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt16_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c4xSK: // global
           R1 = GHC.Int.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cfiniteBitSize_info" {
     GHC.Int.$fBitsInt16_$cfiniteBitSize_info:
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.103964916 UTC

[section ""data" . GHC.Int.$fNumInt32_$cfromInteger_closure" {
     GHC.Int.$fNumInt32_$cfromInteger_closure:
         const GHC.Int.$fNumInt32_$cfromInteger_info;
 },
 GHC.Int.$fNumInt32_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c4xSY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xT5; else goto c4xT6;
       c4xT5: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xT6: // global
           I64[Sp - 8] = block_c4xSW_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$cfromInteger_info" {
     GHC.Int.$fNumInt32_$cfromInteger_info:
         const GHC.Int.$fNumInt32_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xSW() //  [R1]
         { []
         }
     {offset
       c4xSW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xT9; else goto c4xT8;
       c4xT9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4xT8: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xSW_info" {
     block_c4xSW_info:
         const _c4xSW;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.110619655 UTC

[section ""data" . GHC.Int.$fNumInt32_$cnegate_closure" {
     GHC.Int.$fNumInt32_$cnegate_closure:
         const GHC.Int.$fNumInt32_$cnegate_info;
 },
 GHC.Int.$fNumInt32_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c4xTt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xTD; else goto c4xTE;
       c4xTD: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xTE: // global
           I64[Sp - 8] = block_c4xTq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xTI; else goto c4xTr;
       u4xTI: // global
           call _c4xTq(R1) args: 0, res: 0, upd: 0;
       c4xTr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$cnegate_info" {
     GHC.Int.$fNumInt32_$cnegate_info:
         const GHC.Int.$fNumInt32_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xTq() //  [R1]
         { []
         }
     {offset
       c4xTq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xTH; else goto c4xTG;
       c4xTH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xTG: // global
           _s4vJ2::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJ2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xTq_info" {
     block_c4xTq_info:
         const _c4xTq;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.116931138 UTC

[section ""data" . GHC.Int.$fNumInt32_$c*_closure" {
     GHC.Int.$fNumInt32_$c*_closure:
         const GHC.Int.$fNumInt32_$c*_info;
 },
 GHC.Int.$fNumInt32_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xU3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xUi; else goto c4xUj;
       c4xUi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xUj: // global
           I64[Sp - 16] = block_c4xU0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xUp; else goto c4xU1;
       u4xUp: // global
           call _c4xU0(R1) args: 0, res: 0, upd: 0;
       c4xU1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$c*_info" {
     GHC.Int.$fNumInt32_$c*_info:
         const GHC.Int.$fNumInt32_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xU0() //  [R1]
         { []
         }
     {offset
       c4xU0: // global
           I64[Sp] = block_c4xU6_info;
           _s4vJ6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJ6::I64;
           if (R1 & 7 != 0) goto u4xUo; else goto c4xU7;
       u4xUo: // global
           call _c4xU6(R1) args: 0, res: 0, upd: 0;
       c4xU7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xU0_info" {
     block_c4xU0_info:
         const _c4xU0;
         const 1;
         const 30;
 },
 _c4xU6() //  [R1]
         { []
         }
     {offset
       c4xU6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xUn; else goto c4xUm;
       c4xUn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xUm: // global
           _s4vJa::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] * I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xU6_info" {
     block_c4xU6_info:
         const _c4xU6;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.125814371 UTC

[section ""data" . GHC.Int.$fNumInt32_$c-_closure" {
     GHC.Int.$fNumInt32_$c-_closure:
         const GHC.Int.$fNumInt32_$c-_info;
 },
 GHC.Int.$fNumInt32_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xUR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xV6; else goto c4xV7;
       c4xV6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xV7: // global
           I64[Sp - 16] = block_c4xUO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xVd; else goto c4xUP;
       u4xVd: // global
           call _c4xUO(R1) args: 0, res: 0, upd: 0;
       c4xUP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$c-_info" {
     GHC.Int.$fNumInt32_$c-_info:
         const GHC.Int.$fNumInt32_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xUO() //  [R1]
         { []
         }
     {offset
       c4xUO: // global
           I64[Sp] = block_c4xUU_info;
           _s4vJe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJe::I64;
           if (R1 & 7 != 0) goto u4xVc; else goto c4xUV;
       u4xVc: // global
           call _c4xUU(R1) args: 0, res: 0, upd: 0;
       c4xUV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xUO_info" {
     block_c4xUO_info:
         const _c4xUO;
         const 1;
         const 30;
 },
 _c4xUU() //  [R1]
         { []
         }
     {offset
       c4xUU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xVb; else goto c4xVa;
       c4xVb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xVa: // global
           _s4vJi::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] - I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJi::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xUU_info" {
     block_c4xUU_info:
         const _c4xUU;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.134544523 UTC

[section ""data" . GHC.Int.$fNumInt32_$c+_closure" {
     GHC.Int.$fNumInt32_$c+_closure:
         const GHC.Int.$fNumInt32_$c+_info;
 },
 GHC.Int.$fNumInt32_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xVF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xVU; else goto c4xVV;
       c4xVU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xVV: // global
           I64[Sp - 16] = block_c4xVC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xW1; else goto c4xVD;
       u4xW1: // global
           call _c4xVC(R1) args: 0, res: 0, upd: 0;
       c4xVD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$c+_info" {
     GHC.Int.$fNumInt32_$c+_info:
         const GHC.Int.$fNumInt32_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xVC() //  [R1]
         { []
         }
     {offset
       c4xVC: // global
           I64[Sp] = block_c4xVI_info;
           _s4vJm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJm::I64;
           if (R1 & 7 != 0) goto u4xW0; else goto c4xVJ;
       u4xW0: // global
           call _c4xVI(R1) args: 0, res: 0, upd: 0;
       c4xVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xVC_info" {
     block_c4xVC_info:
         const _c4xVC;
         const 1;
         const 30;
 },
 _c4xVI() //  [R1]
         { []
         }
     {offset
       c4xVI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xVZ; else goto c4xVY;
       c4xVZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xVY: // global
           _s4vJq::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] + I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xVI_info" {
     block_c4xVI_info:
         const _c4xVI;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.14216307 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt32_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt32_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt32_$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c4xWt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xWu; else goto c4xWv;
       c4xWu: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xWv: // global
           I64[Sp - 8] = block_c4xWq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xWz; else goto c4xWr;
       u4xWz: // global
           call _c4xWq(R1) args: 0, res: 0, upd: 0;
       c4xWr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$ctoInteger_info" {
     GHC.Int.$fIntegralInt32_$ctoInteger_info:
         const GHC.Int.$fIntegralInt32_$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xWq() //  [R1]
         { []
         }
     {offset
       c4xWq: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xWq_info" {
     block_c4xWq_info:
         const _c4xWq;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.148275194 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cpopCount_closure" {
     GHC.Int.$fBitsInt32_$cpopCount_closure:
         const GHC.Int.$fBitsInt32_$cpopCount_info;
 },
 GHC.Int.$fBitsInt32_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c4xWR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4xX5; else goto c4xX6;
       c4xX5: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4xX6: // global
           I64[Sp - 8] = block_c4xWO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4xXa; else goto c4xWP;
       u4xXa: // global
           call _c4xWO(R1) args: 0, res: 0, upd: 0;
       c4xWP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cpopCount_info" {
     GHC.Int.$fBitsInt32_$cpopCount_info:
         const GHC.Int.$fBitsInt32_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4xWO() //  [R1]
         { []
         }
     {offset
       c4xWO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xX9; else goto c4xX8;
       c4xX9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xX8: // global
           (_c4xWX::I64) = call MO_PopCnt W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4xWX::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xWO_info" {
     block_c4xWO_info:
         const _c4xWO;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.155702008 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xXu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xXG; else goto c4xXH;
       c4xXG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xXH: // global
           I64[Sp - 16] = block_c4xXr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xXN; else goto c4xXs;
       u4xXN: // global
           call _c4xXr(R1) args: 0, res: 0, upd: 0;
       c4xXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cunsafeShiftR_info" {
     GHC.Int.$fBitsInt32_$cunsafeShiftR_info:
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xXr() //  [R1]
         { []
         }
     {offset
       c4xXr: // global
           I64[Sp] = block_c4xXx_info;
           _s4vJD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJD::I64;
           if (R1 & 7 != 0) goto u4xXM; else goto c4xXy;
       u4xXM: // global
           call _c4xXx(R1) args: 0, res: 0, upd: 0;
       c4xXy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xXr_info" {
     block_c4xXr_info:
         const _c4xXr;
         const 1;
         const 30;
 },
 _c4xXx() //  [R1]
         { []
         }
     {offset
       c4xXx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xXL; else goto c4xXK;
       c4xXL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xXK: // global
           _s4vJG::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xXx_info" {
     block_c4xXx_info:
         const _c4xXx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.162760148 UTC

[section ""data" . GHC.Int.$fBitsInt6_closure" {
     GHC.Int.$fBitsInt6_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.164466552 UTC

[section ""data" . GHC.Int.$fNumInt4_closure" {
     GHC.Int.$fNumInt4_closure:
         const GHC.Int.I32#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.167961944 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftR_closure" {
     GHC.Int.$fBitsInt32_$cshiftR_closure:
         const GHC.Int.$fBitsInt32_$cshiftR_info;
 },
 GHC.Int.$fBitsInt32_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xYf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xYj; else goto c4xYk;
       c4xYj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xYk: // global
           I64[Sp - 16] = block_c4xYc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xYK; else goto c4xYd;
       u4xYK: // global
           call _c4xYc(R1) args: 0, res: 0, upd: 0;
       c4xYd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cshiftR_info" {
     GHC.Int.$fBitsInt32_$cshiftR_info:
         const GHC.Int.$fBitsInt32_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xYc() //  [R1]
         { []
         }
     {offset
       c4xYc: // global
           I64[Sp] = block_c4xYi_info;
           _s4vJK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJK::I64;
           if (R1 & 7 != 0) goto u4xYJ; else goto c4xYm;
       u4xYJ: // global
           call _c4xYi(R1) args: 0, res: 0, upd: 0;
       c4xYm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xYc_info" {
     block_c4xYc_info:
         const _c4xYc;
         const 1;
         const 30;
 },
 _c4xYi() //  [R1]
         { []
         }
     {offset
       c4xYi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xYs; else goto c4xYr;
       c4xYs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xYr: // global
           _s4vJK::I64 = I64[Sp + 8];
           _s4vJM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vJM::I64, 64)) goto c4xYB; else goto c4xYI;
       c4xYB: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vJK::I64, _s4vJM::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xYI: // global
           if (%MO_S_Ge_W64(_s4vJK::I64, 0)) goto c4xYG; else goto c4xYH;
       c4xYG: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4xYH: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xYi_info" {
     block_c4xYi_info:
         const _c4xYi;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.177195458 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt32_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt32_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xZc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4xZr; else goto c4xZs;
       c4xZr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4xZs: // global
           I64[Sp - 16] = block_c4xZ9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4xZy; else goto c4xZa;
       u4xZy: // global
           call _c4xZ9(R1) args: 0, res: 0, upd: 0;
       c4xZa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cunsafeShiftL_info" {
     GHC.Int.$fBitsInt32_$cunsafeShiftL_info:
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xZ9() //  [R1]
         { []
         }
     {offset
       c4xZ9: // global
           I64[Sp] = block_c4xZf_info;
           _s4vJT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vJT::I64;
           if (R1 & 7 != 0) goto u4xZx; else goto c4xZg;
       u4xZx: // global
           call _c4xZf(R1) args: 0, res: 0, upd: 0;
       c4xZg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xZ9_info" {
     block_c4xZ9_info:
         const _c4xZ9;
         const 1;
         const 30;
 },
 _c4xZf() //  [R1]
         { []
         }
     {offset
       c4xZf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4xZw; else goto c4xZv;
       c4xZw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4xZv: // global
           _s4vJX::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vJX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xZf_info" {
     block_c4xZf_info:
         const _c4xZf;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.18602763 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshiftL_closure" {
     GHC.Int.$fBitsInt32_$cshiftL_closure:
         const GHC.Int.$fBitsInt32_$cshiftL_info;
 },
 GHC.Int.$fBitsInt32_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4xZY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4y02; else goto c4y03;
       c4y02: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y03: // global
           I64[Sp - 16] = block_c4xZV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y0q; else goto c4xZW;
       u4y0q: // global
           call _c4xZV(R1) args: 0, res: 0, upd: 0;
       c4xZW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cshiftL_info" {
     GHC.Int.$fBitsInt32_$cshiftL_info:
         const GHC.Int.$fBitsInt32_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4xZV() //  [R1]
         { []
         }
     {offset
       c4xZV: // global
           I64[Sp] = block_c4y01_info;
           _s4vK1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vK1::I64;
           if (R1 & 7 != 0) goto u4y0p; else goto c4y05;
       u4y0p: // global
           call _c4y01(R1) args: 0, res: 0, upd: 0;
       c4y05: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4xZV_info" {
     block_c4xZV_info:
         const _c4xZV;
         const 1;
         const 30;
 },
 _c4y01() //  [R1]
         { []
         }
     {offset
       c4y01: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y0b; else goto c4y0a;
       c4y0b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y0a: // global
           _s4vK3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vK3::I64, 64)) goto c4y0n; else goto c4y0o;
       c4y0n: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8] << _s4vK3::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4y0o: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y01_info" {
     block_c4y01_info:
         const _c4y01;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.19405395 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cisSigned_closure" {
     GHC.Int.$fBitsInt32_$cisSigned_closure:
         const GHC.Int.$fBitsInt32_$cisSigned_info;
 },
 GHC.Int.$fBitsInt32_$cisSigned_entry() //  []
         { []
         }
     {offset
       c4y0P: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cisSigned_info" {
     GHC.Int.$fBitsInt32_$cisSigned_info:
         const GHC.Int.$fBitsInt32_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.199310169 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotate_closure" {
     GHC.Int.$fBitsInt32_$crotate_closure:
         const GHC.Int.$fBitsInt32_$crotate_info;
 },
 GHC.Int.$fBitsInt32_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c4y15: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4y19; else goto c4y1a;
       c4y19: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y1a: // global
           I64[Sp - 16] = block_c4y12_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y26; else goto c4y13;
       u4y26: // global
           call _c4y12(R1) args: 0, res: 0, upd: 0;
       c4y13: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$crotate_info" {
     GHC.Int.$fBitsInt32_$crotate_info:
         const GHC.Int.$fBitsInt32_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4y12() //  [R1]
         { []
         }
     {offset
       c4y12: // global
           I64[Sp - 8] = block_c4y18_info;
           _s4vKa::P64 = R1;
           _s4vKb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vKb::I64;
           P64[Sp + 8] = _s4vKa::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4y25; else goto c4y1c;
       u4y25: // global
           call _c4y18(R1) args: 0, res: 0, upd: 0;
       c4y1c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y12_info" {
     block_c4y12_info:
         const _c4y12;
         const 1;
         const 30;
 },
 _c4y18() //  [R1]
         { []
         }
     {offset
       c4y18: // global
           _s4vKg::I64 = I64[R1 + 7] & 31;
           if (_s4vKg::I64 != 0) goto u4y23; else goto c4y1Z;
       u4y23: // global
           I64[Sp + 16] = _s4vKg::I64;
           Sp = Sp + 8;
           call _c4y1r() args: 0, res: 0, upd: 0;
       c4y1Z: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y18_info" {
     block_c4y18_info:
         const _c4y18;
         const 66;
         const 30;
 },
 _c4y1r() //  []
         { []
         }
     {offset
       c4y1r: // global
           Hp = Hp + 16;
           _s4vKg::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4y1W; else goto c4y1V;
       c4y1W: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4y1q_info;
           R1 = _s4vKg::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4y1V: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4vKh::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4vKh::I64 << _s4vKg::I64) | (_s4vKh::I64 >> 32 - _s4vKg::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4y1q() //  [R1]
         { []
         }
     {offset
       c4y1q: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4y1r() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4y1q_info" {
     block_c4y1q_info:
         const _c4y1q;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.211809438 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cshift_closure" {
     GHC.Int.$fBitsInt32_$cshift_closure:
         const GHC.Int.$fBitsInt32_$cshift_info;
 },
 GHC.Int.$fBitsInt32_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c4y2N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4y2R; else goto c4y2S;
       c4y2R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y2S: // global
           I64[Sp - 16] = block_c4y2K_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y3F; else goto c4y2L;
       u4y3F: // global
           call _c4y2K(R1) args: 0, res: 0, upd: 0;
       c4y2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cshift_info" {
     GHC.Int.$fBitsInt32_$cshift_info:
         const GHC.Int.$fBitsInt32_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4y2K() //  [R1]
         { []
         }
     {offset
       c4y2K: // global
           I64[Sp] = block_c4y2Q_info;
           _s4vKs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vKs::I64;
           if (R1 & 7 != 0) goto u4y3E; else goto c4y2U;
       u4y3E: // global
           call _c4y2Q(R1) args: 0, res: 0, upd: 0;
       c4y2U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y2K_info" {
     block_c4y2K_info:
         const _c4y2K;
         const 1;
         const 30;
 },
 _c4y2Q() //  [R1]
         { []
         }
     {offset
       c4y2Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y30; else goto c4y2Z;
       c4y30: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y2Z: // global
           _s4vKs::I64 = I64[Sp + 8];
           _s4vKu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vKu::I64, 0)) goto c4y3o; else goto c4y3D;
       c4y3o: // global
           _s4vKw::I64 = -_s4vKu::I64;
           if (%MO_S_Lt_W64(_s4vKw::I64, 64)) goto c4y3f; else goto c4y3m;
       c4y3f: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vKs::I64, _s4vKw::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4y3m: // global
           if (%MO_S_Ge_W64(_s4vKs::I64, 0)) goto c4y3C; else goto c4y3l;
       c4y3l: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4y3D: // global
           if (%MO_S_Ge_W64(_s4vKu::I64, 64)) goto c4y3C; else goto c4y3B;
       c4y3C: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4y3B: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4vKs::I64 << _s4vKu::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y2Q_info" {
     block_c4y2Q_info:
         const _c4y2Q;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.220567927 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplement_closure" {
     GHC.Int.$fBitsInt32_$ccomplement_closure:
         const GHC.Int.$fBitsInt32_$ccomplement_info;
 },
 GHC.Int.$fBitsInt32_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c4y4b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4y4o; else goto c4y4p;
       c4y4o: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4y4p: // global
           I64[Sp - 8] = block_c4y48_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4y4t; else goto c4y49;
       u4y4t: // global
           call _c4y48(R1) args: 0, res: 0, upd: 0;
       c4y49: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$ccomplement_info" {
     GHC.Int.$fBitsInt32_$ccomplement_info:
         const GHC.Int.$fBitsInt32_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4y48() //  [R1]
         { []
         }
     {offset
       c4y48: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y4s; else goto c4y4r;
       c4y4s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y4r: // global
           _s4vKI::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vKI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y48_info" {
     block_c4y48_info:
         const _c4y48;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.226996362 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cxor_closure" {
     GHC.Int.$fBitsInt32_$cxor_closure:
         const GHC.Int.$fBitsInt32_$cxor_info;
 },
 GHC.Int.$fBitsInt32_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c4y4N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4y58; else goto c4y59;
       c4y58: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y59: // global
           I64[Sp - 16] = block_c4y4K_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y5f; else goto c4y4L;
       u4y5f: // global
           call _c4y4K(R1) args: 0, res: 0, upd: 0;
       c4y4L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cxor_info" {
     GHC.Int.$fBitsInt32_$cxor_info:
         const GHC.Int.$fBitsInt32_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4y4K() //  [R1]
         { []
         }
     {offset
       c4y4K: // global
           I64[Sp] = block_c4y4Q_info;
           _s4vKM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vKM::I64;
           if (R1 & 7 != 0) goto u4y5e; else goto c4y4R;
       u4y5e: // global
           call _c4y4Q(R1) args: 0, res: 0, upd: 0;
       c4y4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y4K_info" {
     block_c4y4K_info:
         const _c4y4K;
         const 1;
         const 30;
 },
 _c4y4Q() //  [R1]
         { []
         }
     {offset
       c4y4Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y5d; else goto c4y5c;
       c4y5d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y5c: // global
           _s4vKS::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vKS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y4Q_info" {
     block_c4y4Q_info:
         const _c4y4Q;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.235901584 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.|._closure" {
     GHC.Int.$fBitsInt32_$c.|._closure:
         const GHC.Int.$fBitsInt32_$c.|._info;
 },
 GHC.Int.$fBitsInt32_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c4y5G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4y61; else goto c4y62;
       c4y61: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y62: // global
           I64[Sp - 16] = block_c4y5D_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y68; else goto c4y5E;
       u4y68: // global
           call _c4y5D(R1) args: 0, res: 0, upd: 0;
       c4y5E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$c.|._info" {
     GHC.Int.$fBitsInt32_$c.|._info:
         const GHC.Int.$fBitsInt32_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4y5D() //  [R1]
         { []
         }
     {offset
       c4y5D: // global
           I64[Sp] = block_c4y5J_info;
           _s4vKW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vKW::I64;
           if (R1 & 7 != 0) goto u4y67; else goto c4y5K;
       u4y67: // global
           call _c4y5J(R1) args: 0, res: 0, upd: 0;
       c4y5K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y5D_info" {
     block_c4y5D_info:
         const _c4y5D;
         const 1;
         const 30;
 },
 _c4y5J() //  [R1]
         { []
         }
     {offset
       c4y5J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y66; else goto c4y65;
       c4y66: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y65: // global
           _s4vL2::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vL2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y5J_info" {
     block_c4y5J_info:
         const _c4y5J;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.244214783 UTC

[section ""data" . GHC.Int.$fBitsInt32_$c.&._closure" {
     GHC.Int.$fBitsInt32_$c.&._closure:
         const GHC.Int.$fBitsInt32_$c.&._info;
 },
 GHC.Int.$fBitsInt32_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c4y6z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4y6U; else goto c4y6V;
       c4y6U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4y6V: // global
           I64[Sp - 16] = block_c4y6w_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4y71; else goto c4y6x;
       u4y71: // global
           call _c4y6w(R1) args: 0, res: 0, upd: 0;
       c4y6x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$c.&._info" {
     GHC.Int.$fBitsInt32_$c.&._info:
         const GHC.Int.$fBitsInt32_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4y6w() //  [R1]
         { []
         }
     {offset
       c4y6w: // global
           I64[Sp] = block_c4y6C_info;
           _s4vL6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vL6::I64;
           if (R1 & 7 != 0) goto u4y70; else goto c4y6D;
       u4y70: // global
           call _c4y6C(R1) args: 0, res: 0, upd: 0;
       c4y6D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y6w_info" {
     block_c4y6w_info:
         const _c4y6w;
         const 1;
         const 30;
 },
 _c4y6C() //  [R1]
         { []
         }
     {offset
       c4y6C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y6Z; else goto c4y6Y;
       c4y6Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y6Y: // global
           _s4vLc::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4vLc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y6C_info" {
     block_c4y6C_info:
         const _c4y6C;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.252551185 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4y7s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4y7G; else goto c4y7H;
       c4y7G: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4y7H: // global
           I64[Sp - 8] = block_c4y7p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4y7L; else goto c4y7q;
       u4y7L: // global
           call _c4y7p(R1) args: 0, res: 0, upd: 0;
       c4y7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info" {
     GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_info:
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4y7p() //  [R1]
         { []
         }
     {offset
       c4y7p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y7K; else goto c4y7J;
       c4y7K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y7J: // global
           (_c4y7y::I64) = call MO_Ctz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4y7y::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y7p_info" {
     block_c4y7p_info:
         const _c4y7p;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.259037641 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4y87: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4y8l; else goto c4y8m;
       c4y8l: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4y8m: // global
           I64[Sp - 8] = block_c4y84_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4y8q; else goto c4y85;
       u4y8q: // global
           call _c4y84(R1) args: 0, res: 0, upd: 0;
       c4y85: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info" {
     GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_info:
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4y84() //  [R1]
         { []
         }
     {offset
       c4y84: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y8p; else goto c4y8o;
       c4y8p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y8o: // global
           (_c4y8d::I64) = call MO_Clz W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4y8d::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y84_info" {
     block_c4y84_info:
         const _c4y84;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.26424673 UTC

[section ""data" . GHC.Int.$fBitsInt4_closure" {
     GHC.Int.$fBitsInt4_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.266570439 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt32_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt32_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c4y8K: // global
           R1 = GHC.Int.$fBitsInt4_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cfiniteBitSize_info" {
     GHC.Int.$fBitsInt32_$cfiniteBitSize_info:
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.270792812 UTC

[section ""data" . GHC.Int.$fNumInt64_$cfromInteger_closure" {
     GHC.Int.$fNumInt64_$cfromInteger_closure:
         const GHC.Int.$fNumInt64_$cfromInteger_info;
 },
 GHC.Int.$fNumInt64_$cfromInteger_entry() //  [R2]
         { []
         }
     {offset
       c4y8Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4y92; else goto c4y93;
       c4y92: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4y93: // global
           I64[Sp - 8] = block_c4y8W_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$cfromInteger_info" {
     GHC.Int.$fNumInt64_$cfromInteger_info:
         const GHC.Int.$fNumInt64_$cfromInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4y8W() //  [R1]
         { []
         }
     {offset
       c4y8W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y96; else goto c4y95;
       c4y96: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4y95: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y8W_info" {
     block_c4y8W_info:
         const _c4y8W;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.277223643 UTC

[section ""data" . GHC.Int.$fNumInt64_$cnegate_closure" {
     GHC.Int.$fNumInt64_$cnegate_closure:
         const GHC.Int.$fNumInt64_$cnegate_info;
 },
 GHC.Int.$fNumInt64_$cnegate_entry() //  [R2]
         { []
         }
     {offset
       c4y9p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4y9w; else goto c4y9x;
       c4y9w: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4y9x: // global
           I64[Sp - 8] = block_c4y9m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4y9B; else goto c4y9n;
       u4y9B: // global
           call _c4y9m(R1) args: 0, res: 0, upd: 0;
       c4y9n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$cnegate_info" {
     GHC.Int.$fNumInt64_$cnegate_info:
         const GHC.Int.$fNumInt64_$cnegate_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4y9m() //  [R1]
         { []
         }
     {offset
       c4y9m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4y9A; else goto c4y9z;
       c4y9A: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4y9z: // global
           _s4vLv::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vLv::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y9m_info" {
     block_c4y9m_info:
         const _c4y9m;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.284246853 UTC

[section ""data" . GHC.Int.$fNumInt64_$c*_closure" {
     GHC.Int.$fNumInt64_$c*_closure:
         const GHC.Int.$fNumInt64_$c*_info;
 },
 GHC.Int.$fNumInt64_$c*_entry() //  [R2, R3]
         { []
         }
     {offset
       c4y9V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ya7; else goto c4ya8;
       c4ya7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ya8: // global
           I64[Sp - 16] = block_c4y9S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yae; else goto c4y9T;
       u4yae: // global
           call _c4y9S(R1) args: 0, res: 0, upd: 0;
       c4y9T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$c*_info" {
     GHC.Int.$fNumInt64_$c*_info:
         const GHC.Int.$fNumInt64_$c*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4y9S() //  [R1]
         { []
         }
     {offset
       c4y9S: // global
           I64[Sp] = block_c4y9Y_info;
           _s4vLz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vLz::I64;
           if (R1 & 7 != 0) goto u4yad; else goto c4y9Z;
       u4yad: // global
           call _c4y9Y(R1) args: 0, res: 0, upd: 0;
       c4y9Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y9S_info" {
     block_c4y9S_info:
         const _c4y9S;
         const 1;
         const 30;
 },
 _c4y9Y() //  [R1]
         { []
         }
     {offset
       c4y9Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yac; else goto c4yab;
       c4yac: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yab: // global
           _s4vLC::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vLC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4y9Y_info" {
     block_c4y9Y_info:
         const _c4y9Y;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.293182092 UTC

[section ""data" . GHC.Int.$fNumInt64_$c-_closure" {
     GHC.Int.$fNumInt64_$c-_closure:
         const GHC.Int.$fNumInt64_$c-_info;
 },
 GHC.Int.$fNumInt64_$c-_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yaF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yaR; else goto c4yaS;
       c4yaR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yaS: // global
           I64[Sp - 16] = block_c4yaC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yaY; else goto c4yaD;
       u4yaY: // global
           call _c4yaC(R1) args: 0, res: 0, upd: 0;
       c4yaD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$c-_info" {
     GHC.Int.$fNumInt64_$c-_info:
         const GHC.Int.$fNumInt64_$c-_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yaC() //  [R1]
         { []
         }
     {offset
       c4yaC: // global
           I64[Sp] = block_c4yaI_info;
           _s4vLG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vLG::I64;
           if (R1 & 7 != 0) goto u4yaX; else goto c4yaJ;
       u4yaX: // global
           call _c4yaI(R1) args: 0, res: 0, upd: 0;
       c4yaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yaC_info" {
     block_c4yaC_info:
         const _c4yaC;
         const 1;
         const 30;
 },
 _c4yaI() //  [R1]
         { []
         }
     {offset
       c4yaI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yaW; else goto c4yaV;
       c4yaW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yaV: // global
           _s4vLJ::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vLJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yaI_info" {
     block_c4yaI_info:
         const _c4yaI;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.30181811 UTC

[section ""data" . GHC.Int.$fNumInt64_$c+_closure" {
     GHC.Int.$fNumInt64_$c+_closure:
         const GHC.Int.$fNumInt64_$c+_info;
 },
 GHC.Int.$fNumInt64_$c+_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ybp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ybB; else goto c4ybC;
       c4ybB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ybC: // global
           I64[Sp - 16] = block_c4ybm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ybI; else goto c4ybn;
       u4ybI: // global
           call _c4ybm(R1) args: 0, res: 0, upd: 0;
       c4ybn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$c+_info" {
     GHC.Int.$fNumInt64_$c+_info:
         const GHC.Int.$fNumInt64_$c+_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4ybm() //  [R1]
         { []
         }
     {offset
       c4ybm: // global
           I64[Sp] = block_c4ybs_info;
           _s4vLN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vLN::I64;
           if (R1 & 7 != 0) goto u4ybH; else goto c4ybt;
       u4ybH: // global
           call _c4ybs(R1) args: 0, res: 0, upd: 0;
       c4ybt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ybm_info" {
     block_c4ybm_info:
         const _c4ybm;
         const 1;
         const 30;
 },
 _c4ybs() //  [R1]
         { []
         }
     {offset
       c4ybs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ybG; else goto c4ybF;
       c4ybG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ybF: // global
           _s4vLQ::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vLQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ybs_info" {
     block_c4ybs_info:
         const _c4ybs;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.30970333 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$ctoInteger_closure" {
     GHC.Int.$fIntegralInt64_$ctoInteger_closure:
         const GHC.Int.$fIntegralInt64_$ctoInteger_info;
 },
 GHC.Int.$fIntegralInt64_$ctoInteger_entry() //  [R2]
         { []
         }
     {offset
       c4yc9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yca; else goto c4ycb;
       c4yca: // global
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$ctoInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ycb: // global
           I64[Sp - 8] = block_c4yc6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ycf; else goto c4yc7;
       u4ycf: // global
           call _c4yc6(R1) args: 0, res: 0, upd: 0;
       c4yc7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$ctoInteger_info" {
     GHC.Int.$fIntegralInt64_$ctoInteger_info:
         const GHC.Int.$fIntegralInt64_$ctoInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4yc6() //  [R1]
         { []
         }
     {offset
       c4yc6: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yc6_info" {
     block_c4yc6_info:
         const _c4yc6;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.316377266 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cpopCount_closure" {
     GHC.Int.$fBitsInt64_$cpopCount_closure:
         const GHC.Int.$fBitsInt64_$cpopCount_info;
 },
 GHC.Int.$fBitsInt64_$cpopCount_entry() //  [R2]
         { []
         }
     {offset
       c4ycx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ycL; else goto c4ycM;
       c4ycL: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ycM: // global
           I64[Sp - 8] = block_c4ycu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ycQ; else goto c4ycv;
       u4ycQ: // global
           call _c4ycu(R1) args: 0, res: 0, upd: 0;
       c4ycv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cpopCount_info" {
     GHC.Int.$fBitsInt64_$cpopCount_info:
         const GHC.Int.$fBitsInt64_$cpopCount_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4ycu() //  [R1]
         { []
         }
     {offset
       c4ycu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ycP; else goto c4ycO;
       c4ycP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ycO: // global
           (_c4ycD::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4ycD::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ycu_info" {
     block_c4ycu_info:
         const _c4ycu;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.323221877 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftR_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftR_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yda: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ydm; else goto c4ydn;
       c4ydm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ydn: // global
           I64[Sp - 16] = block_c4yd7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ydt; else goto c4yd8;
       u4ydt: // global
           call _c4yd7(R1) args: 0, res: 0, upd: 0;
       c4yd8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cunsafeShiftR_info" {
     GHC.Int.$fBitsInt64_$cunsafeShiftR_info:
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yd7() //  [R1]
         { []
         }
     {offset
       c4yd7: // global
           I64[Sp] = block_c4ydd_info;
           _s4vM3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vM3::I64;
           if (R1 & 7 != 0) goto u4yds; else goto c4yde;
       u4yds: // global
           call _c4ydd(R1) args: 0, res: 0, upd: 0;
       c4yde: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yd7_info" {
     block_c4yd7_info:
         const _c4yd7;
         const 1;
         const 30;
 },
 _c4ydd() //  [R1]
         { []
         }
     {offset
       c4ydd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ydr; else goto c4ydq;
       c4ydr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ydq: // global
           _s4vM6::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vM6::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ydd_info" {
     block_c4ydd_info:
         const _c4ydd;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.330433323 UTC

[section ""data" . GHC.Int.$fBitsInt10_closure" {
     GHC.Int.$fBitsInt10_closure:
         const GHC.Int.I64#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.332176551 UTC

[section ""data" . GHC.Int.$fNumInt6_closure" {
     GHC.Int.$fNumInt6_closure:
         const GHC.Int.I64#_con_info;
         const (-1);
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.336056648 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftR_closure" {
     GHC.Int.$fBitsInt64_$cshiftR_closure:
         const GHC.Int.$fBitsInt64_$cshiftR_info;
 },
 GHC.Int.$fBitsInt64_$cshiftR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ydV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ydZ; else goto c4ye0;
       c4ydZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ye0: // global
           I64[Sp - 16] = block_c4ydS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yeq; else goto c4ydT;
       u4yeq: // global
           call _c4ydS(R1) args: 0, res: 0, upd: 0;
       c4ydT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cshiftR_info" {
     GHC.Int.$fBitsInt64_$cshiftR_info:
         const GHC.Int.$fBitsInt64_$cshiftR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4ydS() //  [R1]
         { []
         }
     {offset
       c4ydS: // global
           I64[Sp] = block_c4ydY_info;
           _s4vMa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vMa::I64;
           if (R1 & 7 != 0) goto u4yep; else goto c4ye2;
       u4yep: // global
           call _c4ydY(R1) args: 0, res: 0, upd: 0;
       c4ye2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ydS_info" {
     block_c4ydS_info:
         const _c4ydS;
         const 1;
         const 30;
 },
 _c4ydY() //  [R1]
         { []
         }
     {offset
       c4ydY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ye8; else goto c4ye7;
       c4ye8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ye7: // global
           _s4vMa::I64 = I64[Sp + 8];
           _s4vMc::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vMc::I64, 64)) goto c4yeh; else goto c4yeo;
       c4yeh: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vMa::I64, _s4vMc::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yeo: // global
           if (%MO_S_Ge_W64(_s4vMa::I64, 0)) goto c4yem; else goto c4yen;
       c4yem: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yen: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ydY_info" {
     block_c4ydY_info:
         const _c4ydY;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.344497816 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cunsafeShiftL_closure" {
     GHC.Int.$fBitsInt64_$cunsafeShiftL_closure:
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_info;
 },
 GHC.Int.$fBitsInt64_$cunsafeShiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yeS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yf4; else goto c4yf5;
       c4yf4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yf5: // global
           I64[Sp - 16] = block_c4yeP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yfb; else goto c4yeQ;
       u4yfb: // global
           call _c4yeP(R1) args: 0, res: 0, upd: 0;
       c4yeQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cunsafeShiftL_info" {
     GHC.Int.$fBitsInt64_$cunsafeShiftL_info:
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yeP() //  [R1]
         { []
         }
     {offset
       c4yeP: // global
           I64[Sp] = block_c4yeV_info;
           _s4vMj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vMj::I64;
           if (R1 & 7 != 0) goto u4yfa; else goto c4yeW;
       u4yfa: // global
           call _c4yeV(R1) args: 0, res: 0, upd: 0;
       c4yeW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yeP_info" {
     block_c4yeP_info:
         const _c4yeP;
         const 1;
         const 30;
 },
 _c4yeV() //  [R1]
         { []
         }
     {offset
       c4yeV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yf9; else goto c4yf8;
       c4yf9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yf8: // global
           _s4vMm::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vMm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yeV_info" {
     block_c4yeV_info:
         const _c4yeV;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.353152029 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshiftL_closure" {
     GHC.Int.$fBitsInt64_$cshiftL_closure:
         const GHC.Int.$fBitsInt64_$cshiftL_info;
 },
 GHC.Int.$fBitsInt64_$cshiftL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yfB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yfF; else goto c4yfG;
       c4yfF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yfG: // global
           I64[Sp - 16] = block_c4yfy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yg0; else goto c4yfz;
       u4yg0: // global
           call _c4yfy(R1) args: 0, res: 0, upd: 0;
       c4yfz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cshiftL_info" {
     GHC.Int.$fBitsInt64_$cshiftL_info:
         const GHC.Int.$fBitsInt64_$cshiftL_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yfy() //  [R1]
         { []
         }
     {offset
       c4yfy: // global
           I64[Sp] = block_c4yfE_info;
           _s4vMq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vMq::I64;
           if (R1 & 7 != 0) goto u4yfZ; else goto c4yfI;
       u4yfZ: // global
           call _c4yfE(R1) args: 0, res: 0, upd: 0;
       c4yfI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yfy_info" {
     block_c4yfy_info:
         const _c4yfy;
         const 1;
         const 30;
 },
 _c4yfE() //  [R1]
         { []
         }
     {offset
       c4yfE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yfO; else goto c4yfN;
       c4yfO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yfN: // global
           _s4vMs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vMs::I64, 64)) goto c4yfX; else goto c4yfY;
       c4yfX: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] << _s4vMs::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yfY: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yfE_info" {
     block_c4yfE_info:
         const _c4yfE;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.361503293 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cisSigned_closure" {
     GHC.Int.$fBitsInt64_$cisSigned_closure:
         const GHC.Int.$fBitsInt64_$cisSigned_info;
 },
 GHC.Int.$fBitsInt64_$cisSigned_entry() //  []
         { []
         }
     {offset
       c4ygo: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cisSigned_info" {
     GHC.Int.$fBitsInt64_$cisSigned_info:
         const GHC.Int.$fBitsInt64_$cisSigned_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.366664755 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotate_closure" {
     GHC.Int.$fBitsInt64_$crotate_closure:
         const GHC.Int.$fBitsInt64_$crotate_info;
 },
 GHC.Int.$fBitsInt64_$crotate_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ygE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ygI; else goto c4ygJ;
       c4ygI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ygJ: // global
           I64[Sp - 16] = block_c4ygB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yhz; else goto c4ygC;
       u4yhz: // global
           call _c4ygB(R1) args: 0, res: 0, upd: 0;
       c4ygC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$crotate_info" {
     GHC.Int.$fBitsInt64_$crotate_info:
         const GHC.Int.$fBitsInt64_$crotate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4ygB() //  [R1]
         { []
         }
     {offset
       c4ygB: // global
           I64[Sp - 8] = block_c4ygH_info;
           _s4vMy::P64 = R1;
           _s4vMz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vMz::I64;
           P64[Sp + 8] = _s4vMy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yhy; else goto c4ygL;
       u4yhy: // global
           call _c4ygH(R1) args: 0, res: 0, upd: 0;
       c4ygL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ygB_info" {
     block_c4ygB_info:
         const _c4ygB;
         const 1;
         const 30;
 },
 _c4ygH() //  [R1]
         { []
         }
     {offset
       c4ygH: // global
           _s4vME::I64 = I64[R1 + 7] & 63;
           if (_s4vME::I64 != 0) goto u4yhw; else goto c4yhs;
       u4yhw: // global
           I64[Sp + 16] = _s4vME::I64;
           Sp = Sp + 8;
           call _c4yh0() args: 0, res: 0, upd: 0;
       c4yhs: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ygH_info" {
     block_c4ygH_info:
         const _c4ygH;
         const 66;
         const 30;
 },
 _c4yh0() //  []
         { []
         }
     {offset
       c4yh0: // global
           Hp = Hp + 16;
           _s4vME::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4yhp; else goto c4yho;
       c4yhp: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4ygZ_info;
           R1 = _s4vME::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4yho: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4vMF::I64 = I64[Sp];
           I64[Hp] = (_s4vMF::I64 << _s4vME::I64) | (_s4vMF::I64 >> 64 - _s4vME::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4ygZ() //  [R1]
         { []
         }
     {offset
       c4ygZ: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4yh0() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4ygZ_info" {
     block_c4ygZ_info:
         const _c4ygZ;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.378993415 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cshift_closure" {
     GHC.Int.$fBitsInt64_$cshift_closure:
         const GHC.Int.$fBitsInt64_$cshift_info;
 },
 GHC.Int.$fBitsInt64_$cshift_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yie: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yii; else goto c4yij;
       c4yii: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yij: // global
           I64[Sp - 16] = block_c4yib_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yj3; else goto c4yic;
       u4yj3: // global
           call _c4yib(R1) args: 0, res: 0, upd: 0;
       c4yic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cshift_info" {
     GHC.Int.$fBitsInt64_$cshift_info:
         const GHC.Int.$fBitsInt64_$cshift_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yib() //  [R1]
         { []
         }
     {offset
       c4yib: // global
           I64[Sp] = block_c4yih_info;
           _s4vMO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vMO::I64;
           if (R1 & 7 != 0) goto u4yj2; else goto c4yil;
       u4yj2: // global
           call _c4yih(R1) args: 0, res: 0, upd: 0;
       c4yil: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yib_info" {
     block_c4yib_info:
         const _c4yib;
         const 1;
         const 30;
 },
 _c4yih() //  [R1]
         { []
         }
     {offset
       c4yih: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yir; else goto c4yiq;
       c4yir: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yiq: // global
           _s4vMO::I64 = I64[Sp + 8];
           _s4vMQ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vMQ::I64, 0)) goto c4yiP; else goto c4yj1;
       c4yiP: // global
           _s4vMS::I64 = -_s4vMQ::I64;
           if (%MO_S_Lt_W64(_s4vMS::I64, 64)) goto c4yiG; else goto c4yiN;
       c4yiG: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s4vMO::I64, _s4vMS::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yiN: // global
           if (%MO_S_Ge_W64(_s4vMO::I64, 0)) goto c4yj0; else goto c4yiM;
       c4yiM: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yj1: // global
           if (%MO_S_Ge_W64(_s4vMQ::I64, 64)) goto c4yj0; else goto c4yiZ;
       c4yj0: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yiZ: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vMO::I64 << _s4vMQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yih_info" {
     block_c4yih_info:
         const _c4yih;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.387494303 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplement_closure" {
     GHC.Int.$fBitsInt64_$ccomplement_closure:
         const GHC.Int.$fBitsInt64_$ccomplement_info;
 },
 GHC.Int.$fBitsInt64_$ccomplement_entry() //  [R2]
         { []
         }
     {offset
       c4yjy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yjL; else goto c4yjM;
       c4yjL: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yjM: // global
           I64[Sp - 8] = block_c4yjv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yjQ; else goto c4yjw;
       u4yjQ: // global
           call _c4yjv(R1) args: 0, res: 0, upd: 0;
       c4yjw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$ccomplement_info" {
     GHC.Int.$fBitsInt64_$ccomplement_info:
         const GHC.Int.$fBitsInt64_$ccomplement_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4yjv() //  [R1]
         { []
         }
     {offset
       c4yjv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yjP; else goto c4yjO;
       c4yjP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yjO: // global
           _s4vN3::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vN3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yjv_info" {
     block_c4yjv_info:
         const _c4yjv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.394248933 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cxor_closure" {
     GHC.Int.$fBitsInt64_$cxor_closure:
         const GHC.Int.$fBitsInt64_$cxor_info;
 },
 GHC.Int.$fBitsInt64_$cxor_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ykb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ykw; else goto c4ykx;
       c4ykw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ykx: // global
           I64[Sp - 16] = block_c4yk8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ykD; else goto c4yk9;
       u4ykD: // global
           call _c4yk8(R1) args: 0, res: 0, upd: 0;
       c4yk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cxor_info" {
     GHC.Int.$fBitsInt64_$cxor_info:
         const GHC.Int.$fBitsInt64_$cxor_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yk8() //  [R1]
         { []
         }
     {offset
       c4yk8: // global
           I64[Sp] = block_c4yke_info;
           _s4vN7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vN7::I64;
           if (R1 & 7 != 0) goto u4ykC; else goto c4ykf;
       u4ykC: // global
           call _c4yke(R1) args: 0, res: 0, upd: 0;
       c4ykf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yk8_info" {
     block_c4yk8_info:
         const _c4yk8;
         const 1;
         const 30;
 },
 _c4yke() //  [R1]
         { []
         }
     {offset
       c4yke: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ykB; else goto c4ykA;
       c4ykB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ykA: // global
           _s4vNd::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vNd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yke_info" {
     block_c4yke_info:
         const _c4yke;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.403148251 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.|._closure" {
     GHC.Int.$fBitsInt64_$c.|._closure:
         const GHC.Int.$fBitsInt64_$c.|._info;
 },
 GHC.Int.$fBitsInt64_$c.|._entry() //  [R2, R3]
         { []
         }
     {offset
       c4yl4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ylp; else goto c4ylq;
       c4ylp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ylq: // global
           I64[Sp - 16] = block_c4yl1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ylw; else goto c4yl2;
       u4ylw: // global
           call _c4yl1(R1) args: 0, res: 0, upd: 0;
       c4yl2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$c.|._info" {
     GHC.Int.$fBitsInt64_$c.|._info:
         const GHC.Int.$fBitsInt64_$c.|._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yl1() //  [R1]
         { []
         }
     {offset
       c4yl1: // global
           I64[Sp] = block_c4yl7_info;
           _s4vNh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vNh::I64;
           if (R1 & 7 != 0) goto u4ylv; else goto c4yl8;
       u4ylv: // global
           call _c4yl7(R1) args: 0, res: 0, upd: 0;
       c4yl8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yl1_info" {
     block_c4yl1_info:
         const _c4yl1;
         const 1;
         const 30;
 },
 _c4yl7() //  [R1]
         { []
         }
     {offset
       c4yl7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ylu; else goto c4ylt;
       c4ylu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ylt: // global
           _s4vNn::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vNn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yl7_info" {
     block_c4yl7_info:
         const _c4yl7;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.411547203 UTC

[section ""data" . GHC.Int.$fBitsInt64_$c.&._closure" {
     GHC.Int.$fBitsInt64_$c.&._closure:
         const GHC.Int.$fBitsInt64_$c.&._info;
 },
 GHC.Int.$fBitsInt64_$c.&._entry() //  [R2, R3]
         { []
         }
     {offset
       c4ylX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ymi; else goto c4ymj;
       c4ymi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ymj: // global
           I64[Sp - 16] = block_c4ylU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ymp; else goto c4ylV;
       u4ymp: // global
           call _c4ylU(R1) args: 0, res: 0, upd: 0;
       c4ylV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$c.&._info" {
     GHC.Int.$fBitsInt64_$c.&._info:
         const GHC.Int.$fBitsInt64_$c.&._entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4ylU() //  [R1]
         { []
         }
     {offset
       c4ylU: // global
           I64[Sp] = block_c4ym0_info;
           _s4vNr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vNr::I64;
           if (R1 & 7 != 0) goto u4ymo; else goto c4ym1;
       u4ymo: // global
           call _c4ym0(R1) args: 0, res: 0, upd: 0;
       c4ym1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ylU_info" {
     block_c4ylU_info:
         const _c4ylU;
         const 1;
         const 30;
 },
 _c4ym0() //  [R1]
         { []
         }
     {offset
       c4ym0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ymn; else goto c4ymm;
       c4ymn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ymm: // global
           _s4vNx::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4vNx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ym0_info" {
     block_c4ym0_info:
         const _c4ym0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.420061365 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4ymQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yn4; else goto c4yn5;
       c4yn4: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yn5: // global
           I64[Sp - 8] = block_c4ymN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yn9; else goto c4ymO;
       u4yn9: // global
           call _c4ymN(R1) args: 0, res: 0, upd: 0;
       c4ymO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info" {
     GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_info:
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4ymN() //  [R1]
         { []
         }
     {offset
       c4ymN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yn8; else goto c4yn7;
       c4yn8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yn7: // global
           (_c4ymW::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4ymW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ymN_info" {
     block_c4ymN_info:
         const _c4ymN;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.426738864 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure" {
     GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure:
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info;
 },
 GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_entry() //  [R2]
         { []
         }
     {offset
       c4ynv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ynJ; else goto c4ynK;
       c4ynJ: // global
           R2 = R2;
           R1 = GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ynK: // global
           I64[Sp - 8] = block_c4yns_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ynO; else goto c4ynt;
       u4ynO: // global
           call _c4yns(R1) args: 0, res: 0, upd: 0;
       c4ynt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info" {
     GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_info:
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4yns() //  [R1]
         { []
         }
     {offset
       c4yns: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ynN; else goto c4ynM;
       c4ynN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ynM: // global
           (_c4ynB::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c4ynB::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yns_info" {
     block_c4yns_info:
         const _c4yns;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.432010173 UTC

[section ""data" . GHC.Int.$fBitsInt7_closure" {
     GHC.Int.$fBitsInt7_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.434477039 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cfiniteBitSize_closure" {
     GHC.Int.$fBitsInt64_$cfiniteBitSize_closure:
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_info;
 },
 GHC.Int.$fBitsInt64_$cfiniteBitSize_entry() //  []
         { []
         }
     {offset
       c4yo8: // global
           R1 = GHC.Int.$fBitsInt7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cfiniteBitSize_info" {
     GHC.Int.$fBitsInt64_$cfiniteBitSize_info:
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.439636274 UTC

[section ""data" . GHC.Int.eqInt8_closure" {
     GHC.Int.eqInt8_closure:
         const GHC.Int.eqInt8_info;
 },
 GHC.Int.eqInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yon: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yor; else goto c4yos;
       c4yor: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yos: // global
           I64[Sp - 16] = block_c4yok_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yoB; else goto c4yol;
       u4yoB: // global
           call _c4yok(R1) args: 0, res: 0, upd: 0;
       c4yol: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.eqInt8_info" {
     GHC.Int.eqInt8_info:
         const GHC.Int.eqInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yok() //  [R1]
         { []
         }
     {offset
       c4yok: // global
           I64[Sp] = block_c4yoq_info;
           _s4vNO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vNO::I64;
           if (R1 & 7 != 0) goto u4yoA; else goto c4you;
       u4yoA: // global
           call _c4yoq(R1) args: 0, res: 0, upd: 0;
       c4you: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yok_info" {
     block_c4yok_info:
         const _c4yok;
         const 1;
         const 30;
 },
 _c4yoq() //  [R1]
         { []
         }
     {offset
       c4yoq: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yoq_info" {
     block_c4yoq_info:
         const _c4yoq;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.446609217 UTC

[section ""data" . GHC.Int.$fEqInt8_closure" {
     GHC.Int.$fEqInt8_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt8_closure+2;
         const GHC.Int.neInt8_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.449549107 UTC

[section ""data" . GHC.Int.gtInt8_closure" {
     GHC.Int.gtInt8_closure:
         const GHC.Int.gtInt8_info;
 },
 GHC.Int.gtInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yp4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yp8; else goto c4yp9;
       c4yp8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yp9: // global
           I64[Sp - 16] = block_c4yp1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ypi; else goto c4yp2;
       u4ypi: // global
           call _c4yp1(R1) args: 0, res: 0, upd: 0;
       c4yp2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.gtInt8_info" {
     GHC.Int.gtInt8_info:
         const GHC.Int.gtInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yp1() //  [R1]
         { []
         }
     {offset
       c4yp1: // global
           I64[Sp] = block_c4yp7_info;
           _s4vNV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vNV::I64;
           if (R1 & 7 != 0) goto u4yph; else goto c4ypb;
       u4yph: // global
           call _c4yp7(R1) args: 0, res: 0, upd: 0;
       c4ypb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yp1_info" {
     block_c4yp1_info:
         const _c4yp1;
         const 1;
         const 30;
 },
 _c4yp7() //  [R1]
         { []
         }
     {offset
       c4yp7: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yp7_info" {
     block_c4yp7_info:
         const _c4yp7;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.460546513 UTC

[section ""data" . GHC.Int.geInt8_closure" {
     GHC.Int.geInt8_closure:
         const GHC.Int.geInt8_info;
 },
 GHC.Int.geInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ypK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ypO; else goto c4ypP;
       c4ypO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ypP: // global
           I64[Sp - 16] = block_c4ypH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ypY; else goto c4ypI;
       u4ypY: // global
           call _c4ypH(R1) args: 0, res: 0, upd: 0;
       c4ypI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.geInt8_info" {
     GHC.Int.geInt8_info:
         const GHC.Int.geInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4ypH() //  [R1]
         { []
         }
     {offset
       c4ypH: // global
           I64[Sp] = block_c4ypN_info;
           _s4vO2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vO2::I64;
           if (R1 & 7 != 0) goto u4ypX; else goto c4ypR;
       u4ypX: // global
           call _c4ypN(R1) args: 0, res: 0, upd: 0;
       c4ypR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ypH_info" {
     block_c4ypH_info:
         const _c4ypH;
         const 1;
         const 30;
 },
 _c4ypN() //  [R1]
         { []
         }
     {offset
       c4ypN: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ypN_info" {
     block_c4ypN_info:
         const _c4ypN;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.470971896 UTC

[section ""data" . GHC.Int.ltInt8_closure" {
     GHC.Int.ltInt8_closure:
         const GHC.Int.ltInt8_info;
 },
 GHC.Int.ltInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yqq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yqu; else goto c4yqv;
       c4yqu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yqv: // global
           I64[Sp - 16] = block_c4yqn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yqE; else goto c4yqo;
       u4yqE: // global
           call _c4yqn(R1) args: 0, res: 0, upd: 0;
       c4yqo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.ltInt8_info" {
     GHC.Int.ltInt8_info:
         const GHC.Int.ltInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yqn() //  [R1]
         { []
         }
     {offset
       c4yqn: // global
           I64[Sp] = block_c4yqt_info;
           _s4vO9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vO9::I64;
           if (R1 & 7 != 0) goto u4yqD; else goto c4yqx;
       u4yqD: // global
           call _c4yqt(R1) args: 0, res: 0, upd: 0;
       c4yqx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yqn_info" {
     block_c4yqn_info:
         const _c4yqn;
         const 1;
         const 30;
 },
 _c4yqt() //  [R1]
         { []
         }
     {offset
       c4yqt: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yqt_info" {
     block_c4yqt_info:
         const _c4yqt;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.478851558 UTC

[section ""data" . GHC.Int.leInt8_closure" {
     GHC.Int.leInt8_closure:
         const GHC.Int.leInt8_info;
 },
 GHC.Int.leInt8_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yr6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yra; else goto c4yrb;
       c4yra: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yrb: // global
           I64[Sp - 16] = block_c4yr3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yrk; else goto c4yr4;
       u4yrk: // global
           call _c4yr3(R1) args: 0, res: 0, upd: 0;
       c4yr4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.leInt8_info" {
     GHC.Int.leInt8_info:
         const GHC.Int.leInt8_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yr3() //  [R1]
         { []
         }
     {offset
       c4yr3: // global
           I64[Sp] = block_c4yr9_info;
           _s4vOg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vOg::I64;
           if (R1 & 7 != 0) goto u4yrj; else goto c4yrd;
       u4yrj: // global
           call _c4yr9(R1) args: 0, res: 0, upd: 0;
       c4yrd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yr3_info" {
     block_c4yr3_info:
         const _c4yr3;
         const 1;
         const 30;
 },
 _c4yr9() //  [R1]
         { []
         }
     {offset
       c4yr9: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yr9_info" {
     block_c4yr9_info:
         const _c4yr9;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.488343387 UTC

[section ""data" . GHC.Int.$fOrdInt8_$ccompare_closure" {
     GHC.Int.$fOrdInt8_$ccompare_closure:
         const GHC.Int.$fOrdInt8_$ccompare_info;
 },
 GHC.Int.$fOrdInt8_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yrM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yrQ; else goto c4yrR;
       c4yrQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yrR: // global
           I64[Sp - 16] = block_c4yrJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ysa; else goto c4yrK;
       u4ysa: // global
           call _c4yrJ(R1) args: 0, res: 0, upd: 0;
       c4yrK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt8_$ccompare_info" {
     GHC.Int.$fOrdInt8_$ccompare_info:
         const GHC.Int.$fOrdInt8_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yrJ() //  [R1]
         { []
         }
     {offset
       c4yrJ: // global
           I64[Sp] = block_c4yrP_info;
           _s4vOn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vOn::I64;
           if (R1 & 7 != 0) goto u4ys9; else goto c4yrT;
       u4ys9: // global
           call _c4yrP(R1) args: 0, res: 0, upd: 0;
       c4yrT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yrJ_info" {
     block_c4yrJ_info:
         const _c4yrJ;
         const 1;
         const 30;
 },
 _c4yrP() //  [R1]
         { []
         }
     {offset
       c4yrP: // global
           _s4vOn::I64 = I64[Sp + 8];
           _s4vOp::I64 = I64[R1 + 7];
           if (_s4vOn::I64 == _s4vOp::I64) goto c4ys8; else goto c4ys7;
       c4ys8: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ys7: // global
           if (%MO_S_Gt_W64(_s4vOn::I64,
                            _s4vOp::I64)) goto c4ys4; else goto c4ys5;
       c4ys4: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ys5: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yrP_info" {
     block_c4yrP_info:
         const _c4yrP;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.496735137 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmax_closure" {
     GHC.Int.$fOrdInt8_$cmax_closure:
         const GHC.Int.$fOrdInt8_$cmax_info;
 },
 GHC.Int.$fOrdInt8_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ysD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ysH; else goto c4ysI;
       c4ysH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ysI: // global
           I64[Sp - 16] = block_c4ysA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ysV; else goto c4ysB;
       u4ysV: // global
           call _c4ysA(R1) args: 0, res: 0, upd: 0;
       c4ysB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt8_$cmax_info" {
     GHC.Int.$fOrdInt8_$cmax_info:
         const GHC.Int.$fOrdInt8_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4ysA() //  [R1]
         { []
         }
     {offset
       c4ysA: // global
           I64[Sp - 8] = block_c4ysG_info;
           _s4vOu::P64 = R1;
           _s4vOv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vOv::I64;
           P64[Sp + 8] = _s4vOu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ysU; else goto c4ysK;
       u4ysU: // global
           call _c4ysG(R1) args: 0, res: 0, upd: 0;
       c4ysK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ysA_info" {
     block_c4ysA_info:
         const _c4ysA;
         const 1;
         const 30;
 },
 _c4ysG() //  [R1]
         { []
         }
     {offset
       c4ysG: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4ysS; else goto c4ysT;
       c4ysS: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ysT: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ysG_info" {
     block_c4ysG_info:
         const _c4ysG;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.50602486 UTC

[section ""data" . GHC.Int.$fOrdInt8_$cmin_closure" {
     GHC.Int.$fOrdInt8_$cmin_closure:
         const GHC.Int.$fOrdInt8_$cmin_info;
 },
 GHC.Int.$fOrdInt8_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ytn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ytr; else goto c4yts;
       c4ytr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt8_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yts: // global
           I64[Sp - 16] = block_c4ytk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ytF; else goto c4ytl;
       u4ytF: // global
           call _c4ytk(R1) args: 0, res: 0, upd: 0;
       c4ytl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt8_$cmin_info" {
     GHC.Int.$fOrdInt8_$cmin_info:
         const GHC.Int.$fOrdInt8_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4ytk() //  [R1]
         { []
         }
     {offset
       c4ytk: // global
           I64[Sp - 8] = block_c4ytq_info;
           _s4vOB::P64 = R1;
           _s4vOC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vOC::I64;
           P64[Sp + 8] = _s4vOB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ytE; else goto c4ytu;
       u4ytE: // global
           call _c4ytq(R1) args: 0, res: 0, upd: 0;
       c4ytu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ytk_info" {
     block_c4ytk_info:
         const _c4ytk;
         const 1;
         const 30;
 },
 _c4ytq() //  [R1]
         { []
         }
     {offset
       c4ytq: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4ytC; else goto c4ytD;
       c4ytC: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4ytD: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ytq_info" {
     block_c4ytq_info:
         const _c4ytq;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.512679459 UTC

[section ""data" . GHC.Int.$fOrdInt8_closure" {
     GHC.Int.$fOrdInt8_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fOrdInt8_$ccompare_closure+2;
         const GHC.Int.ltInt8_closure+2;
         const GHC.Int.leInt8_closure+2;
         const GHC.Int.gtInt8_closure+2;
         const GHC.Int.geInt8_closure+2;
         const GHC.Int.$fOrdInt8_$cmax_closure+2;
         const GHC.Int.$fOrdInt8_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.51659826 UTC

[section ""data" . GHC.Int.$fIxInt8_$cinRange_closure" {
     GHC.Int.$fIxInt8_$cinRange_closure:
         const GHC.Int.$fIxInt8_$cinRange_info;
 },
 GHC.Int.$fIxInt8_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yu8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yuh; else goto c4yui;
       c4yuh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yui: // global
           I64[Sp - 16] = block_c4yu5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yuF; else goto c4yu6;
       u4yuF: // global
           call _c4yu5(R1) args: 0, res: 0, upd: 0;
       c4yu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$cinRange_info" {
     GHC.Int.$fIxInt8_$cinRange_info:
         const GHC.Int.$fIxInt8_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yu5() //  [R1]
         { []
         }
     {offset
       c4yu5: // global
           I64[Sp - 8] = block_c4yub_info;
           _s4vOK::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4vOK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yuE; else goto c4yuc;
       u4yuE: // global
           call _c4yub(R1) args: 0, res: 0, upd: 0;
       c4yuc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yu5_info" {
     block_c4yu5_info:
         const _c4yu5;
         const 1;
         const 30;
 },
 _c4yub() //  [R1]
         { []
         }
     {offset
       c4yub: // global
           I64[Sp] = block_c4yug_info;
           _s4vOM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vOM::I64;
           if (R1 & 7 != 0) goto u4yuG; else goto c4yul;
       u4yuG: // global
           call _c4yug(R1) args: 0, res: 0, upd: 0;
       c4yul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yub_info" {
     block_c4yub_info:
         const _c4yub;
         const 2;
         const 30;
 },
 _c4yug() //  [R1]
         { []
         }
     {offset
       c4yug: // global
           _s4vOO::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4vOO::I64)) goto c4yut; else goto c4yux;
       c4yut: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yux: // global
           _s4vOK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4yuw_info;
           R1 = _s4vOK::P64;
           I64[Sp + 16] = _s4vOO::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4yuH; else goto c4yuy;
       u4yuH: // global
           call _c4yuw(R1) args: 0, res: 0, upd: 0;
       c4yuy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yug_info" {
     block_c4yug_info:
         const _c4yug;
         const 130;
         const 30;
 },
 _c4yuw() //  [R1]
         { []
         }
     {offset
       c4yuw: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yuw_info" {
     block_c4yuw_info:
         const _c4yuw;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.527753266 UTC

[section ""data" . GHC.Int.$fNumInt7_closure" {
     GHC.Int.$fNumInt7_closure:
         const GHC.Int.I8#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.530594536 UTC

[section ""data" . GHC.Int.$fNumInt8_$csignum_closure" {
     GHC.Int.$fNumInt8_$csignum_closure:
         const GHC.Int.$fNumInt8_$csignum_info;
 },
 GHC.Int.$fNumInt8_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c4yvm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yvn; else goto c4yvo;
       c4yvn: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yvo: // global
           I64[Sp - 8] = block_c4yvj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yvC; else goto c4yvk;
       u4yvC: // global
           call _c4yvj(R1) args: 0, res: 0, upd: 0;
       c4yvk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$csignum_info" {
     GHC.Int.$fNumInt8_$csignum_info:
         const GHC.Int.$fNumInt8_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4yvj() //  [R1]
         { []
         }
     {offset
       c4yvj: // global
           _s4vOV::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4vOV::I64, 0)) goto c4yvA; else goto c4yvB;
       c4yvA: // global
           if (_s4vOV::I64 == 0) goto c4yvy; else goto c4yvx;
       c4yvy: // global
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yvx: // global
           R1 = GHC.Int.$fNumInt9_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yvB: // global
           R1 = GHC.Int.$fNumInt7_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yvj_info" {
     block_c4yvj_info:
         const _c4yvj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.537233111 UTC

[section ""data" . GHC.Int.$fNumInt8_$cabs_closure" {
     GHC.Int.$fNumInt8_$cabs_closure:
         const GHC.Int.$fNumInt8_$cabs_info;
 },
 GHC.Int.$fNumInt8_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c4yvX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yvY; else goto c4yvZ;
       c4yvY: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt8_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yvZ: // global
           I64[Sp - 8] = block_c4yvU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ywi; else goto c4yvV;
       u4ywi: // global
           call _c4yvU(R1) args: 0, res: 0, upd: 0;
       c4yvV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt8_$cabs_info" {
     GHC.Int.$fNumInt8_$cabs_info:
         const GHC.Int.$fNumInt8_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4yvU() //  [R1]
         { []
         }
     {offset
       c4yvU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yw4; else goto c4yw3;
       c4yw4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yw3: // global
           _s4vP0::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vP0::I64, 0)) goto c4ywg; else goto c4ywh;
       c4ywg: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(-_s4vP0::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ywh: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yvU_info" {
     block_c4yvU_info:
         const _c4yvU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.543542541 UTC

[section ""data" . GHC.Int.$fNumInt8_closure" {
     GHC.Int.$fNumInt8_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt8_$c+_closure+2;
         const GHC.Int.$fNumInt8_$c-_closure+2;
         const GHC.Int.$fNumInt8_$c*_closure+2;
         const GHC.Int.$fNumInt8_$cnegate_closure+1;
         const GHC.Int.$fNumInt8_$cabs_closure+1;
         const GHC.Int.$fNumInt8_$csignum_closure+1;
         const GHC.Int.$fNumInt8_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.546056049 UTC

[section ""data" . GHC.Int.$fBitsInt12_closure" {
     GHC.Int.$fBitsInt12_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt11_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.548316364 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt8_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c4ywF: // global
           R1 = GHC.Int.$fBitsInt12_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cbitSizeMaybe_info" {
     GHC.Int.$fBitsInt8_$cbitSizeMaybe_info:
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.554506893 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cbit_closure" {
     GHC.Int.$fBitsInt8_$cbit_closure:
         const GHC.Int.$fBitsInt8_$cbit_info;
 },
 GHC.Int.$fBitsInt8_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c4ywU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ywV; else goto c4ywW;
       c4ywV: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ywW: // global
           I64[Sp - 8] = block_c4ywR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yxf; else goto c4ywS;
       u4yxf: // global
           call _c4ywR(R1) args: 0, res: 0, upd: 0;
       c4ywS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cbit_info" {
     GHC.Int.$fBitsInt8_$cbit_info:
         const GHC.Int.$fBitsInt8_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4ywR() //  [R1]
         { []
         }
     {offset
       c4ywR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yx1; else goto c4yx0;
       c4yx1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yx0: // global
           _s4vP7::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vP7::I64, 64)) goto c4yxd; else goto c4yxe;
       c4yxd: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4vP7::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yxe: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt13_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ywR_info" {
     block_c4ywR_info:
         const _c4ywR;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.566140991 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ctestBit_closure" {
     GHC.Int.$fBitsInt8_$ctestBit_closure:
         const GHC.Int.$fBitsInt8_$ctestBit_info;
 },
 GHC.Int.$fBitsInt8_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yxD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yxH; else goto c4yxI;
       c4yxH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yxI: // global
           I64[Sp - 16] = block_c4yxA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yyq; else goto c4yxB;
       u4yyq: // global
           call _c4yxA(R1) args: 0, res: 0, upd: 0;
       c4yxB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$ctestBit_info" {
     GHC.Int.$fBitsInt8_$ctestBit_info:
         const GHC.Int.$fBitsInt8_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yxA() //  [R1]
         { []
         }
     {offset
       c4yxA: // global
           I64[Sp] = block_c4yxG_info;
           _s4vPe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vPe::I64;
           if (R1 & 7 != 0) goto u4yyp; else goto c4yxK;
       u4yyp: // global
           call _c4yxG(R1) args: 0, res: 0, upd: 0;
       c4yxK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yxA_info" {
     block_c4yxA_info:
         const _c4yxA;
         const 1;
         const 30;
 },
 _c4yxG() //  [R1]
         { []
         }
     {offset
       c4yxG: // global
           _s4vPg::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4vPg::I64, 64)) goto c4yyo; else goto c4yyn;
       c4yyn: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4vPg::I64)) == 0) goto c4yyo; else goto c4yyc;
       c4yyo: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yyc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yxG_info" {
     block_c4yxG_info:
         const _c4yxG;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.579326957 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateR_closure" {
     GHC.Int.$fBitsInt8_$crotateR_closure:
         const GHC.Int.$fBitsInt8_$crotateR_info;
 },
 GHC.Int.$fBitsInt8_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yyW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yz0; else goto c4yz1;
       c4yz0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yz1: // global
           I64[Sp - 16] = block_c4yyT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yA0; else goto c4yyU;
       u4yA0: // global
           call _c4yyT(R1) args: 0, res: 0, upd: 0;
       c4yyU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$crotateR_info" {
     GHC.Int.$fBitsInt8_$crotateR_info:
         const GHC.Int.$fBitsInt8_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yyT() //  [R1]
         { []
         }
     {offset
       c4yyT: // global
           I64[Sp - 8] = block_c4yyZ_info;
           _s4vPq::P64 = R1;
           _s4vPr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vPr::I64;
           P64[Sp + 8] = _s4vPq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yzZ; else goto c4yz3;
       u4yzZ: // global
           call _c4yyZ(R1) args: 0, res: 0, upd: 0;
       c4yz3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yyT_info" {
     block_c4yyT_info:
         const _c4yyT;
         const 1;
         const 30;
 },
 _c4yyZ() //  [R1]
         { []
         }
     {offset
       c4yyZ: // global
           _s4vPx::I64 = -I64[R1 + 7] & 7;
           if (_s4vPx::I64 != 0) goto u4yzX; else goto c4yzT;
       u4yzX: // global
           I64[Sp + 16] = _s4vPx::I64;
           Sp = Sp + 8;
           call _c4yzl() args: 0, res: 0, upd: 0;
       c4yzT: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yyZ_info" {
     block_c4yyZ_info:
         const _c4yyZ;
         const 66;
         const 30;
 },
 _c4yzl() //  []
         { []
         }
     {offset
       c4yzl: // global
           Hp = Hp + 16;
           _s4vPx::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4yzQ; else goto c4yzP;
       c4yzQ: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4yzk_info;
           R1 = _s4vPx::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4yzP: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           _s4vPy::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8((_s4vPy::I64 << _s4vPx::I64) | (_s4vPy::I64 >> 8 - _s4vPx::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4yzk() //  [R1]
         { []
         }
     {offset
       c4yzk: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4yzl() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4yzk_info" {
     block_c4yzk_info:
         const _c4yzk;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.593227541 UTC

[section ""data" . GHC.Int.$fBitsInt8_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt8_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt8_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt8_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yAH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yAL; else goto c4yAM;
       c4yAL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yAM: // global
           I64[Sp - 16] = block_c4yAE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yBl; else goto c4yAF;
       u4yBl: // global
           call _c4yAE(R1) args: 0, res: 0, upd: 0;
       c4yAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$ccomplementBit_info" {
     GHC.Int.$fBitsInt8_$ccomplementBit_info:
         const GHC.Int.$fBitsInt8_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yAE() //  [R1]
         { []
         }
     {offset
       c4yAE: // global
           I64[Sp - 8] = block_c4yAK_info;
           _s4vPI::P64 = R1;
           _s4vPJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vPJ::I64;
           P64[Sp + 8] = _s4vPI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yBk; else goto c4yAO;
       u4yBk: // global
           call _c4yAK(R1) args: 0, res: 0, upd: 0;
       c4yAO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yAE_info" {
     block_c4yAE_info:
         const _c4yAE;
         const 1;
         const 30;
 },
 _c4yAK() //  [R1]
         { []
         }
     {offset
       c4yAK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yAU; else goto c4yAT;
       c4yAU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yAT: // global
           _s4vPL::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vPL::I64, 64)) goto c4yBi; else goto c4yBj;
       c4yBi: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4vPL::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yBj: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yAK_info" {
     block_c4yAK_info:
         const _c4yAK;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.604229415 UTC

[section ""data" . GHC.Int.$fBitsInt8_$cclearBit_closure" {
     GHC.Int.$fBitsInt8_$cclearBit_closure:
         const GHC.Int.$fBitsInt8_$cclearBit_info;
 },
 GHC.Int.$fBitsInt8_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yBR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yBV; else goto c4yBW;
       c4yBV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yBW: // global
           I64[Sp - 16] = block_c4yBO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yCJ; else goto c4yBP;
       u4yCJ: // global
           call _c4yBO(R1) args: 0, res: 0, upd: 0;
       c4yBP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$cclearBit_info" {
     GHC.Int.$fBitsInt8_$cclearBit_info:
         const GHC.Int.$fBitsInt8_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yBO() //  [R1]
         { []
         }
     {offset
       c4yBO: // global
           I64[Sp] = block_c4yBU_info;
           _s4vPW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vPW::I64;
           if (R1 & 7 != 0) goto u4yCI; else goto c4yBY;
       u4yCI: // global
           call _c4yBU(R1) args: 0, res: 0, upd: 0;
       c4yBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yBO_info" {
     block_c4yBO_info:
         const _c4yBO;
         const 1;
         const 30;
 },
 _c4yBU() //  [R1]
         { []
         }
     {offset
       c4yBU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yC4; else goto c4yC3;
       c4yC4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yC3: // global
           _s4vPW::I64 = I64[Sp + 8];
           _s4vPY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vPY::I64, 64)) goto c4yCv; else goto c4yCH;
       c4yCv: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vPW::I64 & ~%MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4vPY::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yCH: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vPW::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yBU_info" {
     block_c4yBU_info:
         const _c4yBU;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.61292044 UTC

[section ""data" . GHC.Int.$fBitsInt8_$csetBit_closure" {
     GHC.Int.$fBitsInt8_$csetBit_closure:
         const GHC.Int.$fBitsInt8_$csetBit_info;
 },
 GHC.Int.$fBitsInt8_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yDh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yDl; else goto c4yDm;
       c4yDl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt8_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yDm: // global
           I64[Sp - 16] = block_c4yDe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yDV; else goto c4yDf;
       u4yDV: // global
           call _c4yDe(R1) args: 0, res: 0, upd: 0;
       c4yDf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$csetBit_info" {
     GHC.Int.$fBitsInt8_$csetBit_info:
         const GHC.Int.$fBitsInt8_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yDe() //  [R1]
         { []
         }
     {offset
       c4yDe: // global
           I64[Sp - 8] = block_c4yDk_info;
           _s4vQc::P64 = R1;
           _s4vQd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vQd::I64;
           P64[Sp + 8] = _s4vQc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yDU; else goto c4yDo;
       u4yDU: // global
           call _c4yDk(R1) args: 0, res: 0, upd: 0;
       c4yDo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yDe_info" {
     block_c4yDe_info:
         const _c4yDe;
         const 1;
         const 30;
 },
 _c4yDk() //  [R1]
         { []
         }
     {offset
       c4yDk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yDu; else goto c4yDt;
       c4yDu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yDt: // global
           _s4vQf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vQf::I64, 64)) goto c4yDS; else goto c4yDT;
       c4yDS: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(1 << _s4vQf::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yDT: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yDk_info" {
     block_c4yDk_info:
         const _c4yDk;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.621177974 UTC

[section ""data" . GHC.Int.$fBitsInt8_$crotateL_closure" {
     GHC.Int.$fBitsInt8_$crotateL_closure:
         const GHC.Int.$fBitsInt8_$crotateL_info;
 },
 GHC.Int.$fBitsInt8_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yEo: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt8_$crotate_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt8_$crotateL_info" {
     GHC.Int.$fBitsInt8_$crotateL_info:
         const GHC.Int.$fBitsInt8_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.624495348 UTC

[section ""data" . GHC.Int.$fBitsInt8_closure" {
     GHC.Int.$fBitsInt8_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt8_closure+1;
         const GHC.Int.$fBitsInt8_$c.&._closure+2;
         const GHC.Int.$fBitsInt8_$c.|._closure+2;
         const GHC.Int.$fBitsInt8_$cxor_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt8_$cshift_closure+2;
         const GHC.Int.$fBitsInt8_$crotate_closure+2;
         const GHC.Int.$fBitsInt13_closure+1;
         const GHC.Int.$fBitsInt8_$cbit_closure+1;
         const GHC.Int.$fBitsInt8_$csetBit_closure+2;
         const GHC.Int.$fBitsInt8_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt8_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt8_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt8_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt8_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt8_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt8_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt8_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt8_$crotateL_closure+2;
         const GHC.Int.$fBitsInt8_$crotateR_closure+2;
         const GHC.Int.$fBitsInt8_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.626694694 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt8_closure" {
     GHC.Int.$fFiniteBitsInt8_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt8_closure+1;
         const GHC.Int.$fBitsInt8_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.632159428 UTC

[section ""data" . GHC.Int.$fReadInt8_go_closure" {
     GHC.Int.$fReadInt8_go_closure:
         const GHC.Int.$fReadInt8_go_info;
 },
 sat_s4vQz_entry() //  [R1]
         { []
         }
     {offset
       c4yEQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yER; else goto c4yES;
       c4yER: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4yES: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vQz_info" {
     sat_s4vQz_info:
         const sat_s4vQz_entry;
         const 1;
         const 16;
 },
 sat_s4vQx_entry() //  [R1]
         { []
         }
     {offset
       c4yF0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yF7; else goto c4yF8;
       c4yF7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4yF8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4yEX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4yFc; else goto c4yEY;
       u4yFc: // global
           call _c4yEX(R1) args: 0, res: 0, upd: 0;
       c4yEY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vQx_info" {
     sat_s4vQx_info:
         const sat_s4vQx_entry;
         const 1;
         const 16;
 },
 _c4yEX() //  [R1]
         { []
         }
     {offset
       c4yEX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yFb; else goto c4yFa;
       c4yFb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4yFa: // global
           _s4vQw::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4vQw::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4yEX_info" {
     block_c4yEX_info:
         const _c4yEX;
         const 0;
         const 30;
 },
 GHC.Int.$fReadInt8_go_entry() //  [R2]
         { []
         }
     {offset
       c4yFh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yFi; else goto c4yFj;
       c4yFi: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yFj: // global
           I64[Sp - 8] = block_c4yEB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yFt; else goto c4yEC;
       u4yFt: // global
           call _c4yEB(R1) args: 0, res: 0, upd: 0;
       c4yEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt8_go_info" {
     GHC.Int.$fReadInt8_go_info:
         const GHC.Int.$fReadInt8_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4yEB() //  [R1]
         { []
         }
     {offset
       c4yEB: // global
           if (R1 & 7 == 1) goto c4yFe; else goto c4yFf;
       c4yFe: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yFf: // global
           I64[Sp - 8] = block_c4yEH_info;
           _s4vQq::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4vQq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yFs; else goto c4yEI;
       u4yFs: // global
           call _c4yEH(R1) args: 0, res: 0, upd: 0;
       c4yEI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yEB_info" {
     block_c4yEB_info:
         const _c4yEB;
         const 0;
         const 30;
 },
 _c4yEH() //  [R1]
         { []
         }
     {offset
       c4yEH: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4yFr; else goto c4yFq;
       c4yFr: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yFq: // global
           _s4vQs::P64 = P64[R1 + 7];
           _s4vQt::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4vQz_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4vQx_info;
           P64[Hp - 48] = _s4vQs::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4vQt::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yEH_info" {
     block_c4yEH_info:
         const _c4yEH;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.650393127 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadsPrec_closure" {
     GHC.Int.$fReadInt8_$creadsPrec_closure:
         const GHC.Int.$fReadInt8_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yGk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yGo; else goto c4yGp;
       c4yGo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt8_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yGp: // global
           I64[Sp - 16] = block_c4yGi_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4vQB::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4vQB::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt8_$creadsPrec_info" {
     GHC.Int.$fReadInt8_$creadsPrec_info:
         const GHC.Int.$fReadInt8_$creadsPrec_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const S4wm5_srt+472;
 },
 _c4yGi() //  [R1]
         { []
         }
     {offset
       c4yGi: // global
           _s4vQB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4yGn_info;
           R3 = _s4vQB::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yGi_info" {
     block_c4yGi_info:
         const _c4yGi;
         const 1;
         const 30;
 },
 _c4yGn() //  [R1]
         { []
         }
     {offset
       c4yGn: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt8_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yGn_info" {
     block_c4yGn_info:
         const _c4yGn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.658240087 UTC

[section ""data" . GHC.Int.$fReadInt13_closure" {
     GHC.Int.$fReadInt13_closure:
         const GHC.Int.$fReadInt13_info;
         const 0;
 },
 sat_s4vQG_entry() //  [R1, R2]
         { []
         }
     {offset
       c4yGT: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt8_$creadsPrec_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s4vQG_info" {
     sat_s4vQG_info:
         const sat_s4vQG_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S4wm5_srt+488;
 },
 GHC.Int.$fReadInt13_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yGZ: // global
           _s4vQF::P64 = R3;
           _s4vQE::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4yH0; else goto c4yH1;
       c4yH1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yH3; else goto c4yH2;
       c4yH3: // global
           HpAlloc = 16;
           goto c4yH0;
       c4yH0: // global
           R3 = _s4vQF::P64;
           R2 = _s4vQE::P64;
           R1 = GHC.Int.$fReadInt13_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yH2: // global
           I64[Hp - 8] = sat_s4vQG_info;
           P64[Hp] = _s4vQE::P64;
           I64[Sp - 8] = block_c4yGW_info;
           R3 = _s4vQF::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt13_info" {
     GHC.Int.$fReadInt13_info:
         const GHC.Int.$fReadInt13_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+488;
 },
 _c4yGW() //  [R1]
         { []
         }
     {offset
       c4yGW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yH6; else goto c4yH5;
       c4yH6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yH5: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yGW_info" {
     block_c4yGW_info:
         const _c4yGW;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.665615186 UTC

[section ""data" . GHC.Int.$fIxInt1_closure" {
     GHC.Int.$fIxInt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.667964496 UTC

[section ""data" . GHC.Int.$fReadInt12_closure" {
     GHC.Int.$fReadInt12_closure:
         const GHC.Int.$fReadInt12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt12_entry() //  [R1]
         { []
         }
     {offset
       c4yHt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4yHu; else goto c4yHv;
       c4yHu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4yHv: // global
           (_c4yHq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4yHq::I64 == 0) goto c4yHs; else goto c4yHr;
       c4yHs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4yHr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4yHq::I64;
           R2 = GHC.Int.$fReadInt13_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt12_info" {
     GHC.Int.$fReadInt12_info:
         const GHC.Int.$fReadInt12_entry;
         const 0;
         const 12884901909;
         const S4wm5_srt+496;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.671955834 UTC

[section ""data" . GHC.Int.$fReadInt8_$creadList_closure" {
     GHC.Int.$fReadInt8_$creadList_closure:
         const GHC.Int.$fReadInt8_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt8_$creadList_entry() //  [R2]
         { []
         }
     {offset
       c4yHM: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt8_$creadList_info" {
     GHC.Int.$fReadInt8_$creadList_info:
         const GHC.Int.$fReadInt8_$creadList_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S4wm5_srt+512;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.676126152 UTC

[section ""data" . GHC.Int.$fReadInt11_closure" {
     GHC.Int.$fReadInt11_closure:
         const GHC.Int.$fReadInt11_info;
         const 0;
 },
 GHC.Int.$fReadInt11_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yI0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yI1; else goto c4yI2;
       c4yI1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yI2: // global
           I64[Sp - 8] = block_c4yHX_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt8_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt11_info" {
     GHC.Int.$fReadInt11_info:
         const GHC.Int.$fReadInt11_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+520;
 },
 _c4yHX() //  [R1]
         { []
         }
     {offset
       c4yHX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yI5; else goto c4yI4;
       c4yI5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yI4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yHX_info" {
     block_c4yHX_info:
         const _c4yHX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.681093033 UTC

[section ""data" . GHC.Int.$fReadInt8_closure" {
     GHC.Int.$fReadInt8_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt8_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt8_$creadList_closure+1;
         const GHC.Int.$fReadInt13_closure+2;
         const GHC.Int.$fReadInt11_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.685865458 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquot_closure" {
     GHC.Int.$fIntegralInt8_$cquot_closure:
         const GHC.Int.$fIntegralInt8_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yIp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yIt; else goto c4yIu;
       c4yIt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yIu: // global
           I64[Sp - 16] = block_c4yIm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yJ5; else goto c4yIn;
       u4yJ5: // global
           call _c4yIm(R1) args: 0, res: 0, upd: 0;
       c4yIn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$cquot_info" {
     GHC.Int.$fIntegralInt8_$cquot_info:
         const GHC.Int.$fIntegralInt8_$cquot_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const S4wm5_srt+536;
 },
 _c4yIm() //  [R1]
         { []
         }
     {offset
       c4yIm: // global
           I64[Sp] = block_c4yIs_info;
           _s4vQQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vQQ::I64;
           if (R1 & 7 != 0) goto u4yJ4; else goto c4yIw;
       u4yJ4: // global
           call _c4yIs(R1) args: 0, res: 0, upd: 0;
       c4yIw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yIm_info" {
     block_c4yIm_info:
         const _c4yIm;
         const 1;
         const 12884901918;
         const S4wm5_srt+536;
 },
 _c4yIs() //  [R1]
         { []
         }
     {offset
       c4yIs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yIC; else goto c4yIB;
       c4yIC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yIB: // global
           _s4vQQ::I64 = I64[Sp + 8];
           _s4vQT::I64 = I64[R1 + 7];
           if (_s4vQT::I64 != (-1)) goto u4yJ3; else goto c4yJ1;
       u4yJ3: // global
           if (_s4vQT::I64 != 0) goto c4yIN; else goto c4yJ2;
       c4yIN: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4vQQ::I64,
                                                                          _s4vQT::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yJ2: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yJ1: // global
           if (_s4vQQ::I64 == (-128)) goto c4yJ0; else goto c4yIZ;
       c4yJ0: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yIZ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Quot_W64(_s4vQQ::I64,
                                                                          (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yIs_info" {
     block_c4yIs_info:
         const _c4yIs;
         const 65;
         const 12884901918;
         const S4wm5_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.695853556 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$crem_closure" {
     GHC.Int.$fIntegralInt8_$crem_closure:
         const GHC.Int.$fIntegralInt8_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yJB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yJF; else goto c4yJG;
       c4yJF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yJG: // global
           I64[Sp - 16] = block_c4yJy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yK2; else goto c4yJz;
       u4yK2: // global
           call _c4yJy(R1) args: 0, res: 0, upd: 0;
       c4yJz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$crem_info" {
     GHC.Int.$fIntegralInt8_$crem_info:
         const GHC.Int.$fIntegralInt8_$crem_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const S4wm5_srt+536;
 },
 _c4yJy() //  [R1]
         { []
         }
     {offset
       c4yJy: // global
           I64[Sp] = block_c4yJE_info;
           _s4vR4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vR4::I64;
           if (R1 & 7 != 0) goto u4yK1; else goto c4yJI;
       u4yK1: // global
           call _c4yJE(R1) args: 0, res: 0, upd: 0;
       c4yJI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yJy_info" {
     block_c4yJy_info:
         const _c4yJy;
         const 1;
         const 4294967326;
         const S4wm5_srt+536;
 },
 _c4yJE() //  [R1]
         { []
         }
     {offset
       c4yJE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yJO; else goto c4yJN;
       c4yJO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yJN: // global
           _s4vR7::I64 = I64[R1 + 7];
           if (_s4vR7::I64 != 0) goto c4yJZ; else goto c4yK0;
       c4yJZ: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(%MO_S_Rem_W64(I64[Sp + 8],
                                                                         _s4vR7::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yK0: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yJE_info" {
     block_c4yJE_info:
         const _c4yJE;
         const 65;
         const 4294967326;
         const S4wm5_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.704467063 UTC

[section ""data" . GHC.Int.$w$cdiv3_closure" {
     GHC.Int.$w$cdiv3_closure:
         const GHC.Int.$w$cdiv3_info;
         const 0;
 },
 GHC.Int.$w$cdiv3_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yKv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yKw; else goto c4yKx;
       c4yKw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yKx: // global
           if (R3 == (-1)) goto c4yKt; else goto u4yKR;
       c4yKt: // global
           if (R2 == (-128)) goto c4yKQ; else goto c4yKO;
       c4yKQ: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yKO: // global
           I64[Sp - 8] = block_c4yKI_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4yKR: // global
           if (R3 == 0) goto c4yKu; else goto c4yKs;
       c4yKu: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yKs: // global
           I64[Sp - 8] = block_c4yKz_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdiv3_info" {
     GHC.Int.$w$cdiv3_info:
         const GHC.Int.$w$cdiv3_entry;
         const 0;
         const 81604378638;
         const 8589934604;
         const S4wm5_srt+536;
 },
 _c4yKI() //  [R1]
         { []
         }
     {offset
       c4yKI: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yKI_info" {
     block_c4yKI_info:
         const _c4yKI;
         const 0;
         const 30;
 },
 _c4yKz() //  [R1]
         { []
         }
     {offset
       c4yKz: // global
           R1 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yKz_info" {
     block_c4yKz_info:
         const _c4yKz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.713568472 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdiv_closure" {
     GHC.Int.$fIntegralInt8_$cdiv_closure:
         const GHC.Int.$fIntegralInt8_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yLg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yLt; else goto c4yLu;
       c4yLt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yLu: // global
           I64[Sp - 16] = block_c4yLd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yLB; else goto c4yLe;
       u4yLB: // global
           call _c4yLd(R1) args: 0, res: 0, upd: 0;
       c4yLe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$cdiv_info" {
     GHC.Int.$fIntegralInt8_$cdiv_info:
         const GHC.Int.$fIntegralInt8_$cdiv_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+568;
 },
 _c4yLd() //  [R1]
         { []
         }
     {offset
       c4yLd: // global
           I64[Sp] = block_c4yLj_info;
           _s4vRl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vRl::I64;
           if (R1 & 7 != 0) goto u4yLA; else goto c4yLk;
       u4yLA: // global
           call _c4yLj(R1) args: 0, res: 0, upd: 0;
       c4yLk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yLd_info" {
     block_c4yLd_info:
         const _c4yLd;
         const 1;
         const 4294967326;
         const S4wm5_srt+568;
 },
 _c4yLj() //  [R1]
         { []
         }
     {offset
       c4yLj: // global
           _s4vRl::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4yLo_info;
           R3 = I64[R1 + 7];
           R2 = _s4vRl::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yLj_info" {
     block_c4yLj_info:
         const _c4yLj;
         const 65;
         const 4294967326;
         const S4wm5_srt+568;
 },
 _c4yLo() //  [R1]
         { []
         }
     {offset
       c4yLo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yLz; else goto c4yLy;
       c4yLz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4yLy: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yLo_info" {
     block_c4yLo_info:
         const _c4yLo;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.72326439 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cmod_closure" {
     GHC.Int.$fIntegralInt8_$cmod_closure:
         const GHC.Int.$fIntegralInt8_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cmod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yM4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yM8; else goto c4yM9;
       c4yM8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yM9: // global
           I64[Sp - 16] = block_c4yM1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yMx; else goto c4yM2;
       u4yMx: // global
           call _c4yM1(R1) args: 0, res: 0, upd: 0;
       c4yM2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$cmod_info" {
     GHC.Int.$fIntegralInt8_$cmod_info:
         const GHC.Int.$fIntegralInt8_$cmod_entry;
         const 0;
         const 279172874254;
         const 8589934607;
         const S4wm5_srt+536;
 },
 _c4yM1() //  [R1]
         { []
         }
     {offset
       c4yM1: // global
           I64[Sp] = block_c4yM7_info;
           _s4vRs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vRs::I64;
           if (R1 & 7 != 0) goto u4yMw; else goto c4yMb;
       u4yMw: // global
           call _c4yM7(R1) args: 0, res: 0, upd: 0;
       c4yMb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yM1_info" {
     block_c4yM1_info:
         const _c4yM1;
         const 1;
         const 4294967326;
         const S4wm5_srt+536;
 },
 _c4yM7() //  [R1]
         { []
         }
     {offset
       c4yM7: // global
           _s4vRv::I64 = I64[R1 + 7];
           if (_s4vRv::I64 != 0) goto c4yMr; else goto c4yMv;
       c4yMr: // global
           _s4vRs::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4yMi_info;
           R3 = _s4vRv::I64;
           R2 = _s4vRs::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4yMv: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yM7_info" {
     block_c4yM7_info:
         const _c4yM7;
         const 65;
         const 4294967326;
         const S4wm5_srt+536;
 },
 _c4yMi() //  [R1]
         { []
         }
     {offset
       c4yMi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yMu; else goto c4yMt;
       c4yMu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4yMt: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yMi_info" {
     block_c4yMi_info:
         const _c4yMi;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.731939821 UTC

[section ""data" . lvl6_r4kPx_closure" {
     lvl6_r4kPx_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt13_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.735795624 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cquotRem_closure" {
     GHC.Int.$fIntegralInt8_$cquotRem_closure:
         const GHC.Int.$fIntegralInt8_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yN3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yN7; else goto c4yN8;
       c4yN7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yN8: // global
           I64[Sp - 16] = block_c4yN0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yNN; else goto c4yN1;
       u4yNN: // global
           call _c4yN0(R1) args: 0, res: 0, upd: 0;
       c4yN1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$cquotRem_info" {
     GHC.Int.$fIntegralInt8_$cquotRem_info:
         const GHC.Int.$fIntegralInt8_$cquotRem_entry;
         const 0;
         const 1653562408974;
         const 8589934607;
         const S4wm5_srt+536;
 },
 _c4yN0() //  [R1]
         { []
         }
     {offset
       c4yN0: // global
           I64[Sp] = block_c4yN6_info;
           _s4vRC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vRC::I64;
           if (R1 & 7 != 0) goto u4yNM; else goto c4yNa;
       u4yNM: // global
           call _c4yN6(R1) args: 0, res: 0, upd: 0;
       c4yNa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yN0_info" {
     block_c4yN0_info:
         const _c4yN0;
         const 1;
         const 1103806595102;
         const S4wm5_srt+536;
 },
 _c4yN6() //  [R1]
         { []
         }
     {offset
       c4yN6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4yNg; else goto c4yNf;
       c4yNg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yNf: // global
           _s4vRC::I64 = I64[Sp + 8];
           _s4vRF::I64 = I64[R1 + 7];
           if (_s4vRF::I64 != (-1)) goto u4yNL; else goto c4yNJ;
       u4yNL: // global
           if (_s4vRF::I64 != 0) goto c4yNt; else goto c4yNK;
       c4yNt: // global
           (_s4vRH::I64, _s4vRI::I64) = call MO_S_QuotRem W64(_s4vRC::I64, _s4vRF::I64);
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vRI::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vRH::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yNK: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yNJ: // global
           if (_s4vRC::I64 == (-128)) goto c4yNI; else goto c4yNH;
       c4yNI: // global
           Hp = Hp - 56;
           R1 = lvl6_r4kPx_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yNH: // global
           (_s4vRP::I64, _s4vRQ::I64) = call MO_S_QuotRem W64(_s4vRC::I64, (-1));
           I64[Hp - 48] = GHC.Int.I8#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vRQ::I64));
           I64[Hp - 32] = GHC.Int.I8#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vRP::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yN6_info" {
     block_c4yN6_info:
         const _c4yN6;
         const 65;
         const 1103806595102;
         const S4wm5_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.74742525 UTC

[section ""data" . GHC.Int.$w$cdivMod3_closure" {
     GHC.Int.$w$cdivMod3_closure:
         const GHC.Int.$w$cdivMod3_info;
         const 0;
 },
 GHC.Int.$w$cdivMod3_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yOx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yOy; else goto c4yOz;
       c4yOy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yOz: // global
           if (R3 == 0) goto c4yOw; else goto c4yOv;
       c4yOw: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4yOv: // global
           if (R3 == (-1)) goto c4yR2; else goto u4yR3;
       c4yR2: // global
           if (R2 == (-128)) goto c4yR1; else goto u4yR4;
       c4yR1: // global
           R2 = GHC.Int.$fBitsInt13_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4yR4: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4yR6;
       u4yR3: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4yR6;
       u4yR6: // global
           call _c4yOE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdivMod3_info" {
     GHC.Int.$w$cdivMod3_info:
         const GHC.Int.$w$cdivMod3_entry;
         const 0;
         const 2211908157454;
         const 8589934604;
         const S4wm5_srt+536;
 },
 _c4yOE() //  []
         { []
         }
     {offset
       c4yOE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4yOI; else goto c4yOH;
       c4yOI: // global
           HpAlloc = 32;
           I64[Sp] = block_c4yOE_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4yOH: // global
           _s4vRW::I64 = I64[Sp + 8];
           _s4vRY::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4vRW::I64, 0)) goto c4yPB; else goto c4yQS;
       c4yPB: // global
           if (%MO_S_Ge_W64(_s4vRW::I64, 0)) goto c4yOY; else goto c4yPz;
       c4yOY: // global
           (_s4vS3::I64, _s4vS4::I64) = call MO_S_QuotRem W64(_s4vRW::I64, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vS4::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vS3::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yPz: // global
           if (%MO_S_Le_W64(_s4vRY::I64, 0)) goto c4yPc; else goto c4yPy;
       c4yPc: // global
           (_s4vSb::I64, _s4vSc::I64) = call MO_S_QuotRem W64(_s4vRW::I64, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSc::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSb::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yPy: // global
           (_s4vSj::I64, _s4vSk::I64) = call MO_S_QuotRem W64(_s4vRW::I64 + 1, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSk::I64 + _s4vRY::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSj::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yQS: // global
           if (%MO_S_Ge_W64(_s4vRY::I64, 0)) goto c4yQv; else goto c4yQR;
       c4yQv: // global
           if (%MO_S_Ge_W64(_s4vRW::I64, 0)) goto c4yPS; else goto c4yQt;
       c4yPS: // global
           (_s4vSv::I64, _s4vSw::I64) = call MO_S_QuotRem W64(_s4vRW::I64, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSw::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSv::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yQt: // global
           if (%MO_S_Le_W64(_s4vRY::I64, 0)) goto c4yQ6; else goto c4yQs;
       c4yQ6: // global
           (_s4vSD::I64, _s4vSE::I64) = call MO_S_QuotRem W64(_s4vRW::I64, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSE::I64));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSD::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yQs: // global
           (_s4vSL::I64, _s4vSM::I64) = call MO_S_QuotRem W64(_s4vRW::I64 + 1, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSM::I64 + _s4vRY::I64 - 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSL::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4yQR: // global
           (_s4vSW::I64, _s4vSX::I64) = call MO_S_QuotRem W64(_s4vRW::I64 - 1, _s4vRY::I64);
           I64[Hp - 24] = GHC.Int.I8#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSX::I64 + _s4vRY::I64 + 1));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(_s4vSW::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yOE_info" {
     block_c4yOE_info:
         const _c4yOE;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.757456501 UTC

[section ""data" . GHC.Int.$fIntegralInt8_$cdivMod_closure" {
     GHC.Int.$fIntegralInt8_$cdivMod_closure:
         const GHC.Int.$fIntegralInt8_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt8_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ySh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ySs; else goto c4ySt;
       c4ySs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt8_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ySt: // global
           I64[Sp - 16] = block_c4ySe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ySA; else goto c4ySf;
       u4ySA: // global
           call _c4ySe(R1) args: 0, res: 0, upd: 0;
       c4ySf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt8_$cdivMod_info" {
     GHC.Int.$fIntegralInt8_$cdivMod_info:
         const GHC.Int.$fIntegralInt8_$cdivMod_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+608;
 },
 _c4ySe() //  [R1]
         { []
         }
     {offset
       c4ySe: // global
           I64[Sp] = block_c4ySk_info;
           _s4vTb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vTb::I64;
           if (R1 & 7 != 0) goto u4ySz; else goto c4ySl;
       u4ySz: // global
           call _c4ySk(R1) args: 0, res: 0, upd: 0;
       c4ySl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ySe_info" {
     block_c4ySe_info:
         const _c4ySe;
         const 1;
         const 4294967326;
         const S4wm5_srt+608;
 },
 _c4ySk() //  [R1]
         { []
         }
     {offset
       c4ySk: // global
           _s4vTb::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4ySp_info;
           R3 = I64[R1 + 7];
           R2 = _s4vTb::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod3_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ySk_info" {
     block_c4ySk_info:
         const _c4ySk;
         const 65;
         const 4294967326;
         const S4wm5_srt+608;
 },
 _c4ySp() //  [R1, R2]
         { []
         }
     {offset
       c4ySp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ySy; else goto c4ySx;
       c4ySy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ySx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ySp_info" {
     block_c4ySp_info:
         const _c4ySp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.765924846 UTC

[section ""data" . sat_s4vTh_closure" {
     sat_s4vTh_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.768152854 UTC

[section ""data" . sat_s4vTi_closure" {
     sat_s4vTi_closure:
         const :_con_info;
         const sat_s4vTh_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.770663248 UTC

[section ""data" . GHC.Int.$fRealInt1_closure" {
     GHC.Int.$fRealInt1_closure:
         const GHC.Int.$fRealInt1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fRealInt1_entry() //  [R1]
         { []
         }
     {offset
       c4yT4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yT5; else goto c4yT6;
       c4yT5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4yT6: // global
           (_c4yT1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4yT1::I64 == 0) goto c4yT3; else goto c4yT2;
       c4yT3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4yT2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4yT1::I64;
           R3 = sat_s4vTi_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fRealInt1_info" {
     GHC.Int.$fRealInt1_info:
         const GHC.Int.$fRealInt1_entry;
         const 0;
         const 4294967317;
         const S4wm5_srt+624;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.775972526 UTC

[section ""data" . GHC.Int.$fRealInt8_$ctoRational_closure" {
     GHC.Int.$fRealInt8_$ctoRational_closure:
         const GHC.Int.$fRealInt8_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt8_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c4yTn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yTB; else goto c4yTC;
       c4yTB: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt8_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yTC: // global
           I64[Sp - 8] = block_c4yTk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yTJ; else goto c4yTl;
       u4yTJ: // global
           call _c4yTk(R1) args: 0, res: 0, upd: 0;
       c4yTl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fRealInt8_$ctoRational_info" {
     GHC.Int.$fRealInt8_$ctoRational_info:
         const GHC.Int.$fRealInt8_$ctoRational_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S4wm5_srt+632;
 },
 _c4yTk() //  [R1]
         { []
         }
     {offset
       c4yTk: // global
           I64[Sp] = block_c4yTq_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yTk_info" {
     block_c4yTk_info:
         const _c4yTk;
         const 0;
         const 30064771102;
         const S4wm5_srt+632;
 },
 _c4yTq() //  [R1]
         { []
         }
     {offset
       c4yTq: // global
           I64[Sp] = block_c4yTu_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yTq_info" {
     block_c4yTq_info:
         const _c4yTq;
         const 0;
         const 30064771102;
         const S4wm5_srt+632;
 },
 _c4yTu() //  [R1]
         { []
         }
     {offset
       c4yTu: // global
           I64[Sp] = block_c4yTy_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yTu_info" {
     block_c4yTu_info:
         const _c4yTu;
         const 0;
         const 12884901918;
         const S4wm5_srt+640;
 },
 _c4yTy() //  [R1, R2]
         { []
         }
     {offset
       c4yTy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4yTI; else goto c4yTH;
       c4yTI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4yTH: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yTy_info" {
     block_c4yTy_info:
         const _c4yTy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.785874759 UTC

[section ""data" . GHC.Int.$fRealInt8_closure" {
     GHC.Int.$fRealInt8_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt8_closure+1;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fRealInt8_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.788294604 UTC

[section ""data" . GHC.Int.$fIntegralInt8_closure" {
     GHC.Int.$fIntegralInt8_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt8_closure+1;
         const GHC.Int.$fEnumInt8_closure+1;
         const GHC.Int.$fIntegralInt8_$cquot_closure+2;
         const GHC.Int.$fIntegralInt8_$crem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt8_$cmod_closure+2;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt8_$ctoInteger_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.792109274 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt8_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt8_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt8_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yUh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yUy; else goto c4yUz;
       c4yUy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yUz: // global
           I64[Sp - 16] = block_c4yUe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yUG; else goto c4yUf;
       u4yUG: // global
           call _c4yUe(R1) args: 0, res: 0, upd: 0;
       c4yUf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$cunsafeIndex_info" {
     GHC.Int.$fIxInt8_$cunsafeIndex_info:
         const GHC.Int.$fIxInt8_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yUe() //  [R1]
         { []
         }
     {offset
       c4yUe: // global
           I64[Sp] = block_c4yUk_info;
           _s4vTu::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4vTu::P64;
           if (R1 & 7 != 0) goto u4yUF; else goto c4yUl;
       u4yUF: // global
           call _c4yUk(R1) args: 0, res: 0, upd: 0;
       c4yUl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yUe_info" {
     block_c4yUe_info:
         const _c4yUe;
         const 1;
         const 30;
 },
 _c4yUk() //  [R1]
         { []
         }
     {offset
       c4yUk: // global
           I64[Sp] = block_c4yUp_info;
           _s4vTx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vTx::I64;
           if (R1 & 7 != 0) goto u4yUH; else goto c4yUq;
       u4yUH: // global
           call _c4yUp(R1) args: 0, res: 0, upd: 0;
       c4yUq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yUk_info" {
     block_c4yUk_info:
         const _c4yUk;
         const 1;
         const 30;
 },
 _c4yUp() //  [R1]
         { []
         }
     {offset
       c4yUp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yUE; else goto c4yUD;
       c4yUE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yUD: // global
           _s4vTA::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vTA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yUp_info" {
     block_c4yUp_info:
         const _c4yUp;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.801406364 UTC

[section ""data" . GHC.Int.$fIxInt8_$crange_closure" {
     GHC.Int.$fIxInt8_$crange_closure:
         const GHC.Int.$fIxInt8_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$crange_entry() //  [R2]
         { []
         }
     {offset
       c4yVd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4yVe; else goto c4yVf;
       c4yVe: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yVf: // global
           I64[Sp - 8] = block_c4yVa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yVj; else goto c4yVb;
       u4yVj: // global
           call _c4yVa(R1) args: 0, res: 0, upd: 0;
       c4yVb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$crange_info" {
     GHC.Int.$fIxInt8_$crange_info:
         const GHC.Int.$fIxInt8_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+664;
 },
 _c4yVa() //  [R1]
         { []
         }
     {offset
       c4yVa: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt8_$cenumFromTo_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yVa_info" {
     block_c4yVa_info:
         const _c4yVa;
         const 0;
         const 4294967326;
         const S4wm5_srt+672;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.808167488 UTC

[section ""data" . GHC.Int.$fIxInt8_$crangeSize_closure" {
     GHC.Int.$fIxInt8_$crangeSize_closure:
         const GHC.Int.$fIxInt8_$crangeSize_info;
 },
 GHC.Int.$fIxInt8_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4yVB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yVK; else goto c4yVL;
       c4yVK: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yVL: // global
           I64[Sp - 8] = block_c4yVy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yWa; else goto c4yVz;
       u4yWa: // global
           call _c4yVy(R1) args: 0, res: 0, upd: 0;
       c4yVz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$crangeSize_info" {
     GHC.Int.$fIxInt8_$crangeSize_info:
         const GHC.Int.$fIxInt8_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4yVy() //  [R1]
         { []
         }
     {offset
       c4yVy: // global
           I64[Sp - 8] = block_c4yVE_info;
           _s4vTI::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4vTI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yW9; else goto c4yVF;
       u4yW9: // global
           call _c4yVE(R1) args: 0, res: 0, upd: 0;
       c4yVF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yVy_info" {
     block_c4yVy_info:
         const _c4yVy;
         const 0;
         const 30;
 },
 _c4yVE() //  [R1]
         { []
         }
     {offset
       c4yVE: // global
           I64[Sp] = block_c4yVJ_info;
           _s4vTK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vTK::I64;
           if (R1 & 7 != 0) goto u4yWb; else goto c4yVO;
       u4yWb: // global
           call _c4yVJ(R1) args: 0, res: 0, upd: 0;
       c4yVO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yVE_info" {
     block_c4yVE_info:
         const _c4yVE;
         const 1;
         const 30;
 },
 _c4yVJ() //  [R1]
         { []
         }
     {offset
       c4yVJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yVU; else goto c4yVT;
       c4yVU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yVT: // global
           _s4vTK::I64 = I64[Sp + 8];
           _s4vTM::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4vTK::I64,
                            _s4vTM::I64)) goto c4yVY; else goto c4yW8;
       c4yVY: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4yW8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vTM::I64 - _s4vTK::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yVJ_info" {
     block_c4yVJ_info:
         const _c4yVJ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.819154848 UTC

[section ""data" . GHC.Int.$fIxInt8_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt8_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt8_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4yWJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yX3; else goto c4yX4;
       c4yX3: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4yX4: // global
           I64[Sp - 8] = block_c4yWG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yXb; else goto c4yWH;
       u4yXb: // global
           call _c4yWG(R1) args: 0, res: 0, upd: 0;
       c4yWH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$cunsafeRangeSize_info" {
     GHC.Int.$fIxInt8_$cunsafeRangeSize_info:
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4yWG() //  [R1]
         { []
         }
     {offset
       c4yWG: // global
           I64[Sp - 8] = block_c4yWM_info;
           _s4vTS::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4vTS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yXa; else goto c4yWN;
       u4yXa: // global
           call _c4yWM(R1) args: 0, res: 0, upd: 0;
       c4yWN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yWG_info" {
     block_c4yWG_info:
         const _c4yWG;
         const 0;
         const 30;
 },
 _c4yWM() //  [R1]
         { []
         }
     {offset
       c4yWM: // global
           I64[Sp] = block_c4yWR_info;
           _s4vTV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vTV::I64;
           if (R1 & 7 != 0) goto u4yXc; else goto c4yWS;
       u4yXc: // global
           call _c4yWR(R1) args: 0, res: 0, upd: 0;
       c4yWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yWM_info" {
     block_c4yWM_info:
         const _c4yWM;
         const 1;
         const 30;
 },
 _c4yWR() //  [R1]
         { []
         }
     {offset
       c4yWR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yX9; else goto c4yX8;
       c4yX9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yX8: // global
           _s4vTZ::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vTZ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yWR_info" {
     block_c4yWR_info:
         const _c4yWR;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.830836131 UTC

[section ""data" . GHC.Int.$fIxInt8_$cindex_closure" {
     GHC.Int.$fIxInt8_$cindex_closure:
         const GHC.Int.$fIxInt8_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt8_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yXJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4yXS; else goto c4yXT;
       c4yXS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt8_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yXT: // global
           I64[Sp - 16] = block_c4yXG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yYs; else goto c4yXH;
       u4yYs: // global
           call _c4yXG(R1) args: 0, res: 0, upd: 0;
       c4yXH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt8_$cindex_info" {
     GHC.Int.$fIxInt8_$cindex_info:
         const GHC.Int.$fIxInt8_$cindex_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+680;
 },
 _c4yXG() //  [R1]
         { []
         }
     {offset
       c4yXG: // global
           I64[Sp - 8] = block_c4yXM_info;
           _s4vU4::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4vU4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4yYr; else goto c4yXN;
       u4yYr: // global
           call _c4yXM(R1) args: 0, res: 0, upd: 0;
       c4yXN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yXG_info" {
     block_c4yXG_info:
         const _c4yXG;
         const 1;
         const 4294967326;
         const S4wm5_srt+680;
 },
 _c4yXM() //  [R1]
         { []
         }
     {offset
       c4yXM: // global
           I64[Sp] = block_c4yXR_info;
           _s4vU6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vU6::I64;
           if (R1 & 7 != 0) goto u4yYt; else goto c4yXW;
       u4yYt: // global
           call _c4yXR(R1) args: 0, res: 0, upd: 0;
       c4yXW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yXM_info" {
     block_c4yXM_info:
         const _c4yXM;
         const 2;
         const 4294967326;
         const S4wm5_srt+680;
 },
 _c4yXR() //  [R1]
         { []
         }
     {offset
       c4yXR: // global
           _s4vU8::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4vU8::I64)) goto c4yY4; else goto c4yY8;
       c4yY4: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4yY8: // global
           I64[Sp] = block_c4yY7_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vU8::I64;
           if (R1 & 7 != 0) goto u4yYu; else goto c4yY9;
       u4yYu: // global
           call _c4yY7(R1) args: 0, res: 0, upd: 0;
       c4yY9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yXR_info" {
     block_c4yXR_info:
         const _c4yXR;
         const 130;
         const 4294967326;
         const S4wm5_srt+680;
 },
 _c4yY7() //  [R1]
         { []
         }
     {offset
       c4yY7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4yYf; else goto c4yYe;
       c4yYf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4yYe: // global
           _s4vU8::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4vU8::I64,
                            I64[R1 + 7])) goto c4yYj; else goto c4yYq;
       c4yYj: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4yYq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4vU8::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yY7_info" {
     block_c4yY7_info:
         const _c4yY7;
         const 194;
         const 4294967326;
         const S4wm5_srt+680;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.841136464 UTC

[section ""data" . GHC.Int.$fIxInt8_closure" {
     GHC.Int.$fIxInt8_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt8_closure+1;
         const GHC.Int.$fIxInt8_$crange_closure+1;
         const GHC.Int.$fIxInt8_$cindex_closure+2;
         const GHC.Int.$fIxInt8_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt8_$cinRange_closure+2;
         const GHC.Int.$fIxInt8_$crangeSize_closure+1;
         const GHC.Int.$fIxInt8_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.844279841 UTC

[section ""data" . GHC.Int.eqInt16_closure" {
     GHC.Int.eqInt16_closure:
         const GHC.Int.eqInt16_info;
 },
 GHC.Int.eqInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yZ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yZc; else goto c4yZd;
       c4yZc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yZd: // global
           I64[Sp - 16] = block_c4yZ5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4yZm; else goto c4yZ6;
       u4yZm: // global
           call _c4yZ5(R1) args: 0, res: 0, upd: 0;
       c4yZ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.eqInt16_info" {
     GHC.Int.eqInt16_info:
         const GHC.Int.eqInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yZ5() //  [R1]
         { []
         }
     {offset
       c4yZ5: // global
           I64[Sp] = block_c4yZb_info;
           _s4vUh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUh::I64;
           if (R1 & 7 != 0) goto u4yZl; else goto c4yZf;
       u4yZl: // global
           call _c4yZb(R1) args: 0, res: 0, upd: 0;
       c4yZf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yZ5_info" {
     block_c4yZ5_info:
         const _c4yZ5;
         const 1;
         const 30;
 },
 _c4yZb() //  [R1]
         { []
         }
     {offset
       c4yZb: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yZb_info" {
     block_c4yZb_info:
         const _c4yZb;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.851847744 UTC

[section ""data" . GHC.Int.$fEqInt16_closure" {
     GHC.Int.$fEqInt16_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt16_closure+2;
         const GHC.Int.neInt16_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.854827154 UTC

[section ""data" . GHC.Int.gtInt16_closure" {
     GHC.Int.gtInt16_closure:
         const GHC.Int.gtInt16_info;
 },
 GHC.Int.gtInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4yZP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4yZT; else goto c4yZU;
       c4yZT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4yZU: // global
           I64[Sp - 16] = block_c4yZM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z03; else goto c4yZN;
       u4z03: // global
           call _c4yZM(R1) args: 0, res: 0, upd: 0;
       c4yZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.gtInt16_info" {
     GHC.Int.gtInt16_info:
         const GHC.Int.gtInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4yZM() //  [R1]
         { []
         }
     {offset
       c4yZM: // global
           I64[Sp] = block_c4yZS_info;
           _s4vUo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUo::I64;
           if (R1 & 7 != 0) goto u4z02; else goto c4yZW;
       u4z02: // global
           call _c4yZS(R1) args: 0, res: 0, upd: 0;
       c4yZW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yZM_info" {
     block_c4yZM_info:
         const _c4yZM;
         const 1;
         const 30;
 },
 _c4yZS() //  [R1]
         { []
         }
     {offset
       c4yZS: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4yZS_info" {
     block_c4yZS_info:
         const _c4yZS;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.8628382 UTC

[section ""data" . GHC.Int.geInt16_closure" {
     GHC.Int.geInt16_closure:
         const GHC.Int.geInt16_info;
 },
 GHC.Int.geInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4z0v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4z0z; else goto c4z0A;
       c4z0z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z0A: // global
           I64[Sp - 16] = block_c4z0s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z0J; else goto c4z0t;
       u4z0J: // global
           call _c4z0s(R1) args: 0, res: 0, upd: 0;
       c4z0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.geInt16_info" {
     GHC.Int.geInt16_info:
         const GHC.Int.geInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4z0s() //  [R1]
         { []
         }
     {offset
       c4z0s: // global
           I64[Sp] = block_c4z0y_info;
           _s4vUv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUv::I64;
           if (R1 & 7 != 0) goto u4z0I; else goto c4z0C;
       u4z0I: // global
           call _c4z0y(R1) args: 0, res: 0, upd: 0;
       c4z0C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z0s_info" {
     block_c4z0s_info:
         const _c4z0s;
         const 1;
         const 30;
 },
 _c4z0y() //  [R1]
         { []
         }
     {offset
       c4z0y: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z0y_info" {
     block_c4z0y_info:
         const _c4z0y;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.87147318 UTC

[section ""data" . GHC.Int.ltInt16_closure" {
     GHC.Int.ltInt16_closure:
         const GHC.Int.ltInt16_info;
 },
 GHC.Int.ltInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4z1b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4z1f; else goto c4z1g;
       c4z1f: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z1g: // global
           I64[Sp - 16] = block_c4z18_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z1p; else goto c4z19;
       u4z1p: // global
           call _c4z18(R1) args: 0, res: 0, upd: 0;
       c4z19: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.ltInt16_info" {
     GHC.Int.ltInt16_info:
         const GHC.Int.ltInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4z18() //  [R1]
         { []
         }
     {offset
       c4z18: // global
           I64[Sp] = block_c4z1e_info;
           _s4vUC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUC::I64;
           if (R1 & 7 != 0) goto u4z1o; else goto c4z1i;
       u4z1o: // global
           call _c4z1e(R1) args: 0, res: 0, upd: 0;
       c4z1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z18_info" {
     block_c4z18_info:
         const _c4z18;
         const 1;
         const 30;
 },
 _c4z1e() //  [R1]
         { []
         }
     {offset
       c4z1e: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z1e_info" {
     block_c4z1e_info:
         const _c4z1e;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.879561169 UTC

[section ""data" . GHC.Int.leInt16_closure" {
     GHC.Int.leInt16_closure:
         const GHC.Int.leInt16_info;
 },
 GHC.Int.leInt16_entry() //  [R2, R3]
         { []
         }
     {offset
       c4z1R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4z1V; else goto c4z1W;
       c4z1V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt16_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z1W: // global
           I64[Sp - 16] = block_c4z1O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z25; else goto c4z1P;
       u4z25: // global
           call _c4z1O(R1) args: 0, res: 0, upd: 0;
       c4z1P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.leInt16_info" {
     GHC.Int.leInt16_info:
         const GHC.Int.leInt16_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4z1O() //  [R1]
         { []
         }
     {offset
       c4z1O: // global
           I64[Sp] = block_c4z1U_info;
           _s4vUJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUJ::I64;
           if (R1 & 7 != 0) goto u4z24; else goto c4z1Y;
       u4z24: // global
           call _c4z1U(R1) args: 0, res: 0, upd: 0;
       c4z1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z1O_info" {
     block_c4z1O_info:
         const _c4z1O;
         const 1;
         const 30;
 },
 _c4z1U() //  [R1]
         { []
         }
     {offset
       c4z1U: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z1U_info" {
     block_c4z1U_info:
         const _c4z1U;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.887669194 UTC

[section ""data" . GHC.Int.$fOrdInt16_$ccompare_closure" {
     GHC.Int.$fOrdInt16_$ccompare_closure:
         const GHC.Int.$fOrdInt16_$ccompare_info;
 },
 GHC.Int.$fOrdInt16_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c4z2x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4z2B; else goto c4z2C;
       c4z2B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z2C: // global
           I64[Sp - 16] = block_c4z2u_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z2V; else goto c4z2v;
       u4z2V: // global
           call _c4z2u(R1) args: 0, res: 0, upd: 0;
       c4z2v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt16_$ccompare_info" {
     GHC.Int.$fOrdInt16_$ccompare_info:
         const GHC.Int.$fOrdInt16_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4z2u() //  [R1]
         { []
         }
     {offset
       c4z2u: // global
           I64[Sp] = block_c4z2A_info;
           _s4vUQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vUQ::I64;
           if (R1 & 7 != 0) goto u4z2U; else goto c4z2E;
       u4z2U: // global
           call _c4z2A(R1) args: 0, res: 0, upd: 0;
       c4z2E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z2u_info" {
     block_c4z2u_info:
         const _c4z2u;
         const 1;
         const 30;
 },
 _c4z2A() //  [R1]
         { []
         }
     {offset
       c4z2A: // global
           _s4vUQ::I64 = I64[Sp + 8];
           _s4vUS::I64 = I64[R1 + 7];
           if (_s4vUQ::I64 == _s4vUS::I64) goto c4z2T; else goto c4z2S;
       c4z2T: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z2S: // global
           if (%MO_S_Gt_W64(_s4vUQ::I64,
                            _s4vUS::I64)) goto c4z2P; else goto c4z2Q;
       c4z2P: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z2Q: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z2A_info" {
     block_c4z2A_info:
         const _c4z2A;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.896803511 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmax_closure" {
     GHC.Int.$fOrdInt16_$cmax_closure:
         const GHC.Int.$fOrdInt16_$cmax_info;
 },
 GHC.Int.$fOrdInt16_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c4z3o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4z3s; else goto c4z3t;
       c4z3s: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z3t: // global
           I64[Sp - 16] = block_c4z3l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z3G; else goto c4z3m;
       u4z3G: // global
           call _c4z3l(R1) args: 0, res: 0, upd: 0;
       c4z3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt16_$cmax_info" {
     GHC.Int.$fOrdInt16_$cmax_info:
         const GHC.Int.$fOrdInt16_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4z3l() //  [R1]
         { []
         }
     {offset
       c4z3l: // global
           I64[Sp - 8] = block_c4z3r_info;
           _s4vUX::P64 = R1;
           _s4vUY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vUY::I64;
           P64[Sp + 8] = _s4vUX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z3F; else goto c4z3v;
       u4z3F: // global
           call _c4z3r(R1) args: 0, res: 0, upd: 0;
       c4z3v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z3l_info" {
     block_c4z3l_info:
         const _c4z3l;
         const 1;
         const 30;
 },
 _c4z3r() //  [R1]
         { []
         }
     {offset
       c4z3r: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4z3D; else goto c4z3E;
       c4z3D: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4z3E: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z3r_info" {
     block_c4z3r_info:
         const _c4z3r;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.904973882 UTC

[section ""data" . GHC.Int.$fOrdInt16_$cmin_closure" {
     GHC.Int.$fOrdInt16_$cmin_closure:
         const GHC.Int.$fOrdInt16_$cmin_info;
 },
 GHC.Int.$fOrdInt16_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c4z48: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4z4c; else goto c4z4d;
       c4z4c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt16_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z4d: // global
           I64[Sp - 16] = block_c4z45_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z4q; else goto c4z46;
       u4z4q: // global
           call _c4z45(R1) args: 0, res: 0, upd: 0;
       c4z46: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt16_$cmin_info" {
     GHC.Int.$fOrdInt16_$cmin_info:
         const GHC.Int.$fOrdInt16_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4z45() //  [R1]
         { []
         }
     {offset
       c4z45: // global
           I64[Sp - 8] = block_c4z4b_info;
           _s4vV4::P64 = R1;
           _s4vV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vV5::I64;
           P64[Sp + 8] = _s4vV4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z4p; else goto c4z4f;
       u4z4p: // global
           call _c4z4b(R1) args: 0, res: 0, upd: 0;
       c4z4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z45_info" {
     block_c4z45_info:
         const _c4z45;
         const 1;
         const 30;
 },
 _c4z4b() //  [R1]
         { []
         }
     {offset
       c4z4b: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4z4n; else goto c4z4o;
       c4z4n: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4z4o: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z4b_info" {
     block_c4z4b_info:
         const _c4z4b;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.912999873 UTC

[section ""data" . GHC.Int.$fOrdInt16_closure" {
     GHC.Int.$fOrdInt16_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fOrdInt16_$ccompare_closure+2;
         const GHC.Int.ltInt16_closure+2;
         const GHC.Int.leInt16_closure+2;
         const GHC.Int.gtInt16_closure+2;
         const GHC.Int.geInt16_closure+2;
         const GHC.Int.$fOrdInt16_$cmax_closure+2;
         const GHC.Int.$fOrdInt16_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.91679747 UTC

[section ""data" . GHC.Int.$fIxInt16_$cinRange_closure" {
     GHC.Int.$fIxInt16_$cinRange_closure:
         const GHC.Int.$fIxInt16_$cinRange_info;
 },
 GHC.Int.$fIxInt16_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c4z4T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4z52; else goto c4z53;
       c4z52: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z53: // global
           I64[Sp - 16] = block_c4z4Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z5q; else goto c4z4R;
       u4z5q: // global
           call _c4z4Q(R1) args: 0, res: 0, upd: 0;
       c4z4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$cinRange_info" {
     GHC.Int.$fIxInt16_$cinRange_info:
         const GHC.Int.$fIxInt16_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4z4Q() //  [R1]
         { []
         }
     {offset
       c4z4Q: // global
           I64[Sp - 8] = block_c4z4W_info;
           _s4vVd::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4vVd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z5p; else goto c4z4X;
       u4z5p: // global
           call _c4z4W(R1) args: 0, res: 0, upd: 0;
       c4z4X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z4Q_info" {
     block_c4z4Q_info:
         const _c4z4Q;
         const 1;
         const 30;
 },
 _c4z4W() //  [R1]
         { []
         }
     {offset
       c4z4W: // global
           I64[Sp] = block_c4z51_info;
           _s4vVf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4vVf::I64;
           if (R1 & 7 != 0) goto u4z5r; else goto c4z56;
       u4z5r: // global
           call _c4z51(R1) args: 0, res: 0, upd: 0;
       c4z56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z4W_info" {
     block_c4z4W_info:
         const _c4z4W;
         const 2;
         const 30;
 },
 _c4z51() //  [R1]
         { []
         }
     {offset
       c4z51: // global
           _s4vVh::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4vVh::I64)) goto c4z5e; else goto c4z5i;
       c4z5e: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z5i: // global
           _s4vVd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4z5h_info;
           R1 = _s4vVd::P64;
           I64[Sp + 16] = _s4vVh::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4z5s; else goto c4z5j;
       u4z5s: // global
           call _c4z5h(R1) args: 0, res: 0, upd: 0;
       c4z5j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z51_info" {
     block_c4z51_info:
         const _c4z51;
         const 130;
         const 30;
 },
 _c4z5h() //  [R1]
         { []
         }
     {offset
       c4z5h: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z5h_info" {
     block_c4z5h_info:
         const _c4z5h;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.926913584 UTC

[section ""data" . GHC.Int.$fNumInt1_closure" {
     GHC.Int.$fNumInt1_closure:
         const GHC.Int.I16#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.929837605 UTC

[section ""data" . GHC.Int.$fNumInt16_$csignum_closure" {
     GHC.Int.$fNumInt16_$csignum_closure:
         const GHC.Int.$fNumInt16_$csignum_info;
 },
 GHC.Int.$fNumInt16_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c4z67: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4z68; else goto c4z69;
       c4z68: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4z69: // global
           I64[Sp - 8] = block_c4z64_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z6n; else goto c4z65;
       u4z6n: // global
           call _c4z64(R1) args: 0, res: 0, upd: 0;
       c4z65: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$csignum_info" {
     GHC.Int.$fNumInt16_$csignum_info:
         const GHC.Int.$fNumInt16_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4z64() //  [R1]
         { []
         }
     {offset
       c4z64: // global
           _s4vVo::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4vVo::I64, 0)) goto c4z6l; else goto c4z6m;
       c4z6l: // global
           if (_s4vVo::I64 == 0) goto c4z6j; else goto c4z6i;
       c4z6j: // global
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z6i: // global
           R1 = GHC.Int.$fNumInt2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z6m: // global
           R1 = GHC.Int.$fNumInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z64_info" {
     block_c4z64_info:
         const _c4z64;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.937502669 UTC

[section ""data" . GHC.Int.$fNumInt16_$cabs_closure" {
     GHC.Int.$fNumInt16_$cabs_closure:
         const GHC.Int.$fNumInt16_$cabs_info;
 },
 GHC.Int.$fNumInt16_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c4z6I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4z6J; else goto c4z6K;
       c4z6J: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt16_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4z6K: // global
           I64[Sp - 8] = block_c4z6F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z73; else goto c4z6G;
       u4z73: // global
           call _c4z6F(R1) args: 0, res: 0, upd: 0;
       c4z6G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt16_$cabs_info" {
     GHC.Int.$fNumInt16_$cabs_info:
         const GHC.Int.$fNumInt16_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4z6F() //  [R1]
         { []
         }
     {offset
       c4z6F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4z6P; else goto c4z6O;
       c4z6P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4z6O: // global
           _s4vVt::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vVt::I64, 0)) goto c4z71; else goto c4z72;
       c4z71: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(-_s4vVt::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z72: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z6F_info" {
     block_c4z6F_info:
         const _c4z6F;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.942826699 UTC

[section ""data" . GHC.Int.$fNumInt16_closure" {
     GHC.Int.$fNumInt16_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt16_$c+_closure+2;
         const GHC.Int.$fNumInt16_$c-_closure+2;
         const GHC.Int.$fNumInt16_$c*_closure+2;
         const GHC.Int.$fNumInt16_$cnegate_closure+1;
         const GHC.Int.$fNumInt16_$cabs_closure+1;
         const GHC.Int.$fNumInt16_$csignum_closure+1;
         const GHC.Int.$fNumInt16_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.944689404 UTC

[section ""data" . GHC.Int.$fBitsInt2_closure" {
     GHC.Int.$fBitsInt2_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.946803385 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt16_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c4z7q: // global
           R1 = GHC.Int.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cbitSizeMaybe_info" {
     GHC.Int.$fBitsInt16_$cbitSizeMaybe_info:
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.951249861 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cbit_closure" {
     GHC.Int.$fBitsInt16_$cbit_closure:
         const GHC.Int.$fBitsInt16_$cbit_info;
 },
 GHC.Int.$fBitsInt16_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c4z7F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4z7G; else goto c4z7H;
       c4z7G: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4z7H: // global
           I64[Sp - 8] = block_c4z7C_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4z80; else goto c4z7D;
       u4z80: // global
           call _c4z7C(R1) args: 0, res: 0, upd: 0;
       c4z7D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cbit_info" {
     GHC.Int.$fBitsInt16_$cbit_info:
         const GHC.Int.$fBitsInt16_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4z7C() //  [R1]
         { []
         }
     {offset
       c4z7C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4z7M; else goto c4z7L;
       c4z7M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4z7L: // global
           _s4vVA::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vVA::I64, 64)) goto c4z7Y; else goto c4z7Z;
       c4z7Y: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4vVA::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z7Z: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z7C_info" {
     block_c4z7C_info:
         const _c4z7C;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.958884869 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ctestBit_closure" {
     GHC.Int.$fBitsInt16_$ctestBit_closure:
         const GHC.Int.$fBitsInt16_$ctestBit_info;
 },
 GHC.Int.$fBitsInt16_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4z8o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4z8s; else goto c4z8t;
       c4z8s: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z8t: // global
           I64[Sp - 16] = block_c4z8l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4z9b; else goto c4z8m;
       u4z9b: // global
           call _c4z8l(R1) args: 0, res: 0, upd: 0;
       c4z8m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$ctestBit_info" {
     GHC.Int.$fBitsInt16_$ctestBit_info:
         const GHC.Int.$fBitsInt16_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4z8l() //  [R1]
         { []
         }
     {offset
       c4z8l: // global
           I64[Sp] = block_c4z8r_info;
           _s4vVH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vVH::I64;
           if (R1 & 7 != 0) goto u4z9a; else goto c4z8v;
       u4z9a: // global
           call _c4z8r(R1) args: 0, res: 0, upd: 0;
       c4z8v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z8l_info" {
     block_c4z8l_info:
         const _c4z8l;
         const 1;
         const 30;
 },
 _c4z8r() //  [R1]
         { []
         }
     {offset
       c4z8r: // global
           _s4vVJ::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4vVJ::I64, 64)) goto c4z99; else goto c4z98;
       c4z98: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4vVJ::I64)) == 0) goto c4z99; else goto c4z8X;
       c4z99: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4z8X: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z8r_info" {
     block_c4z8r_info:
         const _c4z8r;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.968384738 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateR_closure" {
     GHC.Int.$fBitsInt16_$crotateR_closure:
         const GHC.Int.$fBitsInt16_$crotateR_info;
 },
 GHC.Int.$fBitsInt16_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4z9H: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4z9L; else goto c4z9M;
       c4z9L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4z9M: // global
           I64[Sp - 16] = block_c4z9E_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zaL; else goto c4z9F;
       u4zaL: // global
           call _c4z9E(R1) args: 0, res: 0, upd: 0;
       c4z9F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$crotateR_info" {
     GHC.Int.$fBitsInt16_$crotateR_info:
         const GHC.Int.$fBitsInt16_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4z9E() //  [R1]
         { []
         }
     {offset
       c4z9E: // global
           I64[Sp - 8] = block_c4z9K_info;
           _s4vVT::P64 = R1;
           _s4vVU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vVU::I64;
           P64[Sp + 8] = _s4vVT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zaK; else goto c4z9O;
       u4zaK: // global
           call _c4z9K(R1) args: 0, res: 0, upd: 0;
       c4z9O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z9E_info" {
     block_c4z9E_info:
         const _c4z9E;
         const 1;
         const 30;
 },
 _c4z9K() //  [R1]
         { []
         }
     {offset
       c4z9K: // global
           _s4vW0::I64 = -I64[R1 + 7] & 15;
           if (_s4vW0::I64 != 0) goto u4zaI; else goto c4zaE;
       u4zaI: // global
           I64[Sp + 16] = _s4vW0::I64;
           Sp = Sp + 8;
           call _c4za6() args: 0, res: 0, upd: 0;
       c4zaE: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4z9K_info" {
     block_c4z9K_info:
         const _c4z9K;
         const 66;
         const 30;
 },
 _c4za6() //  []
         { []
         }
     {offset
       c4za6: // global
           Hp = Hp + 16;
           _s4vW0::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4zaB; else goto c4zaA;
       c4zaB: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4za5_info;
           R1 = _s4vW0::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4zaA: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           _s4vW1::I64 = %MO_UU_Conv_W16_W64(%MO_UU_Conv_W64_W16(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16((_s4vW1::I64 << _s4vW0::I64) | (_s4vW1::I64 >> 16 - _s4vW0::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4za5() //  [R1]
         { []
         }
     {offset
       c4za5: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4za6() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4za5_info" {
     block_c4za5_info:
         const _c4za5;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.980384104 UTC

[section ""data" . GHC.Int.$fBitsInt16_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt16_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt16_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt16_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zbs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zbw; else goto c4zbx;
       c4zbw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zbx: // global
           I64[Sp - 16] = block_c4zbp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zc6; else goto c4zbq;
       u4zc6: // global
           call _c4zbp(R1) args: 0, res: 0, upd: 0;
       c4zbq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$ccomplementBit_info" {
     GHC.Int.$fBitsInt16_$ccomplementBit_info:
         const GHC.Int.$fBitsInt16_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zbp() //  [R1]
         { []
         }
     {offset
       c4zbp: // global
           I64[Sp - 8] = block_c4zbv_info;
           _s4vWb::P64 = R1;
           _s4vWc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vWc::I64;
           P64[Sp + 8] = _s4vWb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zc5; else goto c4zbz;
       u4zc5: // global
           call _c4zbv(R1) args: 0, res: 0, upd: 0;
       c4zbz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zbp_info" {
     block_c4zbp_info:
         const _c4zbp;
         const 1;
         const 30;
 },
 _c4zbv() //  [R1]
         { []
         }
     {offset
       c4zbv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zbF; else goto c4zbE;
       c4zbF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zbE: // global
           _s4vWe::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vWe::I64, 64)) goto c4zc3; else goto c4zc4;
       c4zc3: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4vWe::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zc4: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zbv_info" {
     block_c4zbv_info:
         const _c4zbv;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:25.990420516 UTC

[section ""data" . GHC.Int.$fBitsInt16_$cclearBit_closure" {
     GHC.Int.$fBitsInt16_$cclearBit_closure:
         const GHC.Int.$fBitsInt16_$cclearBit_info;
 },
 GHC.Int.$fBitsInt16_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zcC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zcG; else goto c4zcH;
       c4zcG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zcH: // global
           I64[Sp - 16] = block_c4zcz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zdu; else goto c4zcA;
       u4zdu: // global
           call _c4zcz(R1) args: 0, res: 0, upd: 0;
       c4zcA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$cclearBit_info" {
     GHC.Int.$fBitsInt16_$cclearBit_info:
         const GHC.Int.$fBitsInt16_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zcz() //  [R1]
         { []
         }
     {offset
       c4zcz: // global
           I64[Sp] = block_c4zcF_info;
           _s4vWp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vWp::I64;
           if (R1 & 7 != 0) goto u4zdt; else goto c4zcJ;
       u4zdt: // global
           call _c4zcF(R1) args: 0, res: 0, upd: 0;
       c4zcJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zcz_info" {
     block_c4zcz_info:
         const _c4zcz;
         const 1;
         const 30;
 },
 _c4zcF() //  [R1]
         { []
         }
     {offset
       c4zcF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zcP; else goto c4zcO;
       c4zcP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zcO: // global
           _s4vWp::I64 = I64[Sp + 8];
           _s4vWr::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vWr::I64, 64)) goto c4zdg; else goto c4zds;
       c4zdg: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vWp::I64 & ~%MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4vWr::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zds: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vWp::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zcF_info" {
     block_c4zcF_info:
         const _c4zcF;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.000041859 UTC

[section ""data" . GHC.Int.$fBitsInt16_$csetBit_closure" {
     GHC.Int.$fBitsInt16_$csetBit_closure:
         const GHC.Int.$fBitsInt16_$csetBit_info;
 },
 GHC.Int.$fBitsInt16_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ze2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ze6; else goto c4ze7;
       c4ze6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt16_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ze7: // global
           I64[Sp - 16] = block_c4zdZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zeG; else goto c4ze0;
       u4zeG: // global
           call _c4zdZ(R1) args: 0, res: 0, upd: 0;
       c4ze0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$csetBit_info" {
     GHC.Int.$fBitsInt16_$csetBit_info:
         const GHC.Int.$fBitsInt16_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zdZ() //  [R1]
         { []
         }
     {offset
       c4zdZ: // global
           I64[Sp - 8] = block_c4ze5_info;
           _s4vWF::P64 = R1;
           _s4vWG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4vWG::I64;
           P64[Sp + 8] = _s4vWF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zeF; else goto c4ze9;
       u4zeF: // global
           call _c4ze5(R1) args: 0, res: 0, upd: 0;
       c4ze9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zdZ_info" {
     block_c4zdZ_info:
         const _c4zdZ;
         const 1;
         const 30;
 },
 _c4ze5() //  [R1]
         { []
         }
     {offset
       c4ze5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zef; else goto c4zee;
       c4zef: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zee: // global
           _s4vWI::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4vWI::I64, 64)) goto c4zeD; else goto c4zeE;
       c4zeD: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(1 << _s4vWI::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zeE: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ze5_info" {
     block_c4ze5_info:
         const _c4ze5;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.007627127 UTC

[section ""data" . GHC.Int.$fBitsInt16_$crotateL_closure" {
     GHC.Int.$fBitsInt16_$crotateL_closure:
         const GHC.Int.$fBitsInt16_$crotateL_info;
 },
 GHC.Int.$fBitsInt16_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zf9: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt16_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt16_$crotateL_info" {
     GHC.Int.$fBitsInt16_$crotateL_info:
         const GHC.Int.$fBitsInt16_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.011110858 UTC

[section ""data" . GHC.Int.$fBitsInt16_closure" {
     GHC.Int.$fBitsInt16_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt16_closure+1;
         const GHC.Int.$fBitsInt16_$c.&._closure+2;
         const GHC.Int.$fBitsInt16_$c.|._closure+2;
         const GHC.Int.$fBitsInt16_$cxor_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt16_$cshift_closure+2;
         const GHC.Int.$fBitsInt16_$crotate_closure+2;
         const GHC.Int.$fBitsInt3_closure+1;
         const GHC.Int.$fBitsInt16_$cbit_closure+1;
         const GHC.Int.$fBitsInt16_$csetBit_closure+2;
         const GHC.Int.$fBitsInt16_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt16_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt16_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt16_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt16_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt16_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt16_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt16_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt16_$crotateL_closure+2;
         const GHC.Int.$fBitsInt16_$crotateR_closure+2;
         const GHC.Int.$fBitsInt16_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.013175177 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt16_closure" {
     GHC.Int.$fFiniteBitsInt16_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt16_closure+1;
         const GHC.Int.$fBitsInt16_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.018678638 UTC

[section ""data" . GHC.Int.$fReadInt16_go_closure" {
     GHC.Int.$fReadInt16_go_closure:
         const GHC.Int.$fReadInt16_go_info;
 },
 sat_s4vX2_entry() //  [R1]
         { []
         }
     {offset
       c4zfB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zfC; else goto c4zfD;
       c4zfC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zfD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vX2_info" {
     sat_s4vX2_info:
         const sat_s4vX2_entry;
         const 1;
         const 16;
 },
 sat_s4vX0_entry() //  [R1]
         { []
         }
     {offset
       c4zfL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zfS; else goto c4zfT;
       c4zfS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zfT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4zfI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4zfX; else goto c4zfJ;
       u4zfX: // global
           call _c4zfI(R1) args: 0, res: 0, upd: 0;
       c4zfJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4vX0_info" {
     sat_s4vX0_info:
         const sat_s4vX0_entry;
         const 1;
         const 16;
 },
 _c4zfI() //  [R1]
         { []
         }
     {offset
       c4zfI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zfW; else goto c4zfV;
       c4zfW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4zfV: // global
           _s4vWZ::I64 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4vWZ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4zfI_info" {
     block_c4zfI_info:
         const _c4zfI;
         const 0;
         const 30;
 },
 GHC.Int.$fReadInt16_go_entry() //  [R2]
         { []
         }
     {offset
       c4zg2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zg3; else goto c4zg4;
       c4zg3: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zg4: // global
           I64[Sp - 8] = block_c4zfm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zge; else goto c4zfn;
       u4zge: // global
           call _c4zfm(R1) args: 0, res: 0, upd: 0;
       c4zfn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt16_go_info" {
     GHC.Int.$fReadInt16_go_info:
         const GHC.Int.$fReadInt16_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4zfm() //  [R1]
         { []
         }
     {offset
       c4zfm: // global
           if (R1 & 7 == 1) goto c4zfZ; else goto c4zg0;
       c4zfZ: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zg0: // global
           I64[Sp - 8] = block_c4zfs_info;
           _s4vWT::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4vWT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zgd; else goto c4zft;
       u4zgd: // global
           call _c4zfs(R1) args: 0, res: 0, upd: 0;
       c4zft: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zfm_info" {
     block_c4zfm_info:
         const _c4zfm;
         const 0;
         const 30;
 },
 _c4zfs() //  [R1]
         { []
         }
     {offset
       c4zfs: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4zgc; else goto c4zgb;
       c4zgc: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zgb: // global
           _s4vWV::P64 = P64[R1 + 7];
           _s4vWW::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4vX2_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4vX0_info;
           P64[Hp - 48] = _s4vWV::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4vWW::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zfs_info" {
     block_c4zfs_info:
         const _c4zfs;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.032149831 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadsPrec_closure" {
     GHC.Int.$fReadInt16_$creadsPrec_closure:
         const GHC.Int.$fReadInt16_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zh5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zh9; else goto c4zha;
       c4zh9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt16_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zha: // global
           I64[Sp - 16] = block_c4zh3_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4vX4::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4vX4::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt16_$creadsPrec_info" {
     GHC.Int.$fReadInt16_$creadsPrec_info:
         const GHC.Int.$fReadInt16_$creadsPrec_entry;
         const 0;
         const 1152921517491748878;
         const 8589934607;
         const S4wm5_srt+472;
 },
 _c4zh3() //  [R1]
         { []
         }
     {offset
       c4zh3: // global
           _s4vX4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4zh8_info;
           R3 = _s4vX4::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zh3_info" {
     block_c4zh3_info:
         const _c4zh3;
         const 1;
         const 30;
 },
 _c4zh8() //  [R1]
         { []
         }
     {offset
       c4zh8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt16_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zh8_info" {
     block_c4zh8_info:
         const _c4zh8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.04084185 UTC

[section ""data" . GHC.Int.$fReadInt3_closure" {
     GHC.Int.$fReadInt3_closure:
         const GHC.Int.$fReadInt3_info;
         const 0;
 },
 sat_s4vX9_entry() //  [R1, R2]
         { []
         }
     {offset
       c4zhE: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt16_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s4vX9_info" {
     sat_s4vX9_info:
         const sat_s4vX9_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S4wm5_srt+696;
 },
 GHC.Int.$fReadInt3_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zhK: // global
           _s4vX8::P64 = R3;
           _s4vX7::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4zhL; else goto c4zhM;
       c4zhM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zhO; else goto c4zhN;
       c4zhO: // global
           HpAlloc = 16;
           goto c4zhL;
       c4zhL: // global
           R3 = _s4vX8::P64;
           R2 = _s4vX7::P64;
           R1 = GHC.Int.$fReadInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zhN: // global
           I64[Hp - 8] = sat_s4vX9_info;
           P64[Hp] = _s4vX7::P64;
           I64[Sp - 8] = block_c4zhH_info;
           R3 = _s4vX8::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt3_info" {
     GHC.Int.$fReadInt3_info:
         const GHC.Int.$fReadInt3_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+696;
 },
 _c4zhH() //  [R1]
         { []
         }
     {offset
       c4zhH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zhR; else goto c4zhQ;
       c4zhR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zhQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zhH_info" {
     block_c4zhH_info:
         const _c4zhH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.048475901 UTC

[section ""data" . GHC.Int.$fReadInt2_closure" {
     GHC.Int.$fReadInt2_closure:
         const GHC.Int.$fReadInt2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Int.$fReadInt2_entry() //  [R1]
         { []
         }
     {offset
       c4zid: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4zie; else goto c4zif;
       c4zie: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zif: // global
           (_c4zia::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4zia::I64 == 0) goto c4zic; else goto c4zib;
       c4zic: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4zib: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4zia::I64;
           R2 = GHC.Int.$fReadInt3_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt2_info" {
     GHC.Int.$fReadInt2_info:
         const GHC.Int.$fReadInt2_entry;
         const 0;
         const 144115192370823189;
         const S4wm5_srt+504;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.052909435 UTC

[section ""data" . GHC.Int.$fReadInt16_$creadList_closure" {
     GHC.Int.$fReadInt16_$creadList_closure:
         const GHC.Int.$fReadInt16_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt16_$creadList_entry() //  [R2]
         { []
         }
     {offset
       c4ziw: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt2_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt16_$creadList_info" {
     GHC.Int.$fReadInt16_$creadList_info:
         const GHC.Int.$fReadInt16_$creadList_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S4wm5_srt+712;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.057182063 UTC

[section ""data" . GHC.Int.$fReadInt1_closure" {
     GHC.Int.$fReadInt1_closure:
         const GHC.Int.$fReadInt1_info;
         const 0;
 },
 GHC.Int.$fReadInt1_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ziK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ziL; else goto c4ziM;
       c4ziL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ziM: // global
           I64[Sp - 8] = block_c4ziH_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt16_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt1_info" {
     GHC.Int.$fReadInt1_info:
         const GHC.Int.$fReadInt1_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+720;
 },
 _c4ziH() //  [R1]
         { []
         }
     {offset
       c4ziH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ziP; else goto c4ziO;
       c4ziP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ziO: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ziH_info" {
     block_c4ziH_info:
         const _c4ziH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.063407522 UTC

[section ""data" . GHC.Int.$fReadInt16_closure" {
     GHC.Int.$fReadInt16_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt16_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt16_$creadList_closure+1;
         const GHC.Int.$fReadInt3_closure+2;
         const GHC.Int.$fReadInt1_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.067263767 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquot_closure" {
     GHC.Int.$fIntegralInt16_$cquot_closure:
         const GHC.Int.$fIntegralInt16_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zj9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zjd; else goto c4zje;
       c4zjd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zje: // global
           I64[Sp - 16] = block_c4zj6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zjP; else goto c4zj7;
       u4zjP: // global
           call _c4zj6(R1) args: 0, res: 0, upd: 0;
       c4zj7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$cquot_info" {
     GHC.Int.$fIntegralInt16_$cquot_info:
         const GHC.Int.$fIntegralInt16_$cquot_entry;
         const 0;
         const 144115200960757774;
         const 8589934607;
         const S4wm5_srt+536;
 },
 _c4zj6() //  [R1]
         { []
         }
     {offset
       c4zj6: // global
           I64[Sp] = block_c4zjc_info;
           _s4vXj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vXj::I64;
           if (R1 & 7 != 0) goto u4zjO; else goto c4zjg;
       u4zjO: // global
           call _c4zjc(R1) args: 0, res: 0, upd: 0;
       c4zjg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zj6_info" {
     block_c4zj6_info:
         const _c4zj6;
         const 1;
         const 12884901918;
         const S4wm5_srt+536;
 },
 _c4zjc() //  [R1]
         { []
         }
     {offset
       c4zjc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zjm; else goto c4zjl;
       c4zjm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zjl: // global
           _s4vXj::I64 = I64[Sp + 8];
           _s4vXm::I64 = I64[R1 + 7];
           if (_s4vXm::I64 != (-1)) goto u4zjN; else goto c4zjL;
       u4zjN: // global
           if (_s4vXm::I64 != 0) goto c4zjx; else goto c4zjM;
       c4zjx: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4vXj::I64,
                                                                            _s4vXm::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zjM: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zjL: // global
           if (_s4vXj::I64 == (-32768)) goto c4zjK; else goto c4zjJ;
       c4zjK: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zjJ: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Quot_W64(_s4vXj::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zjc_info" {
     block_c4zjc_info:
         const _c4zjc;
         const 65;
         const 12884901918;
         const S4wm5_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.078129817 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$crem_closure" {
     GHC.Int.$fIntegralInt16_$crem_closure:
         const GHC.Int.$fIntegralInt16_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zkl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zkp; else goto c4zkq;
       c4zkp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zkq: // global
           I64[Sp - 16] = block_c4zki_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zkM; else goto c4zkj;
       u4zkM: // global
           call _c4zki(R1) args: 0, res: 0, upd: 0;
       c4zkj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$crem_info" {
     GHC.Int.$fIntegralInt16_$crem_info:
         const GHC.Int.$fIntegralInt16_$crem_entry;
         const 0;
         const 288230380446679054;
         const 8589934607;
         const S4wm5_srt+536;
 },
 _c4zki() //  [R1]
         { []
         }
     {offset
       c4zki: // global
           I64[Sp] = block_c4zko_info;
           _s4vXx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vXx::I64;
           if (R1 & 7 != 0) goto u4zkL; else goto c4zks;
       u4zkL: // global
           call _c4zko(R1) args: 0, res: 0, upd: 0;
       c4zks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zki_info" {
     block_c4zki_info:
         const _c4zki;
         const 1;
         const 4294967326;
         const S4wm5_srt+536;
 },
 _c4zko() //  [R1]
         { []
         }
     {offset
       c4zko: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zky; else goto c4zkx;
       c4zky: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zkx: // global
           _s4vXA::I64 = I64[R1 + 7];
           if (_s4vXA::I64 != 0) goto c4zkJ; else goto c4zkK;
       c4zkJ: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4vXA::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zkK: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zko_info" {
     block_c4zko_info:
         const _c4zko;
         const 65;
         const 4294967326;
         const S4wm5_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.087617281 UTC

[section ""data" . GHC.Int.$w$cdiv_closure" {
     GHC.Int.$w$cdiv_closure:
         const GHC.Int.$w$cdiv_info;
         const 0;
 },
 GHC.Int.$w$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zlf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zlg; else goto c4zlh;
       c4zlg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zlh: // global
           if (R3 == (-1)) goto c4zld; else goto u4zlB;
       c4zld: // global
           if (R2 == (-32768)) goto c4zlA; else goto c4zly;
       c4zlA: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zly: // global
           I64[Sp - 8] = block_c4zls_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4zlB: // global
           if (R3 == 0) goto c4zle; else goto c4zlc;
       c4zle: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zlc: // global
           I64[Sp - 8] = block_c4zlj_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdiv_info" {
     GHC.Int.$w$cdiv_info:
         const GHC.Int.$w$cdiv_entry;
         const 0;
         const 576460765188325390;
         const 8589934604;
         const S4wm5_srt+536;
 },
 _c4zls() //  [R1]
         { []
         }
     {offset
       c4zls: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zls_info" {
     block_c4zls_info:
         const _c4zls;
         const 0;
         const 30;
 },
 _c4zlj() //  [R1]
         { []
         }
     {offset
       c4zlj: // global
           R1 = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zlj_info" {
     block_c4zlj_info:
         const _c4zlj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.096018256 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdiv_closure" {
     GHC.Int.$fIntegralInt16_$cdiv_closure:
         const GHC.Int.$fIntegralInt16_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zm0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zmd; else goto c4zme;
       c4zmd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zme: // global
           I64[Sp - 16] = block_c4zlX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zml; else goto c4zlY;
       u4zml: // global
           call _c4zlX(R1) args: 0, res: 0, upd: 0;
       c4zlY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$cdiv_info" {
     GHC.Int.$fIntegralInt16_$cdiv_info:
         const GHC.Int.$fIntegralInt16_$cdiv_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+752;
 },
 _c4zlX() //  [R1]
         { []
         }
     {offset
       c4zlX: // global
           I64[Sp] = block_c4zm3_info;
           _s4vXO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vXO::I64;
           if (R1 & 7 != 0) goto u4zmk; else goto c4zm4;
       u4zmk: // global
           call _c4zm3(R1) args: 0, res: 0, upd: 0;
       c4zm4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zlX_info" {
     block_c4zlX_info:
         const _c4zlX;
         const 1;
         const 4294967326;
         const S4wm5_srt+752;
 },
 _c4zm3() //  [R1]
         { []
         }
     {offset
       c4zm3: // global
           _s4vXO::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4zm8_info;
           R3 = I64[R1 + 7];
           R2 = _s4vXO::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zm3_info" {
     block_c4zm3_info:
         const _c4zm3;
         const 65;
         const 4294967326;
         const S4wm5_srt+752;
 },
 _c4zm8() //  [R1]
         { []
         }
     {offset
       c4zm8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zmj; else goto c4zmi;
       c4zmj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4zmi: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zm8_info" {
     block_c4zm8_info:
         const _c4zm8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.107375815 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cmod_closure" {
     GHC.Int.$fIntegralInt16_$cmod_closure:
         const GHC.Int.$fIntegralInt16_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cmod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zmO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zmS; else goto c4zmT;
       c4zmS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zmT: // global
           I64[Sp - 16] = block_c4zmL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4znh; else goto c4zmM;
       u4znh: // global
           call _c4zmL(R1) args: 0, res: 0, upd: 0;
       c4zmM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$cmod_info" {
     GHC.Int.$fIntegralInt16_$cmod_info:
         const GHC.Int.$fIntegralInt16_$cmod_entry;
         const 0;
         const 2305843013508661262;
         const 8589934607;
         const S4wm5_srt+536;
 },
 _c4zmL() //  [R1]
         { []
         }
     {offset
       c4zmL: // global
           I64[Sp] = block_c4zmR_info;
           _s4vXV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vXV::I64;
           if (R1 & 7 != 0) goto u4zng; else goto c4zmV;
       u4zng: // global
           call _c4zmR(R1) args: 0, res: 0, upd: 0;
       c4zmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zmL_info" {
     block_c4zmL_info:
         const _c4zmL;
         const 1;
         const 4294967326;
         const S4wm5_srt+536;
 },
 _c4zmR() //  [R1]
         { []
         }
     {offset
       c4zmR: // global
           _s4vXY::I64 = I64[R1 + 7];
           if (_s4vXY::I64 != 0) goto c4znb; else goto c4znf;
       c4znb: // global
           _s4vXV::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4zn2_info;
           R3 = _s4vXY::I64;
           R2 = _s4vXV::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4znf: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zmR_info" {
     block_c4zmR_info:
         const _c4zmR;
         const 65;
         const 4294967326;
         const S4wm5_srt+536;
 },
 _c4zn2() //  [R1]
         { []
         }
     {offset
       c4zn2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zne; else goto c4znd;
       c4zne: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4znd: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zn2_info" {
     block_c4zn2_info:
         const _c4zn2;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.115917076 UTC

[section ""data" . lvl7_r4kPy_closure" {
     lvl7_r4kPy_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt3_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.120132609 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cquotRem_closure" {
     GHC.Int.$fIntegralInt16_$cquotRem_closure:
         const GHC.Int.$fIntegralInt16_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4znN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4znR; else goto c4znS;
       c4znR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4znS: // global
           I64[Sp - 16] = block_c4znK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zox; else goto c4znL;
       u4zox: // global
           call _c4znK(R1) args: 0, res: 0, upd: 0;
       c4znL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$cquotRem_info" {
     GHC.Int.$fIntegralInt16_$cquotRem_info:
         const GHC.Int.$fIntegralInt16_$cquotRem_entry;
         const 0;
         const 13835058059577131022;
         const 8589934607;
         const S4wm5_srt+536;
 },
 _c4znK() //  [R1]
         { []
         }
     {offset
       c4znK: // global
           I64[Sp] = block_c4znQ_info;
           _s4vY5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vY5::I64;
           if (R1 & 7 != 0) goto u4zow; else goto c4znU;
       u4zow: // global
           call _c4znQ(R1) args: 0, res: 0, upd: 0;
       c4znU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4znK_info" {
     block_c4znK_info:
         const _c4znK;
         const 1;
         const 9223372041149743134;
         const S4wm5_srt+536;
 },
 _c4znQ() //  [R1]
         { []
         }
     {offset
       c4znQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4zo0; else goto c4znZ;
       c4zo0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4znZ: // global
           _s4vY5::I64 = I64[Sp + 8];
           _s4vY8::I64 = I64[R1 + 7];
           if (_s4vY8::I64 != (-1)) goto u4zov; else goto c4zot;
       u4zov: // global
           if (_s4vY8::I64 != 0) goto c4zod; else goto c4zou;
       c4zod: // global
           (_s4vYa::I64, _s4vYb::I64) = call MO_S_QuotRem W64(_s4vY5::I64, _s4vY8::I64);
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYb::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYa::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zou: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zot: // global
           if (_s4vY5::I64 == (-32768)) goto c4zos; else goto c4zor;
       c4zos: // global
           Hp = Hp - 56;
           R1 = lvl7_r4kPy_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zor: // global
           (_s4vYi::I64, _s4vYj::I64) = call MO_S_QuotRem W64(_s4vY5::I64, (-1));
           I64[Hp - 48] = GHC.Int.I16#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYj::I64));
           I64[Hp - 32] = GHC.Int.I16#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYi::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4znQ_info" {
     block_c4znQ_info:
         const _c4znQ;
         const 65;
         const 9223372041149743134;
         const S4wm5_srt+536;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.133385262 UTC

[section ""data" . GHC.Int.$w$cdivMod_closure" {
     GHC.Int.$w$cdivMod_closure:
         const GHC.Int.$w$cdivMod_info;
         const 0;
 },
 section ""relreadonly" . u4zrR_srtd" {
     u4zrR_srtd:
         const S4wm5_srt+536;
         const 33;
         const 4294967299;
 },
 GHC.Int.$w$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zph: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zpi; else goto c4zpj;
       c4zpi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zpj: // global
           if (R3 == 0) goto c4zpg; else goto c4zpf;
       c4zpg: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zpf: // global
           if (R3 == (-1)) goto c4zrM; else goto u4zrN;
       c4zrM: // global
           if (R2 == (-32768)) goto c4zrL; else goto u4zrO;
       c4zrL: // global
           R2 = GHC.Int.$fBitsInt3_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4zrO: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4zrQ;
       u4zrN: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4zrQ;
       u4zrQ: // global
           call _c4zpo() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdivMod_info" {
     GHC.Int.$w$cdivMod_info:
         const GHC.Int.$w$cdivMod_entry;
         const 0;
         const 18446744069414584334;
         const 8589934604;
         const u4zrR_srtd;
 },
 _c4zpo() //  []
         { []
         }
     {offset
       c4zpo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4zps; else goto c4zpr;
       c4zps: // global
           HpAlloc = 32;
           I64[Sp] = block_c4zpo_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4zpr: // global
           _s4vYp::I64 = I64[Sp + 8];
           _s4vYr::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4vYp::I64, 0)) goto c4zql; else goto c4zrC;
       c4zql: // global
           if (%MO_S_Ge_W64(_s4vYp::I64, 0)) goto c4zpI; else goto c4zqj;
       c4zpI: // global
           (_s4vYw::I64, _s4vYx::I64) = call MO_S_QuotRem W64(_s4vYp::I64, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYx::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYw::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zqj: // global
           if (%MO_S_Le_W64(_s4vYr::I64, 0)) goto c4zpW; else goto c4zqi;
       c4zpW: // global
           (_s4vYE::I64, _s4vYF::I64) = call MO_S_QuotRem W64(_s4vYp::I64, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYF::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYE::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zqi: // global
           (_s4vYM::I64, _s4vYN::I64) = call MO_S_QuotRem W64(_s4vYp::I64 + 1, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYN::I64 + _s4vYr::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYM::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zrC: // global
           if (%MO_S_Ge_W64(_s4vYr::I64, 0)) goto c4zrf; else goto c4zrB;
       c4zrf: // global
           if (%MO_S_Ge_W64(_s4vYp::I64, 0)) goto c4zqC; else goto c4zrd;
       c4zqC: // global
           (_s4vYY::I64, _s4vYZ::I64) = call MO_S_QuotRem W64(_s4vYp::I64, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYZ::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vYY::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zrd: // global
           if (%MO_S_Le_W64(_s4vYr::I64, 0)) goto c4zqQ; else goto c4zrc;
       c4zqQ: // global
           (_s4vZ6::I64, _s4vZ7::I64) = call MO_S_QuotRem W64(_s4vYp::I64, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZ7::I64));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZ6::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zrc: // global
           (_s4vZe::I64, _s4vZf::I64) = call MO_S_QuotRem W64(_s4vYp::I64 + 1, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZf::I64 + _s4vYr::I64 - 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZe::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4zrB: // global
           (_s4vZp::I64, _s4vZq::I64) = call MO_S_QuotRem W64(_s4vYp::I64 - 1, _s4vYr::I64);
           I64[Hp - 24] = GHC.Int.I16#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZq::I64 + _s4vYr::I64 + 1));
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = %MO_SS_Conv_W16_W64(%MO_SS_Conv_W64_W16(_s4vZp::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zpo_info" {
     block_c4zpo_info:
         const _c4zpo;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.14516116 UTC

[section ""data" . GHC.Int.$fIntegralInt16_$cdivMod_closure" {
     GHC.Int.$fIntegralInt16_$cdivMod_closure:
         const GHC.Int.$fIntegralInt16_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt16_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zt3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zte; else goto c4ztf;
       c4zte: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt16_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ztf: // global
           I64[Sp - 16] = block_c4zt0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ztm; else goto c4zt1;
       u4ztm: // global
           call _c4zt0(R1) args: 0, res: 0, upd: 0;
       c4zt1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt16_$cdivMod_info" {
     GHC.Int.$fIntegralInt16_$cdivMod_info:
         const GHC.Int.$fIntegralInt16_$cdivMod_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+792;
 },
 _c4zt0() //  [R1]
         { []
         }
     {offset
       c4zt0: // global
           I64[Sp] = block_c4zt6_info;
           _s4vZE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vZE::I64;
           if (R1 & 7 != 0) goto u4ztl; else goto c4zt7;
       u4ztl: // global
           call _c4zt6(R1) args: 0, res: 0, upd: 0;
       c4zt7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zt0_info" {
     block_c4zt0_info:
         const _c4zt0;
         const 1;
         const 4294967326;
         const S4wm5_srt+792;
 },
 _c4zt6() //  [R1]
         { []
         }
     {offset
       c4zt6: // global
           _s4vZE::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4ztb_info;
           R3 = I64[R1 + 7];
           R2 = _s4vZE::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zt6_info" {
     block_c4zt6_info:
         const _c4zt6;
         const 65;
         const 4294967326;
         const S4wm5_srt+792;
 },
 _c4ztb() //  [R1, R2]
         { []
         }
     {offset
       c4ztb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ztk; else goto c4ztj;
       c4ztk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ztj: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ztb_info" {
     block_c4ztb_info:
         const _c4ztb;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.155609392 UTC

[section ""data" . GHC.Int.$fRealInt16_$ctoRational_closure" {
     GHC.Int.$fRealInt16_$ctoRational_closure:
         const GHC.Int.$fRealInt16_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt16_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c4ztP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zu3; else goto c4zu4;
       c4zu3: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt16_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zu4: // global
           I64[Sp - 8] = block_c4ztM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zub; else goto c4ztN;
       u4zub: // global
           call _c4ztM(R1) args: 0, res: 0, upd: 0;
       c4ztN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fRealInt16_$ctoRational_info" {
     GHC.Int.$fRealInt16_$ctoRational_info:
         const GHC.Int.$fRealInt16_$ctoRational_entry;
         const 0;
         const 18014428574253070;
         const 4294967301;
         const S4wm5_srt+632;
 },
 _c4ztM() //  [R1]
         { []
         }
     {offset
       c4ztM: // global
           I64[Sp] = block_c4ztS_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ztM_info" {
     block_c4ztM_info:
         const _c4ztM;
         const 0;
         const 30064771102;
         const S4wm5_srt+632;
 },
 _c4ztS() //  [R1]
         { []
         }
     {offset
       c4ztS: // global
           I64[Sp] = block_c4ztW_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ztS_info" {
     block_c4ztS_info:
         const _c4ztS;
         const 0;
         const 30064771102;
         const S4wm5_srt+632;
 },
 _c4ztW() //  [R1]
         { []
         }
     {offset
       c4ztW: // global
           I64[Sp] = block_c4zu0_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ztW_info" {
     block_c4ztW_info:
         const _c4ztW;
         const 0;
         const 12884901918;
         const S4wm5_srt+640;
 },
 _c4zu0() //  [R1, R2]
         { []
         }
     {offset
       c4zu0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4zua; else goto c4zu9;
       c4zua: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4zu9: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zu0_info" {
     block_c4zu0_info:
         const _c4zu0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.166311748 UTC

[section ""data" . GHC.Int.$fRealInt16_closure" {
     GHC.Int.$fRealInt16_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt16_closure+1;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fRealInt16_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.168293297 UTC

[section ""data" . GHC.Int.$fIntegralInt16_closure" {
     GHC.Int.$fIntegralInt16_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt16_closure+1;
         const GHC.Int.$fEnumInt16_closure+1;
         const GHC.Int.$fIntegralInt16_$cquot_closure+2;
         const GHC.Int.$fIntegralInt16_$crem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt16_$cmod_closure+2;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt16_$ctoInteger_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.172706951 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt16_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt16_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt16_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zuJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zv0; else goto c4zv1;
       c4zv0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zv1: // global
           I64[Sp - 16] = block_c4zuG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zv8; else goto c4zuH;
       u4zv8: // global
           call _c4zuG(R1) args: 0, res: 0, upd: 0;
       c4zuH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$cunsafeIndex_info" {
     GHC.Int.$fIxInt16_$cunsafeIndex_info:
         const GHC.Int.$fIxInt16_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zuG() //  [R1]
         { []
         }
     {offset
       c4zuG: // global
           I64[Sp] = block_c4zuM_info;
           _s4vZV::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4vZV::P64;
           if (R1 & 7 != 0) goto u4zv7; else goto c4zuN;
       u4zv7: // global
           call _c4zuM(R1) args: 0, res: 0, upd: 0;
       c4zuN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zuG_info" {
     block_c4zuG_info:
         const _c4zuG;
         const 1;
         const 30;
 },
 _c4zuM() //  [R1]
         { []
         }
     {offset
       c4zuM: // global
           I64[Sp] = block_c4zuR_info;
           _s4vZY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4vZY::I64;
           if (R1 & 7 != 0) goto u4zv9; else goto c4zuS;
       u4zv9: // global
           call _c4zuR(R1) args: 0, res: 0, upd: 0;
       c4zuS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zuM_info" {
     block_c4zuM_info:
         const _c4zuM;
         const 1;
         const 30;
 },
 _c4zuR() //  [R1]
         { []
         }
     {offset
       c4zuR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zv6; else goto c4zv5;
       c4zv6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zv5: // global
           _s4w01::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w01::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zuR_info" {
     block_c4zuR_info:
         const _c4zuR;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.182225224 UTC

[section ""data" . GHC.Int.$fIxInt16_$crange_closure" {
     GHC.Int.$fIxInt16_$crange_closure:
         const GHC.Int.$fIxInt16_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$crange_entry() //  [R2]
         { []
         }
     {offset
       c4zvF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zvG; else goto c4zvH;
       c4zvG: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zvH: // global
           I64[Sp - 8] = block_c4zvC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zvL; else goto c4zvD;
       u4zvL: // global
           call _c4zvC(R1) args: 0, res: 0, upd: 0;
       c4zvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$crange_info" {
     GHC.Int.$fIxInt16_$crange_info:
         const GHC.Int.$fIxInt16_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+816;
 },
 _c4zvC() //  [R1]
         { []
         }
     {offset
       c4zvC: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt16_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zvC_info" {
     block_c4zvC_info:
         const _c4zvC;
         const 0;
         const 4294967326;
         const S4wm5_srt+824;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.189854696 UTC

[section ""data" . GHC.Int.$fIxInt16_$crangeSize_closure" {
     GHC.Int.$fIxInt16_$crangeSize_closure:
         const GHC.Int.$fIxInt16_$crangeSize_info;
 },
 GHC.Int.$fIxInt16_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4zw3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zwc; else goto c4zwd;
       c4zwc: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zwd: // global
           I64[Sp - 8] = block_c4zw0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zwC; else goto c4zw1;
       u4zwC: // global
           call _c4zw0(R1) args: 0, res: 0, upd: 0;
       c4zw1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$crangeSize_info" {
     GHC.Int.$fIxInt16_$crangeSize_info:
         const GHC.Int.$fIxInt16_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4zw0() //  [R1]
         { []
         }
     {offset
       c4zw0: // global
           I64[Sp - 8] = block_c4zw6_info;
           _s4w09::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w09::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zwB; else goto c4zw7;
       u4zwB: // global
           call _c4zw6(R1) args: 0, res: 0, upd: 0;
       c4zw7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zw0_info" {
     block_c4zw0_info:
         const _c4zw0;
         const 0;
         const 30;
 },
 _c4zw6() //  [R1]
         { []
         }
     {offset
       c4zw6: // global
           I64[Sp] = block_c4zwb_info;
           _s4w0b::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0b::I64;
           if (R1 & 7 != 0) goto u4zwD; else goto c4zwg;
       u4zwD: // global
           call _c4zwb(R1) args: 0, res: 0, upd: 0;
       c4zwg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zw6_info" {
     block_c4zw6_info:
         const _c4zw6;
         const 1;
         const 30;
 },
 _c4zwb() //  [R1]
         { []
         }
     {offset
       c4zwb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zwm; else goto c4zwl;
       c4zwm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zwl: // global
           _s4w0b::I64 = I64[Sp + 8];
           _s4w0d::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4w0b::I64,
                            _s4w0d::I64)) goto c4zwq; else goto c4zwA;
       c4zwq: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zwA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w0d::I64 - _s4w0b::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zwb_info" {
     block_c4zwb_info:
         const _c4zwb;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.200474628 UTC

[section ""data" . GHC.Int.$fIxInt16_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt16_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt16_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4zxb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zxv; else goto c4zxw;
       c4zxv: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zxw: // global
           I64[Sp - 8] = block_c4zx8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zxD; else goto c4zx9;
       u4zxD: // global
           call _c4zx8(R1) args: 0, res: 0, upd: 0;
       c4zx9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$cunsafeRangeSize_info" {
     GHC.Int.$fIxInt16_$cunsafeRangeSize_info:
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4zx8() //  [R1]
         { []
         }
     {offset
       c4zx8: // global
           I64[Sp - 8] = block_c4zxe_info;
           _s4w0j::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4w0j::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zxC; else goto c4zxf;
       u4zxC: // global
           call _c4zxe(R1) args: 0, res: 0, upd: 0;
       c4zxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zx8_info" {
     block_c4zx8_info:
         const _c4zx8;
         const 0;
         const 30;
 },
 _c4zxe() //  [R1]
         { []
         }
     {offset
       c4zxe: // global
           I64[Sp] = block_c4zxj_info;
           _s4w0m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0m::I64;
           if (R1 & 7 != 0) goto u4zxE; else goto c4zxk;
       u4zxE: // global
           call _c4zxj(R1) args: 0, res: 0, upd: 0;
       c4zxk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zxe_info" {
     block_c4zxe_info:
         const _c4zxe;
         const 1;
         const 30;
 },
 _c4zxj() //  [R1]
         { []
         }
     {offset
       c4zxj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zxB; else goto c4zxA;
       c4zxB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zxA: // global
           _s4w0q::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w0q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zxj_info" {
     block_c4zxj_info:
         const _c4zxj;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.212341136 UTC

[section ""data" . GHC.Int.$fIxInt16_$cindex_closure" {
     GHC.Int.$fIxInt16_$cindex_closure:
         const GHC.Int.$fIxInt16_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt16_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zyb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zyk; else goto c4zyl;
       c4zyk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt16_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zyl: // global
           I64[Sp - 16] = block_c4zy8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zyU; else goto c4zy9;
       u4zyU: // global
           call _c4zy8(R1) args: 0, res: 0, upd: 0;
       c4zy9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt16_$cindex_info" {
     GHC.Int.$fIxInt16_$cindex_info:
         const GHC.Int.$fIxInt16_$cindex_entry;
         const 0;
         const 2251804108652558;
         const 8589934607;
         const S4wm5_srt+680;
 },
 _c4zy8() //  [R1]
         { []
         }
     {offset
       c4zy8: // global
           I64[Sp - 8] = block_c4zye_info;
           _s4w0v::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w0v::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zyT; else goto c4zyf;
       u4zyT: // global
           call _c4zye(R1) args: 0, res: 0, upd: 0;
       c4zyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zy8_info" {
     block_c4zy8_info:
         const _c4zy8;
         const 1;
         const 4294967326;
         const S4wm5_srt+680;
 },
 _c4zye() //  [R1]
         { []
         }
     {offset
       c4zye: // global
           I64[Sp] = block_c4zyj_info;
           _s4w0x::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4w0x::I64;
           if (R1 & 7 != 0) goto u4zyV; else goto c4zyo;
       u4zyV: // global
           call _c4zyj(R1) args: 0, res: 0, upd: 0;
       c4zyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zye_info" {
     block_c4zye_info:
         const _c4zye;
         const 2;
         const 4294967326;
         const S4wm5_srt+680;
 },
 _c4zyj() //  [R1]
         { []
         }
     {offset
       c4zyj: // global
           _s4w0z::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4w0z::I64)) goto c4zyw; else goto c4zyA;
       c4zyw: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4zyA: // global
           I64[Sp] = block_c4zyz_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0z::I64;
           if (R1 & 7 != 0) goto u4zyW; else goto c4zyB;
       u4zyW: // global
           call _c4zyz(R1) args: 0, res: 0, upd: 0;
       c4zyB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zyj_info" {
     block_c4zyj_info:
         const _c4zyj;
         const 130;
         const 4294967326;
         const S4wm5_srt+680;
 },
 _c4zyz() //  [R1]
         { []
         }
     {offset
       c4zyz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zyH; else goto c4zyG;
       c4zyH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zyG: // global
           _s4w0z::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4w0z::I64,
                            I64[R1 + 7])) goto c4zyL; else goto c4zyS;
       c4zyL: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4zyS: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w0z::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zyz_info" {
     block_c4zyz_info:
         const _c4zyz;
         const 194;
         const 4294967326;
         const S4wm5_srt+680;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.222965111 UTC

[section ""data" . GHC.Int.$fIxInt16_closure" {
     GHC.Int.$fIxInt16_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt16_closure+1;
         const GHC.Int.$fIxInt16_$crange_closure+1;
         const GHC.Int.$fIxInt16_$cindex_closure+2;
         const GHC.Int.$fIxInt16_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt16_$cinRange_closure+2;
         const GHC.Int.$fIxInt16_$crangeSize_closure+1;
         const GHC.Int.$fIxInt16_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.226163939 UTC

[section ""data" . GHC.Int.eqInt32_closure" {
     GHC.Int.eqInt32_closure:
         const GHC.Int.eqInt32_info;
 },
 GHC.Int.eqInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zzA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zzE; else goto c4zzF;
       c4zzE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zzF: // global
           I64[Sp - 16] = block_c4zzx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zzO; else goto c4zzy;
       u4zzO: // global
           call _c4zzx(R1) args: 0, res: 0, upd: 0;
       c4zzy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.eqInt32_info" {
     GHC.Int.eqInt32_info:
         const GHC.Int.eqInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zzx() //  [R1]
         { []
         }
     {offset
       c4zzx: // global
           I64[Sp] = block_c4zzD_info;
           _s4w0I::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0I::I64;
           if (R1 & 7 != 0) goto u4zzN; else goto c4zzH;
       u4zzN: // global
           call _c4zzD(R1) args: 0, res: 0, upd: 0;
       c4zzH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zzx_info" {
     block_c4zzx_info:
         const _c4zzx;
         const 1;
         const 30;
 },
 _c4zzD() //  [R1]
         { []
         }
     {offset
       c4zzD: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zzD_info" {
     block_c4zzD_info:
         const _c4zzD;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.236991586 UTC

[section ""data" . GHC.Int.$fEqInt32_closure" {
     GHC.Int.$fEqInt32_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt32_closure+2;
         const GHC.Int.neInt32_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.240317367 UTC

[section ""data" . GHC.Int.gtInt32_closure" {
     GHC.Int.gtInt32_closure:
         const GHC.Int.gtInt32_info;
 },
 GHC.Int.gtInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zAh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zAl; else goto c4zAm;
       c4zAl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zAm: // global
           I64[Sp - 16] = block_c4zAe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zAv; else goto c4zAf;
       u4zAv: // global
           call _c4zAe(R1) args: 0, res: 0, upd: 0;
       c4zAf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.gtInt32_info" {
     GHC.Int.gtInt32_info:
         const GHC.Int.gtInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zAe() //  [R1]
         { []
         }
     {offset
       c4zAe: // global
           I64[Sp] = block_c4zAk_info;
           _s4w0P::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0P::I64;
           if (R1 & 7 != 0) goto u4zAu; else goto c4zAo;
       u4zAu: // global
           call _c4zAk(R1) args: 0, res: 0, upd: 0;
       c4zAo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zAe_info" {
     block_c4zAe_info:
         const _c4zAe;
         const 1;
         const 30;
 },
 _c4zAk() //  [R1]
         { []
         }
     {offset
       c4zAk: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zAk_info" {
     block_c4zAk_info:
         const _c4zAk;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.248647193 UTC

[section ""data" . GHC.Int.geInt32_closure" {
     GHC.Int.geInt32_closure:
         const GHC.Int.geInt32_info;
 },
 GHC.Int.geInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zAX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zB1; else goto c4zB2;
       c4zB1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zB2: // global
           I64[Sp - 16] = block_c4zAU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zBb; else goto c4zAV;
       u4zBb: // global
           call _c4zAU(R1) args: 0, res: 0, upd: 0;
       c4zAV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.geInt32_info" {
     GHC.Int.geInt32_info:
         const GHC.Int.geInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zAU() //  [R1]
         { []
         }
     {offset
       c4zAU: // global
           I64[Sp] = block_c4zB0_info;
           _s4w0W::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w0W::I64;
           if (R1 & 7 != 0) goto u4zBa; else goto c4zB4;
       u4zBa: // global
           call _c4zB0(R1) args: 0, res: 0, upd: 0;
       c4zB4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zAU_info" {
     block_c4zAU_info:
         const _c4zAU;
         const 1;
         const 30;
 },
 _c4zB0() //  [R1]
         { []
         }
     {offset
       c4zB0: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zB0_info" {
     block_c4zB0_info:
         const _c4zB0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.257948355 UTC

[section ""data" . GHC.Int.ltInt32_closure" {
     GHC.Int.ltInt32_closure:
         const GHC.Int.ltInt32_info;
 },
 GHC.Int.ltInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zBD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zBH; else goto c4zBI;
       c4zBH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zBI: // global
           I64[Sp - 16] = block_c4zBA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zBR; else goto c4zBB;
       u4zBR: // global
           call _c4zBA(R1) args: 0, res: 0, upd: 0;
       c4zBB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.ltInt32_info" {
     GHC.Int.ltInt32_info:
         const GHC.Int.ltInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zBA() //  [R1]
         { []
         }
     {offset
       c4zBA: // global
           I64[Sp] = block_c4zBG_info;
           _s4w13::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w13::I64;
           if (R1 & 7 != 0) goto u4zBQ; else goto c4zBK;
       u4zBQ: // global
           call _c4zBG(R1) args: 0, res: 0, upd: 0;
       c4zBK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zBA_info" {
     block_c4zBA_info:
         const _c4zBA;
         const 1;
         const 30;
 },
 _c4zBG() //  [R1]
         { []
         }
     {offset
       c4zBG: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zBG_info" {
     block_c4zBG_info:
         const _c4zBG;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.266295099 UTC

[section ""data" . GHC.Int.leInt32_closure" {
     GHC.Int.leInt32_closure:
         const GHC.Int.leInt32_info;
 },
 GHC.Int.leInt32_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zCj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zCn; else goto c4zCo;
       c4zCn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt32_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zCo: // global
           I64[Sp - 16] = block_c4zCg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zCx; else goto c4zCh;
       u4zCx: // global
           call _c4zCg(R1) args: 0, res: 0, upd: 0;
       c4zCh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.leInt32_info" {
     GHC.Int.leInt32_info:
         const GHC.Int.leInt32_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zCg() //  [R1]
         { []
         }
     {offset
       c4zCg: // global
           I64[Sp] = block_c4zCm_info;
           _s4w1a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w1a::I64;
           if (R1 & 7 != 0) goto u4zCw; else goto c4zCq;
       u4zCw: // global
           call _c4zCm(R1) args: 0, res: 0, upd: 0;
       c4zCq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zCg_info" {
     block_c4zCg_info:
         const _c4zCg;
         const 1;
         const 30;
 },
 _c4zCm() //  [R1]
         { []
         }
     {offset
       c4zCm: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zCm_info" {
     block_c4zCm_info:
         const _c4zCm;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.275447747 UTC

[section ""data" . GHC.Int.$fOrdInt32_$ccompare_closure" {
     GHC.Int.$fOrdInt32_$ccompare_closure:
         const GHC.Int.$fOrdInt32_$ccompare_info;
 },
 GHC.Int.$fOrdInt32_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zCZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zD3; else goto c4zD4;
       c4zD3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zD4: // global
           I64[Sp - 16] = block_c4zCW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zDn; else goto c4zCX;
       u4zDn: // global
           call _c4zCW(R1) args: 0, res: 0, upd: 0;
       c4zCX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt32_$ccompare_info" {
     GHC.Int.$fOrdInt32_$ccompare_info:
         const GHC.Int.$fOrdInt32_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zCW() //  [R1]
         { []
         }
     {offset
       c4zCW: // global
           I64[Sp] = block_c4zD2_info;
           _s4w1h::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w1h::I64;
           if (R1 & 7 != 0) goto u4zDm; else goto c4zD6;
       u4zDm: // global
           call _c4zD2(R1) args: 0, res: 0, upd: 0;
       c4zD6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zCW_info" {
     block_c4zCW_info:
         const _c4zCW;
         const 1;
         const 30;
 },
 _c4zD2() //  [R1]
         { []
         }
     {offset
       c4zD2: // global
           _s4w1h::I64 = I64[Sp + 8];
           _s4w1j::I64 = I64[R1 + 7];
           if (_s4w1h::I64 == _s4w1j::I64) goto c4zDl; else goto c4zDk;
       c4zDl: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zDk: // global
           if (%MO_S_Gt_W64(_s4w1h::I64,
                            _s4w1j::I64)) goto c4zDh; else goto c4zDi;
       c4zDh: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zDi: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zD2_info" {
     block_c4zD2_info:
         const _c4zD2;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.28447597 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmax_closure" {
     GHC.Int.$fOrdInt32_$cmax_closure:
         const GHC.Int.$fOrdInt32_$cmax_info;
 },
 GHC.Int.$fOrdInt32_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zDQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zDU; else goto c4zDV;
       c4zDU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zDV: // global
           I64[Sp - 16] = block_c4zDN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zE8; else goto c4zDO;
       u4zE8: // global
           call _c4zDN(R1) args: 0, res: 0, upd: 0;
       c4zDO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt32_$cmax_info" {
     GHC.Int.$fOrdInt32_$cmax_info:
         const GHC.Int.$fOrdInt32_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zDN() //  [R1]
         { []
         }
     {offset
       c4zDN: // global
           I64[Sp - 8] = block_c4zDT_info;
           _s4w1o::P64 = R1;
           _s4w1p::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w1p::I64;
           P64[Sp + 8] = _s4w1o::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zE7; else goto c4zDX;
       u4zE7: // global
           call _c4zDT(R1) args: 0, res: 0, upd: 0;
       c4zDX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zDN_info" {
     block_c4zDN_info:
         const _c4zDN;
         const 1;
         const 30;
 },
 _c4zDT() //  [R1]
         { []
         }
     {offset
       c4zDT: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4zE5; else goto c4zE6;
       c4zE5: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4zE6: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zDT_info" {
     block_c4zDT_info:
         const _c4zDT;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.292780991 UTC

[section ""data" . GHC.Int.$fOrdInt32_$cmin_closure" {
     GHC.Int.$fOrdInt32_$cmin_closure:
         const GHC.Int.$fOrdInt32_$cmin_info;
 },
 GHC.Int.$fOrdInt32_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zEA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zEE; else goto c4zEF;
       c4zEE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt32_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zEF: // global
           I64[Sp - 16] = block_c4zEx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zES; else goto c4zEy;
       u4zES: // global
           call _c4zEx(R1) args: 0, res: 0, upd: 0;
       c4zEy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt32_$cmin_info" {
     GHC.Int.$fOrdInt32_$cmin_info:
         const GHC.Int.$fOrdInt32_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zEx() //  [R1]
         { []
         }
     {offset
       c4zEx: // global
           I64[Sp - 8] = block_c4zED_info;
           _s4w1v::P64 = R1;
           _s4w1w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w1w::I64;
           P64[Sp + 8] = _s4w1v::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zER; else goto c4zEH;
       u4zER: // global
           call _c4zED(R1) args: 0, res: 0, upd: 0;
       c4zEH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zEx_info" {
     block_c4zEx_info:
         const _c4zEx;
         const 1;
         const 30;
 },
 _c4zED() //  [R1]
         { []
         }
     {offset
       c4zED: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4zEP; else goto c4zEQ;
       c4zEP: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4zEQ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zED_info" {
     block_c4zED_info:
         const _c4zED;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.300601737 UTC

[section ""data" . GHC.Int.$fOrdInt32_closure" {
     GHC.Int.$fOrdInt32_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fOrdInt32_$ccompare_closure+2;
         const GHC.Int.ltInt32_closure+2;
         const GHC.Int.leInt32_closure+2;
         const GHC.Int.gtInt32_closure+2;
         const GHC.Int.geInt32_closure+2;
         const GHC.Int.$fOrdInt32_$cmax_closure+2;
         const GHC.Int.$fOrdInt32_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.304485174 UTC

[section ""data" . GHC.Int.$fIxInt32_$cinRange_closure" {
     GHC.Int.$fIxInt32_$cinRange_closure:
         const GHC.Int.$fIxInt32_$cinRange_info;
 },
 GHC.Int.$fIxInt32_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zFl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zFu; else goto c4zFv;
       c4zFu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zFv: // global
           I64[Sp - 16] = block_c4zFi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zFS; else goto c4zFj;
       u4zFS: // global
           call _c4zFi(R1) args: 0, res: 0, upd: 0;
       c4zFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$cinRange_info" {
     GHC.Int.$fIxInt32_$cinRange_info:
         const GHC.Int.$fIxInt32_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zFi() //  [R1]
         { []
         }
     {offset
       c4zFi: // global
           I64[Sp - 8] = block_c4zFo_info;
           _s4w1E::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w1E::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zFR; else goto c4zFp;
       u4zFR: // global
           call _c4zFo(R1) args: 0, res: 0, upd: 0;
       c4zFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zFi_info" {
     block_c4zFi_info:
         const _c4zFi;
         const 1;
         const 30;
 },
 _c4zFo() //  [R1]
         { []
         }
     {offset
       c4zFo: // global
           I64[Sp] = block_c4zFt_info;
           _s4w1G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4w1G::I64;
           if (R1 & 7 != 0) goto u4zFT; else goto c4zFy;
       u4zFT: // global
           call _c4zFt(R1) args: 0, res: 0, upd: 0;
       c4zFy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zFo_info" {
     block_c4zFo_info:
         const _c4zFo;
         const 2;
         const 30;
 },
 _c4zFt() //  [R1]
         { []
         }
     {offset
       c4zFt: // global
           _s4w1I::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4w1I::I64)) goto c4zFG; else goto c4zFK;
       c4zFG: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zFK: // global
           _s4w1E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4zFJ_info;
           R1 = _s4w1E::P64;
           I64[Sp + 16] = _s4w1I::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4zFU; else goto c4zFL;
       u4zFU: // global
           call _c4zFJ(R1) args: 0, res: 0, upd: 0;
       c4zFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zFt_info" {
     block_c4zFt_info:
         const _c4zFt;
         const 130;
         const 30;
 },
 _c4zFJ() //  [R1]
         { []
         }
     {offset
       c4zFJ: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zFJ_info" {
     block_c4zFJ_info:
         const _c4zFJ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.315527994 UTC

[section ""data" . GHC.Int.$fNumInt3_closure" {
     GHC.Int.$fNumInt3_closure:
         const GHC.Int.I32#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.319116989 UTC

[section ""data" . GHC.Int.$fNumInt32_$csignum_closure" {
     GHC.Int.$fNumInt32_$csignum_closure:
         const GHC.Int.$fNumInt32_$csignum_info;
 },
 GHC.Int.$fNumInt32_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c4zGz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zGA; else goto c4zGB;
       c4zGA: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zGB: // global
           I64[Sp - 8] = block_c4zGw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zGP; else goto c4zGx;
       u4zGP: // global
           call _c4zGw(R1) args: 0, res: 0, upd: 0;
       c4zGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$csignum_info" {
     GHC.Int.$fNumInt32_$csignum_info:
         const GHC.Int.$fNumInt32_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4zGw() //  [R1]
         { []
         }
     {offset
       c4zGw: // global
           _s4w1P::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4w1P::I64, 0)) goto c4zGN; else goto c4zGO;
       c4zGN: // global
           if (_s4w1P::I64 == 0) goto c4zGL; else goto c4zGK;
       c4zGL: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zGK: // global
           R1 = GHC.Int.$fNumInt4_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zGO: // global
           R1 = GHC.Int.$fNumInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zGw_info" {
     block_c4zGw_info:
         const _c4zGw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.326596186 UTC

[section ""data" . GHC.Int.$fNumInt32_$cabs_closure" {
     GHC.Int.$fNumInt32_$cabs_closure:
         const GHC.Int.$fNumInt32_$cabs_info;
 },
 GHC.Int.$fNumInt32_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c4zHa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zHb; else goto c4zHc;
       c4zHb: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt32_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zHc: // global
           I64[Sp - 8] = block_c4zH7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zHv; else goto c4zH8;
       u4zHv: // global
           call _c4zH7(R1) args: 0, res: 0, upd: 0;
       c4zH8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt32_$cabs_info" {
     GHC.Int.$fNumInt32_$cabs_info:
         const GHC.Int.$fNumInt32_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4zH7() //  [R1]
         { []
         }
     {offset
       c4zH7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zHh; else goto c4zHg;
       c4zHh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zHg: // global
           _s4w1U::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w1U::I64, 0)) goto c4zHt; else goto c4zHu;
       c4zHt: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-_s4w1U::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zHu: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zH7_info" {
     block_c4zH7_info:
         const _c4zH7;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.332299038 UTC

[section ""data" . GHC.Int.$fNumInt32_closure" {
     GHC.Int.$fNumInt32_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt32_$c+_closure+2;
         const GHC.Int.$fNumInt32_$c-_closure+2;
         const GHC.Int.$fNumInt32_$c*_closure+2;
         const GHC.Int.$fNumInt32_$cnegate_closure+1;
         const GHC.Int.$fNumInt32_$cabs_closure+1;
         const GHC.Int.$fNumInt32_$csignum_closure+1;
         const GHC.Int.$fNumInt32_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.334469343 UTC

[section ""data" . GHC.Int.$fBitsInt5_closure" {
     GHC.Int.$fBitsInt5_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt4_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.336944897 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt32_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c4zHS: // global
           R1 = GHC.Int.$fBitsInt5_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cbitSizeMaybe_info" {
     GHC.Int.$fBitsInt32_$cbitSizeMaybe_info:
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.342272353 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cbit_closure" {
     GHC.Int.$fBitsInt32_$cbit_closure:
         const GHC.Int.$fBitsInt32_$cbit_info;
 },
 GHC.Int.$fBitsInt32_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c4zI7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zI8; else goto c4zI9;
       c4zI8: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zI9: // global
           I64[Sp - 8] = block_c4zI4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zIs; else goto c4zI5;
       u4zIs: // global
           call _c4zI4(R1) args: 0, res: 0, upd: 0;
       c4zI5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cbit_info" {
     GHC.Int.$fBitsInt32_$cbit_info:
         const GHC.Int.$fBitsInt32_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4zI4() //  [R1]
         { []
         }
     {offset
       c4zI4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zIe; else goto c4zId;
       c4zIe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zId: // global
           _s4w21::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w21::I64, 64)) goto c4zIq; else goto c4zIr;
       c4zIq: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4w21::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zIr: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zI4_info" {
     block_c4zI4_info:
         const _c4zI4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.349655495 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ctestBit_closure" {
     GHC.Int.$fBitsInt32_$ctestBit_closure:
         const GHC.Int.$fBitsInt32_$ctestBit_info;
 },
 GHC.Int.$fBitsInt32_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zIP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zIT; else goto c4zIU;
       c4zIT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zIU: // global
           I64[Sp - 16] = block_c4zIM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zJC; else goto c4zIN;
       u4zJC: // global
           call _c4zIM(R1) args: 0, res: 0, upd: 0;
       c4zIN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$ctestBit_info" {
     GHC.Int.$fBitsInt32_$ctestBit_info:
         const GHC.Int.$fBitsInt32_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zIM() //  [R1]
         { []
         }
     {offset
       c4zIM: // global
           I64[Sp] = block_c4zIS_info;
           _s4w28::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w28::I64;
           if (R1 & 7 != 0) goto u4zJB; else goto c4zIW;
       u4zJB: // global
           call _c4zIS(R1) args: 0, res: 0, upd: 0;
       c4zIW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zIM_info" {
     block_c4zIM_info:
         const _c4zIM;
         const 1;
         const 30;
 },
 _c4zIS() //  [R1]
         { []
         }
     {offset
       c4zIS: // global
           _s4w2a::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4w2a::I64, 64)) goto c4zJA; else goto c4zJz;
       c4zJz: // global
           if (I64[Sp + 8] & %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4w2a::I64)) == 0) goto c4zJA; else goto c4zJo;
       c4zJA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zJo: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zIS_info" {
     block_c4zIS_info:
         const _c4zIS;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.360715971 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateR_closure" {
     GHC.Int.$fBitsInt32_$crotateR_closure:
         const GHC.Int.$fBitsInt32_$crotateR_info;
 },
 GHC.Int.$fBitsInt32_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zK7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zKb; else goto c4zKc;
       c4zKb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zKc: // global
           I64[Sp - 16] = block_c4zK4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zLb; else goto c4zK5;
       u4zLb: // global
           call _c4zK4(R1) args: 0, res: 0, upd: 0;
       c4zK5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$crotateR_info" {
     GHC.Int.$fBitsInt32_$crotateR_info:
         const GHC.Int.$fBitsInt32_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zK4() //  [R1]
         { []
         }
     {offset
       c4zK4: // global
           I64[Sp - 8] = block_c4zKa_info;
           _s4w2k::P64 = R1;
           _s4w2l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w2l::I64;
           P64[Sp + 8] = _s4w2k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zLa; else goto c4zKe;
       u4zLa: // global
           call _c4zKa(R1) args: 0, res: 0, upd: 0;
       c4zKe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zK4_info" {
     block_c4zK4_info:
         const _c4zK4;
         const 1;
         const 30;
 },
 _c4zKa() //  [R1]
         { []
         }
     {offset
       c4zKa: // global
           _s4w2r::I64 = -I64[R1 + 7] & 31;
           if (_s4w2r::I64 != 0) goto u4zL8; else goto c4zL4;
       u4zL8: // global
           I64[Sp + 16] = _s4w2r::I64;
           Sp = Sp + 8;
           call _c4zKw() args: 0, res: 0, upd: 0;
       c4zL4: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zKa_info" {
     block_c4zKa_info:
         const _c4zKa;
         const 66;
         const 30;
 },
 _c4zKw() //  []
         { []
         }
     {offset
       c4zKw: // global
           Hp = Hp + 16;
           _s4w2r::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4zL1; else goto c4zL0;
       c4zL1: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4zKv_info;
           R1 = _s4w2r::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4zL0: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           _s4w2s::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp]));
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32((_s4w2s::I64 << _s4w2r::I64) | (_s4w2s::I64 >> 32 - _s4w2r::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4zKv() //  [R1]
         { []
         }
     {offset
       c4zKv: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4zKw() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4zKv_info" {
     block_c4zKv_info:
         const _c4zKv;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.372692569 UTC

[section ""data" . GHC.Int.$fBitsInt32_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt32_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt32_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt32_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zLS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zLW; else goto c4zLX;
       c4zLW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zLX: // global
           I64[Sp - 16] = block_c4zLP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zMw; else goto c4zLQ;
       u4zMw: // global
           call _c4zLP(R1) args: 0, res: 0, upd: 0;
       c4zLQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$ccomplementBit_info" {
     GHC.Int.$fBitsInt32_$ccomplementBit_info:
         const GHC.Int.$fBitsInt32_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zLP() //  [R1]
         { []
         }
     {offset
       c4zLP: // global
           I64[Sp - 8] = block_c4zLV_info;
           _s4w2C::P64 = R1;
           _s4w2D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w2D::I64;
           P64[Sp + 8] = _s4w2C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zMv; else goto c4zLZ;
       u4zMv: // global
           call _c4zLV(R1) args: 0, res: 0, upd: 0;
       c4zLZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zLP_info" {
     block_c4zLP_info:
         const _c4zLP;
         const 1;
         const 30;
 },
 _c4zLV() //  [R1]
         { []
         }
     {offset
       c4zLV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zM5; else goto c4zM4;
       c4zM5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zM4: // global
           _s4w2F::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w2F::I64, 64)) goto c4zMt; else goto c4zMu;
       c4zMt: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] ^ %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4w2F::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zMu: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zLV_info" {
     block_c4zLV_info:
         const _c4zLV;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.382798792 UTC

[section ""data" . GHC.Int.$fBitsInt32_$cclearBit_closure" {
     GHC.Int.$fBitsInt32_$cclearBit_closure:
         const GHC.Int.$fBitsInt32_$cclearBit_info;
 },
 GHC.Int.$fBitsInt32_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zN1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zN5; else goto c4zN6;
       c4zN5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zN6: // global
           I64[Sp - 16] = block_c4zMY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zNT; else goto c4zMZ;
       u4zNT: // global
           call _c4zMY(R1) args: 0, res: 0, upd: 0;
       c4zMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$cclearBit_info" {
     GHC.Int.$fBitsInt32_$cclearBit_info:
         const GHC.Int.$fBitsInt32_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zMY() //  [R1]
         { []
         }
     {offset
       c4zMY: // global
           I64[Sp] = block_c4zN4_info;
           _s4w2Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w2Q::I64;
           if (R1 & 7 != 0) goto u4zNS; else goto c4zN8;
       u4zNS: // global
           call _c4zN4(R1) args: 0, res: 0, upd: 0;
       c4zN8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zMY_info" {
     block_c4zMY_info:
         const _c4zMY;
         const 1;
         const 30;
 },
 _c4zN4() //  [R1]
         { []
         }
     {offset
       c4zN4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zNe; else goto c4zNd;
       c4zNe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zNd: // global
           _s4w2Q::I64 = I64[Sp + 8];
           _s4w2S::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w2S::I64, 64)) goto c4zNF; else goto c4zNR;
       c4zNF: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4w2Q::I64 & ~%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4w2S::I64));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zNR: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4w2Q::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zN4_info" {
     block_c4zN4_info:
         const _c4zN4;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.392638875 UTC

[section ""data" . GHC.Int.$fBitsInt32_$csetBit_closure" {
     GHC.Int.$fBitsInt32_$csetBit_closure:
         const GHC.Int.$fBitsInt32_$csetBit_info;
 },
 GHC.Int.$fBitsInt32_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zOq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zOu; else goto c4zOv;
       c4zOu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt32_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zOv: // global
           I64[Sp - 16] = block_c4zOn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zP4; else goto c4zOo;
       u4zP4: // global
           call _c4zOn(R1) args: 0, res: 0, upd: 0;
       c4zOo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$csetBit_info" {
     GHC.Int.$fBitsInt32_$csetBit_info:
         const GHC.Int.$fBitsInt32_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4zOn() //  [R1]
         { []
         }
     {offset
       c4zOn: // global
           I64[Sp - 8] = block_c4zOt_info;
           _s4w36::P64 = R1;
           _s4w37::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w37::I64;
           P64[Sp + 8] = _s4w36::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zP3; else goto c4zOx;
       u4zP3: // global
           call _c4zOt(R1) args: 0, res: 0, upd: 0;
       c4zOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zOn_info" {
     block_c4zOn_info:
         const _c4zOn;
         const 1;
         const 30;
 },
 _c4zOt() //  [R1]
         { []
         }
     {offset
       c4zOt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zOD; else goto c4zOC;
       c4zOD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zOC: // global
           _s4w39::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w39::I64, 64)) goto c4zP1; else goto c4zP2;
       c4zP1: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = I64[Sp + 8] | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(1 << _s4w39::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zP2: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zOt_info" {
     block_c4zOt_info:
         const _c4zOt;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.400587877 UTC

[section ""data" . GHC.Int.$fBitsInt32_$crotateL_closure" {
     GHC.Int.$fBitsInt32_$crotateL_closure:
         const GHC.Int.$fBitsInt32_$crotateL_info;
 },
 GHC.Int.$fBitsInt32_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zPw: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt32_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt32_$crotateL_info" {
     GHC.Int.$fBitsInt32_$crotateL_info:
         const GHC.Int.$fBitsInt32_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.404664796 UTC

[section ""data" . GHC.Int.$fBitsInt32_closure" {
     GHC.Int.$fBitsInt32_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt32_closure+1;
         const GHC.Int.$fBitsInt32_$c.&._closure+2;
         const GHC.Int.$fBitsInt32_$c.|._closure+2;
         const GHC.Int.$fBitsInt32_$cxor_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt32_$cshift_closure+2;
         const GHC.Int.$fBitsInt32_$crotate_closure+2;
         const GHC.Int.$fBitsInt6_closure+1;
         const GHC.Int.$fBitsInt32_$cbit_closure+1;
         const GHC.Int.$fBitsInt32_$csetBit_closure+2;
         const GHC.Int.$fBitsInt32_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt32_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt32_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt32_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt32_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt32_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt32_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt32_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt32_$crotateL_closure+2;
         const GHC.Int.$fBitsInt32_$crotateR_closure+2;
         const GHC.Int.$fBitsInt32_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.406758563 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt32_closure" {
     GHC.Int.$fFiniteBitsInt32_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt32_closure+1;
         const GHC.Int.$fBitsInt32_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.411541498 UTC

[section ""data" . GHC.Int.$fReadInt32_go_closure" {
     GHC.Int.$fReadInt32_go_closure:
         const GHC.Int.$fReadInt32_go_info;
 },
 sat_s4w3t_entry() //  [R1]
         { []
         }
     {offset
       c4zPY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zPZ; else goto c4zQ0;
       c4zPZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zQ0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4w3t_info" {
     sat_s4w3t_info:
         const sat_s4w3t_entry;
         const 1;
         const 16;
 },
 sat_s4w3r_entry() //  [R1]
         { []
         }
     {offset
       c4zQ8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zQf; else goto c4zQg;
       c4zQf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zQg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4zQ5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4zQk; else goto c4zQ6;
       u4zQk: // global
           call _c4zQ5(R1) args: 0, res: 0, upd: 0;
       c4zQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4w3r_info" {
     sat_s4w3r_info:
         const sat_s4w3r_entry;
         const 1;
         const 16;
 },
 _c4zQ5() //  [R1]
         { []
         }
     {offset
       c4zQ5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zQj; else goto c4zQi;
       c4zQj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4zQi: // global
           _s4w3q::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4w3q::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4zQ5_info" {
     block_c4zQ5_info:
         const _c4zQ5;
         const 0;
         const 30;
 },
 GHC.Int.$fReadInt32_go_entry() //  [R2]
         { []
         }
     {offset
       c4zQp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zQq; else goto c4zQr;
       c4zQq: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4zQr: // global
           I64[Sp - 8] = block_c4zPJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zQB; else goto c4zPK;
       u4zQB: // global
           call _c4zPJ(R1) args: 0, res: 0, upd: 0;
       c4zPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt32_go_info" {
     GHC.Int.$fReadInt32_go_info:
         const GHC.Int.$fReadInt32_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4zPJ() //  [R1]
         { []
         }
     {offset
       c4zPJ: // global
           if (R1 & 7 == 1) goto c4zQm; else goto c4zQn;
       c4zQm: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zQn: // global
           I64[Sp - 8] = block_c4zPP_info;
           _s4w3k::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4w3k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4zQA; else goto c4zPQ;
       u4zQA: // global
           call _c4zPP(R1) args: 0, res: 0, upd: 0;
       c4zPQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zPJ_info" {
     block_c4zPJ_info:
         const _c4zPJ;
         const 0;
         const 30;
 },
 _c4zPP() //  [R1]
         { []
         }
     {offset
       c4zPP: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4zQz; else goto c4zQy;
       c4zQz: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zQy: // global
           _s4w3m::P64 = P64[R1 + 7];
           _s4w3n::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4w3t_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4w3r_info;
           P64[Hp - 48] = _s4w3m::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4w3n::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zPP_info" {
     block_c4zPP_info:
         const _c4zPP;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.426478216 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadsPrec_closure" {
     GHC.Int.$fReadInt32_$creadsPrec_closure:
         const GHC.Int.$fReadInt32_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zRs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zRw; else goto c4zRx;
       c4zRw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt32_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zRx: // global
           I64[Sp - 16] = block_c4zRq_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4w3v::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4w3v::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt32_$creadsPrec_info" {
     GHC.Int.$fReadInt32_$creadsPrec_info:
         const GHC.Int.$fReadInt32_$creadsPrec_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const S4wm5_srt+840;
 },
 _c4zRq() //  [R1]
         { []
         }
     {offset
       c4zRq: // global
           _s4w3v::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4zRv_info;
           R3 = _s4w3v::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zRq_info" {
     block_c4zRq_info:
         const _c4zRq;
         const 1;
         const 30;
 },
 _c4zRv() //  [R1]
         { []
         }
     {offset
       c4zRv: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt32_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zRv_info" {
     block_c4zRv_info:
         const _c4zRv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.434385154 UTC

[section ""data" . GHC.Int.$fReadInt6_closure" {
     GHC.Int.$fReadInt6_closure:
         const GHC.Int.$fReadInt6_info;
         const 0;
 },
 sat_s4w3A_entry() //  [R1, R2]
         { []
         }
     {offset
       c4zS1: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt32_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s4w3A_info" {
     sat_s4w3A_info:
         const sat_s4w3A_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S4wm5_srt+840;
 },
 GHC.Int.$fReadInt6_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zS7: // global
           _s4w3z::P64 = R3;
           _s4w3y::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4zS8; else goto c4zS9;
       c4zS9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zSb; else goto c4zSa;
       c4zSb: // global
           HpAlloc = 16;
           goto c4zS8;
       c4zS8: // global
           R3 = _s4w3z::P64;
           R2 = _s4w3y::P64;
           R1 = GHC.Int.$fReadInt6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zSa: // global
           I64[Hp - 8] = sat_s4w3A_info;
           P64[Hp] = _s4w3y::P64;
           I64[Sp - 8] = block_c4zS4_info;
           R3 = _s4w3z::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt6_info" {
     GHC.Int.$fReadInt6_info:
         const GHC.Int.$fReadInt6_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const S4wm5_srt+840;
 },
 _c4zS4() //  [R1]
         { []
         }
     {offset
       c4zS4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zSe; else goto c4zSd;
       c4zSe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zSd: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zS4_info" {
     block_c4zS4_info:
         const _c4zS4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.442883813 UTC

[section ""data" . GHC.Int.$fReadInt5_closure" {
     GHC.Int.$fReadInt5_closure:
         const GHC.Int.$fReadInt5_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4zSD_srtd" {
     u4zSD_srtd:
         const S4wm5_srt+504;
         const 46;
         const 35184372088833;
 },
 GHC.Int.$fReadInt5_entry() //  [R1]
         { []
         }
     {offset
       c4zSA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4zSB; else goto c4zSC;
       c4zSB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4zSC: // global
           (_c4zSx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4zSx::I64 == 0) goto c4zSz; else goto c4zSy;
       c4zSz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4zSy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4zSx::I64;
           R2 = GHC.Int.$fReadInt6_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt5_info" {
     GHC.Int.$fReadInt5_info:
         const GHC.Int.$fReadInt5_entry;
         const 0;
         const 18446744069414584341;
         const u4zSD_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.448664807 UTC

[section ""data" . GHC.Int.$fReadInt32_$creadList_closure" {
     GHC.Int.$fReadInt32_$creadList_closure:
         const GHC.Int.$fReadInt32_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt32_$creadList_entry() //  [R2]
         { []
         }
     {offset
       c4zSV: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt5_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt32_$creadList_info" {
     GHC.Int.$fReadInt32_$creadList_info:
         const GHC.Int.$fReadInt32_$creadList_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S4wm5_srt+872;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.453586954 UTC

[section ""data" . GHC.Int.$fReadInt4_closure" {
     GHC.Int.$fReadInt4_closure:
         const GHC.Int.$fReadInt4_info;
         const 0;
 },
 GHC.Int.$fReadInt4_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zT9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zTa; else goto c4zTb;
       c4zTa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zTb: // global
           I64[Sp - 8] = block_c4zT6_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt32_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt4_info" {
     GHC.Int.$fReadInt4_info:
         const GHC.Int.$fReadInt4_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+880;
 },
 _c4zT6() //  [R1]
         { []
         }
     {offset
       c4zT6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zTe; else goto c4zTd;
       c4zTe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zTd: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zT6_info" {
     block_c4zT6_info:
         const _c4zT6;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.46217785 UTC

[section ""data" . GHC.Int.$fReadInt32_closure" {
     GHC.Int.$fReadInt32_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt32_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt32_$creadList_closure+1;
         const GHC.Int.$fReadInt6_closure+2;
         const GHC.Int.$fReadInt4_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.46670469 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquot_closure" {
     GHC.Int.$fIntegralInt32_$cquot_closure:
         const GHC.Int.$fIntegralInt32_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zTy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zTC; else goto c4zTD;
       c4zTC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zTD: // global
           I64[Sp - 16] = block_c4zTv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zUe; else goto c4zTw;
       u4zUe: // global
           call _c4zTv(R1) args: 0, res: 0, upd: 0;
       c4zTw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$cquot_info" {
     GHC.Int.$fIntegralInt32_$cquot_info:
         const GHC.Int.$fIntegralInt32_$cquot_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const S4wm5_srt+896;
 },
 _c4zTv() //  [R1]
         { []
         }
     {offset
       c4zTv: // global
           I64[Sp] = block_c4zTB_info;
           _s4w3K::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w3K::I64;
           if (R1 & 7 != 0) goto u4zUd; else goto c4zTF;
       u4zUd: // global
           call _c4zTB(R1) args: 0, res: 0, upd: 0;
       c4zTF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zTv_info" {
     block_c4zTv_info:
         const _c4zTv;
         const 1;
         const 12884901918;
         const S4wm5_srt+904;
 },
 _c4zTB() //  [R1]
         { []
         }
     {offset
       c4zTB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zTL; else goto c4zTK;
       c4zTL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zTK: // global
           _s4w3K::I64 = I64[Sp + 8];
           _s4w3N::I64 = I64[R1 + 7];
           if (_s4w3N::I64 != (-1)) goto u4zUc; else goto c4zUa;
       u4zUc: // global
           if (_s4w3N::I64 != 0) goto c4zTW; else goto c4zUb;
       c4zTW: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4w3K::I64,
                                                                            _s4w3N::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zUb: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zUa: // global
           if (_s4w3K::I64 == (-2147483648)) goto c4zU9; else goto c4zU8;
       c4zU9: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zU8: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Quot_W64(_s4w3K::I64,
                                                                            (-1))));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zTB_info" {
     block_c4zTB_info:
         const _c4zTB;
         const 65;
         const 12884901918;
         const S4wm5_srt+904;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.47709516 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$crem_closure" {
     GHC.Int.$fIntegralInt32_$crem_closure:
         const GHC.Int.$fIntegralInt32_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zUI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zUM; else goto c4zUN;
       c4zUM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zUN: // global
           I64[Sp - 16] = block_c4zUF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zVb; else goto c4zUG;
       u4zVb: // global
           call _c4zUF(R1) args: 0, res: 0, upd: 0;
       c4zUG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$crem_info" {
     GHC.Int.$fIntegralInt32_$crem_info:
         const GHC.Int.$fIntegralInt32_$crem_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+912;
 },
 _c4zUF() //  [R1]
         { []
         }
     {offset
       c4zUF: // global
           I64[Sp] = block_c4zUL_info;
           _s4w3Y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w3Y::I64;
           if (R1 & 7 != 0) goto u4zVa; else goto c4zUP;
       u4zVa: // global
           call _c4zUL(R1) args: 0, res: 0, upd: 0;
       c4zUP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zUF_info" {
     block_c4zUF_info:
         const _c4zUF;
         const 1;
         const 4294967326;
         const S4wm5_srt+912;
 },
 _c4zUL() //  [R1]
         { []
         }
     {offset
       c4zUL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zUV; else goto c4zUU;
       c4zUV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zUU: // global
           _s4w41::I64 = I64[R1 + 7];
           if (_s4w41::I64 != (-1)) goto u4zV9; else goto c4zV7;
       u4zV9: // global
           if (_s4w41::I64 != 0) goto c4zV6; else goto c4zV8;
       c4zV6: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(%MO_S_Rem_W64(I64[Sp + 8],
                                                                           _s4w41::I64)));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zV8: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zV7: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zUL_info" {
     block_c4zUL_info:
         const _c4zUL;
         const 65;
         const 4294967326;
         const S4wm5_srt+912;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.48635747 UTC

[section ""data" . GHC.Int.$w$cdiv1_closure" {
     GHC.Int.$w$cdiv1_closure:
         const GHC.Int.$w$cdiv1_info;
         const 0;
 },
 GHC.Int.$w$cdiv1_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zVE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4zVF; else goto c4zVG;
       c4zVF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdiv1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zVG: // global
           if (R3 == (-1)) goto c4zVC; else goto u4zW0;
       c4zVC: // global
           if (R2 == (-2147483648)) goto c4zVZ; else goto c4zVX;
       c4zVZ: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zVX: // global
           I64[Sp - 8] = block_c4zVR_info;
           R3 = (-1);
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       u4zW0: // global
           if (R3 == 0) goto c4zVD; else goto c4zVB;
       c4zVD: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zVB: // global
           I64[Sp - 8] = block_c4zVI_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdiv1_info" {
     GHC.Int.$w$cdiv1_info:
         const GHC.Int.$w$cdiv1_entry;
         const 0;
         const 47244640270;
         const 8589934604;
         const S4wm5_srt+904;
 },
 _c4zVR() //  [R1]
         { []
         }
     {offset
       c4zVR: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zVR_info" {
     block_c4zVR_info:
         const _c4zVR;
         const 0;
         const 30;
 },
 _c4zVI() //  [R1]
         { []
         }
     {offset
       c4zVI: // global
           R1 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zVI_info" {
     block_c4zVI_info:
         const _c4zVI;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.49594626 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdiv_closure" {
     GHC.Int.$fIntegralInt32_$cdiv_closure:
         const GHC.Int.$fIntegralInt32_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zWn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zWA; else goto c4zWB;
       c4zWA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zWB: // global
           I64[Sp - 16] = block_c4zWk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zWI; else goto c4zWl;
       u4zWI: // global
           call _c4zWk(R1) args: 0, res: 0, upd: 0;
       c4zWl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$cdiv_info" {
     GHC.Int.$fIntegralInt32_$cdiv_info:
         const GHC.Int.$fIntegralInt32_$cdiv_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+928;
 },
 _c4zWk() //  [R1]
         { []
         }
     {offset
       c4zWk: // global
           I64[Sp] = block_c4zWq_info;
           _s4w4f::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w4f::I64;
           if (R1 & 7 != 0) goto u4zWH; else goto c4zWr;
       u4zWH: // global
           call _c4zWq(R1) args: 0, res: 0, upd: 0;
       c4zWr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zWk_info" {
     block_c4zWk_info:
         const _c4zWk;
         const 1;
         const 4294967326;
         const S4wm5_srt+928;
 },
 _c4zWq() //  [R1]
         { []
         }
     {offset
       c4zWq: // global
           _s4w4f::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4zWv_info;
           R3 = I64[R1 + 7];
           R2 = _s4w4f::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zWq_info" {
     block_c4zWq_info:
         const _c4zWq;
         const 65;
         const 4294967326;
         const S4wm5_srt+928;
 },
 _c4zWv() //  [R1]
         { []
         }
     {offset
       c4zWv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zWG; else goto c4zWF;
       c4zWG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4zWF: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zWv_info" {
     block_c4zWv_info:
         const _c4zWv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.506414607 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cmod_closure" {
     GHC.Int.$fIntegralInt32_$cmod_closure:
         const GHC.Int.$fIntegralInt32_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cmod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zXb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zXf; else goto c4zXg;
       c4zXf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zXg: // global
           I64[Sp - 16] = block_c4zX8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zXG; else goto c4zX9;
       u4zXG: // global
           call _c4zX8(R1) args: 0, res: 0, upd: 0;
       c4zX9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$cmod_info" {
     GHC.Int.$fIntegralInt32_$cmod_info:
         const GHC.Int.$fIntegralInt32_$cmod_entry;
         const 0;
         const 73014444046;
         const 8589934607;
         const S4wm5_srt+912;
 },
 _c4zX8() //  [R1]
         { []
         }
     {offset
       c4zX8: // global
           I64[Sp] = block_c4zXe_info;
           _s4w4m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w4m::I64;
           if (R1 & 7 != 0) goto u4zXF; else goto c4zXi;
       u4zXF: // global
           call _c4zXe(R1) args: 0, res: 0, upd: 0;
       c4zXi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zX8_info" {
     block_c4zX8_info:
         const _c4zX8;
         const 1;
         const 4294967326;
         const S4wm5_srt+912;
 },
 _c4zXe() //  [R1]
         { []
         }
     {offset
       c4zXe: // global
           _s4w4p::I64 = I64[R1 + 7];
           if (_s4w4p::I64 != (-1)) goto u4zXE; else goto c4zXC;
       u4zXE: // global
           if (_s4w4p::I64 != 0) goto c4zXy; else goto c4zXD;
       c4zXy: // global
           _s4w4m::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4zXp_info;
           R3 = _s4w4p::I64;
           R2 = _s4w4m::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4zXD: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zXC: // global
           R1 = GHC.Int.$fBitsInt6_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zXe_info" {
     block_c4zXe_info:
         const _c4zXe;
         const 65;
         const 4294967326;
         const S4wm5_srt+912;
 },
 _c4zXp() //  [R1]
         { []
         }
     {offset
       c4zXp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4zXB; else goto c4zXA;
       c4zXB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4zXA: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R1));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zXp_info" {
     block_c4zXp_info:
         const _c4zXp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.516226359 UTC

[section ""data" . lvl8_r4kPz_closure" {
     lvl8_r4kPz_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt6_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.520425526 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cquotRem_closure" {
     GHC.Int.$fIntegralInt32_$cquotRem_closure:
         const GHC.Int.$fIntegralInt32_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zYc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4zYg; else goto c4zYh;
       c4zYg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zYh: // global
           I64[Sp - 16] = block_c4zY9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4zYW; else goto c4zYa;
       u4zYW: // global
           call _c4zY9(R1) args: 0, res: 0, upd: 0;
       c4zYa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$cquotRem_info" {
     GHC.Int.$fIntegralInt32_$cquotRem_info:
         const GHC.Int.$fIntegralInt32_$cquotRem_entry;
         const 0;
         const 416611827726;
         const 8589934607;
         const S4wm5_srt+912;
 },
 _c4zY9() //  [R1]
         { []
         }
     {offset
       c4zY9: // global
           I64[Sp] = block_c4zYf_info;
           _s4w4w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w4w::I64;
           if (R1 & 7 != 0) goto u4zYV; else goto c4zYj;
       u4zYV: // global
           call _c4zYf(R1) args: 0, res: 0, upd: 0;
       c4zYj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zY9_info" {
     block_c4zY9_info:
         const _c4zY9;
         const 1;
         const 279172874270;
         const S4wm5_srt+912;
 },
 _c4zYf() //  [R1]
         { []
         }
     {offset
       c4zYf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4zYp; else goto c4zYo;
       c4zYp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4zYo: // global
           _s4w4w::I64 = I64[Sp + 8];
           _s4w4z::I64 = I64[R1 + 7];
           if (_s4w4z::I64 != (-1)) goto u4zYU; else goto c4zYS;
       u4zYU: // global
           if (_s4w4z::I64 != 0) goto c4zYC; else goto c4zYT;
       c4zYC: // global
           (_s4w4B::I64, _s4w4C::I64) = call MO_S_QuotRem W64(_s4w4w::I64, _s4w4z::I64);
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4C::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4B::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zYT: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zYS: // global
           if (_s4w4w::I64 == (-2147483648)) goto c4zYR; else goto c4zYQ;
       c4zYR: // global
           Hp = Hp - 56;
           R1 = lvl8_r4kPz_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4zYQ: // global
           (_s4w4J::I64, _s4w4K::I64) = call MO_S_QuotRem W64(_s4w4w::I64, (-1));
           I64[Hp - 48] = GHC.Int.I32#_con_info;
           I64[Hp - 40] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4K::I64));
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4J::I64));
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zYf_info" {
     block_c4zYf_info:
         const _c4zYf;
         const 65;
         const 279172874270;
         const S4wm5_srt+912;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.533954619 UTC

[section ""data" . GHC.Int.$w$cdivMod1_closure" {
     GHC.Int.$w$cdivMod1_closure:
         const GHC.Int.$w$cdivMod1_info;
         const 0;
 },
 GHC.Int.$w$cdivMod1_entry() //  [R2, R3]
         { []
         }
     {offset
       c4zZC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4zZD; else goto c4zZE;
       c4zZD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4zZE: // global
           if (R3 == 0) goto c4zZB; else goto c4zZA;
       c4zZB: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4zZA: // global
           if (R3 == (-1)) goto c4A27; else goto u4A28;
       c4A27: // global
           if (R2 == (-2147483648)) goto c4A26; else goto u4A29;
       c4A26: // global
           R2 = GHC.Int.$fBitsInt6_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4A29: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4A2b;
       u4A28: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4A2b;
       u4A2b: // global
           call _c4zZJ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdivMod1_info" {
     GHC.Int.$w$cdivMod1_info:
         const GHC.Int.$w$cdivMod1_entry;
         const 0;
         const 1112396529678;
         const 8589934604;
         const S4wm5_srt+904;
 },
 _c4zZJ() //  []
         { []
         }
     {offset
       c4zZJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4zZN; else goto c4zZM;
       c4zZN: // global
           HpAlloc = 32;
           I64[Sp] = block_c4zZJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4zZM: // global
           _s4w4Q::I64 = I64[Sp + 8];
           _s4w4S::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4w4Q::I64, 0)) goto c4A0G; else goto c4A1X;
       c4A0G: // global
           if (%MO_S_Ge_W64(_s4w4Q::I64, 0)) goto c4A03; else goto c4A0E;
       c4A03: // global
           (_s4w4X::I64, _s4w4Y::I64) = call MO_S_QuotRem W64(_s4w4Q::I64, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4Y::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w4X::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A0E: // global
           if (%MO_S_Le_W64(_s4w4S::I64, 0)) goto c4A0h; else goto c4A0D;
       c4A0h: // global
           (_s4w55::I64, _s4w56::I64) = call MO_S_QuotRem W64(_s4w4Q::I64, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w56::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w55::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A0D: // global
           (_s4w5d::I64, _s4w5e::I64) = call MO_S_QuotRem W64(_s4w4Q::I64 + 1, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5e::I64 + _s4w4S::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5d::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A1X: // global
           if (%MO_S_Ge_W64(_s4w4S::I64, 0)) goto c4A1A; else goto c4A1W;
       c4A1A: // global
           if (%MO_S_Ge_W64(_s4w4Q::I64, 0)) goto c4A0X; else goto c4A1y;
       c4A0X: // global
           (_s4w5p::I64, _s4w5q::I64) = call MO_S_QuotRem W64(_s4w4Q::I64, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5q::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5p::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A1y: // global
           if (%MO_S_Le_W64(_s4w4S::I64, 0)) goto c4A1b; else goto c4A1x;
       c4A1b: // global
           (_s4w5x::I64, _s4w5y::I64) = call MO_S_QuotRem W64(_s4w4Q::I64, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5y::I64));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5x::I64));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A1x: // global
           (_s4w5F::I64, _s4w5G::I64) = call MO_S_QuotRem W64(_s4w4Q::I64 + 1, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5G::I64 + _s4w4S::I64 - 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5F::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4A1W: // global
           (_s4w5Q::I64, _s4w5R::I64) = call MO_S_QuotRem W64(_s4w4Q::I64 - 1, _s4w4S::I64);
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5R::I64 + _s4w4S::I64 + 1));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s4w5Q::I64 - 1));
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4zZJ_info" {
     block_c4zZJ_info:
         const _c4zZJ;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.54434471 UTC

[section ""data" . GHC.Int.$fIntegralInt32_$cdivMod_closure" {
     GHC.Int.$fIntegralInt32_$cdivMod_closure:
         const GHC.Int.$fIntegralInt32_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt32_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4A3e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4A3p; else goto c4A3q;
       c4A3p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt32_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4A3q: // global
           I64[Sp - 16] = block_c4A3b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4A3x; else goto c4A3c;
       u4A3x: // global
           call _c4A3b(R1) args: 0, res: 0, upd: 0;
       c4A3c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt32_$cdivMod_info" {
     GHC.Int.$fIntegralInt32_$cdivMod_info:
         const GHC.Int.$fIntegralInt32_$cdivMod_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+968;
 },
 _c4A3b() //  [R1]
         { []
         }
     {offset
       c4A3b: // global
           I64[Sp] = block_c4A3h_info;
           _s4w65::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w65::I64;
           if (R1 & 7 != 0) goto u4A3w; else goto c4A3i;
       u4A3w: // global
           call _c4A3h(R1) args: 0, res: 0, upd: 0;
       c4A3i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A3b_info" {
     block_c4A3b_info:
         const _c4A3b;
         const 1;
         const 4294967326;
         const S4wm5_srt+968;
 },
 _c4A3h() //  [R1]
         { []
         }
     {offset
       c4A3h: // global
           _s4w65::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4A3m_info;
           R3 = I64[R1 + 7];
           R2 = _s4w65::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A3h_info" {
     block_c4A3h_info:
         const _c4A3h;
         const 65;
         const 4294967326;
         const S4wm5_srt+968;
 },
 _c4A3m() //  [R1, R2]
         { []
         }
     {offset
       c4A3m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4A3v; else goto c4A3u;
       c4A3v: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4A3u: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A3m_info" {
     block_c4A3m_info:
         const _c4A3m;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.555962141 UTC

[section ""data" . GHC.Int.$fRealInt32_$ctoRational_closure" {
     GHC.Int.$fRealInt32_$ctoRational_closure:
         const GHC.Int.$fRealInt32_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt32_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c4A40: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4A4e; else goto c4A4f;
       c4A4e: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt32_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4A4f: // global
           I64[Sp - 8] = block_c4A3X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A4m; else goto c4A3Y;
       u4A4m: // global
           call _c4A3X(R1) args: 0, res: 0, upd: 0;
       c4A3Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fRealInt32_$ctoRational_info" {
     GHC.Int.$fRealInt32_$ctoRational_info:
         const GHC.Int.$fRealInt32_$ctoRational_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const S4wm5_srt+984;
 },
 _c4A3X() //  [R1]
         { []
         }
     {offset
       c4A3X: // global
           I64[Sp] = block_c4A43_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A3X_info" {
     block_c4A3X_info:
         const _c4A3X;
         const 0;
         const 30064771102;
         const S4wm5_srt+992;
 },
 _c4A43() //  [R1]
         { []
         }
     {offset
       c4A43: // global
           I64[Sp] = block_c4A47_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A43_info" {
     block_c4A43_info:
         const _c4A43;
         const 0;
         const 30064771102;
         const S4wm5_srt+992;
 },
 _c4A47() //  [R1]
         { []
         }
     {offset
       c4A47: // global
           I64[Sp] = block_c4A4b_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A47_info" {
     block_c4A47_info:
         const _c4A47;
         const 0;
         const 12884901918;
         const S4wm5_srt+992;
 },
 _c4A4b() //  [R1, R2]
         { []
         }
     {offset
       c4A4b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4A4l; else goto c4A4k;
       c4A4l: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4A4k: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A4b_info" {
     block_c4A4b_info:
         const _c4A4b;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.565748327 UTC

[section ""data" . GHC.Int.$fRealInt32_closure" {
     GHC.Int.$fRealInt32_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt32_closure+1;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fRealInt32_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.567598659 UTC

[section ""data" . GHC.Int.$fIntegralInt32_closure" {
     GHC.Int.$fIntegralInt32_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt32_closure+1;
         const GHC.Int.$fEnumInt32_closure+1;
         const GHC.Int.$fIntegralInt32_$cquot_closure+2;
         const GHC.Int.$fIntegralInt32_$crem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt32_$cmod_closure+2;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt32_$ctoInteger_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.570579231 UTC

[section ""data" . GHC.Int.$fIxInt32_$crange_closure" {
     GHC.Int.$fIxInt32_$crange_closure:
         const GHC.Int.$fIxInt32_$crange_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$crange_entry() //  [R2]
         { []
         }
     {offset
       c4A4U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4A4V; else goto c4A4W;
       c4A4V: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4A4W: // global
           I64[Sp - 8] = block_c4A4R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A50; else goto c4A4S;
       u4A50: // global
           call _c4A4R(R1) args: 0, res: 0, upd: 0;
       c4A4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$crange_info" {
     GHC.Int.$fIxInt32_$crange_info:
         const GHC.Int.$fIxInt32_$crange_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S4wm5_srt+1016;
 },
 _c4A4R() //  [R1]
         { []
         }
     {offset
       c4A4R: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt32_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A4R_info" {
     block_c4A4R_info:
         const _c4A4R;
         const 0;
         const 4294967326;
         const S4wm5_srt+1024;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.578237751 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt32_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt32_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt32_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4A5i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4A5z; else goto c4A5A;
       c4A5z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4A5A: // global
           I64[Sp - 16] = block_c4A5f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4A5H; else goto c4A5g;
       u4A5H: // global
           call _c4A5f(R1) args: 0, res: 0, upd: 0;
       c4A5g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$cunsafeIndex_info" {
     GHC.Int.$fIxInt32_$cunsafeIndex_info:
         const GHC.Int.$fIxInt32_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4A5f() //  [R1]
         { []
         }
     {offset
       c4A5f: // global
           I64[Sp] = block_c4A5l_info;
           _s4w6q::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4w6q::P64;
           if (R1 & 7 != 0) goto u4A5G; else goto c4A5m;
       u4A5G: // global
           call _c4A5l(R1) args: 0, res: 0, upd: 0;
       c4A5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A5f_info" {
     block_c4A5f_info:
         const _c4A5f;
         const 1;
         const 30;
 },
 _c4A5l() //  [R1]
         { []
         }
     {offset
       c4A5l: // global
           I64[Sp] = block_c4A5q_info;
           _s4w6t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w6t::I64;
           if (R1 & 7 != 0) goto u4A5I; else goto c4A5r;
       u4A5I: // global
           call _c4A5q(R1) args: 0, res: 0, upd: 0;
       c4A5r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A5l_info" {
     block_c4A5l_info:
         const _c4A5l;
         const 1;
         const 30;
 },
 _c4A5q() //  [R1]
         { []
         }
     {offset
       c4A5q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4A5F; else goto c4A5E;
       c4A5F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4A5E: // global
           _s4w6w::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w6w::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A5q_info" {
     block_c4A5q_info:
         const _c4A5q;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.588475483 UTC

[section ""data" . GHC.Int.$fIxInt32_$crangeSize_closure" {
     GHC.Int.$fIxInt32_$crangeSize_closure:
         const GHC.Int.$fIxInt32_$crangeSize_info;
 },
 GHC.Int.$fIxInt32_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4A6e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4A6n; else goto c4A6o;
       c4A6n: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4A6o: // global
           I64[Sp - 8] = block_c4A6b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A6N; else goto c4A6c;
       u4A6N: // global
           call _c4A6b(R1) args: 0, res: 0, upd: 0;
       c4A6c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$crangeSize_info" {
     GHC.Int.$fIxInt32_$crangeSize_info:
         const GHC.Int.$fIxInt32_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4A6b() //  [R1]
         { []
         }
     {offset
       c4A6b: // global
           I64[Sp - 8] = block_c4A6h_info;
           _s4w6A::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w6A::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A6M; else goto c4A6i;
       u4A6M: // global
           call _c4A6h(R1) args: 0, res: 0, upd: 0;
       c4A6i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A6b_info" {
     block_c4A6b_info:
         const _c4A6b;
         const 0;
         const 30;
 },
 _c4A6h() //  [R1]
         { []
         }
     {offset
       c4A6h: // global
           I64[Sp] = block_c4A6m_info;
           _s4w6C::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w6C::I64;
           if (R1 & 7 != 0) goto u4A6O; else goto c4A6r;
       u4A6O: // global
           call _c4A6m(R1) args: 0, res: 0, upd: 0;
       c4A6r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A6h_info" {
     block_c4A6h_info:
         const _c4A6h;
         const 1;
         const 30;
 },
 _c4A6m() //  [R1]
         { []
         }
     {offset
       c4A6m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4A6x; else goto c4A6w;
       c4A6x: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4A6w: // global
           _s4w6C::I64 = I64[Sp + 8];
           _s4w6E::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4w6C::I64,
                            _s4w6E::I64)) goto c4A6B; else goto c4A6L;
       c4A6B: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4A6L: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w6E::I64 - _s4w6C::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A6m_info" {
     block_c4A6m_info:
         const _c4A6m;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.600155927 UTC

[section ""data" . GHC.Int.$fIxInt32_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt32_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt32_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4A7m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4A7G; else goto c4A7H;
       c4A7G: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4A7H: // global
           I64[Sp - 8] = block_c4A7j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A7O; else goto c4A7k;
       u4A7O: // global
           call _c4A7j(R1) args: 0, res: 0, upd: 0;
       c4A7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$cunsafeRangeSize_info" {
     GHC.Int.$fIxInt32_$cunsafeRangeSize_info:
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4A7j() //  [R1]
         { []
         }
     {offset
       c4A7j: // global
           I64[Sp - 8] = block_c4A7p_info;
           _s4w6K::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4w6K::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A7N; else goto c4A7q;
       u4A7N: // global
           call _c4A7p(R1) args: 0, res: 0, upd: 0;
       c4A7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A7j_info" {
     block_c4A7j_info:
         const _c4A7j;
         const 0;
         const 30;
 },
 _c4A7p() //  [R1]
         { []
         }
     {offset
       c4A7p: // global
           I64[Sp] = block_c4A7u_info;
           _s4w6N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w6N::I64;
           if (R1 & 7 != 0) goto u4A7P; else goto c4A7v;
       u4A7P: // global
           call _c4A7u(R1) args: 0, res: 0, upd: 0;
       c4A7v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A7p_info" {
     block_c4A7p_info:
         const _c4A7p;
         const 1;
         const 30;
 },
 _c4A7u() //  [R1]
         { []
         }
     {offset
       c4A7u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4A7M; else goto c4A7L;
       c4A7M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4A7L: // global
           _s4w6R::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w6R::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A7u_info" {
     block_c4A7u_info:
         const _c4A7u;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.611611669 UTC

[section ""data" . GHC.Int.$fIxInt32_$cindex_closure" {
     GHC.Int.$fIxInt32_$cindex_closure:
         const GHC.Int.$fIxInt32_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt32_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4A8m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4A8v; else goto c4A8w;
       c4A8v: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt32_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4A8w: // global
           I64[Sp - 16] = block_c4A8j_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4A95; else goto c4A8k;
       u4A95: // global
           call _c4A8j(R1) args: 0, res: 0, upd: 0;
       c4A8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt32_$cindex_info" {
     GHC.Int.$fIxInt32_$cindex_info:
         const GHC.Int.$fIxInt32_$cindex_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+1032;
 },
 _c4A8j() //  [R1]
         { []
         }
     {offset
       c4A8j: // global
           I64[Sp - 8] = block_c4A8p_info;
           _s4w6W::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w6W::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4A94; else goto c4A8q;
       u4A94: // global
           call _c4A8p(R1) args: 0, res: 0, upd: 0;
       c4A8q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A8j_info" {
     block_c4A8j_info:
         const _c4A8j;
         const 1;
         const 4294967326;
         const S4wm5_srt+1040;
 },
 _c4A8p() //  [R1]
         { []
         }
     {offset
       c4A8p: // global
           I64[Sp] = block_c4A8u_info;
           _s4w6Y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4w6Y::I64;
           if (R1 & 7 != 0) goto u4A96; else goto c4A8z;
       u4A96: // global
           call _c4A8u(R1) args: 0, res: 0, upd: 0;
       c4A8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A8p_info" {
     block_c4A8p_info:
         const _c4A8p;
         const 2;
         const 4294967326;
         const S4wm5_srt+1040;
 },
 _c4A8u() //  [R1]
         { []
         }
     {offset
       c4A8u: // global
           _s4w70::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4w70::I64)) goto c4A8H; else goto c4A8L;
       c4A8H: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4A8L: // global
           I64[Sp] = block_c4A8K_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w70::I64;
           if (R1 & 7 != 0) goto u4A97; else goto c4A8M;
       u4A97: // global
           call _c4A8K(R1) args: 0, res: 0, upd: 0;
       c4A8M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A8u_info" {
     block_c4A8u_info:
         const _c4A8u;
         const 130;
         const 4294967326;
         const S4wm5_srt+1040;
 },
 _c4A8K() //  [R1]
         { []
         }
     {offset
       c4A8K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4A8S; else goto c4A8R;
       c4A8S: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4A8R: // global
           _s4w70::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4w70::I64,
                            I64[R1 + 7])) goto c4A8W; else goto c4A93;
       c4A8W: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4A93: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4w70::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A8K_info" {
     block_c4A8K_info:
         const _c4A8K;
         const 194;
         const 4294967326;
         const S4wm5_srt+1040;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.623310243 UTC

[section ""data" . GHC.Int.$fIxInt32_closure" {
     GHC.Int.$fIxInt32_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt32_closure+1;
         const GHC.Int.$fIxInt32_$crange_closure+1;
         const GHC.Int.$fIxInt32_$cindex_closure+2;
         const GHC.Int.$fIxInt32_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt32_$cinRange_closure+2;
         const GHC.Int.$fIxInt32_$crangeSize_closure+1;
         const GHC.Int.$fIxInt32_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.626953816 UTC

[section ""data" . GHC.Int.eqInt64_closure" {
     GHC.Int.eqInt64_closure:
         const GHC.Int.eqInt64_info;
 },
 GHC.Int.eqInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4A9L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4A9P; else goto c4A9Q;
       c4A9P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.eqInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4A9Q: // global
           I64[Sp - 16] = block_c4A9I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4A9Z; else goto c4A9J;
       u4A9Z: // global
           call _c4A9I(R1) args: 0, res: 0, upd: 0;
       c4A9J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.eqInt64_info" {
     GHC.Int.eqInt64_info:
         const GHC.Int.eqInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4A9I() //  [R1]
         { []
         }
     {offset
       c4A9I: // global
           I64[Sp] = block_c4A9O_info;
           _s4w79::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w79::I64;
           if (R1 & 7 != 0) goto u4A9Y; else goto c4A9S;
       u4A9Y: // global
           call _c4A9O(R1) args: 0, res: 0, upd: 0;
       c4A9S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A9I_info" {
     block_c4A9I_info:
         const _c4A9I;
         const 1;
         const 30;
 },
 _c4A9O() //  [R1]
         { []
         }
     {offset
       c4A9O: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4A9O_info" {
     block_c4A9O_info:
         const _c4A9O;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.633983393 UTC

[section ""data" . GHC.Int.$fEqInt64_closure" {
     GHC.Int.$fEqInt64_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Int.eqInt64_closure+2;
         const GHC.Int.neInt64_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.637861273 UTC

[section ""data" . GHC.Int.gtInt64_closure" {
     GHC.Int.gtInt64_closure:
         const GHC.Int.gtInt64_info;
 },
 GHC.Int.gtInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Aas: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Aaw; else goto c4Aax;
       c4Aaw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.gtInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Aax: // global
           I64[Sp - 16] = block_c4Aap_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AaG; else goto c4Aaq;
       u4AaG: // global
           call _c4Aap(R1) args: 0, res: 0, upd: 0;
       c4Aaq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.gtInt64_info" {
     GHC.Int.gtInt64_info:
         const GHC.Int.gtInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4Aap() //  [R1]
         { []
         }
     {offset
       c4Aap: // global
           I64[Sp] = block_c4Aav_info;
           _s4w7g::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w7g::I64;
           if (R1 & 7 != 0) goto u4AaF; else goto c4Aaz;
       u4AaF: // global
           call _c4Aav(R1) args: 0, res: 0, upd: 0;
       c4Aaz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Aap_info" {
     block_c4Aap_info:
         const _c4Aap;
         const 1;
         const 30;
 },
 _c4Aav() //  [R1]
         { []
         }
     {offset
       c4Aav: // global
           R1 = I64[(%MO_S_Gt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Aav_info" {
     block_c4Aav_info:
         const _c4Aav;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.645926563 UTC

[section ""data" . GHC.Int.geInt64_closure" {
     GHC.Int.geInt64_closure:
         const GHC.Int.geInt64_info;
 },
 GHC.Int.geInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Ab8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Abc; else goto c4Abd;
       c4Abc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.geInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Abd: // global
           I64[Sp - 16] = block_c4Ab5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Abm; else goto c4Ab6;
       u4Abm: // global
           call _c4Ab5(R1) args: 0, res: 0, upd: 0;
       c4Ab6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.geInt64_info" {
     GHC.Int.geInt64_info:
         const GHC.Int.geInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4Ab5() //  [R1]
         { []
         }
     {offset
       c4Ab5: // global
           I64[Sp] = block_c4Abb_info;
           _s4w7n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w7n::I64;
           if (R1 & 7 != 0) goto u4Abl; else goto c4Abf;
       u4Abl: // global
           call _c4Abb(R1) args: 0, res: 0, upd: 0;
       c4Abf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ab5_info" {
     block_c4Ab5_info:
         const _c4Ab5;
         const 1;
         const 30;
 },
 _c4Abb() //  [R1]
         { []
         }
     {offset
       c4Abb: // global
           R1 = I64[(%MO_S_Ge_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Abb_info" {
     block_c4Abb_info:
         const _c4Abb;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.654165976 UTC

[section ""data" . GHC.Int.ltInt64_closure" {
     GHC.Int.ltInt64_closure:
         const GHC.Int.ltInt64_info;
 },
 GHC.Int.ltInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AbO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AbS; else goto c4AbT;
       c4AbS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.ltInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AbT: // global
           I64[Sp - 16] = block_c4AbL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ac2; else goto c4AbM;
       u4Ac2: // global
           call _c4AbL(R1) args: 0, res: 0, upd: 0;
       c4AbM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.ltInt64_info" {
     GHC.Int.ltInt64_info:
         const GHC.Int.ltInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4AbL() //  [R1]
         { []
         }
     {offset
       c4AbL: // global
           I64[Sp] = block_c4AbR_info;
           _s4w7u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w7u::I64;
           if (R1 & 7 != 0) goto u4Ac1; else goto c4AbV;
       u4Ac1: // global
           call _c4AbR(R1) args: 0, res: 0, upd: 0;
       c4AbV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AbL_info" {
     block_c4AbL_info:
         const _c4AbL;
         const 1;
         const 30;
 },
 _c4AbR() //  [R1]
         { []
         }
     {offset
       c4AbR: // global
           R1 = I64[(%MO_S_Lt_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AbR_info" {
     block_c4AbR_info:
         const _c4AbR;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.662862874 UTC

[section ""data" . GHC.Int.leInt64_closure" {
     GHC.Int.leInt64_closure:
         const GHC.Int.leInt64_info;
 },
 GHC.Int.leInt64_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Acu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Acy; else goto c4Acz;
       c4Acy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.leInt64_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Acz: // global
           I64[Sp - 16] = block_c4Acr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AcI; else goto c4Acs;
       u4AcI: // global
           call _c4Acr(R1) args: 0, res: 0, upd: 0;
       c4Acs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.leInt64_info" {
     GHC.Int.leInt64_info:
         const GHC.Int.leInt64_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4Acr() //  [R1]
         { []
         }
     {offset
       c4Acr: // global
           I64[Sp] = block_c4Acx_info;
           _s4w7B::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w7B::I64;
           if (R1 & 7 != 0) goto u4AcH; else goto c4AcB;
       u4AcH: // global
           call _c4Acx(R1) args: 0, res: 0, upd: 0;
       c4AcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Acr_info" {
     block_c4Acr_info:
         const _c4Acr;
         const 1;
         const 30;
 },
 _c4Acx() //  [R1]
         { []
         }
     {offset
       c4Acx: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Acx_info" {
     block_c4Acx_info:
         const _c4Acx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.670704303 UTC

[section ""data" . GHC.Int.$fOrdInt64_$ccompare_closure" {
     GHC.Int.$fOrdInt64_$ccompare_closure:
         const GHC.Int.$fOrdInt64_$ccompare_info;
 },
 GHC.Int.$fOrdInt64_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Ada: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ade; else goto c4Adf;
       c4Ade: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Adf: // global
           I64[Sp - 16] = block_c4Ad7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ady; else goto c4Ad8;
       u4Ady: // global
           call _c4Ad7(R1) args: 0, res: 0, upd: 0;
       c4Ad8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt64_$ccompare_info" {
     GHC.Int.$fOrdInt64_$ccompare_info:
         const GHC.Int.$fOrdInt64_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4Ad7() //  [R1]
         { []
         }
     {offset
       c4Ad7: // global
           I64[Sp] = block_c4Add_info;
           _s4w7I::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w7I::I64;
           if (R1 & 7 != 0) goto u4Adx; else goto c4Adh;
       u4Adx: // global
           call _c4Add(R1) args: 0, res: 0, upd: 0;
       c4Adh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ad7_info" {
     block_c4Ad7_info:
         const _c4Ad7;
         const 1;
         const 30;
 },
 _c4Add() //  [R1]
         { []
         }
     {offset
       c4Add: // global
           _s4w7I::I64 = I64[Sp + 8];
           _s4w7K::I64 = I64[R1 + 7];
           if (_s4w7I::I64 == _s4w7K::I64) goto c4Adw; else goto c4Adv;
       c4Adw: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Adv: // global
           if (%MO_S_Gt_W64(_s4w7I::I64,
                            _s4w7K::I64)) goto c4Ads; else goto c4Adt;
       c4Ads: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Adt: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Add_info" {
     block_c4Add_info:
         const _c4Add;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.680280353 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmax_closure" {
     GHC.Int.$fOrdInt64_$cmax_closure:
         const GHC.Int.$fOrdInt64_$cmax_info;
 },
 GHC.Int.$fOrdInt64_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Ae1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Ae5; else goto c4Ae6;
       c4Ae5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ae6: // global
           I64[Sp - 16] = block_c4AdY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Aej; else goto c4AdZ;
       u4Aej: // global
           call _c4AdY(R1) args: 0, res: 0, upd: 0;
       c4AdZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt64_$cmax_info" {
     GHC.Int.$fOrdInt64_$cmax_info:
         const GHC.Int.$fOrdInt64_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4AdY() //  [R1]
         { []
         }
     {offset
       c4AdY: // global
           I64[Sp - 8] = block_c4Ae4_info;
           _s4w7P::P64 = R1;
           _s4w7Q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w7Q::I64;
           P64[Sp + 8] = _s4w7P::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Aei; else goto c4Ae8;
       u4Aei: // global
           call _c4Ae4(R1) args: 0, res: 0, upd: 0;
       c4Ae8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AdY_info" {
     block_c4AdY_info:
         const _c4AdY;
         const 1;
         const 30;
 },
 _c4Ae4() //  [R1]
         { []
         }
     {offset
       c4Ae4: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4Aeg; else goto c4Aeh;
       c4Aeg: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4Aeh: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ae4_info" {
     block_c4Ae4_info:
         const _c4Ae4;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.688450693 UTC

[section ""data" . GHC.Int.$fOrdInt64_$cmin_closure" {
     GHC.Int.$fOrdInt64_$cmin_closure:
         const GHC.Int.$fOrdInt64_$cmin_info;
 },
 GHC.Int.$fOrdInt64_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AeL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4AeP; else goto c4AeQ;
       c4AeP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fOrdInt64_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AeQ: // global
           I64[Sp - 16] = block_c4AeI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Af3; else goto c4AeJ;
       u4Af3: // global
           call _c4AeI(R1) args: 0, res: 0, upd: 0;
       c4AeJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fOrdInt64_$cmin_info" {
     GHC.Int.$fOrdInt64_$cmin_info:
         const GHC.Int.$fOrdInt64_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4AeI() //  [R1]
         { []
         }
     {offset
       c4AeI: // global
           I64[Sp - 8] = block_c4AeO_info;
           _s4w7W::P64 = R1;
           _s4w7X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w7X::I64;
           P64[Sp + 8] = _s4w7W::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Af2; else goto c4AeS;
       u4Af2: // global
           call _c4AeO(R1) args: 0, res: 0, upd: 0;
       c4AeS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AeI_info" {
     block_c4AeI_info:
         const _c4AeI;
         const 1;
         const 30;
 },
 _c4AeO() //  [R1]
         { []
         }
     {offset
       c4AeO: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto c4Af0; else goto c4Af1;
       c4Af0: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4Af1: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AeO_info" {
     block_c4AeO_info:
         const _c4AeO;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.69563023 UTC

[section ""data" . GHC.Int.$fOrdInt64_closure" {
     GHC.Int.$fOrdInt64_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fOrdInt64_$ccompare_closure+2;
         const GHC.Int.ltInt64_closure+2;
         const GHC.Int.leInt64_closure+2;
         const GHC.Int.gtInt64_closure+2;
         const GHC.Int.geInt64_closure+2;
         const GHC.Int.$fOrdInt64_$cmax_closure+2;
         const GHC.Int.$fOrdInt64_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.700201634 UTC

[section ""data" . GHC.Int.$fIxInt64_$cinRange_closure" {
     GHC.Int.$fIxInt64_$cinRange_closure:
         const GHC.Int.$fIxInt64_$cinRange_info;
 },
 GHC.Int.$fIxInt64_$cinRange_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Afw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4AfF; else goto c4AfG;
       c4AfF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cinRange_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AfG: // global
           I64[Sp - 16] = block_c4Aft_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ag3; else goto c4Afu;
       u4Ag3: // global
           call _c4Aft(R1) args: 0, res: 0, upd: 0;
       c4Afu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$cinRange_info" {
     GHC.Int.$fIxInt64_$cinRange_info:
         const GHC.Int.$fIxInt64_$cinRange_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4Aft() //  [R1]
         { []
         }
     {offset
       c4Aft: // global
           I64[Sp - 8] = block_c4Afz_info;
           _s4w85::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4w85::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Ag2; else goto c4AfA;
       u4Ag2: // global
           call _c4Afz(R1) args: 0, res: 0, upd: 0;
       c4AfA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Aft_info" {
     block_c4Aft_info:
         const _c4Aft;
         const 1;
         const 30;
 },
 _c4Afz() //  [R1]
         { []
         }
     {offset
       c4Afz: // global
           I64[Sp] = block_c4AfE_info;
           _s4w87::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4w87::I64;
           if (R1 & 7 != 0) goto u4Ag4; else goto c4AfJ;
       u4Ag4: // global
           call _c4AfE(R1) args: 0, res: 0, upd: 0;
       c4AfJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Afz_info" {
     block_c4Afz_info:
         const _c4Afz;
         const 2;
         const 30;
 },
 _c4AfE() //  [R1]
         { []
         }
     {offset
       c4AfE: // global
           _s4w89::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4w89::I64)) goto c4AfR; else goto c4AfV;
       c4AfR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AfV: // global
           _s4w85::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4AfU_info;
           R1 = _s4w85::P64;
           I64[Sp + 16] = _s4w89::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Ag5; else goto c4AfW;
       u4Ag5: // global
           call _c4AfU(R1) args: 0, res: 0, upd: 0;
       c4AfW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AfE_info" {
     block_c4AfE_info:
         const _c4AfE;
         const 130;
         const 30;
 },
 _c4AfU() //  [R1]
         { []
         }
     {offset
       c4AfU: // global
           R1 = I64[(%MO_S_Le_W64(I64[Sp + 8],
                                  I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AfU_info" {
     block_c4AfU_info:
         const _c4AfU;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.710820052 UTC

[section ""data" . GHC.Int.$fNumInt5_closure" {
     GHC.Int.$fNumInt5_closure:
         const GHC.Int.I64#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.713736559 UTC

[section ""data" . GHC.Int.$fNumInt64_$csignum_closure" {
     GHC.Int.$fNumInt64_$csignum_closure:
         const GHC.Int.$fNumInt64_$csignum_info;
 },
 GHC.Int.$fNumInt64_$csignum_entry() //  [R2]
         { []
         }
     {offset
       c4AgK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4AgL; else goto c4AgM;
       c4AgL: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AgM: // global
           I64[Sp - 8] = block_c4AgH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Ah0; else goto c4AgI;
       u4Ah0: // global
           call _c4AgH(R1) args: 0, res: 0, upd: 0;
       c4AgI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$csignum_info" {
     GHC.Int.$fNumInt64_$csignum_info:
         const GHC.Int.$fNumInt64_$csignum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4AgH() //  [R1]
         { []
         }
     {offset
       c4AgH: // global
           _s4w8g::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s4w8g::I64, 0)) goto c4AgY; else goto c4AgZ;
       c4AgY: // global
           if (_s4w8g::I64 == 0) goto c4AgW; else goto c4AgV;
       c4AgW: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AgV: // global
           R1 = GHC.Int.$fNumInt6_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AgZ: // global
           R1 = GHC.Int.$fNumInt5_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AgH_info" {
     block_c4AgH_info:
         const _c4AgH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.721084447 UTC

[section ""data" . GHC.Int.$fNumInt64_$cabs_closure" {
     GHC.Int.$fNumInt64_$cabs_closure:
         const GHC.Int.$fNumInt64_$cabs_info;
 },
 GHC.Int.$fNumInt64_$cabs_entry() //  [R2]
         { []
         }
     {offset
       c4Ahl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Ahm; else goto c4Ahn;
       c4Ahm: // global
           R2 = R2;
           R1 = GHC.Int.$fNumInt64_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Ahn: // global
           I64[Sp - 8] = block_c4Ahi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AhD; else goto c4Ahj;
       u4AhD: // global
           call _c4Ahi(R1) args: 0, res: 0, upd: 0;
       c4Ahj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fNumInt64_$cabs_info" {
     GHC.Int.$fNumInt64_$cabs_info:
         const GHC.Int.$fNumInt64_$cabs_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4Ahi() //  [R1]
         { []
         }
     {offset
       c4Ahi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ahs; else goto c4Ahr;
       c4Ahs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Ahr: // global
           _s4w8l::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w8l::I64, 0)) goto c4AhB; else goto c4AhC;
       c4AhB: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = -_s4w8l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AhC: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ahi_info" {
     block_c4Ahi_info:
         const _c4Ahi;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.727073624 UTC

[section ""data" . GHC.Int.$fNumInt64_closure" {
     GHC.Int.$fNumInt64_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Int.$fNumInt64_$c+_closure+2;
         const GHC.Int.$fNumInt64_$c-_closure+2;
         const GHC.Int.$fNumInt64_$c*_closure+2;
         const GHC.Int.$fNumInt64_$cnegate_closure+1;
         const GHC.Int.$fNumInt64_$cabs_closure+1;
         const GHC.Int.$fNumInt64_$csignum_closure+1;
         const GHC.Int.$fNumInt64_$cfromInteger_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.728850268 UTC

[section ""data" . GHC.Int.$fBitsInt9_closure" {
     GHC.Int.$fBitsInt9_closure:
         const GHC.Base.Just_con_info;
         const GHC.Int.$fBitsInt7_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.73107706 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure" {
     GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure:
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_info;
 },
 GHC.Int.$fBitsInt64_$cbitSizeMaybe_entry() //  []
         { []
         }
     {offset
       c4AhZ: // global
           R1 = GHC.Int.$fBitsInt9_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cbitSizeMaybe_info" {
     GHC.Int.$fBitsInt64_$cbitSizeMaybe_info:
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.735582025 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cbit_closure" {
     GHC.Int.$fBitsInt64_$cbit_closure:
         const GHC.Int.$fBitsInt64_$cbit_info;
 },
 GHC.Int.$fBitsInt64_$cbit_entry() //  [R2]
         { []
         }
     {offset
       c4Aie: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Aif; else goto c4Aig;
       c4Aif: // global
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Aig: // global
           I64[Sp - 8] = block_c4Aib_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Aiw; else goto c4Aic;
       u4Aiw: // global
           call _c4Aib(R1) args: 0, res: 0, upd: 0;
       c4Aic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cbit_info" {
     GHC.Int.$fBitsInt64_$cbit_info:
         const GHC.Int.$fBitsInt64_$cbit_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4Aib() //  [R1]
         { []
         }
     {offset
       c4Aib: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ail; else goto c4Aik;
       c4Ail: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Aik: // global
           _s4w8r::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w8r::I64, 64)) goto c4Aiu; else goto c4Aiv;
       c4Aiu: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = 1 << _s4w8r::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Aiv: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Aib_info" {
     block_c4Aib_info:
         const _c4Aib;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.743663156 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ctestBit_closure" {
     GHC.Int.$fBitsInt64_$ctestBit_closure:
         const GHC.Int.$fBitsInt64_$ctestBit_info;
 },
 GHC.Int.$fBitsInt64_$ctestBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AiS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AiW; else goto c4AiX;
       c4AiW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AiX: // global
           I64[Sp - 16] = block_c4AiP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AjC; else goto c4AiQ;
       u4AjC: // global
           call _c4AiP(R1) args: 0, res: 0, upd: 0;
       c4AiQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$ctestBit_info" {
     GHC.Int.$fBitsInt64_$ctestBit_info:
         const GHC.Int.$fBitsInt64_$ctestBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4AiP() //  [R1]
         { []
         }
     {offset
       c4AiP: // global
           I64[Sp] = block_c4AiV_info;
           _s4w8x::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w8x::I64;
           if (R1 & 7 != 0) goto u4AjB; else goto c4AiZ;
       u4AjB: // global
           call _c4AiV(R1) args: 0, res: 0, upd: 0;
       c4AiZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AiP_info" {
     block_c4AiP_info:
         const _c4AiP;
         const 1;
         const 30;
 },
 _c4AiV() //  [R1]
         { []
         }
     {offset
       c4AiV: // global
           _s4w8z::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4w8z::I64, 64)) goto c4AjA; else goto c4Ajz;
       c4Ajz: // global
           if (I64[Sp + 8] & (1 << _s4w8z::I64) == 0) goto c4AjA; else goto c4Ajo;
       c4AjA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ajo: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AiV_info" {
     block_c4AiV_info:
         const _c4AiV;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.752700165 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateR_closure" {
     GHC.Int.$fBitsInt64_$crotateR_closure:
         const GHC.Int.$fBitsInt64_$crotateR_info;
 },
 GHC.Int.$fBitsInt64_$crotateR_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Ak6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Aka; else goto c4Akb;
       c4Aka: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Akb: // global
           I64[Sp - 16] = block_c4Ak3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Al4; else goto c4Ak4;
       u4Al4: // global
           call _c4Ak3(R1) args: 0, res: 0, upd: 0;
       c4Ak4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$crotateR_info" {
     GHC.Int.$fBitsInt64_$crotateR_info:
         const GHC.Int.$fBitsInt64_$crotateR_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4Ak3() //  [R1]
         { []
         }
     {offset
       c4Ak3: // global
           I64[Sp - 8] = block_c4Ak9_info;
           _s4w8I::P64 = R1;
           _s4w8J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w8J::I64;
           P64[Sp + 8] = _s4w8I::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Al3; else goto c4Akd;
       u4Al3: // global
           call _c4Ak9(R1) args: 0, res: 0, upd: 0;
       c4Akd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ak3_info" {
     block_c4Ak3_info:
         const _c4Ak3;
         const 1;
         const 30;
 },
 _c4Ak9() //  [R1]
         { []
         }
     {offset
       c4Ak9: // global
           _s4w8P::I64 = -I64[R1 + 7] & 63;
           if (_s4w8P::I64 != 0) goto u4Al1; else goto c4AkX;
       u4Al1: // global
           I64[Sp + 16] = _s4w8P::I64;
           Sp = Sp + 8;
           call _c4Akv() args: 0, res: 0, upd: 0;
       c4AkX: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ak9_info" {
     block_c4Ak9_info:
         const _c4Ak9;
         const 66;
         const 30;
 },
 _c4Akv() //  []
         { []
         }
     {offset
       c4Akv: // global
           Hp = Hp + 16;
           _s4w8P::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c4AkU; else goto c4AkT;
       c4AkU: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c4Aku_info;
           R1 = _s4w8P::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4AkT: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           _s4w8Q::I64 = I64[Sp];
           I64[Hp] = (_s4w8Q::I64 << _s4w8P::I64) | (_s4w8Q::I64 >> 64 - _s4w8P::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Aku() //  [R1]
         { []
         }
     {offset
       c4Aku: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c4Akv() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c4Aku_info" {
     block_c4Aku_info:
         const _c4Aku;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.764585574 UTC

[section ""data" . GHC.Int.$fBitsInt64_$ccomplementBit_closure" {
     GHC.Int.$fBitsInt64_$ccomplementBit_closure:
         const GHC.Int.$fBitsInt64_$ccomplementBit_info;
 },
 GHC.Int.$fBitsInt64_$ccomplementBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AlJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4AlN; else goto c4AlO;
       c4AlN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AlO: // global
           I64[Sp - 16] = block_c4AlG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Amk; else goto c4AlH;
       u4Amk: // global
           call _c4AlG(R1) args: 0, res: 0, upd: 0;
       c4AlH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$ccomplementBit_info" {
     GHC.Int.$fBitsInt64_$ccomplementBit_info:
         const GHC.Int.$fBitsInt64_$ccomplementBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4AlG() //  [R1]
         { []
         }
     {offset
       c4AlG: // global
           I64[Sp - 8] = block_c4AlM_info;
           _s4w8Y::P64 = R1;
           _s4w8Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w8Z::I64;
           P64[Sp + 8] = _s4w8Y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Amj; else goto c4AlQ;
       u4Amj: // global
           call _c4AlM(R1) args: 0, res: 0, upd: 0;
       c4AlQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AlG_info" {
     block_c4AlG_info:
         const _c4AlG;
         const 1;
         const 30;
 },
 _c4AlM() //  [R1]
         { []
         }
     {offset
       c4AlM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AlW; else goto c4AlV;
       c4AlW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AlV: // global
           _s4w91::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w91::I64, 64)) goto c4Amh; else goto c4Ami;
       c4Amh: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s4w91::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Ami: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AlM_info" {
     block_c4AlM_info:
         const _c4AlM;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.773538542 UTC

[section ""data" . GHC.Int.$fBitsInt64_$cclearBit_closure" {
     GHC.Int.$fBitsInt64_$cclearBit_closure:
         const GHC.Int.$fBitsInt64_$cclearBit_info;
 },
 GHC.Int.$fBitsInt64_$cclearBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AmO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AmS; else goto c4AmT;
       c4AmS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AmT: // global
           I64[Sp - 16] = block_c4AmL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AnD; else goto c4AmM;
       u4AnD: // global
           call _c4AmL(R1) args: 0, res: 0, upd: 0;
       c4AmM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$cclearBit_info" {
     GHC.Int.$fBitsInt64_$cclearBit_info:
         const GHC.Int.$fBitsInt64_$cclearBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4AmL() //  [R1]
         { []
         }
     {offset
       c4AmL: // global
           I64[Sp] = block_c4AmR_info;
           _s4w9b::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4w9b::I64;
           if (R1 & 7 != 0) goto u4AnC; else goto c4AmV;
       u4AnC: // global
           call _c4AmR(R1) args: 0, res: 0, upd: 0;
       c4AmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AmL_info" {
     block_c4AmL_info:
         const _c4AmL;
         const 1;
         const 30;
 },
 _c4AmR() //  [R1]
         { []
         }
     {offset
       c4AmR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4An1; else goto c4An0;
       c4An1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4An0: // global
           _s4w9b::I64 = I64[Sp + 8];
           _s4w9d::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w9d::I64, 64)) goto c4Anp; else goto c4AnB;
       c4Anp: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4w9b::I64 & (1 << _s4w9d::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AnB: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4w9b::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AmR_info" {
     block_c4AmR_info:
         const _c4AmR;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.783475194 UTC

[section ""data" . GHC.Int.$fBitsInt64_$csetBit_closure" {
     GHC.Int.$fBitsInt64_$csetBit_closure:
         const GHC.Int.$fBitsInt64_$csetBit_info;
 },
 GHC.Int.$fBitsInt64_$csetBit_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Aob: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Aof; else goto c4Aog;
       c4Aof: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fBitsInt64_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Aog: // global
           I64[Sp - 16] = block_c4Ao8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AoM; else goto c4Ao9;
       u4AoM: // global
           call _c4Ao8(R1) args: 0, res: 0, upd: 0;
       c4Ao9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$csetBit_info" {
     GHC.Int.$fBitsInt64_$csetBit_info:
         const GHC.Int.$fBitsInt64_$csetBit_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4Ao8() //  [R1]
         { []
         }
     {offset
       c4Ao8: // global
           I64[Sp - 8] = block_c4Aoe_info;
           _s4w9q::P64 = R1;
           _s4w9r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s4w9r::I64;
           P64[Sp + 8] = _s4w9q::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AoL; else goto c4Aoi;
       u4AoL: // global
           call _c4Aoe(R1) args: 0, res: 0, upd: 0;
       c4Aoi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ao8_info" {
     block_c4Ao8_info:
         const _c4Ao8;
         const 1;
         const 30;
 },
 _c4Aoe() //  [R1]
         { []
         }
     {offset
       c4Aoe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Aoo; else goto c4Aon;
       c4Aoo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Aon: // global
           _s4w9t::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s4w9t::I64, 64)) goto c4AoJ; else goto c4AoK;
       c4AoJ: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s4w9t::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AoK: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Aoe_info" {
     block_c4Aoe_info:
         const _c4Aoe;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.791401656 UTC

[section ""data" . GHC.Int.$fBitsInt64_$crotateL_closure" {
     GHC.Int.$fBitsInt64_$crotateL_closure:
         const GHC.Int.$fBitsInt64_$crotateL_info;
 },
 GHC.Int.$fBitsInt64_$crotateL_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Apd: // global
           R3 = R3;
           R2 = R2;
           call GHC.Int.$fBitsInt64_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fBitsInt64_$crotateL_info" {
     GHC.Int.$fBitsInt64_$crotateL_info:
         const GHC.Int.$fBitsInt64_$crotateL_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.795172585 UTC

[section ""data" . GHC.Int.$fBitsInt64_closure" {
     GHC.Int.$fBitsInt64_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Int.$fEqInt64_closure+1;
         const GHC.Int.$fBitsInt64_$c.&._closure+2;
         const GHC.Int.$fBitsInt64_$c.|._closure+2;
         const GHC.Int.$fBitsInt64_$cxor_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplement_closure+1;
         const GHC.Int.$fBitsInt64_$cshift_closure+2;
         const GHC.Int.$fBitsInt64_$crotate_closure+2;
         const GHC.Int.$fBitsInt10_closure+1;
         const GHC.Int.$fBitsInt64_$cbit_closure+1;
         const GHC.Int.$fBitsInt64_$csetBit_closure+2;
         const GHC.Int.$fBitsInt64_$cclearBit_closure+2;
         const GHC.Int.$fBitsInt64_$ccomplementBit_closure+2;
         const GHC.Int.$fBitsInt64_$ctestBit_closure+2;
         const GHC.Int.$fBitsInt64_$cbitSizeMaybe_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fBitsInt64_$cisSigned_closure+1;
         const GHC.Int.$fBitsInt64_$cshiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftL_closure+2;
         const GHC.Int.$fBitsInt64_$cshiftR_closure+2;
         const GHC.Int.$fBitsInt64_$cunsafeShiftR_closure+2;
         const GHC.Int.$fBitsInt64_$crotateL_closure+2;
         const GHC.Int.$fBitsInt64_$crotateR_closure+2;
         const GHC.Int.$fBitsInt64_$cpopCount_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.797409579 UTC

[section ""data" . GHC.Int.$fFiniteBitsInt64_closure" {
     GHC.Int.$fFiniteBitsInt64_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const GHC.Int.$fBitsInt64_closure+1;
         const GHC.Int.$fBitsInt64_$cfiniteBitSize_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros_closure+1;
         const GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.802774167 UTC

[section ""data" . GHC.Int.$fReadInt64_go_closure" {
     GHC.Int.$fReadInt64_go_closure:
         const GHC.Int.$fReadInt64_go_info;
 },
 sat_s4w9L_entry() //  [R1]
         { []
         }
     {offset
       c4ApF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ApG; else goto c4ApH;
       c4ApG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ApH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4w9L_info" {
     sat_s4w9L_info:
         const sat_s4w9L_entry;
         const 1;
         const 16;
 },
 sat_s4w9J_entry() //  [R1]
         { []
         }
     {offset
       c4ApP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ApT; else goto c4ApU;
       c4ApT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ApU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4ApM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4ApY; else goto c4ApN;
       u4ApY: // global
           call _c4ApM(R1) args: 0, res: 0, upd: 0;
       c4ApN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s4w9J_info" {
     sat_s4w9J_info:
         const sat_s4w9J_entry;
         const 1;
         const 16;
 },
 _c4ApM() //  [R1]
         { []
         }
     {offset
       c4ApM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ApX; else goto c4ApW;
       c4ApX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4ApW: // global
           _s4w9I::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4w9I::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c4ApM_info" {
     block_c4ApM_info:
         const _c4ApM;
         const 0;
         const 30;
 },
 GHC.Int.$fReadInt64_go_entry() //  [R2]
         { []
         }
     {offset
       c4Aq3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Aq4; else goto c4Aq5;
       c4Aq4: // global
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Aq5: // global
           I64[Sp - 8] = block_c4Apq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Aqf; else goto c4Apr;
       u4Aqf: // global
           call _c4Apq(R1) args: 0, res: 0, upd: 0;
       c4Apr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt64_go_info" {
     GHC.Int.$fReadInt64_go_info:
         const GHC.Int.$fReadInt64_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4Apq() //  [R1]
         { []
         }
     {offset
       c4Apq: // global
           if (R1 & 7 == 1) goto c4Aq0; else goto c4Aq1;
       c4Aq0: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Aq1: // global
           I64[Sp - 8] = block_c4Apw_info;
           _s4w9D::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4w9D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Aqe; else goto c4Apx;
       u4Aqe: // global
           call _c4Apw(R1) args: 0, res: 0, upd: 0;
       c4Apx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Apq_info" {
     block_c4Apq_info:
         const _c4Apq;
         const 0;
         const 30;
 },
 _c4Apw() //  [R1]
         { []
         }
     {offset
       c4Apw: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c4Aqd; else goto c4Aqc;
       c4Aqd: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Aqc: // global
           _s4w9F::P64 = P64[R1 + 7];
           _s4w9G::P64 = P64[R1 + 15];
           I64[Hp - 88] = sat_s4w9L_info;
           P64[Hp - 72] = P64[Sp + 8];
           I64[Hp - 64] = sat_s4w9J_info;
           P64[Hp - 48] = _s4w9F::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = _s4w9G::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Apw_info" {
     block_c4Apw_info:
         const _c4Apw;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.816203531 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadsPrec_closure" {
     GHC.Int.$fReadInt64_$creadsPrec_closure:
         const GHC.Int.$fReadInt64_$creadsPrec_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Ar5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ar9; else goto c4Ara;
       c4Ar9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt64_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ara: // global
           I64[Sp - 16] = block_c4Ar3_info;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           _s4w9N::P64 = R3;
           R3 = R2;
           R2 = GHC.Read.$fReadInt2_closure+1;
           P64[Sp - 8] = _s4w9N::P64;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt64_$creadsPrec_info" {
     GHC.Int.$fReadInt64_$creadsPrec_info:
         const GHC.Int.$fReadInt64_$creadsPrec_entry;
         const 0;
         const 144115200960757774;
         const 8589934607;
         const S4wm5_srt+848;
 },
 _c4Ar3() //  [R1]
         { []
         }
     {offset
       c4Ar3: // global
           _s4w9N::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Ar8_info;
           R3 = _s4w9N::P64;
           R2 = R1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ar3_info" {
     block_c4Ar3_info:
         const _c4Ar3;
         const 1;
         const 30;
 },
 _c4Ar8() //  [R1]
         { []
         }
     {offset
       c4Ar8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Int.$fReadInt64_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ar8_info" {
     block_c4Ar8_info:
         const _c4Ar8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.825643593 UTC

[section ""data" . GHC.Int.$fReadInt10_closure" {
     GHC.Int.$fReadInt10_closure:
         const GHC.Int.$fReadInt10_info;
         const 0;
 },
 sat_s4w9S_entry() //  [R1, R2]
         { []
         }
     {offset
       c4ArE: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Int.$fReadInt64_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s4w9S_info" {
     sat_s4w9S_info:
         const sat_s4w9S_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S4wm5_srt+1048;
 },
 GHC.Int.$fReadInt10_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ArK: // global
           _s4w9R::P64 = R3;
           _s4w9Q::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c4ArL; else goto c4ArM;
       c4ArM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ArO; else goto c4ArN;
       c4ArO: // global
           HpAlloc = 16;
           goto c4ArL;
       c4ArL: // global
           R3 = _s4w9R::P64;
           R2 = _s4w9Q::P64;
           R1 = GHC.Int.$fReadInt10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ArN: // global
           I64[Hp - 8] = sat_s4w9S_info;
           P64[Hp] = _s4w9Q::P64;
           I64[Sp - 8] = block_c4ArH_info;
           R3 = _s4w9R::P64;
           R2 = Hp - 7;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt10_info" {
     GHC.Int.$fReadInt10_info:
         const GHC.Int.$fReadInt10_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+1048;
 },
 _c4ArH() //  [R1]
         { []
         }
     {offset
       c4ArH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ArR; else goto c4ArQ;
       c4ArR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ArQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ArH_info" {
     block_c4ArH_info:
         const _c4ArH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.83644607 UTC

[section ""data" . GHC.Int.$fReadInt9_closure" {
     GHC.Int.$fReadInt9_closure:
         const GHC.Int.$fReadInt9_info;
         const 0;
         const 0;
         const 0;
 },
 section ""relreadonly" . u4Asg_srtd" {
     u4Asg_srtd:
         const S4wm5_srt+504;
         const 70;
         const 1;
         const 32;
 },
 GHC.Int.$fReadInt9_entry() //  [R1]
         { []
         }
     {offset
       c4Asd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4Ase; else goto c4Asf;
       c4Ase: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Asf: // global
           (_c4Asa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Asa::I64 == 0) goto c4Asc; else goto c4Asb;
       c4Asc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Asb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Asa::I64;
           R2 = GHC.Int.$fReadInt10_closure+2;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Int.$fIxInt1_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt9_info" {
     GHC.Int.$fReadInt9_info:
         const GHC.Int.$fReadInt9_entry;
         const 0;
         const 18446744069414584341;
         const u4Asg_srtd;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.844311014 UTC

[section ""data" . GHC.Int.$fReadInt64_$creadList_closure" {
     GHC.Int.$fReadInt64_$creadList_closure:
         const GHC.Int.$fReadInt64_$creadList_info;
         const 0;
 },
 GHC.Int.$fReadInt64_$creadList_entry() //  [R2]
         { []
         }
     {offset
       c4Asy: // global
           R3 = R2;
           R2 = GHC.Int.$fReadInt9_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt64_$creadList_info" {
     GHC.Int.$fReadInt64_$creadList_info:
         const GHC.Int.$fReadInt64_$creadList_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S4wm5_srt+1064;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.851594527 UTC

[section ""data" . GHC.Int.$fReadInt7_closure" {
     GHC.Int.$fReadInt7_closure:
         const GHC.Int.$fReadInt7_info;
         const 0;
 },
 GHC.Int.$fReadInt7_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AsM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4AsN; else goto c4AsO;
       c4AsN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fReadInt7_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AsO: // global
           I64[Sp - 8] = block_c4AsJ_info;
           R3 = R3;
           R2 = GHC.Int.$fReadInt64_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fReadInt7_info" {
     GHC.Int.$fReadInt7_info:
         const GHC.Int.$fReadInt7_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+1072;
 },
 _c4AsJ() //  [R1]
         { []
         }
     {offset
       c4AsJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AsR; else goto c4AsQ;
       c4AsR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AsQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AsJ_info" {
     block_c4AsJ_info:
         const _c4AsJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.860180471 UTC

[section ""data" . GHC.Int.$fReadInt64_closure" {
     GHC.Int.$fReadInt64_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Int.$fReadInt64_$creadsPrec_closure+2;
         const GHC.Int.$fReadInt64_$creadList_closure+1;
         const GHC.Int.$fReadInt10_closure+2;
         const GHC.Int.$fReadInt7_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.864349976 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquot_closure" {
     GHC.Int.$fIntegralInt64_$cquot_closure:
         const GHC.Int.$fIntegralInt64_$cquot_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquot_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Atb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Atf; else goto c4Atg;
       c4Atf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquot_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Atg: // global
           I64[Sp - 16] = block_c4At8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AtL; else goto c4At9;
       u4AtL: // global
           call _c4At8(R1) args: 0, res: 0, upd: 0;
       c4At9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$cquot_info" {
     GHC.Int.$fIntegralInt64_$cquot_info:
         const GHC.Int.$fIntegralInt64_$cquot_entry;
         const 0;
         const 36028809903865870;
         const 8589934607;
         const S4wm5_srt+904;
 },
 _c4At8() //  [R1]
         { []
         }
     {offset
       c4At8: // global
           I64[Sp] = block_c4Ate_info;
           _s4wa2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wa2::I64;
           if (R1 & 7 != 0) goto u4AtK; else goto c4Ati;
       u4AtK: // global
           call _c4Ate(R1) args: 0, res: 0, upd: 0;
       c4Ati: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4At8_info" {
     block_c4At8_info:
         const _c4At8;
         const 1;
         const 12884901918;
         const S4wm5_srt+904;
 },
 _c4Ate() //  [R1]
         { []
         }
     {offset
       c4Ate: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ato; else goto c4Atn;
       c4Ato: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Atn: // global
           _s4wa2::I64 = I64[Sp + 8];
           _s4wa5::I64 = I64[R1 + 7];
           if (_s4wa5::I64 != (-1)) goto u4AtJ; else goto c4AtH;
       u4AtJ: // global
           if (_s4wa5::I64 != 0) goto c4Atw; else goto c4AtI;
       c4Atw: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4wa2::I64, _s4wa5::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AtI: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4AtH: // global
           if (_s4wa2::I64 == (-9223372036854775808)) goto c4AtG; else goto c4AtF;
       c4AtG: // global
           Hp = Hp - 16;
           R1 = GHC.Real.overflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4AtF: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Quot_W64(_s4wa2::I64, (-1));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ate_info" {
     block_c4Ate_info:
         const _c4Ate;
         const 65;
         const 12884901918;
         const S4wm5_srt+904;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.875707567 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$crem_closure" {
     GHC.Int.$fIntegralInt64_$crem_closure:
         const GHC.Int.$fIntegralInt64_$crem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$crem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Aug: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Auk; else goto c4Aul;
       c4Auk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$crem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Aul: // global
           I64[Sp - 16] = block_c4Aud_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AuG; else goto c4Aue;
       u4AuG: // global
           call _c4Aud(R1) args: 0, res: 0, upd: 0;
       c4Aue: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$crem_info" {
     GHC.Int.$fIntegralInt64_$crem_info:
         const GHC.Int.$fIntegralInt64_$crem_entry;
         const 0;
         const 36028801313931278;
         const 8589934607;
         const S4wm5_srt+912;
 },
 _c4Aud() //  [R1]
         { []
         }
     {offset
       c4Aud: // global
           I64[Sp] = block_c4Auj_info;
           _s4wae::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wae::I64;
           if (R1 & 7 != 0) goto u4AuF; else goto c4Aun;
       u4AuF: // global
           call _c4Auj(R1) args: 0, res: 0, upd: 0;
       c4Aun: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Aud_info" {
     block_c4Aud_info:
         const _c4Aud;
         const 1;
         const 4294967326;
         const S4wm5_srt+912;
 },
 _c4Auj() //  [R1]
         { []
         }
     {offset
       c4Auj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Aut; else goto c4Aus;
       c4Aut: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Aus: // global
           _s4wah::I64 = I64[R1 + 7];
           if (_s4wah::I64 != (-1)) goto u4AuE; else goto c4AuC;
       u4AuE: // global
           if (_s4wah::I64 != 0) goto c4AuB; else goto c4AuD;
       c4AuB: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = %MO_S_Rem_W64(I64[Sp + 8], _s4wah::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AuD: // global
           Hp = Hp - 16;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4AuC: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Auj_info" {
     block_c4Auj_info:
         const _c4Auj;
         const 65;
         const 4294967326;
         const S4wm5_srt+912;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.884770959 UTC

[section ""data" . GHC.Int.$w$cdiv2_closure" {
     GHC.Int.$w$cdiv2_closure:
         const GHC.Int.$w$cdiv2_info;
         const 0;
 },
 GHC.Int.$w$cdiv2_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Av9: // global
           if (R3 == (-1)) goto c4Av7; else goto u4Avi;
       c4Av7: // global
           if (R2 == (-9223372036854775808)) goto c4Avh; else goto c4Avg;
       c4Avh: // global
           R1 = GHC.Real.overflowError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4Avg: // global
           R3 = (-1);
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
       u4Avi: // global
           if (R3 == 0) goto c4Av8; else goto c4Av6;
       c4Av8: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4Av6: // global
           R3 = R3;
           R2 = R2;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdiv2_info" {
     GHC.Int.$w$cdiv2_info:
         const GHC.Int.$w$cdiv2_entry;
         const 0;
         const 12884901902;
         const 8589934604;
         const S4wm5_srt+904;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.891178526 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdiv_closure" {
     GHC.Int.$fIntegralInt64_$cdiv_closure:
         const GHC.Int.$fIntegralInt64_$cdiv_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdiv_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Avv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AvI; else goto c4AvJ;
       c4AvI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdiv_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AvJ: // global
           I64[Sp - 16] = block_c4Avs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AvQ; else goto c4Avt;
       u4AvQ: // global
           call _c4Avs(R1) args: 0, res: 0, upd: 0;
       c4Avt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$cdiv_info" {
     GHC.Int.$fIntegralInt64_$cdiv_info:
         const GHC.Int.$fIntegralInt64_$cdiv_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+1104;
 },
 _c4Avs() //  [R1]
         { []
         }
     {offset
       c4Avs: // global
           I64[Sp] = block_c4Avy_info;
           _s4was::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4was::I64;
           if (R1 & 7 != 0) goto u4AvP; else goto c4Avz;
       u4AvP: // global
           call _c4Avy(R1) args: 0, res: 0, upd: 0;
       c4Avz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Avs_info" {
     block_c4Avs_info:
         const _c4Avs;
         const 1;
         const 4294967326;
         const S4wm5_srt+1112;
 },
 _c4Avy() //  [R1]
         { []
         }
     {offset
       c4Avy: // global
           _s4was::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4AvD_info;
           R3 = I64[R1 + 7];
           R2 = _s4was::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdiv2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Avy_info" {
     block_c4Avy_info:
         const _c4Avy;
         const 65;
         const 4294967326;
         const S4wm5_srt+1112;
 },
 _c4AvD() //  [R1]
         { []
         }
     {offset
       c4AvD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AvO; else goto c4AvN;
       c4AvO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4AvN: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AvD_info" {
     block_c4AvD_info:
         const _c4AvD;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.902590205 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cmod_closure" {
     GHC.Int.$fIntegralInt64_$cmod_closure:
         const GHC.Int.$fIntegralInt64_$cmod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cmod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Awj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Awn; else goto c4Awo;
       c4Awn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cmod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Awo: // global
           I64[Sp - 16] = block_c4Awg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AwL; else goto c4Awh;
       u4AwL: // global
           call _c4Awg(R1) args: 0, res: 0, upd: 0;
       c4Awh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$cmod_info" {
     GHC.Int.$fIntegralInt64_$cmod_info:
         const GHC.Int.$fIntegralInt64_$cmod_entry;
         const 0;
         const 288230380446679054;
         const 8589934607;
         const S4wm5_srt+912;
 },
 _c4Awg() //  [R1]
         { []
         }
     {offset
       c4Awg: // global
           I64[Sp] = block_c4Awm_info;
           _s4waz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4waz::I64;
           if (R1 & 7 != 0) goto u4AwK; else goto c4Awq;
       u4AwK: // global
           call _c4Awm(R1) args: 0, res: 0, upd: 0;
       c4Awq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Awg_info" {
     block_c4Awg_info:
         const _c4Awg;
         const 1;
         const 4294967326;
         const S4wm5_srt+912;
 },
 _c4Awm() //  [R1]
         { []
         }
     {offset
       c4Awm: // global
           _s4waC::I64 = I64[R1 + 7];
           if (_s4waC::I64 != (-1)) goto u4AwJ; else goto c4AwH;
       u4AwJ: // global
           if (_s4waC::I64 != 0) goto c4AwD; else goto c4AwI;
       c4AwD: // global
           _s4waz::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4Awx_info;
           R3 = _s4waC::I64;
           R2 = _s4waz::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
       c4AwI: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4AwH: // global
           R1 = GHC.Int.$fBitsInt10_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Awm_info" {
     block_c4Awm_info:
         const _c4Awm;
         const 65;
         const 4294967326;
         const S4wm5_srt+912;
 },
 _c4Awx() //  [R1]
         { []
         }
     {offset
       c4Awx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AwG; else goto c4AwF;
       c4AwG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4AwF: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Awx_info" {
     block_c4Awx_info:
         const _c4Awx;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.914660587 UTC

[section ""data" . lvl9_r4kPA_closure" {
     lvl9_r4kPA_closure:
         const (,)_con_info;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fBitsInt10_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.921027138 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cquotRem_closure" {
     GHC.Int.$fIntegralInt64_$cquotRem_closure:
         const GHC.Int.$fIntegralInt64_$cquotRem_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cquotRem_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Axg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Axk; else goto c4Axl;
       c4Axk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Axl: // global
           I64[Sp - 16] = block_c4Axd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AxO; else goto c4Axe;
       u4AxO: // global
           call _c4Axd(R1) args: 0, res: 0, upd: 0;
       c4Axe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$cquotRem_info" {
     GHC.Int.$fIntegralInt64_$cquotRem_info:
         const GHC.Int.$fIntegralInt64_$cquotRem_entry;
         const 0;
         const 1729382261205237774;
         const 8589934607;
         const S4wm5_srt+912;
 },
 _c4Axd() //  [R1]
         { []
         }
     {offset
       c4Axd: // global
           I64[Sp] = block_c4Axj_info;
           _s4waI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4waI::I64;
           if (R1 & 7 != 0) goto u4AxN; else goto c4Axn;
       u4AxN: // global
           call _c4Axj(R1) args: 0, res: 0, upd: 0;
       c4Axn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Axd_info" {
     block_c4Axd_info:
         const _c4Axd;
         const 1;
         const 1152921508901814302;
         const S4wm5_srt+912;
 },
 _c4Axj() //  [R1]
         { []
         }
     {offset
       c4Axj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4Axt; else goto c4Axs;
       c4Axt: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Axs: // global
           _s4waI::I64 = I64[Sp + 8];
           _s4waL::I64 = I64[R1 + 7];
           if (_s4waL::I64 != (-1)) goto u4AxM; else goto c4AxK;
       u4AxM: // global
           if (_s4waL::I64 != 0) goto c4AxA; else goto c4AxL;
       c4AxA: // global
           (_s4waN::I64, _s4waO::I64) = call MO_S_QuotRem W64(_s4waI::I64, _s4waL::I64);
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4waO::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4waN::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AxL: // global
           Hp = Hp - 56;
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4AxK: // global
           if (_s4waI::I64 == (-9223372036854775808)) goto c4AxJ; else goto c4AxI;
       c4AxJ: // global
           Hp = Hp - 56;
           R1 = lvl9_r4kPA_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AxI: // global
           (_s4waT::I64, _s4waU::I64) = call MO_S_QuotRem W64(_s4waI::I64, (-1));
           I64[Hp - 48] = GHC.Int.I64#_con_info;
           I64[Hp - 40] = _s4waU::I64;
           I64[Hp - 32] = GHC.Int.I64#_con_info;
           I64[Hp - 24] = _s4waT::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Axj_info" {
     block_c4Axj_info:
         const _c4Axj;
         const 65;
         const 1152921508901814302;
         const S4wm5_srt+912;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.940761717 UTC

[section ""data" . GHC.Int.$w$cdivMod2_closure" {
     GHC.Int.$w$cdivMod2_closure:
         const GHC.Int.$w$cdivMod2_info;
         const 0;
 },
 GHC.Int.$w$cdivMod2_entry() //  [R2, R3]
         { []
         }
     {offset
       c4Ayr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Ays; else goto c4Ayt;
       c4Ays: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$w$cdivMod2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ayt: // global
           if (R3 == 0) goto c4Ayq; else goto c4Ayp;
       c4Ayq: // global
           R1 = GHC.Real.divZeroError_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4Ayp: // global
           if (R3 == (-1)) goto c4AAg; else goto u4AAh;
       c4AAg: // global
           if (R2 == (-9223372036854775808)) goto c4AAf; else goto u4AAi;
       c4AAf: // global
           R2 = GHC.Int.$fBitsInt10_closure+1;
           R1 = GHC.Real.overflowError_closure;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       u4AAi: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4AAk;
       u4AAh: // global
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           goto u4AAk;
       u4AAk: // global
           call _c4Ayy() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Int.$w$cdivMod2_info" {
     GHC.Int.$w$cdivMod2_info:
         const GHC.Int.$w$cdivMod2_entry;
         const 0;
         const 4611686031312289806;
         const 8589934604;
         const S4wm5_srt+904;
 },
 _c4Ayy() //  []
         { []
         }
     {offset
       c4Ayy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4AyC; else goto c4AyB;
       c4AyC: // global
           HpAlloc = 32;
           I64[Sp] = block_c4Ayy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c4AyB: // global
           _s4waY::I64 = I64[Sp + 8];
           _s4wb0::I64 = I64[Sp + 16];
           if (%MO_S_Le_W64(_s4waY::I64, 0)) goto c4Azd; else goto c4AA6;
       c4Azd: // global
           if (%MO_S_Ge_W64(_s4waY::I64, 0)) goto c4AyM; else goto c4Azb;
       c4AyM: // global
           (_s4wb5::I64, _s4wb6::I64) = call MO_S_QuotRem W64(_s4waY::I64, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wb6::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wb5::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4Azb: // global
           if (%MO_S_Le_W64(_s4wb0::I64, 0)) goto c4AyU; else goto c4Aza;
       c4AyU: // global
           (_s4wbb::I64, _s4wbc::I64) = call MO_S_QuotRem W64(_s4waY::I64, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wbc::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbb::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4Aza: // global
           (_s4wbh::I64, _s4wbi::I64) = call MO_S_QuotRem W64(_s4waY::I64 + 1, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wbi::I64 + _s4wb0::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbh::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4AA6: // global
           if (%MO_S_Ge_W64(_s4wb0::I64, 0)) goto c4AzP; else goto c4AA5;
       c4AzP: // global
           if (%MO_S_Ge_W64(_s4waY::I64, 0)) goto c4Azo; else goto c4AzN;
       c4Azo: // global
           (_s4wbr::I64, _s4wbs::I64) = call MO_S_QuotRem W64(_s4waY::I64, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wbs::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbr::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4AzN: // global
           if (%MO_S_Le_W64(_s4wb0::I64, 0)) goto c4Azw; else goto c4AzM;
       c4Azw: // global
           (_s4wbx::I64, _s4wby::I64) = call MO_S_QuotRem W64(_s4waY::I64, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wby::I64;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbx::I64;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4AzM: // global
           (_s4wbD::I64, _s4wbE::I64) = call MO_S_QuotRem W64(_s4waY::I64 + 1, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wbE::I64 + _s4wb0::I64 - 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbD::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       c4AA5: // global
           (_s4wbM::I64, _s4wbN::I64) = call MO_S_QuotRem W64(_s4waY::I64 - 1, _s4wb0::I64);
           I64[Hp - 24] = GHC.Int.I64#_con_info;
           I64[Hp - 16] = _s4wbN::I64 + _s4wb0::I64 + 1;
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4wbM::I64 - 1;
           R2 = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4Ayy_info" {
     block_c4Ayy_info:
         const _c4Ayy;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.956724599 UTC

[section ""data" . GHC.Int.$fIntegralInt64_$cdivMod_closure" {
     GHC.Int.$fIntegralInt64_$cdivMod_closure:
         const GHC.Int.$fIntegralInt64_$cdivMod_info;
         const 0;
 },
 GHC.Int.$fIntegralInt64_$cdivMod_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ABa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ABl; else goto c4ABm;
       c4ABl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIntegralInt64_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ABm: // global
           I64[Sp - 16] = block_c4AB7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ABt; else goto c4AB8;
       u4ABt: // global
           call _c4AB7(R1) args: 0, res: 0, upd: 0;
       c4AB8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIntegralInt64_$cdivMod_info" {
     GHC.Int.$fIntegralInt64_$cdivMod_info:
         const GHC.Int.$fIntegralInt64_$cdivMod_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const S4wm5_srt+1144;
 },
 _c4AB7() //  [R1]
         { []
         }
     {offset
       c4AB7: // global
           I64[Sp] = block_c4ABd_info;
           _s4wbZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wbZ::I64;
           if (R1 & 7 != 0) goto u4ABs; else goto c4ABe;
       u4ABs: // global
           call _c4ABd(R1) args: 0, res: 0, upd: 0;
       c4ABe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AB7_info" {
     block_c4AB7_info:
         const _c4AB7;
         const 1;
         const 4294967326;
         const S4wm5_srt+1144;
 },
 _c4ABd() //  [R1]
         { []
         }
     {offset
       c4ABd: // global
           _s4wbZ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c4ABi_info;
           R3 = I64[R1 + 7];
           R2 = _s4wbZ::I64;
           Sp = Sp + 8;
           call GHC.Int.$w$cdivMod2_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ABd_info" {
     block_c4ABd_info:
         const _c4ABd;
         const 65;
         const 4294967326;
         const S4wm5_srt+1144;
 },
 _c4ABi() //  [R1, R2]
         { []
         }
     {offset
       c4ABi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ABr; else goto c4ABq;
       c4ABr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ABq: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ABi_info" {
     block_c4ABi_info:
         const _c4ABi;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.968678095 UTC

[section ""data" . GHC.Int.$fIxInt64_$crange_closure" {
     GHC.Int.$fIxInt64_$crange_closure:
         const GHC.Int.$fIxInt64_$crange_info;
 },
 GHC.Int.$fIxInt64_$crange_entry() //  [R2]
         { []
         }
     {offset
       c4ABW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ABX; else goto c4ABY;
       c4ABX: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crange_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ABY: // global
           I64[Sp - 8] = block_c4ABT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AC2; else goto c4ABU;
       u4AC2: // global
           call _c4ABT(R1) args: 0, res: 0, upd: 0;
       c4ABU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$crange_info" {
     GHC.Int.$fIxInt64_$crange_info:
         const GHC.Int.$fIxInt64_$crange_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4ABT() //  [R1]
         { []
         }
     {offset
       c4ABT: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Int.$fEnumInt64_$cenumFromTo_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ABT_info" {
     block_c4ABT_info:
         const _c4ABT;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.97521823 UTC

[section ""data" . GHC.Int.$fRealInt64_$ctoRational_closure" {
     GHC.Int.$fRealInt64_$ctoRational_closure:
         const GHC.Int.$fRealInt64_$ctoRational_info;
         const 0;
 },
 GHC.Int.$fRealInt64_$ctoRational_entry() //  [R2]
         { []
         }
     {offset
       c4ACk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ACy; else goto c4ACz;
       c4ACy: // global
           R2 = R2;
           R1 = GHC.Int.$fRealInt64_$ctoRational_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ACz: // global
           I64[Sp - 8] = block_c4ACh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ACG; else goto c4ACi;
       u4ACG: // global
           call _c4ACh(R1) args: 0, res: 0, upd: 0;
       c4ACi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fRealInt64_$ctoRational_info" {
     GHC.Int.$fRealInt64_$ctoRational_info:
         const GHC.Int.$fRealInt64_$ctoRational_entry;
         const 0;
         const 9007229319512078;
         const 4294967301;
         const S4wm5_srt+992;
 },
 _c4ACh() //  [R1]
         { []
         }
     {offset
       c4ACh: // global
           I64[Sp] = block_c4ACn_info;
           R2 = I64[R1 + 7];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ACh_info" {
     block_c4ACh_info:
         const _c4ACh;
         const 0;
         const 30064771102;
         const S4wm5_srt+992;
 },
 _c4ACn() //  [R1]
         { []
         }
     {offset
       c4ACn: // global
           I64[Sp] = block_c4ACr_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ACn_info" {
     block_c4ACn_info:
         const _c4ACn;
         const 0;
         const 30064771102;
         const S4wm5_srt+992;
 },
 _c4ACr() //  [R1]
         { []
         }
     {offset
       c4ACr: // global
           I64[Sp] = block_c4ACv_info;
           R3 = GHC.Int.$fRealInt1_closure;
           R2 = R1;
           call GHC.Real.$w$sreduce_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ACr_info" {
     block_c4ACr_info:
         const _c4ACr;
         const 0;
         const 12884901918;
         const S4wm5_srt+992;
 },
 _c4ACv() //  [R1, R2]
         { []
         }
     {offset
       c4ACv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ACF; else goto c4ACE;
       c4ACF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ACE: // global
           I64[Hp - 16] = GHC.Real.:%_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ACv_info" {
     block_c4ACv_info:
         const _c4ACv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.985638027 UTC

[section ""data" . GHC.Int.$fRealInt64_closure" {
     GHC.Int.$fRealInt64_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Int.$fNumInt64_closure+1;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fRealInt64_$ctoRational_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.987346739 UTC

[section ""data" . GHC.Int.$fIntegralInt64_closure" {
     GHC.Int.$fIntegralInt64_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Int.$fRealInt64_closure+1;
         const GHC.Int.$fEnumInt64_closure+1;
         const GHC.Int.$fIntegralInt64_$cquot_closure+2;
         const GHC.Int.$fIntegralInt64_$crem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdiv_closure+2;
         const GHC.Int.$fIntegralInt64_$cmod_closure+2;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure+2;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure+2;
         const GHC.Int.$fIntegralInt64_$ctoInteger_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:26.99084812 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeIndex_closure" {
     GHC.Int.$fIxInt64_$cunsafeIndex_closure:
         const GHC.Int.$fIxInt64_$cunsafeIndex_info;
 },
 GHC.Int.$fIxInt64_$cunsafeIndex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4ADe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ADv; else goto c4ADw;
       c4ADv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeIndex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ADw: // global
           I64[Sp - 16] = block_c4ADb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ADD; else goto c4ADc;
       u4ADD: // global
           call _c4ADb(R1) args: 0, res: 0, upd: 0;
       c4ADc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$cunsafeIndex_info" {
     GHC.Int.$fIxInt64_$cunsafeIndex_info:
         const GHC.Int.$fIxInt64_$cunsafeIndex_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4ADb() //  [R1]
         { []
         }
     {offset
       c4ADb: // global
           I64[Sp] = block_c4ADh_info;
           _s4wck::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s4wck::P64;
           if (R1 & 7 != 0) goto u4ADC; else goto c4ADi;
       u4ADC: // global
           call _c4ADh(R1) args: 0, res: 0, upd: 0;
       c4ADi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ADb_info" {
     block_c4ADb_info:
         const _c4ADb;
         const 1;
         const 30;
 },
 _c4ADh() //  [R1]
         { []
         }
     {offset
       c4ADh: // global
           I64[Sp] = block_c4ADm_info;
           _s4wcn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wcn::I64;
           if (R1 & 7 != 0) goto u4ADE; else goto c4ADn;
       u4ADE: // global
           call _c4ADm(R1) args: 0, res: 0, upd: 0;
       c4ADn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ADh_info" {
     block_c4ADh_info:
         const _c4ADh;
         const 1;
         const 30;
 },
 _c4ADm() //  [R1]
         { []
         }
     {offset
       c4ADm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ADB; else goto c4ADA;
       c4ADB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ADA: // global
           _s4wcq::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4wcq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4ADm_info" {
     block_c4ADm_info:
         const _c4ADm;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.00106869 UTC

[section ""data" . GHC.Int.$fIxInt64_$crangeSize_closure" {
     GHC.Int.$fIxInt64_$crangeSize_closure:
         const GHC.Int.$fIxInt64_$crangeSize_info;
 },
 GHC.Int.$fIxInt64_$crangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4AEa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AEj; else goto c4AEk;
       c4AEj: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$crangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AEk: // global
           I64[Sp - 8] = block_c4AE7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AEJ; else goto c4AE8;
       u4AEJ: // global
           call _c4AE7(R1) args: 0, res: 0, upd: 0;
       c4AE8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$crangeSize_info" {
     GHC.Int.$fIxInt64_$crangeSize_info:
         const GHC.Int.$fIxInt64_$crangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4AE7() //  [R1]
         { []
         }
     {offset
       c4AE7: // global
           I64[Sp - 8] = block_c4AEd_info;
           _s4wcu::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4wcu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AEI; else goto c4AEe;
       u4AEI: // global
           call _c4AEd(R1) args: 0, res: 0, upd: 0;
       c4AEe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AE7_info" {
     block_c4AE7_info:
         const _c4AE7;
         const 0;
         const 30;
 },
 _c4AEd() //  [R1]
         { []
         }
     {offset
       c4AEd: // global
           I64[Sp] = block_c4AEi_info;
           _s4wcw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wcw::I64;
           if (R1 & 7 != 0) goto u4AEK; else goto c4AEn;
       u4AEK: // global
           call _c4AEi(R1) args: 0, res: 0, upd: 0;
       c4AEn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AEd_info" {
     block_c4AEd_info:
         const _c4AEd;
         const 1;
         const 30;
 },
 _c4AEi() //  [R1]
         { []
         }
     {offset
       c4AEi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AEt; else goto c4AEs;
       c4AEt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AEs: // global
           _s4wcw::I64 = I64[Sp + 8];
           _s4wcy::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s4wcw::I64,
                            _s4wcy::I64)) goto c4AEx; else goto c4AEH;
       c4AEx: // global
           Hp = Hp - 16;
           R1 = GHC.Int.$fIxInt1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4AEH: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4wcy::I64 - _s4wcw::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AEi_info" {
     block_c4AEi_info:
         const _c4AEi;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.01178831 UTC

[section ""data" . GHC.Int.$fIxInt64_$cunsafeRangeSize_closure" {
     GHC.Int.$fIxInt64_$cunsafeRangeSize_closure:
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_info;
 },
 GHC.Int.$fIxInt64_$cunsafeRangeSize_entry() //  [R2]
         { []
         }
     {offset
       c4AFi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AFC; else goto c4AFD;
       c4AFC: // global
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AFD: // global
           I64[Sp - 8] = block_c4AFf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AFK; else goto c4AFg;
       u4AFK: // global
           call _c4AFf(R1) args: 0, res: 0, upd: 0;
       c4AFg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$cunsafeRangeSize_info" {
     GHC.Int.$fIxInt64_$cunsafeRangeSize_info:
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4AFf() //  [R1]
         { []
         }
     {offset
       c4AFf: // global
           I64[Sp - 8] = block_c4AFl_info;
           _s4wcE::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s4wcE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AFJ; else goto c4AFm;
       u4AFJ: // global
           call _c4AFl(R1) args: 0, res: 0, upd: 0;
       c4AFm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AFf_info" {
     block_c4AFf_info:
         const _c4AFf;
         const 0;
         const 30;
 },
 _c4AFl() //  [R1]
         { []
         }
     {offset
       c4AFl: // global
           I64[Sp] = block_c4AFq_info;
           _s4wcH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wcH::I64;
           if (R1 & 7 != 0) goto u4AFL; else goto c4AFr;
       u4AFL: // global
           call _c4AFq(R1) args: 0, res: 0, upd: 0;
       c4AFr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AFl_info" {
     block_c4AFl_info:
         const _c4AFl;
         const 1;
         const 30;
 },
 _c4AFq() //  [R1]
         { []
         }
     {offset
       c4AFq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AFI; else goto c4AFH;
       c4AFI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AFH: // global
           _s4wcL::I64 = I64[Sp + 8] - I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4wcL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AFq_info" {
     block_c4AFq_info:
         const _c4AFq;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.023438987 UTC

[section ""data" . GHC.Int.$fIxInt64_$cindex_closure" {
     GHC.Int.$fIxInt64_$cindex_closure:
         const GHC.Int.$fIxInt64_$cindex_info;
         const 0;
 },
 GHC.Int.$fIxInt64_$cindex_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AGi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4AGr; else goto c4AGs;
       c4AGr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fIxInt64_$cindex_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AGs: // global
           I64[Sp - 16] = block_c4AGf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AH1; else goto c4AGg;
       u4AH1: // global
           call _c4AGf(R1) args: 0, res: 0, upd: 0;
       c4AGg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fIxInt64_$cindex_info" {
     GHC.Int.$fIxInt64_$cindex_info:
         const GHC.Int.$fIxInt64_$cindex_entry;
         const 0;
         const 281479271677966;
         const 8589934607;
         const S4wm5_srt+1040;
 },
 _c4AGf() //  [R1]
         { []
         }
     {offset
       c4AGf: // global
           I64[Sp - 8] = block_c4AGl_info;
           _s4wcQ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s4wcQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AH0; else goto c4AGm;
       u4AH0: // global
           call _c4AGl(R1) args: 0, res: 0, upd: 0;
       c4AGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AGf_info" {
     block_c4AGf_info:
         const _c4AGf;
         const 1;
         const 4294967326;
         const S4wm5_srt+1040;
 },
 _c4AGl() //  [R1]
         { []
         }
     {offset
       c4AGl: // global
           I64[Sp] = block_c4AGq_info;
           _s4wcS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4wcS::I64;
           if (R1 & 7 != 0) goto u4AH2; else goto c4AGv;
       u4AH2: // global
           call _c4AGq(R1) args: 0, res: 0, upd: 0;
       c4AGv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AGl_info" {
     block_c4AGl_info:
         const _c4AGl;
         const 2;
         const 4294967326;
         const S4wm5_srt+1040;
 },
 _c4AGq() //  [R1]
         { []
         }
     {offset
       c4AGq: // global
           _s4wcU::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _s4wcU::I64)) goto c4AGD; else goto c4AGH;
       c4AGD: // global
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4AGH: // global
           I64[Sp] = block_c4AGG_info;
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wcU::I64;
           if (R1 & 7 != 0) goto u4AH3; else goto c4AGI;
       u4AH3: // global
           call _c4AGG(R1) args: 0, res: 0, upd: 0;
       c4AGI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AGq_info" {
     block_c4AGq_info:
         const _c4AGq;
         const 130;
         const 4294967326;
         const S4wm5_srt+1040;
 },
 _c4AGG() //  [R1]
         { []
         }
     {offset
       c4AGG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AGO; else goto c4AGN;
       c4AGO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4AGN: // global
           _s4wcU::I64 = I64[Sp + 8];
           if (%MO_S_Gt_W64(_s4wcU::I64,
                            I64[R1 + 7])) goto c4AGS; else goto c4AGZ;
       c4AGS: // global
           Hp = Hp - 16;
           R1 = GHC.Arr.hopelessIndexError_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4AGZ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4wcU::I64 - I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AGG_info" {
     block_c4AGG_info:
         const _c4AGG;
         const 194;
         const 4294967326;
         const S4wm5_srt+1040;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.034237085 UTC

[section ""data" . GHC.Int.$fIxInt64_closure" {
     GHC.Int.$fIxInt64_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Int.$fOrdInt64_closure+1;
         const GHC.Int.$fIxInt64_$crange_closure+1;
         const GHC.Int.$fIxInt64_$cindex_closure+2;
         const GHC.Int.$fIxInt64_$cunsafeIndex_closure+2;
         const GHC.Int.$fIxInt64_$cinRange_closure+2;
         const GHC.Int.$fIxInt64_$crangeSize_closure+1;
         const GHC.Int.$fIxInt64_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.037762865 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowsPrec_closure" {
     GHC.Int.$fShowInt64_$cshowsPrec_closure:
         const GHC.Int.$fShowInt64_$cshowsPrec_info;
 },
 GHC.Int.$fShowInt64_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c4AHH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4AHS; else goto c4AHT;
       c4AHS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AHT: // global
           I64[Sp - 24] = block_c4AHE_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4AI0; else goto c4AHF;
       u4AI0: // global
           call _c4AHE(R1) args: 0, res: 0, upd: 0;
       c4AHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt64_$cshowsPrec_info" {
     GHC.Int.$fShowInt64_$cshowsPrec_info:
         const GHC.Int.$fShowInt64_$cshowsPrec_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _c4AHE() //  [R1]
         { []
         }
     {offset
       c4AHE: // global
           I64[Sp] = block_c4AHK_info;
           _s4wd4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4wd4::I64;
           if (R1 & 7 != 0) goto u4AHZ; else goto c4AHL;
       u4AHZ: // global
           call _c4AHK(R1) args: 0, res: 0, upd: 0;
       c4AHL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AHE_info" {
     block_c4AHE_info:
         const _c4AHE;
         const 2;
         const 30;
 },
 _c4AHK() //  [R1]
         { []
         }
     {offset
       c4AHK: // global
           _s4wd2::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4AHP_info;
           R4 = _s4wd2::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AHK_info" {
     block_c4AHK_info:
         const _c4AHK;
         const 66;
         const 30;
 },
 _c4AHP() //  [R1, R2]
         { []
         }
     {offset
       c4AHP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4AHY; else goto c4AHX;
       c4AHY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4AHX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AHP_info" {
     block_c4AHP_info:
         const _c4AHP;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.048052367 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshow_closure" {
     GHC.Int.$fShowInt64_$cshow_closure:
         const GHC.Int.$fShowInt64_$cshow_info;
 },
 GHC.Int.$fShowInt64_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c4AIt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4AIz; else goto c4AIA;
       c4AIz: // global
           R2 = R2;
           R1 = GHC.Int.$fShowInt64_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AIA: // global
           I64[Sp - 8] = block_c4AIq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4AIF; else goto c4AIr;
       u4AIF: // global
           call _c4AIq(R1) args: 0, res: 0, upd: 0;
       c4AIr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt64_$cshow_info" {
     GHC.Int.$fShowInt64_$cshow_info:
         const GHC.Int.$fShowInt64_$cshow_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c4AIq() //  [R1]
         { []
         }
     {offset
       c4AIq: // global
           I64[Sp] = block_c4AIw_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AIq_info" {
     block_c4AIq_info:
         const _c4AIq;
         const 0;
         const 30;
 },
 _c4AIw() //  [R1, R2]
         { []
         }
     {offset
       c4AIw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4AIE; else goto c4AID;
       c4AIE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4AID: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AIw_info" {
     block_c4AIw_info:
         const _c4AIw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.056032872 UTC

[section ""data" . GHC.Int.$fShowInt3_closure" {
     GHC.Int.$fShowInt3_closure:
         const GHC.Int.$fShowInt3_info;
 },
 GHC.Int.$fShowInt3_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AJ4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4AJa; else goto c4AJb;
       c4AJa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Int.$fShowInt3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4AJb: // global
           I64[Sp - 16] = block_c4AJ1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4AJg; else goto c4AJ2;
       u4AJg: // global
           call _c4AJ1(R1) args: 0, res: 0, upd: 0;
       c4AJ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt3_info" {
     GHC.Int.$fShowInt3_info:
         const GHC.Int.$fShowInt3_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c4AJ1() //  [R1]
         { []
         }
     {offset
       c4AJ1: // global
           _s4wdh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4AJ7_info;
           R4 = _s4wdh::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AJ1_info" {
     block_c4AJ1_info:
         const _c4AJ1;
         const 1;
         const 30;
 },
 _c4AJ7() //  [R1, R2]
         { []
         }
     {offset
       c4AJ7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4AJf; else goto c4AJe;
       c4AJf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4AJe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4AJ7_info" {
     block_c4AJ7_info:
         const _c4AJ7;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.064296416 UTC

[section ""data" . GHC.Int.$fShowInt64_$cshowList_closure" {
     GHC.Int.$fShowInt64_$cshowList_closure:
         const GHC.Int.$fShowInt64_$cshowList_info;
 },
 GHC.Int.$fShowInt64_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AJB: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Int.$fShowInt3_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.$fShowInt64_$cshowList_info" {
     GHC.Int.$fShowInt64_$cshowList_info:
         const GHC.Int.$fShowInt64_$cshowList_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.067711823 UTC

[section ""data" . GHC.Int.$fShowInt64_closure" {
     GHC.Int.$fShowInt64_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Int.$fShowInt64_$cshowsPrec_closure+3;
         const GHC.Int.$fShowInt64_$cshow_closure+1;
         const GHC.Int.$fShowInt64_$cshowList_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.069961971 UTC

[section ""data" . GHC.Int.uncheckedIShiftL64#_closure" {
     GHC.Int.uncheckedIShiftL64#_closure:
         const GHC.Int.uncheckedIShiftL64#_info;
 },
 GHC.Int.uncheckedIShiftL64#_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AJO: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.uncheckedIShiftL64#_info" {
     GHC.Int.uncheckedIShiftL64#_info:
         const GHC.Int.uncheckedIShiftL64#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.073985061 UTC

[section ""data" . GHC.Int.uncheckedIShiftRA64#_closure" {
     GHC.Int.uncheckedIShiftRA64#_closure:
         const GHC.Int.uncheckedIShiftRA64#_info;
 },
 GHC.Int.uncheckedIShiftRA64#_entry() //  [R2, R3]
         { []
         }
     {offset
       c4AK2: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.uncheckedIShiftRA64#_info" {
     GHC.Int.uncheckedIShiftRA64#_info:
         const GHC.Int.uncheckedIShiftRA64#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.077295716 UTC

[section ""cstring" . GHC.Int.$trModule4_bytes" {
     GHC.Int.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.079102043 UTC

[section ""data" . GHC.Int.$trModule3_closure" {
     GHC.Int.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.080934534 UTC

[section ""cstring" . GHC.Int.$trModule2_bytes" {
     GHC.Int.$trModule2_bytes:
         I8[] [71,72,67,46,73,110,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.083326506 UTC

[section ""data" . GHC.Int.$trModule1_closure" {
     GHC.Int.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.084995679 UTC

[section ""data" . GHC.Int.$trModule_closure" {
     GHC.Int.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Int.$trModule3_closure+1;
         const GHC.Int.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.086856489 UTC

[section ""data" . $krep_r4kPB_closure" {
     $krep_r4kPB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.088523079 UTC

[section ""data" . GHC.Int.$tcInt7_closure" {
     GHC.Int.$tcInt7_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt9_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.090380627 UTC

[section ""data" . GHC.Int.$tcInt8_closure" {
     GHC.Int.$tcInt8_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt7_closure+1;
         const GHC.Types.krep$*_closure;
         const 1422706860619545536;
         const 2126344328513082648;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.092207319 UTC

[section ""data" . $krep1_r4kPC_closure" {
     $krep1_r4kPC_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt8_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.094025211 UTC

[section ""data" . GHC.Int.$tc'I8#1_closure" {
     GHC.Int.$tc'I8#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep1_r4kPC_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.095729184 UTC

[section ""cstring" . GHC.Int.$tc'I8#3_bytes" {
     GHC.Int.$tc'I8#3_bytes:
         I8[] [39,73,56,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.097511851 UTC

[section ""data" . GHC.Int.$tc'I8#2_closure" {
     GHC.Int.$tc'I8#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I8#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.099793463 UTC

[section ""data" . GHC.Int.$tc'I8#_closure" {
     GHC.Int.$tc'I8#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I8#2_closure+1;
         const GHC.Int.$tc'I8#1_closure+4;
         const 5349338056284818619;
         const 13298037281129101406;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.101848985 UTC

[section ""data" . GHC.Int.$tcInt1_closure" {
     GHC.Int.$tcInt1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.103569818 UTC

[section ""data" . GHC.Int.$tcInt16_closure" {
     GHC.Int.$tcInt16_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16329117591681623238;
         const 13363230803330610095;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.105467574 UTC

[section ""data" . $krep2_r4kPD_closure" {
     $krep2_r4kPD_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt16_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.107280138 UTC

[section ""data" . GHC.Int.$tc'I16#1_closure" {
     GHC.Int.$tc'I16#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep2_r4kPD_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.109040284 UTC

[section ""cstring" . GHC.Int.$tc'I16#3_bytes" {
     GHC.Int.$tc'I16#3_bytes:
         I8[] [39,73,49,54,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.111155733 UTC

[section ""data" . GHC.Int.$tc'I16#2_closure" {
     GHC.Int.$tc'I16#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I16#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.112972411 UTC

[section ""data" . GHC.Int.$tc'I16#_closure" {
     GHC.Int.$tc'I16#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I16#2_closure+1;
         const GHC.Int.$tc'I16#1_closure+4;
         const 1077432500071562197;
         const 13676251251348512601;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.114923095 UTC

[section ""data" . GHC.Int.$tcInt3_closure" {
     GHC.Int.$tcInt3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.116873244 UTC

[section ""data" . GHC.Int.$tcInt32_closure" {
     GHC.Int.$tcInt32_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt3_closure+1;
         const GHC.Types.krep$*_closure;
         const 5115671124548181797;
         const 6203735229629729265;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.119284239 UTC

[section ""data" . $krep3_r4kPE_closure" {
     $krep3_r4kPE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt32_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.121004058 UTC

[section ""data" . GHC.Int.$tc'I32#1_closure" {
     GHC.Int.$tc'I32#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep3_r4kPE_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.122769898 UTC

[section ""cstring" . GHC.Int.$tc'I32#3_bytes" {
     GHC.Int.$tc'I32#3_bytes:
         I8[] [39,73,51,50,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.12451045 UTC

[section ""data" . GHC.Int.$tc'I32#2_closure" {
     GHC.Int.$tc'I32#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I32#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.127201334 UTC

[section ""data" . GHC.Int.$tc'I32#_closure" {
     GHC.Int.$tc'I32#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I32#2_closure+1;
         const GHC.Int.$tc'I32#1_closure+4;
         const 14037617528454219662;
         const 2752255350980319305;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.129075875 UTC

[section ""data" . GHC.Int.$tcInt5_closure" {
     GHC.Int.$tcInt5_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tcInt6_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.130926713 UTC

[section ""data" . GHC.Int.$tcInt64_closure" {
     GHC.Int.$tcInt64_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tcInt5_closure+1;
         const GHC.Types.krep$*_closure;
         const 15049343324344240059;
         const 14445320765379163718;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.132864783 UTC

[section ""data" . $krep4_r4kPF_closure" {
     $krep4_r4kPF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt64_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.134751988 UTC

[section ""data" . GHC.Int.$tc'I64#1_closure" {
     GHC.Int.$tc'I64#1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4kPB_closure+1;
         const $krep4_r4kPF_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.137052862 UTC

[section ""cstring" . GHC.Int.$tc'I64#3_bytes" {
     GHC.Int.$tc'I64#3_bytes:
         I8[] [39,73,54,52,35]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.138801148 UTC

[section ""data" . GHC.Int.$tc'I64#2_closure" {
     GHC.Int.$tc'I64#2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Int.$tc'I64#3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.140552832 UTC

[section ""data" . GHC.Int.$tc'I64#_closure" {
     GHC.Int.$tc'I64#_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Int.$trModule_closure+1;
         const GHC.Int.$tc'I64#2_closure+1;
         const GHC.Int.$tc'I64#1_closure+4;
         const 7755385358338959724;
         const 8520529638322167079;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.143161215 UTC

[section ""data" . GHC.Int.I8#_closure" {
     GHC.Int.I8#_closure:
         const GHC.Int.I8#_info;
 },
 GHC.Int.I8#_entry() //  [R2]
         { []
         }
     {offset
       c4AKO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AKS; else goto c4AKR;
       c4AKS: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I8#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AKR: // global
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I8#_info" {
     GHC.Int.I8#_info:
         const GHC.Int.I8#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.147142322 UTC

[section ""data" . GHC.Int.I16#_closure" {
     GHC.Int.I16#_closure:
         const GHC.Int.I16#_info;
 },
 GHC.Int.I16#_entry() //  [R2]
         { []
         }
     {offset
       c4AL4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4AL8; else goto c4AL7;
       c4AL8: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I16#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4AL7: // global
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I16#_info" {
     GHC.Int.I16#_info:
         const GHC.Int.I16#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.151398042 UTC

[section ""data" . GHC.Int.I32#_closure" {
     GHC.Int.I32#_closure:
         const GHC.Int.I32#_info;
 },
 GHC.Int.I32#_entry() //  [R2]
         { []
         }
     {offset
       c4ALk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ALo; else goto c4ALn;
       c4ALo: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I32#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ALn: // global
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I32#_info" {
     GHC.Int.I32#_info:
         const GHC.Int.I32#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.156744654 UTC

[section ""data" . GHC.Int.I64#_closure" {
     GHC.Int.I64#_closure:
         const GHC.Int.I64#_info;
 },
 GHC.Int.I64#_entry() //  [R2]
         { []
         }
     {offset
       c4ALA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ALE; else goto c4ALD;
       c4ALE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Int.I64#_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ALD: // global
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I64#_info" {
     GHC.Int.I64#_info:
         const GHC.Int.I64#_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.160535411 UTC

[section ""cstring" . i4ALM_str" {
     i4ALM_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,110,116,46,73,56,35]
 },
 GHC.Int.I8#_con_entry() //  [R1]
         { []
         }
     {offset
       c4ALL: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I8#_con_info" {
     GHC.Int.I8#_con_info:
         const GHC.Int.I8#_con_entry;
         const 4294967296;
         const 3;
         const i4ALM_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.163966102 UTC

[section ""cstring" . i4ALT_str" {
     i4ALT_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,110,116,46,73,49,54,35]
 },
 GHC.Int.I16#_con_entry() //  [R1]
         { []
         }
     {offset
       c4ALS: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I16#_con_info" {
     GHC.Int.I16#_con_info:
         const GHC.Int.I16#_con_entry;
         const 4294967296;
         const 3;
         const i4ALT_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.167374912 UTC

[section ""cstring" . i4AM0_str" {
     i4AM0_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,110,116,46,73,51,50,35]
 },
 GHC.Int.I32#_con_entry() //  [R1]
         { []
         }
     {offset
       c4ALZ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I32#_con_info" {
     GHC.Int.I32#_con_info:
         const GHC.Int.I32#_con_entry;
         const 4294967296;
         const 3;
         const i4AM0_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.170712368 UTC

[section ""cstring" . i4AM7_str" {
     i4AM7_str:
         I8[] [98,97,115,101,58,71,72,67,46,73,110,116,46,73,54,52,35]
 },
 GHC.Int.I64#_con_entry() //  [R1]
         { []
         }
     {offset
       c4AM6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Int.I64#_con_info" {
     GHC.Int.I64#_con_info:
         const GHC.Int.I64#_con_entry;
         const 4294967296;
         const 3;
         const i4AM7_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:27.175445247 UTC

[section ""relreadonly" . S4wm5_srt" {
     S4wm5_srt:
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt8_$cpred_closure;
         const GHC.Int.$fEnumInt7_closure;
         const GHC.Int.$fEnumInt8_$csucc_closure;
         const GHC.Int.$fEnumInt9_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const lvl_r4kPr_closure;
         const GHC.Int.$wlvl2_closure;
         const GHC.Int.$fEnumInt8_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum2_closure;
         const GHC.Int.$w$cenumFromThenTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo3_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Int.$wgo3_closure;
         const GHC.Int.$fEnumInt8_go_closure;
         const GHC.Int.$fEnumInt8_$cenumFrom_closure;
         const GHC.Int.$fEnumInt8_closure;
         const GHC.Int.$fEnumInt16_$cpred_closure;
         const GHC.Int.$fEnumInt1_closure;
         const GHC.Int.$fEnumInt16_$csucc_closure;
         const GHC.Int.$fEnumInt2_closure;
         const lvl2_r4kPt_closure;
         const GHC.Int.$wlvl_closure;
         const GHC.Int.$fEnumInt16_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum_closure;
         const GHC.Int.$w$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromThenTo_closure;
         const GHC.Int.$w$cenumFromTo_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$wgo_closure;
         const GHC.Int.$fEnumInt16_go_closure;
         const GHC.Int.$fEnumInt16_$cenumFrom_closure;
         const GHC.Int.$fEnumInt16_closure;
         const GHC.Enum.predError_closure;
         const GHC.Enum.succError_closure;
         const GHC.Int.$fEnumInt32_$cpred_closure;
         const GHC.Int.$fEnumInt3_closure;
         const GHC.Int.$fEnumInt32_$csucc_closure;
         const GHC.Int.$fEnumInt4_closure;
         const lvl4_r4kPv_closure;
         const GHC.Enum.$wtoEnumError_closure;
         const GHC.Int.$wlvl1_closure;
         const GHC.Int.$fEnumInt32_$ctoEnum_closure;
         const GHC.Int.$w$ctoEnum1_closure;
         const GHC.Int.$w$cenumFromTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$wgo1_closure;
         const GHC.Int.$fEnumInt32_go_closure;
         const GHC.Int.$fEnumInt32_$cenumFrom_closure;
         const GHC.Int.$w$cenumFromThenTo1_closure;
         const GHC.Int.$fEnumInt32_$cenumFromThenTo_closure;
         const GHC.Int.$fEnumInt32_closure;
         const GHC.Int.$fEnumInt64_$cpred_closure;
         const GHC.Int.$fEnumInt5_closure;
         const GHC.Int.$fEnumInt64_$csucc_closure;
         const GHC.Int.$fEnumInt6_closure;
         const GHC.Int.$fEnumInt64_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Int.$fReadInt8_$creadsPrec_closure;
         const GHC.Int.$fReadInt13_closure;
         const GHC.Read.list_closure;
         const GHC.Int.$fReadInt12_closure;
         const GHC.Int.$fReadInt11_closure;
         const GHC.Int.$fReadInt8_$creadList_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Int.$fIntegralInt8_$cquot_closure;
         const GHC.Int.$fIntegralInt8_$crem_closure;
         const GHC.Int.$w$cdiv3_closure;
         const GHC.Int.$fIntegralInt8_$cdiv_closure;
         const GHC.Int.$fIntegralInt8_$cmod_closure;
         const GHC.Int.$fIntegralInt8_$cquotRem_closure;
         const lvl6_r4kPx_closure;
         const GHC.Int.$w$cdivMod3_closure;
         const GHC.Int.$fIntegralInt8_$cdivMod_closure;
         const sat_s4vTi_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Int.$fRealInt8_$ctoRational_closure;
         const GHC.Int.$fIxInt8_$crange_closure;
         const GHC.Int.$fEnumInt8_$cenumFromTo_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fIxInt8_$cindex_closure;
         const GHC.Int.$fReadInt16_$creadsPrec_closure;
         const GHC.Int.$fReadInt3_closure;
         const GHC.Int.$fReadInt2_closure;
         const GHC.Int.$fReadInt1_closure;
         const GHC.Int.$fReadInt16_$creadList_closure;
         const GHC.Int.$fIntegralInt16_$cquot_closure;
         const GHC.Int.$fIntegralInt16_$crem_closure;
         const GHC.Int.$w$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cdiv_closure;
         const GHC.Int.$fIntegralInt16_$cmod_closure;
         const GHC.Int.$fIntegralInt16_$cquotRem_closure;
         const lvl7_r4kPy_closure;
         const GHC.Int.$w$cdivMod_closure;
         const GHC.Int.$fIntegralInt16_$cdivMod_closure;
         const GHC.Int.$fRealInt16_$ctoRational_closure;
         const GHC.Int.$fIxInt16_$crange_closure;
         const GHC.Int.$fEnumInt16_$cenumFromTo_closure;
         const GHC.Int.$fIxInt16_$cindex_closure;
         const GHC.Int.$fReadInt32_$creadsPrec_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Int.$fReadInt6_closure;
         const GHC.Int.$fReadInt5_closure;
         const GHC.Int.$fReadInt4_closure;
         const GHC.Int.$fReadInt32_$creadList_closure;
         const GHC.Int.$fIntegralInt32_$cquot_closure;
         const GHC.Real.overflowError_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Int.$fIntegralInt32_$crem_closure;
         const GHC.Int.$w$cdiv1_closure;
         const GHC.Int.$fIntegralInt32_$cdiv_closure;
         const GHC.Int.$fIntegralInt32_$cmod_closure;
         const GHC.Int.$fIntegralInt32_$cquotRem_closure;
         const lvl8_r4kPz_closure;
         const GHC.Int.$w$cdivMod1_closure;
         const GHC.Int.$fIntegralInt32_$cdivMod_closure;
         const GHC.Int.$fRealInt32_$ctoRational_closure;
         const GHC.Int.$fRealInt1_closure;
         const GHC.Real.$w$sreduce_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Int.$fIxInt32_$crange_closure;
         const GHC.Int.$fEnumInt32_$cenumFromTo_closure;
         const GHC.Int.$fIxInt32_$cindex_closure;
         const GHC.Arr.hopelessIndexError_closure;
         const GHC.Int.$fReadInt64_$creadsPrec_closure;
         const GHC.Int.$fReadInt10_closure;
         const GHC.Int.$fReadInt9_closure;
         const GHC.Int.$fReadInt7_closure;
         const GHC.Int.$fReadInt64_$creadList_closure;
         const GHC.Int.$fIntegralInt64_$cquot_closure;
         const GHC.Int.$fIntegralInt64_$crem_closure;
         const GHC.Int.$fIntegralInt64_$cdiv_closure;
         const GHC.Int.$w$cdiv2_closure;
         const GHC.Int.$fIntegralInt64_$cmod_closure;
         const GHC.Int.$fIntegralInt64_$cquotRem_closure;
         const lvl9_r4kPA_closure;
         const GHC.Int.$w$cdivMod2_closure;
         const GHC.Int.$fIntegralInt64_$cdivMod_closure;
         const GHC.Int.$fRealInt64_$ctoRational_closure;
         const GHC.Int.$fIxInt64_$cindex_closure;
 }]

