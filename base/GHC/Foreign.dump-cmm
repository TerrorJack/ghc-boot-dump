
==================== Output Cmm ====================
2018-03-16 16:04:02.528827957 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:02.529531624 UTC

[section ""cstring" . GHC.Foreign.$trModule4_bytes" {
     GHC.Foreign.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.53013617 UTC

[section ""data" . GHC.Foreign.$trModule3_closure" {
     GHC.Foreign.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Foreign.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.530763672 UTC

[section ""cstring" . GHC.Foreign.$trModule2_bytes" {
     GHC.Foreign.$trModule2_bytes:
         I8[] [71,72,67,46,70,111,114,101,105,103,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.531380706 UTC

[section ""data" . GHC.Foreign.$trModule1_closure" {
     GHC.Foreign.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Foreign.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.531992612 UTC

[section ""data" . GHC.Foreign.$trModule_closure" {
     GHC.Foreign.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Foreign.$trModule3_closure+1;
         const GHC.Foreign.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.537712327 UTC

[section ""data" . $wpeekCStringLen_r8TNn_closure" {
     $wpeekCStringLen_r8TNn_closure:
         const $wpeekCStringLen_r8TNn_info;
         const 0;
 },
 sat_s8TOF_entry() //  [R1]
         { info_tbl: [(c8U3I,
                       label: sat_s8TOF_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U3I: // global
           _s8TOF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8U3J; else goto c8U3K;
       c8U3K: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8U3M; else goto c8U3L;
       c8U3M: // global
           HpAlloc = 40;
           goto c8U3J;
       c8U3J: // global
           R1 = _s8TOF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8U3L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8TOF::P64;
           _s8TOu::P64 = P64[_s8TOF::P64 + 16];
           _s8TOC::P64 = P64[_s8TOF::P64 + 24];
           _s8TOy::I64 = I64[_s8TOF::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TOy::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TOu::P64;
           R3 = _s8TOC::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TOW_entry() //  [R1]
         { info_tbl: [(c8U3V,
                       label: sat_s8TOW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U3V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8U3W; else goto c8U3X;
       c8U3W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8U3X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8TNW_entry() //  [R1, R2]
         { info_tbl: [(c8U3Y,
                       label: $wgo_s8TNW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U3Y: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8U3Z; else goto c8U40;
       c8U3Z: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8U40: // global
           I64[Sp - 32] = block_c8U2n_info;
           _s8TNW::P64 = R1;
           _s8TNV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8TNV::P64;
           P64[Sp - 16] = _s8TNW::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8U5A; else goto c8U2o;
       u8U5A: // global
           call _c8U2n(R1) args: 0, res: 0, upd: 0;
       c8U2o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U2n() //  [R1]
         { info_tbl: [(c8U2n,
                       label: block_c8U2n_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U2n: // global
           _s8TNV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8U2s_info;
           R3 = _s8TNV::P64;
           R2 = P64[Sp + 24];
           _s8TO1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8TO1::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U2s() //  [R1]
         { info_tbl: [(c8U2s,
                       label: block_c8U2s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U2s: // global
           I64[Sp] = block_c8U2u_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8U5s; else goto c8U2v;
       u8U5s: // global
           call _c8U2u(R1) args: 0, res: 0, upd: 0;
       c8U2v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U2u() //  [R1]
         { info_tbl: [(c8U2u,
                       label: block_c8U2u_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U2u: // global
           I64[Sp - 16] = block_c8U2z_info;
           _s8TO9::P64 = P64[R1 + 7];
           _s8TOb::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TOb::P64;
           P64[Sp] = _s8TO9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8U5t; else goto c8U2A;
       u8U5t: // global
           call _c8U2z(R1) args: 0, res: 0, upd: 0;
       c8U2A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U2z() //  [R1]
         { info_tbl: [(c8U2z,
                       label: block_c8U2z_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U2z: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8U4V; else goto c8U4o;
       c8U4V: // global
           I64[Sp + 32] = block_c8U37_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8U5v; else goto c8U38;
       u8U5v: // global
           call _c8U37(R1) args: 0, res: 0, upd: 0;
       c8U38: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8U4o: // global
           I64[Sp] = block_c8U45_info;
           _s8TOc::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TOc::P64;
           if (R1 & 7 != 0) goto u8U5u; else goto c8U4p;
       u8U5u: // global
           call _c8U45(R1) args: 0, res: 0, upd: 0;
       c8U4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U37() //  [R1]
         { info_tbl: [(c8U37,
                       label: block_c8U37_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U37: // global
           _s8TPk::P64 = P64[R1 + 7];
           _s8TPp::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8TPp::I64, 0)) goto c8U5d; else goto c8U5e;
       c8U5d: // global
           P64[Sp - 24] = _s8TPk::P64;
           I64[Sp - 16] = _s8TPp::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8U3p() args: 0, res: 0, upd: 0;
       c8U5e: // global
           call MO_Touch(_s8TPk::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8U3p() //  []
         { info_tbl: [(c8U3p,
                       label: block_c8U3p_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U3p: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8U58; else goto c8U57;
       c8U58: // global
           HpAlloc = 40;
           I64[Sp] = block_c8U3p_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8U57: // global
           _s8TPC::P64 = P64[Sp + 24];
           _s8TPE::I64 = I64[Sp + 16];
           if (_s8TPE::I64 != 0) goto c8U5a; else goto c8U5b;
       c8U5a: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8TPE::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TPC::P64;
           I64[Sp + 16] = _s8TPE::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8U3p() args: 0, res: 0, upd: 0;
       c8U5b: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8TPC::P64;
           Sp = Sp + 8;
           call _c8U4Y() args: 0, res: 0, upd: 0;
     }
 },
 _c8U4Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U4Y: // global
           Hp = Hp + 40;
           _s8TPs::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8U55; else goto c8U54;
       c8U55: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8U4X_info;
           R1 = _s8TPs::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8U54: // global
           _s8TPw::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TPw::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TPs::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8U4X() //  [R1]
         { info_tbl: [(c8U4X,
                       label: block_c8U4X_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U4X: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8U4Y() args: 0, res: 0, upd: 0;
     }
 },
 _c8U45() //  [R1]
         { info_tbl: [(c8U45,
                       label: block_c8U45_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U45: // global
           _s8TOb::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8U4P; else goto c8U4D;
       c8U4P: // global
           I64[Sp + 8] = block_c8U4N_info;
           R1 = _s8TOb::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8U5B; else goto c8U4Q;
       u8U5B: // global
           call _c8U4N(R1) args: 0, res: 0, upd: 0;
       c8U4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8U4D: // global
           _s8TOc::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8U4t_info;
           R3 = _s8TOb::P64;
           R2 = _s8TOc::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U4N() //  [R1]
         { info_tbl: [(c8U4N,
                       label: block_c8U4N_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U4N: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8TOk() args: 0, res: 0, upd: 0;
     }
 },
 _c8U4t() //  [R1]
         { info_tbl: [(c8U4t,
                       label: block_c8U4t_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U4t: // global
           I64[Sp] = block_c8U4v_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8U5C; else goto c8U4w;
       u8U5C: // global
           call _c8U4v(R1) args: 0, res: 0, upd: 0;
       c8U4w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U4v() //  [R1]
         { info_tbl: [(c8U4v,
                       label: block_c8U4v_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U4v: // global
           I64[Sp] = block_c8U4A_info;
           _s8TP2::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8TP2::P64;
           if (R1 & 7 != 0) goto u8U5D; else goto c8U4G;
       u8U5D: // global
           call _c8U4A(R1) args: 0, res: 0, upd: 0;
       c8U4G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U4A() //  [R1]
         { info_tbl: [(c8U4A,
                       label: block_c8U4A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U4A: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8TOk() args: 0, res: 0, upd: 0;
     }
 },
 _s8TOk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TOk: // global
           _s8TOr::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8TOr::I64, 0)) goto c8U4i; else goto c8U4j;
       c8U4i: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8TOr::I64 - 1;
           Sp = Sp - 8;
           call _c8U2Z() args: 0, res: 0, upd: 0;
       c8U4j: // global
           _s8TNW::P64 = P64[Sp + 32];
           _s8TOm::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8U3P_info;
           R2 = _s8TOm::P64;
           R1 = _s8TNW::P64;
           Sp = Sp + 40;
           call $wgo_s8TNW_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U2Z() //  []
         { info_tbl: [(c8U2Z,
                       label: block_c8U2Z_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U2Z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8U4d; else goto c8U4c;
       c8U4d: // global
           HpAlloc = 40;
           I64[Sp] = block_c8U2Z_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8U4c: // global
           _s8TOn::I64 = I64[Sp + 32];
           _s8TOI::P64 = P64[Sp + 16];
           _s8TOK::I64 = I64[Sp + 24];
           if (_s8TOK::I64 != 0) goto c8U4f; else goto c8U4g;
       c8U4f: // global
           _s8TON::I64 = %MO_UU_Conv_W32_W64(I32[_s8TOn::I64 + (_s8TOK::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TON::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TOI::P64;
           I64[Sp + 24] = _s8TOK::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8U2Z() args: 0, res: 0, upd: 0;
       c8U4g: // global
           Hp = Hp - 40;
           _s8TNW::P64 = P64[Sp + 40];
           _s8TOm::P64 = P64[Sp + 48];
           _s8TOy::I64 = %MO_UU_Conv_W32_W64(I32[_s8TOn::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8U3A_info;
           R2 = _s8TOm::P64;
           R1 = _s8TNW::P64;
           I64[Sp + 40] = _s8TOy::I64;
           P64[Sp + 48] = _s8TOI::P64;
           Sp = Sp + 32;
           call $wgo_s8TNW_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U3A() //  [R1]
         { info_tbl: [(c8U3A,
                       label: block_c8U3A_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U3A: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8U4a; else goto c8U49;
       c8U4a: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8U49: // global
           I64[Hp - 32] = sat_s8TOF_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8U3P() //  [R1]
         { info_tbl: [(c8U3P,
                       label: block_c8U3P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U3P: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8U4m; else goto c8U4l;
       c8U4m: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8U4l: // global
           I64[Hp - 16] = sat_s8TOW_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8TPR_entry() //  [R1, R2]
         { info_tbl: [(c8U5I,
                       label: sat_s8TPR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U5I: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8U5J; else goto c8U5K;
       c8U5J: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8U5K: // global
           I64[Sp - 24] = block_c8U1M_info;
           _s8TNu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8TNu::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8U64; else goto c8U1N;
       u8U64: // global
           call _c8U1M(R1) args: 0, res: 0, upd: 0;
       c8U1N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U1M() //  [R1]
         { info_tbl: [(c8U1M,
                       label: block_c8U1M_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U1M: // global
           I64[Sp - 8] = block_c8U1R_info;
           _s8TND::I64 = I64[R1 + 7];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s8TND::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U1R() //  [R1]
         { info_tbl: [(c8U1R,
                       label: block_c8U1R_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U1R: // global
           I64[Sp] = block_c8U1T_info;
           _s8TNG::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TNG::P64;
           if (R1 & 7 != 0) goto u8U63; else goto c8U1U;
       u8U63: // global
           call _c8U1T(R1) args: 0, res: 0, upd: 0;
       c8U1U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U1T() //  [R1]
         { info_tbl: [(c8U1T,
                       label: block_c8U1T_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U1T: // global
           _s8TNI::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s8TNI::I64, 1)) goto c8U61; else goto c8U62;
       c8U61: // global
           _s8TNK::I64 = _s8TNI::I64;
           goto s8TNJ;
       c8U62: // global
           _s8TNK::I64 = 1;
           goto s8TNJ;
       s8TNJ: // global
           _s8TNL::I64 = _s8TNK::I64 << 2;
           if (%MO_S_Ge_W64(_s8TNL::I64, 0)) goto c8U5S; else goto c8U5X;
       c8U5S: // global
           I64[Sp - 24] = block_c8U29_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8TNK::I64;
           I64[Sp - 8] = _s8TNL::I64;
           I64[Sp] = _s8TNI::I64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8U5X: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8U29() //  [R1]
         { info_tbl: [(c8U29,
                       label: block_c8U29_info
                       rep:StackRep [True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U29: // global
           I64[Sp] = block_c8U2b_info;
           _s8TNP::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8TNP::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U2b() //  [R1]
         { info_tbl: [(c8U2b,
                       label: block_c8U2b_info
                       rep:StackRep [True, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U2b: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8U5W; else goto c8U5V;
       c8U5W: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8U5V: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8TNW_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 40];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8TNI::I64 = I64[Sp + 24];
           I64[Hp - 16] = _s8TNI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8TNI::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8TNW_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wpeekCStringLen_r8TNn_entry() //  [R2, R3, R4]
         { info_tbl: [(c8U65,
                       label: $wpeekCStringLen_r8TNn_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U65: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8U66; else goto c8U67;
       c8U66: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wpeekCStringLen_r8TNn_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8U67: // global
           I64[Sp - 24] = block_c8U1C_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8U6b; else goto c8U1D;
       u8U6b: // global
           call _c8U1C(R1) args: 0, res: 0, upd: 0;
       c8U1D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U1C() //  [R1]
         { info_tbl: [(c8U1C,
                       label: block_c8U1C_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U1C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8U6a; else goto c8U69;
       c8U6a: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8U69: // global
           _s8TNy::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8TPR_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TNy::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.585824831 UTC

[section ""data" . peekCStringLen1_r8TNo_closure" {
     peekCStringLen1_r8TNo_closure:
         const peekCStringLen1_r8TNo_info;
         const 0;
 },
 peekCStringLen1_r8TNo_entry() //  [R2, R3]
         { info_tbl: [(c8U6k,
                       label: peekCStringLen1_r8TNo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U6k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8U6l; else goto c8U6m;
       c8U6l: // global
           R3 = R3;
           R2 = R2;
           R1 = peekCStringLen1_r8TNo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8U6m: // global
           I64[Sp - 16] = block_c8U6h_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8U6q; else goto c8U6i;
       u8U6q: // global
           call _c8U6h(R1) args: 0, res: 0, upd: 0;
       c8U6i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U6h() //  [R1]
         { info_tbl: [(c8U6h,
                       label: block_c8U6h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U6h: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wpeekCStringLen_r8TNn_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.587097952 UTC

[section ""data" . GHC.Foreign.peekCStringLen_closure" {
     GHC.Foreign.peekCStringLen_closure:
         const GHC.Foreign.peekCStringLen_info;
         const 0;
 },
 GHC.Foreign.peekCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8U6v,
                       label: GHC.Foreign.peekCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U6v: // global
           R3 = R3;
           R2 = R2;
           call peekCStringLen1_r8TNo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.590526756 UTC

[section ""data" . GHC.Foreign.$wtryFillBufferAndCall_closure" {
     GHC.Foreign.$wtryFillBufferAndCall_closure:
         const GHC.Foreign.$wtryFillBufferAndCall_info;
 },
 GHC.Foreign.$wtryFillBufferAndCall_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U6z: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8TRg_entry() //  [R1]
         { info_tbl: [(c8U6M,
                       label: sat_s8TRg_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U6M: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8U6R; else goto c8U6S;
       c8U6R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8U6S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8U6J_info;
           _s8TQ8::P64 = P64[R1 + 24];
           _s8TQ2::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8TQ2::I64;
           P64[Sp - 24] = _s8TQ8::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8U6W; else goto c8U6K;
       u8U6W: // global
           call _c8U6J(R1) args: 0, res: 0, upd: 0;
       c8U6K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8U6J() //  [R1]
         { info_tbl: [(c8U6J,
                       label: block_c8U6J_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U6J: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8U6V; else goto c8U6U;
       c8U6V: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8U6U: // global
           _s8TRe::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8TRe::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Foreign.$wtryFillBufferAndCall_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8U71,
                       label: GHC.Foreign.$wtryFillBufferAndCall_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U71: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8U72; else goto c8U73;
       c8U72: // global
           R1 = GHC.Foreign.$wtryFillBufferAndCall_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       c8U73: // global
           I64[Sp - 48] = block_c8U6D_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U6D() //  [R1]
         { info_tbl: [(c8U6D,
                       label: block_c8U6D_info
                       rep:StackRep [False, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U6D: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8U76; else goto c8U75;
       c8U76: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8U75: // global
           I64[Hp - 32] = sat_s8TRg_info;
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 40];
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = P64[Sp + 32];
           Sp = Sp + 8;
           call _c8U8B() args: 0, res: 0, upd: 0;
     }
 },
 _c8U8B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U8B: // global
           I64[Sp - 8] = block_c8U8D_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U8D() //  [R1]
         { info_tbl: [(c8U8D,
                       label: block_c8U8D_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U8D: // global
           I64[Sp] = block_c8U8F_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8U9z; else goto c8U8G;
       u8U9z: // global
           call _c8U8F(R1) args: 0, res: 0, upd: 0;
       c8U8G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U8F() //  [R1]
         { info_tbl: [(c8U8F,
                       label: block_c8U8F_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U8F: // global
           I64[Sp] = block_c8U8K_info;
           _s8TQV::P64 = P64[R1 + 7];
           _s8TQX::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp + 40] = _s8TQX::P64;
           P64[Sp + 48] = _s8TQV::P64;
           if (R1 & 7 != 0) goto u8U9A; else goto c8U8O;
       u8U9A: // global
           call _c8U8K(R1) args: 0, res: 0, upd: 0;
       c8U8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U8K() //  [R1]
         { info_tbl: [(c8U8K,
                       label: block_c8U8K_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U8K: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8U9j; else goto c8U8Y;
       c8U9j: // global
           I64[Sp + 16] = block_c8U7c_info;
           R1 = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 40];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u8U9C; else goto c8U84;
       u8U9C: // global
           call _c8U7c(R1) args: 0, res: 0, upd: 0;
       c8U84: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8U8Y: // global
           I64[Sp] = block_c8U8W_info;
           _s8TQY::P64 = R1;
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _s8TQY::P64;
           if (R1 & 7 != 0) goto u8U9B; else goto c8U8Z;
       u8U9B: // global
           call _c8U8W(R1) args: 0, res: 0, upd: 0;
       c8U8Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U7c() //  [R1]
         { info_tbl: [(c8U7c,
                       label: block_c8U7c_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U7c: // global
           if (R1 & 7 == 1) goto u8U9q; else goto c8U8f;
       u8U9q: // global
           Sp = Sp + 8;
           call _s8TQc() args: 0, res: 0, upd: 0;
       c8U8f: // global
           I64[Sp] = block_c8U8d_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u8U9u; else goto c8U8g;
       u8U9u: // global
           call _c8U8d(R1) args: 0, res: 0, upd: 0;
       c8U8g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U8d() //  [R1]
         { info_tbl: [(c8U8d,
                       label: block_c8U8d_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U8d: // global
           if (I64[R1 + 31] - I64[R1 + 47] == 0) goto u8U9r; else goto u8U9s;
       u8U9r: // global
           Sp = Sp + 48;
           call _c8U8w() args: 0, res: 0, upd: 0;
       u8U9s: // global
           Sp = Sp + 8;
           call _s8TQc() args: 0, res: 0, upd: 0;
     }
 },
 _s8TQc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TQc: // global
           I64[Sp - 8] = block_c8U7h_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8U9G; else goto c8U7j;
       u8U9G: // global
           call _c8U7h(R1) args: 0, res: 0, upd: 0;
       c8U7j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U7h() //  [R1]
         { info_tbl: [(c8U7h,
                       label: block_c8U7h_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U7h: // global
           I64[Sp] = block_c8U7n_info;
           _s8TQf::P64 = P64[R1 + 7];
           _s8TQe::I64 = I64[R1 + 23];
           _s8TQi::I64 = I64[R1 + 39];
           _s8TQj::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8TQj::I64;
           I64[Sp + 16] = _s8TQi::I64;
           P64[Sp + 24] = _s8TQf::P64;
           I64[Sp + 32] = _s8TQe::I64;
           if (R1 & 7 != 0) goto u8U9w; else goto c8U7p;
       u8U9w: // global
           call _c8U7n(R1) args: 0, res: 0, upd: 0;
       c8U7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U7n() //  [R1]
         { info_tbl: [(c8U7n,
                       label: block_c8U7n_info
                       rep:StackRep [True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U7n: // global
           _s8TQ4::P64 = P64[Sp + 40];
           _s8TQe::I64 = I64[Sp + 32];
           _s8TQi::I64 = I64[Sp + 16];
           _s8TQj::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c8U7E; else goto c8U7X;
       c8U7E: // global
           Hp = Hp + 56;
           _s8TQk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8U80; else goto c8U7G;
       c8U7G: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s8TQj::I64 - _s8TQi::I64;
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = _s8TQe::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8U7z_info;
           R2 = Hp - 15;
           R1 = _s8TQ4::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       c8U7X: // global
           Hp = Hp + 56;
           _s8TQk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8U80; else goto c8U7Z;
       c8U80: // global
           HpAlloc = 56;
           R1 = _s8TQk::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8U7Z: // global
           I8[_s8TQe::I64 + _s8TQj::I64] = 0 :: W8;
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s8TQj::I64 - _s8TQi::I64;
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = _s8TQe::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8U7T_info;
           R2 = Hp - 15;
           R1 = _s8TQ4::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U7z() //  [R1]
         { info_tbl: [(c8U7z,
                       label: block_c8U7z_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U7z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8U7K; else goto c8U7J;
       c8U7K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8U7J: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8U7T() //  [R1]
         { info_tbl: [(c8U7T,
                       label: block_c8U7T_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U7T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8U83; else goto c8U82;
       c8U83: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8U82: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8U8W() //  [R1]
         { info_tbl: [(c8U8W,
                       label: block_c8U8W_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U8W: // global
           if (R1 & 7 == 2) goto u8U9o; else goto c8U98;
       u8U9o: // global
           Sp = Sp + 64;
           call _c8U8w() args: 0, res: 0, upd: 0;
       c8U98: // global
           I64[Sp] = block_c8U93_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 16];
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U8w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U8w: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8U93() //  [R1]
         { info_tbl: [(c8U93,
                       label: block_c8U93_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U93: // global
           I64[Sp] = block_c8U95_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8U9E; else goto c8U9a;
       u8U9E: // global
           call _c8U95(R1) args: 0, res: 0, upd: 0;
       c8U9a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U95() //  [R1]
         { info_tbl: [(c8U95,
                       label: block_c8U95_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U95: // global
           P64[Sp + 48] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 8;
           call _c8U8B() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.596727609 UTC

[section ""data" . GHC.Foreign.newCStringLen1_closure" {
     GHC.Foreign.newCStringLen1_closure:
         const GHC.Foreign.newCStringLen1_info;
 },
 GHC.Foreign.newCStringLen1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8U9O,
                       label: GHC.Foreign.newCStringLen1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U9O: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8U9S; else goto c8U9T;
       c8U9S: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.newCStringLen1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8U9T: // global
           I64[Sp - 40] = block_c8U9L_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Ua1; else goto c8U9M;
       u8Ua1: // global
           call _c8U9L(R1) args: 0, res: 0, upd: 0;
       c8U9M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U9L() //  [R1]
         { info_tbl: [(c8U9L,
                       label: block_c8U9L_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U9L: // global
           I64[Sp - 8] = block_c8U9R_info;
           _s8TRp::P64 = P64[R1 + 7];
           _s8TRq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8TRq::P64;
           P64[Sp + 24] = _s8TRp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Ua0; else goto c8U9V;
       u8Ua0: // global
           call _c8U9R(R1) args: 0, res: 0, upd: 0;
       c8U9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8U9R() //  [R1]
         { info_tbl: [(c8U9R,
                       label: block_c8U9R_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8U9R: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 40;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.602375314 UTC

[section ""data" . withEncodedCString1_r8TNp_closure" {
     withEncodedCString1_r8TNp_closure:
         const withEncodedCString1_r8TNp_info;
 },
 $wgo_s8TRX_entry() //  [R1, R2]
         { info_tbl: [(c8UaL,
                       label: $wgo_s8TRX_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UaL: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8UaM; else goto c8UaN;
       c8UaM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UaN: // global
           I64[Sp - 56] = block_c8UaG_info;
           _s8TRX::P64 = R1;
           _s8TRx::P64 = P64[R1 + 6];
           _s8TRz::P64 = P64[R1 + 14];
           _s8TRF::P64 = P64[R1 + 22];
           _s8TRW::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 48] = _s8TRx::P64;
           P64[Sp - 40] = _s8TRz::P64;
           P64[Sp - 32] = _s8TRF::P64;
           P64[Sp - 24] = _s8TRW::P64;
           P64[Sp - 16] = _s8TRX::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 56;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UaG() //  [R1]
         { info_tbl: [(c8UaG,
                       label: block_c8UaG_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UaG: // global
           I64[Sp] = block_c8UaI_info;
           _s8TS5::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s8TS5::P64;
           if (R1 & 7 != 0) goto u8Ubm; else goto c8UaJ;
       u8Ubm: // global
           call _c8UaI(R1) args: 0, res: 0, upd: 0;
       c8UaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UaI() //  [R1]
         { info_tbl: [(c8UaI,
                       label: block_c8UaI_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UaI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8UaT; else goto c8UaS;
       c8UaT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UaS: // global
           _s8TS7::P64 = P64[R1 + 7];
           _s8TS8::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48];
           _s8TRz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8UaY_info;
           R6 = P64[Sp + 24] + 16;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 8];
           R3 = _s8TS8::P64;
           R2 = _s8TS7::P64;
           P64[Sp] = Hp - 7;
           P64[Sp + 8] = _s8TRz::P64;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8UaY() //  [R1]
         { info_tbl: [(c8UaY,
                       label: block_c8UaY_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UaY: // global
           I64[Sp] = block_c8Ub0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Ubn; else goto c8Ub2;
       u8Ubn: // global
           call _c8Ub0(R1) args: 0, res: 0, upd: 0;
       c8Ub2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ub0() //  [R1]
         { info_tbl: [(c8Ub0,
                       label: block_c8Ub0_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ub0: // global
           if (R1 & 7 == 1) goto c8Ubc; else goto c8Ubi;
       c8Ubc: // global
           I64[Sp] = block_c8Uba_info;
           R2 = I64[Sp + 32] << 1;
           R1 = P64[Sp + 24];
           call $wgo_s8TRX_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8Ubi: // global
           _s8TSn::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 8]);
           R1 = _s8TSn::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Uba() //  [R1]
         { info_tbl: [(c8Uba,
                       label: block_c8Uba_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uba: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8TSF_entry() //  [R1, R2]
         { info_tbl: [(c8Ubo,
                       label: sat_s8TSF_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ubo: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8Ubp; else goto c8Ubq;
       c8Ubp: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Ubq: // global
           I64[Sp - 40] = block_c8Uag_info;
           R3 = 0;
           _s8TRF::P64 = R2;
           _s8TRy::P64 = P64[R1 + 14];
           R2 = _s8TRy::P64;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = _s8TRy::P64;
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _s8TRF::P64;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uag() //  [R1]
         { info_tbl: [(c8Uag,
                       label: block_c8Uag_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uag: // global
           I64[Sp - 8] = block_c8Uan_info;
           R2 = 4;
           _s8TRH::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TRH::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uan() //  [R1]
         { info_tbl: [(c8Uan,
                       label: block_c8Uan_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uan: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c8UbF() args: 0, res: 0, upd: 0;
     }
 },
 _c8UbF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UbF: // global
           _s8TSv::P64 = P64[Sp];
           I64[Sp] = block_c8UbI_info;
           R1 = _s8TSv::P64;
           if (R1 & 7 != 0) goto u8Uc7; else goto c8UbK;
       u8Uc7: // global
           call _c8UbI(R1) args: 0, res: 0, upd: 0;
       c8UbK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UbI() //  [R1]
         { info_tbl: [(c8UbI,
                       label: block_c8UbI_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UbI: // global
           if (R1 & 7 == 1) goto c8UbQ; else goto c8UbV;
       c8UbQ: // global
           I64[Sp + 8] = block_c8Uax_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8UbV: // global
           I64[Sp - 8] = block_c8UbT_info;
           _s8TSA::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TSA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Uc8; else goto c8UbW;
       u8Uc8: // global
           call _c8UbT(R1) args: 0, res: 0, upd: 0;
       c8UbW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uax() //  [R1]
         { info_tbl: [(c8Uax,
                       label: block_c8Uax_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uax: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8Ubw; else goto c8Ubv;
       c8Ubw: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ubv: // global
           I64[Hp - 104] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = Hp - 103;
           P64[Hp - 72] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 64] = I64[Sp + 8];
           _s8TRH::I64 = I64[Sp + 16];
           I64[Hp - 56] = _s8TRH::I64;
           I64[Hp - 48] = 0;
           I64[Hp - 40] = _s8TRH::I64;
           I64[Hp - 32] = $wgo_s8TRX_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = Hp - 87;
           I64[Sp + 24] = block_c8UbA_info;
           R2 = _s8TRH::I64 + 1;
           R1 = Hp - 30;
           Sp = Sp + 24;
           call $wgo_s8TRX_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UbA() //  [R1]
         { info_tbl: [(c8UbA,
                       label: block_c8UbA_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UbA: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UbT() //  [R1]
         { info_tbl: [(c8UbT,
                       label: block_c8UbT_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UbT: // global
           _s8TSw::I64 = I64[Sp + 16];
           _s8TSA::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TSw::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TSA::P64;
           I64[Sp + 16] = _s8TSw::I64 + 1;
           Sp = Sp + 8;
           call _c8UbF() args: 0, res: 0, upd: 0;
     }
 },
 withEncodedCString1_r8TNp_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Uca,
                       label: withEncodedCString1_r8TNp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uca: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Ucb; else goto c8Ucc;
       c8Ucb: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withEncodedCString1_r8TNp_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ucc: // global
           I64[Sp - 32] = block_c8Ua6_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Ucg; else goto c8Ua7;
       u8Ucg: // global
           call _c8Ua6(R1) args: 0, res: 0, upd: 0;
       c8Ua7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ua6() //  [R1]
         { info_tbl: [(c8Ua6,
                       label: block_c8Ua6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ua6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Ucf; else goto c8Uce;
       c8Ucf: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Uce: // global
           _s8TRE::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_s8TSF_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = Hp - 22;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TRE::P64;
           Sp = Sp + 32;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.609611077 UTC

[section ""data" . GHC.Foreign.withEncodedCString_closure" {
     GHC.Foreign.withEncodedCString_closure:
         const GHC.Foreign.withEncodedCString_info;
 },
 GHC.Foreign.withEncodedCString_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Ucl,
                       label: GHC.Foreign.withEncodedCString_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ucl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withEncodedCString1_r8TNp_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.614097578 UTC

[section ""data" . GHC.Foreign.charIsRepresentable3_closure" {
     GHC.Foreign.charIsRepresentable3_closure:
         const GHC.Foreign.charIsRepresentable3_info;
 },
 $wgo_s8TT6_entry() //  [R1, R2]
         { info_tbl: [(c8Udb,
                       label: $wgo_s8TT6_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Udb: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8Udc; else goto c8Udd;
       c8Udc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Udd: // global
           I64[Sp - 48] = block_c8Ud2_info;
           _s8TT6::P64 = R1;
           _s8TSI::P64 = P64[R1 + 6];
           _s8TSO::P64 = P64[R1 + 14];
           _s8TT5::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _s8TSI::P64;
           P64[Sp - 32] = _s8TSO::P64;
           P64[Sp - 24] = _s8TT5::P64;
           P64[Sp - 16] = _s8TT6::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 48;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ud2() //  [R1]
         { info_tbl: [(c8Ud2,
                       label: block_c8Ud2_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ud2: // global
           I64[Sp - 8] = block_c8Ud4_info;
           _s8TTe::P64 = R1;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp] = _s8TTe::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ud4() //  [R1]
         { info_tbl: [(c8Ud4,
                       label: block_c8Ud4_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ud4: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Udh; else goto c8Udg;
       c8Udh: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Udg: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 24] = P64[Sp + 8] + 16;
           I64[Hp - 16] = I64[Sp + 48];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp] = Hp - 47;
           P64[Sp + 32] = P64[Sp + 32];
           call _c8Uea() args: 0, res: 0, upd: 0;
     }
 },
 _c8Uea() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uea: // global
           I64[Sp - 8] = block_c8Uec_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Ufb; else goto c8Ued;
       u8Ufb: // global
           call _c8Uec(R1) args: 0, res: 0, upd: 0;
       c8Ued: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uec() //  [R1]
         { info_tbl: [(c8Uec,
                       label: block_c8Uec_info
                       rep:StackRep [False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uec: // global
           _s8TTO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Ueh_info;
           R3 = _s8TTO::P64;
           R2 = P64[Sp + 40];
           _s8TTS::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 40] = _s8TTS::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ueh() //  [R1]
         { info_tbl: [(c8Ueh,
                       label: block_c8Ueh_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ueh: // global
           I64[Sp] = block_c8Uej_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Ufc; else goto c8Uek;
       u8Ufc: // global
           call _c8Uej(R1) args: 0, res: 0, upd: 0;
       c8Uek: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uej() //  [R1]
         { info_tbl: [(c8Uej,
                       label: block_c8Uej_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uej: // global
           I64[Sp - 16] = block_c8Ueo_info;
           _s8TU0::P64 = P64[R1 + 7];
           _s8TU2::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TU2::P64;
           P64[Sp] = _s8TU0::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Ufd; else goto c8Uet;
       u8Ufd: // global
           call _c8Ueo(R1) args: 0, res: 0, upd: 0;
       c8Uet: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ueo() //  [R1]
         { info_tbl: [(c8Ueo,
                       label: block_c8Ueo_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ueo: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8UeY; else goto c8UeD;
       c8UeY: // global
           I64[Sp + 16] = block_c8Udz_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u8Uff; else goto c8UdB;
       u8Uff: // global
           call _c8Udz(R1) args: 0, res: 0, upd: 0;
       c8UdB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UeD: // global
           I64[Sp] = block_c8UeB_info;
           _s8TU3::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TU3::P64;
           if (R1 & 7 != 0) goto u8Ufe; else goto c8UeE;
       u8Ufe: // global
           call _c8UeB(R1) args: 0, res: 0, upd: 0;
       c8UeE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Udz() //  [R1]
         { info_tbl: [(c8Udz,
                       label: block_c8Udz_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Udz: // global
           _s8TTy::I64 = I64[R1 + 47];
           _s8TTz::I64 = I64[R1 + 31] - _s8TTy::I64;
           if (_s8TTz::I64 != 0) goto u8Uf6; else goto c8UdX;
       u8Uf6: // global
           I64[Sp + 24] = _s8TTz::I64;
           I64[Sp + 32] = _s8TTy::I64;
           P64[Sp + 40] = P64[R1 + 7];
           I64[Sp + 48] = I64[R1 + 23];
           Sp = Sp + 8;
           call _c8UdK() args: 0, res: 0, upd: 0;
       c8UdX: // global
           I64[Sp] = block_c8Ue4_info;
           R2 = I64[Sp + 48] << 1;
           R1 = P64[Sp + 40];
           call $wgo_s8TT6_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UdK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UdK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8UdS; else goto c8UdR;
       c8UdS: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8UdJ_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8UdR: // global
           _s8TSI::P64 = P64[Sp + 8];
           _s8TTt::I64 = I64[Sp + 40];
           I8[_s8TTt::I64 + I64[Sp + 24]] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8TTt::I64;
           I64[Sp - 8] = block_c8UdN_info;
           R2 = Hp - 7;
           R1 = _s8TSI::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UdJ() //  [R1]
         { info_tbl: [(c8UdJ,
                       label: block_c8UdJ_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UdJ: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8UdK() args: 0, res: 0, upd: 0;
     }
 },
 _c8UdN() //  [R1]
         { info_tbl: [(c8UdN,
                       label: block_c8UdN_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UdN: // global
           _s8TTe::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 40]);
           call MO_Touch(_s8TTe::P64);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Ue4() //  [R1]
         { info_tbl: [(c8Ue4,
                       label: block_c8Ue4_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ue4: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UeB() //  [R1]
         { info_tbl: [(c8UeB,
                       label: block_c8UeB_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UeB: // global
           if (R1 & 7 == 2) goto c8UeX; else goto c8UeN;
       c8UeX: // global
           I64[Sp + 16] = block_c8Udr_info;
           R2 = I64[Sp + 64] << 1;
           R1 = P64[Sp + 56];
           Sp = Sp + 16;
           call $wgo_s8TT6_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8UeN: // global
           _s8TU3::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8UeI_info;
           R3 = P64[Sp + 8];
           R2 = _s8TU3::P64;
           R1 = P64[Sp + 48];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Udr() //  [R1]
         { info_tbl: [(c8Udr,
                       label: block_c8Udr_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Udr: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UeI() //  [R1]
         { info_tbl: [(c8UeI,
                       label: block_c8UeI_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UeI: // global
           I64[Sp] = block_c8UeK_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Ufg; else goto c8UeP;
       u8Ufg: // global
           call _c8UeK(R1) args: 0, res: 0, upd: 0;
       c8UeP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UeK() //  [R1]
         { info_tbl: [(c8UeK,
                       label: block_c8UeK_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UeK: // global
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           call _c8Uea() args: 0, res: 0, upd: 0;
     }
 },
 sat_s8TUB_entry() //  [R1, R2]
         { info_tbl: [(c8Ufi,
                       label: sat_s8TUB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ufi: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8Ufj; else goto c8Ufk;
       c8Ufj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Ufk: // global
           I64[Sp - 32] = block_c8UcC_info;
           R3 = 0;
           _s8TSO::P64 = R2;
           _s8TSH::P64 = P64[R1 + 6];
           R2 = _s8TSH::P64;
           P64[Sp - 24] = _s8TSH::P64;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = _s8TSO::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8UcC() //  [R1]
         { info_tbl: [(c8UcC,
                       label: block_c8UcC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UcC: // global
           I64[Sp - 8] = block_c8UcJ_info;
           R2 = 4;
           _s8TSQ::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TSQ::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UcJ() //  [R1]
         { info_tbl: [(c8UcJ,
                       label: block_c8UcJ_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UcJ: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8Ufz() args: 0, res: 0, upd: 0;
     }
 },
 _c8Ufz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ufz: // global
           _s8TUr::P64 = P64[Sp];
           I64[Sp] = block_c8UfC_info;
           R1 = _s8TUr::P64;
           if (R1 & 7 != 0) goto u8Ug1; else goto c8UfE;
       u8Ug1: // global
           call _c8UfC(R1) args: 0, res: 0, upd: 0;
       c8UfE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UfC() //  [R1]
         { info_tbl: [(c8UfC,
                       label: block_c8UfC_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UfC: // global
           if (R1 & 7 == 1) goto c8UfK; else goto c8UfP;
       c8UfK: // global
           I64[Sp + 8] = block_c8UcT_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8UfP: // global
           I64[Sp - 8] = block_c8UfN_info;
           _s8TUw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TUw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Ug2; else goto c8UfQ;
       u8Ug2: // global
           call _c8UfN(R1) args: 0, res: 0, upd: 0;
       c8UfQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UcT() //  [R1]
         { info_tbl: [(c8UcT,
                       label: block_c8UcT_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UcT: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c8Ufq; else goto c8Ufp;
       c8Ufq: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ufp: // global
           I64[Hp - 96] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = Hp - 95;
           P64[Hp - 64] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 56] = I64[Sp + 8];
           _s8TSQ::I64 = I64[Sp + 16];
           I64[Hp - 48] = _s8TSQ::I64;
           I64[Hp - 40] = 0;
           I64[Hp - 32] = _s8TSQ::I64;
           I64[Hp - 24] = $wgo_s8TT6_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 79;
           I64[Sp + 16] = block_c8Ufu_info;
           R2 = _s8TSQ::I64 + 1;
           R1 = Hp - 22;
           Sp = Sp + 16;
           call $wgo_s8TT6_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ufu() //  [R1]
         { info_tbl: [(c8Ufu,
                       label: block_c8Ufu_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ufu: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UfN() //  [R1]
         { info_tbl: [(c8UfN,
                       label: block_c8UfN_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UfN: // global
           _s8TUs::I64 = I64[Sp + 16];
           _s8TUw::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TUs::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TUw::P64;
           I64[Sp + 16] = _s8TUs::I64 + 1;
           Sp = Sp + 8;
           call _c8Ufz() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Foreign.charIsRepresentable3_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Ug4,
                       label: GHC.Foreign.charIsRepresentable3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ug4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ug5; else goto c8Ug6;
       c8Ug5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ug6: // global
           I64[Sp - 24] = block_c8Ucs_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Uga; else goto c8Uct;
       u8Uga: // global
           call _c8Ucs(R1) args: 0, res: 0, upd: 0;
       c8Uct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ucs() //  [R1]
         { info_tbl: [(c8Ucs,
                       label: block_c8Ucs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ucs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Ug9; else goto c8Ug8;
       c8Ug9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ug8: // global
           _s8TSN::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8TUB_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TSN::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.622343263 UTC

[section ""data" . GHC.Foreign.withCString_closure" {
     GHC.Foreign.withCString_closure:
         const GHC.Foreign.withCString_info;
 },
 GHC.Foreign.withCString_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Ugf,
                       label: GHC.Foreign.withCString_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ugf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.624382194 UTC

[section ""data" . GHC.Foreign.withCStringsLen1_closure" {
     GHC.Foreign.withCStringsLen1_closure:
         const GHC.Foreign.withCStringsLen1_info;
         const 0;
 },
 sat_s8TUL_entry() //  [R1]
         { info_tbl: [(c8UgA,
                       label: sat_s8TUL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UgA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UgB; else goto c8UgC;
       c8UgB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8UgC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TUR_entry() //  [R1, R2]
         { info_tbl: [(c8UgL,
                       label: sat_s8TUR_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UgL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UgP; else goto c8UgO;
       c8UgP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UgO: // global
           _s8TUG::P64 = P64[R1 + 6];
           _s8TUH::P64 = P64[R1 + 14];
           _s8TUN::P64 = P64[R1 + 22];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = _s8TUH::P64;
           R3 = _s8TUN::P64;
           R2 = Hp - 14;
           R1 = _s8TUG::P64;
           call go_s8TUG_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s8TUG_entry() //  [R1, R2, R3]
         { info_tbl: [(c8UgU,
                       label: go_s8TUG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UgU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8UgV; else goto c8UgW;
       c8UgV: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UgW: // global
           I64[Sp - 40] = block_c8Ugr_info;
           _s8TUG::P64 = R1;
           _s8TUC::P64 = P64[R1 + 5];
           _s8TUE::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 32] = _s8TUC::P64;
           P64[Sp - 24] = _s8TUE::P64;
           P64[Sp - 16] = _s8TUG::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Uh3; else goto c8Ugs;
       u8Uh3: // global
           call _c8Ugr(R1) args: 0, res: 0, upd: 0;
       c8Ugs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ugr() //  [R1]
         { info_tbl: [(c8Ugr,
                       label: block_c8Ugr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ugr: // global
           _s8TUH::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c8UgR; else goto c8UgS;
       c8UgR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UgZ; else goto c8UgY;
       c8UgZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UgY: // global
           I64[Hp - 16] = sat_s8TUL_info;
           P64[Hp] = _s8TUH::P64;
           R4 = P64[Sp + 16];
           R3 = Hp - 16;
           R2 = Foreign.Storable.$fStorablePtr_closure;
           I64[Sp + 32] = stg_ap_v_info;
           Sp = Sp + 32;
           call Foreign.Marshal.Array.withArrayLen_entry(R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
       c8UgS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Uh2; else goto c8Uh1;
       c8Uh2: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Uh1: // global
           _s8TUM::P64 = P64[R1 + 6];
           _s8TUN::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s8TUR_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _s8TUH::P64;
           P64[Hp] = _s8TUN::P64;
           R4 = Hp - 22;
           R3 = _s8TUM::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.withCStringsLen1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Uh4,
                       label: GHC.Foreign.withCStringsLen1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uh4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Uh8; else goto c8Uh7;
       c8Uh8: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.withCStringsLen1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Uh7: // global
           I64[Hp - 16] = go_s8TUG_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R3 = R3;
           R2 = GHC.Types.[]_closure+1;
           R1 = Hp - 13;
           call go_s8TUG_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.627227422 UTC

[section ""data" . GHC.Foreign.withCStringsLen_closure" {
     GHC.Foreign.withCStringsLen_closure:
         const GHC.Foreign.withCStringsLen_info;
         const 0;
 },
 GHC.Foreign.withCStringsLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Uhd,
                       label: GHC.Foreign.withCStringsLen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uhd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.628226467 UTC

[section ""data" . GHC.Foreign.withCStringLen_closure" {
     GHC.Foreign.withCStringLen_closure:
         const GHC.Foreign.withCStringLen_info;
 },
 GHC.Foreign.withCStringLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Uhk,
                       label: GHC.Foreign.withCStringLen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uhk: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call GHC.Foreign.withEncodedCString_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.629101915 UTC

[section ""data" . GHC.Foreign.newCString2_closure" {
     GHC.Foreign.newCString2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.632378995 UTC

[section ""data" . newEncodedCString1_r8TNq_closure" {
     newEncodedCString1_r8TNq_closure:
         const newEncodedCString1_r8TNq_info;
         const 0;
 },
 sat_s8TWa_entry() //  [R1, R2]
         { info_tbl: [(c8UiM,
                       label: sat_s8TWa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UiM: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8UiN; else goto c8UiO;
       c8UiN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UiO: // global
           I64[Sp - 32] = block_c8UhB_info;
           R3 = 0;
           _s8TV1::P64 = R2;
           _s8TUV::P64 = P64[R1 + 14];
           R2 = _s8TUV::P64;
           P64[Sp - 24] = P64[R1 + 6];
           P64[Sp - 16] = _s8TUV::P64;
           P64[Sp - 8] = _s8TV1::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8UhB() //  [R1]
         { info_tbl: [(c8UhB,
                       label: block_c8UhB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UhB: // global
           I64[Sp - 8] = block_c8UhI_info;
           R2 = 4;
           _s8TV3::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TV3::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UhI() //  [R1]
         { info_tbl: [(c8UhI,
                       label: block_c8UhI_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UhI: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c8Ujt() args: 0, res: 0, upd: 0;
     }
 },
 _c8Ujt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ujt: // global
           _s8TW0::P64 = P64[Sp];
           I64[Sp] = block_c8Ujw_info;
           R1 = _s8TW0::P64;
           if (R1 & 7 != 0) goto u8Ukb; else goto c8Ujy;
       u8Ukb: // global
           call _c8Ujw(R1) args: 0, res: 0, upd: 0;
       c8Ujy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ujw() //  [R1]
         { info_tbl: [(c8Ujw,
                       label: block_c8Ujw_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ujw: // global
           if (R1 & 7 == 1) goto c8UjE; else goto c8UjJ;
       c8UjE: // global
           I64[Sp + 8] = block_c8UhS_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8UjJ: // global
           I64[Sp - 8] = block_c8UjH_info;
           _s8TW5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TW5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Ukc; else goto c8UjK;
       u8Ukc: // global
           call _c8UjH(R1) args: 0, res: 0, upd: 0;
       c8UjK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UhS() //  [R1]
         { info_tbl: [(c8UhS,
                       label: block_c8UhS_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UhS: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8UiU; else goto c8UiT;
       c8UiU: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UiT: // global
           _s8TV3::I64 = I64[Sp + 16];
           _s8TVb::I64 = I64[Sp + 8];
           _s8TVh::I64 = _s8TV3::I64 + 1;
           (_s8TVm::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8TVh::I64);
           if (_s8TVm::I64 == 0) goto c8Ujq; else goto c8Ujp;
       c8Ujq: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Ujp: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8TVb::I64;
           I64[Hp - 32] = _s8TV3::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8TV3::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TVh::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8TVm::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8Uic() args: 0, res: 0, upd: 0;
     }
 },
 _c8Uic() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uic: // global
           I64[Sp - 8] = block_c8Uif_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Uk4; else goto c8Uig;
       u8Uk4: // global
           call _c8Uif(R1) args: 0, res: 0, upd: 0;
       c8Uig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uif() //  [R1]
         { info_tbl: [(c8Uif,
                       label: block_c8Uif_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uif: // global
           I64[Sp] = block_c8Uik_info;
           R6 = I64[Sp + 16];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 32];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 8];
           P64[Sp - 8] = GHC.Base.$fApplicativeIO4_closure+2;
           Sp = Sp - 16;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Uik() //  [R1]
         { info_tbl: [(c8Uik,
                       label: block_c8Uik_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uik: // global
           I64[Sp] = block_c8Uim_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Uk5; else goto c8Uin;
       u8Uk5: // global
           call _c8Uim(R1) args: 0, res: 0, upd: 0;
       c8Uin: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uim() //  [R1]
         { info_tbl: [(c8Uim,
                       label: block_c8Uim_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uim: // global
           if (R1 & 7 == 1) goto c8Uj4; else goto c8Ujn;
       c8Uj4: // global
           _s8TVw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Uir_info;
           R1 = _s8TVw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Uk6; else goto c8Uis;
       u8Uk6: // global
           call _c8Uir(R1) args: 0, res: 0, upd: 0;
       c8Uis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Ujn: // global
           _s8TVs::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 40]);
           R1 = _s8TVs::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Uir() //  [R1]
         { info_tbl: [(c8Uir,
                       label: block_c8Uir_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uir: // global
           _s8TVK::I64 = I64[R1 + 7] << 1;
           if (_s8TVK::I64 != 0) goto u8UjY; else goto c8Ujg;
       u8UjY: // global
           I64[Sp] = _s8TVK::I64;
           call _c8UiA() args: 0, res: 0, upd: 0;
       c8Ujg: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = GHC.Foreign.newCString2_closure+1;
           call _c8Uic() args: 0, res: 0, upd: 0;
     }
 },
 _c8UiA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UiA: // global
           Hp = Hp + 16;
           _s8TVK::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8Uja; else goto c8Uj9;
       c8Uja: // global
           HpAlloc = 16;
           I64[Sp] = block_c8Uiz_info;
           R1 = _s8TVK::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Uj9: // global
           (_s8TVP::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8TVK::I64);
           if (_s8TVP::I64 == 0) goto c8Ujd; else goto c8Ujc;
       c8Ujd: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Ujc: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TVK::I64;
           I64[Sp + 8] = _s8TVP::I64;
           P64[Sp] = Hp - 7;
           call _c8Uic() args: 0, res: 0, upd: 0;
     }
 },
 _c8Uiz() //  [R1]
         { info_tbl: [(c8Uiz,
                       label: block_c8Uiz_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uiz: // global
           I64[Sp] = R1;
           call _c8UiA() args: 0, res: 0, upd: 0;
     }
 },
 _c8UjH() //  [R1]
         { info_tbl: [(c8UjH,
                       label: block_c8UjH_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UjH: // global
           _s8TW1::I64 = I64[Sp + 16];
           _s8TW5::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TW1::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TW5::P64;
           I64[Sp + 16] = _s8TW1::I64 + 1;
           Sp = Sp + 8;
           call _c8Ujt() args: 0, res: 0, upd: 0;
     }
 },
 newEncodedCString1_r8TNq_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Uke,
                       label: newEncodedCString1_r8TNq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uke: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ukf; else goto c8Ukg;
       c8Ukf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = newEncodedCString1_r8TNq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ukg: // global
           I64[Sp - 24] = block_c8Uhr_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Ukk; else goto c8Uhs;
       u8Ukk: // global
           call _c8Uhr(R1) args: 0, res: 0, upd: 0;
       c8Uhs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uhr() //  [R1]
         { info_tbl: [(c8Uhr,
                       label: block_c8Uhr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uhr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Ukj; else goto c8Uki;
       c8Ukj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Uki: // global
           _s8TV0::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8TWa_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TV0::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.637928472 UTC

[section ""data" . GHC.Foreign.newEncodedCString_closure" {
     GHC.Foreign.newEncodedCString_closure:
         const GHC.Foreign.newEncodedCString_info;
         const 0;
 },
 GHC.Foreign.newEncodedCString_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Ukp,
                       label: GHC.Foreign.newEncodedCString_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ukp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call newEncodedCString1_r8TNq_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.643700394 UTC

[section ""data" . GHC.Foreign.newCString1_closure" {
     GHC.Foreign.newCString1_closure:
         const GHC.Foreign.newCString1_info;
         const 0;
 },
 sat_s8TY4_entry() //  [R1]
         { info_tbl: [(c8Um3,
                       label: sat_s8TY4_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Um3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Um8; else goto c8Um9;
       c8Um8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Um9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8Um0_info;
           _s8TWX::P64 = P64[R1 + 24];
           _s8TWM::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8TWM::I64;
           P64[Sp - 24] = _s8TWX::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Umd; else goto c8Um1;
       u8Umd: // global
           call _c8Um0(R1) args: 0, res: 0, upd: 0;
       c8Um1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Um0() //  [R1]
         { info_tbl: [(c8Um0,
                       label: block_c8Um0_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Um0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Umc; else goto c8Umb;
       c8Umc: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Umb: // global
           _s8TY2::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8TY2::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TYi_entry() //  [R1, R2]
         { info_tbl: [(c8Ume,
                       label: sat_s8TYi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ume: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c8Umf; else goto c8Umg;
       c8Umf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Umg: // global
           I64[Sp - 24] = block_c8UkG_info;
           R3 = 0;
           _s8TWi::P64 = R2;
           _s8TWc::P64 = P64[R1 + 6];
           R2 = _s8TWc::P64;
           P64[Sp - 16] = _s8TWc::P64;
           P64[Sp - 8] = _s8TWi::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8UkG() //  [R1]
         { info_tbl: [(c8UkG,
                       label: block_c8UkG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UkG: // global
           I64[Sp - 8] = block_c8UkN_info;
           R2 = 4;
           _s8TWk::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TWk::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UkN() //  [R1]
         { info_tbl: [(c8UkN,
                       label: block_c8UkN_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UkN: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8Uoj() args: 0, res: 0, upd: 0;
     }
 },
 _c8Uoj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uoj: // global
           _s8TY8::P64 = P64[Sp];
           I64[Sp] = block_c8Uom_info;
           R1 = _s8TY8::P64;
           if (R1 & 7 != 0) goto u8Upu; else goto c8Uoo;
       u8Upu: // global
           call _c8Uom(R1) args: 0, res: 0, upd: 0;
       c8Uoo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uom() //  [R1]
         { info_tbl: [(c8Uom,
                       label: block_c8Uom_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uom: // global
           if (R1 & 7 == 1) goto c8Uou; else goto c8Uoz;
       c8Uou: // global
           I64[Sp + 8] = block_c8UkX_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8Uoz: // global
           I64[Sp - 8] = block_c8Uox_info;
           _s8TYd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TYd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Upv; else goto c8UoA;
       u8Upv: // global
           call _c8Uox(R1) args: 0, res: 0, upd: 0;
       c8UoA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UkX() //  [R1]
         { info_tbl: [(c8UkX,
                       label: block_c8UkX_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UkX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8Umm; else goto c8Uml;
       c8Umm: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Uml: // global
           _s8TWk::I64 = I64[Sp + 16];
           _s8TWs::I64 = I64[Sp + 8];
           _s8TWy::I64 = _s8TWk::I64 + 1;
           (_s8TWD::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8TWy::I64);
           if (_s8TWD::I64 == 0) goto c8Uog; else goto c8Uof;
       c8Uog: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Uof: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8TWs::I64;
           I64[Hp - 32] = _s8TWk::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8TWk::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TWy::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8TWD::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8Ulh() args: 0, res: 0, upd: 0;
     }
 },
 _c8Ulh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ulh: // global
           I64[Sp - 8] = block_c8Ulk_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Upb; else goto c8Ull;
       u8Upb: // global
           call _c8Ulk(R1) args: 0, res: 0, upd: 0;
       c8Ull: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ulk() //  [R1]
         { info_tbl: [(c8Ulk,
                       label: block_c8Ulk_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ulk: // global
           I64[Sp - 16] = block_c8Ulp_info;
           _s8TWQ::P64 = P64[R1 + 7];
           _s8TWR::P64 = P64[R1 + 15];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = _s8TWR::P64;
           P64[Sp] = _s8TWQ::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ulp() //  [R1]
         { info_tbl: [(c8Ulp,
                       label: block_c8Ulp_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ulp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Umv; else goto c8Umu;
       c8Umv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Umu: // global
           I64[Hp - 32] = sat_s8TY4_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 32];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = P64[Sp + 40];
           Sp = Sp - 8;
           call _c8Unv() args: 0, res: 0, upd: 0;
     }
 },
 _c8Unv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Unv: // global
           _s8TXC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Unx_info;
           R3 = P64[Sp];
           R2 = _s8TXC::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Unx() //  [R1]
         { info_tbl: [(c8Unx,
                       label: block_c8Unx_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Unx: // global
           I64[Sp] = block_c8Unz_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Upn; else goto c8UnA;
       u8Upn: // global
           call _c8Unz(R1) args: 0, res: 0, upd: 0;
       c8UnA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Unz() //  [R1]
         { info_tbl: [(c8Unz,
                       label: block_c8Unz_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Unz: // global
           I64[Sp - 16] = block_c8UnE_info;
           _s8TXJ::P64 = P64[R1 + 7];
           _s8TXL::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TXL::P64;
           P64[Sp] = _s8TXJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Upo; else goto c8UnI;
       u8Upo: // global
           call _c8UnE(R1) args: 0, res: 0, upd: 0;
       c8UnI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UnE() //  [R1]
         { info_tbl: [(c8UnE,
                       label: block_c8UnE_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UnE: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8Uod; else goto c8UnS;
       c8Uod: // global
           I64[Sp + 32] = block_c8Un4_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8Upq; else goto c8Un6;
       u8Upq: // global
           call _c8Un4(R1) args: 0, res: 0, upd: 0;
       c8Un6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UnS: // global
           I64[Sp] = block_c8UnQ_info;
           _s8TXM::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TXM::P64;
           if (R1 & 7 != 0) goto u8Upp; else goto c8UnT;
       u8Upp: // global
           call _c8UnQ(R1) args: 0, res: 0, upd: 0;
       c8UnT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Un4() //  [R1]
         { info_tbl: [(c8Un4,
                       label: block_c8Un4_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Un4: // global
           _s8TXs::I64 = I64[R1 + 47];
           _s8TXt::I64 = I64[R1 + 31] - _s8TXs::I64;
           if (_s8TXt::I64 != 0) goto u8Up1; else goto u8Up0;
       u8Up1: // global
           P64[Sp - 32] = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 39];
           I64[Sp - 16] = _s8TXs::I64;
           I64[Sp - 8] = _s8TXt::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8Unh() args: 0, res: 0, upd: 0;
       u8Up0: // global
           Sp = Sp + 8;
           call _c8Uno() args: 0, res: 0, upd: 0;
     }
 },
 _c8Unh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Unh: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Unl; else goto c8Unk;
       c8Unl: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_c8Une_info;
           R1 = I64[Sp + 24];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Unk: // global
           _s8TXn::I64 = I64[Sp + 32];
           _s8TXo::P64 = P64[Sp];
           _s8TXr::I64 = I64[Sp + 8];
           _s8TXs::I64 = I64[Sp + 16];
           I8[_s8TXn::I64 + _s8TXs::I64] = 0 :: W8;
           call MO_Touch(_s8TXo::P64);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _s8TXs::I64 - _s8TXr::I64;
           I64[Hp - 48] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 40] = _s8TXn::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 63;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           P64[Sp + 32] = Hp - 6;
           Sp = Sp + 32;
           call _s8TWY() args: 0, res: 0, upd: 0;
     }
 },
 _c8Une() //  [R1]
         { info_tbl: [(c8Une,
                       label: block_c8Une_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Une: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _c8Unh() args: 0, res: 0, upd: 0;
     }
 },
 _c8UnQ() //  [R1]
         { info_tbl: [(c8UnQ,
                       label: block_c8UnQ_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UnQ: // global
           if (R1 & 7 == 2) goto u8UoY; else goto c8Uo2;
       u8UoY: // global
           Sp = Sp + 40;
           call _c8Uno() args: 0, res: 0, upd: 0;
       c8Uo2: // global
           _s8TXM::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8UnX_info;
           R3 = P64[Sp + 8];
           R2 = _s8TXM::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uno() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uno: // global
           P64[Sp - 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call _s8TWY() args: 0, res: 0, upd: 0;
     }
 },
 _s8TWY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TWY: // global
           _s8TX0::P64 = P64[Sp];
           I64[Sp] = block_c8Uly_info;
           R1 = _s8TX0::P64;
           if (R1 & 7 != 0) goto u8Upx; else goto c8Ulz;
       u8Upx: // global
           call _c8Uly(R1) args: 0, res: 0, upd: 0;
       c8Ulz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uly() //  [R1]
         { info_tbl: [(c8Uly,
                       label: block_c8Uly_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uly: // global
           if (R1 & 7 == 1) goto c8Umz; else goto c8UmS;
       c8Umz: // global
           _s8TWN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8UlD_info;
           R1 = _s8TWN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Upd; else goto c8UlE;
       u8Upd: // global
           call _c8UlD(R1) args: 0, res: 0, upd: 0;
       c8UlE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UmS: // global
           _s8TWJ::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 32]);
           R1 = _s8TWJ::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UlD() //  [R1]
         { info_tbl: [(c8UlD,
                       label: block_c8UlD_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UlD: // global
           _s8TX4::I64 = I64[R1 + 7] << 1;
           if (_s8TX4::I64 != 0) goto u8Up5; else goto c8UmL;
       u8Up5: // global
           I64[Sp] = _s8TX4::I64;
           call _c8UlM() args: 0, res: 0, upd: 0;
       c8UmL: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = GHC.Foreign.newCString2_closure+1;
           call _c8Ulh() args: 0, res: 0, upd: 0;
     }
 },
 _c8UlM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UlM: // global
           Hp = Hp + 16;
           _s8TX4::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8UmF; else goto c8UmE;
       c8UmF: // global
           HpAlloc = 16;
           I64[Sp] = block_c8UlL_info;
           R1 = _s8TX4::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8UmE: // global
           (_s8TX9::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8TX4::I64);
           if (_s8TX9::I64 == 0) goto c8UmI; else goto c8UmH;
       c8UmI: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8UmH: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TX4::I64;
           I64[Sp + 8] = _s8TX9::I64;
           P64[Sp] = Hp - 7;
           call _c8Ulh() args: 0, res: 0, upd: 0;
     }
 },
 _c8UlL() //  [R1]
         { info_tbl: [(c8UlL,
                       label: block_c8UlL_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UlL: // global
           I64[Sp] = R1;
           call _c8UlM() args: 0, res: 0, upd: 0;
     }
 },
 _c8UnX() //  [R1]
         { info_tbl: [(c8UnX,
                       label: block_c8UnX_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UnX: // global
           I64[Sp] = block_c8UnZ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Ups; else goto c8Uo4;
       u8Ups: // global
           call _c8UnZ(R1) args: 0, res: 0, upd: 0;
       c8Uo4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UnZ() //  [R1]
         { info_tbl: [(c8UnZ,
                       label: block_c8UnZ_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UnZ: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _c8Unv() args: 0, res: 0, upd: 0;
     }
 },
 _c8Uox() //  [R1]
         { info_tbl: [(c8Uox,
                       label: block_c8Uox_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uox: // global
           _s8TY9::I64 = I64[Sp + 16];
           _s8TYd::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TY9::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TYd::P64;
           I64[Sp + 16] = _s8TY9::I64 + 1;
           Sp = Sp + 8;
           call _c8Uoj() args: 0, res: 0, upd: 0;
     }
 },
 sat_s8TYm_entry() //  [R1]
         { info_tbl: [(c8UpE,
                       label: sat_s8TYm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UpE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UpF; else goto c8UpG;
       c8UpF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8UpG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.fst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Foreign.newCString1_entry() //  [R2, R3]
         { info_tbl: [(c8UpH,
                       label: GHC.Foreign.newCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UpH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UpI; else goto c8UpJ;
       c8UpI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.newCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UpJ: // global
           I64[Sp - 16] = block_c8Ukw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8UpQ; else goto c8Ukx;
       u8UpQ: // global
           call _c8Ukw(R1) args: 0, res: 0, upd: 0;
       c8Ukx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ukw() //  [R1]
         { info_tbl: [(c8Ukw,
                       label: block_c8Ukw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ukw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8UpM; else goto c8UpL;
       c8UpM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UpL: // global
           _s8TWh::P64 = P64[R1 + 23];
           I64[Hp - 8] = sat_s8TYi_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8Upy_info;
           R4 = Hp - 6;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TWh::P64;
           Sp = Sp + 8;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Upy() //  [R1]
         { info_tbl: [(c8Upy,
                       label: block_c8Upy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Upy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UpP; else goto c8UpO;
       c8UpP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UpO: // global
           I64[Hp - 16] = sat_s8TYm_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.654352256 UTC

[section ""data" . GHC.Foreign.newCString_closure" {
     GHC.Foreign.newCString_closure:
         const GHC.Foreign.newCString_info;
         const 0;
 },
 GHC.Foreign.newCString_entry() //  [R2, R3]
         { info_tbl: [(c8UpV,
                       label: GHC.Foreign.newCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UpV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.655274407 UTC

[section ""data" . GHC.Foreign.newCStringLen_closure" {
     GHC.Foreign.newCStringLen_closure:
         const GHC.Foreign.newCStringLen_info;
         const 0;
 },
 GHC.Foreign.newCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8Uq2,
                       label: GHC.Foreign.newCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uq2: // global
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call GHC.Foreign.newEncodedCString_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.660167256 UTC

[section ""data" . GHC.Foreign.$wpeekCString_closure" {
     GHC.Foreign.$wpeekCString_closure:
         const GHC.Foreign.$wpeekCString_info;
         const 0;
 },
 sat_s8TZz_entry() //  [R1]
         { info_tbl: [(c8Usa,
                       label: sat_s8TZz_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Usa: // global
           _s8TZz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Usb; else goto c8Usc;
       c8Usc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Use; else goto c8Usd;
       c8Use: // global
           HpAlloc = 40;
           goto c8Usb;
       c8Usb: // global
           R1 = _s8TZz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Usd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8TZz::P64;
           _s8TZo::P64 = P64[_s8TZz::P64 + 16];
           _s8TZw::P64 = P64[_s8TZz::P64 + 24];
           _s8TZs::I64 = I64[_s8TZz::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TZs::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TZo::P64;
           R3 = _s8TZw::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TZQ_entry() //  [R1]
         { info_tbl: [(c8Usn,
                       label: sat_s8TZQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Usn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Uso; else goto c8Usp;
       c8Uso: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Usp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8TYQ_entry() //  [R1, R2]
         { info_tbl: [(c8Usq,
                       label: $wgo_s8TYQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Usq: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8Usr; else goto c8Uss;
       c8Usr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Uss: // global
           I64[Sp - 32] = block_c8UqP_info;
           _s8TYQ::P64 = R1;
           _s8TYP::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8TYP::P64;
           P64[Sp - 16] = _s8TYQ::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Uu2; else goto c8UqQ;
       u8Uu2: // global
           call _c8UqP(R1) args: 0, res: 0, upd: 0;
       c8UqQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UqP() //  [R1]
         { info_tbl: [(c8UqP,
                       label: block_c8UqP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UqP: // global
           _s8TYP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8UqU_info;
           R3 = _s8TYP::P64;
           R2 = P64[Sp + 24];
           _s8TYV::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8TYV::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UqU() //  [R1]
         { info_tbl: [(c8UqU,
                       label: block_c8UqU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UqU: // global
           I64[Sp] = block_c8UqW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UtU; else goto c8UqX;
       u8UtU: // global
           call _c8UqW(R1) args: 0, res: 0, upd: 0;
       c8UqX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UqW() //  [R1]
         { info_tbl: [(c8UqW,
                       label: block_c8UqW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UqW: // global
           I64[Sp - 16] = block_c8Ur1_info;
           _s8TZ3::P64 = P64[R1 + 7];
           _s8TZ5::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TZ5::P64;
           P64[Sp] = _s8TZ3::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8UtV; else goto c8Ur2;
       u8UtV: // global
           call _c8Ur1(R1) args: 0, res: 0, upd: 0;
       c8Ur2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ur1() //  [R1]
         { info_tbl: [(c8Ur1,
                       label: block_c8Ur1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ur1: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8Utn; else goto c8UsQ;
       c8Utn: // global
           I64[Sp + 32] = block_c8Urz_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8UtX; else goto c8UrA;
       u8UtX: // global
           call _c8Urz(R1) args: 0, res: 0, upd: 0;
       c8UrA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UsQ: // global
           I64[Sp] = block_c8Usx_info;
           _s8TZ6::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TZ6::P64;
           if (R1 & 7 != 0) goto u8UtW; else goto c8UsR;
       u8UtW: // global
           call _c8Usx(R1) args: 0, res: 0, upd: 0;
       c8UsR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Urz() //  [R1]
         { info_tbl: [(c8Urz,
                       label: block_c8Urz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Urz: // global
           _s8U0e::P64 = P64[R1 + 7];
           _s8U0j::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8U0j::I64, 0)) goto c8UtF; else goto c8UtG;
       c8UtF: // global
           P64[Sp - 24] = _s8U0e::P64;
           I64[Sp - 16] = _s8U0j::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8UrR() args: 0, res: 0, upd: 0;
       c8UtG: // global
           call MO_Touch(_s8U0e::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UrR() //  []
         { info_tbl: [(c8UrR,
                       label: block_c8UrR_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UrR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UtA; else goto c8Utz;
       c8UtA: // global
           HpAlloc = 40;
           I64[Sp] = block_c8UrR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Utz: // global
           _s8U0w::P64 = P64[Sp + 24];
           _s8U0y::I64 = I64[Sp + 16];
           if (_s8U0y::I64 != 0) goto c8UtC; else goto c8UtD;
       c8UtC: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8U0y::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8U0w::P64;
           I64[Sp + 16] = _s8U0y::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8UrR() args: 0, res: 0, upd: 0;
       c8UtD: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8U0w::P64;
           Sp = Sp + 8;
           call _c8Utq() args: 0, res: 0, upd: 0;
     }
 },
 _c8Utq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Utq: // global
           Hp = Hp + 40;
           _s8U0m::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8Utx; else goto c8Utw;
       c8Utx: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8Utp_info;
           R1 = _s8U0m::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Utw: // global
           _s8U0q::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8U0q::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8U0m::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Utp() //  [R1]
         { info_tbl: [(c8Utp,
                       label: block_c8Utp_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Utp: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8Utq() args: 0, res: 0, upd: 0;
     }
 },
 _c8Usx() //  [R1]
         { info_tbl: [(c8Usx,
                       label: block_c8Usx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Usx: // global
           _s8TZ5::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8Uth; else goto c8Ut5;
       c8Uth: // global
           I64[Sp + 8] = block_c8Utf_info;
           R1 = _s8TZ5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Uu3; else goto c8Uti;
       u8Uu3: // global
           call _c8Utf(R1) args: 0, res: 0, upd: 0;
       c8Uti: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Ut5: // global
           _s8TZ6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8UsV_info;
           R3 = _s8TZ5::P64;
           R2 = _s8TZ6::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Utf() //  [R1]
         { info_tbl: [(c8Utf,
                       label: block_c8Utf_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Utf: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8TZe() args: 0, res: 0, upd: 0;
     }
 },
 _c8UsV() //  [R1]
         { info_tbl: [(c8UsV,
                       label: block_c8UsV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UsV: // global
           I64[Sp] = block_c8UsX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Uu4; else goto c8UsY;
       u8Uu4: // global
           call _c8UsX(R1) args: 0, res: 0, upd: 0;
       c8UsY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UsX() //  [R1]
         { info_tbl: [(c8UsX,
                       label: block_c8UsX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UsX: // global
           I64[Sp] = block_c8Ut2_info;
           _s8TZW::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8TZW::P64;
           if (R1 & 7 != 0) goto u8Uu5; else goto c8Ut8;
       u8Uu5: // global
           call _c8Ut2(R1) args: 0, res: 0, upd: 0;
       c8Ut8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ut2() //  [R1]
         { info_tbl: [(c8Ut2,
                       label: block_c8Ut2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ut2: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8TZe() args: 0, res: 0, upd: 0;
     }
 },
 _s8TZe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TZe: // global
           _s8TZl::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8TZl::I64, 0)) goto c8UsK; else goto c8UsL;
       c8UsK: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8TZl::I64 - 1;
           Sp = Sp - 8;
           call _c8Urr() args: 0, res: 0, upd: 0;
       c8UsL: // global
           _s8TYQ::P64 = P64[Sp + 32];
           _s8TZg::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8Ush_info;
           R2 = _s8TZg::P64;
           R1 = _s8TYQ::P64;
           Sp = Sp + 40;
           call $wgo_s8TYQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Urr() //  []
         { info_tbl: [(c8Urr,
                       label: block_c8Urr_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Urr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UsF; else goto c8UsE;
       c8UsF: // global
           HpAlloc = 40;
           I64[Sp] = block_c8Urr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8UsE: // global
           _s8TZh::I64 = I64[Sp + 32];
           _s8TZC::P64 = P64[Sp + 16];
           _s8TZE::I64 = I64[Sp + 24];
           if (_s8TZE::I64 != 0) goto c8UsH; else goto c8UsI;
       c8UsH: // global
           _s8TZH::I64 = %MO_UU_Conv_W32_W64(I32[_s8TZh::I64 + (_s8TZE::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TZH::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TZC::P64;
           I64[Sp + 24] = _s8TZE::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8Urr() args: 0, res: 0, upd: 0;
       c8UsI: // global
           Hp = Hp - 40;
           _s8TYQ::P64 = P64[Sp + 40];
           _s8TZg::P64 = P64[Sp + 48];
           _s8TZs::I64 = %MO_UU_Conv_W32_W64(I32[_s8TZh::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8Us2_info;
           R2 = _s8TZg::P64;
           R1 = _s8TYQ::P64;
           I64[Sp + 40] = _s8TZs::I64;
           P64[Sp + 48] = _s8TZC::P64;
           Sp = Sp + 32;
           call $wgo_s8TYQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Us2() //  [R1]
         { info_tbl: [(c8Us2,
                       label: block_c8Us2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Us2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UsC; else goto c8UsB;
       c8UsC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UsB: // global
           I64[Hp - 32] = sat_s8TZz_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Ush() //  [R1]
         { info_tbl: [(c8Ush,
                       label: block_c8Ush_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ush: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UsO; else goto c8UsN;
       c8UsO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UsN: // global
           I64[Hp - 16] = sat_s8TZQ_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8U0L_entry() //  [R1, R2]
         { info_tbl: [(c8Uuf,
                       label: sat_s8U0L_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uuf: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8Uug; else goto c8Uuh;
       c8Uug: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Uuh: // global
           I64[Sp - 32] = block_c8Uqo_info;
           _s8TYp::I64 = I64[R1 + 6];
           _s8TYs::I64 = I64[R1 + 14];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 24] = _s8TYp::I64;
           I64[Sp - 16] = _s8TYs::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uqo() //  [R1]
         { info_tbl: [(c8Uqo,
                       label: block_c8Uqo_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uqo: // global
           _s8TYs::I64 = I64[Sp + 16];
           if (%MO_S_Gt_W64(_s8TYs::I64, 1)) goto c8Uud; else goto c8Uue;
       c8Uud: // global
           _s8TYC::P64 = R1;
           _s8TYE::I64 = _s8TYs::I64;
           goto s8TYD;
       c8Uue: // global
           _s8TYC::P64 = R1;
           _s8TYE::I64 = 1;
           goto s8TYD;
       s8TYD: // global
           _s8TYF::I64 = _s8TYE::I64 << 2;
           if (%MO_S_Ge_W64(_s8TYF::I64, 0)) goto c8Uun; else goto c8Uus;
       c8Uun: // global
           I64[Sp - 24] = block_c8UqB_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8TYE::I64;
           I64[Sp - 8] = _s8TYF::I64;
           P64[Sp] = _s8TYC::P64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8Uus: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UqB() //  [R1]
         { info_tbl: [(c8UqB,
                       label: block_c8UqB_info
                       rep:StackRep [True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UqB: // global
           I64[Sp] = block_c8UqD_info;
           _s8TYJ::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8TYJ::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UqD() //  [R1]
         { info_tbl: [(c8UqD,
                       label: block_c8UqD_info
                       rep:StackRep [True, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UqD: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8Uur; else goto c8Uuq;
       c8Uur: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Uuq: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8TYQ_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 24];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8TYs::I64 = I64[Sp + 40];
           I64[Hp - 16] = _s8TYs::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8TYs::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8TYQ_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.$wpeekCString_entry() //  [R2, R3]
         { info_tbl: [(c8Uuv,
                       label: GHC.Foreign.$wpeekCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uuv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Uuw; else goto c8Uux;
       c8Uuw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.$wpeekCString_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Uux: // global
           _s8TYp::I64 = R3;
           _s8TYo::P64 = R2;
           _s8U0N::I64 = 0;
           goto c8UuD;
       c8UuD: // global
           if (I8[_s8TYp::I64 + _s8U0N::I64] == 0 :: W8) goto c8UuJ; else goto c8UuI;
       c8UuJ: // global
           I64[Sp - 24] = block_c8Uqe_info;
           R1 = _s8TYo::P64;
           I64[Sp - 16] = _s8TYp::I64;
           I64[Sp - 8] = _s8U0N::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8UuM; else goto c8Uqf;
       u8UuM: // global
           call _c8Uqe(R1) args: 0, res: 0, upd: 0;
       c8Uqf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UuI: // global
           _s8U0N::I64 = _s8U0N::I64 + 1;
           goto c8UuD;
     }
 },
 _c8Uqe() //  [R1]
         { info_tbl: [(c8Uqe,
                       label: block_c8Uqe_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uqe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UuB; else goto c8UuA;
       c8UuB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UuA: // global
           _s8TYw::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8U0L_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TYw::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.668858974 UTC

[section ""data" . GHC.Foreign.peekCString1_closure" {
     GHC.Foreign.peekCString1_closure:
         const GHC.Foreign.peekCString1_info;
         const 0;
 },
 GHC.Foreign.peekCString1_entry() //  [R2, R3]
         { info_tbl: [(c8UuU,
                       label: GHC.Foreign.peekCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UuU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UuV; else goto c8UuW;
       c8UuV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.peekCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UuW: // global
           I64[Sp - 16] = block_c8UuR_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Uv0; else goto c8UuS;
       u8Uv0: // global
           call _c8UuR(R1) args: 0, res: 0, upd: 0;
       c8UuS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UuR() //  [R1]
         { info_tbl: [(c8UuR,
                       label: block_c8UuR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UuR: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.670049744 UTC

[section ""data" . GHC.Foreign.peekCString_closure" {
     GHC.Foreign.peekCString_closure:
         const GHC.Foreign.peekCString_info;
         const 0;
 },
 GHC.Foreign.peekCString_entry() //  [R2, R3]
         { info_tbl: [(c8Uv5,
                       label: GHC.Foreign.peekCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uv5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.peekCString1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.671169959 UTC

[section ""data" . GHC.Foreign.charIsRepresentable2_closure" {
     GHC.Foreign.charIsRepresentable2_closure:
         const GHC.Foreign.charIsRepresentable2_info;
         const 0;
 },
 GHC.Foreign.charIsRepresentable2_entry() //  [R2]
         { info_tbl: [(c8Uvf,
                       label: GHC.Foreign.charIsRepresentable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uvf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Uvj; else goto c8Uvk;
       c8Uvj: // global
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Uvk: // global
           I64[Sp - 8] = block_c8Uvc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8UvC; else goto c8Uvd;
       u8UvC: // global
           call _c8Uvc(R1) args: 0, res: 0, upd: 0;
       c8Uvd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uvc() //  [R1]
         { info_tbl: [(c8Uvc,
                       label: block_c8Uvc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uvc: // global
           I64[Sp - 8] = block_c8Uvi_info;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uvi() //  [R1]
         { info_tbl: [(c8Uvi,
                       label: block_c8Uvi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uvi: // global
           I64[Sp] = block_c8Uvp_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uvp() //  [R1]
         { info_tbl: [(c8Uvp,
                       label: block_c8Uvp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uvp: // global
           if (R1 & 7 == 1) goto c8Uvw; else goto c8UvA;
       c8Uvw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8UvA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.673816887 UTC

[section ""data" . GHC.Foreign.charIsRepresentable1_closure" {
     GHC.Foreign.charIsRepresentable1_closure:
         const GHC.Foreign.charIsRepresentable1_info;
         const 0;
 },
 sat_s8U1w_entry() //  [R1, R2]
         { info_tbl: [(c8UvU,
                       label: sat_s8U1w_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UvU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8UvV; else goto c8UvW;
       c8UvV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UvW: // global
           I64[Sp - 24] = block_c8UvR_info;
           _s8U17::P64 = P64[R1 + 6];
           _s8U19::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _s8U17::P64;
           P64[Sp - 8] = _s8U19::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8UwN; else goto c8UvS;
       u8UwN: // global
           call _c8UvR(R1) args: 0, res: 0, upd: 0;
       c8UvS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UvR() //  [R1]
         { info_tbl: [(c8UvR,
                       label: block_c8UvR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UvR: // global
           I64[Sp] = block_c8UvZ_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8UvZ() //  [R1]
         { info_tbl: [(c8UvZ,
                       label: block_c8UvZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UvZ: // global
           I64[Sp] = block_c8Uw1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UwO; else goto c8Uw4;
       u8UwO: // global
           call _c8Uw1(R1) args: 0, res: 0, upd: 0;
       c8Uw4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uw1() //  [R1]
         { info_tbl: [(c8Uw1,
                       label: block_c8Uw1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uw1: // global
           if (R1 & 7 == 1) goto u8UwK; else goto c8Uwf;
       u8UwK: // global
           Sp = Sp + 24;
           call _c8UwH() args: 0, res: 0, upd: 0;
       c8Uwf: // global
           I64[Sp] = block_c8Uwd_info;
           _s8U1m::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp + 16] = _s8U1m::P64;
           if (R1 & 7 != 0) goto u8UwP; else goto c8Uwg;
       u8UwP: // global
           call _c8Uwd(R1) args: 0, res: 0, upd: 0;
       c8Uwg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uwd() //  [R1]
         { info_tbl: [(c8Uwd,
                       label: block_c8Uwd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uwd: // global
           if (R1 & 7 == 1) goto c8Uws; else goto u8UwL;
       c8Uws: // global
           I64[Sp] = block_c8Uwk_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8UwR; else goto c8Uwl;
       u8UwR: // global
           call _c8Uwk(R1) args: 0, res: 0, upd: 0;
       c8Uwl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8UwL: // global
           Sp = Sp + 24;
           call _c8UwH() args: 0, res: 0, upd: 0;
     }
 },
 _c8Uwk() //  [R1]
         { info_tbl: [(c8Uwk,
                       label: block_c8Uwk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uwk: // global
           _s8U17::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Uwp_info;
           _s8U1q::I64 = I64[R1 + 7];
           R1 = _s8U17::P64;
           I64[Sp + 16] = _s8U1q::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8UwT; else goto c8Uwu;
       u8UwT: // global
           call _c8Uwp(R1) args: 0, res: 0, upd: 0;
       c8Uwu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uwp() //  [R1]
         { info_tbl: [(c8Uwp,
                       label: block_c8Uwp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uwp: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c8UwD; else goto u8UwM;
       c8UwD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8UwM: // global
           Sp = Sp + 16;
           call _c8UwH() args: 0, res: 0, upd: 0;
     }
 },
 _c8UwH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UwH: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8U1x_entry() //  [R1]
         { info_tbl: [(c8Ux1,
                       label: sat_s8U1x_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ux1: // global
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.charIsRepresentable1_entry() //  [R2, R3]
         { info_tbl: [(c8Ux4,
                       label: GHC.Foreign.charIsRepresentable1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ux4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ux5; else goto c8Ux6;
       c8Ux5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ux6: // global
           I64[Sp - 16] = block_c8UvH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Uxa; else goto c8UvI;
       u8Uxa: // global
           call _c8UvH(R1) args: 0, res: 0, upd: 0;
       c8UvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UvH() //  [R1]
         { info_tbl: [(c8UvH,
                       label: block_c8UvH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UvH: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8Ux9; else goto c8Ux8;
       c8Ux9: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ux8: // global
           I64[Hp - 72] = sat_s8U1w_info;
           _s8U17::P64 = P64[Sp + 8];
           P64[Hp - 64] = _s8U17::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = _s8U17::P64;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           I64[Hp - 24] = sat_s8U1x_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 70;
           R2 = GHC.Foreign.charIsRepresentable2_closure+2;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.677373344 UTC

[section ""data" . GHC.Foreign.charIsRepresentable_closure" {
     GHC.Foreign.charIsRepresentable_closure:
         const GHC.Foreign.charIsRepresentable_info;
         const 0;
 },
 GHC.Foreign.charIsRepresentable_entry() //  [R2, R3]
         { info_tbl: [(c8Uxf,
                       label: GHC.Foreign.charIsRepresentable_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uxf: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.679457171 UTC

[section ""relreadonly" . S8U6c_srt" {
     S8U6c_srt:
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const $wpeekCStringLen_r8TNn_closure;
         const peekCStringLen1_r8TNo_closure;
         const Foreign.Marshal.Array.withArrayLen_closure;
         const GHC.Foreign.withCStringsLen1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const newEncodedCString1_r8TNq_closure;
         const GHC.Foreign.newCString1_closure;
         const GHC.Foreign.newEncodedCString_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.Foreign.peekCString1_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.Foreign.charIsRepresentable2_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.680100859 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:02.68059093 UTC

[section ""cstring" . GHC.Foreign.$trModule4_bytes" {
     GHC.Foreign.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.681145124 UTC

[section ""data" . GHC.Foreign.$trModule3_closure" {
     GHC.Foreign.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Foreign.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.681745547 UTC

[section ""cstring" . GHC.Foreign.$trModule2_bytes" {
     GHC.Foreign.$trModule2_bytes:
         I8[] [71,72,67,46,70,111,114,101,105,103,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.682309339 UTC

[section ""data" . GHC.Foreign.$trModule1_closure" {
     GHC.Foreign.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Foreign.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.682879398 UTC

[section ""data" . GHC.Foreign.$trModule_closure" {
     GHC.Foreign.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Foreign.$trModule3_closure+1;
         const GHC.Foreign.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.687752848 UTC

[section ""data" . $wpeekCStringLen_r8TNn_closure" {
     $wpeekCStringLen_r8TNn_closure:
         const $wpeekCStringLen_r8TNn_info;
         const 0;
 },
 sat_s8TOF_entry() //  [R1]
         { info_tbl: [(c8Uzs,
                       label: sat_s8TOF_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uzs: // global
           _s8TOF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Uzt; else goto c8Uzu;
       c8Uzu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Uzw; else goto c8Uzv;
       c8Uzw: // global
           HpAlloc = 40;
           goto c8Uzt;
       c8Uzt: // global
           R1 = _s8TOF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Uzv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8TOF::P64;
           _s8TOu::P64 = P64[_s8TOF::P64 + 16];
           _s8TOC::P64 = P64[_s8TOF::P64 + 24];
           _s8TOy::I64 = I64[_s8TOF::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TOy::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TOu::P64;
           R3 = _s8TOC::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TOW_entry() //  [R1]
         { info_tbl: [(c8UzF,
                       label: sat_s8TOW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UzF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UzG; else goto c8UzH;
       c8UzG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8UzH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8TNW_entry() //  [R1, R2]
         { info_tbl: [(c8UzI,
                       label: $wgo_s8TNW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UzI: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8UzJ; else goto c8UzK;
       c8UzJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UzK: // global
           I64[Sp - 32] = block_c8Uy7_info;
           _s8TNW::P64 = R1;
           _s8TNV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8TNV::P64;
           P64[Sp - 16] = _s8TNW::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8UBk; else goto c8Uy8;
       u8UBk: // global
           call _c8Uy7(R1) args: 0, res: 0, upd: 0;
       c8Uy8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uy7() //  [R1]
         { info_tbl: [(c8Uy7,
                       label: block_c8Uy7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uy7: // global
           _s8TNV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Uyc_info;
           R3 = _s8TNV::P64;
           R2 = P64[Sp + 24];
           _s8TO1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8TO1::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uyc() //  [R1]
         { info_tbl: [(c8Uyc,
                       label: block_c8Uyc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uyc: // global
           I64[Sp] = block_c8Uye_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UBc; else goto c8Uyf;
       u8UBc: // global
           call _c8Uye(R1) args: 0, res: 0, upd: 0;
       c8Uyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uye() //  [R1]
         { info_tbl: [(c8Uye,
                       label: block_c8Uye_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uye: // global
           I64[Sp - 16] = block_c8Uyj_info;
           _s8TO9::P64 = P64[R1 + 7];
           _s8TOb::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TOb::P64;
           P64[Sp] = _s8TO9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8UBd; else goto c8Uyk;
       u8UBd: // global
           call _c8Uyj(R1) args: 0, res: 0, upd: 0;
       c8Uyk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uyj() //  [R1]
         { info_tbl: [(c8Uyj,
                       label: block_c8Uyj_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uyj: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8UAF; else goto c8UA8;
       c8UAF: // global
           I64[Sp + 32] = block_c8UyR_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8UBf; else goto c8UyS;
       u8UBf: // global
           call _c8UyR(R1) args: 0, res: 0, upd: 0;
       c8UyS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UA8: // global
           I64[Sp] = block_c8UzP_info;
           _s8TOc::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TOc::P64;
           if (R1 & 7 != 0) goto u8UBe; else goto c8UA9;
       u8UBe: // global
           call _c8UzP(R1) args: 0, res: 0, upd: 0;
       c8UA9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UyR() //  [R1]
         { info_tbl: [(c8UyR,
                       label: block_c8UyR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UyR: // global
           _s8TPk::P64 = P64[R1 + 7];
           _s8TPp::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8TPp::I64, 0)) goto c8UAX; else goto c8UAY;
       c8UAX: // global
           P64[Sp - 24] = _s8TPk::P64;
           I64[Sp - 16] = _s8TPp::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8Uz9() args: 0, res: 0, upd: 0;
       c8UAY: // global
           call MO_Touch(_s8TPk::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Uz9() //  []
         { info_tbl: [(c8Uz9,
                       label: block_c8Uz9_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uz9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UAS; else goto c8UAR;
       c8UAS: // global
           HpAlloc = 40;
           I64[Sp] = block_c8Uz9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8UAR: // global
           _s8TPC::P64 = P64[Sp + 24];
           _s8TPE::I64 = I64[Sp + 16];
           if (_s8TPE::I64 != 0) goto c8UAU; else goto c8UAV;
       c8UAU: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8TPE::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TPC::P64;
           I64[Sp + 16] = _s8TPE::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8Uz9() args: 0, res: 0, upd: 0;
       c8UAV: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8TPC::P64;
           Sp = Sp + 8;
           call _c8UAI() args: 0, res: 0, upd: 0;
     }
 },
 _c8UAI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UAI: // global
           Hp = Hp + 40;
           _s8TPs::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8UAP; else goto c8UAO;
       c8UAP: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8UAH_info;
           R1 = _s8TPs::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UAO: // global
           _s8TPw::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TPw::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TPs::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UAH() //  [R1]
         { info_tbl: [(c8UAH,
                       label: block_c8UAH_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UAH: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8UAI() args: 0, res: 0, upd: 0;
     }
 },
 _c8UzP() //  [R1]
         { info_tbl: [(c8UzP,
                       label: block_c8UzP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UzP: // global
           _s8TOb::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8UAz; else goto c8UAn;
       c8UAz: // global
           I64[Sp + 8] = block_c8UAx_info;
           R1 = _s8TOb::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8UBl; else goto c8UAA;
       u8UBl: // global
           call _c8UAx(R1) args: 0, res: 0, upd: 0;
       c8UAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UAn: // global
           _s8TOc::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8UAd_info;
           R3 = _s8TOb::P64;
           R2 = _s8TOc::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UAx() //  [R1]
         { info_tbl: [(c8UAx,
                       label: block_c8UAx_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UAx: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8TOk() args: 0, res: 0, upd: 0;
     }
 },
 _c8UAd() //  [R1]
         { info_tbl: [(c8UAd,
                       label: block_c8UAd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UAd: // global
           I64[Sp] = block_c8UAf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UBm; else goto c8UAg;
       u8UBm: // global
           call _c8UAf(R1) args: 0, res: 0, upd: 0;
       c8UAg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UAf() //  [R1]
         { info_tbl: [(c8UAf,
                       label: block_c8UAf_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UAf: // global
           I64[Sp] = block_c8UAk_info;
           _s8TP2::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8TP2::P64;
           if (R1 & 7 != 0) goto u8UBn; else goto c8UAq;
       u8UBn: // global
           call _c8UAk(R1) args: 0, res: 0, upd: 0;
       c8UAq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UAk() //  [R1]
         { info_tbl: [(c8UAk,
                       label: block_c8UAk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UAk: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8TOk() args: 0, res: 0, upd: 0;
     }
 },
 _s8TOk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TOk: // global
           _s8TOr::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8TOr::I64, 0)) goto c8UA2; else goto c8UA3;
       c8UA2: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8TOr::I64 - 1;
           Sp = Sp - 8;
           call _c8UyJ() args: 0, res: 0, upd: 0;
       c8UA3: // global
           _s8TNW::P64 = P64[Sp + 32];
           _s8TOm::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8Uzz_info;
           R2 = _s8TOm::P64;
           R1 = _s8TNW::P64;
           Sp = Sp + 40;
           call $wgo_s8TNW_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UyJ() //  []
         { info_tbl: [(c8UyJ,
                       label: block_c8UyJ_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UyJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UzX; else goto c8UzW;
       c8UzX: // global
           HpAlloc = 40;
           I64[Sp] = block_c8UyJ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8UzW: // global
           _s8TOn::I64 = I64[Sp + 32];
           _s8TOI::P64 = P64[Sp + 16];
           _s8TOK::I64 = I64[Sp + 24];
           if (_s8TOK::I64 != 0) goto c8UzZ; else goto c8UA0;
       c8UzZ: // global
           _s8TON::I64 = %MO_UU_Conv_W32_W64(I32[_s8TOn::I64 + (_s8TOK::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TON::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TOI::P64;
           I64[Sp + 24] = _s8TOK::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8UyJ() args: 0, res: 0, upd: 0;
       c8UA0: // global
           Hp = Hp - 40;
           _s8TNW::P64 = P64[Sp + 40];
           _s8TOm::P64 = P64[Sp + 48];
           _s8TOy::I64 = %MO_UU_Conv_W32_W64(I32[_s8TOn::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8Uzk_info;
           R2 = _s8TOm::P64;
           R1 = _s8TNW::P64;
           I64[Sp + 40] = _s8TOy::I64;
           P64[Sp + 48] = _s8TOI::P64;
           Sp = Sp + 32;
           call $wgo_s8TNW_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uzk() //  [R1]
         { info_tbl: [(c8Uzk,
                       label: block_c8Uzk_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uzk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UzU; else goto c8UzT;
       c8UzU: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UzT: // global
           I64[Hp - 32] = sat_s8TOF_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Uzz() //  [R1]
         { info_tbl: [(c8Uzz,
                       label: block_c8Uzz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uzz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UA6; else goto c8UA5;
       c8UA6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UA5: // global
           I64[Hp - 16] = sat_s8TOW_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8TPR_entry() //  [R1, R2]
         { info_tbl: [(c8UBs,
                       label: sat_s8TPR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UBs: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8UBt; else goto c8UBu;
       c8UBt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UBu: // global
           I64[Sp - 24] = block_c8Uxw_info;
           _s8TNu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8TNu::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8UBO; else goto c8Uxx;
       u8UBO: // global
           call _c8Uxw(R1) args: 0, res: 0, upd: 0;
       c8Uxx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uxw() //  [R1]
         { info_tbl: [(c8Uxw,
                       label: block_c8Uxw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uxw: // global
           I64[Sp - 8] = block_c8UxB_info;
           _s8TND::I64 = I64[R1 + 7];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s8TND::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UxB() //  [R1]
         { info_tbl: [(c8UxB,
                       label: block_c8UxB_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UxB: // global
           I64[Sp] = block_c8UxD_info;
           _s8TNG::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TNG::P64;
           if (R1 & 7 != 0) goto u8UBN; else goto c8UxE;
       u8UBN: // global
           call _c8UxD(R1) args: 0, res: 0, upd: 0;
       c8UxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UxD() //  [R1]
         { info_tbl: [(c8UxD,
                       label: block_c8UxD_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UxD: // global
           _s8TNI::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s8TNI::I64, 1)) goto c8UBL; else goto c8UBM;
       c8UBL: // global
           _s8TNK::I64 = _s8TNI::I64;
           goto s8TNJ;
       c8UBM: // global
           _s8TNK::I64 = 1;
           goto s8TNJ;
       s8TNJ: // global
           _s8TNL::I64 = _s8TNK::I64 << 2;
           if (%MO_S_Ge_W64(_s8TNL::I64, 0)) goto c8UBC; else goto c8UBH;
       c8UBC: // global
           I64[Sp - 24] = block_c8UxT_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8TNK::I64;
           I64[Sp - 8] = _s8TNL::I64;
           I64[Sp] = _s8TNI::I64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8UBH: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UxT() //  [R1]
         { info_tbl: [(c8UxT,
                       label: block_c8UxT_info
                       rep:StackRep [True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UxT: // global
           I64[Sp] = block_c8UxV_info;
           _s8TNP::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8TNP::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UxV() //  [R1]
         { info_tbl: [(c8UxV,
                       label: block_c8UxV_info
                       rep:StackRep [True, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UxV: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8UBG; else goto c8UBF;
       c8UBG: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UBF: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8TNW_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 40];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8TNI::I64 = I64[Sp + 24];
           I64[Hp - 16] = _s8TNI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8TNI::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8TNW_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wpeekCStringLen_r8TNn_entry() //  [R2, R3, R4]
         { info_tbl: [(c8UBP,
                       label: $wpeekCStringLen_r8TNn_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UBP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8UBQ; else goto c8UBR;
       c8UBQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wpeekCStringLen_r8TNn_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UBR: // global
           I64[Sp - 24] = block_c8Uxm_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8UBV; else goto c8Uxn;
       u8UBV: // global
           call _c8Uxm(R1) args: 0, res: 0, upd: 0;
       c8Uxn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Uxm() //  [R1]
         { info_tbl: [(c8Uxm,
                       label: block_c8Uxm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Uxm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UBU; else goto c8UBT;
       c8UBU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UBT: // global
           _s8TNy::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8TPR_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TNy::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.696710363 UTC

[section ""data" . peekCStringLen1_r8TNo_closure" {
     peekCStringLen1_r8TNo_closure:
         const peekCStringLen1_r8TNo_info;
         const 0;
 },
 peekCStringLen1_r8TNo_entry() //  [R2, R3]
         { info_tbl: [(c8UC3,
                       label: peekCStringLen1_r8TNo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UC3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UC4; else goto c8UC5;
       c8UC4: // global
           R3 = R3;
           R2 = R2;
           R1 = peekCStringLen1_r8TNo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UC5: // global
           I64[Sp - 16] = block_c8UC0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8UC9; else goto c8UC1;
       u8UC9: // global
           call _c8UC0(R1) args: 0, res: 0, upd: 0;
       c8UC1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UC0() //  [R1]
         { info_tbl: [(c8UC0,
                       label: block_c8UC0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UC0: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wpeekCStringLen_r8TNn_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.697988805 UTC

[section ""data" . GHC.Foreign.peekCStringLen_closure" {
     GHC.Foreign.peekCStringLen_closure:
         const GHC.Foreign.peekCStringLen_info;
         const 0;
 },
 GHC.Foreign.peekCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8UCe,
                       label: GHC.Foreign.peekCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UCe: // global
           R3 = R3;
           R2 = R2;
           call peekCStringLen1_r8TNo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.701440455 UTC

[section ""data" . GHC.Foreign.$wtryFillBufferAndCall_closure" {
     GHC.Foreign.$wtryFillBufferAndCall_closure:
         const GHC.Foreign.$wtryFillBufferAndCall_info;
 },
 GHC.Foreign.$wtryFillBufferAndCall_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UCi: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8TRg_entry() //  [R1]
         { info_tbl: [(c8UCv,
                       label: sat_s8TRg_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UCv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8UCA; else goto c8UCB;
       c8UCA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8UCB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8UCs_info;
           _s8TQ8::P64 = P64[R1 + 24];
           _s8TQ2::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8TQ2::I64;
           P64[Sp - 24] = _s8TQ8::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8UCF; else goto c8UCt;
       u8UCF: // global
           call _c8UCs(R1) args: 0, res: 0, upd: 0;
       c8UCt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8UCs() //  [R1]
         { info_tbl: [(c8UCs,
                       label: block_c8UCs_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UCs: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8UCE; else goto c8UCD;
       c8UCE: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8UCD: // global
           _s8TRe::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8TRe::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Foreign.$wtryFillBufferAndCall_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8UCK,
                       label: GHC.Foreign.$wtryFillBufferAndCall_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UCK: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8UCL; else goto c8UCM;
       c8UCL: // global
           R1 = GHC.Foreign.$wtryFillBufferAndCall_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       c8UCM: // global
           I64[Sp - 48] = block_c8UCm_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UCm() //  [R1]
         { info_tbl: [(c8UCm,
                       label: block_c8UCm_info
                       rep:StackRep [False, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UCm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UCP; else goto c8UCO;
       c8UCP: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UCO: // global
           I64[Hp - 32] = sat_s8TRg_info;
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 40];
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = P64[Sp + 32];
           Sp = Sp + 8;
           call _c8UEk() args: 0, res: 0, upd: 0;
     }
 },
 _c8UEk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UEk: // global
           I64[Sp - 8] = block_c8UEm_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UEm() //  [R1]
         { info_tbl: [(c8UEm,
                       label: block_c8UEm_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UEm: // global
           I64[Sp] = block_c8UEo_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UFi; else goto c8UEp;
       u8UFi: // global
           call _c8UEo(R1) args: 0, res: 0, upd: 0;
       c8UEp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UEo() //  [R1]
         { info_tbl: [(c8UEo,
                       label: block_c8UEo_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UEo: // global
           I64[Sp] = block_c8UEt_info;
           _s8TQV::P64 = P64[R1 + 7];
           _s8TQX::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp + 40] = _s8TQX::P64;
           P64[Sp + 48] = _s8TQV::P64;
           if (R1 & 7 != 0) goto u8UFj; else goto c8UEx;
       u8UFj: // global
           call _c8UEt(R1) args: 0, res: 0, upd: 0;
       c8UEx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UEt() //  [R1]
         { info_tbl: [(c8UEt,
                       label: block_c8UEt_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UEt: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8UF2; else goto c8UEH;
       c8UF2: // global
           I64[Sp + 16] = block_c8UCV_info;
           R1 = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 40];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u8UFl; else goto c8UDN;
       u8UFl: // global
           call _c8UCV(R1) args: 0, res: 0, upd: 0;
       c8UDN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UEH: // global
           I64[Sp] = block_c8UEF_info;
           _s8TQY::P64 = R1;
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _s8TQY::P64;
           if (R1 & 7 != 0) goto u8UFk; else goto c8UEI;
       u8UFk: // global
           call _c8UEF(R1) args: 0, res: 0, upd: 0;
       c8UEI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UCV() //  [R1]
         { info_tbl: [(c8UCV,
                       label: block_c8UCV_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UCV: // global
           if (R1 & 7 == 1) goto u8UF9; else goto c8UDY;
       u8UF9: // global
           Sp = Sp + 8;
           call _s8TQc() args: 0, res: 0, upd: 0;
       c8UDY: // global
           I64[Sp] = block_c8UDW_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u8UFd; else goto c8UDZ;
       u8UFd: // global
           call _c8UDW(R1) args: 0, res: 0, upd: 0;
       c8UDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UDW() //  [R1]
         { info_tbl: [(c8UDW,
                       label: block_c8UDW_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UDW: // global
           if (I64[R1 + 31] - I64[R1 + 47] == 0) goto u8UFa; else goto u8UFb;
       u8UFa: // global
           Sp = Sp + 48;
           call _c8UEf() args: 0, res: 0, upd: 0;
       u8UFb: // global
           Sp = Sp + 8;
           call _s8TQc() args: 0, res: 0, upd: 0;
     }
 },
 _s8TQc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TQc: // global
           I64[Sp - 8] = block_c8UD0_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8UFp; else goto c8UD2;
       u8UFp: // global
           call _c8UD0(R1) args: 0, res: 0, upd: 0;
       c8UD2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UD0() //  [R1]
         { info_tbl: [(c8UD0,
                       label: block_c8UD0_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UD0: // global
           I64[Sp] = block_c8UD6_info;
           _s8TQf::P64 = P64[R1 + 7];
           _s8TQe::I64 = I64[R1 + 23];
           _s8TQi::I64 = I64[R1 + 39];
           _s8TQj::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8TQj::I64;
           I64[Sp + 16] = _s8TQi::I64;
           P64[Sp + 24] = _s8TQf::P64;
           I64[Sp + 32] = _s8TQe::I64;
           if (R1 & 7 != 0) goto u8UFf; else goto c8UD8;
       u8UFf: // global
           call _c8UD6(R1) args: 0, res: 0, upd: 0;
       c8UD8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UD6() //  [R1]
         { info_tbl: [(c8UD6,
                       label: block_c8UD6_info
                       rep:StackRep [True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UD6: // global
           _s8TQ4::P64 = P64[Sp + 40];
           _s8TQe::I64 = I64[Sp + 32];
           _s8TQi::I64 = I64[Sp + 16];
           _s8TQj::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c8UDn; else goto c8UDG;
       c8UDn: // global
           Hp = Hp + 56;
           _s8TQk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8UDJ; else goto c8UDp;
       c8UDp: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s8TQj::I64 - _s8TQi::I64;
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = _s8TQe::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8UDi_info;
           R2 = Hp - 15;
           R1 = _s8TQ4::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       c8UDG: // global
           Hp = Hp + 56;
           _s8TQk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8UDJ; else goto c8UDI;
       c8UDJ: // global
           HpAlloc = 56;
           R1 = _s8TQk::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UDI: // global
           I8[_s8TQe::I64 + _s8TQj::I64] = 0 :: W8;
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s8TQj::I64 - _s8TQi::I64;
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = _s8TQe::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8UDC_info;
           R2 = Hp - 15;
           R1 = _s8TQ4::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UDi() //  [R1]
         { info_tbl: [(c8UDi,
                       label: block_c8UDi_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UDi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8UDt; else goto c8UDs;
       c8UDt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UDs: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UDC() //  [R1]
         { info_tbl: [(c8UDC,
                       label: block_c8UDC_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UDC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8UDM; else goto c8UDL;
       c8UDM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UDL: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UEF() //  [R1]
         { info_tbl: [(c8UEF,
                       label: block_c8UEF_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UEF: // global
           if (R1 & 7 == 2) goto u8UF7; else goto c8UER;
       u8UF7: // global
           Sp = Sp + 64;
           call _c8UEf() args: 0, res: 0, upd: 0;
       c8UER: // global
           I64[Sp] = block_c8UEM_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 16];
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UEf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UEf: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UEM() //  [R1]
         { info_tbl: [(c8UEM,
                       label: block_c8UEM_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UEM: // global
           I64[Sp] = block_c8UEO_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UFn; else goto c8UET;
       u8UFn: // global
           call _c8UEO(R1) args: 0, res: 0, upd: 0;
       c8UET: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UEO() //  [R1]
         { info_tbl: [(c8UEO,
                       label: block_c8UEO_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UEO: // global
           P64[Sp + 48] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 8;
           call _c8UEk() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.708065739 UTC

[section ""data" . GHC.Foreign.newCStringLen1_closure" {
     GHC.Foreign.newCStringLen1_closure:
         const GHC.Foreign.newCStringLen1_info;
 },
 GHC.Foreign.newCStringLen1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8UFx,
                       label: GHC.Foreign.newCStringLen1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UFx: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8UFB; else goto c8UFC;
       c8UFB: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.newCStringLen1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8UFC: // global
           I64[Sp - 40] = block_c8UFu_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8UFK; else goto c8UFv;
       u8UFK: // global
           call _c8UFu(R1) args: 0, res: 0, upd: 0;
       c8UFv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UFu() //  [R1]
         { info_tbl: [(c8UFu,
                       label: block_c8UFu_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UFu: // global
           I64[Sp - 8] = block_c8UFA_info;
           _s8TRp::P64 = P64[R1 + 7];
           _s8TRq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8TRq::P64;
           P64[Sp + 24] = _s8TRp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8UFJ; else goto c8UFE;
       u8UFJ: // global
           call _c8UFA(R1) args: 0, res: 0, upd: 0;
       c8UFE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UFA() //  [R1]
         { info_tbl: [(c8UFA,
                       label: block_c8UFA_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UFA: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 40;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.713157168 UTC

[section ""data" . withEncodedCString1_r8TNp_closure" {
     withEncodedCString1_r8TNp_closure:
         const withEncodedCString1_r8TNp_info;
 },
 $wgo_s8TRX_entry() //  [R1, R2]
         { info_tbl: [(c8UGu,
                       label: $wgo_s8TRX_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UGu: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8UGv; else goto c8UGw;
       c8UGv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UGw: // global
           I64[Sp - 56] = block_c8UGp_info;
           _s8TRX::P64 = R1;
           _s8TRx::P64 = P64[R1 + 6];
           _s8TRz::P64 = P64[R1 + 14];
           _s8TRF::P64 = P64[R1 + 22];
           _s8TRW::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 48] = _s8TRx::P64;
           P64[Sp - 40] = _s8TRz::P64;
           P64[Sp - 32] = _s8TRF::P64;
           P64[Sp - 24] = _s8TRW::P64;
           P64[Sp - 16] = _s8TRX::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 56;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UGp() //  [R1]
         { info_tbl: [(c8UGp,
                       label: block_c8UGp_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UGp: // global
           I64[Sp] = block_c8UGr_info;
           _s8TS5::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s8TS5::P64;
           if (R1 & 7 != 0) goto u8UH5; else goto c8UGs;
       u8UH5: // global
           call _c8UGr(R1) args: 0, res: 0, upd: 0;
       c8UGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UGr() //  [R1]
         { info_tbl: [(c8UGr,
                       label: block_c8UGr_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UGr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8UGC; else goto c8UGB;
       c8UGC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UGB: // global
           _s8TS7::P64 = P64[R1 + 7];
           _s8TS8::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48];
           _s8TRz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8UGH_info;
           R6 = P64[Sp + 24] + 16;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 8];
           R3 = _s8TS8::P64;
           R2 = _s8TS7::P64;
           P64[Sp] = Hp - 7;
           P64[Sp + 8] = _s8TRz::P64;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8UGH() //  [R1]
         { info_tbl: [(c8UGH,
                       label: block_c8UGH_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UGH: // global
           I64[Sp] = block_c8UGJ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UH6; else goto c8UGL;
       u8UH6: // global
           call _c8UGJ(R1) args: 0, res: 0, upd: 0;
       c8UGL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UGJ() //  [R1]
         { info_tbl: [(c8UGJ,
                       label: block_c8UGJ_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UGJ: // global
           if (R1 & 7 == 1) goto c8UGV; else goto c8UH1;
       c8UGV: // global
           I64[Sp] = block_c8UGT_info;
           R2 = I64[Sp + 32] << 1;
           R1 = P64[Sp + 24];
           call $wgo_s8TRX_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8UH1: // global
           _s8TSn::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 8]);
           R1 = _s8TSn::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UGT() //  [R1]
         { info_tbl: [(c8UGT,
                       label: block_c8UGT_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UGT: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8TSF_entry() //  [R1, R2]
         { info_tbl: [(c8UH7,
                       label: sat_s8TSF_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UH7: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8UH8; else goto c8UH9;
       c8UH8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UH9: // global
           I64[Sp - 40] = block_c8UFZ_info;
           R3 = 0;
           _s8TRF::P64 = R2;
           _s8TRy::P64 = P64[R1 + 14];
           R2 = _s8TRy::P64;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = _s8TRy::P64;
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _s8TRF::P64;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8UFZ() //  [R1]
         { info_tbl: [(c8UFZ,
                       label: block_c8UFZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UFZ: // global
           I64[Sp - 8] = block_c8UG6_info;
           R2 = 4;
           _s8TRH::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TRH::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UG6() //  [R1]
         { info_tbl: [(c8UG6,
                       label: block_c8UG6_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UG6: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c8UHo() args: 0, res: 0, upd: 0;
     }
 },
 _c8UHo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UHo: // global
           _s8TSv::P64 = P64[Sp];
           I64[Sp] = block_c8UHr_info;
           R1 = _s8TSv::P64;
           if (R1 & 7 != 0) goto u8UHQ; else goto c8UHt;
       u8UHQ: // global
           call _c8UHr(R1) args: 0, res: 0, upd: 0;
       c8UHt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UHr() //  [R1]
         { info_tbl: [(c8UHr,
                       label: block_c8UHr_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UHr: // global
           if (R1 & 7 == 1) goto c8UHz; else goto c8UHE;
       c8UHz: // global
           I64[Sp + 8] = block_c8UGg_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8UHE: // global
           I64[Sp - 8] = block_c8UHC_info;
           _s8TSA::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TSA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8UHR; else goto c8UHF;
       u8UHR: // global
           call _c8UHC(R1) args: 0, res: 0, upd: 0;
       c8UHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UGg() //  [R1]
         { info_tbl: [(c8UGg,
                       label: block_c8UGg_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UGg: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8UHf; else goto c8UHe;
       c8UHf: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UHe: // global
           I64[Hp - 104] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = Hp - 103;
           P64[Hp - 72] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 64] = I64[Sp + 8];
           _s8TRH::I64 = I64[Sp + 16];
           I64[Hp - 56] = _s8TRH::I64;
           I64[Hp - 48] = 0;
           I64[Hp - 40] = _s8TRH::I64;
           I64[Hp - 32] = $wgo_s8TRX_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = Hp - 87;
           I64[Sp + 24] = block_c8UHj_info;
           R2 = _s8TRH::I64 + 1;
           R1 = Hp - 30;
           Sp = Sp + 24;
           call $wgo_s8TRX_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UHj() //  [R1]
         { info_tbl: [(c8UHj,
                       label: block_c8UHj_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UHj: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UHC() //  [R1]
         { info_tbl: [(c8UHC,
                       label: block_c8UHC_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UHC: // global
           _s8TSw::I64 = I64[Sp + 16];
           _s8TSA::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TSw::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TSA::P64;
           I64[Sp + 16] = _s8TSw::I64 + 1;
           Sp = Sp + 8;
           call _c8UHo() args: 0, res: 0, upd: 0;
     }
 },
 withEncodedCString1_r8TNp_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8UHT,
                       label: withEncodedCString1_r8TNp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UHT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8UHU; else goto c8UHV;
       c8UHU: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withEncodedCString1_r8TNp_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UHV: // global
           I64[Sp - 32] = block_c8UFP_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8UHZ; else goto c8UFQ;
       u8UHZ: // global
           call _c8UFP(R1) args: 0, res: 0, upd: 0;
       c8UFQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UFP() //  [R1]
         { info_tbl: [(c8UFP,
                       label: block_c8UFP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UFP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8UHY; else goto c8UHX;
       c8UHY: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UHX: // global
           _s8TRE::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_s8TSF_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = Hp - 22;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TRE::P64;
           Sp = Sp + 32;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.718248182 UTC

[section ""data" . GHC.Foreign.withEncodedCString_closure" {
     GHC.Foreign.withEncodedCString_closure:
         const GHC.Foreign.withEncodedCString_info;
 },
 GHC.Foreign.withEncodedCString_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8UI4,
                       label: GHC.Foreign.withEncodedCString_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UI4: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withEncodedCString1_r8TNp_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.722168066 UTC

[section ""data" . GHC.Foreign.charIsRepresentable3_closure" {
     GHC.Foreign.charIsRepresentable3_closure:
         const GHC.Foreign.charIsRepresentable3_info;
 },
 $wgo_s8TT6_entry() //  [R1, R2]
         { info_tbl: [(c8UIU,
                       label: $wgo_s8TT6_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UIU: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8UIV; else goto c8UIW;
       c8UIV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UIW: // global
           I64[Sp - 48] = block_c8UIL_info;
           _s8TT6::P64 = R1;
           _s8TSI::P64 = P64[R1 + 6];
           _s8TSO::P64 = P64[R1 + 14];
           _s8TT5::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _s8TSI::P64;
           P64[Sp - 32] = _s8TSO::P64;
           P64[Sp - 24] = _s8TT5::P64;
           P64[Sp - 16] = _s8TT6::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 48;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UIL() //  [R1]
         { info_tbl: [(c8UIL,
                       label: block_c8UIL_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UIL: // global
           I64[Sp - 8] = block_c8UIN_info;
           _s8TTe::P64 = R1;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp] = _s8TTe::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UIN() //  [R1]
         { info_tbl: [(c8UIN,
                       label: block_c8UIN_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UIN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8UJ0; else goto c8UIZ;
       c8UJ0: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UIZ: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 24] = P64[Sp + 8] + 16;
           I64[Hp - 16] = I64[Sp + 48];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp] = Hp - 47;
           P64[Sp + 32] = P64[Sp + 32];
           call _c8UJT() args: 0, res: 0, upd: 0;
     }
 },
 _c8UJT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UJT: // global
           I64[Sp - 8] = block_c8UJV_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8UKU; else goto c8UJW;
       u8UKU: // global
           call _c8UJV(R1) args: 0, res: 0, upd: 0;
       c8UJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UJV() //  [R1]
         { info_tbl: [(c8UJV,
                       label: block_c8UJV_info
                       rep:StackRep [False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UJV: // global
           _s8TTO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8UK0_info;
           R3 = _s8TTO::P64;
           R2 = P64[Sp + 40];
           _s8TTS::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 40] = _s8TTS::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UK0() //  [R1]
         { info_tbl: [(c8UK0,
                       label: block_c8UK0_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UK0: // global
           I64[Sp] = block_c8UK2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UKV; else goto c8UK3;
       u8UKV: // global
           call _c8UK2(R1) args: 0, res: 0, upd: 0;
       c8UK3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UK2() //  [R1]
         { info_tbl: [(c8UK2,
                       label: block_c8UK2_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UK2: // global
           I64[Sp - 16] = block_c8UK7_info;
           _s8TU0::P64 = P64[R1 + 7];
           _s8TU2::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TU2::P64;
           P64[Sp] = _s8TU0::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8UKW; else goto c8UKc;
       u8UKW: // global
           call _c8UK7(R1) args: 0, res: 0, upd: 0;
       c8UKc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UK7() //  [R1]
         { info_tbl: [(c8UK7,
                       label: block_c8UK7_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UK7: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8UKH; else goto c8UKm;
       c8UKH: // global
           I64[Sp + 16] = block_c8UJi_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u8UKY; else goto c8UJk;
       u8UKY: // global
           call _c8UJi(R1) args: 0, res: 0, upd: 0;
       c8UJk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UKm: // global
           I64[Sp] = block_c8UKk_info;
           _s8TU3::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TU3::P64;
           if (R1 & 7 != 0) goto u8UKX; else goto c8UKn;
       u8UKX: // global
           call _c8UKk(R1) args: 0, res: 0, upd: 0;
       c8UKn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UJi() //  [R1]
         { info_tbl: [(c8UJi,
                       label: block_c8UJi_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UJi: // global
           _s8TTy::I64 = I64[R1 + 47];
           _s8TTz::I64 = I64[R1 + 31] - _s8TTy::I64;
           if (_s8TTz::I64 != 0) goto u8UKP; else goto c8UJG;
       u8UKP: // global
           I64[Sp + 24] = _s8TTz::I64;
           I64[Sp + 32] = _s8TTy::I64;
           P64[Sp + 40] = P64[R1 + 7];
           I64[Sp + 48] = I64[R1 + 23];
           Sp = Sp + 8;
           call _c8UJt() args: 0, res: 0, upd: 0;
       c8UJG: // global
           I64[Sp] = block_c8UJN_info;
           R2 = I64[Sp + 48] << 1;
           R1 = P64[Sp + 40];
           call $wgo_s8TT6_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UJt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UJt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8UJB; else goto c8UJA;
       c8UJB: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8UJs_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8UJA: // global
           _s8TSI::P64 = P64[Sp + 8];
           _s8TTt::I64 = I64[Sp + 40];
           I8[_s8TTt::I64 + I64[Sp + 24]] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8TTt::I64;
           I64[Sp - 8] = block_c8UJw_info;
           R2 = Hp - 7;
           R1 = _s8TSI::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UJs() //  [R1]
         { info_tbl: [(c8UJs,
                       label: block_c8UJs_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UJs: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8UJt() args: 0, res: 0, upd: 0;
     }
 },
 _c8UJw() //  [R1]
         { info_tbl: [(c8UJw,
                       label: block_c8UJw_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UJw: // global
           _s8TTe::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 40]);
           call MO_Touch(_s8TTe::P64);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UJN() //  [R1]
         { info_tbl: [(c8UJN,
                       label: block_c8UJN_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UJN: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UKk() //  [R1]
         { info_tbl: [(c8UKk,
                       label: block_c8UKk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UKk: // global
           if (R1 & 7 == 2) goto c8UKG; else goto c8UKw;
       c8UKG: // global
           I64[Sp + 16] = block_c8UJa_info;
           R2 = I64[Sp + 64] << 1;
           R1 = P64[Sp + 56];
           Sp = Sp + 16;
           call $wgo_s8TT6_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8UKw: // global
           _s8TU3::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8UKr_info;
           R3 = P64[Sp + 8];
           R2 = _s8TU3::P64;
           R1 = P64[Sp + 48];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UJa() //  [R1]
         { info_tbl: [(c8UJa,
                       label: block_c8UJa_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UJa: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UKr() //  [R1]
         { info_tbl: [(c8UKr,
                       label: block_c8UKr_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UKr: // global
           I64[Sp] = block_c8UKt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UKZ; else goto c8UKy;
       u8UKZ: // global
           call _c8UKt(R1) args: 0, res: 0, upd: 0;
       c8UKy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UKt() //  [R1]
         { info_tbl: [(c8UKt,
                       label: block_c8UKt_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UKt: // global
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           call _c8UJT() args: 0, res: 0, upd: 0;
     }
 },
 sat_s8TUB_entry() //  [R1, R2]
         { info_tbl: [(c8UL1,
                       label: sat_s8TUB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UL1: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8UL2; else goto c8UL3;
       c8UL2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UL3: // global
           I64[Sp - 32] = block_c8UIl_info;
           R3 = 0;
           _s8TSO::P64 = R2;
           _s8TSH::P64 = P64[R1 + 6];
           R2 = _s8TSH::P64;
           P64[Sp - 24] = _s8TSH::P64;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = _s8TSO::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8UIl() //  [R1]
         { info_tbl: [(c8UIl,
                       label: block_c8UIl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UIl: // global
           I64[Sp - 8] = block_c8UIs_info;
           R2 = 4;
           _s8TSQ::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TSQ::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UIs() //  [R1]
         { info_tbl: [(c8UIs,
                       label: block_c8UIs_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UIs: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8ULi() args: 0, res: 0, upd: 0;
     }
 },
 _c8ULi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ULi: // global
           _s8TUr::P64 = P64[Sp];
           I64[Sp] = block_c8ULl_info;
           R1 = _s8TUr::P64;
           if (R1 & 7 != 0) goto u8ULK; else goto c8ULn;
       u8ULK: // global
           call _c8ULl(R1) args: 0, res: 0, upd: 0;
       c8ULn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ULl() //  [R1]
         { info_tbl: [(c8ULl,
                       label: block_c8ULl_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ULl: // global
           if (R1 & 7 == 1) goto c8ULt; else goto c8ULy;
       c8ULt: // global
           I64[Sp + 8] = block_c8UIC_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8ULy: // global
           I64[Sp - 8] = block_c8ULw_info;
           _s8TUw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TUw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ULL; else goto c8ULz;
       u8ULL: // global
           call _c8ULw(R1) args: 0, res: 0, upd: 0;
       c8ULz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UIC() //  [R1]
         { info_tbl: [(c8UIC,
                       label: block_c8UIC_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UIC: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c8UL9; else goto c8UL8;
       c8UL9: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UL8: // global
           I64[Hp - 96] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = Hp - 95;
           P64[Hp - 64] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 56] = I64[Sp + 8];
           _s8TSQ::I64 = I64[Sp + 16];
           I64[Hp - 48] = _s8TSQ::I64;
           I64[Hp - 40] = 0;
           I64[Hp - 32] = _s8TSQ::I64;
           I64[Hp - 24] = $wgo_s8TT6_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 79;
           I64[Sp + 16] = block_c8ULd_info;
           R2 = _s8TSQ::I64 + 1;
           R1 = Hp - 22;
           Sp = Sp + 16;
           call $wgo_s8TT6_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ULd() //  [R1]
         { info_tbl: [(c8ULd,
                       label: block_c8ULd_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ULd: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ULw() //  [R1]
         { info_tbl: [(c8ULw,
                       label: block_c8ULw_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ULw: // global
           _s8TUs::I64 = I64[Sp + 16];
           _s8TUw::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TUs::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TUw::P64;
           I64[Sp + 16] = _s8TUs::I64 + 1;
           Sp = Sp + 8;
           call _c8ULi() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Foreign.charIsRepresentable3_entry() //  [R2, R3, R4]
         { info_tbl: [(c8ULN,
                       label: GHC.Foreign.charIsRepresentable3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ULN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8ULO; else goto c8ULP;
       c8ULO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ULP: // global
           I64[Sp - 24] = block_c8UIb_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8ULT; else goto c8UIc;
       u8ULT: // global
           call _c8UIb(R1) args: 0, res: 0, upd: 0;
       c8UIc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UIb() //  [R1]
         { info_tbl: [(c8UIb,
                       label: block_c8UIb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UIb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ULS; else goto c8ULR;
       c8ULS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ULR: // global
           _s8TSN::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8TUB_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TSN::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.729295435 UTC

[section ""data" . GHC.Foreign.withCString_closure" {
     GHC.Foreign.withCString_closure:
         const GHC.Foreign.withCString_info;
 },
 GHC.Foreign.withCString_entry() //  [R2, R3, R4]
         { info_tbl: [(c8ULY,
                       label: GHC.Foreign.withCString_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ULY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.731090246 UTC

[section ""data" . GHC.Foreign.withCStringsLen1_closure" {
     GHC.Foreign.withCStringsLen1_closure:
         const GHC.Foreign.withCStringsLen1_info;
         const 0;
 },
 sat_s8TUL_entry() //  [R1]
         { info_tbl: [(c8UMj,
                       label: sat_s8TUL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UMj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UMk; else goto c8UMl;
       c8UMk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8UMl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TUR_entry() //  [R1, R2]
         { info_tbl: [(c8UMu,
                       label: sat_s8TUR_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UMu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UMy; else goto c8UMx;
       c8UMy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UMx: // global
           _s8TUG::P64 = P64[R1 + 6];
           _s8TUH::P64 = P64[R1 + 14];
           _s8TUN::P64 = P64[R1 + 22];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = _s8TUH::P64;
           R3 = _s8TUN::P64;
           R2 = Hp - 14;
           R1 = _s8TUG::P64;
           call go_s8TUG_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s8TUG_entry() //  [R1, R2, R3]
         { info_tbl: [(c8UMD,
                       label: go_s8TUG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UMD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8UME; else goto c8UMF;
       c8UME: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UMF: // global
           I64[Sp - 40] = block_c8UMa_info;
           _s8TUG::P64 = R1;
           _s8TUC::P64 = P64[R1 + 5];
           _s8TUE::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 32] = _s8TUC::P64;
           P64[Sp - 24] = _s8TUE::P64;
           P64[Sp - 16] = _s8TUG::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8UMM; else goto c8UMb;
       u8UMM: // global
           call _c8UMa(R1) args: 0, res: 0, upd: 0;
       c8UMb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UMa() //  [R1]
         { info_tbl: [(c8UMa,
                       label: block_c8UMa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UMa: // global
           _s8TUH::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c8UMA; else goto c8UMB;
       c8UMA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UMI; else goto c8UMH;
       c8UMI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UMH: // global
           I64[Hp - 16] = sat_s8TUL_info;
           P64[Hp] = _s8TUH::P64;
           R4 = P64[Sp + 16];
           R3 = Hp - 16;
           R2 = Foreign.Storable.$fStorablePtr_closure;
           I64[Sp + 32] = stg_ap_v_info;
           Sp = Sp + 32;
           call Foreign.Marshal.Array.withArrayLen_entry(R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
       c8UMB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8UML; else goto c8UMK;
       c8UML: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UMK: // global
           _s8TUM::P64 = P64[R1 + 6];
           _s8TUN::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s8TUR_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _s8TUH::P64;
           P64[Hp] = _s8TUN::P64;
           R4 = Hp - 22;
           R3 = _s8TUM::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.withCStringsLen1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8UMN,
                       label: GHC.Foreign.withCStringsLen1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UMN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UMR; else goto c8UMQ;
       c8UMR: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.withCStringsLen1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UMQ: // global
           I64[Hp - 16] = go_s8TUG_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R3 = R3;
           R2 = GHC.Types.[]_closure+1;
           R1 = Hp - 13;
           call go_s8TUG_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.733703194 UTC

[section ""data" . GHC.Foreign.withCStringsLen_closure" {
     GHC.Foreign.withCStringsLen_closure:
         const GHC.Foreign.withCStringsLen_info;
         const 0;
 },
 GHC.Foreign.withCStringsLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8UMW,
                       label: GHC.Foreign.withCStringsLen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UMW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.734545976 UTC

[section ""data" . GHC.Foreign.withCStringLen_closure" {
     GHC.Foreign.withCStringLen_closure:
         const GHC.Foreign.withCStringLen_info;
 },
 GHC.Foreign.withCStringLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8UN3,
                       label: GHC.Foreign.withCStringLen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UN3: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call GHC.Foreign.withEncodedCString_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.735293951 UTC

[section ""data" . GHC.Foreign.newCString2_closure" {
     GHC.Foreign.newCString2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.73820014 UTC

[section ""data" . newEncodedCString1_r8TNq_closure" {
     newEncodedCString1_r8TNq_closure:
         const newEncodedCString1_r8TNq_info;
         const 0;
 },
 sat_s8TWa_entry() //  [R1, R2]
         { info_tbl: [(c8UOv,
                       label: sat_s8TWa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UOv: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8UOw; else goto c8UOx;
       c8UOw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UOx: // global
           I64[Sp - 32] = block_c8UNk_info;
           R3 = 0;
           _s8TV1::P64 = R2;
           _s8TUV::P64 = P64[R1 + 14];
           R2 = _s8TUV::P64;
           P64[Sp - 24] = P64[R1 + 6];
           P64[Sp - 16] = _s8TUV::P64;
           P64[Sp - 8] = _s8TV1::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8UNk() //  [R1]
         { info_tbl: [(c8UNk,
                       label: block_c8UNk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UNk: // global
           I64[Sp - 8] = block_c8UNr_info;
           R2 = 4;
           _s8TV3::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TV3::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UNr() //  [R1]
         { info_tbl: [(c8UNr,
                       label: block_c8UNr_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UNr: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c8UPc() args: 0, res: 0, upd: 0;
     }
 },
 _c8UPc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UPc: // global
           _s8TW0::P64 = P64[Sp];
           I64[Sp] = block_c8UPf_info;
           R1 = _s8TW0::P64;
           if (R1 & 7 != 0) goto u8UPU; else goto c8UPh;
       u8UPU: // global
           call _c8UPf(R1) args: 0, res: 0, upd: 0;
       c8UPh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UPf() //  [R1]
         { info_tbl: [(c8UPf,
                       label: block_c8UPf_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UPf: // global
           if (R1 & 7 == 1) goto c8UPn; else goto c8UPs;
       c8UPn: // global
           I64[Sp + 8] = block_c8UNB_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8UPs: // global
           I64[Sp - 8] = block_c8UPq_info;
           _s8TW5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TW5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8UPV; else goto c8UPt;
       u8UPV: // global
           call _c8UPq(R1) args: 0, res: 0, upd: 0;
       c8UPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UNB() //  [R1]
         { info_tbl: [(c8UNB,
                       label: block_c8UNB_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UNB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8UOD; else goto c8UOC;
       c8UOD: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UOC: // global
           _s8TV3::I64 = I64[Sp + 16];
           _s8TVb::I64 = I64[Sp + 8];
           _s8TVh::I64 = _s8TV3::I64 + 1;
           (_s8TVm::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8TVh::I64);
           if (_s8TVm::I64 == 0) goto c8UP9; else goto c8UP8;
       c8UP9: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8UP8: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8TVb::I64;
           I64[Hp - 32] = _s8TV3::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8TV3::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TVh::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8TVm::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8UNV() args: 0, res: 0, upd: 0;
     }
 },
 _c8UNV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UNV: // global
           I64[Sp - 8] = block_c8UNY_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8UPN; else goto c8UNZ;
       u8UPN: // global
           call _c8UNY(R1) args: 0, res: 0, upd: 0;
       c8UNZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UNY() //  [R1]
         { info_tbl: [(c8UNY,
                       label: block_c8UNY_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UNY: // global
           I64[Sp] = block_c8UO3_info;
           R6 = I64[Sp + 16];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 32];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 8];
           P64[Sp - 8] = GHC.Base.$fApplicativeIO4_closure+2;
           Sp = Sp - 16;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8UO3() //  [R1]
         { info_tbl: [(c8UO3,
                       label: block_c8UO3_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UO3: // global
           I64[Sp] = block_c8UO5_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UPO; else goto c8UO6;
       u8UPO: // global
           call _c8UO5(R1) args: 0, res: 0, upd: 0;
       c8UO6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UO5() //  [R1]
         { info_tbl: [(c8UO5,
                       label: block_c8UO5_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UO5: // global
           if (R1 & 7 == 1) goto c8UON; else goto c8UP6;
       c8UON: // global
           _s8TVw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8UOa_info;
           R1 = _s8TVw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8UPP; else goto c8UOb;
       u8UPP: // global
           call _c8UOa(R1) args: 0, res: 0, upd: 0;
       c8UOb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UP6: // global
           _s8TVs::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 40]);
           R1 = _s8TVs::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UOa() //  [R1]
         { info_tbl: [(c8UOa,
                       label: block_c8UOa_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UOa: // global
           _s8TVK::I64 = I64[R1 + 7] << 1;
           if (_s8TVK::I64 != 0) goto u8UPH; else goto c8UOZ;
       u8UPH: // global
           I64[Sp] = _s8TVK::I64;
           call _c8UOj() args: 0, res: 0, upd: 0;
       c8UOZ: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = GHC.Foreign.newCString2_closure+1;
           call _c8UNV() args: 0, res: 0, upd: 0;
     }
 },
 _c8UOj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UOj: // global
           Hp = Hp + 16;
           _s8TVK::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8UOT; else goto c8UOS;
       c8UOT: // global
           HpAlloc = 16;
           I64[Sp] = block_c8UOi_info;
           R1 = _s8TVK::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8UOS: // global
           (_s8TVP::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8TVK::I64);
           if (_s8TVP::I64 == 0) goto c8UOW; else goto c8UOV;
       c8UOW: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8UOV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TVK::I64;
           I64[Sp + 8] = _s8TVP::I64;
           P64[Sp] = Hp - 7;
           call _c8UNV() args: 0, res: 0, upd: 0;
     }
 },
 _c8UOi() //  [R1]
         { info_tbl: [(c8UOi,
                       label: block_c8UOi_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UOi: // global
           I64[Sp] = R1;
           call _c8UOj() args: 0, res: 0, upd: 0;
     }
 },
 _c8UPq() //  [R1]
         { info_tbl: [(c8UPq,
                       label: block_c8UPq_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UPq: // global
           _s8TW1::I64 = I64[Sp + 16];
           _s8TW5::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TW1::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TW5::P64;
           I64[Sp + 16] = _s8TW1::I64 + 1;
           Sp = Sp + 8;
           call _c8UPc() args: 0, res: 0, upd: 0;
     }
 },
 newEncodedCString1_r8TNq_entry() //  [R2, R3, R4]
         { info_tbl: [(c8UPX,
                       label: newEncodedCString1_r8TNq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UPX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8UPY; else goto c8UPZ;
       c8UPY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = newEncodedCString1_r8TNq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UPZ: // global
           I64[Sp - 24] = block_c8UNa_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8UQ3; else goto c8UNb;
       u8UQ3: // global
           call _c8UNa(R1) args: 0, res: 0, upd: 0;
       c8UNb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UNa() //  [R1]
         { info_tbl: [(c8UNa,
                       label: block_c8UNa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UNa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UQ2; else goto c8UQ1;
       c8UQ2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UQ1: // global
           _s8TV0::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8TWa_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TV0::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.744945981 UTC

[section ""data" . GHC.Foreign.newEncodedCString_closure" {
     GHC.Foreign.newEncodedCString_closure:
         const GHC.Foreign.newEncodedCString_info;
         const 0;
 },
 GHC.Foreign.newEncodedCString_entry() //  [R2, R3, R4]
         { info_tbl: [(c8UQ8,
                       label: GHC.Foreign.newEncodedCString_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UQ8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call newEncodedCString1_r8TNq_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.750699338 UTC

[section ""data" . GHC.Foreign.newCString1_closure" {
     GHC.Foreign.newCString1_closure:
         const GHC.Foreign.newCString1_info;
         const 0;
 },
 sat_s8TY4_entry() //  [R1]
         { info_tbl: [(c8URM,
                       label: sat_s8TY4_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8URM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8URR; else goto c8URS;
       c8URR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8URS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8URJ_info;
           _s8TWX::P64 = P64[R1 + 24];
           _s8TWM::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8TWM::I64;
           P64[Sp - 24] = _s8TWX::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8URW; else goto c8URK;
       u8URW: // global
           call _c8URJ(R1) args: 0, res: 0, upd: 0;
       c8URK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8URJ() //  [R1]
         { info_tbl: [(c8URJ,
                       label: block_c8URJ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8URJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8URV; else goto c8URU;
       c8URV: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8URU: // global
           _s8TY2::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8TY2::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TYi_entry() //  [R1, R2]
         { info_tbl: [(c8URX,
                       label: sat_s8TYi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8URX: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c8URY; else goto c8URZ;
       c8URY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8URZ: // global
           I64[Sp - 24] = block_c8UQp_info;
           R3 = 0;
           _s8TWi::P64 = R2;
           _s8TWc::P64 = P64[R1 + 6];
           R2 = _s8TWc::P64;
           P64[Sp - 16] = _s8TWc::P64;
           P64[Sp - 8] = _s8TWi::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8UQp() //  [R1]
         { info_tbl: [(c8UQp,
                       label: block_c8UQp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UQp: // global
           I64[Sp - 8] = block_c8UQw_info;
           R2 = 4;
           _s8TWk::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TWk::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UQw() //  [R1]
         { info_tbl: [(c8UQw,
                       label: block_c8UQw_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UQw: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8UU2() args: 0, res: 0, upd: 0;
     }
 },
 _c8UU2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UU2: // global
           _s8TY8::P64 = P64[Sp];
           I64[Sp] = block_c8UU5_info;
           R1 = _s8TY8::P64;
           if (R1 & 7 != 0) goto u8UVd; else goto c8UU7;
       u8UVd: // global
           call _c8UU5(R1) args: 0, res: 0, upd: 0;
       c8UU7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UU5() //  [R1]
         { info_tbl: [(c8UU5,
                       label: block_c8UU5_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UU5: // global
           if (R1 & 7 == 1) goto c8UUd; else goto c8UUi;
       c8UUd: // global
           I64[Sp + 8] = block_c8UQG_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8UUi: // global
           I64[Sp - 8] = block_c8UUg_info;
           _s8TYd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TYd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8UVe; else goto c8UUj;
       u8UVe: // global
           call _c8UUg(R1) args: 0, res: 0, upd: 0;
       c8UUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UQG() //  [R1]
         { info_tbl: [(c8UQG,
                       label: block_c8UQG_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UQG: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8US5; else goto c8US4;
       c8US5: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8US4: // global
           _s8TWk::I64 = I64[Sp + 16];
           _s8TWs::I64 = I64[Sp + 8];
           _s8TWy::I64 = _s8TWk::I64 + 1;
           (_s8TWD::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8TWy::I64);
           if (_s8TWD::I64 == 0) goto c8UTZ; else goto c8UTY;
       c8UTZ: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8UTY: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8TWs::I64;
           I64[Hp - 32] = _s8TWk::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8TWk::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TWy::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8TWD::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8UR0() args: 0, res: 0, upd: 0;
     }
 },
 _c8UR0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UR0: // global
           I64[Sp - 8] = block_c8UR3_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8UUU; else goto c8UR4;
       u8UUU: // global
           call _c8UR3(R1) args: 0, res: 0, upd: 0;
       c8UR4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UR3() //  [R1]
         { info_tbl: [(c8UR3,
                       label: block_c8UR3_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UR3: // global
           I64[Sp - 16] = block_c8UR8_info;
           _s8TWQ::P64 = P64[R1 + 7];
           _s8TWR::P64 = P64[R1 + 15];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = _s8TWR::P64;
           P64[Sp] = _s8TWQ::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UR8() //  [R1]
         { info_tbl: [(c8UR8,
                       label: block_c8UR8_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UR8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8USe; else goto c8USd;
       c8USe: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8USd: // global
           I64[Hp - 32] = sat_s8TY4_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 32];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = P64[Sp + 40];
           Sp = Sp - 8;
           call _c8UTe() args: 0, res: 0, upd: 0;
     }
 },
 _c8UTe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UTe: // global
           _s8TXC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8UTg_info;
           R3 = P64[Sp];
           R2 = _s8TXC::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UTg() //  [R1]
         { info_tbl: [(c8UTg,
                       label: block_c8UTg_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UTg: // global
           I64[Sp] = block_c8UTi_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UV6; else goto c8UTj;
       u8UV6: // global
           call _c8UTi(R1) args: 0, res: 0, upd: 0;
       c8UTj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UTi() //  [R1]
         { info_tbl: [(c8UTi,
                       label: block_c8UTi_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UTi: // global
           I64[Sp - 16] = block_c8UTn_info;
           _s8TXJ::P64 = P64[R1 + 7];
           _s8TXL::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TXL::P64;
           P64[Sp] = _s8TXJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8UV7; else goto c8UTr;
       u8UV7: // global
           call _c8UTn(R1) args: 0, res: 0, upd: 0;
       c8UTr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UTn() //  [R1]
         { info_tbl: [(c8UTn,
                       label: block_c8UTn_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UTn: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8UTW; else goto c8UTB;
       c8UTW: // global
           I64[Sp + 32] = block_c8USN_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8UV9; else goto c8USP;
       u8UV9: // global
           call _c8USN(R1) args: 0, res: 0, upd: 0;
       c8USP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UTB: // global
           I64[Sp] = block_c8UTz_info;
           _s8TXM::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TXM::P64;
           if (R1 & 7 != 0) goto u8UV8; else goto c8UTC;
       u8UV8: // global
           call _c8UTz(R1) args: 0, res: 0, upd: 0;
       c8UTC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8USN() //  [R1]
         { info_tbl: [(c8USN,
                       label: block_c8USN_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8USN: // global
           _s8TXs::I64 = I64[R1 + 47];
           _s8TXt::I64 = I64[R1 + 31] - _s8TXs::I64;
           if (_s8TXt::I64 != 0) goto u8UUK; else goto u8UUJ;
       u8UUK: // global
           P64[Sp - 32] = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 39];
           I64[Sp - 16] = _s8TXs::I64;
           I64[Sp - 8] = _s8TXt::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8UT0() args: 0, res: 0, upd: 0;
       u8UUJ: // global
           Sp = Sp + 8;
           call _c8UT7() args: 0, res: 0, upd: 0;
     }
 },
 _c8UT0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UT0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8UT4; else goto c8UT3;
       c8UT4: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_c8USX_info;
           R1 = I64[Sp + 24];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8UT3: // global
           _s8TXn::I64 = I64[Sp + 32];
           _s8TXo::P64 = P64[Sp];
           _s8TXr::I64 = I64[Sp + 8];
           _s8TXs::I64 = I64[Sp + 16];
           I8[_s8TXn::I64 + _s8TXs::I64] = 0 :: W8;
           call MO_Touch(_s8TXo::P64);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _s8TXs::I64 - _s8TXr::I64;
           I64[Hp - 48] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 40] = _s8TXn::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 63;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           P64[Sp + 32] = Hp - 6;
           Sp = Sp + 32;
           call _s8TWY() args: 0, res: 0, upd: 0;
     }
 },
 _c8USX() //  [R1]
         { info_tbl: [(c8USX,
                       label: block_c8USX_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8USX: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _c8UT0() args: 0, res: 0, upd: 0;
     }
 },
 _c8UTz() //  [R1]
         { info_tbl: [(c8UTz,
                       label: block_c8UTz_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UTz: // global
           if (R1 & 7 == 2) goto u8UUH; else goto c8UTL;
       u8UUH: // global
           Sp = Sp + 40;
           call _c8UT7() args: 0, res: 0, upd: 0;
       c8UTL: // global
           _s8TXM::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8UTG_info;
           R3 = P64[Sp + 8];
           R2 = _s8TXM::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UT7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UT7: // global
           P64[Sp - 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call _s8TWY() args: 0, res: 0, upd: 0;
     }
 },
 _s8TWY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TWY: // global
           _s8TX0::P64 = P64[Sp];
           I64[Sp] = block_c8URh_info;
           R1 = _s8TX0::P64;
           if (R1 & 7 != 0) goto u8UVg; else goto c8URi;
       u8UVg: // global
           call _c8URh(R1) args: 0, res: 0, upd: 0;
       c8URi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8URh() //  [R1]
         { info_tbl: [(c8URh,
                       label: block_c8URh_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8URh: // global
           if (R1 & 7 == 1) goto c8USi; else goto c8USB;
       c8USi: // global
           _s8TWN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8URm_info;
           R1 = _s8TWN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8UUW; else goto c8URn;
       u8UUW: // global
           call _c8URm(R1) args: 0, res: 0, upd: 0;
       c8URn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8USB: // global
           _s8TWJ::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 32]);
           R1 = _s8TWJ::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8URm() //  [R1]
         { info_tbl: [(c8URm,
                       label: block_c8URm_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8URm: // global
           _s8TX4::I64 = I64[R1 + 7] << 1;
           if (_s8TX4::I64 != 0) goto u8UUO; else goto c8USu;
       u8UUO: // global
           I64[Sp] = _s8TX4::I64;
           call _c8URv() args: 0, res: 0, upd: 0;
       c8USu: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = GHC.Foreign.newCString2_closure+1;
           call _c8UR0() args: 0, res: 0, upd: 0;
     }
 },
 _c8URv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8URv: // global
           Hp = Hp + 16;
           _s8TX4::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8USo; else goto c8USn;
       c8USo: // global
           HpAlloc = 16;
           I64[Sp] = block_c8URu_info;
           R1 = _s8TX4::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8USn: // global
           (_s8TX9::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8TX4::I64);
           if (_s8TX9::I64 == 0) goto c8USr; else goto c8USq;
       c8USr: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8USq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TX4::I64;
           I64[Sp + 8] = _s8TX9::I64;
           P64[Sp] = Hp - 7;
           call _c8UR0() args: 0, res: 0, upd: 0;
     }
 },
 _c8URu() //  [R1]
         { info_tbl: [(c8URu,
                       label: block_c8URu_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8URu: // global
           I64[Sp] = R1;
           call _c8URv() args: 0, res: 0, upd: 0;
     }
 },
 _c8UTG() //  [R1]
         { info_tbl: [(c8UTG,
                       label: block_c8UTG_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UTG: // global
           I64[Sp] = block_c8UTI_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UVb; else goto c8UTN;
       u8UVb: // global
           call _c8UTI(R1) args: 0, res: 0, upd: 0;
       c8UTN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UTI() //  [R1]
         { info_tbl: [(c8UTI,
                       label: block_c8UTI_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UTI: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _c8UTe() args: 0, res: 0, upd: 0;
     }
 },
 _c8UUg() //  [R1]
         { info_tbl: [(c8UUg,
                       label: block_c8UUg_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UUg: // global
           _s8TY9::I64 = I64[Sp + 16];
           _s8TYd::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TY9::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TYd::P64;
           I64[Sp + 16] = _s8TY9::I64 + 1;
           Sp = Sp + 8;
           call _c8UU2() args: 0, res: 0, upd: 0;
     }
 },
 sat_s8TYm_entry() //  [R1]
         { info_tbl: [(c8UVn,
                       label: sat_s8TYm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UVn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UVo; else goto c8UVp;
       c8UVo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8UVp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.fst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Foreign.newCString1_entry() //  [R2, R3]
         { info_tbl: [(c8UVq,
                       label: GHC.Foreign.newCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UVq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UVr; else goto c8UVs;
       c8UVr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.newCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8UVs: // global
           I64[Sp - 16] = block_c8UQf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8UVz; else goto c8UQg;
       u8UVz: // global
           call _c8UQf(R1) args: 0, res: 0, upd: 0;
       c8UQg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UQf() //  [R1]
         { info_tbl: [(c8UQf,
                       label: block_c8UQf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UQf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8UVv; else goto c8UVu;
       c8UVv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UVu: // global
           _s8TWh::P64 = P64[R1 + 23];
           I64[Hp - 8] = sat_s8TYi_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8UVh_info;
           R4 = Hp - 6;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TWh::P64;
           Sp = Sp + 8;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8UVh() //  [R1]
         { info_tbl: [(c8UVh,
                       label: block_c8UVh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UVh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UVy; else goto c8UVx;
       c8UVy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UVx: // global
           I64[Hp - 16] = sat_s8TYm_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.759548831 UTC

[section ""data" . GHC.Foreign.newCString_closure" {
     GHC.Foreign.newCString_closure:
         const GHC.Foreign.newCString_info;
         const 0;
 },
 GHC.Foreign.newCString_entry() //  [R2, R3]
         { info_tbl: [(c8UVE,
                       label: GHC.Foreign.newCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UVE: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.760498668 UTC

[section ""data" . GHC.Foreign.newCStringLen_closure" {
     GHC.Foreign.newCStringLen_closure:
         const GHC.Foreign.newCStringLen_info;
         const 0;
 },
 GHC.Foreign.newCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8UVL,
                       label: GHC.Foreign.newCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UVL: // global
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call GHC.Foreign.newEncodedCString_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.765478034 UTC

[section ""data" . GHC.Foreign.$wpeekCString_closure" {
     GHC.Foreign.$wpeekCString_closure:
         const GHC.Foreign.$wpeekCString_info;
         const 0;
 },
 sat_s8TZz_entry() //  [R1]
         { info_tbl: [(c8UXT,
                       label: sat_s8TZz_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UXT: // global
           _s8TZz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8UXU; else goto c8UXV;
       c8UXV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UXX; else goto c8UXW;
       c8UXX: // global
           HpAlloc = 40;
           goto c8UXU;
       c8UXU: // global
           R1 = _s8TZz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8UXW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8TZz::P64;
           _s8TZo::P64 = P64[_s8TZz::P64 + 16];
           _s8TZw::P64 = P64[_s8TZz::P64 + 24];
           _s8TZs::I64 = I64[_s8TZz::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TZs::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TZo::P64;
           R3 = _s8TZw::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TZQ_entry() //  [R1]
         { info_tbl: [(c8UY6,
                       label: sat_s8TZQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UY6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8UY7; else goto c8UY8;
       c8UY7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8UY8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8TYQ_entry() //  [R1, R2]
         { info_tbl: [(c8UY9,
                       label: $wgo_s8TYQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UY9: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8UYa; else goto c8UYb;
       c8UYa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8UYb: // global
           I64[Sp - 32] = block_c8UWy_info;
           _s8TYQ::P64 = R1;
           _s8TYP::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8TYP::P64;
           P64[Sp - 16] = _s8TYQ::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8UZL; else goto c8UWz;
       u8UZL: // global
           call _c8UWy(R1) args: 0, res: 0, upd: 0;
       c8UWz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UWy() //  [R1]
         { info_tbl: [(c8UWy,
                       label: block_c8UWy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UWy: // global
           _s8TYP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8UWD_info;
           R3 = _s8TYP::P64;
           R2 = P64[Sp + 24];
           _s8TYV::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8TYV::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UWD() //  [R1]
         { info_tbl: [(c8UWD,
                       label: block_c8UWD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UWD: // global
           I64[Sp] = block_c8UWF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UZD; else goto c8UWG;
       u8UZD: // global
           call _c8UWF(R1) args: 0, res: 0, upd: 0;
       c8UWG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UWF() //  [R1]
         { info_tbl: [(c8UWF,
                       label: block_c8UWF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UWF: // global
           I64[Sp - 16] = block_c8UWK_info;
           _s8TZ3::P64 = P64[R1 + 7];
           _s8TZ5::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TZ5::P64;
           P64[Sp] = _s8TZ3::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8UZE; else goto c8UWL;
       u8UZE: // global
           call _c8UWK(R1) args: 0, res: 0, upd: 0;
       c8UWL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UWK() //  [R1]
         { info_tbl: [(c8UWK,
                       label: block_c8UWK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UWK: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8UZ6; else goto c8UYz;
       c8UZ6: // global
           I64[Sp + 32] = block_c8UXi_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8UZG; else goto c8UXj;
       u8UZG: // global
           call _c8UXi(R1) args: 0, res: 0, upd: 0;
       c8UXj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UYz: // global
           I64[Sp] = block_c8UYg_info;
           _s8TZ6::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TZ6::P64;
           if (R1 & 7 != 0) goto u8UZF; else goto c8UYA;
       u8UZF: // global
           call _c8UYg(R1) args: 0, res: 0, upd: 0;
       c8UYA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UXi() //  [R1]
         { info_tbl: [(c8UXi,
                       label: block_c8UXi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UXi: // global
           _s8U0e::P64 = P64[R1 + 7];
           _s8U0j::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8U0j::I64, 0)) goto c8UZo; else goto c8UZp;
       c8UZo: // global
           P64[Sp - 24] = _s8U0e::P64;
           I64[Sp - 16] = _s8U0j::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8UXA() args: 0, res: 0, upd: 0;
       c8UZp: // global
           call MO_Touch(_s8U0e::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UXA() //  []
         { info_tbl: [(c8UXA,
                       label: block_c8UXA_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UXA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UZj; else goto c8UZi;
       c8UZj: // global
           HpAlloc = 40;
           I64[Sp] = block_c8UXA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8UZi: // global
           _s8U0w::P64 = P64[Sp + 24];
           _s8U0y::I64 = I64[Sp + 16];
           if (_s8U0y::I64 != 0) goto c8UZl; else goto c8UZm;
       c8UZl: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8U0y::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8U0w::P64;
           I64[Sp + 16] = _s8U0y::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8UXA() args: 0, res: 0, upd: 0;
       c8UZm: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8U0w::P64;
           Sp = Sp + 8;
           call _c8UZ9() args: 0, res: 0, upd: 0;
     }
 },
 _c8UZ9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UZ9: // global
           Hp = Hp + 40;
           _s8U0m::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8UZg; else goto c8UZf;
       c8UZg: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8UZ8_info;
           R1 = _s8U0m::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UZf: // global
           _s8U0q::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8U0q::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8U0m::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UZ8() //  [R1]
         { info_tbl: [(c8UZ8,
                       label: block_c8UZ8_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UZ8: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8UZ9() args: 0, res: 0, upd: 0;
     }
 },
 _c8UYg() //  [R1]
         { info_tbl: [(c8UYg,
                       label: block_c8UYg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UYg: // global
           _s8TZ5::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8UZ0; else goto c8UYO;
       c8UZ0: // global
           I64[Sp + 8] = block_c8UYY_info;
           R1 = _s8TZ5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8UZM; else goto c8UZ1;
       u8UZM: // global
           call _c8UYY(R1) args: 0, res: 0, upd: 0;
       c8UZ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8UYO: // global
           _s8TZ6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8UYE_info;
           R3 = _s8TZ5::P64;
           R2 = _s8TZ6::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UYY() //  [R1]
         { info_tbl: [(c8UYY,
                       label: block_c8UYY_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UYY: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8TZe() args: 0, res: 0, upd: 0;
     }
 },
 _c8UYE() //  [R1]
         { info_tbl: [(c8UYE,
                       label: block_c8UYE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UYE: // global
           I64[Sp] = block_c8UYG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8UZN; else goto c8UYH;
       u8UZN: // global
           call _c8UYG(R1) args: 0, res: 0, upd: 0;
       c8UYH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UYG() //  [R1]
         { info_tbl: [(c8UYG,
                       label: block_c8UYG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UYG: // global
           I64[Sp] = block_c8UYL_info;
           _s8TZW::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8TZW::P64;
           if (R1 & 7 != 0) goto u8UZO; else goto c8UYR;
       u8UZO: // global
           call _c8UYL(R1) args: 0, res: 0, upd: 0;
       c8UYR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UYL() //  [R1]
         { info_tbl: [(c8UYL,
                       label: block_c8UYL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UYL: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8TZe() args: 0, res: 0, upd: 0;
     }
 },
 _s8TZe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TZe: // global
           _s8TZl::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8TZl::I64, 0)) goto c8UYt; else goto c8UYu;
       c8UYt: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8TZl::I64 - 1;
           Sp = Sp - 8;
           call _c8UXa() args: 0, res: 0, upd: 0;
       c8UYu: // global
           _s8TYQ::P64 = P64[Sp + 32];
           _s8TZg::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8UY0_info;
           R2 = _s8TZg::P64;
           R1 = _s8TYQ::P64;
           Sp = Sp + 40;
           call $wgo_s8TYQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UXa() //  []
         { info_tbl: [(c8UXa,
                       label: block_c8UXa_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UXa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UYo; else goto c8UYn;
       c8UYo: // global
           HpAlloc = 40;
           I64[Sp] = block_c8UXa_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8UYn: // global
           _s8TZh::I64 = I64[Sp + 32];
           _s8TZC::P64 = P64[Sp + 16];
           _s8TZE::I64 = I64[Sp + 24];
           if (_s8TZE::I64 != 0) goto c8UYq; else goto c8UYr;
       c8UYq: // global
           _s8TZH::I64 = %MO_UU_Conv_W32_W64(I32[_s8TZh::I64 + (_s8TZE::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TZH::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TZC::P64;
           I64[Sp + 24] = _s8TZE::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8UXa() args: 0, res: 0, upd: 0;
       c8UYr: // global
           Hp = Hp - 40;
           _s8TYQ::P64 = P64[Sp + 40];
           _s8TZg::P64 = P64[Sp + 48];
           _s8TZs::I64 = %MO_UU_Conv_W32_W64(I32[_s8TZh::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8UXL_info;
           R2 = _s8TZg::P64;
           R1 = _s8TYQ::P64;
           I64[Sp + 40] = _s8TZs::I64;
           P64[Sp + 48] = _s8TZC::P64;
           Sp = Sp + 32;
           call $wgo_s8TYQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UXL() //  [R1]
         { info_tbl: [(c8UXL,
                       label: block_c8UXL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UXL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8UYl; else goto c8UYk;
       c8UYl: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UYk: // global
           I64[Hp - 32] = sat_s8TZz_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UY0() //  [R1]
         { info_tbl: [(c8UY0,
                       label: block_c8UY0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UY0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8UYx; else goto c8UYw;
       c8UYx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8UYw: // global
           I64[Hp - 16] = sat_s8TZQ_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8U0L_entry() //  [R1, R2]
         { info_tbl: [(c8UZY,
                       label: sat_s8U0L_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UZY: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8UZZ; else goto c8V00;
       c8UZZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8V00: // global
           I64[Sp - 32] = block_c8UW7_info;
           _s8TYp::I64 = I64[R1 + 6];
           _s8TYs::I64 = I64[R1 + 14];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 24] = _s8TYp::I64;
           I64[Sp - 16] = _s8TYs::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UW7() //  [R1]
         { info_tbl: [(c8UW7,
                       label: block_c8UW7_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UW7: // global
           _s8TYs::I64 = I64[Sp + 16];
           if (%MO_S_Gt_W64(_s8TYs::I64, 1)) goto c8UZW; else goto c8UZX;
       c8UZW: // global
           _s8TYC::P64 = R1;
           _s8TYE::I64 = _s8TYs::I64;
           goto s8TYD;
       c8UZX: // global
           _s8TYC::P64 = R1;
           _s8TYE::I64 = 1;
           goto s8TYD;
       s8TYD: // global
           _s8TYF::I64 = _s8TYE::I64 << 2;
           if (%MO_S_Ge_W64(_s8TYF::I64, 0)) goto c8V06; else goto c8V0b;
       c8V06: // global
           I64[Sp - 24] = block_c8UWk_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8TYE::I64;
           I64[Sp - 8] = _s8TYF::I64;
           P64[Sp] = _s8TYC::P64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8V0b: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8UWk() //  [R1]
         { info_tbl: [(c8UWk,
                       label: block_c8UWk_info
                       rep:StackRep [True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UWk: // global
           I64[Sp] = block_c8UWm_info;
           _s8TYJ::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8TYJ::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8UWm() //  [R1]
         { info_tbl: [(c8UWm,
                       label: block_c8UWm_info
                       rep:StackRep [True, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UWm: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8V0a; else goto c8V09;
       c8V0a: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8V09: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8TYQ_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 24];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8TYs::I64 = I64[Sp + 40];
           I64[Hp - 16] = _s8TYs::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8TYs::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8TYQ_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.$wpeekCString_entry() //  [R2, R3]
         { info_tbl: [(c8V0e,
                       label: GHC.Foreign.$wpeekCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V0e: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8V0f; else goto c8V0g;
       c8V0f: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.$wpeekCString_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8V0g: // global
           _s8TYp::I64 = R3;
           _s8TYo::P64 = R2;
           _s8U0N::I64 = 0;
           goto c8V0m;
       c8V0m: // global
           if (I8[_s8TYp::I64 + _s8U0N::I64] == 0 :: W8) goto c8V0s; else goto c8V0r;
       c8V0s: // global
           I64[Sp - 24] = block_c8UVX_info;
           R1 = _s8TYo::P64;
           I64[Sp - 16] = _s8TYp::I64;
           I64[Sp - 8] = _s8U0N::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8V0v; else goto c8UVY;
       u8V0v: // global
           call _c8UVX(R1) args: 0, res: 0, upd: 0;
       c8UVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8V0r: // global
           _s8U0N::I64 = _s8U0N::I64 + 1;
           goto c8V0m;
     }
 },
 _c8UVX() //  [R1]
         { info_tbl: [(c8UVX,
                       label: block_c8UVX_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8UVX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8V0k; else goto c8V0j;
       c8V0k: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8V0j: // global
           _s8TYw::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8U0L_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TYw::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.774414889 UTC

[section ""data" . GHC.Foreign.peekCString1_closure" {
     GHC.Foreign.peekCString1_closure:
         const GHC.Foreign.peekCString1_info;
         const 0;
 },
 GHC.Foreign.peekCString1_entry() //  [R2, R3]
         { info_tbl: [(c8V0D,
                       label: GHC.Foreign.peekCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V0D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8V0E; else goto c8V0F;
       c8V0E: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.peekCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8V0F: // global
           I64[Sp - 16] = block_c8V0A_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8V0J; else goto c8V0B;
       u8V0J: // global
           call _c8V0A(R1) args: 0, res: 0, upd: 0;
       c8V0B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V0A() //  [R1]
         { info_tbl: [(c8V0A,
                       label: block_c8V0A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V0A: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.777153044 UTC

[section ""data" . GHC.Foreign.peekCString_closure" {
     GHC.Foreign.peekCString_closure:
         const GHC.Foreign.peekCString_info;
         const 0;
 },
 GHC.Foreign.peekCString_entry() //  [R2, R3]
         { info_tbl: [(c8V0O,
                       label: GHC.Foreign.peekCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V0O: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.peekCString1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.778849774 UTC

[section ""data" . GHC.Foreign.charIsRepresentable2_closure" {
     GHC.Foreign.charIsRepresentable2_closure:
         const GHC.Foreign.charIsRepresentable2_info;
         const 0;
 },
 GHC.Foreign.charIsRepresentable2_entry() //  [R2]
         { info_tbl: [(c8V0Y,
                       label: GHC.Foreign.charIsRepresentable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V0Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8V12; else goto c8V13;
       c8V12: // global
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8V13: // global
           I64[Sp - 8] = block_c8V0V_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8V1l; else goto c8V0W;
       u8V1l: // global
           call _c8V0V(R1) args: 0, res: 0, upd: 0;
       c8V0W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V0V() //  [R1]
         { info_tbl: [(c8V0V,
                       label: block_c8V0V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V0V: // global
           I64[Sp - 8] = block_c8V11_info;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8V11() //  [R1]
         { info_tbl: [(c8V11,
                       label: block_c8V11_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V11: // global
           I64[Sp] = block_c8V18_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8V18() //  [R1]
         { info_tbl: [(c8V18,
                       label: block_c8V18_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V18: // global
           if (R1 & 7 == 1) goto c8V1f; else goto c8V1j;
       c8V1f: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8V1j: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.781730315 UTC

[section ""data" . GHC.Foreign.charIsRepresentable1_closure" {
     GHC.Foreign.charIsRepresentable1_closure:
         const GHC.Foreign.charIsRepresentable1_info;
         const 0;
 },
 sat_s8U1w_entry() //  [R1, R2]
         { info_tbl: [(c8V1D,
                       label: sat_s8U1w_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V1D: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8V1E; else goto c8V1F;
       c8V1E: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8V1F: // global
           I64[Sp - 24] = block_c8V1A_info;
           _s8U17::P64 = P64[R1 + 6];
           _s8U19::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _s8U17::P64;
           P64[Sp - 8] = _s8U19::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8V2w; else goto c8V1B;
       u8V2w: // global
           call _c8V1A(R1) args: 0, res: 0, upd: 0;
       c8V1B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V1A() //  [R1]
         { info_tbl: [(c8V1A,
                       label: block_c8V1A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V1A: // global
           I64[Sp] = block_c8V1I_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8V1I() //  [R1]
         { info_tbl: [(c8V1I,
                       label: block_c8V1I_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V1I: // global
           I64[Sp] = block_c8V1K_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8V2x; else goto c8V1N;
       u8V2x: // global
           call _c8V1K(R1) args: 0, res: 0, upd: 0;
       c8V1N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V1K() //  [R1]
         { info_tbl: [(c8V1K,
                       label: block_c8V1K_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V1K: // global
           if (R1 & 7 == 1) goto u8V2t; else goto c8V1Y;
       u8V2t: // global
           Sp = Sp + 24;
           call _c8V2q() args: 0, res: 0, upd: 0;
       c8V1Y: // global
           I64[Sp] = block_c8V1W_info;
           _s8U1m::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp + 16] = _s8U1m::P64;
           if (R1 & 7 != 0) goto u8V2y; else goto c8V1Z;
       u8V2y: // global
           call _c8V1W(R1) args: 0, res: 0, upd: 0;
       c8V1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V1W() //  [R1]
         { info_tbl: [(c8V1W,
                       label: block_c8V1W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V1W: // global
           if (R1 & 7 == 1) goto c8V2b; else goto u8V2u;
       c8V2b: // global
           I64[Sp] = block_c8V23_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8V2A; else goto c8V24;
       u8V2A: // global
           call _c8V23(R1) args: 0, res: 0, upd: 0;
       c8V24: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8V2u: // global
           Sp = Sp + 24;
           call _c8V2q() args: 0, res: 0, upd: 0;
     }
 },
 _c8V23() //  [R1]
         { info_tbl: [(c8V23,
                       label: block_c8V23_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V23: // global
           _s8U17::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8V28_info;
           _s8U1q::I64 = I64[R1 + 7];
           R1 = _s8U17::P64;
           I64[Sp + 16] = _s8U1q::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8V2C; else goto c8V2d;
       u8V2C: // global
           call _c8V28(R1) args: 0, res: 0, upd: 0;
       c8V2d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V28() //  [R1]
         { info_tbl: [(c8V28,
                       label: block_c8V28_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V28: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c8V2m; else goto u8V2v;
       c8V2m: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8V2v: // global
           Sp = Sp + 16;
           call _c8V2q() args: 0, res: 0, upd: 0;
     }
 },
 _c8V2q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V2q: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8U1x_entry() //  [R1]
         { info_tbl: [(c8V2K,
                       label: sat_s8U1x_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V2K: // global
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.charIsRepresentable1_entry() //  [R2, R3]
         { info_tbl: [(c8V2N,
                       label: GHC.Foreign.charIsRepresentable1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V2N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8V2O; else goto c8V2P;
       c8V2O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8V2P: // global
           I64[Sp - 16] = block_c8V1q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8V2T; else goto c8V1r;
       u8V2T: // global
           call _c8V1q(R1) args: 0, res: 0, upd: 0;
       c8V1r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V1q() //  [R1]
         { info_tbl: [(c8V1q,
                       label: block_c8V1q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V1q: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8V2S; else goto c8V2R;
       c8V2S: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8V2R: // global
           I64[Hp - 72] = sat_s8U1w_info;
           _s8U17::P64 = P64[Sp + 8];
           P64[Hp - 64] = _s8U17::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = _s8U17::P64;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           I64[Hp - 24] = sat_s8U1x_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 70;
           R2 = GHC.Foreign.charIsRepresentable2_closure+2;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.785128401 UTC

[section ""data" . GHC.Foreign.charIsRepresentable_closure" {
     GHC.Foreign.charIsRepresentable_closure:
         const GHC.Foreign.charIsRepresentable_info;
         const 0;
 },
 GHC.Foreign.charIsRepresentable_entry() //  [R2, R3]
         { info_tbl: [(c8V2Y,
                       label: GHC.Foreign.charIsRepresentable_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V2Y: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.786002374 UTC

[section ""relreadonly" . S8U6c_srt" {
     S8U6c_srt:
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const $wpeekCStringLen_r8TNn_closure;
         const peekCStringLen1_r8TNo_closure;
         const Foreign.Marshal.Array.withArrayLen_closure;
         const GHC.Foreign.withCStringsLen1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const newEncodedCString1_r8TNq_closure;
         const GHC.Foreign.newCString1_closure;
         const GHC.Foreign.newEncodedCString_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.Foreign.peekCString1_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.Foreign.charIsRepresentable2_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.787032956 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:02.788303535 UTC

[section ""cstring" . GHC.Foreign.$trModule4_bytes" {
     GHC.Foreign.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.790271493 UTC

[section ""data" . GHC.Foreign.$trModule3_closure" {
     GHC.Foreign.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Foreign.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.792286637 UTC

[section ""cstring" . GHC.Foreign.$trModule2_bytes" {
     GHC.Foreign.$trModule2_bytes:
         I8[] [71,72,67,46,70,111,114,101,105,103,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.794362105 UTC

[section ""data" . GHC.Foreign.$trModule1_closure" {
     GHC.Foreign.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Foreign.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.796240259 UTC

[section ""data" . GHC.Foreign.$trModule_closure" {
     GHC.Foreign.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Foreign.$trModule3_closure+1;
         const GHC.Foreign.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.805011011 UTC

[section ""data" . $wpeekCStringLen_r8TNn_closure" {
     $wpeekCStringLen_r8TNn_closure:
         const $wpeekCStringLen_r8TNn_info;
         const 0;
 },
 sat_s8TOF_entry() //  [R1]
         { info_tbl: [(c8V5g,
                       label: sat_s8TOF_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V5g: // global
           _s8TOF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8V5h; else goto c8V5i;
       c8V5i: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8V5k; else goto c8V5j;
       c8V5k: // global
           HpAlloc = 40;
           goto c8V5h;
       c8V5h: // global
           R1 = _s8TOF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8V5j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8TOF::P64;
           _s8TOu::P64 = P64[_s8TOF::P64 + 16];
           _s8TOC::P64 = P64[_s8TOF::P64 + 24];
           _s8TOy::I64 = I64[_s8TOF::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TOy::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TOu::P64;
           R3 = _s8TOC::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TOW_entry() //  [R1]
         { info_tbl: [(c8V5t,
                       label: sat_s8TOW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V5t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8V5u; else goto c8V5v;
       c8V5u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8V5v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8TNW_entry() //  [R1, R2]
         { info_tbl: [(c8V5w,
                       label: $wgo_s8TNW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V5w: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8V5x; else goto c8V5y;
       c8V5x: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8V5y: // global
           I64[Sp - 32] = block_c8V3V_info;
           _s8TNW::P64 = R1;
           _s8TNV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8TNV::P64;
           P64[Sp - 16] = _s8TNW::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8V78; else goto c8V3W;
       u8V78: // global
           call _c8V3V(R1) args: 0, res: 0, upd: 0;
       c8V3W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V3V() //  [R1]
         { info_tbl: [(c8V3V,
                       label: block_c8V3V_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V3V: // global
           _s8TNV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8V40_info;
           R3 = _s8TNV::P64;
           R2 = P64[Sp + 24];
           _s8TO1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8TO1::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V40() //  [R1]
         { info_tbl: [(c8V40,
                       label: block_c8V40_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V40: // global
           I64[Sp] = block_c8V42_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8V70; else goto c8V43;
       u8V70: // global
           call _c8V42(R1) args: 0, res: 0, upd: 0;
       c8V43: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V42() //  [R1]
         { info_tbl: [(c8V42,
                       label: block_c8V42_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V42: // global
           I64[Sp - 16] = block_c8V47_info;
           _s8TO9::P64 = P64[R1 + 7];
           _s8TOb::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TOb::P64;
           P64[Sp] = _s8TO9::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8V71; else goto c8V48;
       u8V71: // global
           call _c8V47(R1) args: 0, res: 0, upd: 0;
       c8V48: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V47() //  [R1]
         { info_tbl: [(c8V47,
                       label: block_c8V47_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V47: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8V6t; else goto c8V5W;
       c8V6t: // global
           I64[Sp + 32] = block_c8V4F_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8V73; else goto c8V4G;
       u8V73: // global
           call _c8V4F(R1) args: 0, res: 0, upd: 0;
       c8V4G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8V5W: // global
           I64[Sp] = block_c8V5D_info;
           _s8TOc::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TOc::P64;
           if (R1 & 7 != 0) goto u8V72; else goto c8V5X;
       u8V72: // global
           call _c8V5D(R1) args: 0, res: 0, upd: 0;
       c8V5X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V4F() //  [R1]
         { info_tbl: [(c8V4F,
                       label: block_c8V4F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V4F: // global
           _s8TPk::P64 = P64[R1 + 7];
           _s8TPp::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8TPp::I64, 0)) goto c8V6L; else goto c8V6M;
       c8V6L: // global
           P64[Sp - 24] = _s8TPk::P64;
           I64[Sp - 16] = _s8TPp::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8V4X() args: 0, res: 0, upd: 0;
       c8V6M: // global
           call MO_Touch(_s8TPk::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8V4X() //  []
         { info_tbl: [(c8V4X,
                       label: block_c8V4X_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V4X: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8V6G; else goto c8V6F;
       c8V6G: // global
           HpAlloc = 40;
           I64[Sp] = block_c8V4X_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8V6F: // global
           _s8TPC::P64 = P64[Sp + 24];
           _s8TPE::I64 = I64[Sp + 16];
           if (_s8TPE::I64 != 0) goto c8V6I; else goto c8V6J;
       c8V6I: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8TPE::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TPC::P64;
           I64[Sp + 16] = _s8TPE::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8V4X() args: 0, res: 0, upd: 0;
       c8V6J: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8TPC::P64;
           Sp = Sp + 8;
           call _c8V6w() args: 0, res: 0, upd: 0;
     }
 },
 _c8V6w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V6w: // global
           Hp = Hp + 40;
           _s8TPs::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8V6D; else goto c8V6C;
       c8V6D: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8V6v_info;
           R1 = _s8TPs::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8V6C: // global
           _s8TPw::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TPw::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TPs::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8V6v() //  [R1]
         { info_tbl: [(c8V6v,
                       label: block_c8V6v_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V6v: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8V6w() args: 0, res: 0, upd: 0;
     }
 },
 _c8V5D() //  [R1]
         { info_tbl: [(c8V5D,
                       label: block_c8V5D_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V5D: // global
           _s8TOb::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8V6n; else goto c8V6b;
       c8V6n: // global
           I64[Sp + 8] = block_c8V6l_info;
           R1 = _s8TOb::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8V79; else goto c8V6o;
       u8V79: // global
           call _c8V6l(R1) args: 0, res: 0, upd: 0;
       c8V6o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8V6b: // global
           _s8TOc::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8V61_info;
           R3 = _s8TOb::P64;
           R2 = _s8TOc::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V6l() //  [R1]
         { info_tbl: [(c8V6l,
                       label: block_c8V6l_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V6l: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8TOk() args: 0, res: 0, upd: 0;
     }
 },
 _c8V61() //  [R1]
         { info_tbl: [(c8V61,
                       label: block_c8V61_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V61: // global
           I64[Sp] = block_c8V63_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8V7a; else goto c8V64;
       u8V7a: // global
           call _c8V63(R1) args: 0, res: 0, upd: 0;
       c8V64: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V63() //  [R1]
         { info_tbl: [(c8V63,
                       label: block_c8V63_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V63: // global
           I64[Sp] = block_c8V68_info;
           _s8TP2::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8TP2::P64;
           if (R1 & 7 != 0) goto u8V7b; else goto c8V6e;
       u8V7b: // global
           call _c8V68(R1) args: 0, res: 0, upd: 0;
       c8V6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V68() //  [R1]
         { info_tbl: [(c8V68,
                       label: block_c8V68_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V68: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8TOk() args: 0, res: 0, upd: 0;
     }
 },
 _s8TOk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TOk: // global
           _s8TOr::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8TOr::I64, 0)) goto c8V5Q; else goto c8V5R;
       c8V5Q: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8TOr::I64 - 1;
           Sp = Sp - 8;
           call _c8V4x() args: 0, res: 0, upd: 0;
       c8V5R: // global
           _s8TNW::P64 = P64[Sp + 32];
           _s8TOm::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8V5n_info;
           R2 = _s8TOm::P64;
           R1 = _s8TNW::P64;
           Sp = Sp + 40;
           call $wgo_s8TNW_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V4x() //  []
         { info_tbl: [(c8V4x,
                       label: block_c8V4x_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V4x: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8V5L; else goto c8V5K;
       c8V5L: // global
           HpAlloc = 40;
           I64[Sp] = block_c8V4x_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8V5K: // global
           _s8TOn::I64 = I64[Sp + 32];
           _s8TOI::P64 = P64[Sp + 16];
           _s8TOK::I64 = I64[Sp + 24];
           if (_s8TOK::I64 != 0) goto c8V5N; else goto c8V5O;
       c8V5N: // global
           _s8TON::I64 = %MO_UU_Conv_W32_W64(I32[_s8TOn::I64 + (_s8TOK::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TON::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TOI::P64;
           I64[Sp + 24] = _s8TOK::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8V4x() args: 0, res: 0, upd: 0;
       c8V5O: // global
           Hp = Hp - 40;
           _s8TNW::P64 = P64[Sp + 40];
           _s8TOm::P64 = P64[Sp + 48];
           _s8TOy::I64 = %MO_UU_Conv_W32_W64(I32[_s8TOn::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8V58_info;
           R2 = _s8TOm::P64;
           R1 = _s8TNW::P64;
           I64[Sp + 40] = _s8TOy::I64;
           P64[Sp + 48] = _s8TOI::P64;
           Sp = Sp + 32;
           call $wgo_s8TNW_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V58() //  [R1]
         { info_tbl: [(c8V58,
                       label: block_c8V58_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V58: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8V5I; else goto c8V5H;
       c8V5I: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8V5H: // global
           I64[Hp - 32] = sat_s8TOF_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8V5n() //  [R1]
         { info_tbl: [(c8V5n,
                       label: block_c8V5n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V5n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8V5U; else goto c8V5T;
       c8V5U: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8V5T: // global
           I64[Hp - 16] = sat_s8TOW_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8TPR_entry() //  [R1, R2]
         { info_tbl: [(c8V7g,
                       label: sat_s8TPR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V7g: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8V7h; else goto c8V7i;
       c8V7h: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8V7i: // global
           I64[Sp - 24] = block_c8V3k_info;
           _s8TNu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8TNu::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8V7C; else goto c8V3l;
       u8V7C: // global
           call _c8V3k(R1) args: 0, res: 0, upd: 0;
       c8V3l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V3k() //  [R1]
         { info_tbl: [(c8V3k,
                       label: block_c8V3k_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V3k: // global
           I64[Sp - 8] = block_c8V3p_info;
           _s8TND::I64 = I64[R1 + 7];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s8TND::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V3p() //  [R1]
         { info_tbl: [(c8V3p,
                       label: block_c8V3p_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V3p: // global
           I64[Sp] = block_c8V3r_info;
           _s8TNG::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TNG::P64;
           if (R1 & 7 != 0) goto u8V7B; else goto c8V3s;
       u8V7B: // global
           call _c8V3r(R1) args: 0, res: 0, upd: 0;
       c8V3s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V3r() //  [R1]
         { info_tbl: [(c8V3r,
                       label: block_c8V3r_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V3r: // global
           _s8TNI::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s8TNI::I64, 1)) goto c8V7z; else goto c8V7A;
       c8V7z: // global
           _s8TNK::I64 = _s8TNI::I64;
           goto s8TNJ;
       c8V7A: // global
           _s8TNK::I64 = 1;
           goto s8TNJ;
       s8TNJ: // global
           _s8TNL::I64 = _s8TNK::I64 << 2;
           if (%MO_S_Ge_W64(_s8TNL::I64, 0)) goto c8V7q; else goto c8V7v;
       c8V7q: // global
           I64[Sp - 24] = block_c8V3H_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8TNK::I64;
           I64[Sp - 8] = _s8TNL::I64;
           I64[Sp] = _s8TNI::I64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8V7v: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8V3H() //  [R1]
         { info_tbl: [(c8V3H,
                       label: block_c8V3H_info
                       rep:StackRep [True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V3H: // global
           I64[Sp] = block_c8V3J_info;
           _s8TNP::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8TNP::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V3J() //  [R1]
         { info_tbl: [(c8V3J,
                       label: block_c8V3J_info
                       rep:StackRep [True, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V3J: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8V7u; else goto c8V7t;
       c8V7u: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8V7t: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8TNW_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 40];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8TNI::I64 = I64[Sp + 24];
           I64[Hp - 16] = _s8TNI::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8TNI::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8TNW_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wpeekCStringLen_r8TNn_entry() //  [R2, R3, R4]
         { info_tbl: [(c8V7D,
                       label: $wpeekCStringLen_r8TNn_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V7D: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8V7E; else goto c8V7F;
       c8V7E: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wpeekCStringLen_r8TNn_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8V7F: // global
           I64[Sp - 24] = block_c8V3a_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8V7J; else goto c8V3b;
       u8V7J: // global
           call _c8V3a(R1) args: 0, res: 0, upd: 0;
       c8V3b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8V3a() //  [R1]
         { info_tbl: [(c8V3a,
                       label: block_c8V3a_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8V3a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8V7I; else goto c8V7H;
       c8V7I: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8V7H: // global
           _s8TNy::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8TPR_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TNy::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.872378307 UTC

[section ""data" . peekCStringLen1_r8TNo_closure" {
     peekCStringLen1_r8TNo_closure:
         const peekCStringLen1_r8TNo_info;
         const 0;
 },
 peekCStringLen1_r8TNo_entry() //  [R2, R3]
         { info_tbl: [(c8Vad,
                       label: peekCStringLen1_r8TNo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vad: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Vae; else goto c8Vaf;
       c8Vae: // global
           R3 = R3;
           R2 = R2;
           R1 = peekCStringLen1_r8TNo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Vaf: // global
           I64[Sp - 16] = block_c8Vaa_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Vaj; else goto c8Vab;
       u8Vaj: // global
           call _c8Vaa(R1) args: 0, res: 0, upd: 0;
       c8Vab: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vaa() //  [R1]
         { info_tbl: [(c8Vaa,
                       label: block_c8Vaa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vaa: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wpeekCStringLen_r8TNn_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.879056062 UTC

[section ""data" . GHC.Foreign.peekCStringLen_closure" {
     GHC.Foreign.peekCStringLen_closure:
         const GHC.Foreign.peekCStringLen_info;
         const 0;
 },
 GHC.Foreign.peekCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8Vax,
                       label: GHC.Foreign.peekCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vax: // global
           R3 = R3;
           R2 = R2;
           call peekCStringLen1_r8TNo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.885339481 UTC

[section ""data" . GHC.Foreign.$wtryFillBufferAndCall_closure" {
     GHC.Foreign.$wtryFillBufferAndCall_closure:
         const GHC.Foreign.$wtryFillBufferAndCall_info;
 },
 GHC.Foreign.$wtryFillBufferAndCall_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VaF: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8TRg_entry() //  [R1]
         { info_tbl: [(c8VaS,
                       label: sat_s8TRg_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VaS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8VaX; else goto c8VaY;
       c8VaX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8VaY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8VaP_info;
           _s8TQ8::P64 = P64[R1 + 24];
           _s8TQ2::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8TQ2::I64;
           P64[Sp - 24] = _s8TQ8::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Vb2; else goto c8VaQ;
       u8Vb2: // global
           call _c8VaP(R1) args: 0, res: 0, upd: 0;
       c8VaQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8VaP() //  [R1]
         { info_tbl: [(c8VaP,
                       label: block_c8VaP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VaP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Vb1; else goto c8Vb0;
       c8Vb1: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Vb0: // global
           _s8TRe::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8TRe::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Foreign.$wtryFillBufferAndCall_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8Vb7,
                       label: GHC.Foreign.$wtryFillBufferAndCall_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vb7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8Vb8; else goto c8Vb9;
       c8Vb8: // global
           R1 = GHC.Foreign.$wtryFillBufferAndCall_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       c8Vb9: // global
           I64[Sp - 48] = block_c8VaJ_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VaJ() //  [R1]
         { info_tbl: [(c8VaJ,
                       label: block_c8VaJ_info
                       rep:StackRep [False, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VaJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Vbc; else goto c8Vbb;
       c8Vbc: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vbb: // global
           I64[Hp - 32] = sat_s8TRg_info;
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 40];
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = P64[Sp + 32];
           Sp = Sp + 8;
           call _c8VcH() args: 0, res: 0, upd: 0;
     }
 },
 _c8VcH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VcH: // global
           I64[Sp - 8] = block_c8VcJ_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VcJ() //  [R1]
         { info_tbl: [(c8VcJ,
                       label: block_c8VcJ_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VcJ: // global
           I64[Sp] = block_c8VcL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8VdF; else goto c8VcM;
       u8VdF: // global
           call _c8VcL(R1) args: 0, res: 0, upd: 0;
       c8VcM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VcL() //  [R1]
         { info_tbl: [(c8VcL,
                       label: block_c8VcL_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VcL: // global
           I64[Sp] = block_c8VcQ_info;
           _s8TQV::P64 = P64[R1 + 7];
           _s8TQX::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp + 40] = _s8TQX::P64;
           P64[Sp + 48] = _s8TQV::P64;
           if (R1 & 7 != 0) goto u8VdG; else goto c8VcU;
       u8VdG: // global
           call _c8VcQ(R1) args: 0, res: 0, upd: 0;
       c8VcU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VcQ() //  [R1]
         { info_tbl: [(c8VcQ,
                       label: block_c8VcQ_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VcQ: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8Vdp; else goto c8Vd4;
       c8Vdp: // global
           I64[Sp + 16] = block_c8Vbi_info;
           R1 = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 40];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u8VdI; else goto c8Vca;
       u8VdI: // global
           call _c8Vbi(R1) args: 0, res: 0, upd: 0;
       c8Vca: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Vd4: // global
           I64[Sp] = block_c8Vd2_info;
           _s8TQY::P64 = R1;
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _s8TQY::P64;
           if (R1 & 7 != 0) goto u8VdH; else goto c8Vd5;
       u8VdH: // global
           call _c8Vd2(R1) args: 0, res: 0, upd: 0;
       c8Vd5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vbi() //  [R1]
         { info_tbl: [(c8Vbi,
                       label: block_c8Vbi_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vbi: // global
           if (R1 & 7 == 1) goto u8Vdw; else goto c8Vcl;
       u8Vdw: // global
           Sp = Sp + 8;
           call _s8TQc() args: 0, res: 0, upd: 0;
       c8Vcl: // global
           I64[Sp] = block_c8Vcj_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u8VdA; else goto c8Vcm;
       u8VdA: // global
           call _c8Vcj(R1) args: 0, res: 0, upd: 0;
       c8Vcm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vcj() //  [R1]
         { info_tbl: [(c8Vcj,
                       label: block_c8Vcj_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vcj: // global
           if (I64[R1 + 31] - I64[R1 + 47] == 0) goto u8Vdx; else goto u8Vdy;
       u8Vdx: // global
           Sp = Sp + 48;
           call _c8VcC() args: 0, res: 0, upd: 0;
       u8Vdy: // global
           Sp = Sp + 8;
           call _s8TQc() args: 0, res: 0, upd: 0;
     }
 },
 _s8TQc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TQc: // global
           I64[Sp - 8] = block_c8Vbn_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8VdM; else goto c8Vbp;
       u8VdM: // global
           call _c8Vbn(R1) args: 0, res: 0, upd: 0;
       c8Vbp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vbn() //  [R1]
         { info_tbl: [(c8Vbn,
                       label: block_c8Vbn_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vbn: // global
           I64[Sp] = block_c8Vbt_info;
           _s8TQf::P64 = P64[R1 + 7];
           _s8TQe::I64 = I64[R1 + 23];
           _s8TQi::I64 = I64[R1 + 39];
           _s8TQj::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8TQj::I64;
           I64[Sp + 16] = _s8TQi::I64;
           P64[Sp + 24] = _s8TQf::P64;
           I64[Sp + 32] = _s8TQe::I64;
           if (R1 & 7 != 0) goto u8VdC; else goto c8Vbv;
       u8VdC: // global
           call _c8Vbt(R1) args: 0, res: 0, upd: 0;
       c8Vbv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vbt() //  [R1]
         { info_tbl: [(c8Vbt,
                       label: block_c8Vbt_info
                       rep:StackRep [True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vbt: // global
           _s8TQ4::P64 = P64[Sp + 40];
           _s8TQe::I64 = I64[Sp + 32];
           _s8TQi::I64 = I64[Sp + 16];
           _s8TQj::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c8VbK; else goto c8Vc3;
       c8VbK: // global
           Hp = Hp + 56;
           _s8TQk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8Vc6; else goto c8VbM;
       c8VbM: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s8TQj::I64 - _s8TQi::I64;
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = _s8TQe::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8VbF_info;
           R2 = Hp - 15;
           R1 = _s8TQ4::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       c8Vc3: // global
           Hp = Hp + 56;
           _s8TQk::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8Vc6; else goto c8Vc5;
       c8Vc6: // global
           HpAlloc = 56;
           R1 = _s8TQk::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vc5: // global
           I8[_s8TQe::I64 + _s8TQj::I64] = 0 :: W8;
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s8TQj::I64 - _s8TQi::I64;
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = _s8TQe::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8VbZ_info;
           R2 = Hp - 15;
           R1 = _s8TQ4::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VbF() //  [R1]
         { info_tbl: [(c8VbF,
                       label: block_c8VbF_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VbF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8VbQ; else goto c8VbP;
       c8VbQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VbP: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8VbZ() //  [R1]
         { info_tbl: [(c8VbZ,
                       label: block_c8VbZ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VbZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Vc9; else goto c8Vc8;
       c8Vc9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vc8: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Vd2() //  [R1]
         { info_tbl: [(c8Vd2,
                       label: block_c8Vd2_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vd2: // global
           if (R1 & 7 == 2) goto u8Vdu; else goto c8Vde;
       u8Vdu: // global
           Sp = Sp + 64;
           call _c8VcC() args: 0, res: 0, upd: 0;
       c8Vde: // global
           I64[Sp] = block_c8Vd9_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 16];
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VcC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VcC: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Vd9() //  [R1]
         { info_tbl: [(c8Vd9,
                       label: block_c8Vd9_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vd9: // global
           I64[Sp] = block_c8Vdb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8VdK; else goto c8Vdg;
       u8VdK: // global
           call _c8Vdb(R1) args: 0, res: 0, upd: 0;
       c8Vdg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vdb() //  [R1]
         { info_tbl: [(c8Vdb,
                       label: block_c8Vdb_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vdb: // global
           P64[Sp + 48] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 8;
           call _c8VcH() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.928543148 UTC

[section ""data" . GHC.Foreign.newCStringLen1_closure" {
     GHC.Foreign.newCStringLen1_closure:
         const GHC.Foreign.newCStringLen1_info;
 },
 GHC.Foreign.newCStringLen1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8Vfw,
                       label: GHC.Foreign.newCStringLen1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vfw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8VfA; else goto c8VfB;
       c8VfA: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.newCStringLen1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8VfB: // global
           I64[Sp - 40] = block_c8Vft_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8VfJ; else goto c8Vfu;
       u8VfJ: // global
           call _c8Vft(R1) args: 0, res: 0, upd: 0;
       c8Vfu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vft() //  [R1]
         { info_tbl: [(c8Vft,
                       label: block_c8Vft_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vft: // global
           I64[Sp - 8] = block_c8Vfz_info;
           _s8TRp::P64 = P64[R1 + 7];
           _s8TRq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8TRq::P64;
           P64[Sp + 24] = _s8TRp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8VfI; else goto c8VfD;
       u8VfI: // global
           call _c8Vfz(R1) args: 0, res: 0, upd: 0;
       c8VfD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vfz() //  [R1]
         { info_tbl: [(c8Vfz,
                       label: block_c8Vfz_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vfz: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 40;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.942017845 UTC

[section ""data" . withEncodedCString1_r8TNp_closure" {
     withEncodedCString1_r8TNp_closure:
         const withEncodedCString1_r8TNp_info;
 },
 $wgo_s8TRX_entry() //  [R1, R2]
         { info_tbl: [(c8VgG,
                       label: $wgo_s8TRX_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VgG: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8VgH; else goto c8VgI;
       c8VgH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8VgI: // global
           I64[Sp - 56] = block_c8VgB_info;
           _s8TRX::P64 = R1;
           _s8TRx::P64 = P64[R1 + 6];
           _s8TRz::P64 = P64[R1 + 14];
           _s8TRF::P64 = P64[R1 + 22];
           _s8TRW::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 48] = _s8TRx::P64;
           P64[Sp - 40] = _s8TRz::P64;
           P64[Sp - 32] = _s8TRF::P64;
           P64[Sp - 24] = _s8TRW::P64;
           P64[Sp - 16] = _s8TRX::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 56;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VgB() //  [R1]
         { info_tbl: [(c8VgB,
                       label: block_c8VgB_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VgB: // global
           I64[Sp] = block_c8VgD_info;
           _s8TS5::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s8TS5::P64;
           if (R1 & 7 != 0) goto u8Vhh; else goto c8VgE;
       u8Vhh: // global
           call _c8VgD(R1) args: 0, res: 0, upd: 0;
       c8VgE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VgD() //  [R1]
         { info_tbl: [(c8VgD,
                       label: block_c8VgD_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VgD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8VgO; else goto c8VgN;
       c8VgO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VgN: // global
           _s8TS7::P64 = P64[R1 + 7];
           _s8TS8::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48];
           _s8TRz::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8VgT_info;
           R6 = P64[Sp + 24] + 16;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 8];
           R3 = _s8TS8::P64;
           R2 = _s8TS7::P64;
           P64[Sp] = Hp - 7;
           P64[Sp + 8] = _s8TRz::P64;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8VgT() //  [R1]
         { info_tbl: [(c8VgT,
                       label: block_c8VgT_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VgT: // global
           I64[Sp] = block_c8VgV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Vhi; else goto c8VgX;
       u8Vhi: // global
           call _c8VgV(R1) args: 0, res: 0, upd: 0;
       c8VgX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VgV() //  [R1]
         { info_tbl: [(c8VgV,
                       label: block_c8VgV_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VgV: // global
           if (R1 & 7 == 1) goto c8Vh7; else goto c8Vhd;
       c8Vh7: // global
           I64[Sp] = block_c8Vh5_info;
           R2 = I64[Sp + 32] << 1;
           R1 = P64[Sp + 24];
           call $wgo_s8TRX_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8Vhd: // global
           _s8TSn::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 8]);
           R1 = _s8TSn::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Vh5() //  [R1]
         { info_tbl: [(c8Vh5,
                       label: block_c8Vh5_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vh5: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8TSF_entry() //  [R1, R2]
         { info_tbl: [(c8Vhj,
                       label: sat_s8TSF_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vhj: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8Vhk; else goto c8Vhl;
       c8Vhk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Vhl: // global
           I64[Sp - 40] = block_c8Vgb_info;
           R3 = 0;
           _s8TRF::P64 = R2;
           _s8TRy::P64 = P64[R1 + 14];
           R2 = _s8TRy::P64;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = _s8TRy::P64;
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _s8TRF::P64;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vgb() //  [R1]
         { info_tbl: [(c8Vgb,
                       label: block_c8Vgb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vgb: // global
           I64[Sp - 8] = block_c8Vgi_info;
           R2 = 4;
           _s8TRH::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TRH::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vgi() //  [R1]
         { info_tbl: [(c8Vgi,
                       label: block_c8Vgi_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vgi: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c8VhA() args: 0, res: 0, upd: 0;
     }
 },
 _c8VhA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VhA: // global
           _s8TSv::P64 = P64[Sp];
           I64[Sp] = block_c8VhD_info;
           R1 = _s8TSv::P64;
           if (R1 & 7 != 0) goto u8Vi2; else goto c8VhF;
       u8Vi2: // global
           call _c8VhD(R1) args: 0, res: 0, upd: 0;
       c8VhF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VhD() //  [R1]
         { info_tbl: [(c8VhD,
                       label: block_c8VhD_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VhD: // global
           if (R1 & 7 == 1) goto c8VhL; else goto c8VhQ;
       c8VhL: // global
           I64[Sp + 8] = block_c8Vgs_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8VhQ: // global
           I64[Sp - 8] = block_c8VhO_info;
           _s8TSA::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TSA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Vi3; else goto c8VhR;
       u8Vi3: // global
           call _c8VhO(R1) args: 0, res: 0, upd: 0;
       c8VhR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vgs() //  [R1]
         { info_tbl: [(c8Vgs,
                       label: block_c8Vgs_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vgs: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8Vhr; else goto c8Vhq;
       c8Vhr: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vhq: // global
           I64[Hp - 104] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = Hp - 103;
           P64[Hp - 72] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 64] = I64[Sp + 8];
           _s8TRH::I64 = I64[Sp + 16];
           I64[Hp - 56] = _s8TRH::I64;
           I64[Hp - 48] = 0;
           I64[Hp - 40] = _s8TRH::I64;
           I64[Hp - 32] = $wgo_s8TRX_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = Hp - 87;
           I64[Sp + 24] = block_c8Vhv_info;
           R2 = _s8TRH::I64 + 1;
           R1 = Hp - 30;
           Sp = Sp + 24;
           call $wgo_s8TRX_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vhv() //  [R1]
         { info_tbl: [(c8Vhv,
                       label: block_c8Vhv_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vhv: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8VhO() //  [R1]
         { info_tbl: [(c8VhO,
                       label: block_c8VhO_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VhO: // global
           _s8TSw::I64 = I64[Sp + 16];
           _s8TSA::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TSw::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TSA::P64;
           I64[Sp + 16] = _s8TSw::I64 + 1;
           Sp = Sp + 8;
           call _c8VhA() args: 0, res: 0, upd: 0;
     }
 },
 withEncodedCString1_r8TNp_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Vi5,
                       label: withEncodedCString1_r8TNp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vi5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Vi6; else goto c8Vi7;
       c8Vi6: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withEncodedCString1_r8TNp_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Vi7: // global
           I64[Sp - 32] = block_c8Vg1_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Vib; else goto c8Vg2;
       u8Vib: // global
           call _c8Vg1(R1) args: 0, res: 0, upd: 0;
       c8Vg2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vg1() //  [R1]
         { info_tbl: [(c8Vg1,
                       label: block_c8Vg1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vg1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Via; else goto c8Vi9;
       c8Via: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vi9: // global
           _s8TRE::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_s8TSF_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = Hp - 22;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TRE::P64;
           Sp = Sp + 32;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.973349891 UTC

[section ""data" . GHC.Foreign.withEncodedCString_closure" {
     GHC.Foreign.withEncodedCString_closure:
         const GHC.Foreign.withEncodedCString_info;
 },
 GHC.Foreign.withEncodedCString_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8VjA,
                       label: GHC.Foreign.withEncodedCString_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VjA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withEncodedCString1_r8TNp_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:02.979570844 UTC

[section ""data" . GHC.Foreign.charIsRepresentable3_closure" {
     GHC.Foreign.charIsRepresentable3_closure:
         const GHC.Foreign.charIsRepresentable3_info;
 },
 $wgo_s8TT6_entry() //  [R1, R2]
         { info_tbl: [(c8Vku,
                       label: $wgo_s8TT6_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vku: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8Vkv; else goto c8Vkw;
       c8Vkv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Vkw: // global
           I64[Sp - 48] = block_c8Vkl_info;
           _s8TT6::P64 = R1;
           _s8TSI::P64 = P64[R1 + 6];
           _s8TSO::P64 = P64[R1 + 14];
           _s8TT5::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _s8TSI::P64;
           P64[Sp - 32] = _s8TSO::P64;
           P64[Sp - 24] = _s8TT5::P64;
           P64[Sp - 16] = _s8TT6::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 48;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vkl() //  [R1]
         { info_tbl: [(c8Vkl,
                       label: block_c8Vkl_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vkl: // global
           I64[Sp - 8] = block_c8Vkn_info;
           _s8TTe::P64 = R1;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp] = _s8TTe::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vkn() //  [R1]
         { info_tbl: [(c8Vkn,
                       label: block_c8Vkn_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vkn: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8VkA; else goto c8Vkz;
       c8VkA: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vkz: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 24] = P64[Sp + 8] + 16;
           I64[Hp - 16] = I64[Sp + 48];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp] = Hp - 47;
           P64[Sp + 32] = P64[Sp + 32];
           call _c8Vlt() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vlt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vlt: // global
           I64[Sp - 8] = block_c8Vlv_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Vmu; else goto c8Vlw;
       u8Vmu: // global
           call _c8Vlv(R1) args: 0, res: 0, upd: 0;
       c8Vlw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vlv() //  [R1]
         { info_tbl: [(c8Vlv,
                       label: block_c8Vlv_info
                       rep:StackRep [False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vlv: // global
           _s8TTO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8VlA_info;
           R3 = _s8TTO::P64;
           R2 = P64[Sp + 40];
           _s8TTS::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 40] = _s8TTS::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VlA() //  [R1]
         { info_tbl: [(c8VlA,
                       label: block_c8VlA_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VlA: // global
           I64[Sp] = block_c8VlC_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Vmv; else goto c8VlD;
       u8Vmv: // global
           call _c8VlC(R1) args: 0, res: 0, upd: 0;
       c8VlD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VlC() //  [R1]
         { info_tbl: [(c8VlC,
                       label: block_c8VlC_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VlC: // global
           I64[Sp - 16] = block_c8VlH_info;
           _s8TU0::P64 = P64[R1 + 7];
           _s8TU2::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TU2::P64;
           P64[Sp] = _s8TU0::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Vmw; else goto c8VlM;
       u8Vmw: // global
           call _c8VlH(R1) args: 0, res: 0, upd: 0;
       c8VlM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VlH() //  [R1]
         { info_tbl: [(c8VlH,
                       label: block_c8VlH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VlH: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8Vmh; else goto c8VlW;
       c8Vmh: // global
           I64[Sp + 16] = block_c8VkS_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u8Vmy; else goto c8VkU;
       u8Vmy: // global
           call _c8VkS(R1) args: 0, res: 0, upd: 0;
       c8VkU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8VlW: // global
           I64[Sp] = block_c8VlU_info;
           _s8TU3::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TU3::P64;
           if (R1 & 7 != 0) goto u8Vmx; else goto c8VlX;
       u8Vmx: // global
           call _c8VlU(R1) args: 0, res: 0, upd: 0;
       c8VlX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VkS() //  [R1]
         { info_tbl: [(c8VkS,
                       label: block_c8VkS_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VkS: // global
           _s8TTy::I64 = I64[R1 + 47];
           _s8TTz::I64 = I64[R1 + 31] - _s8TTy::I64;
           if (_s8TTz::I64 != 0) goto u8Vmp; else goto c8Vlg;
       u8Vmp: // global
           I64[Sp + 24] = _s8TTz::I64;
           I64[Sp + 32] = _s8TTy::I64;
           P64[Sp + 40] = P64[R1 + 7];
           I64[Sp + 48] = I64[R1 + 23];
           Sp = Sp + 8;
           call _c8Vl3() args: 0, res: 0, upd: 0;
       c8Vlg: // global
           I64[Sp] = block_c8Vln_info;
           R2 = I64[Sp + 48] << 1;
           R1 = P64[Sp + 40];
           call $wgo_s8TT6_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vl3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vl3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Vlb; else goto c8Vla;
       c8Vlb: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8Vl2_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Vla: // global
           _s8TSI::P64 = P64[Sp + 8];
           _s8TTt::I64 = I64[Sp + 40];
           I8[_s8TTt::I64 + I64[Sp + 24]] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8TTt::I64;
           I64[Sp - 8] = block_c8Vl6_info;
           R2 = Hp - 7;
           R1 = _s8TSI::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vl2() //  [R1]
         { info_tbl: [(c8Vl2,
                       label: block_c8Vl2_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vl2: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8Vl3() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vl6() //  [R1]
         { info_tbl: [(c8Vl6,
                       label: block_c8Vl6_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vl6: // global
           _s8TTe::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 40]);
           call MO_Touch(_s8TTe::P64);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Vln() //  [R1]
         { info_tbl: [(c8Vln,
                       label: block_c8Vln_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vln: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8VlU() //  [R1]
         { info_tbl: [(c8VlU,
                       label: block_c8VlU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VlU: // global
           if (R1 & 7 == 2) goto c8Vmg; else goto c8Vm6;
       c8Vmg: // global
           I64[Sp + 16] = block_c8VkK_info;
           R2 = I64[Sp + 64] << 1;
           R1 = P64[Sp + 56];
           Sp = Sp + 16;
           call $wgo_s8TT6_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8Vm6: // global
           _s8TU3::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8Vm1_info;
           R3 = P64[Sp + 8];
           R2 = _s8TU3::P64;
           R1 = P64[Sp + 48];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VkK() //  [R1]
         { info_tbl: [(c8VkK,
                       label: block_c8VkK_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VkK: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Vm1() //  [R1]
         { info_tbl: [(c8Vm1,
                       label: block_c8Vm1_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vm1: // global
           I64[Sp] = block_c8Vm3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Vmz; else goto c8Vm8;
       u8Vmz: // global
           call _c8Vm3(R1) args: 0, res: 0, upd: 0;
       c8Vm8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vm3() //  [R1]
         { info_tbl: [(c8Vm3,
                       label: block_c8Vm3_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vm3: // global
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           call _c8Vlt() args: 0, res: 0, upd: 0;
     }
 },
 sat_s8TUB_entry() //  [R1, R2]
         { info_tbl: [(c8VmB,
                       label: sat_s8TUB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VmB: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8VmC; else goto c8VmD;
       c8VmC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8VmD: // global
           I64[Sp - 32] = block_c8VjV_info;
           R3 = 0;
           _s8TSO::P64 = R2;
           _s8TSH::P64 = P64[R1 + 6];
           R2 = _s8TSH::P64;
           P64[Sp - 24] = _s8TSH::P64;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = _s8TSO::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8VjV() //  [R1]
         { info_tbl: [(c8VjV,
                       label: block_c8VjV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VjV: // global
           I64[Sp - 8] = block_c8Vk2_info;
           R2 = 4;
           _s8TSQ::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TSQ::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vk2() //  [R1]
         { info_tbl: [(c8Vk2,
                       label: block_c8Vk2_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vk2: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8VmS() args: 0, res: 0, upd: 0;
     }
 },
 _c8VmS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VmS: // global
           _s8TUr::P64 = P64[Sp];
           I64[Sp] = block_c8VmV_info;
           R1 = _s8TUr::P64;
           if (R1 & 7 != 0) goto u8Vnk; else goto c8VmX;
       u8Vnk: // global
           call _c8VmV(R1) args: 0, res: 0, upd: 0;
       c8VmX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VmV() //  [R1]
         { info_tbl: [(c8VmV,
                       label: block_c8VmV_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VmV: // global
           if (R1 & 7 == 1) goto c8Vn3; else goto c8Vn8;
       c8Vn3: // global
           I64[Sp + 8] = block_c8Vkc_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8Vn8: // global
           I64[Sp - 8] = block_c8Vn6_info;
           _s8TUw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TUw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Vnl; else goto c8Vn9;
       u8Vnl: // global
           call _c8Vn6(R1) args: 0, res: 0, upd: 0;
       c8Vn9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vkc() //  [R1]
         { info_tbl: [(c8Vkc,
                       label: block_c8Vkc_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vkc: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c8VmJ; else goto c8VmI;
       c8VmJ: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VmI: // global
           I64[Hp - 96] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = Hp - 95;
           P64[Hp - 64] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 56] = I64[Sp + 8];
           _s8TSQ::I64 = I64[Sp + 16];
           I64[Hp - 48] = _s8TSQ::I64;
           I64[Hp - 40] = 0;
           I64[Hp - 32] = _s8TSQ::I64;
           I64[Hp - 24] = $wgo_s8TT6_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 79;
           I64[Sp + 16] = block_c8VmN_info;
           R2 = _s8TSQ::I64 + 1;
           R1 = Hp - 22;
           Sp = Sp + 16;
           call $wgo_s8TT6_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VmN() //  [R1]
         { info_tbl: [(c8VmN,
                       label: block_c8VmN_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VmN: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Vn6() //  [R1]
         { info_tbl: [(c8Vn6,
                       label: block_c8Vn6_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vn6: // global
           _s8TUs::I64 = I64[Sp + 16];
           _s8TUw::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TUs::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TUw::P64;
           I64[Sp + 16] = _s8TUs::I64 + 1;
           Sp = Sp + 8;
           call _c8VmS() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Foreign.charIsRepresentable3_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Vnn,
                       label: GHC.Foreign.charIsRepresentable3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vnn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Vno; else goto c8Vnp;
       c8Vno: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Vnp: // global
           I64[Sp - 24] = block_c8VjL_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Vnt; else goto c8VjM;
       u8Vnt: // global
           call _c8VjL(R1) args: 0, res: 0, upd: 0;
       c8VjM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VjL() //  [R1]
         { info_tbl: [(c8VjL,
                       label: block_c8VjL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VjL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Vns; else goto c8Vnr;
       c8Vns: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vnr: // global
           _s8TSN::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8TUB_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TSN::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.027790865 UTC

[section ""data" . GHC.Foreign.withCString_closure" {
     GHC.Foreign.withCString_closure:
         const GHC.Foreign.withCString_info;
 },
 GHC.Foreign.withCString_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Vpz,
                       label: GHC.Foreign.withCString_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vpz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.032393304 UTC

[section ""data" . GHC.Foreign.withCStringsLen1_closure" {
     GHC.Foreign.withCStringsLen1_closure:
         const GHC.Foreign.withCStringsLen1_info;
         const 0;
 },
 sat_s8TUL_entry() //  [R1]
         { info_tbl: [(c8VpY,
                       label: sat_s8TUL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VpY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8VpZ; else goto c8Vq0;
       c8VpZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Vq0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TUR_entry() //  [R1, R2]
         { info_tbl: [(c8Vq9,
                       label: sat_s8TUR_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vq9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Vqd; else goto c8Vqc;
       c8Vqd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Vqc: // global
           _s8TUG::P64 = P64[R1 + 6];
           _s8TUH::P64 = P64[R1 + 14];
           _s8TUN::P64 = P64[R1 + 22];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = _s8TUH::P64;
           R3 = _s8TUN::P64;
           R2 = Hp - 14;
           R1 = _s8TUG::P64;
           call go_s8TUG_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s8TUG_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Vqi,
                       label: go_s8TUG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vqi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Vqj; else goto c8Vqk;
       c8Vqj: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Vqk: // global
           I64[Sp - 40] = block_c8VpP_info;
           _s8TUG::P64 = R1;
           _s8TUC::P64 = P64[R1 + 5];
           _s8TUE::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 32] = _s8TUC::P64;
           P64[Sp - 24] = _s8TUE::P64;
           P64[Sp - 16] = _s8TUG::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Vqr; else goto c8VpQ;
       u8Vqr: // global
           call _c8VpP(R1) args: 0, res: 0, upd: 0;
       c8VpQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VpP() //  [R1]
         { info_tbl: [(c8VpP,
                       label: block_c8VpP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VpP: // global
           _s8TUH::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c8Vqf; else goto c8Vqg;
       c8Vqf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Vqn; else goto c8Vqm;
       c8Vqn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vqm: // global
           I64[Hp - 16] = sat_s8TUL_info;
           P64[Hp] = _s8TUH::P64;
           R4 = P64[Sp + 16];
           R3 = Hp - 16;
           R2 = Foreign.Storable.$fStorablePtr_closure;
           I64[Sp + 32] = stg_ap_v_info;
           Sp = Sp + 32;
           call Foreign.Marshal.Array.withArrayLen_entry(R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
       c8Vqg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Vqq; else goto c8Vqp;
       c8Vqq: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vqp: // global
           _s8TUM::P64 = P64[R1 + 6];
           _s8TUN::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s8TUR_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _s8TUH::P64;
           P64[Hp] = _s8TUN::P64;
           R4 = Hp - 22;
           R3 = _s8TUM::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.withCStringsLen1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Vqs,
                       label: GHC.Foreign.withCStringsLen1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vqs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Vqw; else goto c8Vqv;
       c8Vqw: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.withCStringsLen1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Vqv: // global
           I64[Hp - 16] = go_s8TUG_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R3 = R3;
           R2 = GHC.Types.[]_closure+1;
           R1 = Hp - 13;
           call go_s8TUG_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.045115906 UTC

[section ""data" . GHC.Foreign.withCStringsLen_closure" {
     GHC.Foreign.withCStringsLen_closure:
         const GHC.Foreign.withCStringsLen_info;
         const 0;
 },
 GHC.Foreign.withCStringsLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8VqX,
                       label: GHC.Foreign.withCStringsLen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VqX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.049867174 UTC

[section ""data" . GHC.Foreign.withCStringLen_closure" {
     GHC.Foreign.withCStringLen_closure:
         const GHC.Foreign.withCStringLen_info;
 },
 GHC.Foreign.withCStringLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Vr8,
                       label: GHC.Foreign.withCStringLen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vr8: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call GHC.Foreign.withEncodedCString_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.053021971 UTC

[section ""data" . GHC.Foreign.newCString2_closure" {
     GHC.Foreign.newCString2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.057042609 UTC

[section ""data" . newEncodedCString1_r8TNq_closure" {
     newEncodedCString1_r8TNq_closure:
         const newEncodedCString1_r8TNq_info;
         const 0;
 },
 sat_s8TWa_entry() //  [R1, R2]
         { info_tbl: [(c8VsF,
                       label: sat_s8TWa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VsF: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8VsG; else goto c8VsH;
       c8VsG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8VsH: // global
           I64[Sp - 32] = block_c8Vru_info;
           R3 = 0;
           _s8TV1::P64 = R2;
           _s8TUV::P64 = P64[R1 + 14];
           R2 = _s8TUV::P64;
           P64[Sp - 24] = P64[R1 + 6];
           P64[Sp - 16] = _s8TUV::P64;
           P64[Sp - 8] = _s8TV1::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vru() //  [R1]
         { info_tbl: [(c8Vru,
                       label: block_c8Vru_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vru: // global
           I64[Sp - 8] = block_c8VrB_info;
           R2 = 4;
           _s8TV3::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TV3::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VrB() //  [R1]
         { info_tbl: [(c8VrB,
                       label: block_c8VrB_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VrB: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c8Vtm() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vtm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vtm: // global
           _s8TW0::P64 = P64[Sp];
           I64[Sp] = block_c8Vtp_info;
           R1 = _s8TW0::P64;
           if (R1 & 7 != 0) goto u8Vu4; else goto c8Vtr;
       u8Vu4: // global
           call _c8Vtp(R1) args: 0, res: 0, upd: 0;
       c8Vtr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vtp() //  [R1]
         { info_tbl: [(c8Vtp,
                       label: block_c8Vtp_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vtp: // global
           if (R1 & 7 == 1) goto c8Vtx; else goto c8VtC;
       c8Vtx: // global
           I64[Sp + 8] = block_c8VrL_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8VtC: // global
           I64[Sp - 8] = block_c8VtA_info;
           _s8TW5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TW5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Vu5; else goto c8VtD;
       u8Vu5: // global
           call _c8VtA(R1) args: 0, res: 0, upd: 0;
       c8VtD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VrL() //  [R1]
         { info_tbl: [(c8VrL,
                       label: block_c8VrL_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VrL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8VsN; else goto c8VsM;
       c8VsN: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VsM: // global
           _s8TV3::I64 = I64[Sp + 16];
           _s8TVb::I64 = I64[Sp + 8];
           _s8TVh::I64 = _s8TV3::I64 + 1;
           (_s8TVm::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8TVh::I64);
           if (_s8TVm::I64 == 0) goto c8Vtj; else goto c8Vti;
       c8Vtj: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Vti: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8TVb::I64;
           I64[Hp - 32] = _s8TV3::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8TV3::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TVh::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8TVm::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8Vs5() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vs5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vs5: // global
           I64[Sp - 8] = block_c8Vs8_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8VtX; else goto c8Vs9;
       u8VtX: // global
           call _c8Vs8(R1) args: 0, res: 0, upd: 0;
       c8Vs9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vs8() //  [R1]
         { info_tbl: [(c8Vs8,
                       label: block_c8Vs8_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vs8: // global
           I64[Sp] = block_c8Vsd_info;
           R6 = I64[Sp + 16];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 32];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 8];
           P64[Sp - 8] = GHC.Base.$fApplicativeIO4_closure+2;
           Sp = Sp - 16;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Vsd() //  [R1]
         { info_tbl: [(c8Vsd,
                       label: block_c8Vsd_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vsd: // global
           I64[Sp] = block_c8Vsf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8VtY; else goto c8Vsg;
       u8VtY: // global
           call _c8Vsf(R1) args: 0, res: 0, upd: 0;
       c8Vsg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vsf() //  [R1]
         { info_tbl: [(c8Vsf,
                       label: block_c8Vsf_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vsf: // global
           if (R1 & 7 == 1) goto c8VsX; else goto c8Vtg;
       c8VsX: // global
           _s8TVw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Vsk_info;
           R1 = _s8TVw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8VtZ; else goto c8Vsl;
       u8VtZ: // global
           call _c8Vsk(R1) args: 0, res: 0, upd: 0;
       c8Vsl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Vtg: // global
           _s8TVs::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 40]);
           R1 = _s8TVs::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Vsk() //  [R1]
         { info_tbl: [(c8Vsk,
                       label: block_c8Vsk_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vsk: // global
           _s8TVK::I64 = I64[R1 + 7] << 1;
           if (_s8TVK::I64 != 0) goto u8VtR; else goto c8Vt9;
       u8VtR: // global
           I64[Sp] = _s8TVK::I64;
           call _c8Vst() args: 0, res: 0, upd: 0;
       c8Vt9: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = GHC.Foreign.newCString2_closure+1;
           call _c8Vs5() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vst() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vst: // global
           Hp = Hp + 16;
           _s8TVK::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8Vt3; else goto c8Vt2;
       c8Vt3: // global
           HpAlloc = 16;
           I64[Sp] = block_c8Vss_info;
           R1 = _s8TVK::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Vt2: // global
           (_s8TVP::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8TVK::I64);
           if (_s8TVP::I64 == 0) goto c8Vt6; else goto c8Vt5;
       c8Vt6: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Vt5: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TVK::I64;
           I64[Sp + 8] = _s8TVP::I64;
           P64[Sp] = Hp - 7;
           call _c8Vs5() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vss() //  [R1]
         { info_tbl: [(c8Vss,
                       label: block_c8Vss_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vss: // global
           I64[Sp] = R1;
           call _c8Vst() args: 0, res: 0, upd: 0;
     }
 },
 _c8VtA() //  [R1]
         { info_tbl: [(c8VtA,
                       label: block_c8VtA_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VtA: // global
           _s8TW1::I64 = I64[Sp + 16];
           _s8TW5::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TW1::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TW5::P64;
           I64[Sp + 16] = _s8TW1::I64 + 1;
           Sp = Sp + 8;
           call _c8Vtm() args: 0, res: 0, upd: 0;
     }
 },
 newEncodedCString1_r8TNq_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Vu7,
                       label: newEncodedCString1_r8TNq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vu7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Vu8; else goto c8Vu9;
       c8Vu8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = newEncodedCString1_r8TNq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Vu9: // global
           I64[Sp - 24] = block_c8Vrk_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Vud; else goto c8Vrl;
       u8Vud: // global
           call _c8Vrk(R1) args: 0, res: 0, upd: 0;
       c8Vrl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vrk() //  [R1]
         { info_tbl: [(c8Vrk,
                       label: block_c8Vrk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vrk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Vuc; else goto c8Vub;
       c8Vuc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vub: // global
           _s8TV0::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8TWa_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TV0::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.087856949 UTC

[section ""data" . GHC.Foreign.newEncodedCString_closure" {
     GHC.Foreign.newEncodedCString_closure:
         const GHC.Foreign.newEncodedCString_info;
         const 0;
 },
 GHC.Foreign.newEncodedCString_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Vvs,
                       label: GHC.Foreign.newEncodedCString_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vvs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call newEncodedCString1_r8TNq_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.095944996 UTC

[section ""data" . GHC.Foreign.newCString1_closure" {
     GHC.Foreign.newCString1_closure:
         const GHC.Foreign.newCString1_info;
         const 0;
 },
 sat_s8TY4_entry() //  [R1]
         { info_tbl: [(c8Vxa,
                       label: sat_s8TY4_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vxa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Vxf; else goto c8Vxg;
       c8Vxf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Vxg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8Vx7_info;
           _s8TWX::P64 = P64[R1 + 24];
           _s8TWM::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8TWM::I64;
           P64[Sp - 24] = _s8TWX::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Vxk; else goto c8Vx8;
       u8Vxk: // global
           call _c8Vx7(R1) args: 0, res: 0, upd: 0;
       c8Vx8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Vx7() //  [R1]
         { info_tbl: [(c8Vx7,
                       label: block_c8Vx7_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vx7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Vxj; else goto c8Vxi;
       c8Vxj: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Vxi: // global
           _s8TY2::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8TY2::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TYi_entry() //  [R1, R2]
         { info_tbl: [(c8Vxl,
                       label: sat_s8TYi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vxl: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c8Vxm; else goto c8Vxn;
       c8Vxm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Vxn: // global
           I64[Sp - 24] = block_c8VvN_info;
           R3 = 0;
           _s8TWi::P64 = R2;
           _s8TWc::P64 = P64[R1 + 6];
           R2 = _s8TWc::P64;
           P64[Sp - 16] = _s8TWc::P64;
           P64[Sp - 8] = _s8TWi::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8VvN() //  [R1]
         { info_tbl: [(c8VvN,
                       label: block_c8VvN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VvN: // global
           I64[Sp - 8] = block_c8VvU_info;
           R2 = 4;
           _s8TWk::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8TWk::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VvU() //  [R1]
         { info_tbl: [(c8VvU,
                       label: block_c8VvU_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VvU: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8Vzq() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vzq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vzq: // global
           _s8TY8::P64 = P64[Sp];
           I64[Sp] = block_c8Vzt_info;
           R1 = _s8TY8::P64;
           if (R1 & 7 != 0) goto u8VAB; else goto c8Vzv;
       u8VAB: // global
           call _c8Vzt(R1) args: 0, res: 0, upd: 0;
       c8Vzv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vzt() //  [R1]
         { info_tbl: [(c8Vzt,
                       label: block_c8Vzt_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vzt: // global
           if (R1 & 7 == 1) goto c8VzB; else goto c8VzG;
       c8VzB: // global
           I64[Sp + 8] = block_c8Vw4_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8VzG: // global
           I64[Sp - 8] = block_c8VzE_info;
           _s8TYd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8TYd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8VAC; else goto c8VzH;
       u8VAC: // global
           call _c8VzE(R1) args: 0, res: 0, upd: 0;
       c8VzH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vw4() //  [R1]
         { info_tbl: [(c8Vw4,
                       label: block_c8Vw4_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vw4: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8Vxt; else goto c8Vxs;
       c8Vxt: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Vxs: // global
           _s8TWk::I64 = I64[Sp + 16];
           _s8TWs::I64 = I64[Sp + 8];
           _s8TWy::I64 = _s8TWk::I64 + 1;
           (_s8TWD::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8TWy::I64);
           if (_s8TWD::I64 == 0) goto c8Vzn; else goto c8Vzm;
       c8Vzn: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Vzm: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8TWs::I64;
           I64[Hp - 32] = _s8TWk::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8TWk::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TWy::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8TWD::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8Vwo() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vwo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vwo: // global
           I64[Sp - 8] = block_c8Vwr_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8VAi; else goto c8Vws;
       u8VAi: // global
           call _c8Vwr(R1) args: 0, res: 0, upd: 0;
       c8Vws: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vwr() //  [R1]
         { info_tbl: [(c8Vwr,
                       label: block_c8Vwr_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vwr: // global
           I64[Sp - 16] = block_c8Vww_info;
           _s8TWQ::P64 = P64[R1 + 7];
           _s8TWR::P64 = P64[R1 + 15];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = _s8TWR::P64;
           P64[Sp] = _s8TWQ::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vww() //  [R1]
         { info_tbl: [(c8Vww,
                       label: block_c8Vww_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vww: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8VxC; else goto c8VxB;
       c8VxC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VxB: // global
           I64[Hp - 32] = sat_s8TY4_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 32];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = P64[Sp + 40];
           Sp = Sp - 8;
           call _c8VyC() args: 0, res: 0, upd: 0;
     }
 },
 _c8VyC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VyC: // global
           _s8TXC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8VyE_info;
           R3 = P64[Sp];
           R2 = _s8TXC::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VyE() //  [R1]
         { info_tbl: [(c8VyE,
                       label: block_c8VyE_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VyE: // global
           I64[Sp] = block_c8VyG_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8VAu; else goto c8VyH;
       u8VAu: // global
           call _c8VyG(R1) args: 0, res: 0, upd: 0;
       c8VyH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VyG() //  [R1]
         { info_tbl: [(c8VyG,
                       label: block_c8VyG_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VyG: // global
           I64[Sp - 16] = block_c8VyL_info;
           _s8TXJ::P64 = P64[R1 + 7];
           _s8TXL::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TXL::P64;
           P64[Sp] = _s8TXJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8VAv; else goto c8VyP;
       u8VAv: // global
           call _c8VyL(R1) args: 0, res: 0, upd: 0;
       c8VyP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VyL() //  [R1]
         { info_tbl: [(c8VyL,
                       label: block_c8VyL_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VyL: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8Vzk; else goto c8VyZ;
       c8Vzk: // global
           I64[Sp + 32] = block_c8Vyb_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8VAx; else goto c8Vyd;
       u8VAx: // global
           call _c8Vyb(R1) args: 0, res: 0, upd: 0;
       c8Vyd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8VyZ: // global
           I64[Sp] = block_c8VyX_info;
           _s8TXM::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TXM::P64;
           if (R1 & 7 != 0) goto u8VAw; else goto c8Vz0;
       u8VAw: // global
           call _c8VyX(R1) args: 0, res: 0, upd: 0;
       c8Vz0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vyb() //  [R1]
         { info_tbl: [(c8Vyb,
                       label: block_c8Vyb_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vyb: // global
           _s8TXs::I64 = I64[R1 + 47];
           _s8TXt::I64 = I64[R1 + 31] - _s8TXs::I64;
           if (_s8TXt::I64 != 0) goto u8VA8; else goto u8VA7;
       u8VA8: // global
           P64[Sp - 32] = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 39];
           I64[Sp - 16] = _s8TXs::I64;
           I64[Sp - 8] = _s8TXt::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8Vyo() args: 0, res: 0, upd: 0;
       u8VA7: // global
           Sp = Sp + 8;
           call _c8Vyv() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vyo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vyo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Vys; else goto c8Vyr;
       c8Vys: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_c8Vyl_info;
           R1 = I64[Sp + 24];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Vyr: // global
           _s8TXn::I64 = I64[Sp + 32];
           _s8TXo::P64 = P64[Sp];
           _s8TXr::I64 = I64[Sp + 8];
           _s8TXs::I64 = I64[Sp + 16];
           I8[_s8TXn::I64 + _s8TXs::I64] = 0 :: W8;
           call MO_Touch(_s8TXo::P64);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _s8TXs::I64 - _s8TXr::I64;
           I64[Hp - 48] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 40] = _s8TXn::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 63;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           P64[Sp + 32] = Hp - 6;
           Sp = Sp + 32;
           call _s8TWY() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vyl() //  [R1]
         { info_tbl: [(c8Vyl,
                       label: block_c8Vyl_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vyl: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _c8Vyo() args: 0, res: 0, upd: 0;
     }
 },
 _c8VyX() //  [R1]
         { info_tbl: [(c8VyX,
                       label: block_c8VyX_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VyX: // global
           if (R1 & 7 == 2) goto u8VA5; else goto c8Vz9;
       u8VA5: // global
           Sp = Sp + 40;
           call _c8Vyv() args: 0, res: 0, upd: 0;
       c8Vz9: // global
           _s8TXM::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8Vz4_info;
           R3 = P64[Sp + 8];
           R2 = _s8TXM::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vyv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vyv: // global
           P64[Sp - 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call _s8TWY() args: 0, res: 0, upd: 0;
     }
 },
 _s8TWY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TWY: // global
           _s8TX0::P64 = P64[Sp];
           I64[Sp] = block_c8VwF_info;
           R1 = _s8TX0::P64;
           if (R1 & 7 != 0) goto u8VAE; else goto c8VwG;
       u8VAE: // global
           call _c8VwF(R1) args: 0, res: 0, upd: 0;
       c8VwG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VwF() //  [R1]
         { info_tbl: [(c8VwF,
                       label: block_c8VwF_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VwF: // global
           if (R1 & 7 == 1) goto c8VxG; else goto c8VxZ;
       c8VxG: // global
           _s8TWN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8VwK_info;
           R1 = _s8TWN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8VAk; else goto c8VwL;
       u8VAk: // global
           call _c8VwK(R1) args: 0, res: 0, upd: 0;
       c8VwL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8VxZ: // global
           _s8TWJ::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 32]);
           R1 = _s8TWJ::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8VwK() //  [R1]
         { info_tbl: [(c8VwK,
                       label: block_c8VwK_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VwK: // global
           _s8TX4::I64 = I64[R1 + 7] << 1;
           if (_s8TX4::I64 != 0) goto u8VAc; else goto c8VxS;
       u8VAc: // global
           I64[Sp] = _s8TX4::I64;
           call _c8VwT() args: 0, res: 0, upd: 0;
       c8VxS: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = GHC.Foreign.newCString2_closure+1;
           call _c8Vwo() args: 0, res: 0, upd: 0;
     }
 },
 _c8VwT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VwT: // global
           Hp = Hp + 16;
           _s8TX4::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8VxM; else goto c8VxL;
       c8VxM: // global
           HpAlloc = 16;
           I64[Sp] = block_c8VwS_info;
           R1 = _s8TX4::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8VxL: // global
           (_s8TX9::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8TX4::I64);
           if (_s8TX9::I64 == 0) goto c8VxP; else goto c8VxO;
       c8VxP: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8VxO: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8TX4::I64;
           I64[Sp + 8] = _s8TX9::I64;
           P64[Sp] = Hp - 7;
           call _c8Vwo() args: 0, res: 0, upd: 0;
     }
 },
 _c8VwS() //  [R1]
         { info_tbl: [(c8VwS,
                       label: block_c8VwS_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VwS: // global
           I64[Sp] = R1;
           call _c8VwT() args: 0, res: 0, upd: 0;
     }
 },
 _c8Vz4() //  [R1]
         { info_tbl: [(c8Vz4,
                       label: block_c8Vz4_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vz4: // global
           I64[Sp] = block_c8Vz6_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8VAz; else goto c8Vzb;
       u8VAz: // global
           call _c8Vz6(R1) args: 0, res: 0, upd: 0;
       c8Vzb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Vz6() //  [R1]
         { info_tbl: [(c8Vz6,
                       label: block_c8Vz6_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Vz6: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _c8VyC() args: 0, res: 0, upd: 0;
     }
 },
 _c8VzE() //  [R1]
         { info_tbl: [(c8VzE,
                       label: block_c8VzE_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VzE: // global
           _s8TY9::I64 = I64[Sp + 16];
           _s8TYd::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8TY9::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8TYd::P64;
           I64[Sp + 16] = _s8TY9::I64 + 1;
           Sp = Sp + 8;
           call _c8Vzq() args: 0, res: 0, upd: 0;
     }
 },
 sat_s8TYm_entry() //  [R1]
         { info_tbl: [(c8VAL,
                       label: sat_s8TYm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VAL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8VAM; else goto c8VAN;
       c8VAM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8VAN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.fst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Foreign.newCString1_entry() //  [R2, R3]
         { info_tbl: [(c8VAO,
                       label: GHC.Foreign.newCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VAO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8VAP; else goto c8VAQ;
       c8VAP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.newCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8VAQ: // global
           I64[Sp - 16] = block_c8VvD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8VAX; else goto c8VvE;
       u8VAX: // global
           call _c8VvD(R1) args: 0, res: 0, upd: 0;
       c8VvE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VvD() //  [R1]
         { info_tbl: [(c8VvD,
                       label: block_c8VvD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VvD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8VAT; else goto c8VAS;
       c8VAT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VAS: // global
           _s8TWh::P64 = P64[R1 + 23];
           I64[Hp - 8] = sat_s8TYi_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8VAF_info;
           R4 = Hp - 6;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TWh::P64;
           Sp = Sp + 8;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8VAF() //  [R1]
         { info_tbl: [(c8VAF,
                       label: block_c8VAF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VAF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8VAW; else goto c8VAV;
       c8VAW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VAV: // global
           I64[Hp - 16] = sat_s8TYm_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.155489366 UTC

[section ""data" . GHC.Foreign.newCString_closure" {
     GHC.Foreign.newCString_closure:
         const GHC.Foreign.newCString_info;
         const 0;
 },
 GHC.Foreign.newCString_entry() //  [R2, R3]
         { info_tbl: [(c8VDn,
                       label: GHC.Foreign.newCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VDn: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.159830508 UTC

[section ""data" . GHC.Foreign.newCStringLen_closure" {
     GHC.Foreign.newCStringLen_closure:
         const GHC.Foreign.newCStringLen_info;
         const 0;
 },
 GHC.Foreign.newCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8VDy,
                       label: GHC.Foreign.newCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VDy: // global
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call GHC.Foreign.newEncodedCString_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.167035188 UTC

[section ""data" . GHC.Foreign.$wpeekCString_closure" {
     GHC.Foreign.$wpeekCString_closure:
         const GHC.Foreign.$wpeekCString_info;
         const 0;
 },
 sat_s8TZz_entry() //  [R1]
         { info_tbl: [(c8VFK,
                       label: sat_s8TZz_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VFK: // global
           _s8TZz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8VFL; else goto c8VFM;
       c8VFM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8VFO; else goto c8VFN;
       c8VFO: // global
           HpAlloc = 40;
           goto c8VFL;
       c8VFL: // global
           R1 = _s8TZz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8VFN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8TZz::P64;
           _s8TZo::P64 = P64[_s8TZz::P64 + 16];
           _s8TZw::P64 = P64[_s8TZz::P64 + 24];
           _s8TZs::I64 = I64[_s8TZz::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TZs::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TZo::P64;
           R3 = _s8TZw::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8TZQ_entry() //  [R1]
         { info_tbl: [(c8VFX,
                       label: sat_s8TZQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VFX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8VFY; else goto c8VFZ;
       c8VFY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8VFZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8TYQ_entry() //  [R1, R2]
         { info_tbl: [(c8VG0,
                       label: $wgo_s8TYQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VG0: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8VG1; else goto c8VG2;
       c8VG1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8VG2: // global
           I64[Sp - 32] = block_c8VEp_info;
           _s8TYQ::P64 = R1;
           _s8TYP::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8TYP::P64;
           P64[Sp - 16] = _s8TYQ::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8VHC; else goto c8VEq;
       u8VHC: // global
           call _c8VEp(R1) args: 0, res: 0, upd: 0;
       c8VEq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VEp() //  [R1]
         { info_tbl: [(c8VEp,
                       label: block_c8VEp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VEp: // global
           _s8TYP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8VEu_info;
           R3 = _s8TYP::P64;
           R2 = P64[Sp + 24];
           _s8TYV::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8TYV::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VEu() //  [R1]
         { info_tbl: [(c8VEu,
                       label: block_c8VEu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VEu: // global
           I64[Sp] = block_c8VEw_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8VHu; else goto c8VEx;
       u8VHu: // global
           call _c8VEw(R1) args: 0, res: 0, upd: 0;
       c8VEx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VEw() //  [R1]
         { info_tbl: [(c8VEw,
                       label: block_c8VEw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VEw: // global
           I64[Sp - 16] = block_c8VEB_info;
           _s8TZ3::P64 = P64[R1 + 7];
           _s8TZ5::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8TZ5::P64;
           P64[Sp] = _s8TZ3::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8VHv; else goto c8VEC;
       u8VHv: // global
           call _c8VEB(R1) args: 0, res: 0, upd: 0;
       c8VEC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VEB() //  [R1]
         { info_tbl: [(c8VEB,
                       label: block_c8VEB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VEB: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8VGX; else goto c8VGq;
       c8VGX: // global
           I64[Sp + 32] = block_c8VF9_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8VHx; else goto c8VFa;
       u8VHx: // global
           call _c8VF9(R1) args: 0, res: 0, upd: 0;
       c8VFa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8VGq: // global
           I64[Sp] = block_c8VG7_info;
           _s8TZ6::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8TZ6::P64;
           if (R1 & 7 != 0) goto u8VHw; else goto c8VGr;
       u8VHw: // global
           call _c8VG7(R1) args: 0, res: 0, upd: 0;
       c8VGr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VF9() //  [R1]
         { info_tbl: [(c8VF9,
                       label: block_c8VF9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VF9: // global
           _s8U0e::P64 = P64[R1 + 7];
           _s8U0j::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8U0j::I64, 0)) goto c8VHf; else goto c8VHg;
       c8VHf: // global
           P64[Sp - 24] = _s8U0e::P64;
           I64[Sp - 16] = _s8U0j::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8VFr() args: 0, res: 0, upd: 0;
       c8VHg: // global
           call MO_Touch(_s8U0e::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8VFr() //  []
         { info_tbl: [(c8VFr,
                       label: block_c8VFr_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VFr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8VHa; else goto c8VH9;
       c8VHa: // global
           HpAlloc = 40;
           I64[Sp] = block_c8VFr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8VH9: // global
           _s8U0w::P64 = P64[Sp + 24];
           _s8U0y::I64 = I64[Sp + 16];
           if (_s8U0y::I64 != 0) goto c8VHc; else goto c8VHd;
       c8VHc: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8U0y::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8U0w::P64;
           I64[Sp + 16] = _s8U0y::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8VFr() args: 0, res: 0, upd: 0;
       c8VHd: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8U0w::P64;
           Sp = Sp + 8;
           call _c8VH0() args: 0, res: 0, upd: 0;
     }
 },
 _c8VH0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VH0: // global
           Hp = Hp + 40;
           _s8U0m::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8VH7; else goto c8VH6;
       c8VH7: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8VGZ_info;
           R1 = _s8U0m::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VH6: // global
           _s8U0q::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8U0q::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8U0m::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8VGZ() //  [R1]
         { info_tbl: [(c8VGZ,
                       label: block_c8VGZ_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VGZ: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8VH0() args: 0, res: 0, upd: 0;
     }
 },
 _c8VG7() //  [R1]
         { info_tbl: [(c8VG7,
                       label: block_c8VG7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VG7: // global
           _s8TZ5::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8VGR; else goto c8VGF;
       c8VGR: // global
           I64[Sp + 8] = block_c8VGP_info;
           R1 = _s8TZ5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8VHD; else goto c8VGS;
       u8VHD: // global
           call _c8VGP(R1) args: 0, res: 0, upd: 0;
       c8VGS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8VGF: // global
           _s8TZ6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8VGv_info;
           R3 = _s8TZ5::P64;
           R2 = _s8TZ6::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VGP() //  [R1]
         { info_tbl: [(c8VGP,
                       label: block_c8VGP_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VGP: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8TZe() args: 0, res: 0, upd: 0;
     }
 },
 _c8VGv() //  [R1]
         { info_tbl: [(c8VGv,
                       label: block_c8VGv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VGv: // global
           I64[Sp] = block_c8VGx_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8VHE; else goto c8VGy;
       u8VHE: // global
           call _c8VGx(R1) args: 0, res: 0, upd: 0;
       c8VGy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VGx() //  [R1]
         { info_tbl: [(c8VGx,
                       label: block_c8VGx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VGx: // global
           I64[Sp] = block_c8VGC_info;
           _s8TZW::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8TZW::P64;
           if (R1 & 7 != 0) goto u8VHF; else goto c8VGI;
       u8VHF: // global
           call _c8VGC(R1) args: 0, res: 0, upd: 0;
       c8VGI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VGC() //  [R1]
         { info_tbl: [(c8VGC,
                       label: block_c8VGC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VGC: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8TZe() args: 0, res: 0, upd: 0;
     }
 },
 _s8TZe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8TZe: // global
           _s8TZl::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8TZl::I64, 0)) goto c8VGk; else goto c8VGl;
       c8VGk: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8TZl::I64 - 1;
           Sp = Sp - 8;
           call _c8VF1() args: 0, res: 0, upd: 0;
       c8VGl: // global
           _s8TYQ::P64 = P64[Sp + 32];
           _s8TZg::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8VFR_info;
           R2 = _s8TZg::P64;
           R1 = _s8TYQ::P64;
           Sp = Sp + 40;
           call $wgo_s8TYQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VF1() //  []
         { info_tbl: [(c8VF1,
                       label: block_c8VF1_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VF1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8VGf; else goto c8VGe;
       c8VGf: // global
           HpAlloc = 40;
           I64[Sp] = block_c8VF1_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8VGe: // global
           _s8TZh::I64 = I64[Sp + 32];
           _s8TZC::P64 = P64[Sp + 16];
           _s8TZE::I64 = I64[Sp + 24];
           if (_s8TZE::I64 != 0) goto c8VGh; else goto c8VGi;
       c8VGh: // global
           _s8TZH::I64 = %MO_UU_Conv_W32_W64(I32[_s8TZh::I64 + (_s8TZE::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8TZH::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8TZC::P64;
           I64[Sp + 24] = _s8TZE::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8VF1() args: 0, res: 0, upd: 0;
       c8VGi: // global
           Hp = Hp - 40;
           _s8TYQ::P64 = P64[Sp + 40];
           _s8TZg::P64 = P64[Sp + 48];
           _s8TZs::I64 = %MO_UU_Conv_W32_W64(I32[_s8TZh::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8VFC_info;
           R2 = _s8TZg::P64;
           R1 = _s8TYQ::P64;
           I64[Sp + 40] = _s8TZs::I64;
           P64[Sp + 48] = _s8TZC::P64;
           Sp = Sp + 32;
           call $wgo_s8TYQ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VFC() //  [R1]
         { info_tbl: [(c8VFC,
                       label: block_c8VFC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VFC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8VGc; else goto c8VGb;
       c8VGc: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VGb: // global
           I64[Hp - 32] = sat_s8TZz_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8VFR() //  [R1]
         { info_tbl: [(c8VFR,
                       label: block_c8VFR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VFR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8VGo; else goto c8VGn;
       c8VGo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VGn: // global
           I64[Hp - 16] = sat_s8TZQ_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8U0L_entry() //  [R1, R2]
         { info_tbl: [(c8VHP,
                       label: sat_s8U0L_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VHP: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8VHQ; else goto c8VHR;
       c8VHQ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8VHR: // global
           I64[Sp - 32] = block_c8VDY_info;
           _s8TYp::I64 = I64[R1 + 6];
           _s8TYs::I64 = I64[R1 + 14];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 24] = _s8TYp::I64;
           I64[Sp - 16] = _s8TYs::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VDY() //  [R1]
         { info_tbl: [(c8VDY,
                       label: block_c8VDY_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VDY: // global
           _s8TYs::I64 = I64[Sp + 16];
           if (%MO_S_Gt_W64(_s8TYs::I64, 1)) goto c8VHN; else goto c8VHO;
       c8VHN: // global
           _s8TYC::P64 = R1;
           _s8TYE::I64 = _s8TYs::I64;
           goto s8TYD;
       c8VHO: // global
           _s8TYC::P64 = R1;
           _s8TYE::I64 = 1;
           goto s8TYD;
       s8TYD: // global
           _s8TYF::I64 = _s8TYE::I64 << 2;
           if (%MO_S_Ge_W64(_s8TYF::I64, 0)) goto c8VHX; else goto c8VI2;
       c8VHX: // global
           I64[Sp - 24] = block_c8VEb_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8TYE::I64;
           I64[Sp - 8] = _s8TYF::I64;
           P64[Sp] = _s8TYC::P64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8VI2: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8VEb() //  [R1]
         { info_tbl: [(c8VEb,
                       label: block_c8VEb_info
                       rep:StackRep [True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VEb: // global
           I64[Sp] = block_c8VEd_info;
           _s8TYJ::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8TYJ::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VEd() //  [R1]
         { info_tbl: [(c8VEd,
                       label: block_c8VEd_info
                       rep:StackRep [True, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VEd: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8VI1; else goto c8VI0;
       c8VI1: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VI0: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8TYQ_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 24];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8TYs::I64 = I64[Sp + 40];
           I64[Hp - 16] = _s8TYs::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8TYs::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8TYQ_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.$wpeekCString_entry() //  [R2, R3]
         { info_tbl: [(c8VI5,
                       label: GHC.Foreign.$wpeekCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VI5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8VI6; else goto c8VI7;
       c8VI6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.$wpeekCString_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8VI7: // global
           _s8TYp::I64 = R3;
           _s8TYo::P64 = R2;
           _s8U0N::I64 = 0;
           goto c8VId;
       c8VId: // global
           if (I8[_s8TYp::I64 + _s8U0N::I64] == 0 :: W8) goto c8VIj; else goto c8VIi;
       c8VIj: // global
           I64[Sp - 24] = block_c8VDO_info;
           R1 = _s8TYo::P64;
           I64[Sp - 16] = _s8TYp::I64;
           I64[Sp - 8] = _s8U0N::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8VIm; else goto c8VDP;
       u8VIm: // global
           call _c8VDO(R1) args: 0, res: 0, upd: 0;
       c8VDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8VIi: // global
           _s8U0N::I64 = _s8U0N::I64 + 1;
           goto c8VId;
     }
 },
 _c8VDO() //  [R1]
         { info_tbl: [(c8VDO,
                       label: block_c8VDO_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VDO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8VIb; else goto c8VIa;
       c8VIb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VIa: // global
           _s8TYw::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8U0L_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8TYw::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.220061005 UTC

[section ""data" . GHC.Foreign.peekCString1_closure" {
     GHC.Foreign.peekCString1_closure:
         const GHC.Foreign.peekCString1_info;
         const 0;
 },
 GHC.Foreign.peekCString1_entry() //  [R2, R3]
         { info_tbl: [(c8VKI,
                       label: GHC.Foreign.peekCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VKI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8VKJ; else goto c8VKK;
       c8VKJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.peekCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8VKK: // global
           I64[Sp - 16] = block_c8VKF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8VKO; else goto c8VKG;
       u8VKO: // global
           call _c8VKF(R1) args: 0, res: 0, upd: 0;
       c8VKG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VKF() //  [R1]
         { info_tbl: [(c8VKF,
                       label: block_c8VKF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VKF: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.22582997 UTC

[section ""data" . GHC.Foreign.peekCString_closure" {
     GHC.Foreign.peekCString_closure:
         const GHC.Foreign.peekCString_info;
         const 0;
 },
 GHC.Foreign.peekCString_entry() //  [R2, R3]
         { info_tbl: [(c8VL2,
                       label: GHC.Foreign.peekCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VL2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.peekCString1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.229510559 UTC

[section ""data" . GHC.Foreign.charIsRepresentable2_closure" {
     GHC.Foreign.charIsRepresentable2_closure:
         const GHC.Foreign.charIsRepresentable2_info;
         const 0;
 },
 GHC.Foreign.charIsRepresentable2_entry() //  [R2]
         { info_tbl: [(c8VLg,
                       label: GHC.Foreign.charIsRepresentable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VLg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8VLk; else goto c8VLl;
       c8VLk: // global
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8VLl: // global
           I64[Sp - 8] = block_c8VLd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8VLD; else goto c8VLe;
       u8VLD: // global
           call _c8VLd(R1) args: 0, res: 0, upd: 0;
       c8VLe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VLd() //  [R1]
         { info_tbl: [(c8VLd,
                       label: block_c8VLd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VLd: // global
           I64[Sp - 8] = block_c8VLj_info;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8VLj() //  [R1]
         { info_tbl: [(c8VLj,
                       label: block_c8VLj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VLj: // global
           I64[Sp] = block_c8VLq_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8VLq() //  [R1]
         { info_tbl: [(c8VLq,
                       label: block_c8VLq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VLq: // global
           if (R1 & 7 == 1) goto c8VLx; else goto c8VLB;
       c8VLx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8VLB: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.23924796 UTC

[section ""data" . GHC.Foreign.charIsRepresentable1_closure" {
     GHC.Foreign.charIsRepresentable1_closure:
         const GHC.Foreign.charIsRepresentable1_info;
         const 0;
 },
 sat_s8U1w_entry() //  [R1, R2]
         { info_tbl: [(c8VMd,
                       label: sat_s8U1w_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VMd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8VMe; else goto c8VMf;
       c8VMe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8VMf: // global
           I64[Sp - 24] = block_c8VMa_info;
           _s8U17::P64 = P64[R1 + 6];
           _s8U19::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _s8U17::P64;
           P64[Sp - 8] = _s8U19::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8VN6; else goto c8VMb;
       u8VN6: // global
           call _c8VMa(R1) args: 0, res: 0, upd: 0;
       c8VMb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VMa() //  [R1]
         { info_tbl: [(c8VMa,
                       label: block_c8VMa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VMa: // global
           I64[Sp] = block_c8VMi_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8VMi() //  [R1]
         { info_tbl: [(c8VMi,
                       label: block_c8VMi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VMi: // global
           I64[Sp] = block_c8VMk_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8VN7; else goto c8VMn;
       u8VN7: // global
           call _c8VMk(R1) args: 0, res: 0, upd: 0;
       c8VMn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VMk() //  [R1]
         { info_tbl: [(c8VMk,
                       label: block_c8VMk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VMk: // global
           if (R1 & 7 == 1) goto u8VN3; else goto c8VMy;
       u8VN3: // global
           Sp = Sp + 24;
           call _c8VN0() args: 0, res: 0, upd: 0;
       c8VMy: // global
           I64[Sp] = block_c8VMw_info;
           _s8U1m::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp + 16] = _s8U1m::P64;
           if (R1 & 7 != 0) goto u8VN8; else goto c8VMz;
       u8VN8: // global
           call _c8VMw(R1) args: 0, res: 0, upd: 0;
       c8VMz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VMw() //  [R1]
         { info_tbl: [(c8VMw,
                       label: block_c8VMw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VMw: // global
           if (R1 & 7 == 1) goto c8VML; else goto u8VN4;
       c8VML: // global
           I64[Sp] = block_c8VMD_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8VNa; else goto c8VME;
       u8VNa: // global
           call _c8VMD(R1) args: 0, res: 0, upd: 0;
       c8VME: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8VN4: // global
           Sp = Sp + 24;
           call _c8VN0() args: 0, res: 0, upd: 0;
     }
 },
 _c8VMD() //  [R1]
         { info_tbl: [(c8VMD,
                       label: block_c8VMD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VMD: // global
           _s8U17::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8VMI_info;
           _s8U1q::I64 = I64[R1 + 7];
           R1 = _s8U17::P64;
           I64[Sp + 16] = _s8U1q::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8VNc; else goto c8VMN;
       u8VNc: // global
           call _c8VMI(R1) args: 0, res: 0, upd: 0;
       c8VMN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VMI() //  [R1]
         { info_tbl: [(c8VMI,
                       label: block_c8VMI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VMI: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c8VMW; else goto u8VN5;
       c8VMW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8VN5: // global
           Sp = Sp + 16;
           call _c8VN0() args: 0, res: 0, upd: 0;
     }
 },
 _c8VN0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VN0: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8U1x_entry() //  [R1]
         { info_tbl: [(c8VNk,
                       label: sat_s8U1x_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VNk: // global
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.charIsRepresentable1_entry() //  [R2, R3]
         { info_tbl: [(c8VNn,
                       label: GHC.Foreign.charIsRepresentable1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VNn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8VNo; else goto c8VNp;
       c8VNo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8VNp: // global
           I64[Sp - 16] = block_c8VM0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8VNt; else goto c8VM1;
       u8VNt: // global
           call _c8VM0(R1) args: 0, res: 0, upd: 0;
       c8VM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8VM0() //  [R1]
         { info_tbl: [(c8VM0,
                       label: block_c8VM0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VM0: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8VNs; else goto c8VNr;
       c8VNs: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8VNr: // global
           I64[Hp - 72] = sat_s8U1w_info;
           _s8U17::P64 = P64[Sp + 8];
           P64[Hp - 64] = _s8U17::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = _s8U17::P64;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           I64[Hp - 24] = sat_s8U1x_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 70;
           R2 = GHC.Foreign.charIsRepresentable2_closure+2;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.260957723 UTC

[section ""data" . GHC.Foreign.charIsRepresentable_closure" {
     GHC.Foreign.charIsRepresentable_closure:
         const GHC.Foreign.charIsRepresentable_info;
         const 0;
 },
 GHC.Foreign.charIsRepresentable_entry() //  [R2, R3]
         { info_tbl: [(c8VOm,
                       label: GHC.Foreign.charIsRepresentable_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8VOm: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:03.265026277 UTC

[section ""relreadonly" . S8U6c_srt" {
     S8U6c_srt:
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const $wpeekCStringLen_r8TNn_closure;
         const peekCStringLen1_r8TNo_closure;
         const Foreign.Marshal.Array.withArrayLen_closure;
         const GHC.Foreign.withCStringsLen1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const newEncodedCString1_r8TNq_closure;
         const GHC.Foreign.newCString1_closure;
         const GHC.Foreign.newEncodedCString_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.Foreign.peekCString1_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.Foreign.charIsRepresentable2_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.492119106 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:06.493685549 UTC

[section ""cstring" . GHC.Foreign.$trModule4_bytes" {
     GHC.Foreign.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.496421131 UTC

[section ""data" . GHC.Foreign.$trModule3_closure" {
     GHC.Foreign.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Foreign.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.498343542 UTC

[section ""cstring" . GHC.Foreign.$trModule2_bytes" {
     GHC.Foreign.$trModule2_bytes:
         I8[] [71,72,67,46,70,111,114,101,105,103,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.500106047 UTC

[section ""data" . GHC.Foreign.$trModule1_closure" {
     GHC.Foreign.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Foreign.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.502028978 UTC

[section ""data" . GHC.Foreign.$trModule_closure" {
     GHC.Foreign.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Foreign.$trModule3_closure+1;
         const GHC.Foreign.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.508040463 UTC

[section ""data" . $wpeekCStringLen_r8TNn_closure" {
     $wpeekCStringLen_r8TNn_closure:
         const $wpeekCStringLen_r8TNn_info;
         const 0;
 },
 sat_s8VPH_entry() //  [R1]
         { info_tbl: [(c8W4P,
                       label: sat_s8VPH_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W4P: // global
           _s8VPH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8W4Q; else goto c8W4R;
       c8W4R: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8W4T; else goto c8W4S;
       c8W4T: // global
           HpAlloc = 40;
           goto c8W4Q;
       c8W4Q: // global
           R1 = _s8VPH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8W4S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8VPH::P64;
           _s8VPw::P64 = P64[_s8VPH::P64 + 16];
           _s8VPE::P64 = P64[_s8VPH::P64 + 24];
           _s8VPA::I64 = I64[_s8VPH::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8VPA::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8VPw::P64;
           R3 = _s8VPE::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8VPY_entry() //  [R1]
         { info_tbl: [(c8W52,
                       label: sat_s8VPY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W52: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8W53; else goto c8W54;
       c8W53: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8W54: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8VOY_entry() //  [R1, R2]
         { info_tbl: [(c8W55,
                       label: $wgo_s8VOY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W55: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8W56; else goto c8W57;
       c8W56: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8W57: // global
           I64[Sp - 32] = block_c8W3u_info;
           _s8VOY::P64 = R1;
           _s8VOX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8VOX::P64;
           P64[Sp - 16] = _s8VOY::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8W6H; else goto c8W3v;
       u8W6H: // global
           call _c8W3u(R1) args: 0, res: 0, upd: 0;
       c8W3v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W3u() //  [R1]
         { info_tbl: [(c8W3u,
                       label: block_c8W3u_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W3u: // global
           _s8VOX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8W3z_info;
           R3 = _s8VOX::P64;
           R2 = P64[Sp + 24];
           _s8VP3::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8VP3::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W3z() //  [R1]
         { info_tbl: [(c8W3z,
                       label: block_c8W3z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W3z: // global
           I64[Sp] = block_c8W3B_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8W6z; else goto c8W3C;
       u8W6z: // global
           call _c8W3B(R1) args: 0, res: 0, upd: 0;
       c8W3C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W3B() //  [R1]
         { info_tbl: [(c8W3B,
                       label: block_c8W3B_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W3B: // global
           I64[Sp - 16] = block_c8W3G_info;
           _s8VPb::P64 = P64[R1 + 7];
           _s8VPd::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8VPd::P64;
           P64[Sp] = _s8VPb::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8W6A; else goto c8W3H;
       u8W6A: // global
           call _c8W3G(R1) args: 0, res: 0, upd: 0;
       c8W3H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W3G() //  [R1]
         { info_tbl: [(c8W3G,
                       label: block_c8W3G_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W3G: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8W62; else goto c8W5v;
       c8W62: // global
           I64[Sp + 32] = block_c8W4e_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8W6C; else goto c8W4f;
       u8W6C: // global
           call _c8W4e(R1) args: 0, res: 0, upd: 0;
       c8W4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8W5v: // global
           I64[Sp] = block_c8W5c_info;
           _s8VPe::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8VPe::P64;
           if (R1 & 7 != 0) goto u8W6B; else goto c8W5w;
       u8W6B: // global
           call _c8W5c(R1) args: 0, res: 0, upd: 0;
       c8W5w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W4e() //  [R1]
         { info_tbl: [(c8W4e,
                       label: block_c8W4e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W4e: // global
           _s8VQm::P64 = P64[R1 + 7];
           _s8VQr::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8VQr::I64, 0)) goto c8W6k; else goto c8W6l;
       c8W6k: // global
           P64[Sp - 24] = _s8VQm::P64;
           I64[Sp - 16] = _s8VQr::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8W4w() args: 0, res: 0, upd: 0;
       c8W6l: // global
           call MO_Touch(_s8VQm::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8W4w() //  []
         { info_tbl: [(c8W4w,
                       label: block_c8W4w_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W4w: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8W6f; else goto c8W6e;
       c8W6f: // global
           HpAlloc = 40;
           I64[Sp] = block_c8W4w_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8W6e: // global
           _s8VQE::P64 = P64[Sp + 24];
           _s8VQG::I64 = I64[Sp + 16];
           if (_s8VQG::I64 != 0) goto c8W6h; else goto c8W6i;
       c8W6h: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8VQG::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8VQE::P64;
           I64[Sp + 16] = _s8VQG::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8W4w() args: 0, res: 0, upd: 0;
       c8W6i: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8VQE::P64;
           Sp = Sp + 8;
           call _c8W65() args: 0, res: 0, upd: 0;
     }
 },
 _c8W65() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W65: // global
           Hp = Hp + 40;
           _s8VQu::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8W6c; else goto c8W6b;
       c8W6c: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8W64_info;
           R1 = _s8VQu::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8W6b: // global
           _s8VQy::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8VQy::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8VQu::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8W64() //  [R1]
         { info_tbl: [(c8W64,
                       label: block_c8W64_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W64: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8W65() args: 0, res: 0, upd: 0;
     }
 },
 _c8W5c() //  [R1]
         { info_tbl: [(c8W5c,
                       label: block_c8W5c_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W5c: // global
           _s8VPd::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8W5W; else goto c8W5K;
       c8W5W: // global
           I64[Sp + 8] = block_c8W5U_info;
           R1 = _s8VPd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8W6I; else goto c8W5X;
       u8W6I: // global
           call _c8W5U(R1) args: 0, res: 0, upd: 0;
       c8W5X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8W5K: // global
           _s8VPe::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8W5A_info;
           R3 = _s8VPd::P64;
           R2 = _s8VPe::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W5U() //  [R1]
         { info_tbl: [(c8W5U,
                       label: block_c8W5U_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W5U: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8VPm() args: 0, res: 0, upd: 0;
     }
 },
 _c8W5A() //  [R1]
         { info_tbl: [(c8W5A,
                       label: block_c8W5A_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W5A: // global
           I64[Sp] = block_c8W5C_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8W6J; else goto c8W5D;
       u8W6J: // global
           call _c8W5C(R1) args: 0, res: 0, upd: 0;
       c8W5D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W5C() //  [R1]
         { info_tbl: [(c8W5C,
                       label: block_c8W5C_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W5C: // global
           I64[Sp] = block_c8W5H_info;
           _s8VQ4::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8VQ4::P64;
           if (R1 & 7 != 0) goto u8W6K; else goto c8W5N;
       u8W6K: // global
           call _c8W5H(R1) args: 0, res: 0, upd: 0;
       c8W5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W5H() //  [R1]
         { info_tbl: [(c8W5H,
                       label: block_c8W5H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W5H: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8VPm() args: 0, res: 0, upd: 0;
     }
 },
 _s8VPm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8VPm: // global
           _s8VPt::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8VPt::I64, 0)) goto c8W5p; else goto c8W5q;
       c8W5p: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8VPt::I64 - 1;
           Sp = Sp - 8;
           call _c8W46() args: 0, res: 0, upd: 0;
       c8W5q: // global
           _s8VOY::P64 = P64[Sp + 32];
           _s8VPo::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8W4W_info;
           R2 = _s8VPo::P64;
           R1 = _s8VOY::P64;
           Sp = Sp + 40;
           call $wgo_s8VOY_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W46() //  []
         { info_tbl: [(c8W46,
                       label: block_c8W46_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W46: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8W5k; else goto c8W5j;
       c8W5k: // global
           HpAlloc = 40;
           I64[Sp] = block_c8W46_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8W5j: // global
           _s8VPp::I64 = I64[Sp + 32];
           _s8VPK::P64 = P64[Sp + 16];
           _s8VPM::I64 = I64[Sp + 24];
           if (_s8VPM::I64 != 0) goto c8W5m; else goto c8W5n;
       c8W5m: // global
           _s8VPP::I64 = %MO_UU_Conv_W32_W64(I32[_s8VPp::I64 + (_s8VPM::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8VPP::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8VPK::P64;
           I64[Sp + 24] = _s8VPM::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8W46() args: 0, res: 0, upd: 0;
       c8W5n: // global
           Hp = Hp - 40;
           _s8VOY::P64 = P64[Sp + 40];
           _s8VPo::P64 = P64[Sp + 48];
           _s8VPA::I64 = %MO_UU_Conv_W32_W64(I32[_s8VPp::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8W4H_info;
           R2 = _s8VPo::P64;
           R1 = _s8VOY::P64;
           I64[Sp + 40] = _s8VPA::I64;
           P64[Sp + 48] = _s8VPK::P64;
           Sp = Sp + 32;
           call $wgo_s8VOY_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W4H() //  [R1]
         { info_tbl: [(c8W4H,
                       label: block_c8W4H_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W4H: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8W5h; else goto c8W5g;
       c8W5h: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8W5g: // global
           I64[Hp - 32] = sat_s8VPH_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8W4W() //  [R1]
         { info_tbl: [(c8W4W,
                       label: block_c8W4W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W4W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8W5t; else goto c8W5s;
       c8W5t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8W5s: // global
           I64[Hp - 16] = sat_s8VPY_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8VQT_entry() //  [R1, R2]
         { info_tbl: [(c8W6P,
                       label: sat_s8VQT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W6P: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8W6Q; else goto c8W6R;
       c8W6Q: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8W6R: // global
           I64[Sp - 24] = block_c8W2T_info;
           _s8VOw::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8VOw::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8W7b; else goto c8W2U;
       u8W7b: // global
           call _c8W2T(R1) args: 0, res: 0, upd: 0;
       c8W2U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W2T() //  [R1]
         { info_tbl: [(c8W2T,
                       label: block_c8W2T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W2T: // global
           I64[Sp - 8] = block_c8W2Y_info;
           _s8VOF::I64 = I64[R1 + 7];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s8VOF::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W2Y() //  [R1]
         { info_tbl: [(c8W2Y,
                       label: block_c8W2Y_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W2Y: // global
           I64[Sp] = block_c8W30_info;
           _s8VOI::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8VOI::P64;
           if (R1 & 7 != 0) goto u8W7a; else goto c8W31;
       u8W7a: // global
           call _c8W30(R1) args: 0, res: 0, upd: 0;
       c8W31: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W30() //  [R1]
         { info_tbl: [(c8W30,
                       label: block_c8W30_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W30: // global
           _s8VOK::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s8VOK::I64, 1)) goto c8W78; else goto c8W79;
       c8W78: // global
           _s8VOM::I64 = _s8VOK::I64;
           goto s8VOL;
       c8W79: // global
           _s8VOM::I64 = 1;
           goto s8VOL;
       s8VOL: // global
           _s8VON::I64 = _s8VOM::I64 << 2;
           if (%MO_S_Ge_W64(_s8VON::I64, 0)) goto c8W6Z; else goto c8W74;
       c8W6Z: // global
           I64[Sp - 24] = block_c8W3g_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8VOM::I64;
           I64[Sp - 8] = _s8VON::I64;
           I64[Sp] = _s8VOK::I64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8W74: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8W3g() //  [R1]
         { info_tbl: [(c8W3g,
                       label: block_c8W3g_info
                       rep:StackRep [True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W3g: // global
           I64[Sp] = block_c8W3i_info;
           _s8VOR::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8VOR::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W3i() //  [R1]
         { info_tbl: [(c8W3i,
                       label: block_c8W3i_info
                       rep:StackRep [True, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W3i: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8W73; else goto c8W72;
       c8W73: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8W72: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8VOY_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 40];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8VOK::I64 = I64[Sp + 24];
           I64[Hp - 16] = _s8VOK::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8VOK::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8VOY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wpeekCStringLen_r8TNn_entry() //  [R2, R3, R4]
         { info_tbl: [(c8W7c,
                       label: $wpeekCStringLen_r8TNn_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W7c: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8W7d; else goto c8W7e;
       c8W7d: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wpeekCStringLen_r8TNn_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8W7e: // global
           I64[Sp - 24] = block_c8W2J_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8W7i; else goto c8W2K;
       u8W7i: // global
           call _c8W2J(R1) args: 0, res: 0, upd: 0;
       c8W2K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8W2J() //  [R1]
         { info_tbl: [(c8W2J,
                       label: block_c8W2J_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8W2J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8W7h; else goto c8W7g;
       c8W7h: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8W7g: // global
           _s8VOA::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8VQT_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8VOA::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.563002256 UTC

[section ""data" . peekCStringLen1_r8TNo_closure" {
     peekCStringLen1_r8TNo_closure:
         const peekCStringLen1_r8TNo_info;
         const 0;
 },
 peekCStringLen1_r8TNo_entry() //  [R2, R3]
         { info_tbl: [(c8WaD,
                       label: peekCStringLen1_r8TNo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WaD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8WaE; else goto c8WaF;
       c8WaE: // global
           R3 = R3;
           R2 = R2;
           R1 = peekCStringLen1_r8TNo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8WaF: // global
           I64[Sp - 16] = block_c8WaA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8WaJ; else goto c8WaB;
       u8WaJ: // global
           call _c8WaA(R1) args: 0, res: 0, upd: 0;
       c8WaB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WaA() //  [R1]
         { info_tbl: [(c8WaA,
                       label: block_c8WaA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WaA: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call $wpeekCStringLen_r8TNn_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.568556969 UTC

[section ""data" . GHC.Foreign.peekCStringLen_closure" {
     GHC.Foreign.peekCStringLen_closure:
         const GHC.Foreign.peekCStringLen_info;
         const 0;
 },
 GHC.Foreign.peekCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8WaY,
                       label: GHC.Foreign.peekCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WaY: // global
           R3 = R3;
           R2 = R2;
           call peekCStringLen1_r8TNo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.57439132 UTC

[section ""data" . GHC.Foreign.$wtryFillBufferAndCall_closure" {
     GHC.Foreign.$wtryFillBufferAndCall_closure:
         const GHC.Foreign.$wtryFillBufferAndCall_info;
 },
 GHC.Foreign.$wtryFillBufferAndCall_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wb6: // global
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8VSi_entry() //  [R1]
         { info_tbl: [(c8Wbj,
                       label: sat_s8VSi_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wbj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Wbo; else goto c8Wbp;
       c8Wbo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Wbp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8Wbg_info;
           _s8VRa::P64 = P64[R1 + 24];
           _s8VR4::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8VR4::I64;
           P64[Sp - 24] = _s8VRa::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Wbt; else goto c8Wbh;
       u8Wbt: // global
           call _c8Wbg(R1) args: 0, res: 0, upd: 0;
       c8Wbh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Wbg() //  [R1]
         { info_tbl: [(c8Wbg,
                       label: block_c8Wbg_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wbg: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Wbs; else goto c8Wbr;
       c8Wbs: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Wbr: // global
           _s8VSg::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8VSg::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Foreign.$wtryFillBufferAndCall_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8Wby,
                       label: GHC.Foreign.$wtryFillBufferAndCall_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, True, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wby: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8Wbz; else goto c8WbA;
       c8Wbz: // global
           R1 = GHC.Foreign.$wtryFillBufferAndCall_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       c8WbA: // global
           I64[Sp - 48] = block_c8Wba_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = R6;
           Sp = Sp - 48;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wba() //  [R1]
         { info_tbl: [(c8Wba,
                       label: block_c8Wba_info
                       rep:StackRep [False, False, False, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wba: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8WbD; else goto c8WbC;
       c8WbD: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WbC: // global
           I64[Hp - 32] = sat_s8VSi_info;
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 40];
           P64[Sp + 40] = Hp - 32;
           P64[Sp + 48] = P64[Sp + 32];
           Sp = Sp + 8;
           call _c8Wd8() args: 0, res: 0, upd: 0;
     }
 },
 _c8Wd8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wd8: // global
           I64[Sp - 8] = block_c8Wda_info;
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 40];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wda() //  [R1]
         { info_tbl: [(c8Wda,
                       label: block_c8Wda_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wda: // global
           I64[Sp] = block_c8Wdc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8We6; else goto c8Wdd;
       u8We6: // global
           call _c8Wdc(R1) args: 0, res: 0, upd: 0;
       c8Wdd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wdc() //  [R1]
         { info_tbl: [(c8Wdc,
                       label: block_c8Wdc_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wdc: // global
           I64[Sp] = block_c8Wdh_info;
           _s8VRX::P64 = P64[R1 + 7];
           _s8VRZ::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp + 40] = _s8VRZ::P64;
           P64[Sp + 48] = _s8VRX::P64;
           if (R1 & 7 != 0) goto u8We7; else goto c8Wdl;
       u8We7: // global
           call _c8Wdh(R1) args: 0, res: 0, upd: 0;
       c8Wdl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wdh() //  [R1]
         { info_tbl: [(c8Wdh,
                       label: block_c8Wdh_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wdh: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8WdQ; else goto c8Wdv;
       c8WdQ: // global
           I64[Sp + 16] = block_c8WbJ_info;
           R1 = P64[Sp + 24];
           P64[Sp + 48] = P64[Sp + 40];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u8We9; else goto c8WcB;
       u8We9: // global
           call _c8WbJ(R1) args: 0, res: 0, upd: 0;
       c8WcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Wdv: // global
           I64[Sp] = block_c8Wdt_info;
           _s8VS0::P64 = R1;
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _s8VS0::P64;
           if (R1 & 7 != 0) goto u8We8; else goto c8Wdw;
       u8We8: // global
           call _c8Wdt(R1) args: 0, res: 0, upd: 0;
       c8Wdw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WbJ() //  [R1]
         { info_tbl: [(c8WbJ,
                       label: block_c8WbJ_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WbJ: // global
           if (R1 & 7 == 1) goto u8WdX; else goto c8WcM;
       u8WdX: // global
           Sp = Sp + 8;
           call _s8VRe() args: 0, res: 0, upd: 0;
       c8WcM: // global
           I64[Sp] = block_c8WcK_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u8We1; else goto c8WcN;
       u8We1: // global
           call _c8WcK(R1) args: 0, res: 0, upd: 0;
       c8WcN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WcK() //  [R1]
         { info_tbl: [(c8WcK,
                       label: block_c8WcK_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WcK: // global
           if (I64[R1 + 31] - I64[R1 + 47] == 0) goto u8WdY; else goto u8WdZ;
       u8WdY: // global
           Sp = Sp + 48;
           call _c8Wd3() args: 0, res: 0, upd: 0;
       u8WdZ: // global
           Sp = Sp + 8;
           call _s8VRe() args: 0, res: 0, upd: 0;
     }
 },
 _s8VRe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8VRe: // global
           I64[Sp - 8] = block_c8WbO_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Wed; else goto c8WbQ;
       u8Wed: // global
           call _c8WbO(R1) args: 0, res: 0, upd: 0;
       c8WbQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WbO() //  [R1]
         { info_tbl: [(c8WbO,
                       label: block_c8WbO_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WbO: // global
           I64[Sp] = block_c8WbU_info;
           _s8VRh::P64 = P64[R1 + 7];
           _s8VRg::I64 = I64[R1 + 23];
           _s8VRk::I64 = I64[R1 + 39];
           _s8VRl::I64 = I64[R1 + 47];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8VRl::I64;
           I64[Sp + 16] = _s8VRk::I64;
           P64[Sp + 24] = _s8VRh::P64;
           I64[Sp + 32] = _s8VRg::I64;
           if (R1 & 7 != 0) goto u8We3; else goto c8WbW;
       u8We3: // global
           call _c8WbU(R1) args: 0, res: 0, upd: 0;
       c8WbW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WbU() //  [R1]
         { info_tbl: [(c8WbU,
                       label: block_c8WbU_info
                       rep:StackRep [True, True, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WbU: // global
           _s8VR6::P64 = P64[Sp + 40];
           _s8VRg::I64 = I64[Sp + 32];
           _s8VRk::I64 = I64[Sp + 16];
           _s8VRl::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c8Wcb; else goto c8Wcu;
       c8Wcb: // global
           Hp = Hp + 56;
           _s8VRm::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8Wcx; else goto c8Wcd;
       c8Wcd: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s8VRl::I64 - _s8VRk::I64;
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = _s8VRg::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8Wc6_info;
           R2 = Hp - 15;
           R1 = _s8VR6::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       c8Wcu: // global
           Hp = Hp + 56;
           _s8VRm::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c8Wcx; else goto c8Wcw;
       c8Wcx: // global
           HpAlloc = 56;
           R1 = _s8VRm::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Wcw: // global
           I8[_s8VRg::I64 + _s8VRl::I64] = 0 :: W8;
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s8VRl::I64 - _s8VRk::I64;
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = _s8VRg::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8Wcq_info;
           R2 = Hp - 15;
           R1 = _s8VR6::P64;
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wc6() //  [R1]
         { info_tbl: [(c8Wc6,
                       label: block_c8Wc6_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wc6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Wch; else goto c8Wcg;
       c8Wch: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Wcg: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Wcq() //  [R1]
         { info_tbl: [(c8Wcq,
                       label: block_c8Wcq_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wcq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8WcA; else goto c8Wcz;
       c8WcA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Wcz: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Wdt() //  [R1]
         { info_tbl: [(c8Wdt,
                       label: block_c8Wdt_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wdt: // global
           if (R1 & 7 == 2) goto u8WdV; else goto c8WdF;
       u8WdV: // global
           Sp = Sp + 64;
           call _c8Wd3() args: 0, res: 0, upd: 0;
       c8WdF: // global
           I64[Sp] = block_c8WdA_info;
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 16];
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wd3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wd3: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8WdA() //  [R1]
         { info_tbl: [(c8WdA,
                       label: block_c8WdA_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WdA: // global
           I64[Sp] = block_c8WdC_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Web; else goto c8WdH;
       u8Web: // global
           call _c8WdC(R1) args: 0, res: 0, upd: 0;
       c8WdH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WdC() //  [R1]
         { info_tbl: [(c8WdC,
                       label: block_c8WdC_info
                       rep:StackRep [False, False, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WdC: // global
           P64[Sp + 48] = P64[R1 + 7];
           P64[Sp + 40] = P64[R1 + 15];
           Sp = Sp + 8;
           call _c8Wd8() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.611258664 UTC

[section ""data" . GHC.Foreign.newCStringLen1_closure" {
     GHC.Foreign.newCStringLen1_closure:
         const GHC.Foreign.newCStringLen1_info;
 },
 GHC.Foreign.newCStringLen1_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c8Wgr,
                       label: GHC.Foreign.newCStringLen1_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wgr: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8Wgv; else goto c8Wgw;
       c8Wgv: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.newCStringLen1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       c8Wgw: // global
           I64[Sp - 40] = block_c8Wgo_info;
           R1 = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8WgE; else goto c8Wgp;
       u8WgE: // global
           call _c8Wgo(R1) args: 0, res: 0, upd: 0;
       c8Wgp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wgo() //  [R1]
         { info_tbl: [(c8Wgo,
                       label: block_c8Wgo_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wgo: // global
           I64[Sp - 8] = block_c8Wgu_info;
           _s8VSr::P64 = P64[R1 + 7];
           _s8VSs::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8VSs::P64;
           P64[Sp + 24] = _s8VSr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8WgD; else goto c8Wgy;
       u8WgD: // global
           call _c8Wgu(R1) args: 0, res: 0, upd: 0;
       c8Wgy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wgu() //  [R1]
         { info_tbl: [(c8Wgu,
                       label: block_c8Wgu_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wgu: // global
           R6 = I64[R1 + 7];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 40;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.621633901 UTC

[section ""data" . withEncodedCString1_r8TNp_closure" {
     withEncodedCString1_r8TNp_closure:
         const withEncodedCString1_r8TNp_info;
 },
 $wgo_s8VSZ_entry() //  [R1, R2]
         { info_tbl: [(c8WhD,
                       label: $wgo_s8VSZ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WhD: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8WhE; else goto c8WhF;
       c8WhE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8WhF: // global
           I64[Sp - 56] = block_c8Why_info;
           _s8VSZ::P64 = R1;
           _s8VSz::P64 = P64[R1 + 6];
           _s8VSB::P64 = P64[R1 + 14];
           _s8VSH::P64 = P64[R1 + 22];
           _s8VSY::P64 = P64[R1 + 30];
           R1 = R2;
           P64[Sp - 48] = _s8VSz::P64;
           P64[Sp - 40] = _s8VSB::P64;
           P64[Sp - 32] = _s8VSH::P64;
           P64[Sp - 24] = _s8VSY::P64;
           P64[Sp - 16] = _s8VSZ::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 56;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Why() //  [R1]
         { info_tbl: [(c8Why,
                       label: block_c8Why_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Why: // global
           I64[Sp] = block_c8WhA_info;
           _s8VT7::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s8VT7::P64;
           if (R1 & 7 != 0) goto u8Wie; else goto c8WhB;
       u8Wie: // global
           call _c8WhA(R1) args: 0, res: 0, upd: 0;
       c8WhB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WhA() //  [R1]
         { info_tbl: [(c8WhA,
                       label: block_c8WhA_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WhA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8WhL; else goto c8WhK;
       c8WhL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WhK: // global
           _s8VT9::P64 = P64[R1 + 7];
           _s8VTa::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 48];
           _s8VSB::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8WhQ_info;
           R6 = P64[Sp + 24] + 16;
           R5 = P64[Sp + 32];
           R4 = P64[Sp + 8];
           R3 = _s8VTa::P64;
           R2 = _s8VT9::P64;
           P64[Sp] = Hp - 7;
           P64[Sp + 8] = _s8VSB::P64;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8WhQ() //  [R1]
         { info_tbl: [(c8WhQ,
                       label: block_c8WhQ_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WhQ: // global
           I64[Sp] = block_c8WhS_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Wif; else goto c8WhU;
       u8Wif: // global
           call _c8WhS(R1) args: 0, res: 0, upd: 0;
       c8WhU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WhS() //  [R1]
         { info_tbl: [(c8WhS,
                       label: block_c8WhS_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WhS: // global
           if (R1 & 7 == 1) goto c8Wi4; else goto c8Wia;
       c8Wi4: // global
           I64[Sp] = block_c8Wi2_info;
           R2 = I64[Sp + 32] << 1;
           R1 = P64[Sp + 24];
           call $wgo_s8VSZ_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8Wia: // global
           _s8VTp::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 8]);
           R1 = _s8VTp::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Wi2() //  [R1]
         { info_tbl: [(c8Wi2,
                       label: block_c8Wi2_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wi2: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8VTH_entry() //  [R1, R2]
         { info_tbl: [(c8Wig,
                       label: sat_s8VTH_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wig: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8Wih; else goto c8Wii;
       c8Wih: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Wii: // global
           I64[Sp - 40] = block_c8Wh8_info;
           R3 = 0;
           _s8VSH::P64 = R2;
           _s8VSA::P64 = P64[R1 + 14];
           R2 = _s8VSA::P64;
           P64[Sp - 32] = P64[R1 + 6];
           P64[Sp - 24] = _s8VSA::P64;
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _s8VSH::P64;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wh8() //  [R1]
         { info_tbl: [(c8Wh8,
                       label: block_c8Wh8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wh8: // global
           I64[Sp - 8] = block_c8Whf_info;
           R2 = 4;
           _s8VSJ::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8VSJ::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Whf() //  [R1]
         { info_tbl: [(c8Whf,
                       label: block_c8Whf_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Whf: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c8Wix() args: 0, res: 0, upd: 0;
     }
 },
 _c8Wix() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wix: // global
           _s8VTx::P64 = P64[Sp];
           I64[Sp] = block_c8WiA_info;
           R1 = _s8VTx::P64;
           if (R1 & 7 != 0) goto u8WiZ; else goto c8WiC;
       u8WiZ: // global
           call _c8WiA(R1) args: 0, res: 0, upd: 0;
       c8WiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WiA() //  [R1]
         { info_tbl: [(c8WiA,
                       label: block_c8WiA_info
                       rep:StackRep [True, True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WiA: // global
           if (R1 & 7 == 1) goto c8WiI; else goto c8WiN;
       c8WiI: // global
           I64[Sp + 8] = block_c8Whp_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8WiN: // global
           I64[Sp - 8] = block_c8WiL_info;
           _s8VTC::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8VTC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Wj0; else goto c8WiO;
       u8Wj0: // global
           call _c8WiL(R1) args: 0, res: 0, upd: 0;
       c8WiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Whp() //  [R1]
         { info_tbl: [(c8Whp,
                       label: block_c8Whp_info
                       rep:StackRep [True, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Whp: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c8Wio; else goto c8Win;
       c8Wio: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Win: // global
           I64[Hp - 104] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 96] = R1;
           I64[Hp - 88] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 80] = Hp - 103;
           P64[Hp - 72] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 64] = I64[Sp + 8];
           _s8VSJ::I64 = I64[Sp + 16];
           I64[Hp - 56] = _s8VSJ::I64;
           I64[Hp - 48] = 0;
           I64[Hp - 40] = _s8VSJ::I64;
           I64[Hp - 32] = $wgo_s8VSZ_info;
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = Hp - 87;
           I64[Sp + 24] = block_c8Wis_info;
           R2 = _s8VSJ::I64 + 1;
           R1 = Hp - 30;
           Sp = Sp + 24;
           call $wgo_s8VSZ_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wis() //  [R1]
         { info_tbl: [(c8Wis,
                       label: block_c8Wis_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wis: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8WiL() //  [R1]
         { info_tbl: [(c8WiL,
                       label: block_c8WiL_info
                       rep:StackRep [False, True, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WiL: // global
           _s8VTy::I64 = I64[Sp + 16];
           _s8VTC::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8VTy::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8VTC::P64;
           I64[Sp + 16] = _s8VTy::I64 + 1;
           Sp = Sp + 8;
           call _c8Wix() args: 0, res: 0, upd: 0;
     }
 },
 withEncodedCString1_r8TNp_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Wj2,
                       label: withEncodedCString1_r8TNp_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wj2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Wj3; else goto c8Wj4;
       c8Wj3: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = withEncodedCString1_r8TNp_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Wj4: // global
           I64[Sp - 32] = block_c8WgY_info;
           R1 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Wj8; else goto c8WgZ;
       u8Wj8: // global
           call _c8WgY(R1) args: 0, res: 0, upd: 0;
       c8WgZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WgY() //  [R1]
         { info_tbl: [(c8WgY,
                       label: block_c8WgY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WgY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Wj7; else goto c8Wj6;
       c8Wj7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Wj6: // global
           _s8VSG::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_s8VTH_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R4 = Hp - 22;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8VSG::P64;
           Sp = Sp + 32;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.652052556 UTC

[section ""data" . GHC.Foreign.withEncodedCString_closure" {
     GHC.Foreign.withEncodedCString_closure:
         const GHC.Foreign.withEncodedCString_info;
 },
 GHC.Foreign.withEncodedCString_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8WkS,
                       label: GHC.Foreign.withEncodedCString_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WkS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call withEncodedCString1_r8TNp_entry(R5,
                                                R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.658356259 UTC

[section ""data" . GHC.Foreign.charIsRepresentable3_closure" {
     GHC.Foreign.charIsRepresentable3_closure:
         const GHC.Foreign.charIsRepresentable3_info;
 },
 $wgo_s8VU8_entry() //  [R1, R2]
         { info_tbl: [(c8WlM,
                       label: $wgo_s8VU8_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WlM: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8WlN; else goto c8WlO;
       c8WlN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8WlO: // global
           I64[Sp - 48] = block_c8WlD_info;
           _s8VU8::P64 = R1;
           _s8VTK::P64 = P64[R1 + 6];
           _s8VTQ::P64 = P64[R1 + 14];
           _s8VU7::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _s8VTK::P64;
           P64[Sp - 32] = _s8VTQ::P64;
           P64[Sp - 24] = _s8VU7::P64;
           P64[Sp - 16] = _s8VU8::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 48;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WlD() //  [R1]
         { info_tbl: [(c8WlD,
                       label: block_c8WlD_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WlD: // global
           I64[Sp - 8] = block_c8WlF_info;
           _s8VUg::P64 = R1;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp] = _s8VUg::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WlF() //  [R1]
         { info_tbl: [(c8WlF,
                       label: block_c8WlF_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WlF: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8WlS; else goto c8WlR;
       c8WlS: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WlR: // global
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 24] = P64[Sp + 8] + 16;
           I64[Hp - 16] = I64[Sp + 48];
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           P64[Sp] = Hp - 47;
           P64[Sp + 32] = P64[Sp + 32];
           call _c8WmL() args: 0, res: 0, upd: 0;
     }
 },
 _c8WmL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WmL: // global
           I64[Sp - 8] = block_c8WmN_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8WnM; else goto c8WmO;
       u8WnM: // global
           call _c8WmN(R1) args: 0, res: 0, upd: 0;
       c8WmO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WmN() //  [R1]
         { info_tbl: [(c8WmN,
                       label: block_c8WmN_info
                       rep:StackRep [False, False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WmN: // global
           _s8VUQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8WmS_info;
           R3 = _s8VUQ::P64;
           R2 = P64[Sp + 40];
           _s8VUU::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 40] = _s8VUU::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WmS() //  [R1]
         { info_tbl: [(c8WmS,
                       label: block_c8WmS_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WmS: // global
           I64[Sp] = block_c8WmU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8WnN; else goto c8WmV;
       u8WnN: // global
           call _c8WmU(R1) args: 0, res: 0, upd: 0;
       c8WmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WmU() //  [R1]
         { info_tbl: [(c8WmU,
                       label: block_c8WmU_info
                       rep:StackRep [False, False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WmU: // global
           I64[Sp - 16] = block_c8WmZ_info;
           _s8VV2::P64 = P64[R1 + 7];
           _s8VV4::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8VV4::P64;
           P64[Sp] = _s8VV2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8WnO; else goto c8Wn4;
       u8WnO: // global
           call _c8WmZ(R1) args: 0, res: 0, upd: 0;
       c8Wn4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WmZ() //  [R1]
         { info_tbl: [(c8WmZ,
                       label: block_c8WmZ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WmZ: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8Wnz; else goto c8Wne;
       c8Wnz: // global
           I64[Sp + 16] = block_c8Wma_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u8WnQ; else goto c8Wmc;
       u8WnQ: // global
           call _c8Wma(R1) args: 0, res: 0, upd: 0;
       c8Wmc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Wne: // global
           I64[Sp] = block_c8Wnc_info;
           _s8VV5::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8VV5::P64;
           if (R1 & 7 != 0) goto u8WnP; else goto c8Wnf;
       u8WnP: // global
           call _c8Wnc(R1) args: 0, res: 0, upd: 0;
       c8Wnf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wma() //  [R1]
         { info_tbl: [(c8Wma,
                       label: block_c8Wma_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wma: // global
           _s8VUA::I64 = I64[R1 + 47];
           _s8VUB::I64 = I64[R1 + 31] - _s8VUA::I64;
           if (_s8VUB::I64 != 0) goto u8WnH; else goto c8Wmy;
       u8WnH: // global
           I64[Sp + 24] = _s8VUB::I64;
           I64[Sp + 32] = _s8VUA::I64;
           P64[Sp + 40] = P64[R1 + 7];
           I64[Sp + 48] = I64[R1 + 23];
           Sp = Sp + 8;
           call _c8Wml() args: 0, res: 0, upd: 0;
       c8Wmy: // global
           I64[Sp] = block_c8WmF_info;
           R2 = I64[Sp + 48] << 1;
           R1 = P64[Sp + 40];
           call $wgo_s8VU8_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wml() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wml: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Wmt; else goto c8Wms;
       c8Wmt: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8Wmk_info;
           R1 = I64[Sp + 16];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Wms: // global
           _s8VTK::P64 = P64[Sp + 8];
           _s8VUv::I64 = I64[Sp + 40];
           I8[_s8VUv::I64 + I64[Sp + 24]] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8VUv::I64;
           I64[Sp - 8] = block_c8Wmo_info;
           R2 = Hp - 7;
           R1 = _s8VTK::P64;
           Sp = Sp - 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wmk() //  [R1]
         { info_tbl: [(c8Wmk,
                       label: block_c8Wmk_info
                       rep:StackRep [False, False, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wmk: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8Wml() args: 0, res: 0, upd: 0;
     }
 },
 _c8Wmo() //  [R1]
         { info_tbl: [(c8Wmo,
                       label: block_c8Wmo_info
                       rep:StackRep [False, True, True, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wmo: // global
           _s8VUg::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 40]);
           call MO_Touch(_s8VUg::P64);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8WmF() //  [R1]
         { info_tbl: [(c8WmF,
                       label: block_c8WmF_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WmF: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Wnc() //  [R1]
         { info_tbl: [(c8Wnc,
                       label: block_c8Wnc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wnc: // global
           if (R1 & 7 == 2) goto c8Wny; else goto c8Wno;
       c8Wny: // global
           I64[Sp + 16] = block_c8Wm2_info;
           R2 = I64[Sp + 64] << 1;
           R1 = P64[Sp + 56];
           Sp = Sp + 16;
           call $wgo_s8VU8_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8Wno: // global
           _s8VV5::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8Wnj_info;
           R3 = P64[Sp + 8];
           R2 = _s8VV5::P64;
           R1 = P64[Sp + 48];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wm2() //  [R1]
         { info_tbl: [(c8Wm2,
                       label: block_c8Wm2_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wm2: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Wnj() //  [R1]
         { info_tbl: [(c8Wnj,
                       label: block_c8Wnj_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wnj: // global
           I64[Sp] = block_c8Wnl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8WnR; else goto c8Wnq;
       u8WnR: // global
           call _c8Wnl(R1) args: 0, res: 0, upd: 0;
       c8Wnq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wnl() //  [R1]
         { info_tbl: [(c8Wnl,
                       label: block_c8Wnl_info
                       rep:StackRep [False, False, False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wnl: // global
           P64[Sp + 32] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           call _c8WmL() args: 0, res: 0, upd: 0;
     }
 },
 sat_s8VVD_entry() //  [R1, R2]
         { info_tbl: [(c8WnT,
                       label: sat_s8VVD_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WnT: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8WnU; else goto c8WnV;
       c8WnU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8WnV: // global
           I64[Sp - 32] = block_c8Wld_info;
           R3 = 0;
           _s8VTQ::P64 = R2;
           _s8VTJ::P64 = P64[R1 + 6];
           R2 = _s8VTJ::P64;
           P64[Sp - 24] = _s8VTJ::P64;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = _s8VTQ::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wld() //  [R1]
         { info_tbl: [(c8Wld,
                       label: block_c8Wld_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wld: // global
           I64[Sp - 8] = block_c8Wlk_info;
           R2 = 4;
           _s8VTS::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8VTS::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wlk() //  [R1]
         { info_tbl: [(c8Wlk,
                       label: block_c8Wlk_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wlk: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8Woa() args: 0, res: 0, upd: 0;
     }
 },
 _c8Woa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Woa: // global
           _s8VVt::P64 = P64[Sp];
           I64[Sp] = block_c8Wod_info;
           R1 = _s8VVt::P64;
           if (R1 & 7 != 0) goto u8WoC; else goto c8Wof;
       u8WoC: // global
           call _c8Wod(R1) args: 0, res: 0, upd: 0;
       c8Wof: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wod() //  [R1]
         { info_tbl: [(c8Wod,
                       label: block_c8Wod_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wod: // global
           if (R1 & 7 == 1) goto c8Wol; else goto c8Woq;
       c8Wol: // global
           I64[Sp + 8] = block_c8Wlu_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8Woq: // global
           I64[Sp - 8] = block_c8Woo_info;
           _s8VVy::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8VVy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8WoD; else goto c8Wor;
       u8WoD: // global
           call _c8Woo(R1) args: 0, res: 0, upd: 0;
       c8Wor: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wlu() //  [R1]
         { info_tbl: [(c8Wlu,
                       label: block_c8Wlu_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wlu: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c8Wo1; else goto c8Wo0;
       c8Wo1: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Wo0: // global
           I64[Hp - 96] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = Hp - 95;
           P64[Hp - 64] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 56] = I64[Sp + 8];
           _s8VTS::I64 = I64[Sp + 16];
           I64[Hp - 48] = _s8VTS::I64;
           I64[Hp - 40] = 0;
           I64[Hp - 32] = _s8VTS::I64;
           I64[Hp - 24] = $wgo_s8VU8_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 79;
           I64[Sp + 16] = block_c8Wo5_info;
           R2 = _s8VTS::I64 + 1;
           R1 = Hp - 22;
           Sp = Sp + 16;
           call $wgo_s8VU8_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wo5() //  [R1]
         { info_tbl: [(c8Wo5,
                       label: block_c8Wo5_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wo5: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Woo() //  [R1]
         { info_tbl: [(c8Woo,
                       label: block_c8Woo_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Woo: // global
           _s8VVu::I64 = I64[Sp + 16];
           _s8VVy::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8VVu::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8VVy::P64;
           I64[Sp + 16] = _s8VVu::I64 + 1;
           Sp = Sp + 8;
           call _c8Woa() args: 0, res: 0, upd: 0;
     }
 },
 GHC.Foreign.charIsRepresentable3_entry() //  [R2, R3, R4]
         { info_tbl: [(c8WoF,
                       label: GHC.Foreign.charIsRepresentable3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WoF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8WoG; else goto c8WoH;
       c8WoG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8WoH: // global
           I64[Sp - 24] = block_c8Wl3_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8WoL; else goto c8Wl4;
       u8WoL: // global
           call _c8Wl3(R1) args: 0, res: 0, upd: 0;
       c8Wl4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wl3() //  [R1]
         { info_tbl: [(c8Wl3,
                       label: block_c8Wl3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wl3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8WoK; else goto c8WoJ;
       c8WoK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WoJ: // global
           _s8VTP::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8VVD_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8VTP::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.707344173 UTC

[section ""data" . GHC.Foreign.withCString_closure" {
     GHC.Foreign.withCString_closure:
         const GHC.Foreign.withCString_info;
 },
 GHC.Foreign.withCString_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Wrq,
                       label: GHC.Foreign.withCString_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wrq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.711877603 UTC

[section ""data" . GHC.Foreign.withCStringsLen1_closure" {
     GHC.Foreign.withCStringsLen1_closure:
         const GHC.Foreign.withCStringsLen1_info;
         const 0;
 },
 sat_s8VVN_entry() //  [R1]
         { info_tbl: [(c8WrP,
                       label: sat_s8VVN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WrP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8WrQ; else goto c8WrR;
       c8WrQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8WrR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8VVT_entry() //  [R1, R2]
         { info_tbl: [(c8Ws0,
                       label: sat_s8VVT_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ws0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Ws4; else goto c8Ws3;
       c8Ws4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Ws3: // global
           _s8VVI::P64 = P64[R1 + 6];
           _s8VVJ::P64 = P64[R1 + 14];
           _s8VVP::P64 = P64[R1 + 22];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = _s8VVJ::P64;
           R3 = _s8VVP::P64;
           R2 = Hp - 14;
           R1 = _s8VVI::P64;
           call go_s8VVI_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_s8VVI_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Ws9,
                       label: go_s8VVI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ws9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Wsa; else goto c8Wsb;
       c8Wsa: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Wsb: // global
           I64[Sp - 40] = block_c8WrG_info;
           _s8VVI::P64 = R1;
           _s8VVE::P64 = P64[R1 + 5];
           _s8VVG::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 32] = _s8VVE::P64;
           P64[Sp - 24] = _s8VVG::P64;
           P64[Sp - 16] = _s8VVI::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Wsi; else goto c8WrH;
       u8Wsi: // global
           call _c8WrG(R1) args: 0, res: 0, upd: 0;
       c8WrH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WrG() //  [R1]
         { info_tbl: [(c8WrG,
                       label: block_c8WrG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WrG: // global
           _s8VVJ::P64 = P64[Sp + 32];
           if (R1 & 7 == 1) goto c8Ws6; else goto c8Ws7;
       c8Ws6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Wse; else goto c8Wsd;
       c8Wse: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Wsd: // global
           I64[Hp - 16] = sat_s8VVN_info;
           P64[Hp] = _s8VVJ::P64;
           R4 = P64[Sp + 16];
           R3 = Hp - 16;
           R2 = Foreign.Storable.$fStorablePtr_closure;
           I64[Sp + 32] = stg_ap_v_info;
           Sp = Sp + 32;
           call Foreign.Marshal.Array.withArrayLen_entry(R4,
                                                         R3,
                                                         R2) args: 16, res: 0, upd: 8;
       c8Ws7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Wsh; else goto c8Wsg;
       c8Wsh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Wsg: // global
           _s8VVO::P64 = P64[R1 + 6];
           _s8VVP::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s8VVT_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _s8VVJ::P64;
           P64[Hp] = _s8VVP::P64;
           R4 = Hp - 22;
           R3 = _s8VVO::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 40;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.withCStringsLen1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Wsj,
                       label: GHC.Foreign.withCStringsLen1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wsj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Wsn; else goto c8Wsm;
       c8Wsn: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.withCStringsLen1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Wsm: // global
           I64[Hp - 16] = go_s8VVI_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R3 = R3;
           R2 = GHC.Types.[]_closure+1;
           R1 = Hp - 13;
           call go_s8VVI_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.724892229 UTC

[section ""data" . GHC.Foreign.withCStringsLen_closure" {
     GHC.Foreign.withCStringsLen_closure:
         const GHC.Foreign.withCStringsLen_info;
         const 0;
 },
 GHC.Foreign.withCStringsLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8WsW,
                       label: GHC.Foreign.withCStringsLen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WsW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.728280939 UTC

[section ""data" . GHC.Foreign.withCStringLen_closure" {
     GHC.Foreign.withCStringLen_closure:
         const GHC.Foreign.withCStringLen_info;
 },
 GHC.Foreign.withCStringLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Wt7,
                       label: GHC.Foreign.withCStringLen_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wt7: // global
           R5 = R4;
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call GHC.Foreign.withEncodedCString_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.731713605 UTC

[section ""data" . GHC.Foreign.newCString2_closure" {
     GHC.Foreign.newCString2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.735739486 UTC

[section ""data" . newEncodedCString1_r8TNq_closure" {
     newEncodedCString1_r8TNq_closure:
         const newEncodedCString1_r8TNq_info;
         const 0;
 },
 sat_s8VXc_entry() //  [R1, R2]
         { info_tbl: [(c8WuF,
                       label: sat_s8VXc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WuF: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8WuG; else goto c8WuH;
       c8WuG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8WuH: // global
           I64[Sp - 32] = block_c8Wtu_info;
           R3 = 0;
           _s8VW3::P64 = R2;
           _s8VVX::P64 = P64[R1 + 14];
           R2 = _s8VVX::P64;
           P64[Sp - 24] = P64[R1 + 6];
           P64[Sp - 16] = _s8VVX::P64;
           P64[Sp - 8] = _s8VW3::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wtu() //  [R1]
         { info_tbl: [(c8Wtu,
                       label: block_c8Wtu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wtu: // global
           I64[Sp - 8] = block_c8WtB_info;
           R2 = 4;
           _s8VW5::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8VW5::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WtB() //  [R1]
         { info_tbl: [(c8WtB,
                       label: block_c8WtB_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WtB: // global
           P64[Sp - 16] = P64[Sp + 24];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call _c8Wvm() args: 0, res: 0, upd: 0;
     }
 },
 _c8Wvm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wvm: // global
           _s8VX2::P64 = P64[Sp];
           I64[Sp] = block_c8Wvp_info;
           R1 = _s8VX2::P64;
           if (R1 & 7 != 0) goto u8Ww4; else goto c8Wvr;
       u8Ww4: // global
           call _c8Wvp(R1) args: 0, res: 0, upd: 0;
       c8Wvr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wvp() //  [R1]
         { info_tbl: [(c8Wvp,
                       label: block_c8Wvp_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wvp: // global
           if (R1 & 7 == 1) goto c8Wvx; else goto c8WvC;
       c8Wvx: // global
           I64[Sp + 8] = block_c8WtL_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8WvC: // global
           I64[Sp - 8] = block_c8WvA_info;
           _s8VX7::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8VX7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Ww5; else goto c8WvD;
       u8Ww5: // global
           call _c8WvA(R1) args: 0, res: 0, upd: 0;
       c8WvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WtL() //  [R1]
         { info_tbl: [(c8WtL,
                       label: block_c8WtL_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WtL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8WuN; else goto c8WuM;
       c8WuN: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WuM: // global
           _s8VW5::I64 = I64[Sp + 16];
           _s8VWd::I64 = I64[Sp + 8];
           _s8VWj::I64 = _s8VW5::I64 + 1;
           (_s8VWo::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8VWj::I64);
           if (_s8VWo::I64 == 0) goto c8Wvj; else goto c8Wvi;
       c8Wvj: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Wvi: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8VWd::I64;
           I64[Hp - 32] = _s8VW5::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8VW5::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8VWj::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8VWo::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8Wu5() args: 0, res: 0, upd: 0;
     }
 },
 _c8Wu5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wu5: // global
           I64[Sp - 8] = block_c8Wu8_info;
           R1 = P64[Sp + 40];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8WvX; else goto c8Wu9;
       u8WvX: // global
           call _c8Wu8(R1) args: 0, res: 0, upd: 0;
       c8Wu9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wu8() //  [R1]
         { info_tbl: [(c8Wu8,
                       label: block_c8Wu8_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wu8: // global
           I64[Sp] = block_c8Wud_info;
           R6 = I64[Sp + 16];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 32];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 8];
           P64[Sp - 8] = GHC.Base.$fApplicativeIO4_closure+2;
           Sp = Sp - 16;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Wud() //  [R1]
         { info_tbl: [(c8Wud,
                       label: block_c8Wud_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wud: // global
           I64[Sp] = block_c8Wuf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8WvY; else goto c8Wug;
       u8WvY: // global
           call _c8Wuf(R1) args: 0, res: 0, upd: 0;
       c8Wug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wuf() //  [R1]
         { info_tbl: [(c8Wuf,
                       label: block_c8Wuf_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wuf: // global
           if (R1 & 7 == 1) goto c8WuX; else goto c8Wvg;
       c8WuX: // global
           _s8VWy::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Wuk_info;
           R1 = _s8VWy::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8WvZ; else goto c8Wul;
       u8WvZ: // global
           call _c8Wuk(R1) args: 0, res: 0, upd: 0;
       c8Wul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Wvg: // global
           _s8VWu::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 40]);
           R1 = _s8VWu::P64;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Wuk() //  [R1]
         { info_tbl: [(c8Wuk,
                       label: block_c8Wuk_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wuk: // global
           _s8VWM::I64 = I64[R1 + 7] << 1;
           if (_s8VWM::I64 != 0) goto u8WvR; else goto c8Wv9;
       u8WvR: // global
           I64[Sp] = _s8VWM::I64;
           call _c8Wut() args: 0, res: 0, upd: 0;
       c8Wv9: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = GHC.Foreign.newCString2_closure+1;
           call _c8Wu5() args: 0, res: 0, upd: 0;
     }
 },
 _c8Wut() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wut: // global
           Hp = Hp + 16;
           _s8VWM::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8Wv3; else goto c8Wv2;
       c8Wv3: // global
           HpAlloc = 16;
           I64[Sp] = block_c8Wus_info;
           R1 = _s8VWM::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Wv2: // global
           (_s8VWR::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8VWM::I64);
           if (_s8VWR::I64 == 0) goto c8Wv6; else goto c8Wv5;
       c8Wv6: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Wv5: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8VWM::I64;
           I64[Sp + 8] = _s8VWR::I64;
           P64[Sp] = Hp - 7;
           call _c8Wu5() args: 0, res: 0, upd: 0;
     }
 },
 _c8Wus() //  [R1]
         { info_tbl: [(c8Wus,
                       label: block_c8Wus_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wus: // global
           I64[Sp] = R1;
           call _c8Wut() args: 0, res: 0, upd: 0;
     }
 },
 _c8WvA() //  [R1]
         { info_tbl: [(c8WvA,
                       label: block_c8WvA_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WvA: // global
           _s8VX3::I64 = I64[Sp + 16];
           _s8VX7::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8VX3::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8VX7::P64;
           I64[Sp + 16] = _s8VX3::I64 + 1;
           Sp = Sp + 8;
           call _c8Wvm() args: 0, res: 0, upd: 0;
     }
 },
 newEncodedCString1_r8TNq_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Ww7,
                       label: newEncodedCString1_r8TNq_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ww7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ww8; else goto c8Ww9;
       c8Ww8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = newEncodedCString1_r8TNq_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ww9: // global
           I64[Sp - 24] = block_c8Wtk_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Wwd; else goto c8Wtl;
       u8Wwd: // global
           call _c8Wtk(R1) args: 0, res: 0, upd: 0;
       c8Wtl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wtk() //  [R1]
         { info_tbl: [(c8Wtk,
                       label: block_c8Wtk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wtk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Wwc; else goto c8Wwb;
       c8Wwc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Wwb: // global
           _s8VW2::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8VXc_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8VW2::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.766666349 UTC

[section ""data" . GHC.Foreign.newEncodedCString_closure" {
     GHC.Foreign.newEncodedCString_closure:
         const GHC.Foreign.newEncodedCString_info;
         const 0;
 },
 GHC.Foreign.newEncodedCString_entry() //  [R2, R3, R4]
         { info_tbl: [(c8WxP,
                       label: GHC.Foreign.newEncodedCString_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WxP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call newEncodedCString1_r8TNq_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.774463776 UTC

[section ""data" . GHC.Foreign.newCString1_closure" {
     GHC.Foreign.newCString1_closure:
         const GHC.Foreign.newCString1_info;
         const 0;
 },
 sat_s8VZ6_entry() //  [R1]
         { info_tbl: [(c8Wzx,
                       label: sat_s8VZ6_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wzx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8WzC; else goto c8WzD;
       c8WzC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8WzD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8Wzu_info;
           _s8VXZ::P64 = P64[R1 + 24];
           _s8VXO::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8VXO::I64;
           P64[Sp - 24] = _s8VXZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8WzH; else goto c8Wzv;
       u8WzH: // global
           call _c8Wzu(R1) args: 0, res: 0, upd: 0;
       c8Wzv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Wzu() //  [R1]
         { info_tbl: [(c8Wzu,
                       label: block_c8Wzu_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wzu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8WzG; else goto c8WzF;
       c8WzG: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8WzF: // global
           _s8VZ4::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8VZ4::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8VZk_entry() //  [R1, R2]
         { info_tbl: [(c8WzI,
                       label: sat_s8VZk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WzI: // global
           if ((Sp + -88) < SpLim) (likely: False) goto c8WzJ; else goto c8WzK;
       c8WzJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8WzK: // global
           I64[Sp - 24] = block_c8Wya_info;
           R3 = 0;
           _s8VXk::P64 = R2;
           _s8VXe::P64 = P64[R1 + 6];
           R2 = _s8VXe::P64;
           P64[Sp - 16] = _s8VXe::P64;
           P64[Sp - 8] = _s8VXk::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wya() //  [R1]
         { info_tbl: [(c8Wya,
                       label: block_c8Wya_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wya: // global
           I64[Sp - 8] = block_c8Wyh_info;
           R2 = 4;
           _s8VXm::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8VXm::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wyh() //  [R1]
         { info_tbl: [(c8Wyh,
                       label: block_c8Wyh_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wyh: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8WBN() args: 0, res: 0, upd: 0;
     }
 },
 _c8WBN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WBN: // global
           _s8VZa::P64 = P64[Sp];
           I64[Sp] = block_c8WBQ_info;
           R1 = _s8VZa::P64;
           if (R1 & 7 != 0) goto u8WCY; else goto c8WBS;
       u8WCY: // global
           call _c8WBQ(R1) args: 0, res: 0, upd: 0;
       c8WBS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WBQ() //  [R1]
         { info_tbl: [(c8WBQ,
                       label: block_c8WBQ_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WBQ: // global
           if (R1 & 7 == 1) goto c8WBY; else goto c8WC3;
       c8WBY: // global
           I64[Sp + 8] = block_c8Wyr_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8WC3: // global
           I64[Sp - 8] = block_c8WC1_info;
           _s8VZf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8VZf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8WCZ; else goto c8WC4;
       u8WCZ: // global
           call _c8WC1(R1) args: 0, res: 0, upd: 0;
       c8WC4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wyr() //  [R1]
         { info_tbl: [(c8Wyr,
                       label: block_c8Wyr_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wyr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8WzQ; else goto c8WzP;
       c8WzQ: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WzP: // global
           _s8VXm::I64 = I64[Sp + 16];
           _s8VXu::I64 = I64[Sp + 8];
           _s8VXA::I64 = _s8VXm::I64 + 1;
           (_s8VXF::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8VXA::I64);
           if (_s8VXF::I64 == 0) goto c8WBK; else goto c8WBJ;
       c8WBK: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8WBJ: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8VXu::I64;
           I64[Hp - 32] = _s8VXm::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8VXm::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8VXA::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8VXF::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8WyL() args: 0, res: 0, upd: 0;
     }
 },
 _c8WyL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WyL: // global
           I64[Sp - 8] = block_c8WyO_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8WCF; else goto c8WyP;
       u8WCF: // global
           call _c8WyO(R1) args: 0, res: 0, upd: 0;
       c8WyP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WyO() //  [R1]
         { info_tbl: [(c8WyO,
                       label: block_c8WyO_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WyO: // global
           I64[Sp - 16] = block_c8WyT_info;
           _s8VXS::P64 = P64[R1 + 7];
           _s8VXT::P64 = P64[R1 + 15];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = _s8VXT::P64;
           P64[Sp] = _s8VXS::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WyT() //  [R1]
         { info_tbl: [(c8WyT,
                       label: block_c8WyT_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WyT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8WzZ; else goto c8WzY;
       c8WzZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WzY: // global
           I64[Hp - 32] = sat_s8VZ6_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 32];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = P64[Sp + 40];
           Sp = Sp - 8;
           call _c8WAZ() args: 0, res: 0, upd: 0;
     }
 },
 _c8WAZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WAZ: // global
           _s8VYE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8WB1_info;
           R3 = P64[Sp];
           R2 = _s8VYE::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WB1() //  [R1]
         { info_tbl: [(c8WB1,
                       label: block_c8WB1_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WB1: // global
           I64[Sp] = block_c8WB3_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8WCR; else goto c8WB4;
       u8WCR: // global
           call _c8WB3(R1) args: 0, res: 0, upd: 0;
       c8WB4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WB3() //  [R1]
         { info_tbl: [(c8WB3,
                       label: block_c8WB3_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WB3: // global
           I64[Sp - 16] = block_c8WB8_info;
           _s8VYL::P64 = P64[R1 + 7];
           _s8VYN::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8VYN::P64;
           P64[Sp] = _s8VYL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8WCS; else goto c8WBc;
       u8WCS: // global
           call _c8WB8(R1) args: 0, res: 0, upd: 0;
       c8WBc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WB8() //  [R1]
         { info_tbl: [(c8WB8,
                       label: block_c8WB8_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WB8: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8WBH; else goto c8WBm;
       c8WBH: // global
           I64[Sp + 32] = block_c8WAy_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8WCU; else goto c8WAA;
       u8WCU: // global
           call _c8WAy(R1) args: 0, res: 0, upd: 0;
       c8WAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8WBm: // global
           I64[Sp] = block_c8WBk_info;
           _s8VYO::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8VYO::P64;
           if (R1 & 7 != 0) goto u8WCT; else goto c8WBn;
       u8WCT: // global
           call _c8WBk(R1) args: 0, res: 0, upd: 0;
       c8WBn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WAy() //  [R1]
         { info_tbl: [(c8WAy,
                       label: block_c8WAy_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WAy: // global
           _s8VYu::I64 = I64[R1 + 47];
           _s8VYv::I64 = I64[R1 + 31] - _s8VYu::I64;
           if (_s8VYv::I64 != 0) goto u8WCv; else goto u8WCu;
       u8WCv: // global
           P64[Sp - 32] = P64[R1 + 7];
           I64[Sp - 24] = I64[R1 + 39];
           I64[Sp - 16] = _s8VYu::I64;
           I64[Sp - 8] = _s8VYv::I64;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8WAL() args: 0, res: 0, upd: 0;
       u8WCu: // global
           Sp = Sp + 8;
           call _c8WAS() args: 0, res: 0, upd: 0;
     }
 },
 _c8WAL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WAL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8WAP; else goto c8WAO;
       c8WAP: // global
           HpAlloc = 72;
           I64[Sp - 8] = block_c8WAI_info;
           R1 = I64[Sp + 24];
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8WAO: // global
           _s8VYp::I64 = I64[Sp + 32];
           _s8VYq::P64 = P64[Sp];
           _s8VYt::I64 = I64[Sp + 8];
           _s8VYu::I64 = I64[Sp + 16];
           I8[_s8VYp::I64 + _s8VYu::I64] = 0 :: W8;
           call MO_Touch(_s8VYq::P64);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _s8VYu::I64 - _s8VYt::I64;
           I64[Hp - 48] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 40] = _s8VYp::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 63;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           P64[Sp + 32] = Hp - 6;
           Sp = Sp + 32;
           call _s8VY0() args: 0, res: 0, upd: 0;
     }
 },
 _c8WAI() //  [R1]
         { info_tbl: [(c8WAI,
                       label: block_c8WAI_info
                       rep:StackRep [False, True, True, True, True, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WAI: // global
           I64[Sp + 32] = R1;
           Sp = Sp + 8;
           call _c8WAL() args: 0, res: 0, upd: 0;
     }
 },
 _c8WBk() //  [R1]
         { info_tbl: [(c8WBk,
                       label: block_c8WBk_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WBk: // global
           if (R1 & 7 == 2) goto u8WCs; else goto c8WBw;
       u8WCs: // global
           Sp = Sp + 40;
           call _c8WAS() args: 0, res: 0, upd: 0;
       c8WBw: // global
           _s8VYO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8WBr_info;
           R3 = P64[Sp + 8];
           R2 = _s8VYO::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WAS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WAS: // global
           P64[Sp - 8] = GHC.Base.Nothing_closure+1;
           Sp = Sp - 8;
           call _s8VY0() args: 0, res: 0, upd: 0;
     }
 },
 _s8VY0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8VY0: // global
           _s8VY2::P64 = P64[Sp];
           I64[Sp] = block_c8Wz2_info;
           R1 = _s8VY2::P64;
           if (R1 & 7 != 0) goto u8WD1; else goto c8Wz3;
       u8WD1: // global
           call _c8Wz2(R1) args: 0, res: 0, upd: 0;
       c8Wz3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wz2() //  [R1]
         { info_tbl: [(c8Wz2,
                       label: block_c8Wz2_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wz2: // global
           if (R1 & 7 == 1) goto c8WA3; else goto c8WAm;
       c8WA3: // global
           _s8VXP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Wz7_info;
           R1 = _s8VXP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8WCH; else goto c8Wz8;
       u8WCH: // global
           call _c8Wz7(R1) args: 0, res: 0, upd: 0;
       c8Wz8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8WAm: // global
           _s8VXL::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 32]);
           R1 = _s8VXL::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Wz7() //  [R1]
         { info_tbl: [(c8Wz7,
                       label: block_c8Wz7_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wz7: // global
           _s8VY6::I64 = I64[R1 + 7] << 1;
           if (_s8VY6::I64 != 0) goto u8WCz; else goto c8WAf;
       u8WCz: // global
           I64[Sp] = _s8VY6::I64;
           call _c8Wzg() args: 0, res: 0, upd: 0;
       c8WAf: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = GHC.Foreign.newCString2_closure+1;
           call _c8WyL() args: 0, res: 0, upd: 0;
     }
 },
 _c8Wzg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wzg: // global
           Hp = Hp + 16;
           _s8VY6::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8WA9; else goto c8WA8;
       c8WA9: // global
           HpAlloc = 16;
           I64[Sp] = block_c8Wzf_info;
           R1 = _s8VY6::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8WA8: // global
           (_s8VYb::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8VY6::I64);
           if (_s8VYb::I64 == 0) goto c8WAc; else goto c8WAb;
       c8WAc: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8WAb: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8VY6::I64;
           I64[Sp + 8] = _s8VYb::I64;
           P64[Sp] = Hp - 7;
           call _c8WyL() args: 0, res: 0, upd: 0;
     }
 },
 _c8Wzf() //  [R1]
         { info_tbl: [(c8Wzf,
                       label: block_c8Wzf_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wzf: // global
           I64[Sp] = R1;
           call _c8Wzg() args: 0, res: 0, upd: 0;
     }
 },
 _c8WBr() //  [R1]
         { info_tbl: [(c8WBr,
                       label: block_c8WBr_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WBr: // global
           I64[Sp] = block_c8WBt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8WCW; else goto c8WBy;
       u8WCW: // global
           call _c8WBt(R1) args: 0, res: 0, upd: 0;
       c8WBy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WBt() //  [R1]
         { info_tbl: [(c8WBt,
                       label: block_c8WBt_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WBt: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _c8WAZ() args: 0, res: 0, upd: 0;
     }
 },
 _c8WC1() //  [R1]
         { info_tbl: [(c8WC1,
                       label: block_c8WC1_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WC1: // global
           _s8VZb::I64 = I64[Sp + 16];
           _s8VZf::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8VZb::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8VZf::P64;
           I64[Sp + 16] = _s8VZb::I64 + 1;
           Sp = Sp + 8;
           call _c8WBN() args: 0, res: 0, upd: 0;
     }
 },
 sat_s8VZo_entry() //  [R1]
         { info_tbl: [(c8WD8,
                       label: sat_s8VZo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WD8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8WD9; else goto c8WDa;
       c8WD9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8WDa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Tuple.fst_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Foreign.newCString1_entry() //  [R2, R3]
         { info_tbl: [(c8WDb,
                       label: GHC.Foreign.newCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WDb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8WDc; else goto c8WDd;
       c8WDc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.newCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8WDd: // global
           I64[Sp - 16] = block_c8Wy0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8WDk; else goto c8Wy1;
       u8WDk: // global
           call _c8Wy0(R1) args: 0, res: 0, upd: 0;
       c8Wy1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Wy0() //  [R1]
         { info_tbl: [(c8Wy0,
                       label: block_c8Wy0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Wy0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8WDg; else goto c8WDf;
       c8WDg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WDf: // global
           _s8VXj::P64 = P64[R1 + 23];
           I64[Hp - 8] = sat_s8VZk_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c8WD2_info;
           R4 = Hp - 6;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8VXj::P64;
           Sp = Sp + 8;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8WD2() //  [R1]
         { info_tbl: [(c8WD2,
                       label: block_c8WD2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WD2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8WDj; else goto c8WDi;
       c8WDj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WDi: // global
           I64[Hp - 16] = sat_s8VZo_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.839627438 UTC

[section ""data" . GHC.Foreign.newCString_closure" {
     GHC.Foreign.newCString_closure:
         const GHC.Foreign.newCString_info;
         const 0;
 },
 GHC.Foreign.newCString_entry() //  [R2, R3]
         { info_tbl: [(c8WGu,
                       label: GHC.Foreign.newCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WGu: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.843927335 UTC

[section ""data" . GHC.Foreign.newCStringLen_closure" {
     GHC.Foreign.newCStringLen_closure:
         const GHC.Foreign.newCStringLen_info;
         const 0;
 },
 GHC.Foreign.newCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8WGF,
                       label: GHC.Foreign.newCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WGF: // global
           R4 = R3;
           R3 = GHC.Types.False_closure+1;
           R2 = R2;
           call GHC.Foreign.newEncodedCString_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.851806374 UTC

[section ""data" . GHC.Foreign.$wpeekCString_closure" {
     GHC.Foreign.$wpeekCString_closure:
         const GHC.Foreign.$wpeekCString_info;
         const 0;
 },
 sat_s8W0B_entry() //  [R1]
         { info_tbl: [(c8WIS,
                       label: sat_s8W0B_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WIS: // global
           _s8W0B::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8WIT; else goto c8WIU;
       c8WIU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8WIW; else goto c8WIV;
       c8WIW: // global
           HpAlloc = 40;
           goto c8WIT;
       c8WIT: // global
           R1 = _s8W0B::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8WIV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8W0B::P64;
           _s8W0q::P64 = P64[_s8W0B::P64 + 16];
           _s8W0y::P64 = P64[_s8W0B::P64 + 24];
           _s8W0u::I64 = I64[_s8W0B::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8W0u::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8W0q::P64;
           R3 = _s8W0y::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8W0S_entry() //  [R1]
         { info_tbl: [(c8WJ5,
                       label: sat_s8W0S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WJ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8WJ6; else goto c8WJ7;
       c8WJ6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8WJ7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8VZS_entry() //  [R1, R2]
         { info_tbl: [(c8WJ8,
                       label: $wgo_s8VZS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WJ8: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8WJ9; else goto c8WJa;
       c8WJ9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8WJa: // global
           I64[Sp - 32] = block_c8WHx_info;
           _s8VZS::P64 = R1;
           _s8VZR::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8VZR::P64;
           P64[Sp - 16] = _s8VZS::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8WKK; else goto c8WHy;
       u8WKK: // global
           call _c8WHx(R1) args: 0, res: 0, upd: 0;
       c8WHy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WHx() //  [R1]
         { info_tbl: [(c8WHx,
                       label: block_c8WHx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WHx: // global
           _s8VZR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8WHC_info;
           R3 = _s8VZR::P64;
           R2 = P64[Sp + 24];
           _s8VZX::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8VZX::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WHC() //  [R1]
         { info_tbl: [(c8WHC,
                       label: block_c8WHC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WHC: // global
           I64[Sp] = block_c8WHE_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8WKC; else goto c8WHF;
       u8WKC: // global
           call _c8WHE(R1) args: 0, res: 0, upd: 0;
       c8WHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WHE() //  [R1]
         { info_tbl: [(c8WHE,
                       label: block_c8WHE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WHE: // global
           I64[Sp - 16] = block_c8WHJ_info;
           _s8W05::P64 = P64[R1 + 7];
           _s8W07::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8W07::P64;
           P64[Sp] = _s8W05::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8WKD; else goto c8WHK;
       u8WKD: // global
           call _c8WHJ(R1) args: 0, res: 0, upd: 0;
       c8WHK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WHJ() //  [R1]
         { info_tbl: [(c8WHJ,
                       label: block_c8WHJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WHJ: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8WK5; else goto c8WJy;
       c8WK5: // global
           I64[Sp + 32] = block_c8WIh_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8WKF; else goto c8WIi;
       u8WKF: // global
           call _c8WIh(R1) args: 0, res: 0, upd: 0;
       c8WIi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8WJy: // global
           I64[Sp] = block_c8WJf_info;
           _s8W08::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8W08::P64;
           if (R1 & 7 != 0) goto u8WKE; else goto c8WJz;
       u8WKE: // global
           call _c8WJf(R1) args: 0, res: 0, upd: 0;
       c8WJz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WIh() //  [R1]
         { info_tbl: [(c8WIh,
                       label: block_c8WIh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WIh: // global
           _s8W1g::P64 = P64[R1 + 7];
           _s8W1l::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8W1l::I64, 0)) goto c8WKn; else goto c8WKo;
       c8WKn: // global
           P64[Sp - 24] = _s8W1g::P64;
           I64[Sp - 16] = _s8W1l::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8WIz() args: 0, res: 0, upd: 0;
       c8WKo: // global
           call MO_Touch(_s8W1g::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8WIz() //  []
         { info_tbl: [(c8WIz,
                       label: block_c8WIz_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WIz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8WKi; else goto c8WKh;
       c8WKi: // global
           HpAlloc = 40;
           I64[Sp] = block_c8WIz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8WKh: // global
           _s8W1y::P64 = P64[Sp + 24];
           _s8W1A::I64 = I64[Sp + 16];
           if (_s8W1A::I64 != 0) goto c8WKk; else goto c8WKl;
       c8WKk: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8W1A::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8W1y::P64;
           I64[Sp + 16] = _s8W1A::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8WIz() args: 0, res: 0, upd: 0;
       c8WKl: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8W1y::P64;
           Sp = Sp + 8;
           call _c8WK8() args: 0, res: 0, upd: 0;
     }
 },
 _c8WK8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WK8: // global
           Hp = Hp + 40;
           _s8W1o::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8WKf; else goto c8WKe;
       c8WKf: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8WK7_info;
           R1 = _s8W1o::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WKe: // global
           _s8W1s::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8W1s::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8W1o::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8WK7() //  [R1]
         { info_tbl: [(c8WK7,
                       label: block_c8WK7_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WK7: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8WK8() args: 0, res: 0, upd: 0;
     }
 },
 _c8WJf() //  [R1]
         { info_tbl: [(c8WJf,
                       label: block_c8WJf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WJf: // global
           _s8W07::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8WJZ; else goto c8WJN;
       c8WJZ: // global
           I64[Sp + 8] = block_c8WJX_info;
           R1 = _s8W07::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8WKL; else goto c8WK0;
       u8WKL: // global
           call _c8WJX(R1) args: 0, res: 0, upd: 0;
       c8WK0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8WJN: // global
           _s8W08::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8WJD_info;
           R3 = _s8W07::P64;
           R2 = _s8W08::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WJX() //  [R1]
         { info_tbl: [(c8WJX,
                       label: block_c8WJX_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WJX: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8W0g() args: 0, res: 0, upd: 0;
     }
 },
 _c8WJD() //  [R1]
         { info_tbl: [(c8WJD,
                       label: block_c8WJD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WJD: // global
           I64[Sp] = block_c8WJF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8WKM; else goto c8WJG;
       u8WKM: // global
           call _c8WJF(R1) args: 0, res: 0, upd: 0;
       c8WJG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WJF() //  [R1]
         { info_tbl: [(c8WJF,
                       label: block_c8WJF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WJF: // global
           I64[Sp] = block_c8WJK_info;
           _s8W0Y::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8W0Y::P64;
           if (R1 & 7 != 0) goto u8WKN; else goto c8WJQ;
       u8WKN: // global
           call _c8WJK(R1) args: 0, res: 0, upd: 0;
       c8WJQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WJK() //  [R1]
         { info_tbl: [(c8WJK,
                       label: block_c8WJK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WJK: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8W0g() args: 0, res: 0, upd: 0;
     }
 },
 _s8W0g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8W0g: // global
           _s8W0n::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8W0n::I64, 0)) goto c8WJs; else goto c8WJt;
       c8WJs: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8W0n::I64 - 1;
           Sp = Sp - 8;
           call _c8WI9() args: 0, res: 0, upd: 0;
       c8WJt: // global
           _s8VZS::P64 = P64[Sp + 32];
           _s8W0i::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8WIZ_info;
           R2 = _s8W0i::P64;
           R1 = _s8VZS::P64;
           Sp = Sp + 40;
           call $wgo_s8VZS_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WI9() //  []
         { info_tbl: [(c8WI9,
                       label: block_c8WI9_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WI9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8WJn; else goto c8WJm;
       c8WJn: // global
           HpAlloc = 40;
           I64[Sp] = block_c8WI9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8WJm: // global
           _s8W0j::I64 = I64[Sp + 32];
           _s8W0E::P64 = P64[Sp + 16];
           _s8W0G::I64 = I64[Sp + 24];
           if (_s8W0G::I64 != 0) goto c8WJp; else goto c8WJq;
       c8WJp: // global
           _s8W0J::I64 = %MO_UU_Conv_W32_W64(I32[_s8W0j::I64 + (_s8W0G::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8W0J::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8W0E::P64;
           I64[Sp + 24] = _s8W0G::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8WI9() args: 0, res: 0, upd: 0;
       c8WJq: // global
           Hp = Hp - 40;
           _s8VZS::P64 = P64[Sp + 40];
           _s8W0i::P64 = P64[Sp + 48];
           _s8W0u::I64 = %MO_UU_Conv_W32_W64(I32[_s8W0j::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8WIK_info;
           R2 = _s8W0i::P64;
           R1 = _s8VZS::P64;
           I64[Sp + 40] = _s8W0u::I64;
           P64[Sp + 48] = _s8W0E::P64;
           Sp = Sp + 32;
           call $wgo_s8VZS_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WIK() //  [R1]
         { info_tbl: [(c8WIK,
                       label: block_c8WIK_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WIK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8WJk; else goto c8WJj;
       c8WJk: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WJj: // global
           I64[Hp - 32] = sat_s8W0B_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8WIZ() //  [R1]
         { info_tbl: [(c8WIZ,
                       label: block_c8WIZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WIZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8WJw; else goto c8WJv;
       c8WJw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WJv: // global
           I64[Hp - 16] = sat_s8W0S_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8W1N_entry() //  [R1, R2]
         { info_tbl: [(c8WKX,
                       label: sat_s8W1N_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WKX: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8WKY; else goto c8WKZ;
       c8WKY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8WKZ: // global
           I64[Sp - 32] = block_c8WH6_info;
           _s8VZr::I64 = I64[R1 + 6];
           _s8VZu::I64 = I64[R1 + 14];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 24] = _s8VZr::I64;
           I64[Sp - 16] = _s8VZu::I64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WH6() //  [R1]
         { info_tbl: [(c8WH6,
                       label: block_c8WH6_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WH6: // global
           _s8VZu::I64 = I64[Sp + 16];
           if (%MO_S_Gt_W64(_s8VZu::I64, 1)) goto c8WKV; else goto c8WKW;
       c8WKV: // global
           _s8VZE::P64 = R1;
           _s8VZG::I64 = _s8VZu::I64;
           goto s8VZF;
       c8WKW: // global
           _s8VZE::P64 = R1;
           _s8VZG::I64 = 1;
           goto s8VZF;
       s8VZF: // global
           _s8VZH::I64 = _s8VZG::I64 << 2;
           if (%MO_S_Ge_W64(_s8VZH::I64, 0)) goto c8WL5; else goto c8WLa;
       c8WL5: // global
           I64[Sp - 24] = block_c8WHj_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8VZG::I64;
           I64[Sp - 8] = _s8VZH::I64;
           P64[Sp] = _s8VZE::P64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8WLa: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8WHj() //  [R1]
         { info_tbl: [(c8WHj,
                       label: block_c8WHj_info
                       rep:StackRep [True, True, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WHj: // global
           I64[Sp] = block_c8WHl_info;
           _s8VZL::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8VZL::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WHl() //  [R1]
         { info_tbl: [(c8WHl,
                       label: block_c8WHl_info
                       rep:StackRep [True, False, False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WHl: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8WL9; else goto c8WL8;
       c8WL9: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WL8: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8VZS_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 24];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8VZu::I64 = I64[Sp + 40];
           I64[Hp - 16] = _s8VZu::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8VZu::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8VZS_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.$wpeekCString_entry() //  [R2, R3]
         { info_tbl: [(c8WLd,
                       label: GHC.Foreign.$wpeekCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WLd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8WLe; else goto c8WLf;
       c8WLe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.$wpeekCString_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8WLf: // global
           _s8VZr::I64 = R3;
           _s8VZq::P64 = R2;
           _s8W1P::I64 = 0;
           goto c8WLl;
       c8WLl: // global
           if (I8[_s8VZr::I64 + _s8W1P::I64] == 0 :: W8) goto c8WLr; else goto c8WLq;
       c8WLr: // global
           I64[Sp - 24] = block_c8WGW_info;
           R1 = _s8VZq::P64;
           I64[Sp - 16] = _s8VZr::I64;
           I64[Sp - 8] = _s8W1P::I64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8WLu; else goto c8WGX;
       u8WLu: // global
           call _c8WGW(R1) args: 0, res: 0, upd: 0;
       c8WGX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8WLq: // global
           _s8W1P::I64 = _s8W1P::I64 + 1;
           goto c8WLl;
     }
 },
 _c8WGW() //  [R1]
         { info_tbl: [(c8WGW,
                       label: block_c8WGW_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WGW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8WLj; else goto c8WLi;
       c8WLj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WLi: // global
           _s8VZy::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8W1N_info;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8VZy::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.909963712 UTC

[section ""data" . GHC.Foreign.peekCString1_closure" {
     GHC.Foreign.peekCString1_closure:
         const GHC.Foreign.peekCString1_info;
         const 0;
 },
 GHC.Foreign.peekCString1_entry() //  [R2, R3]
         { info_tbl: [(c8WOE,
                       label: GHC.Foreign.peekCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WOE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8WOF; else goto c8WOG;
       c8WOF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.peekCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8WOG: // global
           I64[Sp - 16] = block_c8WOB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8WOK; else goto c8WOC;
       u8WOK: // global
           call _c8WOB(R1) args: 0, res: 0, upd: 0;
       c8WOC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WOB() //  [R1]
         { info_tbl: [(c8WOB,
                       label: block_c8WOB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WOB: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.915402497 UTC

[section ""data" . GHC.Foreign.peekCString_closure" {
     GHC.Foreign.peekCString_closure:
         const GHC.Foreign.peekCString_info;
         const 0;
 },
 GHC.Foreign.peekCString_entry() //  [R2, R3]
         { info_tbl: [(c8WOZ,
                       label: GHC.Foreign.peekCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WOZ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.peekCString1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.919425794 UTC

[section ""data" . GHC.Foreign.charIsRepresentable2_closure" {
     GHC.Foreign.charIsRepresentable2_closure:
         const GHC.Foreign.charIsRepresentable2_info;
         const 0;
 },
 GHC.Foreign.charIsRepresentable2_entry() //  [R2]
         { info_tbl: [(c8WPd,
                       label: GHC.Foreign.charIsRepresentable2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WPd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8WPh; else goto c8WPi;
       c8WPh: // global
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8WPi: // global
           I64[Sp - 8] = block_c8WPa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8WPA; else goto c8WPb;
       u8WPA: // global
           call _c8WPa(R1) args: 0, res: 0, upd: 0;
       c8WPb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WPa() //  [R1]
         { info_tbl: [(c8WPa,
                       label: block_c8WPa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WPa: // global
           I64[Sp - 8] = block_c8WPg_info;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8WPg() //  [R1]
         { info_tbl: [(c8WPg,
                       label: block_c8WPg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WPg: // global
           I64[Sp] = block_c8WPn_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8WPn() //  [R1]
         { info_tbl: [(c8WPn,
                       label: block_c8WPn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WPn: // global
           if (R1 & 7 == 1) goto c8WPu; else goto c8WPy;
       c8WPu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8WPy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.92930736 UTC

[section ""data" . GHC.Foreign.charIsRepresentable1_closure" {
     GHC.Foreign.charIsRepresentable1_closure:
         const GHC.Foreign.charIsRepresentable1_info;
         const 0;
 },
 sat_s8W2y_entry() //  [R1, R2]
         { info_tbl: [(c8WQe,
                       label: sat_s8W2y_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WQe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8WQf; else goto c8WQg;
       c8WQf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8WQg: // global
           I64[Sp - 24] = block_c8WQb_info;
           _s8W29::P64 = P64[R1 + 6];
           _s8W2b::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _s8W29::P64;
           P64[Sp - 8] = _s8W2b::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8WR7; else goto c8WQc;
       u8WR7: // global
           call _c8WQb(R1) args: 0, res: 0, upd: 0;
       c8WQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WQb() //  [R1]
         { info_tbl: [(c8WQb,
                       label: block_c8WQb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WQb: // global
           I64[Sp] = block_c8WQj_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8WQj() //  [R1]
         { info_tbl: [(c8WQj,
                       label: block_c8WQj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WQj: // global
           I64[Sp] = block_c8WQl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8WR8; else goto c8WQo;
       u8WR8: // global
           call _c8WQl(R1) args: 0, res: 0, upd: 0;
       c8WQo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WQl() //  [R1]
         { info_tbl: [(c8WQl,
                       label: block_c8WQl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WQl: // global
           if (R1 & 7 == 1) goto u8WR4; else goto c8WQz;
       u8WR4: // global
           Sp = Sp + 24;
           call _c8WR1() args: 0, res: 0, upd: 0;
       c8WQz: // global
           I64[Sp] = block_c8WQx_info;
           _s8W2o::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp + 16] = _s8W2o::P64;
           if (R1 & 7 != 0) goto u8WR9; else goto c8WQA;
       u8WR9: // global
           call _c8WQx(R1) args: 0, res: 0, upd: 0;
       c8WQA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WQx() //  [R1]
         { info_tbl: [(c8WQx,
                       label: block_c8WQx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WQx: // global
           if (R1 & 7 == 1) goto c8WQM; else goto u8WR5;
       c8WQM: // global
           I64[Sp] = block_c8WQE_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u8WRb; else goto c8WQF;
       u8WRb: // global
           call _c8WQE(R1) args: 0, res: 0, upd: 0;
       c8WQF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u8WR5: // global
           Sp = Sp + 24;
           call _c8WR1() args: 0, res: 0, upd: 0;
     }
 },
 _c8WQE() //  [R1]
         { info_tbl: [(c8WQE,
                       label: block_c8WQE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WQE: // global
           _s8W29::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8WQJ_info;
           _s8W2s::I64 = I64[R1 + 7];
           R1 = _s8W29::P64;
           I64[Sp + 16] = _s8W2s::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8WRd; else goto c8WQO;
       u8WRd: // global
           call _c8WQJ(R1) args: 0, res: 0, upd: 0;
       c8WQO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WQJ() //  [R1]
         { info_tbl: [(c8WQJ,
                       label: block_c8WQJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WQJ: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c8WQX; else goto u8WR6;
       c8WQX: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u8WR6: // global
           Sp = Sp + 16;
           call _c8WR1() args: 0, res: 0, upd: 0;
     }
 },
 _c8WR1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WR1: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8W2z_entry() //  [R1]
         { info_tbl: [(c8WRl,
                       label: sat_s8W2z_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WRl: // global
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Foreign.charIsRepresentable1_entry() //  [R2, R3]
         { info_tbl: [(c8WRo,
                       label: GHC.Foreign.charIsRepresentable1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WRo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8WRp; else goto c8WRq;
       c8WRp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Foreign.charIsRepresentable1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8WRq: // global
           I64[Sp - 16] = block_c8WQ1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8WRu; else goto c8WQ2;
       u8WRu: // global
           call _c8WQ1(R1) args: 0, res: 0, upd: 0;
       c8WQ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8WQ1() //  [R1]
         { info_tbl: [(c8WQ1,
                       label: block_c8WQ1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WQ1: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c8WRt; else goto c8WRs;
       c8WRt: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8WRs: // global
           I64[Hp - 72] = sat_s8W2y_info;
           _s8W29::P64 = P64[Sp + 8];
           P64[Hp - 64] = _s8W29::P64;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = _s8W29::P64;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           I64[Hp - 24] = sat_s8W2z_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = Hp - 46;
           P64[Hp] = Hp - 70;
           R2 = GHC.Foreign.charIsRepresentable2_closure+2;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.950445495 UTC

[section ""data" . GHC.Foreign.charIsRepresentable_closure" {
     GHC.Foreign.charIsRepresentable_closure:
         const GHC.Foreign.charIsRepresentable_info;
         const 0;
 },
 GHC.Foreign.charIsRepresentable_entry() //  [R2, R3]
         { info_tbl: [(c8WSB,
                       label: GHC.Foreign.charIsRepresentable_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8WSB: // global
           R3 = R3;
           R2 = R2;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:06.953634266 UTC

[section ""relreadonly" . S8W7j_srt" {
     S8W7j_srt:
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const $wpeekCStringLen_r8TNn_closure;
         const peekCStringLen1_r8TNo_closure;
         const Foreign.Marshal.Array.withArrayLen_closure;
         const GHC.Foreign.withCStringsLen1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const newEncodedCString1_r8TNq_closure;
         const GHC.Foreign.newCString1_closure;
         const GHC.Foreign.newEncodedCString_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.Foreign.peekCString1_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const GHC.Foreign.charIsRepresentable2_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
 }]

