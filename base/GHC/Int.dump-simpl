
==================== Tidy Core ====================
2018-03-16 15:59:07.536156923 UTC

Result size of Tidy Core
  = {terms: 7,355, types: 4,392, coercions: 140, joins: 4/44}

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt8_$cfromEnum :: Int8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eRQ [Occ=Once!] :: Int8) ->
                 case ds_d4eRQ of { I8# x#_a4d1N [Occ=Once] ->
                 GHC.Types.I# x#_a4d1N
                 }}]
GHC.Int.$fEnumInt8_$cfromEnum
  = \ (ds_d4eRQ :: Int8) ->
      case ds_d4eRQ of { I8# x#_a4d1N -> GHC.Types.I# x#_a4d1N }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt16_$cfromEnum :: Int16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eNC [Occ=Once!] :: Int16) ->
                 case ds_d4eNC of { I16# x#_a4d0t [Occ=Once] ->
                 GHC.Types.I# x#_a4d0t
                 }}]
GHC.Int.$fEnumInt16_$cfromEnum
  = \ (ds_d4eNC :: Int16) ->
      case ds_d4eNC of { I16# x#_a4d0t -> GHC.Types.I# x#_a4d0t }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt32_$cfromEnum :: Int32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eJp [Occ=Once!] :: Int32) ->
                 case ds_d4eJp of { I32# x#_a4cZa [Occ=Once] ->
                 GHC.Types.I# x#_a4cZa
                 }}]
GHC.Int.$fEnumInt32_$cfromEnum
  = \ (ds_d4eJp :: Int32) ->
      case ds_d4eJp of { I32# x#_a4cZa -> GHC.Types.I# x#_a4cZa }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt64_$cfromEnum :: Int64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eF7 [Occ=Once!] :: Int64) ->
                 case ds_d4eF7 of { I64# x#_a4cXQ [Occ=Once] ->
                 GHC.Types.I# x#_a4cXQ
                 }}]
GHC.Int.$fEnumInt64_$cfromEnum
  = \ (ds_d4eF7 :: Int64) ->
      case ds_d4eF7 of { I64# x#_a4cXQ -> GHC.Types.I# x#_a4cXQ }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt64_$ctoEnum :: Int -> Int64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eF3 [Occ=Once!] :: Int) ->
                 case ds_d4eF3 of { I# i#_a4cXP [Occ=Once] ->
                 GHC.Int.I64# i#_a4cXP
                 }}]
GHC.Int.$fEnumInt64_$ctoEnum
  = \ (ds_d4eF3 :: Int) ->
      case ds_d4eF3 of { I# i#_a4cXP -> GHC.Int.I64# i#_a4cXP }

-- RHS size: {terms: 107, types: 36, coercions: 0, joins: 0/6}
GHC.Int.$w$cenumFromThenTo2 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> Int# -> [Int64]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 433 140}]
GHC.Int.$w$cenumFromThenTo2
  = \ (ww_s4iB0 :: Int#) (ww1_s4iB4 :: Int#) (ww2_s4iB8 :: Int#) ->
      case >=# ww1_s4iB4 ww_s4iB0 of {
        __DEFAULT ->
          case ># ww2_s4iB8 ww1_s4iB4 of {
            __DEFAULT ->
              GHC.Types.:
                @ Int64
                (GHC.Int.I64# ww_s4iB0)
                (let {
                   delta_i2ioH [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioH = -# ww1_s4iB4 ww_s4iB0 } in
                 let {
                   y'_i2ioI [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioI = -# ww2_s4iB8 delta_i2ioH } in
                 letrec {
                   go_dn_i2ioJ [Occ=LoopBreaker] :: Int# -> [Int64]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_dn_i2ioJ
                     = \ (x_i2ioK :: Int#) ->
                         case <# x_i2ioK y'_i2ioI of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Int64
                               (GHC.Int.I64# x_i2ioK)
                               (go_dn_i2ioJ (+# x_i2ioK delta_i2ioH));
                           1# ->
                             GHC.Types.: @ Int64 (GHC.Int.I64# x_i2ioK) (GHC.Types.[] @ Int64)
                         }; } in
                 go_dn_i2ioJ ww1_s4iB4);
            1# ->
              case ># ww2_s4iB8 ww_s4iB0 of {
                __DEFAULT ->
                  GHC.Types.: @ Int64 (GHC.Int.I64# ww_s4iB0) (GHC.Types.[] @ Int64);
                1# -> GHC.Types.[] @ Int64
              }
          };
        1# ->
          case <# ww2_s4iB8 ww1_s4iB4 of {
            __DEFAULT ->
              GHC.Types.:
                @ Int64
                (GHC.Int.I64# ww_s4iB0)
                (let {
                   delta_i2ioX [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioX = -# ww1_s4iB4 ww_s4iB0 } in
                 let {
                   y'_i2ioY [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioY = -# ww2_s4iB8 delta_i2ioX } in
                 letrec {
                   go_up_i2ioZ [Occ=LoopBreaker] :: Int# -> [Int64]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_up_i2ioZ
                     = \ (x_i2ip0 :: Int#) ->
                         case ># x_i2ip0 y'_i2ioY of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Int64
                               (GHC.Int.I64# x_i2ip0)
                               (go_up_i2ioZ (+# x_i2ip0 delta_i2ioX));
                           1# ->
                             GHC.Types.: @ Int64 (GHC.Int.I64# x_i2ip0) (GHC.Types.[] @ Int64)
                         }; } in
                 go_up_i2ioZ ww1_s4iB4);
            1# ->
              case <# ww2_s4iB8 ww_s4iB0 of {
                __DEFAULT ->
                  GHC.Types.: @ Int64 (GHC.Int.I64# ww_s4iB0) (GHC.Types.[] @ Int64);
                1# -> GHC.Types.[] @ Int64
              }
          }
      }

-- RHS size: {terms: 16, types: 9, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt64_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Int64 -> Int64 -> Int64 -> [Int64]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iAV [Occ=Once!] :: Int64)
                 (w1_s4iAW [Occ=Once!] :: Int64)
                 (w2_s4iAX [Occ=Once!] :: Int64) ->
                 case w_s4iAV of { I64# ww1_s4iB0 [Occ=Once] ->
                 case w1_s4iAW of { I64# ww3_s4iB4 [Occ=Once] ->
                 case w2_s4iAX of { I64# ww5_s4iB8 [Occ=Once] ->
                 GHC.Int.$w$cenumFromThenTo2 ww1_s4iB0 ww3_s4iB4 ww5_s4iB8
                 }
                 }
                 }}]
GHC.Int.$fEnumInt64_$cenumFromThenTo
  = \ (w_s4iAV :: Int64) (w1_s4iAW :: Int64) (w2_s4iAX :: Int64) ->
      case w_s4iAV of { I64# ww1_s4iB0 ->
      case w1_s4iAW of { I64# ww3_s4iB4 ->
      case w2_s4iAX of { I64# ww5_s4iB8 ->
      GHC.Int.$w$cenumFromThenTo2 ww1_s4iB0 ww3_s4iB4 ww5_s4iB8
      }
      }
      }

-- RHS size: {terms: 27, types: 11, coercions: 0, joins: 0/1}
GHC.Int.$w$cenumFromTo2 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> [Int64]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 123 10}]
GHC.Int.$w$cenumFromTo2
  = \ (ww_s4iBg :: Int#) (ww1_s4iBk :: Int#) ->
      case ># ww_s4iBg ww1_s4iBk of {
        __DEFAULT ->
          letrec {
            go_i1MGC [Occ=LoopBreaker] :: Int# -> [Int64]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_i1MGC
              = \ (x_i1MGD :: Int#) ->
                  GHC.Types.:
                    @ Int64
                    (GHC.Int.I64# x_i1MGD)
                    (case ==# x_i1MGD ww1_s4iBk of {
                       __DEFAULT -> go_i1MGC (+# x_i1MGD 1#);
                       1# -> GHC.Types.[] @ Int64
                     }); } in
          go_i1MGC ww_s4iBg;
        1# -> GHC.Types.[] @ Int64
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt64_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Int64 -> Int64 -> [Int64]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iBc [Occ=Once!] :: Int64)
                 (w1_s4iBd [Occ=Once!] :: Int64) ->
                 case w_s4iBc of { I64# ww1_s4iBg [Occ=Once] ->
                 case w1_s4iBd of { I64# ww3_s4iBk [Occ=Once] ->
                 GHC.Int.$w$cenumFromTo2 ww1_s4iBg ww3_s4iBk
                 }
                 }}]
GHC.Int.$fEnumInt64_$cenumFromTo
  = \ (w_s4iBc :: Int64) (w1_s4iBd :: Int64) ->
      case w_s4iBc of { I64# ww1_s4iBg ->
      case w1_s4iBd of { I64# ww3_s4iBk ->
      GHC.Int.$w$cenumFromTo2 ww1_s4iBg ww3_s4iBk
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt9 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Int.$tcInt9 = "Int8"#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt7 :: Int8
[GblId, Str=x]
GHC.Int.$fEnumInt7
  = predError @ Int8 (unpackCString# GHC.Int.$tcInt9)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt9 :: Int8
[GblId, Str=x]
GHC.Int.$fEnumInt9
  = succError @ Int8 (unpackCString# GHC.Int.$tcInt9)

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
neInt8 [InlPrag=INLINE[1] (sat-args=2)] :: Int8 -> Int8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eB2 [Occ=Once!] :: Int8)
                 (ds1_d4eB3 [Occ=Once!] :: Int8) ->
                 case ds_d4eB2 of { I8# x_a4d23 [Occ=Once] ->
                 case ds1_d4eB3 of { I8# y_a4d24 [Occ=Once] ->
                 tagToEnum# @ Bool (/=# x_a4d23 y_a4d24)
                 }
                 }}]
neInt8
  = \ (ds_d4eB2 :: Int8) (ds1_d4eB3 :: Int8) ->
      case ds_d4eB2 of { I8# x_a4d23 ->
      case ds1_d4eB3 of { I8# y_a4d24 ->
      tagToEnum# @ Bool (/=# x_a4d23 y_a4d24)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl_r4kPr :: [Char]
[GblId]
lvl_r4kPr = unpackCString# GHC.Int.$tcInt9

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt8_$cminBound :: Int8
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBoundedInt8_$cminBound = GHC.Int.I8# -128#

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt8_$cpred :: Int8 -> Int8
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4d1K [Occ=Once!] :: Int8) ->
                 case x_a4d1K of { I8# x1_a4d23 [Occ=Once!] ->
                 case x1_a4d23 of wild1_X9a {
                   __DEFAULT -> GHC.Int.I8# (narrow8Int# (-# wild1_X9a 1#));
                   -128# -> GHC.Int.$fEnumInt7
                 }
                 }}]
GHC.Int.$fEnumInt8_$cpred
  = \ (x_a4d1K :: Int8) ->
      case x_a4d1K of { I8# x1_a4d23 ->
      case x1_a4d23 of wild1_X9a {
        __DEFAULT -> GHC.Int.I8# (narrow8Int# (-# wild1_X9a 1#));
        -128# -> GHC.Int.$fEnumInt7
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt8_$cmaxBound :: Int8
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBoundedInt8_$cmaxBound = GHC.Int.I8# 127#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Int8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Int8
                          GHC.Int.$fBoundedInt8_$cminBound
                          GHC.Int.$fBoundedInt8_$cmaxBound]
GHC.Int.$fBoundedInt8
  = GHC.Enum.C:Bounded
      @ Int8
      GHC.Int.$fBoundedInt8_$cminBound
      GHC.Int.$fBoundedInt8_$cmaxBound

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt8_$csucc :: Int8 -> Int8
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4d1J [Occ=Once!] :: Int8) ->
                 case x_a4d1J of { I8# x1_a4d23 [Occ=Once!] ->
                 case x1_a4d23 of wild1_X9e {
                   __DEFAULT -> GHC.Int.I8# (narrow8Int# (+# wild1_X9e 1#));
                   127# -> GHC.Int.$fEnumInt9
                 }
                 }}]
GHC.Int.$fEnumInt8_$csucc
  = \ (x_a4d1J :: Int8) ->
      case x_a4d1J of { I8# x1_a4d23 ->
      case x1_a4d23 of wild1_X9e {
        __DEFAULT -> GHC.Int.I8# (narrow8Int# (+# wild1_X9e 1#));
        127# -> GHC.Int.$fEnumInt9
      }
      }

-- RHS size: {terms: 18, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt8_$cshowsPrec :: Int -> Int8 -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4d1Z [Occ=Once!] :: Int)
                 (x_a4d20 [Occ=Once!] :: Int8)
                 (eta_B1 [Occ=Once] :: String) ->
                 case x_a4d20 of { I8# x#_a4d3s [Occ=Once] ->
                 case p_a4d1Z of { I# ww1_i1MOV [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt ww1_i1MOV x#_a4d3s eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }
                 }}]
GHC.Int.$fShowInt8_$cshowsPrec
  = \ (p_a4d1Z :: Int) (x_a4d20 :: Int8) (eta_B1 :: String) ->
      case x_a4d20 of { I8# x#_a4d3s ->
      case p_a4d1Z of { I# ww1_i1MOV ->
      case GHC.Show.$wshowSignedInt ww1_i1MOV x#_a4d3s eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }
      }

-- RHS size: {terms: 13, types: 14, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt8_$cshow :: Int8 -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i1Jj2 [Occ=Once!] :: Int8) ->
                 case x_i1Jj2 of { I8# x#_a4d3s [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# x#_a4d3s (GHC.Types.[] @ Char) of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Int.$fShowInt8_$cshow
  = \ (x_i1Jj2 :: Int8) ->
      case x_i1Jj2 of { I8# x#_a4d3s ->
      case GHC.Show.$wshowSignedInt 0# x#_a4d3s (GHC.Types.[] @ Char) of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt4 :: Int8 -> String -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4d20 [Occ=Once!] :: Int8)
                 (eta_B1 [Occ=Once, OS=OneShot] :: String) ->
                 case x_a4d20 of { I8# x#_a4d3s [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# x#_a4d3s eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Int.$fShowInt4
  = \ (x_a4d20 :: Int8) (eta_B1 [OS=OneShot] :: String) ->
      case x_a4d20 of { I8# x#_a4d3s ->
      case GHC.Show.$wshowSignedInt 0# x#_a4d3s eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt8_$cshowList :: [Int8] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i1Mix [Occ=Once] :: [Int8])
                 (s_i1Miy [Occ=Once] :: String) ->
                 showList__ @ Int8 GHC.Int.$fShowInt4 ls_i1Mix s_i1Miy}]
GHC.Int.$fShowInt8_$cshowList
  = \ (ls_i1Mix :: [Int8]) (s_i1Miy :: String) ->
      showList__ @ Int8 GHC.Int.$fShowInt4 ls_i1Mix s_i1Miy

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt8 [InlPrag=NOUSERINLINE CONLIKE] :: Show Int8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Int8
                       GHC.Int.$fShowInt8_$cshowsPrec
                       GHC.Int.$fShowInt8_$cshow
                       GHC.Int.$fShowInt8_$cshowList]
GHC.Int.$fShowInt8
  = GHC.Show.C:Show
      @ Int8
      GHC.Int.$fShowInt8_$cshowsPrec
      GHC.Int.$fShowInt8_$cshow
      GHC.Int.$fShowInt8_$cshowList

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$wlvl2 [InlPrag=NOUSERINLINE[0]] :: Int# -> Int8
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Int.$wlvl2
  = \ (ww_s4iBq :: Int#) ->
      GHC.Enum.$wtoEnumError
        @ Int8
        @ Int8
        GHC.Int.$fShowInt8
        lvl_r4kPr
        ww_s4iBq
        GHC.Int.$fBoundedInt8_$cminBound
        GHC.Int.$fBoundedInt8_$cmaxBound

-- RHS size: {terms: 20, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$w$ctoEnum2 [InlPrag=NOUSERINLINE[0]] :: Int# -> Int#
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 82 0}]
GHC.Int.$w$ctoEnum2
  = \ (ww_s4iBw :: Int#) ->
      case >=# ww_s4iBw -128# of {
        __DEFAULT -> case GHC.Int.$wlvl2 ww_s4iBw of wild_00 { };
        1# ->
          case <=# ww_s4iBw 127# of {
            __DEFAULT -> case GHC.Int.$wlvl2 ww_s4iBw of wild_00 { };
            1# -> ww_s4iBw
          }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt8_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int8
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iBt [Occ=Once!] :: Int) ->
                 case w_s4iBt of { I# ww1_s4iBw [Occ=Once] ->
                 case GHC.Int.$w$ctoEnum2 ww1_s4iBw of ww2_s4iBA { __DEFAULT ->
                 GHC.Int.I8# ww2_s4iBA
                 }
                 }}]
GHC.Int.$fEnumInt8_$ctoEnum
  = \ (w_s4iBt :: Int) ->
      case w_s4iBt of { I# ww1_s4iBw ->
      case GHC.Int.$w$ctoEnum2 ww1_s4iBw of ww2_s4iBA { __DEFAULT ->
      GHC.Int.I8# ww2_s4iBA
      }
      }

-- RHS size: {terms: 235, types: 52, coercions: 0, joins: 0/6}
GHC.Int.$w$cenumFromThenTo3 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> Int# -> [Int8]
[GblId, Arity=3, Str=<S,U><S,U><S,U>, Unf=OtherCon []]
GHC.Int.$w$cenumFromThenTo3
  = \ (ww_s4iBJ :: Int#) (ww1_s4iBN :: Int#) (ww2_s4iBR :: Int#) ->
      case >=# ww1_s4iBN ww_s4iBJ of {
        __DEFAULT ->
          case ># ww2_s4iBR ww1_s4iBN of {
            __DEFAULT ->
              GHC.Types.:
                @ Int8
                (case >=# ww_s4iBJ -128# of {
                   __DEFAULT -> GHC.Int.$wlvl2 ww_s4iBJ;
                   1# ->
                     case <=# ww_s4iBJ 127# of {
                       __DEFAULT -> GHC.Int.$wlvl2 ww_s4iBJ;
                       1# -> GHC.Int.I8# ww_s4iBJ
                     }
                 })
                (let {
                   delta_i2ioH [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioH = -# ww1_s4iBN ww_s4iBJ } in
                 let {
                   y'_i2ioI [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioI = -# ww2_s4iBR delta_i2ioH } in
                 letrec {
                   go_dn_i2ioJ [Occ=LoopBreaker] :: Int# -> [Int8]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_dn_i2ioJ
                     = \ (x_i2ioK :: Int#) ->
                         case <# x_i2ioK y'_i2ioI of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Int8
                               (case >=# x_i2ioK -128# of {
                                  __DEFAULT -> GHC.Int.$wlvl2 x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 127# of {
                                      __DEFAULT -> GHC.Int.$wlvl2 x_i2ioK;
                                      1# -> GHC.Int.I8# x_i2ioK
                                    }
                                })
                               (go_dn_i2ioJ (+# x_i2ioK delta_i2ioH));
                           1# ->
                             GHC.Types.:
                               @ Int8
                               (case >=# x_i2ioK -128# of {
                                  __DEFAULT -> GHC.Int.$wlvl2 x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 127# of {
                                      __DEFAULT -> GHC.Int.$wlvl2 x_i2ioK;
                                      1# -> GHC.Int.I8# x_i2ioK
                                    }
                                })
                               (GHC.Types.[] @ Int8)
                         }; } in
                 go_dn_i2ioJ ww1_s4iBN);
            1# ->
              case ># ww2_s4iBR ww_s4iBJ of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Int8
                    (case >=# ww_s4iBJ -128# of {
                       __DEFAULT -> GHC.Int.$wlvl2 ww_s4iBJ;
                       1# ->
                         case <=# ww_s4iBJ 127# of {
                           __DEFAULT -> GHC.Int.$wlvl2 ww_s4iBJ;
                           1# -> GHC.Int.I8# ww_s4iBJ
                         }
                     })
                    (GHC.Types.[] @ Int8);
                1# -> GHC.Types.[] @ Int8
              }
          };
        1# ->
          case <# ww2_s4iBR ww1_s4iBN of {
            __DEFAULT ->
              GHC.Types.:
                @ Int8
                (case >=# ww_s4iBJ -128# of {
                   __DEFAULT -> GHC.Int.$wlvl2 ww_s4iBJ;
                   1# ->
                     case <=# ww_s4iBJ 127# of {
                       __DEFAULT -> GHC.Int.$wlvl2 ww_s4iBJ;
                       1# -> GHC.Int.I8# ww_s4iBJ
                     }
                 })
                (let {
                   delta_i2ioX [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioX = -# ww1_s4iBN ww_s4iBJ } in
                 let {
                   y'_i2ioY [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioY = -# ww2_s4iBR delta_i2ioX } in
                 letrec {
                   go_up_i2ioZ [Occ=LoopBreaker] :: Int# -> [Int8]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_up_i2ioZ
                     = \ (x_i2ip0 :: Int#) ->
                         case ># x_i2ip0 y'_i2ioY of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Int8
                               (case >=# x_i2ip0 -128# of {
                                  __DEFAULT -> GHC.Int.$wlvl2 x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 127# of {
                                      __DEFAULT -> GHC.Int.$wlvl2 x_i2ip0;
                                      1# -> GHC.Int.I8# x_i2ip0
                                    }
                                })
                               (go_up_i2ioZ (+# x_i2ip0 delta_i2ioX));
                           1# ->
                             GHC.Types.:
                               @ Int8
                               (case >=# x_i2ip0 -128# of {
                                  __DEFAULT -> GHC.Int.$wlvl2 x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 127# of {
                                      __DEFAULT -> GHC.Int.$wlvl2 x_i2ip0;
                                      1# -> GHC.Int.I8# x_i2ip0
                                    }
                                })
                               (GHC.Types.[] @ Int8)
                         }; } in
                 go_up_i2ioZ ww1_s4iBN);
            1# ->
              case <# ww2_s4iBR ww_s4iBJ of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Int8
                    (case >=# ww_s4iBJ -128# of {
                       __DEFAULT -> GHC.Int.$wlvl2 ww_s4iBJ;
                       1# ->
                         case <=# ww_s4iBJ 127# of {
                           __DEFAULT -> GHC.Int.$wlvl2 ww_s4iBJ;
                           1# -> GHC.Int.I8# ww_s4iBJ
                         }
                     })
                    (GHC.Types.[] @ Int8);
                1# -> GHC.Types.[] @ Int8
              }
          }
      }

-- RHS size: {terms: 16, types: 9, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt8_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Int8 -> Int8 -> Int8 -> [Int8]
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iBE [Occ=Once!] :: Int8)
                 (w1_s4iBF [Occ=Once!] :: Int8)
                 (w2_s4iBG [Occ=Once!] :: Int8) ->
                 case w_s4iBE of { I8# ww1_s4iBJ [Occ=Once] ->
                 case w1_s4iBF of { I8# ww3_s4iBN [Occ=Once] ->
                 case w2_s4iBG of { I8# ww5_s4iBR [Occ=Once] ->
                 GHC.Int.$w$cenumFromThenTo3 ww1_s4iBJ ww3_s4iBN ww5_s4iBR
                 }
                 }
                 }}]
GHC.Int.$fEnumInt8_$cenumFromThenTo
  = \ (w_s4iBE :: Int8) (w1_s4iBF :: Int8) (w2_s4iBG :: Int8) ->
      case w_s4iBE of { I8# ww1_s4iBJ ->
      case w1_s4iBF of { I8# ww3_s4iBN ->
      case w2_s4iBG of { I8# ww5_s4iBR ->
      GHC.Int.$w$cenumFromThenTo3 ww1_s4iBJ ww3_s4iBN ww5_s4iBR
      }
      }
      }

-- RHS size: {terms: 43, types: 13, coercions: 0, joins: 0/1}
GHC.Int.$w$cenumFromTo3 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> [Int8]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 205 10}]
GHC.Int.$w$cenumFromTo3
  = \ (ww_s4iBZ :: Int#) (ww1_s4iC3 :: Int#) ->
      case ># ww_s4iBZ ww1_s4iC3 of {
        __DEFAULT ->
          letrec {
            go_i1MGC [Occ=LoopBreaker] :: Int# -> [Int8]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_i1MGC
              = \ (x_i1MGD :: Int#) ->
                  GHC.Types.:
                    @ Int8
                    (case >=# x_i1MGD -128# of {
                       __DEFAULT -> GHC.Int.$wlvl2 x_i1MGD;
                       1# ->
                         case <=# x_i1MGD 127# of {
                           __DEFAULT -> GHC.Int.$wlvl2 x_i1MGD;
                           1# -> GHC.Int.I8# x_i1MGD
                         }
                     })
                    (case ==# x_i1MGD ww1_s4iC3 of {
                       __DEFAULT -> go_i1MGC (+# x_i1MGD 1#);
                       1# -> GHC.Types.[] @ Int8
                     }); } in
          go_i1MGC ww_s4iBZ;
        1# -> GHC.Types.[] @ Int8
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt8_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Int8 -> Int8 -> [Int8]
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iBV [Occ=Once!] :: Int8)
                 (w1_s4iBW [Occ=Once!] :: Int8) ->
                 case w_s4iBV of { I8# ww1_s4iBZ [Occ=Once] ->
                 case w1_s4iBW of { I8# ww3_s4iC3 [Occ=Once] ->
                 GHC.Int.$w$cenumFromTo3 ww1_s4iBZ ww3_s4iC3
                 }
                 }}]
GHC.Int.$fEnumInt8_$cenumFromTo
  = \ (w_s4iBV :: Int8) (w1_s4iBW :: Int8) ->
      case w_s4iBV of { I8# ww1_s4iBZ ->
      case w1_s4iBW of { I8# ww3_s4iC3 ->
      GHC.Int.$w$cenumFromTo3 ww1_s4iBZ ww3_s4iC3
      }
      }

Rec {
-- RHS size: {terms: 34, types: 20, coercions: 0, joins: 0/0}
GHC.Int.$wgo3 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Int# -> (# Int8, [Int8] #)
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
GHC.Int.$wgo3
  = \ (w_s4iC6 :: Int#) ->
      (# case >=# w_s4iC6 -128# of {
           __DEFAULT -> GHC.Int.$wlvl2 w_s4iC6;
           1# ->
             case <=# w_s4iC6 127# of {
               __DEFAULT -> GHC.Int.$wlvl2 w_s4iC6;
               1# -> GHC.Int.I8# w_s4iC6
             }
         },
         case w_s4iC6 of wild_X8x {
           __DEFAULT ->
             case GHC.Int.$wgo3 (+# wild_X8x 1#) of
             { (# ww1_s4iKj, ww2_s4iKk #) ->
             GHC.Types.: @ Int8 ww1_s4iKj ww2_s4iKk
             };
           127# -> GHC.Types.[] @ Int8
         } #)
end Rec }

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt8_go [InlPrag=NOUSERINLINE[0]] :: Int# -> [Int8]
[GblId,
 Arity=1,
 Str=<S,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iC6 [Occ=Once] :: Int#) ->
                 case GHC.Int.$wgo3 w_s4iC6 of
                 { (# ww1_s4iKj [Occ=Once], ww2_s4iKk [Occ=Once] #) ->
                 GHC.Types.: @ Int8 ww1_s4iKj ww2_s4iKk
                 }}]
GHC.Int.$fEnumInt8_go
  = \ (w_s4iC6 :: Int#) ->
      case GHC.Int.$wgo3 w_s4iC6 of { (# ww1_s4iKj, ww2_s4iKk #) ->
      GHC.Types.: @ Int8 ww1_s4iKj ww2_s4iKk
      }

-- RHS size: {terms: 13, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt8_$cenumFrom :: Int8 -> [Int8]
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i2puv [Occ=Once!] :: Int8) ->
                 case n_i2puv of { I8# x#_a4d1N ->
                 case ># x#_a4d1N 127# of {
                   __DEFAULT -> GHC.Int.$fEnumInt8_go x#_a4d1N;
                   1# -> GHC.Types.[] @ Int8
                 }
                 }}]
GHC.Int.$fEnumInt8_$cenumFrom
  = \ (n_i2puv :: Int8) ->
      case n_i2puv of { I8# x#_a4d1N ->
      case ># x#_a4d1N 127# of {
        __DEFAULT -> GHC.Int.$fEnumInt8_go x#_a4d1N;
        1# -> GHC.Types.[] @ Int8
      }
      }

Rec {
-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt8 [InlPrag=NOUSERINLINE CONLIKE] :: Enum Int8
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Int8
                       GHC.Int.$fEnumInt8_$csucc
                       GHC.Int.$fEnumInt8_$cpred
                       GHC.Int.$fEnumInt8_$ctoEnum
                       GHC.Int.$fEnumInt8_$cfromEnum
                       GHC.Int.$fEnumInt8_$cenumFrom
                       GHC.Int.$fEnumInt8_$cenumFromThen
                       GHC.Int.$fEnumInt8_$cenumFromTo
                       GHC.Int.$fEnumInt8_$cenumFromThenTo]
GHC.Int.$fEnumInt8
  = GHC.Enum.C:Enum
      @ Int8
      GHC.Int.$fEnumInt8_$csucc
      GHC.Int.$fEnumInt8_$cpred
      GHC.Int.$fEnumInt8_$ctoEnum
      GHC.Int.$fEnumInt8_$cfromEnum
      GHC.Int.$fEnumInt8_$cenumFrom
      GHC.Int.$fEnumInt8_$cenumFromThen
      GHC.Int.$fEnumInt8_$cenumFromTo
      GHC.Int.$fEnumInt8_$cenumFromThenTo

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt8_$cenumFromThen [Occ=LoopBreaker]
  :: Int8 -> Int8 -> [Int8]
[GblId, Arity=2, Unf=OtherCon []]
GHC.Int.$fEnumInt8_$cenumFromThen
  = boundedEnumFromThen
      @ Int8 GHC.Int.$fEnumInt8 GHC.Int.$fBoundedInt8
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Int.$tcInt2 = "Int16"#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt1 :: Int16
[GblId, Str=x]
GHC.Int.$fEnumInt1
  = predError @ Int16 (unpackCString# GHC.Int.$tcInt2)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt2 :: Int16
[GblId, Str=x]
GHC.Int.$fEnumInt2
  = succError @ Int16 (unpackCString# GHC.Int.$tcInt2)

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
neInt16 [InlPrag=INLINE[1] (sat-args=2)] :: Int16 -> Int16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eAm [Occ=Once!] :: Int16)
                 (ds1_d4eAn [Occ=Once!] :: Int16) ->
                 case ds_d4eAm of { I16# x_a4d2f [Occ=Once] ->
                 case ds1_d4eAn of { I16# y_a4d2g [Occ=Once] ->
                 tagToEnum# @ Bool (/=# x_a4d2f y_a4d2g)
                 }
                 }}]
neInt16
  = \ (ds_d4eAm :: Int16) (ds1_d4eAn :: Int16) ->
      case ds_d4eAm of { I16# x_a4d2f ->
      case ds1_d4eAn of { I16# y_a4d2g ->
      tagToEnum# @ Bool (/=# x_a4d2f y_a4d2g)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl2_r4kPt :: [Char]
[GblId]
lvl2_r4kPt = unpackCString# GHC.Int.$tcInt2

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt16_$cminBound :: Int16
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBoundedInt16_$cminBound = GHC.Int.I16# -32768#

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt16_$cpred :: Int16 -> Int16
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4d0q [Occ=Once!] :: Int16) ->
                 case x_a4d0q of { I16# x1_a4d2f [Occ=Once!] ->
                 case x1_a4d2f of wild1_X9E {
                   __DEFAULT -> GHC.Int.I16# (narrow16Int# (-# wild1_X9E 1#));
                   -32768# -> GHC.Int.$fEnumInt1
                 }
                 }}]
GHC.Int.$fEnumInt16_$cpred
  = \ (x_a4d0q :: Int16) ->
      case x_a4d0q of { I16# x1_a4d2f ->
      case x1_a4d2f of wild1_X9E {
        __DEFAULT -> GHC.Int.I16# (narrow16Int# (-# wild1_X9E 1#));
        -32768# -> GHC.Int.$fEnumInt1
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt16_$cmaxBound :: Int16
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBoundedInt16_$cmaxBound = GHC.Int.I16# 32767#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Int16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Int16
                          GHC.Int.$fBoundedInt16_$cminBound
                          GHC.Int.$fBoundedInt16_$cmaxBound]
GHC.Int.$fBoundedInt16
  = GHC.Enum.C:Bounded
      @ Int16
      GHC.Int.$fBoundedInt16_$cminBound
      GHC.Int.$fBoundedInt16_$cmaxBound

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt16_$csucc :: Int16 -> Int16
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4d0p [Occ=Once!] :: Int16) ->
                 case x_a4d0p of { I16# x1_a4d2f [Occ=Once!] ->
                 case x1_a4d2f of wild1_X9I {
                   __DEFAULT -> GHC.Int.I16# (narrow16Int# (+# wild1_X9I 1#));
                   32767# -> GHC.Int.$fEnumInt2
                 }
                 }}]
GHC.Int.$fEnumInt16_$csucc
  = \ (x_a4d0p :: Int16) ->
      case x_a4d0p of { I16# x1_a4d2f ->
      case x1_a4d2f of wild1_X9I {
        __DEFAULT -> GHC.Int.I16# (narrow16Int# (+# wild1_X9I 1#));
        32767# -> GHC.Int.$fEnumInt2
      }
      }

-- RHS size: {terms: 18, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt16_$cshowsPrec :: Int -> Int16 -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4d0F [Occ=Once!] :: Int)
                 (x_a4d0G [Occ=Once!] :: Int16)
                 (eta_B1 [Occ=Once] :: String) ->
                 case x_a4d0G of { I16# x#_a4d3j [Occ=Once] ->
                 case p_a4d0F of { I# ww1_i1MOV [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt ww1_i1MOV x#_a4d3j eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }
                 }}]
GHC.Int.$fShowInt16_$cshowsPrec
  = \ (p_a4d0F :: Int) (x_a4d0G :: Int16) (eta_B1 :: String) ->
      case x_a4d0G of { I16# x#_a4d3j ->
      case p_a4d0F of { I# ww1_i1MOV ->
      case GHC.Show.$wshowSignedInt ww1_i1MOV x#_a4d3j eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }
      }

-- RHS size: {terms: 13, types: 14, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt16_$cshow :: Int16 -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i1Jj2 [Occ=Once!] :: Int16) ->
                 case x_i1Jj2 of { I16# x#_a4d3j [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# x#_a4d3j (GHC.Types.[] @ Char) of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Int.$fShowInt16_$cshow
  = \ (x_i1Jj2 :: Int16) ->
      case x_i1Jj2 of { I16# x#_a4d3j ->
      case GHC.Show.$wshowSignedInt 0# x#_a4d3j (GHC.Types.[] @ Char) of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt1 :: Int16 -> String -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4d0G [Occ=Once!] :: Int16)
                 (eta_B1 [Occ=Once, OS=OneShot] :: String) ->
                 case x_a4d0G of { I16# x#_a4d3j [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# x#_a4d3j eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Int.$fShowInt1
  = \ (x_a4d0G :: Int16) (eta_B1 [OS=OneShot] :: String) ->
      case x_a4d0G of { I16# x#_a4d3j ->
      case GHC.Show.$wshowSignedInt 0# x#_a4d3j eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt16_$cshowList :: [Int16] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i1Mix [Occ=Once] :: [Int16])
                 (s_i1Miy [Occ=Once] :: String) ->
                 showList__ @ Int16 GHC.Int.$fShowInt1 ls_i1Mix s_i1Miy}]
GHC.Int.$fShowInt16_$cshowList
  = \ (ls_i1Mix :: [Int16]) (s_i1Miy :: String) ->
      showList__ @ Int16 GHC.Int.$fShowInt1 ls_i1Mix s_i1Miy

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt16 [InlPrag=NOUSERINLINE CONLIKE] :: Show Int16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Int16
                       GHC.Int.$fShowInt16_$cshowsPrec
                       GHC.Int.$fShowInt16_$cshow
                       GHC.Int.$fShowInt16_$cshowList]
GHC.Int.$fShowInt16
  = GHC.Show.C:Show
      @ Int16
      GHC.Int.$fShowInt16_$cshowsPrec
      GHC.Int.$fShowInt16_$cshow
      GHC.Int.$fShowInt16_$cshowList

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$wlvl [InlPrag=NOUSERINLINE[0]] :: Int# -> Int16
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Int.$wlvl
  = \ (ww_s4iCj :: Int#) ->
      GHC.Enum.$wtoEnumError
        @ Int16
        @ Int16
        GHC.Int.$fShowInt16
        lvl2_r4kPt
        ww_s4iCj
        GHC.Int.$fBoundedInt16_$cminBound
        GHC.Int.$fBoundedInt16_$cmaxBound

-- RHS size: {terms: 20, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$w$ctoEnum [InlPrag=NOUSERINLINE[0]] :: Int# -> Int#
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 82 0}]
GHC.Int.$w$ctoEnum
  = \ (ww_s4iCp :: Int#) ->
      case >=# ww_s4iCp -32768# of {
        __DEFAULT -> case GHC.Int.$wlvl ww_s4iCp of wild_00 { };
        1# ->
          case <=# ww_s4iCp 32767# of {
            __DEFAULT -> case GHC.Int.$wlvl ww_s4iCp of wild_00 { };
            1# -> ww_s4iCp
          }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt16_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int16
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iCm [Occ=Once!] :: Int) ->
                 case w_s4iCm of { I# ww1_s4iCp [Occ=Once] ->
                 case GHC.Int.$w$ctoEnum ww1_s4iCp of ww2_s4iCt { __DEFAULT ->
                 GHC.Int.I16# ww2_s4iCt
                 }
                 }}]
GHC.Int.$fEnumInt16_$ctoEnum
  = \ (w_s4iCm :: Int) ->
      case w_s4iCm of { I# ww1_s4iCp ->
      case GHC.Int.$w$ctoEnum ww1_s4iCp of ww2_s4iCt { __DEFAULT ->
      GHC.Int.I16# ww2_s4iCt
      }
      }

-- RHS size: {terms: 235, types: 52, coercions: 0, joins: 0/6}
GHC.Int.$w$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> Int# -> [Int16]
[GblId, Arity=3, Str=<S,U><S,U><S,U>, Unf=OtherCon []]
GHC.Int.$w$cenumFromThenTo
  = \ (ww_s4iCC :: Int#) (ww1_s4iCG :: Int#) (ww2_s4iCK :: Int#) ->
      case >=# ww1_s4iCG ww_s4iCC of {
        __DEFAULT ->
          case ># ww2_s4iCK ww1_s4iCG of {
            __DEFAULT ->
              GHC.Types.:
                @ Int16
                (case >=# ww_s4iCC -32768# of {
                   __DEFAULT -> GHC.Int.$wlvl ww_s4iCC;
                   1# ->
                     case <=# ww_s4iCC 32767# of {
                       __DEFAULT -> GHC.Int.$wlvl ww_s4iCC;
                       1# -> GHC.Int.I16# ww_s4iCC
                     }
                 })
                (let {
                   delta_i2ioH [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioH = -# ww1_s4iCG ww_s4iCC } in
                 let {
                   y'_i2ioI [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioI = -# ww2_s4iCK delta_i2ioH } in
                 letrec {
                   go_dn_i2ioJ [Occ=LoopBreaker] :: Int# -> [Int16]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_dn_i2ioJ
                     = \ (x_i2ioK :: Int#) ->
                         case <# x_i2ioK y'_i2ioI of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Int16
                               (case >=# x_i2ioK -32768# of {
                                  __DEFAULT -> GHC.Int.$wlvl x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 32767# of {
                                      __DEFAULT -> GHC.Int.$wlvl x_i2ioK;
                                      1# -> GHC.Int.I16# x_i2ioK
                                    }
                                })
                               (go_dn_i2ioJ (+# x_i2ioK delta_i2ioH));
                           1# ->
                             GHC.Types.:
                               @ Int16
                               (case >=# x_i2ioK -32768# of {
                                  __DEFAULT -> GHC.Int.$wlvl x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 32767# of {
                                      __DEFAULT -> GHC.Int.$wlvl x_i2ioK;
                                      1# -> GHC.Int.I16# x_i2ioK
                                    }
                                })
                               (GHC.Types.[] @ Int16)
                         }; } in
                 go_dn_i2ioJ ww1_s4iCG);
            1# ->
              case ># ww2_s4iCK ww_s4iCC of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Int16
                    (case >=# ww_s4iCC -32768# of {
                       __DEFAULT -> GHC.Int.$wlvl ww_s4iCC;
                       1# ->
                         case <=# ww_s4iCC 32767# of {
                           __DEFAULT -> GHC.Int.$wlvl ww_s4iCC;
                           1# -> GHC.Int.I16# ww_s4iCC
                         }
                     })
                    (GHC.Types.[] @ Int16);
                1# -> GHC.Types.[] @ Int16
              }
          };
        1# ->
          case <# ww2_s4iCK ww1_s4iCG of {
            __DEFAULT ->
              GHC.Types.:
                @ Int16
                (case >=# ww_s4iCC -32768# of {
                   __DEFAULT -> GHC.Int.$wlvl ww_s4iCC;
                   1# ->
                     case <=# ww_s4iCC 32767# of {
                       __DEFAULT -> GHC.Int.$wlvl ww_s4iCC;
                       1# -> GHC.Int.I16# ww_s4iCC
                     }
                 })
                (let {
                   delta_i2ioX [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioX = -# ww1_s4iCG ww_s4iCC } in
                 let {
                   y'_i2ioY [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioY = -# ww2_s4iCK delta_i2ioX } in
                 letrec {
                   go_up_i2ioZ [Occ=LoopBreaker] :: Int# -> [Int16]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_up_i2ioZ
                     = \ (x_i2ip0 :: Int#) ->
                         case ># x_i2ip0 y'_i2ioY of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Int16
                               (case >=# x_i2ip0 -32768# of {
                                  __DEFAULT -> GHC.Int.$wlvl x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 32767# of {
                                      __DEFAULT -> GHC.Int.$wlvl x_i2ip0;
                                      1# -> GHC.Int.I16# x_i2ip0
                                    }
                                })
                               (go_up_i2ioZ (+# x_i2ip0 delta_i2ioX));
                           1# ->
                             GHC.Types.:
                               @ Int16
                               (case >=# x_i2ip0 -32768# of {
                                  __DEFAULT -> GHC.Int.$wlvl x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 32767# of {
                                      __DEFAULT -> GHC.Int.$wlvl x_i2ip0;
                                      1# -> GHC.Int.I16# x_i2ip0
                                    }
                                })
                               (GHC.Types.[] @ Int16)
                         }; } in
                 go_up_i2ioZ ww1_s4iCG);
            1# ->
              case <# ww2_s4iCK ww_s4iCC of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Int16
                    (case >=# ww_s4iCC -32768# of {
                       __DEFAULT -> GHC.Int.$wlvl ww_s4iCC;
                       1# ->
                         case <=# ww_s4iCC 32767# of {
                           __DEFAULT -> GHC.Int.$wlvl ww_s4iCC;
                           1# -> GHC.Int.I16# ww_s4iCC
                         }
                     })
                    (GHC.Types.[] @ Int16);
                1# -> GHC.Types.[] @ Int16
              }
          }
      }

-- RHS size: {terms: 16, types: 9, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt16_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Int16 -> Int16 -> Int16 -> [Int16]
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iCx [Occ=Once!] :: Int16)
                 (w1_s4iCy [Occ=Once!] :: Int16)
                 (w2_s4iCz [Occ=Once!] :: Int16) ->
                 case w_s4iCx of { I16# ww1_s4iCC [Occ=Once] ->
                 case w1_s4iCy of { I16# ww3_s4iCG [Occ=Once] ->
                 case w2_s4iCz of { I16# ww5_s4iCK [Occ=Once] ->
                 GHC.Int.$w$cenumFromThenTo ww1_s4iCC ww3_s4iCG ww5_s4iCK
                 }
                 }
                 }}]
GHC.Int.$fEnumInt16_$cenumFromThenTo
  = \ (w_s4iCx :: Int16) (w1_s4iCy :: Int16) (w2_s4iCz :: Int16) ->
      case w_s4iCx of { I16# ww1_s4iCC ->
      case w1_s4iCy of { I16# ww3_s4iCG ->
      case w2_s4iCz of { I16# ww5_s4iCK ->
      GHC.Int.$w$cenumFromThenTo ww1_s4iCC ww3_s4iCG ww5_s4iCK
      }
      }
      }

-- RHS size: {terms: 43, types: 13, coercions: 0, joins: 0/1}
GHC.Int.$w$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> [Int16]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 205 10}]
GHC.Int.$w$cenumFromTo
  = \ (ww_s4iCS :: Int#) (ww1_s4iCW :: Int#) ->
      case ># ww_s4iCS ww1_s4iCW of {
        __DEFAULT ->
          letrec {
            go_i1MGC [Occ=LoopBreaker] :: Int# -> [Int16]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_i1MGC
              = \ (x_i1MGD :: Int#) ->
                  GHC.Types.:
                    @ Int16
                    (case >=# x_i1MGD -32768# of {
                       __DEFAULT -> GHC.Int.$wlvl x_i1MGD;
                       1# ->
                         case <=# x_i1MGD 32767# of {
                           __DEFAULT -> GHC.Int.$wlvl x_i1MGD;
                           1# -> GHC.Int.I16# x_i1MGD
                         }
                     })
                    (case ==# x_i1MGD ww1_s4iCW of {
                       __DEFAULT -> go_i1MGC (+# x_i1MGD 1#);
                       1# -> GHC.Types.[] @ Int16
                     }); } in
          go_i1MGC ww_s4iCS;
        1# -> GHC.Types.[] @ Int16
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt16_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Int16 -> Int16 -> [Int16]
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iCO [Occ=Once!] :: Int16)
                 (w1_s4iCP [Occ=Once!] :: Int16) ->
                 case w_s4iCO of { I16# ww1_s4iCS [Occ=Once] ->
                 case w1_s4iCP of { I16# ww3_s4iCW [Occ=Once] ->
                 GHC.Int.$w$cenumFromTo ww1_s4iCS ww3_s4iCW
                 }
                 }}]
GHC.Int.$fEnumInt16_$cenumFromTo
  = \ (w_s4iCO :: Int16) (w1_s4iCP :: Int16) ->
      case w_s4iCO of { I16# ww1_s4iCS ->
      case w1_s4iCP of { I16# ww3_s4iCW ->
      GHC.Int.$w$cenumFromTo ww1_s4iCS ww3_s4iCW
      }
      }

Rec {
-- RHS size: {terms: 34, types: 20, coercions: 0, joins: 0/0}
GHC.Int.$wgo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Int# -> (# Int16, [Int16] #)
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
GHC.Int.$wgo
  = \ (w_s4iCZ :: Int#) ->
      (# case >=# w_s4iCZ -32768# of {
           __DEFAULT -> GHC.Int.$wlvl w_s4iCZ;
           1# ->
             case <=# w_s4iCZ 32767# of {
               __DEFAULT -> GHC.Int.$wlvl w_s4iCZ;
               1# -> GHC.Int.I16# w_s4iCZ
             }
         },
         case w_s4iCZ of wild_X9H {
           __DEFAULT ->
             case GHC.Int.$wgo (+# wild_X9H 1#) of
             { (# ww1_s4iKm, ww2_s4iKn #) ->
             GHC.Types.: @ Int16 ww1_s4iKm ww2_s4iKn
             };
           32767# -> GHC.Types.[] @ Int16
         } #)
end Rec }

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt16_go [InlPrag=NOUSERINLINE[0]] :: Int# -> [Int16]
[GblId,
 Arity=1,
 Str=<S,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iCZ [Occ=Once] :: Int#) ->
                 case GHC.Int.$wgo w_s4iCZ of
                 { (# ww1_s4iKm [Occ=Once], ww2_s4iKn [Occ=Once] #) ->
                 GHC.Types.: @ Int16 ww1_s4iKm ww2_s4iKn
                 }}]
GHC.Int.$fEnumInt16_go
  = \ (w_s4iCZ :: Int#) ->
      case GHC.Int.$wgo w_s4iCZ of { (# ww1_s4iKm, ww2_s4iKn #) ->
      GHC.Types.: @ Int16 ww1_s4iKm ww2_s4iKn
      }

-- RHS size: {terms: 13, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt16_$cenumFrom :: Int16 -> [Int16]
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i2puv [Occ=Once!] :: Int16) ->
                 case n_i2puv of { I16# x#_a4d0t ->
                 case ># x#_a4d0t 32767# of {
                   __DEFAULT -> GHC.Int.$fEnumInt16_go x#_a4d0t;
                   1# -> GHC.Types.[] @ Int16
                 }
                 }}]
GHC.Int.$fEnumInt16_$cenumFrom
  = \ (n_i2puv :: Int16) ->
      case n_i2puv of { I16# x#_a4d0t ->
      case ># x#_a4d0t 32767# of {
        __DEFAULT -> GHC.Int.$fEnumInt16_go x#_a4d0t;
        1# -> GHC.Types.[] @ Int16
      }
      }

Rec {
-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt16 [InlPrag=NOUSERINLINE CONLIKE] :: Enum Int16
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Int16
                       GHC.Int.$fEnumInt16_$csucc
                       GHC.Int.$fEnumInt16_$cpred
                       GHC.Int.$fEnumInt16_$ctoEnum
                       GHC.Int.$fEnumInt16_$cfromEnum
                       GHC.Int.$fEnumInt16_$cenumFrom
                       GHC.Int.$fEnumInt16_$cenumFromThen
                       GHC.Int.$fEnumInt16_$cenumFromTo
                       GHC.Int.$fEnumInt16_$cenumFromThenTo]
GHC.Int.$fEnumInt16
  = GHC.Enum.C:Enum
      @ Int16
      GHC.Int.$fEnumInt16_$csucc
      GHC.Int.$fEnumInt16_$cpred
      GHC.Int.$fEnumInt16_$ctoEnum
      GHC.Int.$fEnumInt16_$cfromEnum
      GHC.Int.$fEnumInt16_$cenumFrom
      GHC.Int.$fEnumInt16_$cenumFromThen
      GHC.Int.$fEnumInt16_$cenumFromTo
      GHC.Int.$fEnumInt16_$cenumFromThenTo

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt16_$cenumFromThen [Occ=LoopBreaker]
  :: Int16 -> Int16 -> [Int16]
[GblId, Arity=2, Unf=OtherCon []]
GHC.Int.$fEnumInt16_$cenumFromThen
  = boundedEnumFromThen
      @ Int16 GHC.Int.$fEnumInt16 GHC.Int.$fBoundedInt16
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Int.$tcInt4 = "Int32"#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt3 :: Int32
[GblId, Str=x]
GHC.Int.$fEnumInt3
  = predError @ Int32 (unpackCString# GHC.Int.$tcInt4)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt4 :: Int32
[GblId, Str=x]
GHC.Int.$fEnumInt4
  = succError @ Int32 (unpackCString# GHC.Int.$tcInt4)

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
neInt32 [InlPrag=INLINE[1] (sat-args=2)] :: Int32 -> Int32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4ezG [Occ=Once!] :: Int32)
                 (ds1_d4ezH [Occ=Once!] :: Int32) ->
                 case ds_d4ezG of { I32# x_a4d2r [Occ=Once] ->
                 case ds1_d4ezH of { I32# y_a4d2s [Occ=Once] ->
                 tagToEnum# @ Bool (/=# x_a4d2r y_a4d2s)
                 }
                 }}]
neInt32
  = \ (ds_d4ezG :: Int32) (ds1_d4ezH :: Int32) ->
      case ds_d4ezG of { I32# x_a4d2r ->
      case ds1_d4ezH of { I32# y_a4d2s ->
      tagToEnum# @ Bool (/=# x_a4d2r y_a4d2s)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl4_r4kPv :: [Char]
[GblId]
lvl4_r4kPv = unpackCString# GHC.Int.$tcInt4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt32_$cminBound :: Int32
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBoundedInt32_$cminBound = GHC.Int.I32# -2147483648#

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt32_$cpred :: Int32 -> Int32
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4cZ7 [Occ=Once!] :: Int32) ->
                 case x_a4cZ7 of { I32# x1_a4d2r [Occ=Once!] ->
                 case x1_a4d2r of wild1_Xa8 {
                   __DEFAULT -> GHC.Int.I32# (narrow32Int# (-# wild1_Xa8 1#));
                   -2147483648# -> GHC.Int.$fEnumInt3
                 }
                 }}]
GHC.Int.$fEnumInt32_$cpred
  = \ (x_a4cZ7 :: Int32) ->
      case x_a4cZ7 of { I32# x1_a4d2r ->
      case x1_a4d2r of wild1_Xa8 {
        __DEFAULT -> GHC.Int.I32# (narrow32Int# (-# wild1_Xa8 1#));
        -2147483648# -> GHC.Int.$fEnumInt3
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt32_$cmaxBound :: Int32
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBoundedInt32_$cmaxBound = GHC.Int.I32# 2147483647#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Int32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Int32
                          GHC.Int.$fBoundedInt32_$cminBound
                          GHC.Int.$fBoundedInt32_$cmaxBound]
GHC.Int.$fBoundedInt32
  = GHC.Enum.C:Bounded
      @ Int32
      GHC.Int.$fBoundedInt32_$cminBound
      GHC.Int.$fBoundedInt32_$cmaxBound

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt32_$csucc :: Int32 -> Int32
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4cZ6 [Occ=Once!] :: Int32) ->
                 case x_a4cZ6 of { I32# x1_a4d2r [Occ=Once!] ->
                 case x1_a4d2r of wild1_Xac {
                   __DEFAULT -> GHC.Int.I32# (narrow32Int# (+# wild1_Xac 1#));
                   2147483647# -> GHC.Int.$fEnumInt4
                 }
                 }}]
GHC.Int.$fEnumInt32_$csucc
  = \ (x_a4cZ6 :: Int32) ->
      case x_a4cZ6 of { I32# x1_a4d2r ->
      case x1_a4d2r of wild1_Xac {
        __DEFAULT -> GHC.Int.I32# (narrow32Int# (+# wild1_Xac 1#));
        2147483647# -> GHC.Int.$fEnumInt4
      }
      }

-- RHS size: {terms: 18, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt32_$cshowsPrec :: Int -> Int32 -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4cZl [Occ=Once!] :: Int)
                 (x_a4cZm [Occ=Once!] :: Int32)
                 (eta_B1 [Occ=Once] :: String) ->
                 case x_a4cZm of { I32# x#_a4d38 [Occ=Once] ->
                 case p_a4cZl of { I# ww1_i1MOV [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt ww1_i1MOV x#_a4d38 eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }
                 }}]
GHC.Int.$fShowInt32_$cshowsPrec
  = \ (p_a4cZl :: Int) (x_a4cZm :: Int32) (eta_B1 :: String) ->
      case x_a4cZm of { I32# x#_a4d38 ->
      case p_a4cZl of { I# ww1_i1MOV ->
      case GHC.Show.$wshowSignedInt ww1_i1MOV x#_a4d38 eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }
      }

-- RHS size: {terms: 13, types: 14, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt32_$cshow :: Int32 -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i1Jj2 [Occ=Once!] :: Int32) ->
                 case x_i1Jj2 of { I32# x#_a4d38 [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# x#_a4d38 (GHC.Types.[] @ Char) of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Int.$fShowInt32_$cshow
  = \ (x_i1Jj2 :: Int32) ->
      case x_i1Jj2 of { I32# x#_a4d38 ->
      case GHC.Show.$wshowSignedInt 0# x#_a4d38 (GHC.Types.[] @ Char) of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt2 :: Int32 -> String -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4cZm [Occ=Once!] :: Int32)
                 (eta_B1 [Occ=Once, OS=OneShot] :: String) ->
                 case x_a4cZm of { I32# x#_a4d38 [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# x#_a4d38 eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Int.$fShowInt2
  = \ (x_a4cZm :: Int32) (eta_B1 [OS=OneShot] :: String) ->
      case x_a4cZm of { I32# x#_a4d38 ->
      case GHC.Show.$wshowSignedInt 0# x#_a4d38 eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt32_$cshowList :: [Int32] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i1Mix [Occ=Once] :: [Int32])
                 (s_i1Miy [Occ=Once] :: String) ->
                 showList__ @ Int32 GHC.Int.$fShowInt2 ls_i1Mix s_i1Miy}]
GHC.Int.$fShowInt32_$cshowList
  = \ (ls_i1Mix :: [Int32]) (s_i1Miy :: String) ->
      showList__ @ Int32 GHC.Int.$fShowInt2 ls_i1Mix s_i1Miy

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt32 [InlPrag=NOUSERINLINE CONLIKE] :: Show Int32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Int32
                       GHC.Int.$fShowInt32_$cshowsPrec
                       GHC.Int.$fShowInt32_$cshow
                       GHC.Int.$fShowInt32_$cshowList]
GHC.Int.$fShowInt32
  = GHC.Show.C:Show
      @ Int32
      GHC.Int.$fShowInt32_$cshowsPrec
      GHC.Int.$fShowInt32_$cshow
      GHC.Int.$fShowInt32_$cshowList

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$wlvl1 [InlPrag=NOUSERINLINE[0]] :: Int# -> Int32
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Int.$wlvl1
  = \ (ww_s4iDc :: Int#) ->
      GHC.Enum.$wtoEnumError
        @ Int32
        @ Int32
        GHC.Int.$fShowInt32
        lvl4_r4kPv
        ww_s4iDc
        GHC.Int.$fBoundedInt32_$cminBound
        GHC.Int.$fBoundedInt32_$cmaxBound

-- RHS size: {terms: 20, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$w$ctoEnum1 [InlPrag=NOUSERINLINE[0]] :: Int# -> Int#
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 82 0}]
GHC.Int.$w$ctoEnum1
  = \ (ww_s4iDi :: Int#) ->
      case >=# ww_s4iDi -2147483648# of {
        __DEFAULT -> case GHC.Int.$wlvl1 ww_s4iDi of wild_00 { };
        1# ->
          case <=# ww_s4iDi 2147483647# of {
            __DEFAULT -> case GHC.Int.$wlvl1 ww_s4iDi of wild_00 { };
            1# -> ww_s4iDi
          }
      }

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt32_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int32
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iDf [Occ=Once!] :: Int) ->
                 case w_s4iDf of { I# ww1_s4iDi [Occ=Once] ->
                 case GHC.Int.$w$ctoEnum1 ww1_s4iDi of ww2_s4iDm { __DEFAULT ->
                 GHC.Int.I32# ww2_s4iDm
                 }
                 }}]
GHC.Int.$fEnumInt32_$ctoEnum
  = \ (w_s4iDf :: Int) ->
      case w_s4iDf of { I# ww1_s4iDi ->
      case GHC.Int.$w$ctoEnum1 ww1_s4iDi of ww2_s4iDm { __DEFAULT ->
      GHC.Int.I32# ww2_s4iDm
      }
      }

-- RHS size: {terms: 43, types: 13, coercions: 0, joins: 0/1}
GHC.Int.$w$cenumFromTo1 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> [Int32]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 205 10}]
GHC.Int.$w$cenumFromTo1
  = \ (ww_s4iDt :: Int#) (ww1_s4iDx :: Int#) ->
      case ># ww_s4iDt ww1_s4iDx of {
        __DEFAULT ->
          letrec {
            go_i1MGC [Occ=LoopBreaker] :: Int# -> [Int32]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_i1MGC
              = \ (x_i1MGD :: Int#) ->
                  GHC.Types.:
                    @ Int32
                    (case >=# x_i1MGD -2147483648# of {
                       __DEFAULT -> GHC.Int.$wlvl1 x_i1MGD;
                       1# ->
                         case <=# x_i1MGD 2147483647# of {
                           __DEFAULT -> GHC.Int.$wlvl1 x_i1MGD;
                           1# -> GHC.Int.I32# x_i1MGD
                         }
                     })
                    (case ==# x_i1MGD ww1_s4iDx of {
                       __DEFAULT -> go_i1MGC (+# x_i1MGD 1#);
                       1# -> GHC.Types.[] @ Int32
                     }); } in
          go_i1MGC ww_s4iDt;
        1# -> GHC.Types.[] @ Int32
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt32_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Int32 -> Int32 -> [Int32]
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iDp [Occ=Once!] :: Int32)
                 (w1_s4iDq [Occ=Once!] :: Int32) ->
                 case w_s4iDp of { I32# ww1_s4iDt [Occ=Once] ->
                 case w1_s4iDq of { I32# ww3_s4iDx [Occ=Once] ->
                 GHC.Int.$w$cenumFromTo1 ww1_s4iDt ww3_s4iDx
                 }
                 }}]
GHC.Int.$fEnumInt32_$cenumFromTo
  = \ (w_s4iDp :: Int32) (w1_s4iDq :: Int32) ->
      case w_s4iDp of { I32# ww1_s4iDt ->
      case w1_s4iDq of { I32# ww3_s4iDx ->
      GHC.Int.$w$cenumFromTo1 ww1_s4iDt ww3_s4iDx
      }
      }

Rec {
-- RHS size: {terms: 34, types: 20, coercions: 0, joins: 0/0}
GHC.Int.$wgo1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Int# -> (# Int32, [Int32] #)
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
GHC.Int.$wgo1
  = \ (w_s4iDA :: Int#) ->
      (# case >=# w_s4iDA -2147483648# of {
           __DEFAULT -> GHC.Int.$wlvl1 w_s4iDA;
           1# ->
             case <=# w_s4iDA 2147483647# of {
               __DEFAULT -> GHC.Int.$wlvl1 w_s4iDA;
               1# -> GHC.Int.I32# w_s4iDA
             }
         },
         case w_s4iDA of wild_XaS {
           __DEFAULT ->
             case GHC.Int.$wgo1 (+# wild_XaS 1#) of
             { (# ww1_s4iKp, ww2_s4iKq #) ->
             GHC.Types.: @ Int32 ww1_s4iKp ww2_s4iKq
             };
           2147483647# -> GHC.Types.[] @ Int32
         } #)
end Rec }

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt32_go [InlPrag=NOUSERINLINE[0]] :: Int# -> [Int32]
[GblId,
 Arity=1,
 Str=<S,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iDA [Occ=Once] :: Int#) ->
                 case GHC.Int.$wgo1 w_s4iDA of
                 { (# ww1_s4iKp [Occ=Once], ww2_s4iKq [Occ=Once] #) ->
                 GHC.Types.: @ Int32 ww1_s4iKp ww2_s4iKq
                 }}]
GHC.Int.$fEnumInt32_go
  = \ (w_s4iDA :: Int#) ->
      case GHC.Int.$wgo1 w_s4iDA of { (# ww1_s4iKp, ww2_s4iKq #) ->
      GHC.Types.: @ Int32 ww1_s4iKp ww2_s4iKq
      }

-- RHS size: {terms: 13, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt32_$cenumFrom :: Int32 -> [Int32]
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i2puv [Occ=Once!] :: Int32) ->
                 case n_i2puv of { I32# x#_a4cZa ->
                 case ># x#_a4cZa 2147483647# of {
                   __DEFAULT -> GHC.Int.$fEnumInt32_go x#_a4cZa;
                   1# -> GHC.Types.[] @ Int32
                 }
                 }}]
GHC.Int.$fEnumInt32_$cenumFrom
  = \ (n_i2puv :: Int32) ->
      case n_i2puv of { I32# x#_a4cZa ->
      case ># x#_a4cZa 2147483647# of {
        __DEFAULT -> GHC.Int.$fEnumInt32_go x#_a4cZa;
        1# -> GHC.Types.[] @ Int32
      }
      }

-- RHS size: {terms: 235, types: 52, coercions: 0, joins: 0/6}
GHC.Int.$w$cenumFromThenTo1 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> Int# -> [Int32]
[GblId, Arity=3, Str=<S,U><S,U><S,U>, Unf=OtherCon []]
GHC.Int.$w$cenumFromThenTo1
  = \ (ww_s4iDM :: Int#) (ww1_s4iDQ :: Int#) (ww2_s4iDU :: Int#) ->
      case >=# ww1_s4iDQ ww_s4iDM of {
        __DEFAULT ->
          case ># ww2_s4iDU ww1_s4iDQ of {
            __DEFAULT ->
              GHC.Types.:
                @ Int32
                (case >=# ww_s4iDM -2147483648# of {
                   __DEFAULT -> GHC.Int.$wlvl1 ww_s4iDM;
                   1# ->
                     case <=# ww_s4iDM 2147483647# of {
                       __DEFAULT -> GHC.Int.$wlvl1 ww_s4iDM;
                       1# -> GHC.Int.I32# ww_s4iDM
                     }
                 })
                (let {
                   delta_i2ioH [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioH = -# ww1_s4iDQ ww_s4iDM } in
                 let {
                   y'_i2ioI [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioI = -# ww2_s4iDU delta_i2ioH } in
                 letrec {
                   go_dn_i2ioJ [Occ=LoopBreaker] :: Int# -> [Int32]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_dn_i2ioJ
                     = \ (x_i2ioK :: Int#) ->
                         case <# x_i2ioK y'_i2ioI of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Int32
                               (case >=# x_i2ioK -2147483648# of {
                                  __DEFAULT -> GHC.Int.$wlvl1 x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 2147483647# of {
                                      __DEFAULT -> GHC.Int.$wlvl1 x_i2ioK;
                                      1# -> GHC.Int.I32# x_i2ioK
                                    }
                                })
                               (go_dn_i2ioJ (+# x_i2ioK delta_i2ioH));
                           1# ->
                             GHC.Types.:
                               @ Int32
                               (case >=# x_i2ioK -2147483648# of {
                                  __DEFAULT -> GHC.Int.$wlvl1 x_i2ioK;
                                  1# ->
                                    case <=# x_i2ioK 2147483647# of {
                                      __DEFAULT -> GHC.Int.$wlvl1 x_i2ioK;
                                      1# -> GHC.Int.I32# x_i2ioK
                                    }
                                })
                               (GHC.Types.[] @ Int32)
                         }; } in
                 go_dn_i2ioJ ww1_s4iDQ);
            1# ->
              case ># ww2_s4iDU ww_s4iDM of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Int32
                    (case >=# ww_s4iDM -2147483648# of {
                       __DEFAULT -> GHC.Int.$wlvl1 ww_s4iDM;
                       1# ->
                         case <=# ww_s4iDM 2147483647# of {
                           __DEFAULT -> GHC.Int.$wlvl1 ww_s4iDM;
                           1# -> GHC.Int.I32# ww_s4iDM
                         }
                     })
                    (GHC.Types.[] @ Int32);
                1# -> GHC.Types.[] @ Int32
              }
          };
        1# ->
          case <# ww2_s4iDU ww1_s4iDQ of {
            __DEFAULT ->
              GHC.Types.:
                @ Int32
                (case >=# ww_s4iDM -2147483648# of {
                   __DEFAULT -> GHC.Int.$wlvl1 ww_s4iDM;
                   1# ->
                     case <=# ww_s4iDM 2147483647# of {
                       __DEFAULT -> GHC.Int.$wlvl1 ww_s4iDM;
                       1# -> GHC.Int.I32# ww_s4iDM
                     }
                 })
                (let {
                   delta_i2ioX [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_i2ioX = -# ww1_s4iDQ ww_s4iDM } in
                 let {
                   y'_i2ioY [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_i2ioY = -# ww2_s4iDU delta_i2ioX } in
                 letrec {
                   go_up_i2ioZ [Occ=LoopBreaker] :: Int# -> [Int32]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_up_i2ioZ
                     = \ (x_i2ip0 :: Int#) ->
                         case ># x_i2ip0 y'_i2ioY of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ Int32
                               (case >=# x_i2ip0 -2147483648# of {
                                  __DEFAULT -> GHC.Int.$wlvl1 x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 2147483647# of {
                                      __DEFAULT -> GHC.Int.$wlvl1 x_i2ip0;
                                      1# -> GHC.Int.I32# x_i2ip0
                                    }
                                })
                               (go_up_i2ioZ (+# x_i2ip0 delta_i2ioX));
                           1# ->
                             GHC.Types.:
                               @ Int32
                               (case >=# x_i2ip0 -2147483648# of {
                                  __DEFAULT -> GHC.Int.$wlvl1 x_i2ip0;
                                  1# ->
                                    case <=# x_i2ip0 2147483647# of {
                                      __DEFAULT -> GHC.Int.$wlvl1 x_i2ip0;
                                      1# -> GHC.Int.I32# x_i2ip0
                                    }
                                })
                               (GHC.Types.[] @ Int32)
                         }; } in
                 go_up_i2ioZ ww1_s4iDQ);
            1# ->
              case <# ww2_s4iDU ww_s4iDM of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Int32
                    (case >=# ww_s4iDM -2147483648# of {
                       __DEFAULT -> GHC.Int.$wlvl1 ww_s4iDM;
                       1# ->
                         case <=# ww_s4iDM 2147483647# of {
                           __DEFAULT -> GHC.Int.$wlvl1 ww_s4iDM;
                           1# -> GHC.Int.I32# ww_s4iDM
                         }
                     })
                    (GHC.Types.[] @ Int32);
                1# -> GHC.Types.[] @ Int32
              }
          }
      }

-- RHS size: {terms: 16, types: 9, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt32_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Int32 -> Int32 -> Int32 -> [Int32]
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iDH [Occ=Once!] :: Int32)
                 (w1_s4iDI [Occ=Once!] :: Int32)
                 (w2_s4iDJ [Occ=Once!] :: Int32) ->
                 case w_s4iDH of { I32# ww1_s4iDM [Occ=Once] ->
                 case w1_s4iDI of { I32# ww3_s4iDQ [Occ=Once] ->
                 case w2_s4iDJ of { I32# ww5_s4iDU [Occ=Once] ->
                 GHC.Int.$w$cenumFromThenTo1 ww1_s4iDM ww3_s4iDQ ww5_s4iDU
                 }
                 }
                 }}]
GHC.Int.$fEnumInt32_$cenumFromThenTo
  = \ (w_s4iDH :: Int32) (w1_s4iDI :: Int32) (w2_s4iDJ :: Int32) ->
      case w_s4iDH of { I32# ww1_s4iDM ->
      case w1_s4iDI of { I32# ww3_s4iDQ ->
      case w2_s4iDJ of { I32# ww5_s4iDU ->
      GHC.Int.$w$cenumFromThenTo1 ww1_s4iDM ww3_s4iDQ ww5_s4iDU
      }
      }
      }

Rec {
-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt32 [InlPrag=NOUSERINLINE CONLIKE] :: Enum Int32
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Int32
                       GHC.Int.$fEnumInt32_$csucc
                       GHC.Int.$fEnumInt32_$cpred
                       GHC.Int.$fEnumInt32_$ctoEnum
                       GHC.Int.$fEnumInt32_$cfromEnum
                       GHC.Int.$fEnumInt32_$cenumFrom
                       GHC.Int.$fEnumInt32_$cenumFromThen
                       GHC.Int.$fEnumInt32_$cenumFromTo
                       GHC.Int.$fEnumInt32_$cenumFromThenTo]
GHC.Int.$fEnumInt32
  = GHC.Enum.C:Enum
      @ Int32
      GHC.Int.$fEnumInt32_$csucc
      GHC.Int.$fEnumInt32_$cpred
      GHC.Int.$fEnumInt32_$ctoEnum
      GHC.Int.$fEnumInt32_$cfromEnum
      GHC.Int.$fEnumInt32_$cenumFrom
      GHC.Int.$fEnumInt32_$cenumFromThen
      GHC.Int.$fEnumInt32_$cenumFromTo
      GHC.Int.$fEnumInt32_$cenumFromThenTo

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt32_$cenumFromThen [Occ=LoopBreaker]
  :: Int32 -> Int32 -> [Int32]
[GblId, Arity=2, Unf=OtherCon []]
GHC.Int.$fEnumInt32_$cenumFromThen
  = boundedEnumFromThen
      @ Int32 GHC.Int.$fEnumInt32 GHC.Int.$fBoundedInt32
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Int.$tcInt6 = "Int64"#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt5 :: Int64
[GblId, Str=x]
GHC.Int.$fEnumInt5
  = predError @ Int64 (unpackCString# GHC.Int.$tcInt6)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt6 :: Int64
[GblId, Str=x]
GHC.Int.$fEnumInt6
  = succError @ Int64 (unpackCString# GHC.Int.$tcInt6)

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
neInt64 [InlPrag=INLINE[1] (sat-args=2)] :: Int64 -> Int64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4ez0 [Occ=Once!] :: Int64)
                 (ds1_d4ez1 [Occ=Once!] :: Int64) ->
                 case ds_d4ez0 of { I64# x_a4d2D [Occ=Once] ->
                 case ds1_d4ez1 of { I64# y_a4d2E [Occ=Once] ->
                 tagToEnum# @ Bool (/=# x_a4d2D y_a4d2E)
                 }
                 }}]
neInt64
  = \ (ds_d4ez0 :: Int64) (ds1_d4ez1 :: Int64) ->
      case ds_d4ez0 of { I64# x_a4d2D ->
      case ds1_d4ez1 of { I64# y_a4d2E ->
      tagToEnum# @ Bool (/=# x_a4d2D y_a4d2E)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt64_$cminBound :: Int64
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBoundedInt64_$cminBound
  = GHC.Int.I64# -9223372036854775808#

-- RHS size: {terms: 13, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt64_$cpred :: Int64 -> Int64
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4cXO [Occ=Once!] :: Int64) ->
                 case x_a4cXO of { I64# x1_a4d2D [Occ=Once!] ->
                 case x1_a4d2D of wild1_Xay {
                   __DEFAULT -> GHC.Int.I64# (-# wild1_Xay 1#);
                   -9223372036854775808# -> GHC.Int.$fEnumInt5
                 }
                 }}]
GHC.Int.$fEnumInt64_$cpred
  = \ (x_a4cXO :: Int64) ->
      case x_a4cXO of { I64# x1_a4d2D ->
      case x1_a4d2D of wild1_Xay {
        __DEFAULT -> GHC.Int.I64# (-# wild1_Xay 1#);
        -9223372036854775808# -> GHC.Int.$fEnumInt5
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt64_$cmaxBound :: Int64
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBoundedInt64_$cmaxBound
  = GHC.Int.I64# 9223372036854775807#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBoundedInt64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Int64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Int64
                          GHC.Int.$fBoundedInt64_$cminBound
                          GHC.Int.$fBoundedInt64_$cmaxBound]
GHC.Int.$fBoundedInt64
  = GHC.Enum.C:Bounded
      @ Int64
      GHC.Int.$fBoundedInt64_$cminBound
      GHC.Int.$fBoundedInt64_$cmaxBound

-- RHS size: {terms: 13, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt64_$csucc :: Int64 -> Int64
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4cXN [Occ=Once!] :: Int64) ->
                 case x_a4cXN of { I64# x1_a4d2D [Occ=Once!] ->
                 case x1_a4d2D of wild1_XaB {
                   __DEFAULT -> GHC.Int.I64# (+# wild1_XaB 1#);
                   9223372036854775807# -> GHC.Int.$fEnumInt6
                 }
                 }}]
GHC.Int.$fEnumInt64_$csucc
  = \ (x_a4cXN :: Int64) ->
      case x_a4cXN of { I64# x1_a4d2D ->
      case x1_a4d2D of wild1_XaB {
        __DEFAULT -> GHC.Int.I64# (+# wild1_XaB 1#);
        9223372036854775807# -> GHC.Int.$fEnumInt6
      }
      }

Rec {
-- RHS size: {terms: 18, types: 18, coercions: 0, joins: 0/0}
GHC.Int.$wgo2 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Int# -> (# Int64, [Int64] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>, Unf=OtherCon []]
GHC.Int.$wgo2
  = \ (w_s4iE2 :: Int#) ->
      (# GHC.Int.I64# w_s4iE2,
         case w_s4iE2 of wild_XbT {
           __DEFAULT ->
             case GHC.Int.$wgo2 (+# wild_XbT 1#) of
             { (# ww1_s4iKs, ww2_s4iKt #) ->
             GHC.Types.: @ Int64 ww1_s4iKs ww2_s4iKt
             };
           9223372036854775807# -> GHC.Types.[] @ Int64
         } #)
end Rec }

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt64_go [InlPrag=NOUSERINLINE[0]] :: Int# -> [Int64]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iE2 [Occ=Once] :: Int#) ->
                 case GHC.Int.$wgo2 w_s4iE2 of
                 { (# ww1_s4iKs [Occ=Once], ww2_s4iKt [Occ=Once] #) ->
                 GHC.Types.: @ Int64 ww1_s4iKs ww2_s4iKt
                 }}]
GHC.Int.$fEnumInt64_go
  = \ (w_s4iE2 :: Int#) ->
      case GHC.Int.$wgo2 w_s4iE2 of { (# ww1_s4iKs, ww2_s4iKt #) ->
      GHC.Types.: @ Int64 ww1_s4iKs ww2_s4iKt
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt64_$cenumFrom :: Int64 -> [Int64]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_i2puv [Occ=Once!] :: Int64) ->
                 case n_i2puv of { I64# x#_a4cXQ [Occ=Once] ->
                 GHC.Int.$fEnumInt64_go x#_a4cXQ
                 }}]
GHC.Int.$fEnumInt64_$cenumFrom
  = \ (n_i2puv :: Int64) ->
      case n_i2puv of { I64# x#_a4cXQ ->
      GHC.Int.$fEnumInt64_go x#_a4cXQ
      }

Rec {
-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt64 [InlPrag=NOUSERINLINE CONLIKE] :: Enum Int64
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Int64
                       GHC.Int.$fEnumInt64_$csucc
                       GHC.Int.$fEnumInt64_$cpred
                       GHC.Int.$fEnumInt64_$ctoEnum
                       GHC.Int.$fEnumInt64_$cfromEnum
                       GHC.Int.$fEnumInt64_$cenumFrom
                       GHC.Int.$fEnumInt64_$cenumFromThen
                       GHC.Int.$fEnumInt64_$cenumFromTo
                       GHC.Int.$fEnumInt64_$cenumFromThenTo]
GHC.Int.$fEnumInt64
  = GHC.Enum.C:Enum
      @ Int64
      GHC.Int.$fEnumInt64_$csucc
      GHC.Int.$fEnumInt64_$cpred
      GHC.Int.$fEnumInt64_$ctoEnum
      GHC.Int.$fEnumInt64_$cfromEnum
      GHC.Int.$fEnumInt64_$cenumFrom
      GHC.Int.$fEnumInt64_$cenumFromThen
      GHC.Int.$fEnumInt64_$cenumFromTo
      GHC.Int.$fEnumInt64_$cenumFromThenTo

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEnumInt64_$cenumFromThen [Occ=LoopBreaker]
  :: Int64 -> Int64 -> [Int64]
[GblId, Arity=2, Unf=OtherCon []]
GHC.Int.$fEnumInt64_$cenumFromThen
  = boundedEnumFromThen
      @ Int64 GHC.Int.$fEnumInt64 GHC.Int.$fBoundedInt64
end Rec }

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt8_$cfromInteger :: Integer -> Int8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a4d1Y [Occ=Once] :: Integer) ->
                 case integerToInt i_a4d1Y of wild_X5U { __DEFAULT ->
                 GHC.Int.I8# (narrow8Int# wild_X5U)
                 }}]
GHC.Int.$fNumInt8_$cfromInteger
  = \ (i_a4d1Y :: Integer) ->
      case integerToInt i_a4d1Y of wild_X5U { __DEFAULT ->
      GHC.Int.I8# (narrow8Int# wild_X5U)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt8_$cnegate :: Int8 -> Int8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eSi [Occ=Once!] :: Int8) ->
                 case ds_d4eSi of { I8# x#_a4d1V [Occ=Once] ->
                 GHC.Int.I8# (narrow8Int# (negateInt# x#_a4d1V))
                 }}]
GHC.Int.$fNumInt8_$cnegate
  = \ (ds_d4eSi :: Int8) ->
      case ds_d4eSi of { I8# x#_a4d1V ->
      GHC.Int.I8# (narrow8Int# (negateInt# x#_a4d1V))
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt8_$c* :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eSb [Occ=Once!] :: Int8)
                 (ds1_d4eSc [Occ=Once!] :: Int8) ->
                 case ds_d4eSb of { I8# x#_a4d1T [Occ=Once] ->
                 case ds1_d4eSc of { I8# y#_a4d1U [Occ=Once] ->
                 GHC.Int.I8# (narrow8Int# (*# x#_a4d1T y#_a4d1U))
                 }
                 }}]
GHC.Int.$fNumInt8_$c*
  = \ (ds_d4eSb :: Int8) (ds1_d4eSc :: Int8) ->
      case ds_d4eSb of { I8# x#_a4d1T ->
      case ds1_d4eSc of { I8# y#_a4d1U ->
      GHC.Int.I8# (narrow8Int# (*# x#_a4d1T y#_a4d1U))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt8_$c- :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eS4 [Occ=Once!] :: Int8)
                 (ds1_d4eS5 [Occ=Once!] :: Int8) ->
                 case ds_d4eS4 of { I8# x#_a4d1R [Occ=Once] ->
                 case ds1_d4eS5 of { I8# y#_a4d1S [Occ=Once] ->
                 GHC.Int.I8# (narrow8Int# (-# x#_a4d1R y#_a4d1S))
                 }
                 }}]
GHC.Int.$fNumInt8_$c-
  = \ (ds_d4eS4 :: Int8) (ds1_d4eS5 :: Int8) ->
      case ds_d4eS4 of { I8# x#_a4d1R ->
      case ds1_d4eS5 of { I8# y#_a4d1S ->
      GHC.Int.I8# (narrow8Int# (-# x#_a4d1R y#_a4d1S))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt8_$c+ :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eRX [Occ=Once!] :: Int8)
                 (ds1_d4eRY [Occ=Once!] :: Int8) ->
                 case ds_d4eRX of { I8# x#_a4d1P [Occ=Once] ->
                 case ds1_d4eRY of { I8# y#_a4d1Q [Occ=Once] ->
                 GHC.Int.I8# (narrow8Int# (+# x#_a4d1P y#_a4d1Q))
                 }
                 }}]
GHC.Int.$fNumInt8_$c+
  = \ (ds_d4eRX :: Int8) (ds1_d4eRY :: Int8) ->
      case ds_d4eRX of { I8# x#_a4d1P ->
      case ds1_d4eRY of { I8# y#_a4d1Q ->
      GHC.Int.I8# (narrow8Int# (+# x#_a4d1P y#_a4d1Q))
      }
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt8_$ctoInteger :: Int8 -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eRA [Occ=Once!] :: Int8) ->
                 case ds_d4eRA of { I8# x#_a4d1I [Occ=Once] ->
                 smallInteger x#_a4d1I
                 }}]
GHC.Int.$fIntegralInt8_$ctoInteger
  = \ (ds_d4eRA :: Int8) ->
      case ds_d4eRA of { I8# x#_a4d1I -> smallInteger x#_a4d1I }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cpopCount :: Int8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4ePS [Occ=Once!] :: Int8) ->
                 case ds_d4ePS of { I8# x#_a4d16 [Occ=Once] ->
                 GHC.Types.I# (word2Int# (popCnt8# (int2Word# x#_a4d16)))
                 }}]
GHC.Int.$fBitsInt8_$cpopCount
  = \ (ds_d4ePS :: Int8) ->
      case ds_d4ePS of { I8# x#_a4d16 ->
      GHC.Types.I# (word2Int# (popCnt8# (int2Word# x#_a4d16)))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cunsafeShiftR :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4ePL [Occ=Once!] :: Int8)
                 (ds1_d4ePM [Occ=Once!] :: Int) ->
                 case ds_d4ePL of { I8# x#_a4d0Y [Occ=Once] ->
                 case ds1_d4ePM of { I# i#_a4d0Z [Occ=Once] ->
                 GHC.Int.I8# (uncheckedIShiftRA# x#_a4d0Y i#_a4d0Z)
                 }
                 }}]
GHC.Int.$fBitsInt8_$cunsafeShiftR
  = \ (ds_d4ePL :: Int8) (ds1_d4ePM :: Int) ->
      case ds_d4ePL of { I8# x#_a4d0Y ->
      case ds1_d4ePM of { I# i#_a4d0Z ->
      GHC.Int.I8# (uncheckedIShiftRA# x#_a4d0Y i#_a4d0Z)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt13 :: Int8
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt13 = GHC.Int.I8# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt9 :: Int8
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fNumInt9 = GHC.Int.I8# -1#

-- RHS size: {terms: 26, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cshiftR [InlPrag=NOUSERINLINE[0]]
  :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iE7 [Occ=Once!] :: Int8)
                 (w1_s4iE8 [Occ=Once!] :: Int) ->
                 case w_s4iE7 of { I8# ww1_s4iEb [Occ=Once*] ->
                 case w1_s4iE8 of { I# ww3_s4iEf ->
                 case >=# ww3_s4iEf 64# of {
                   __DEFAULT -> GHC.Int.I8# (uncheckedIShiftRA# ww1_s4iEb ww3_s4iEf);
                   1# ->
                     case <# ww1_s4iEb 0# of {
                       __DEFAULT -> GHC.Int.I8# 0#;
                       1# -> GHC.Int.I8# -1#
                     }
                 }
                 }
                 }}]
GHC.Int.$fBitsInt8_$cshiftR
  = \ (w_s4iE7 :: Int8) (w1_s4iE8 :: Int) ->
      case w_s4iE7 of { I8# ww1_s4iEb ->
      case w1_s4iE8 of { I# ww3_s4iEf ->
      case >=# ww3_s4iEf 64# of {
        __DEFAULT -> GHC.Int.I8# (uncheckedIShiftRA# ww1_s4iEb ww3_s4iEf);
        1# ->
          case <# ww1_s4iEb 0# of {
            __DEFAULT -> GHC.Int.$fBitsInt13;
            1# -> GHC.Int.$fNumInt9
          }
      }
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cunsafeShiftL :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4ePx [Occ=Once!] :: Int8)
                 (ds1_d4ePy [Occ=Once!] :: Int) ->
                 case ds_d4ePx of { I8# x#_a4d0U [Occ=Once] ->
                 case ds1_d4ePy of { I# i#_a4d0V [Occ=Once] ->
                 GHC.Int.I8# (narrow8Int# (uncheckedIShiftL# x#_a4d0U i#_a4d0V))
                 }
                 }}]
GHC.Int.$fBitsInt8_$cunsafeShiftL
  = \ (ds_d4ePx :: Int8) (ds1_d4ePy :: Int) ->
      case ds_d4ePx of { I8# x#_a4d0U ->
      case ds1_d4ePy of { I# i#_a4d0V ->
      GHC.Int.I8# (narrow8Int# (uncheckedIShiftL# x#_a4d0U i#_a4d0V))
      }
      }

-- RHS size: {terms: 20, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cshiftL :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4ePq [Occ=Once!] :: Int8)
                 (ds1_d4ePr [Occ=Once!] :: Int) ->
                 case ds_d4ePq of { I8# x#_a4d0S [Occ=Once] ->
                 case ds1_d4ePr of { I# i#_a4d0T ->
                 case >=# i#_a4d0T 64# of {
                   __DEFAULT ->
                     GHC.Int.I8# (narrow8Int# (uncheckedIShiftL# x#_a4d0S i#_a4d0T));
                   1# -> GHC.Int.I8# 0#
                 }
                 }
                 }}]
GHC.Int.$fBitsInt8_$cshiftL
  = \ (ds_d4ePq :: Int8) (ds1_d4ePr :: Int) ->
      case ds_d4ePq of { I8# x#_a4d0S ->
      case ds1_d4ePr of { I# i#_a4d0T ->
      case >=# i#_a4d0T 64# of {
        __DEFAULT ->
          GHC.Int.I8# (narrow8Int# (uncheckedIShiftL# x#_a4d0S i#_a4d0T));
        1# -> GHC.Int.$fBitsInt13
      }
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cisSigned :: Int8 -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.True}]
GHC.Int.$fBitsInt8_$cisSigned = \ _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 33, types: 8, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt8_$crotate :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eP8 [Occ=Once!] :: Int8)
                 (ds1_d4eP9 [Occ=Once!] :: Int) ->
                 case ds_d4eP8 of { I8# x#_a4d10 [Occ=Once*] ->
                 case ds1_d4eP9 of { I# i#_a4d11 [Occ=Once] ->
                 case word2Int# (and# (int2Word# i#_a4d11) 7##) of wild2_X6m {
                   __DEFAULT ->
                     let {
                       x'#_s4fCd :: Word#
                       [LclId]
                       x'#_s4fCd = narrow8Word# (int2Word# x#_a4d10) } in
                     GHC.Int.I8#
                       (narrow8Int#
                          (word2Int#
                             (or#
                                (uncheckedShiftL# x'#_s4fCd wild2_X6m)
                                (uncheckedShiftRL# x'#_s4fCd (-# 8# wild2_X6m)))));
                   0# -> GHC.Int.I8# x#_a4d10
                 }
                 }
                 }}]
GHC.Int.$fBitsInt8_$crotate
  = \ (ds_d4eP8 :: Int8) (ds1_d4eP9 :: Int) ->
      case ds_d4eP8 of wild_X68 { I8# x#_a4d10 ->
      case ds1_d4eP9 of { I# i#_a4d11 ->
      case word2Int# (and# (int2Word# i#_a4d11) 7##) of wild2_X6m {
        __DEFAULT ->
          let {
            x'#_s4fCd [Dmd=<S,U>] :: Word#
            [LclId]
            x'#_s4fCd = narrow8Word# (int2Word# x#_a4d10) } in
          GHC.Int.I8#
            (narrow8Int#
               (word2Int#
                  (or#
                     (uncheckedShiftL# x'#_s4fCd wild2_X6m)
                     (uncheckedShiftRL# x'#_s4fCd (-# 8# wild2_X6m)))));
        0# -> wild_X68
      }
      }
      }

-- RHS size: {terms: 47, types: 11, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt8_$cshift [InlPrag=INLINE (sat-args=2)]
  :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eOZ [Occ=Once!] :: Int8)
                 (ds1_d4eP0 [Occ=Once!] :: Int) ->
                 case ds_d4eOZ of { I8# x#_a4d0Q [Occ=Once*] ->
                 case ds1_d4eP0 of { I# i#_a4d0R ->
                 case >=# i#_a4d0R 0# of {
                   __DEFAULT ->
                     let {
                       b_i1AI0 :: Int#
                       [LclId]
                       b_i1AI0 = negateInt# i#_a4d0R } in
                     case >=# b_i1AI0 64# of {
                       __DEFAULT -> GHC.Int.I8# (uncheckedIShiftRA# x#_a4d0Q b_i1AI0);
                       1# ->
                         case <# x#_a4d0Q 0# of {
                           __DEFAULT -> GHC.Int.I8# 0#;
                           1# -> GHC.Int.I8# -1#
                         }
                     };
                   1# ->
                     case >=# i#_a4d0R 64# of {
                       __DEFAULT ->
                         GHC.Int.I8# (narrow8Int# (uncheckedIShiftL# x#_a4d0Q i#_a4d0R));
                       1# -> GHC.Int.I8# 0#
                     }
                 }
                 }
                 }}]
GHC.Int.$fBitsInt8_$cshift
  = \ (ds_d4eOZ :: Int8) (ds1_d4eP0 :: Int) ->
      case ds_d4eOZ of { I8# x#_a4d0Q ->
      case ds1_d4eP0 of { I# i#_a4d0R ->
      case >=# i#_a4d0R 0# of {
        __DEFAULT ->
          let {
            b_s4fCa [Dmd=<S,U>] :: Int#
            [LclId]
            b_s4fCa = negateInt# i#_a4d0R } in
          case >=# b_s4fCa 64# of {
            __DEFAULT -> GHC.Int.I8# (uncheckedIShiftRA# x#_a4d0Q b_s4fCa);
            1# ->
              case <# x#_a4d0Q 0# of {
                __DEFAULT -> GHC.Int.$fBitsInt13;
                1# -> GHC.Int.$fNumInt9
              }
          };
        1# ->
          case >=# i#_a4d0R 64# of {
            __DEFAULT ->
              GHC.Int.I8# (narrow8Int# (uncheckedIShiftL# x#_a4d0Q i#_a4d0R));
            1# -> GHC.Int.$fBitsInt13
          }
      }
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$ccomplement :: Int8 -> Int8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eOV [Occ=Once!] :: Int8) ->
                 case ds_d4eOV of { I8# x#_a4d0P [Occ=Once] ->
                 GHC.Int.I8# (word2Int# (not# (int2Word# x#_a4d0P)))
                 }}]
GHC.Int.$fBitsInt8_$ccomplement
  = \ (ds_d4eOV :: Int8) ->
      case ds_d4eOV of { I8# x#_a4d0P ->
      GHC.Int.I8# (word2Int# (not# (int2Word# x#_a4d0P)))
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cxor :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eOO [Occ=Once!] :: Int8)
                 (ds1_d4eOP [Occ=Once!] :: Int8) ->
                 case ds_d4eOO of { I8# x#_a4d0N [Occ=Once] ->
                 case ds1_d4eOP of { I8# y#_a4d0O [Occ=Once] ->
                 GHC.Int.I8#
                   (word2Int# (xor# (int2Word# x#_a4d0N) (int2Word# y#_a4d0O)))
                 }
                 }}]
GHC.Int.$fBitsInt8_$cxor
  = \ (ds_d4eOO :: Int8) (ds1_d4eOP :: Int8) ->
      case ds_d4eOO of { I8# x#_a4d0N ->
      case ds1_d4eOP of { I8# y#_a4d0O ->
      GHC.Int.I8#
        (word2Int# (xor# (int2Word# x#_a4d0N) (int2Word# y#_a4d0O)))
      }
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$c.|. :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eOH [Occ=Once!] :: Int8)
                 (ds1_d4eOI [Occ=Once!] :: Int8) ->
                 case ds_d4eOH of { I8# x#_a4d0L [Occ=Once] ->
                 case ds1_d4eOI of { I8# y#_a4d0M [Occ=Once] ->
                 GHC.Int.I8#
                   (word2Int# (or# (int2Word# x#_a4d0L) (int2Word# y#_a4d0M)))
                 }
                 }}]
GHC.Int.$fBitsInt8_$c.|.
  = \ (ds_d4eOH :: Int8) (ds1_d4eOI :: Int8) ->
      case ds_d4eOH of { I8# x#_a4d0L ->
      case ds1_d4eOI of { I8# y#_a4d0M ->
      GHC.Int.I8#
        (word2Int# (or# (int2Word# x#_a4d0L) (int2Word# y#_a4d0M)))
      }
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$c.&. :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eOA [Occ=Once!] :: Int8)
                 (ds1_d4eOB [Occ=Once!] :: Int8) ->
                 case ds_d4eOA of { I8# x#_a4d0J [Occ=Once] ->
                 case ds1_d4eOB of { I8# y#_a4d0K [Occ=Once] ->
                 GHC.Int.I8#
                   (word2Int# (and# (int2Word# x#_a4d0J) (int2Word# y#_a4d0K)))
                 }
                 }}]
GHC.Int.$fBitsInt8_$c.&.
  = \ (ds_d4eOA :: Int8) (ds1_d4eOB :: Int8) ->
      case ds_d4eOA of { I8# x#_a4d0J ->
      case ds1_d4eOB of { I8# y#_a4d0K ->
      GHC.Int.I8#
        (word2Int# (and# (int2Word# x#_a4d0J) (int2Word# y#_a4d0K)))
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros :: Int8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eOw [Occ=Once!] :: Int8) ->
                 case ds_d4eOw of { I8# x#_a4d0I [Occ=Once] ->
                 GHC.Types.I# (word2Int# (ctz8# (int2Word# x#_a4d0I)))
                 }}]
GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros
  = \ (ds_d4eOw :: Int8) ->
      case ds_d4eOw of { I8# x#_a4d0I ->
      GHC.Types.I# (word2Int# (ctz8# (int2Word# x#_a4d0I)))
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros :: Int8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eOs [Occ=Once!] :: Int8) ->
                 case ds_d4eOs of { I8# x#_a4d0H [Occ=Once] ->
                 GHC.Types.I# (word2Int# (clz8# (int2Word# x#_a4d0H)))
                 }}]
GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros
  = \ (ds_d4eOs :: Int8) ->
      case ds_d4eOs of { I8# x#_a4d0H ->
      GHC.Types.I# (word2Int# (clz8# (int2Word# x#_a4d0H)))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt11 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt11 = GHC.Types.I# 8#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cfiniteBitSize :: Int8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Int.$fBitsInt11}]
GHC.Int.$fBitsInt8_$cfiniteBitSize
  = \ _ [Occ=Dead] -> GHC.Int.$fBitsInt11

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt16_$cfromInteger :: Integer -> Int16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a4d0E [Occ=Once] :: Integer) ->
                 case integerToInt i_a4d0E of wild_X6g { __DEFAULT ->
                 GHC.Int.I16# (narrow16Int# wild_X6g)
                 }}]
GHC.Int.$fNumInt16_$cfromInteger
  = \ (i_a4d0E :: Integer) ->
      case integerToInt i_a4d0E of wild_X6g { __DEFAULT ->
      GHC.Int.I16# (narrow16Int# wild_X6g)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt16_$cnegate :: Int16 -> Int16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eO4 [Occ=Once!] :: Int16) ->
                 case ds_d4eO4 of { I16# x#_a4d0B [Occ=Once] ->
                 GHC.Int.I16# (narrow16Int# (negateInt# x#_a4d0B))
                 }}]
GHC.Int.$fNumInt16_$cnegate
  = \ (ds_d4eO4 :: Int16) ->
      case ds_d4eO4 of { I16# x#_a4d0B ->
      GHC.Int.I16# (narrow16Int# (negateInt# x#_a4d0B))
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt16_$c* :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eNX [Occ=Once!] :: Int16)
                 (ds1_d4eNY [Occ=Once!] :: Int16) ->
                 case ds_d4eNX of { I16# x#_a4d0z [Occ=Once] ->
                 case ds1_d4eNY of { I16# y#_a4d0A [Occ=Once] ->
                 GHC.Int.I16# (narrow16Int# (*# x#_a4d0z y#_a4d0A))
                 }
                 }}]
GHC.Int.$fNumInt16_$c*
  = \ (ds_d4eNX :: Int16) (ds1_d4eNY :: Int16) ->
      case ds_d4eNX of { I16# x#_a4d0z ->
      case ds1_d4eNY of { I16# y#_a4d0A ->
      GHC.Int.I16# (narrow16Int# (*# x#_a4d0z y#_a4d0A))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt16_$c- :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eNQ [Occ=Once!] :: Int16)
                 (ds1_d4eNR [Occ=Once!] :: Int16) ->
                 case ds_d4eNQ of { I16# x#_a4d0x [Occ=Once] ->
                 case ds1_d4eNR of { I16# y#_a4d0y [Occ=Once] ->
                 GHC.Int.I16# (narrow16Int# (-# x#_a4d0x y#_a4d0y))
                 }
                 }}]
GHC.Int.$fNumInt16_$c-
  = \ (ds_d4eNQ :: Int16) (ds1_d4eNR :: Int16) ->
      case ds_d4eNQ of { I16# x#_a4d0x ->
      case ds1_d4eNR of { I16# y#_a4d0y ->
      GHC.Int.I16# (narrow16Int# (-# x#_a4d0x y#_a4d0y))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt16_$c+ :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eNJ [Occ=Once!] :: Int16)
                 (ds1_d4eNK [Occ=Once!] :: Int16) ->
                 case ds_d4eNJ of { I16# x#_a4d0v [Occ=Once] ->
                 case ds1_d4eNK of { I16# y#_a4d0w [Occ=Once] ->
                 GHC.Int.I16# (narrow16Int# (+# x#_a4d0v y#_a4d0w))
                 }
                 }}]
GHC.Int.$fNumInt16_$c+
  = \ (ds_d4eNJ :: Int16) (ds1_d4eNK :: Int16) ->
      case ds_d4eNJ of { I16# x#_a4d0v ->
      case ds1_d4eNK of { I16# y#_a4d0w ->
      GHC.Int.I16# (narrow16Int# (+# x#_a4d0v y#_a4d0w))
      }
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt16_$ctoInteger :: Int16 -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eNm [Occ=Once!] :: Int16) ->
                 case ds_d4eNm of { I16# x#_a4d0o [Occ=Once] ->
                 smallInteger x#_a4d0o
                 }}]
GHC.Int.$fIntegralInt16_$ctoInteger
  = \ (ds_d4eNm :: Int16) ->
      case ds_d4eNm of { I16# x#_a4d0o -> smallInteger x#_a4d0o }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cpopCount :: Int16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eLE [Occ=Once!] :: Int16) ->
                 case ds_d4eLE of { I16# x#_a4cZM [Occ=Once] ->
                 GHC.Types.I# (word2Int# (popCnt16# (int2Word# x#_a4cZM)))
                 }}]
GHC.Int.$fBitsInt16_$cpopCount
  = \ (ds_d4eLE :: Int16) ->
      case ds_d4eLE of { I16# x#_a4cZM ->
      GHC.Types.I# (word2Int# (popCnt16# (int2Word# x#_a4cZM)))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cunsafeShiftR :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eLx [Occ=Once!] :: Int16)
                 (ds1_d4eLy [Occ=Once!] :: Int) ->
                 case ds_d4eLx of { I16# x#_a4cZE [Occ=Once] ->
                 case ds1_d4eLy of { I# i#_a4cZF [Occ=Once] ->
                 GHC.Int.I16# (uncheckedIShiftRA# x#_a4cZE i#_a4cZF)
                 }
                 }}]
GHC.Int.$fBitsInt16_$cunsafeShiftR
  = \ (ds_d4eLx :: Int16) (ds1_d4eLy :: Int) ->
      case ds_d4eLx of { I16# x#_a4cZE ->
      case ds1_d4eLy of { I# i#_a4cZF ->
      GHC.Int.I16# (uncheckedIShiftRA# x#_a4cZE i#_a4cZF)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt3 :: Int16
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt3 = GHC.Int.I16# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt2 :: Int16
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fNumInt2 = GHC.Int.I16# -1#

-- RHS size: {terms: 26, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cshiftR [InlPrag=NOUSERINLINE[0]]
  :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iEl [Occ=Once!] :: Int16)
                 (w1_s4iEm [Occ=Once!] :: Int) ->
                 case w_s4iEl of { I16# ww1_s4iEp [Occ=Once*] ->
                 case w1_s4iEm of { I# ww3_s4iEt ->
                 case >=# ww3_s4iEt 64# of {
                   __DEFAULT -> GHC.Int.I16# (uncheckedIShiftRA# ww1_s4iEp ww3_s4iEt);
                   1# ->
                     case <# ww1_s4iEp 0# of {
                       __DEFAULT -> GHC.Int.I16# 0#;
                       1# -> GHC.Int.I16# -1#
                     }
                 }
                 }
                 }}]
GHC.Int.$fBitsInt16_$cshiftR
  = \ (w_s4iEl :: Int16) (w1_s4iEm :: Int) ->
      case w_s4iEl of { I16# ww1_s4iEp ->
      case w1_s4iEm of { I# ww3_s4iEt ->
      case >=# ww3_s4iEt 64# of {
        __DEFAULT -> GHC.Int.I16# (uncheckedIShiftRA# ww1_s4iEp ww3_s4iEt);
        1# ->
          case <# ww1_s4iEp 0# of {
            __DEFAULT -> GHC.Int.$fBitsInt3;
            1# -> GHC.Int.$fNumInt2
          }
      }
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cunsafeShiftL :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eLj [Occ=Once!] :: Int16)
                 (ds1_d4eLk [Occ=Once!] :: Int) ->
                 case ds_d4eLj of { I16# x#_a4cZA [Occ=Once] ->
                 case ds1_d4eLk of { I# i#_a4cZB [Occ=Once] ->
                 GHC.Int.I16# (narrow16Int# (uncheckedIShiftL# x#_a4cZA i#_a4cZB))
                 }
                 }}]
GHC.Int.$fBitsInt16_$cunsafeShiftL
  = \ (ds_d4eLj :: Int16) (ds1_d4eLk :: Int) ->
      case ds_d4eLj of { I16# x#_a4cZA ->
      case ds1_d4eLk of { I# i#_a4cZB ->
      GHC.Int.I16# (narrow16Int# (uncheckedIShiftL# x#_a4cZA i#_a4cZB))
      }
      }

-- RHS size: {terms: 20, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cshiftL :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eLc [Occ=Once!] :: Int16)
                 (ds1_d4eLd [Occ=Once!] :: Int) ->
                 case ds_d4eLc of { I16# x#_a4cZy [Occ=Once] ->
                 case ds1_d4eLd of { I# i#_a4cZz ->
                 case >=# i#_a4cZz 64# of {
                   __DEFAULT ->
                     GHC.Int.I16# (narrow16Int# (uncheckedIShiftL# x#_a4cZy i#_a4cZz));
                   1# -> GHC.Int.I16# 0#
                 }
                 }
                 }}]
GHC.Int.$fBitsInt16_$cshiftL
  = \ (ds_d4eLc :: Int16) (ds1_d4eLd :: Int) ->
      case ds_d4eLc of { I16# x#_a4cZy ->
      case ds1_d4eLd of { I# i#_a4cZz ->
      case >=# i#_a4cZz 64# of {
        __DEFAULT ->
          GHC.Int.I16# (narrow16Int# (uncheckedIShiftL# x#_a4cZy i#_a4cZz));
        1# -> GHC.Int.$fBitsInt3
      }
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cisSigned :: Int16 -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.True}]
GHC.Int.$fBitsInt16_$cisSigned = \ _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 33, types: 8, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt16_$crotate :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eKU [Occ=Once!] :: Int16)
                 (ds1_d4eKV [Occ=Once!] :: Int) ->
                 case ds_d4eKU of { I16# x#_a4cZG [Occ=Once*] ->
                 case ds1_d4eKV of { I# i#_a4cZH [Occ=Once] ->
                 case word2Int# (and# (int2Word# i#_a4cZH) 15##) of wild2_X6I {
                   __DEFAULT ->
                     let {
                       x'#_s4fC7 :: Word#
                       [LclId]
                       x'#_s4fC7 = narrow16Word# (int2Word# x#_a4cZG) } in
                     GHC.Int.I16#
                       (narrow16Int#
                          (word2Int#
                             (or#
                                (uncheckedShiftL# x'#_s4fC7 wild2_X6I)
                                (uncheckedShiftRL# x'#_s4fC7 (-# 16# wild2_X6I)))));
                   0# -> GHC.Int.I16# x#_a4cZG
                 }
                 }
                 }}]
GHC.Int.$fBitsInt16_$crotate
  = \ (ds_d4eKU :: Int16) (ds1_d4eKV :: Int) ->
      case ds_d4eKU of wild_X6u { I16# x#_a4cZG ->
      case ds1_d4eKV of { I# i#_a4cZH ->
      case word2Int# (and# (int2Word# i#_a4cZH) 15##) of wild2_X6I {
        __DEFAULT ->
          let {
            x'#_s4fC7 [Dmd=<S,U>] :: Word#
            [LclId]
            x'#_s4fC7 = narrow16Word# (int2Word# x#_a4cZG) } in
          GHC.Int.I16#
            (narrow16Int#
               (word2Int#
                  (or#
                     (uncheckedShiftL# x'#_s4fC7 wild2_X6I)
                     (uncheckedShiftRL# x'#_s4fC7 (-# 16# wild2_X6I)))));
        0# -> wild_X6u
      }
      }
      }

-- RHS size: {terms: 47, types: 11, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt16_$cshift [InlPrag=INLINE (sat-args=2)]
  :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eKL [Occ=Once!] :: Int16)
                 (ds1_d4eKM [Occ=Once!] :: Int) ->
                 case ds_d4eKL of { I16# x#_a4cZw [Occ=Once*] ->
                 case ds1_d4eKM of { I# i#_a4cZx ->
                 case >=# i#_a4cZx 0# of {
                   __DEFAULT ->
                     let {
                       b_i1AI0 :: Int#
                       [LclId]
                       b_i1AI0 = negateInt# i#_a4cZx } in
                     case >=# b_i1AI0 64# of {
                       __DEFAULT -> GHC.Int.I16# (uncheckedIShiftRA# x#_a4cZw b_i1AI0);
                       1# ->
                         case <# x#_a4cZw 0# of {
                           __DEFAULT -> GHC.Int.I16# 0#;
                           1# -> GHC.Int.I16# -1#
                         }
                     };
                   1# ->
                     case >=# i#_a4cZx 64# of {
                       __DEFAULT ->
                         GHC.Int.I16# (narrow16Int# (uncheckedIShiftL# x#_a4cZw i#_a4cZx));
                       1# -> GHC.Int.I16# 0#
                     }
                 }
                 }
                 }}]
GHC.Int.$fBitsInt16_$cshift
  = \ (ds_d4eKL :: Int16) (ds1_d4eKM :: Int) ->
      case ds_d4eKL of { I16# x#_a4cZw ->
      case ds1_d4eKM of { I# i#_a4cZx ->
      case >=# i#_a4cZx 0# of {
        __DEFAULT ->
          let {
            b_s4fC4 [Dmd=<S,U>] :: Int#
            [LclId]
            b_s4fC4 = negateInt# i#_a4cZx } in
          case >=# b_s4fC4 64# of {
            __DEFAULT -> GHC.Int.I16# (uncheckedIShiftRA# x#_a4cZw b_s4fC4);
            1# ->
              case <# x#_a4cZw 0# of {
                __DEFAULT -> GHC.Int.$fBitsInt3;
                1# -> GHC.Int.$fNumInt2
              }
          };
        1# ->
          case >=# i#_a4cZx 64# of {
            __DEFAULT ->
              GHC.Int.I16# (narrow16Int# (uncheckedIShiftL# x#_a4cZw i#_a4cZx));
            1# -> GHC.Int.$fBitsInt3
          }
      }
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$ccomplement :: Int16 -> Int16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eKH [Occ=Once!] :: Int16) ->
                 case ds_d4eKH of { I16# x#_a4cZv [Occ=Once] ->
                 GHC.Int.I16# (word2Int# (not# (int2Word# x#_a4cZv)))
                 }}]
GHC.Int.$fBitsInt16_$ccomplement
  = \ (ds_d4eKH :: Int16) ->
      case ds_d4eKH of { I16# x#_a4cZv ->
      GHC.Int.I16# (word2Int# (not# (int2Word# x#_a4cZv)))
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cxor :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eKA [Occ=Once!] :: Int16)
                 (ds1_d4eKB [Occ=Once!] :: Int16) ->
                 case ds_d4eKA of { I16# x#_a4cZt [Occ=Once] ->
                 case ds1_d4eKB of { I16# y#_a4cZu [Occ=Once] ->
                 GHC.Int.I16#
                   (word2Int# (xor# (int2Word# x#_a4cZt) (int2Word# y#_a4cZu)))
                 }
                 }}]
GHC.Int.$fBitsInt16_$cxor
  = \ (ds_d4eKA :: Int16) (ds1_d4eKB :: Int16) ->
      case ds_d4eKA of { I16# x#_a4cZt ->
      case ds1_d4eKB of { I16# y#_a4cZu ->
      GHC.Int.I16#
        (word2Int# (xor# (int2Word# x#_a4cZt) (int2Word# y#_a4cZu)))
      }
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$c.|. :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eKt [Occ=Once!] :: Int16)
                 (ds1_d4eKu [Occ=Once!] :: Int16) ->
                 case ds_d4eKt of { I16# x#_a4cZr [Occ=Once] ->
                 case ds1_d4eKu of { I16# y#_a4cZs [Occ=Once] ->
                 GHC.Int.I16#
                   (word2Int# (or# (int2Word# x#_a4cZr) (int2Word# y#_a4cZs)))
                 }
                 }}]
GHC.Int.$fBitsInt16_$c.|.
  = \ (ds_d4eKt :: Int16) (ds1_d4eKu :: Int16) ->
      case ds_d4eKt of { I16# x#_a4cZr ->
      case ds1_d4eKu of { I16# y#_a4cZs ->
      GHC.Int.I16#
        (word2Int# (or# (int2Word# x#_a4cZr) (int2Word# y#_a4cZs)))
      }
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$c.&. :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eKm [Occ=Once!] :: Int16)
                 (ds1_d4eKn [Occ=Once!] :: Int16) ->
                 case ds_d4eKm of { I16# x#_a4cZp [Occ=Once] ->
                 case ds1_d4eKn of { I16# y#_a4cZq [Occ=Once] ->
                 GHC.Int.I16#
                   (word2Int# (and# (int2Word# x#_a4cZp) (int2Word# y#_a4cZq)))
                 }
                 }}]
GHC.Int.$fBitsInt16_$c.&.
  = \ (ds_d4eKm :: Int16) (ds1_d4eKn :: Int16) ->
      case ds_d4eKm of { I16# x#_a4cZp ->
      case ds1_d4eKn of { I16# y#_a4cZq ->
      GHC.Int.I16#
        (word2Int# (and# (int2Word# x#_a4cZp) (int2Word# y#_a4cZq)))
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros :: Int16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eKi [Occ=Once!] :: Int16) ->
                 case ds_d4eKi of { I16# x#_a4cZo [Occ=Once] ->
                 GHC.Types.I# (word2Int# (ctz16# (int2Word# x#_a4cZo)))
                 }}]
GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros
  = \ (ds_d4eKi :: Int16) ->
      case ds_d4eKi of { I16# x#_a4cZo ->
      GHC.Types.I# (word2Int# (ctz16# (int2Word# x#_a4cZo)))
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros :: Int16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eKe [Occ=Once!] :: Int16) ->
                 case ds_d4eKe of { I16# x#_a4cZn [Occ=Once] ->
                 GHC.Types.I# (word2Int# (clz16# (int2Word# x#_a4cZn)))
                 }}]
GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros
  = \ (ds_d4eKe :: Int16) ->
      case ds_d4eKe of { I16# x#_a4cZn ->
      GHC.Types.I# (word2Int# (clz16# (int2Word# x#_a4cZn)))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt1 = GHC.Types.I# 16#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cfiniteBitSize :: Int16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Int.$fBitsInt1}]
GHC.Int.$fBitsInt16_$cfiniteBitSize
  = \ _ [Occ=Dead] -> GHC.Int.$fBitsInt1

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt32_$cfromInteger :: Integer -> Int32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a4cZk [Occ=Once] :: Integer) ->
                 case integerToInt i_a4cZk of wild_X6C { __DEFAULT ->
                 GHC.Int.I32# (narrow32Int# wild_X6C)
                 }}]
GHC.Int.$fNumInt32_$cfromInteger
  = \ (i_a4cZk :: Integer) ->
      case integerToInt i_a4cZk of wild_X6C { __DEFAULT ->
      GHC.Int.I32# (narrow32Int# wild_X6C)
      }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt32_$cnegate :: Int32 -> Int32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eJQ [Occ=Once!] :: Int32) ->
                 case ds_d4eJQ of { I32# x#_a4cZh [Occ=Once] ->
                 GHC.Int.I32# (narrow32Int# (negateInt# x#_a4cZh))
                 }}]
GHC.Int.$fNumInt32_$cnegate
  = \ (ds_d4eJQ :: Int32) ->
      case ds_d4eJQ of { I32# x#_a4cZh ->
      GHC.Int.I32# (narrow32Int# (negateInt# x#_a4cZh))
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt32_$c* :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eJJ [Occ=Once!] :: Int32)
                 (ds1_d4eJK [Occ=Once!] :: Int32) ->
                 case ds_d4eJJ of { I32# x#_a4cZf [Occ=Once] ->
                 case ds1_d4eJK of { I32# y#_a4cZg [Occ=Once] ->
                 GHC.Int.I32# (narrow32Int# (*# x#_a4cZf y#_a4cZg))
                 }
                 }}]
GHC.Int.$fNumInt32_$c*
  = \ (ds_d4eJJ :: Int32) (ds1_d4eJK :: Int32) ->
      case ds_d4eJJ of { I32# x#_a4cZf ->
      case ds1_d4eJK of { I32# y#_a4cZg ->
      GHC.Int.I32# (narrow32Int# (*# x#_a4cZf y#_a4cZg))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt32_$c- :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eJC [Occ=Once!] :: Int32)
                 (ds1_d4eJD [Occ=Once!] :: Int32) ->
                 case ds_d4eJC of { I32# x#_a4cZd [Occ=Once] ->
                 case ds1_d4eJD of { I32# y#_a4cZe [Occ=Once] ->
                 GHC.Int.I32# (narrow32Int# (-# x#_a4cZd y#_a4cZe))
                 }
                 }}]
GHC.Int.$fNumInt32_$c-
  = \ (ds_d4eJC :: Int32) (ds1_d4eJD :: Int32) ->
      case ds_d4eJC of { I32# x#_a4cZd ->
      case ds1_d4eJD of { I32# y#_a4cZe ->
      GHC.Int.I32# (narrow32Int# (-# x#_a4cZd y#_a4cZe))
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt32_$c+ :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eJv [Occ=Once!] :: Int32)
                 (ds1_d4eJw [Occ=Once!] :: Int32) ->
                 case ds_d4eJv of { I32# x#_a4cZb [Occ=Once] ->
                 case ds1_d4eJw of { I32# y#_a4cZc [Occ=Once] ->
                 GHC.Int.I32# (narrow32Int# (+# x#_a4cZb y#_a4cZc))
                 }
                 }}]
GHC.Int.$fNumInt32_$c+
  = \ (ds_d4eJv :: Int32) (ds1_d4eJw :: Int32) ->
      case ds_d4eJv of { I32# x#_a4cZb ->
      case ds1_d4eJw of { I32# y#_a4cZc ->
      GHC.Int.I32# (narrow32Int# (+# x#_a4cZb y#_a4cZc))
      }
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt32_$ctoInteger :: Int32 -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eJ9 [Occ=Once!] :: Int32) ->
                 case ds_d4eJ9 of { I32# x#_a4cZ5 [Occ=Once] ->
                 smallInteger x#_a4cZ5
                 }}]
GHC.Int.$fIntegralInt32_$ctoInteger
  = \ (ds_d4eJ9 :: Int32) ->
      case ds_d4eJ9 of { I32# x#_a4cZ5 -> smallInteger x#_a4cZ5 }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cpopCount :: Int32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eHG [Occ=Once!] :: Int32) ->
                 case ds_d4eHG of { I32# x#_a4cYA [Occ=Once] ->
                 GHC.Types.I# (word2Int# (popCnt32# (int2Word# x#_a4cYA)))
                 }}]
GHC.Int.$fBitsInt32_$cpopCount
  = \ (ds_d4eHG :: Int32) ->
      case ds_d4eHG of { I32# x#_a4cYA ->
      GHC.Types.I# (word2Int# (popCnt32# (int2Word# x#_a4cYA)))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cunsafeShiftR :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eHz [Occ=Once!] :: Int32)
                 (ds1_d4eHA [Occ=Once!] :: Int) ->
                 case ds_d4eHz of { I32# x#_a4cYs [Occ=Once] ->
                 case ds1_d4eHA of { I# i#_a4cYt [Occ=Once] ->
                 GHC.Int.I32# (uncheckedIShiftRA# x#_a4cYs i#_a4cYt)
                 }
                 }}]
GHC.Int.$fBitsInt32_$cunsafeShiftR
  = \ (ds_d4eHz :: Int32) (ds1_d4eHA :: Int) ->
      case ds_d4eHz of { I32# x#_a4cYs ->
      case ds1_d4eHA of { I# i#_a4cYt ->
      GHC.Int.I32# (uncheckedIShiftRA# x#_a4cYs i#_a4cYt)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt6 :: Int32
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt6 = GHC.Int.I32# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt4 :: Int32
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fNumInt4 = GHC.Int.I32# -1#

-- RHS size: {terms: 26, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cshiftR [InlPrag=NOUSERINLINE[0]]
  :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iEz [Occ=Once!] :: Int32)
                 (w1_s4iEA [Occ=Once!] :: Int) ->
                 case w_s4iEz of { I32# ww1_s4iED [Occ=Once*] ->
                 case w1_s4iEA of { I# ww3_s4iEH ->
                 case >=# ww3_s4iEH 64# of {
                   __DEFAULT -> GHC.Int.I32# (uncheckedIShiftRA# ww1_s4iED ww3_s4iEH);
                   1# ->
                     case <# ww1_s4iED 0# of {
                       __DEFAULT -> GHC.Int.I32# 0#;
                       1# -> GHC.Int.I32# -1#
                     }
                 }
                 }
                 }}]
GHC.Int.$fBitsInt32_$cshiftR
  = \ (w_s4iEz :: Int32) (w1_s4iEA :: Int) ->
      case w_s4iEz of { I32# ww1_s4iED ->
      case w1_s4iEA of { I# ww3_s4iEH ->
      case >=# ww3_s4iEH 64# of {
        __DEFAULT -> GHC.Int.I32# (uncheckedIShiftRA# ww1_s4iED ww3_s4iEH);
        1# ->
          case <# ww1_s4iED 0# of {
            __DEFAULT -> GHC.Int.$fBitsInt6;
            1# -> GHC.Int.$fNumInt4
          }
      }
      }
      }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cunsafeShiftL :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eHl [Occ=Once!] :: Int32)
                 (ds1_d4eHm [Occ=Once!] :: Int) ->
                 case ds_d4eHl of { I32# x#_a4cYo [Occ=Once] ->
                 case ds1_d4eHm of { I# i#_a4cYp [Occ=Once] ->
                 GHC.Int.I32# (narrow32Int# (uncheckedIShiftL# x#_a4cYo i#_a4cYp))
                 }
                 }}]
GHC.Int.$fBitsInt32_$cunsafeShiftL
  = \ (ds_d4eHl :: Int32) (ds1_d4eHm :: Int) ->
      case ds_d4eHl of { I32# x#_a4cYo ->
      case ds1_d4eHm of { I# i#_a4cYp ->
      GHC.Int.I32# (narrow32Int# (uncheckedIShiftL# x#_a4cYo i#_a4cYp))
      }
      }

-- RHS size: {terms: 20, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cshiftL :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eHe [Occ=Once!] :: Int32)
                 (ds1_d4eHf [Occ=Once!] :: Int) ->
                 case ds_d4eHe of { I32# x#_a4cYm [Occ=Once] ->
                 case ds1_d4eHf of { I# i#_a4cYn ->
                 case >=# i#_a4cYn 64# of {
                   __DEFAULT ->
                     GHC.Int.I32# (narrow32Int# (uncheckedIShiftL# x#_a4cYm i#_a4cYn));
                   1# -> GHC.Int.I32# 0#
                 }
                 }
                 }}]
GHC.Int.$fBitsInt32_$cshiftL
  = \ (ds_d4eHe :: Int32) (ds1_d4eHf :: Int) ->
      case ds_d4eHe of { I32# x#_a4cYm ->
      case ds1_d4eHf of { I# i#_a4cYn ->
      case >=# i#_a4cYn 64# of {
        __DEFAULT ->
          GHC.Int.I32# (narrow32Int# (uncheckedIShiftL# x#_a4cYm i#_a4cYn));
        1# -> GHC.Int.$fBitsInt6
      }
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cisSigned :: Int32 -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.True}]
GHC.Int.$fBitsInt32_$cisSigned = \ _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 33, types: 8, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt32_$crotate :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eGW [Occ=Once!] :: Int32)
                 (ds1_d4eGX [Occ=Once!] :: Int) ->
                 case ds_d4eGW of { I32# x#_a4cYu [Occ=Once*] ->
                 case ds1_d4eGX of { I# i#_a4cYv [Occ=Once] ->
                 case word2Int# (and# (int2Word# i#_a4cYv) 31##) of wild2_X74 {
                   __DEFAULT ->
                     let {
                       x'#_s4fC1 :: Word#
                       [LclId]
                       x'#_s4fC1 = narrow32Word# (int2Word# x#_a4cYu) } in
                     GHC.Int.I32#
                       (narrow32Int#
                          (word2Int#
                             (or#
                                (uncheckedShiftL# x'#_s4fC1 wild2_X74)
                                (uncheckedShiftRL# x'#_s4fC1 (-# 32# wild2_X74)))));
                   0# -> GHC.Int.I32# x#_a4cYu
                 }
                 }
                 }}]
GHC.Int.$fBitsInt32_$crotate
  = \ (ds_d4eGW :: Int32) (ds1_d4eGX :: Int) ->
      case ds_d4eGW of wild_X6Q { I32# x#_a4cYu ->
      case ds1_d4eGX of { I# i#_a4cYv ->
      case word2Int# (and# (int2Word# i#_a4cYv) 31##) of wild2_X74 {
        __DEFAULT ->
          let {
            x'#_s4fC1 [Dmd=<S,U>] :: Word#
            [LclId]
            x'#_s4fC1 = narrow32Word# (int2Word# x#_a4cYu) } in
          GHC.Int.I32#
            (narrow32Int#
               (word2Int#
                  (or#
                     (uncheckedShiftL# x'#_s4fC1 wild2_X74)
                     (uncheckedShiftRL# x'#_s4fC1 (-# 32# wild2_X74)))));
        0# -> wild_X6Q
      }
      }
      }

-- RHS size: {terms: 47, types: 11, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt32_$cshift [InlPrag=INLINE (sat-args=2)]
  :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eGN [Occ=Once!] :: Int32)
                 (ds1_d4eGO [Occ=Once!] :: Int) ->
                 case ds_d4eGN of { I32# x#_a4cYk [Occ=Once*] ->
                 case ds1_d4eGO of { I# i#_a4cYl ->
                 case >=# i#_a4cYl 0# of {
                   __DEFAULT ->
                     let {
                       b_i1AI0 :: Int#
                       [LclId]
                       b_i1AI0 = negateInt# i#_a4cYl } in
                     case >=# b_i1AI0 64# of {
                       __DEFAULT -> GHC.Int.I32# (uncheckedIShiftRA# x#_a4cYk b_i1AI0);
                       1# ->
                         case <# x#_a4cYk 0# of {
                           __DEFAULT -> GHC.Int.I32# 0#;
                           1# -> GHC.Int.I32# -1#
                         }
                     };
                   1# ->
                     case >=# i#_a4cYl 64# of {
                       __DEFAULT ->
                         GHC.Int.I32# (narrow32Int# (uncheckedIShiftL# x#_a4cYk i#_a4cYl));
                       1# -> GHC.Int.I32# 0#
                     }
                 }
                 }
                 }}]
GHC.Int.$fBitsInt32_$cshift
  = \ (ds_d4eGN :: Int32) (ds1_d4eGO :: Int) ->
      case ds_d4eGN of { I32# x#_a4cYk ->
      case ds1_d4eGO of { I# i#_a4cYl ->
      case >=# i#_a4cYl 0# of {
        __DEFAULT ->
          let {
            b_s4fBY [Dmd=<S,U>] :: Int#
            [LclId]
            b_s4fBY = negateInt# i#_a4cYl } in
          case >=# b_s4fBY 64# of {
            __DEFAULT -> GHC.Int.I32# (uncheckedIShiftRA# x#_a4cYk b_s4fBY);
            1# ->
              case <# x#_a4cYk 0# of {
                __DEFAULT -> GHC.Int.$fBitsInt6;
                1# -> GHC.Int.$fNumInt4
              }
          };
        1# ->
          case >=# i#_a4cYl 64# of {
            __DEFAULT ->
              GHC.Int.I32# (narrow32Int# (uncheckedIShiftL# x#_a4cYk i#_a4cYl));
            1# -> GHC.Int.$fBitsInt6
          }
      }
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$ccomplement :: Int32 -> Int32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eGJ [Occ=Once!] :: Int32) ->
                 case ds_d4eGJ of { I32# x#_a4cYj [Occ=Once] ->
                 GHC.Int.I32# (word2Int# (not# (int2Word# x#_a4cYj)))
                 }}]
GHC.Int.$fBitsInt32_$ccomplement
  = \ (ds_d4eGJ :: Int32) ->
      case ds_d4eGJ of { I32# x#_a4cYj ->
      GHC.Int.I32# (word2Int# (not# (int2Word# x#_a4cYj)))
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cxor :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eGC [Occ=Once!] :: Int32)
                 (ds1_d4eGD [Occ=Once!] :: Int32) ->
                 case ds_d4eGC of { I32# x#_a4cYh [Occ=Once] ->
                 case ds1_d4eGD of { I32# y#_a4cYi [Occ=Once] ->
                 GHC.Int.I32#
                   (word2Int# (xor# (int2Word# x#_a4cYh) (int2Word# y#_a4cYi)))
                 }
                 }}]
GHC.Int.$fBitsInt32_$cxor
  = \ (ds_d4eGC :: Int32) (ds1_d4eGD :: Int32) ->
      case ds_d4eGC of { I32# x#_a4cYh ->
      case ds1_d4eGD of { I32# y#_a4cYi ->
      GHC.Int.I32#
        (word2Int# (xor# (int2Word# x#_a4cYh) (int2Word# y#_a4cYi)))
      }
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$c.|. :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eGv [Occ=Once!] :: Int32)
                 (ds1_d4eGw [Occ=Once!] :: Int32) ->
                 case ds_d4eGv of { I32# x#_a4cYf [Occ=Once] ->
                 case ds1_d4eGw of { I32# y#_a4cYg [Occ=Once] ->
                 GHC.Int.I32#
                   (word2Int# (or# (int2Word# x#_a4cYf) (int2Word# y#_a4cYg)))
                 }
                 }}]
GHC.Int.$fBitsInt32_$c.|.
  = \ (ds_d4eGv :: Int32) (ds1_d4eGw :: Int32) ->
      case ds_d4eGv of { I32# x#_a4cYf ->
      case ds1_d4eGw of { I32# y#_a4cYg ->
      GHC.Int.I32#
        (word2Int# (or# (int2Word# x#_a4cYf) (int2Word# y#_a4cYg)))
      }
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$c.&. :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eGo [Occ=Once!] :: Int32)
                 (ds1_d4eGp [Occ=Once!] :: Int32) ->
                 case ds_d4eGo of { I32# x#_a4cYd [Occ=Once] ->
                 case ds1_d4eGp of { I32# y#_a4cYe [Occ=Once] ->
                 GHC.Int.I32#
                   (word2Int# (and# (int2Word# x#_a4cYd) (int2Word# y#_a4cYe)))
                 }
                 }}]
GHC.Int.$fBitsInt32_$c.&.
  = \ (ds_d4eGo :: Int32) (ds1_d4eGp :: Int32) ->
      case ds_d4eGo of { I32# x#_a4cYd ->
      case ds1_d4eGp of { I32# y#_a4cYe ->
      GHC.Int.I32#
        (word2Int# (and# (int2Word# x#_a4cYd) (int2Word# y#_a4cYe)))
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros :: Int32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eGk [Occ=Once!] :: Int32) ->
                 case ds_d4eGk of { I32# x#_a4cYc [Occ=Once] ->
                 GHC.Types.I# (word2Int# (ctz32# (int2Word# x#_a4cYc)))
                 }}]
GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros
  = \ (ds_d4eGk :: Int32) ->
      case ds_d4eGk of { I32# x#_a4cYc ->
      GHC.Types.I# (word2Int# (ctz32# (int2Word# x#_a4cYc)))
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros :: Int32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eGg [Occ=Once!] :: Int32) ->
                 case ds_d4eGg of { I32# x#_a4cYb [Occ=Once] ->
                 GHC.Types.I# (word2Int# (clz32# (int2Word# x#_a4cYb)))
                 }}]
GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros
  = \ (ds_d4eGg :: Int32) ->
      case ds_d4eGg of { I32# x#_a4cYb ->
      GHC.Types.I# (word2Int# (clz32# (int2Word# x#_a4cYb)))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt4 = GHC.Types.I# 32#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cfiniteBitSize :: Int32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Int.$fBitsInt4}]
GHC.Int.$fBitsInt32_$cfiniteBitSize
  = \ _ [Occ=Dead] -> GHC.Int.$fBitsInt4

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt64_$cfromInteger :: Integer -> Int64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_a4cY0 [Occ=Once] :: Integer) ->
                 case integerToInt i_a4cY0 of wild_X6Y { __DEFAULT ->
                 GHC.Int.I64# wild_X6Y
                 }}]
GHC.Int.$fNumInt64_$cfromInteger
  = \ (i_a4cY0 :: Integer) ->
      case integerToInt i_a4cY0 of wild_X6Y { __DEFAULT ->
      GHC.Int.I64# wild_X6Y
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt64_$cnegate :: Int64 -> Int64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eFy [Occ=Once!] :: Int64) ->
                 case ds_d4eFy of { I64# x#_a4cXX [Occ=Once] ->
                 GHC.Int.I64# (negateInt# x#_a4cXX)
                 }}]
GHC.Int.$fNumInt64_$cnegate
  = \ (ds_d4eFy :: Int64) ->
      case ds_d4eFy of { I64# x#_a4cXX ->
      GHC.Int.I64# (negateInt# x#_a4cXX)
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt64_$c* :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eFr [Occ=Once!] :: Int64)
                 (ds1_d4eFs [Occ=Once!] :: Int64) ->
                 case ds_d4eFr of { I64# x#_a4cXV [Occ=Once] ->
                 case ds1_d4eFs of { I64# y#_a4cXW [Occ=Once] ->
                 GHC.Int.I64# (*# x#_a4cXV y#_a4cXW)
                 }
                 }}]
GHC.Int.$fNumInt64_$c*
  = \ (ds_d4eFr :: Int64) (ds1_d4eFs :: Int64) ->
      case ds_d4eFr of { I64# x#_a4cXV ->
      case ds1_d4eFs of { I64# y#_a4cXW ->
      GHC.Int.I64# (*# x#_a4cXV y#_a4cXW)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt64_$c- :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eFk [Occ=Once!] :: Int64)
                 (ds1_d4eFl [Occ=Once!] :: Int64) ->
                 case ds_d4eFk of { I64# x#_a4cXT [Occ=Once] ->
                 case ds1_d4eFl of { I64# y#_a4cXU [Occ=Once] ->
                 GHC.Int.I64# (-# x#_a4cXT y#_a4cXU)
                 }
                 }}]
GHC.Int.$fNumInt64_$c-
  = \ (ds_d4eFk :: Int64) (ds1_d4eFl :: Int64) ->
      case ds_d4eFk of { I64# x#_a4cXT ->
      case ds1_d4eFl of { I64# y#_a4cXU ->
      GHC.Int.I64# (-# x#_a4cXT y#_a4cXU)
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt64_$c+ :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eFd [Occ=Once!] :: Int64)
                 (ds1_d4eFe [Occ=Once!] :: Int64) ->
                 case ds_d4eFd of { I64# x#_a4cXR [Occ=Once] ->
                 case ds1_d4eFe of { I64# y#_a4cXS [Occ=Once] ->
                 GHC.Int.I64# (+# x#_a4cXR y#_a4cXS)
                 }
                 }}]
GHC.Int.$fNumInt64_$c+
  = \ (ds_d4eFd :: Int64) (ds1_d4eFe :: Int64) ->
      case ds_d4eFd of { I64# x#_a4cXR ->
      case ds1_d4eFe of { I64# y#_a4cXS ->
      GHC.Int.I64# (+# x#_a4cXR y#_a4cXS)
      }
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt64_$ctoInteger :: Int64 -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eET [Occ=Once!] :: Int64) ->
                 case ds_d4eET of { I64# x#_a4cXM [Occ=Once] ->
                 smallInteger x#_a4cXM
                 }}]
GHC.Int.$fIntegralInt64_$ctoInteger
  = \ (ds_d4eET :: Int64) ->
      case ds_d4eET of { I64# x#_a4cXM -> smallInteger x#_a4cXM }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cpopCount :: Int64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eD3 [Occ=Once!] :: Int64) ->
                 case ds_d4eD3 of { I64# x#_a4cXh [Occ=Once] ->
                 GHC.Types.I# (word2Int# (popCnt64# (int2Word# x#_a4cXh)))
                 }}]
GHC.Int.$fBitsInt64_$cpopCount
  = \ (ds_d4eD3 :: Int64) ->
      case ds_d4eD3 of { I64# x#_a4cXh ->
      GHC.Types.I# (word2Int# (popCnt64# (int2Word# x#_a4cXh)))
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cunsafeShiftR :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eCW [Occ=Once!] :: Int64)
                 (ds1_d4eCX [Occ=Once!] :: Int) ->
                 case ds_d4eCW of { I64# x#_a4cX9 [Occ=Once] ->
                 case ds1_d4eCX of { I# i#_a4cXa [Occ=Once] ->
                 GHC.Int.I64# (uncheckedIShiftRA# x#_a4cX9 i#_a4cXa)
                 }
                 }}]
GHC.Int.$fBitsInt64_$cunsafeShiftR
  = \ (ds_d4eCW :: Int64) (ds1_d4eCX :: Int) ->
      case ds_d4eCW of { I64# x#_a4cX9 ->
      case ds1_d4eCX of { I# i#_a4cXa ->
      GHC.Int.I64# (uncheckedIShiftRA# x#_a4cX9 i#_a4cXa)
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt10 :: Int64
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt10 = GHC.Int.I64# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt6 :: Int64
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fNumInt6 = GHC.Int.I64# -1#

-- RHS size: {terms: 26, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cshiftR [InlPrag=NOUSERINLINE[0]]
  :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iEN [Occ=Once!] :: Int64)
                 (w1_s4iEO [Occ=Once!] :: Int) ->
                 case w_s4iEN of { I64# ww1_s4iER [Occ=Once*] ->
                 case w1_s4iEO of { I# ww3_s4iEV ->
                 case >=# ww3_s4iEV 64# of {
                   __DEFAULT -> GHC.Int.I64# (uncheckedIShiftRA# ww1_s4iER ww3_s4iEV);
                   1# ->
                     case <# ww1_s4iER 0# of {
                       __DEFAULT -> GHC.Int.I64# 0#;
                       1# -> GHC.Int.I64# -1#
                     }
                 }
                 }
                 }}]
GHC.Int.$fBitsInt64_$cshiftR
  = \ (w_s4iEN :: Int64) (w1_s4iEO :: Int) ->
      case w_s4iEN of { I64# ww1_s4iER ->
      case w1_s4iEO of { I# ww3_s4iEV ->
      case >=# ww3_s4iEV 64# of {
        __DEFAULT -> GHC.Int.I64# (uncheckedIShiftRA# ww1_s4iER ww3_s4iEV);
        1# ->
          case <# ww1_s4iER 0# of {
            __DEFAULT -> GHC.Int.$fBitsInt10;
            1# -> GHC.Int.$fNumInt6
          }
      }
      }
      }

-- RHS size: {terms: 12, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cunsafeShiftL :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eCI [Occ=Once!] :: Int64)
                 (ds1_d4eCJ [Occ=Once!] :: Int) ->
                 case ds_d4eCI of { I64# x#_a4cX5 [Occ=Once] ->
                 case ds1_d4eCJ of { I# i#_a4cX6 [Occ=Once] ->
                 GHC.Int.I64# (uncheckedIShiftL# x#_a4cX5 i#_a4cX6)
                 }
                 }}]
GHC.Int.$fBitsInt64_$cunsafeShiftL
  = \ (ds_d4eCI :: Int64) (ds1_d4eCJ :: Int) ->
      case ds_d4eCI of { I64# x#_a4cX5 ->
      case ds1_d4eCJ of { I# i#_a4cX6 ->
      GHC.Int.I64# (uncheckedIShiftL# x#_a4cX5 i#_a4cX6)
      }
      }

-- RHS size: {terms: 19, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cshiftL :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eCB [Occ=Once!] :: Int64)
                 (ds1_d4eCC [Occ=Once!] :: Int) ->
                 case ds_d4eCB of { I64# x#_a4cX3 [Occ=Once] ->
                 case ds1_d4eCC of { I# i#_a4cX4 ->
                 case >=# i#_a4cX4 64# of {
                   __DEFAULT -> GHC.Int.I64# (uncheckedIShiftL# x#_a4cX3 i#_a4cX4);
                   1# -> GHC.Int.I64# 0#
                 }
                 }
                 }}]
GHC.Int.$fBitsInt64_$cshiftL
  = \ (ds_d4eCB :: Int64) (ds1_d4eCC :: Int) ->
      case ds_d4eCB of { I64# x#_a4cX3 ->
      case ds1_d4eCC of { I# i#_a4cX4 ->
      case >=# i#_a4cX4 64# of {
        __DEFAULT -> GHC.Int.I64# (uncheckedIShiftL# x#_a4cX3 i#_a4cX4);
        1# -> GHC.Int.$fBitsInt10
      }
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cisSigned :: Int64 -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.True}]
GHC.Int.$fBitsInt64_$cisSigned = \ _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 31, types: 8, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt64_$crotate :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eCj [Occ=Once!] :: Int64)
                 (ds1_d4eCk [Occ=Once!] :: Int) ->
                 case ds_d4eCj of { I64# x#_a4cXb [Occ=Once*] ->
                 case ds1_d4eCk of { I# i#_a4cXc [Occ=Once] ->
                 case word2Int# (and# (int2Word# i#_a4cXc) 63##) of wild2_X7r {
                   __DEFAULT ->
                     let {
                       x'#_s4fBV :: Word#
                       [LclId]
                       x'#_s4fBV = int2Word# x#_a4cXb } in
                     GHC.Int.I64#
                       (word2Int#
                          (or#
                             (uncheckedShiftL# x'#_s4fBV wild2_X7r)
                             (uncheckedShiftRL# x'#_s4fBV (-# 64# wild2_X7r))));
                   0# -> GHC.Int.I64# x#_a4cXb
                 }
                 }
                 }}]
GHC.Int.$fBitsInt64_$crotate
  = \ (ds_d4eCj :: Int64) (ds1_d4eCk :: Int) ->
      case ds_d4eCj of wild_X7d { I64# x#_a4cXb ->
      case ds1_d4eCk of { I# i#_a4cXc ->
      case word2Int# (and# (int2Word# i#_a4cXc) 63##) of wild2_X7r {
        __DEFAULT ->
          let {
            x'#_s4fBV [Dmd=<S,U>] :: Word#
            [LclId]
            x'#_s4fBV = int2Word# x#_a4cXb } in
          GHC.Int.I64#
            (word2Int#
               (or#
                  (uncheckedShiftL# x'#_s4fBV wild2_X7r)
                  (uncheckedShiftRL# x'#_s4fBV (-# 64# wild2_X7r))));
        0# -> wild_X7d
      }
      }
      }

-- RHS size: {terms: 46, types: 11, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt64_$cshift [InlPrag=INLINE (sat-args=2)]
  :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eCa [Occ=Once!] :: Int64)
                 (ds1_d4eCb [Occ=Once!] :: Int) ->
                 case ds_d4eCa of { I64# x#_a4cX1 [Occ=Once*] ->
                 case ds1_d4eCb of { I# i#_a4cX2 ->
                 case >=# i#_a4cX2 0# of {
                   __DEFAULT ->
                     let {
                       b_i1AI0 :: Int#
                       [LclId]
                       b_i1AI0 = negateInt# i#_a4cX2 } in
                     case >=# b_i1AI0 64# of {
                       __DEFAULT -> GHC.Int.I64# (uncheckedIShiftRA# x#_a4cX1 b_i1AI0);
                       1# ->
                         case <# x#_a4cX1 0# of {
                           __DEFAULT -> GHC.Int.I64# 0#;
                           1# -> GHC.Int.I64# -1#
                         }
                     };
                   1# ->
                     case >=# i#_a4cX2 64# of {
                       __DEFAULT -> GHC.Int.I64# (uncheckedIShiftL# x#_a4cX1 i#_a4cX2);
                       1# -> GHC.Int.I64# 0#
                     }
                 }
                 }
                 }}]
GHC.Int.$fBitsInt64_$cshift
  = \ (ds_d4eCa :: Int64) (ds1_d4eCb :: Int) ->
      case ds_d4eCa of { I64# x#_a4cX1 ->
      case ds1_d4eCb of { I# i#_a4cX2 ->
      case >=# i#_a4cX2 0# of {
        __DEFAULT ->
          let {
            b_s4fBS [Dmd=<S,U>] :: Int#
            [LclId]
            b_s4fBS = negateInt# i#_a4cX2 } in
          case >=# b_s4fBS 64# of {
            __DEFAULT -> GHC.Int.I64# (uncheckedIShiftRA# x#_a4cX1 b_s4fBS);
            1# ->
              case <# x#_a4cX1 0# of {
                __DEFAULT -> GHC.Int.$fBitsInt10;
                1# -> GHC.Int.$fNumInt6
              }
          };
        1# ->
          case >=# i#_a4cX2 64# of {
            __DEFAULT -> GHC.Int.I64# (uncheckedIShiftL# x#_a4cX1 i#_a4cX2);
            1# -> GHC.Int.$fBitsInt10
          }
      }
      }
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$ccomplement :: Int64 -> Int64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eC6 [Occ=Once!] :: Int64) ->
                 case ds_d4eC6 of { I64# x#_a4cX0 [Occ=Once] ->
                 GHC.Int.I64#
                   (word2Int# (xor# (int2Word# x#_a4cX0) 18446744073709551615##))
                 }}]
GHC.Int.$fBitsInt64_$ccomplement
  = \ (ds_d4eC6 :: Int64) ->
      case ds_d4eC6 of { I64# x#_a4cX0 ->
      GHC.Int.I64#
        (word2Int# (xor# (int2Word# x#_a4cX0) 18446744073709551615##))
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cxor :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eBZ [Occ=Once!] :: Int64)
                 (ds1_d4eC0 [Occ=Once!] :: Int64) ->
                 case ds_d4eBZ of { I64# x#_a4cWY [Occ=Once] ->
                 case ds1_d4eC0 of { I64# y#_a4cWZ [Occ=Once] ->
                 GHC.Int.I64#
                   (word2Int# (xor# (int2Word# x#_a4cWY) (int2Word# y#_a4cWZ)))
                 }
                 }}]
GHC.Int.$fBitsInt64_$cxor
  = \ (ds_d4eBZ :: Int64) (ds1_d4eC0 :: Int64) ->
      case ds_d4eBZ of { I64# x#_a4cWY ->
      case ds1_d4eC0 of { I64# y#_a4cWZ ->
      GHC.Int.I64#
        (word2Int# (xor# (int2Word# x#_a4cWY) (int2Word# y#_a4cWZ)))
      }
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$c.|. :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eBS [Occ=Once!] :: Int64)
                 (ds1_d4eBT [Occ=Once!] :: Int64) ->
                 case ds_d4eBS of { I64# x#_a4cWW [Occ=Once] ->
                 case ds1_d4eBT of { I64# y#_a4cWX [Occ=Once] ->
                 GHC.Int.I64#
                   (word2Int# (or# (int2Word# x#_a4cWW) (int2Word# y#_a4cWX)))
                 }
                 }}]
GHC.Int.$fBitsInt64_$c.|.
  = \ (ds_d4eBS :: Int64) (ds1_d4eBT :: Int64) ->
      case ds_d4eBS of { I64# x#_a4cWW ->
      case ds1_d4eBT of { I64# y#_a4cWX ->
      GHC.Int.I64#
        (word2Int# (or# (int2Word# x#_a4cWW) (int2Word# y#_a4cWX)))
      }
      }

-- RHS size: {terms: 15, types: 6, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$c.&. :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eBL [Occ=Once!] :: Int64)
                 (ds1_d4eBM [Occ=Once!] :: Int64) ->
                 case ds_d4eBL of { I64# x#_a4cWU [Occ=Once] ->
                 case ds1_d4eBM of { I64# y#_a4cWV [Occ=Once] ->
                 GHC.Int.I64#
                   (word2Int# (and# (int2Word# x#_a4cWU) (int2Word# y#_a4cWV)))
                 }
                 }}]
GHC.Int.$fBitsInt64_$c.&.
  = \ (ds_d4eBL :: Int64) (ds1_d4eBM :: Int64) ->
      case ds_d4eBL of { I64# x#_a4cWU ->
      case ds1_d4eBM of { I64# y#_a4cWV ->
      GHC.Int.I64#
        (word2Int# (and# (int2Word# x#_a4cWU) (int2Word# y#_a4cWV)))
      }
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros :: Int64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eBH [Occ=Once!] :: Int64) ->
                 case ds_d4eBH of { I64# x#_a4cWT [Occ=Once] ->
                 GHC.Types.I# (word2Int# (ctz64# (int2Word# x#_a4cWT)))
                 }}]
GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
  = \ (ds_d4eBH :: Int64) ->
      case ds_d4eBH of { I64# x#_a4cWT ->
      GHC.Types.I# (word2Int# (ctz64# (int2Word# x#_a4cWT)))
      }

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros :: Int64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eBD [Occ=Once!] :: Int64) ->
                 case ds_d4eBD of { I64# x#_a4cWS [Occ=Once] ->
                 GHC.Types.I# (word2Int# (clz64# (int2Word# x#_a4cWS)))
                 }}]
GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
  = \ (ds_d4eBD :: Int64) ->
      case ds_d4eBD of { I64# x#_a4cWS ->
      GHC.Types.I# (word2Int# (clz64# (int2Word# x#_a4cWS)))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt7 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt7 = GHC.Types.I# 64#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cfiniteBitSize :: Int64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Int.$fBitsInt7}]
GHC.Int.$fBitsInt64_$cfiniteBitSize
  = \ _ [Occ=Dead] -> GHC.Int.$fBitsInt7

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
eqInt8 [InlPrag=INLINE[1] (sat-args=2)] :: Int8 -> Int8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eB9 [Occ=Once!] :: Int8)
                 (ds1_d4eBa [Occ=Once!] :: Int8) ->
                 case ds_d4eB9 of { I8# x_a4d21 [Occ=Once] ->
                 case ds1_d4eBa of { I8# y_a4d22 [Occ=Once] ->
                 tagToEnum# @ Bool (==# x_a4d21 y_a4d22)
                 }
                 }}]
eqInt8
  = \ (ds_d4eB9 :: Int8) (ds1_d4eBa :: Int8) ->
      case ds_d4eB9 of { I8# x_a4d21 ->
      case ds1_d4eBa of { I8# y_a4d22 ->
      tagToEnum# @ Bool (==# x_a4d21 y_a4d22)
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEqInt8 [InlPrag=NOUSERINLINE CONLIKE] :: Eq Int8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ -> GHC.Classes.C:Eq TYPE: Int8 eqInt8 neInt8]
GHC.Int.$fEqInt8 = GHC.Classes.C:Eq @ Int8 eqInt8 neInt8

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
gtInt8 [InlPrag=INLINE[1] (sat-args=2)] :: Int8 -> Int8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eAV [Occ=Once!] :: Int8)
                 (ds1_d4eAW [Occ=Once!] :: Int8) ->
                 case ds_d4eAV of { I8# x_a4d25 [Occ=Once] ->
                 case ds1_d4eAW of { I8# y_a4d26 [Occ=Once] ->
                 tagToEnum# @ Bool (># x_a4d25 y_a4d26)
                 }
                 }}]
gtInt8
  = \ (ds_d4eAV :: Int8) (ds1_d4eAW :: Int8) ->
      case ds_d4eAV of { I8# x_a4d25 ->
      case ds1_d4eAW of { I8# y_a4d26 ->
      tagToEnum# @ Bool (># x_a4d25 y_a4d26)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
geInt8 [InlPrag=INLINE[1] (sat-args=2)] :: Int8 -> Int8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eAO [Occ=Once!] :: Int8)
                 (ds1_d4eAP [Occ=Once!] :: Int8) ->
                 case ds_d4eAO of { I8# x_a4d27 [Occ=Once] ->
                 case ds1_d4eAP of { I8# y_a4d28 [Occ=Once] ->
                 tagToEnum# @ Bool (>=# x_a4d27 y_a4d28)
                 }
                 }}]
geInt8
  = \ (ds_d4eAO :: Int8) (ds1_d4eAP :: Int8) ->
      case ds_d4eAO of { I8# x_a4d27 ->
      case ds1_d4eAP of { I8# y_a4d28 ->
      tagToEnum# @ Bool (>=# x_a4d27 y_a4d28)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
ltInt8 [InlPrag=INLINE[1] (sat-args=2)] :: Int8 -> Int8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eAH [Occ=Once!] :: Int8)
                 (ds1_d4eAI [Occ=Once!] :: Int8) ->
                 case ds_d4eAH of { I8# x_a4d29 [Occ=Once] ->
                 case ds1_d4eAI of { I8# y_a4d2a [Occ=Once] ->
                 tagToEnum# @ Bool (<# x_a4d29 y_a4d2a)
                 }
                 }}]
ltInt8
  = \ (ds_d4eAH :: Int8) (ds1_d4eAI :: Int8) ->
      case ds_d4eAH of { I8# x_a4d29 ->
      case ds1_d4eAI of { I8# y_a4d2a ->
      tagToEnum# @ Bool (<# x_a4d29 y_a4d2a)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
leInt8 [InlPrag=INLINE[1] (sat-args=2)] :: Int8 -> Int8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eAA [Occ=Once!] :: Int8)
                 (ds1_d4eAB [Occ=Once!] :: Int8) ->
                 case ds_d4eAA of { I8# x_a4d2b [Occ=Once] ->
                 case ds1_d4eAB of { I8# y_a4d2c [Occ=Once] ->
                 tagToEnum# @ Bool (<=# x_a4d2b y_a4d2c)
                 }
                 }}]
leInt8
  = \ (ds_d4eAA :: Int8) (ds1_d4eAB :: Int8) ->
      case ds_d4eAA of { I8# x_a4d2b ->
      case ds1_d4eAB of { I8# y_a4d2c ->
      tagToEnum# @ Bool (<=# x_a4d2b y_a4d2c)
      }
      }

-- RHS size: {terms: 23, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt8_$ccompare :: Int8 -> Int8 -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fi2 [Occ=Once!] :: Int8)
                 (y_a1fi3 [Occ=Once!] :: Int8) ->
                 case x_a1fi2 of { I8# x1_a4d21 ->
                 case y_a1fi3 of { I8# y1_a4d22 ->
                 case ==# x1_a4d21 y1_a4d22 of {
                   __DEFAULT ->
                     case <=# x1_a4d21 y1_a4d22 of {
                       __DEFAULT -> GHC.Types.GT;
                       1# -> GHC.Types.LT
                     };
                   1# -> GHC.Types.EQ
                 }
                 }
                 }}]
GHC.Int.$fOrdInt8_$ccompare
  = \ (x_a1fi2 :: Int8) (y_a1fi3 :: Int8) ->
      case x_a1fi2 of { I8# x1_a4d21 ->
      case y_a1fi3 of { I8# y1_a4d22 ->
      case ==# x1_a4d21 y1_a4d22 of {
        __DEFAULT ->
          case <=# x1_a4d21 y1_a4d22 of {
            __DEFAULT -> GHC.Types.GT;
            1# -> GHC.Types.LT
          };
        1# -> GHC.Types.EQ
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt8_$cmax :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once!] :: Int8)
                 (y_a55e [Occ=Once!] :: Int8) ->
                 case x_a55d of wild_X7s { I8# x1_a4d2b [Occ=Once] ->
                 case y_a55e of wild1_X5 { I8# y1_a4d2c [Occ=Once] ->
                 case <=# x1_a4d2b y1_a4d2c of {
                   __DEFAULT -> wild_X7s;
                   1# -> wild1_X5
                 }
                 }
                 }}]
GHC.Int.$fOrdInt8_$cmax
  = \ (x_a55d :: Int8) (y_a55e :: Int8) ->
      case x_a55d of wild_X7s { I8# x1_a4d2b ->
      case y_a55e of wild1_X5 { I8# y1_a4d2c ->
      case <=# x1_a4d2b y1_a4d2c of {
        __DEFAULT -> wild_X7s;
        1# -> wild1_X5
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt8_$cmin :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m [Occ=Once!] :: Int8)
                 (y_a55n [Occ=Once!] :: Int8) ->
                 case x_a55m of wild_X7s { I8# x1_a4d2b [Occ=Once] ->
                 case y_a55n of wild1_X5 { I8# y1_a4d2c [Occ=Once] ->
                 case <=# x1_a4d2b y1_a4d2c of {
                   __DEFAULT -> wild1_X5;
                   1# -> wild_X7s
                 }
                 }
                 }}]
GHC.Int.$fOrdInt8_$cmin
  = \ (x_a55m :: Int8) (y_a55n :: Int8) ->
      case x_a55m of wild_X7s { I8# x1_a4d2b ->
      case y_a55n of wild1_X5 { I8# y1_a4d2c ->
      case <=# x1_a4d2b y1_a4d2c of {
        __DEFAULT -> wild1_X5;
        1# -> wild_X7s
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt8 [InlPrag=NOUSERINLINE CONLIKE] :: Ord Int8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Int8
                         GHC.Int.$fEqInt8
                         GHC.Int.$fOrdInt8_$ccompare
                         ltInt8
                         leInt8
                         gtInt8
                         geInt8
                         GHC.Int.$fOrdInt8_$cmax
                         GHC.Int.$fOrdInt8_$cmin]
GHC.Int.$fOrdInt8
  = GHC.Classes.C:Ord
      @ Int8
      GHC.Int.$fEqInt8
      GHC.Int.$fOrdInt8_$ccompare
      ltInt8
      leInt8
      gtInt8
      geInt8
      GHC.Int.$fOrdInt8_$cmax
      GHC.Int.$fOrdInt8_$cmin

-- RHS size: {terms: 25, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt8_$cinRange :: (Int8, Int8) -> Int8 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),1*U(U))><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eQj [Occ=Once!] :: (Int8, Int8))
                 (i_a4d1h [Occ=Once!] :: Int8) ->
                 case ds_d4eQj of { (m_a4d1f [Occ=Once!], n_a4d1g [Occ=Once!]) ->
                 case m_a4d1f of { I8# x_a4d2b [Occ=Once] ->
                 case i_a4d1h of { I8# y_a4d2c ->
                 case <=# x_a4d2b y_a4d2c of {
                   __DEFAULT -> GHC.Types.False;
                   1# ->
                     case n_a4d1g of { I8# y1_X4deJ [Occ=Once] ->
                     tagToEnum# @ Bool (<=# y_a4d2c y1_X4deJ)
                     }
                 }
                 }
                 }
                 }}]
GHC.Int.$fIxInt8_$cinRange
  = \ (ds_d4eQj :: (Int8, Int8)) (i_a4d1h :: Int8) ->
      case ds_d4eQj of { (m_a4d1f, n_a4d1g) ->
      case m_a4d1f of { I8# x_a4d2b ->
      case i_a4d1h of { I8# y_a4d2c ->
      case <=# x_a4d2b y_a4d2c of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case n_a4d1g of { I8# y1_X4deJ ->
          tagToEnum# @ Bool (<=# y_a4d2c y1_X4deJ)
          }
      }
      }
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt7 :: Int8
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fNumInt7 = GHC.Int.I8# 1#

-- RHS size: {terms: 17, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt8_$csignum :: Int8 -> Int8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4d1X [Occ=Once!] :: Int8) ->
                 case x_a4d1X of { I8# x1_a4d25 ->
                 case ># x1_a4d25 0# of {
                   __DEFAULT ->
                     case x1_a4d25 of {
                       __DEFAULT -> GHC.Int.$fNumInt9;
                       0# -> GHC.Int.$fBitsInt13
                     };
                   1# -> GHC.Int.$fNumInt7
                 }
                 }}]
GHC.Int.$fNumInt8_$csignum
  = \ (x_a4d1X :: Int8) ->
      case x_a4d1X of { I8# x1_a4d25 ->
      case ># x1_a4d25 0# of {
        __DEFAULT ->
          case x1_a4d25 of {
            __DEFAULT -> GHC.Int.$fNumInt9;
            0# -> GHC.Int.$fBitsInt13
          };
        1# -> GHC.Int.$fNumInt7
      }
      }

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt8_$cabs :: Int8 -> Int8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4d1W [Occ=Once!] :: Int8) ->
                 case x_a4d1W of wild_X7q { I8# x1_a4d27 ->
                 case >=# x1_a4d27 0# of {
                   __DEFAULT -> GHC.Int.I8# (narrow8Int# (negateInt# x1_a4d27));
                   1# -> wild_X7q
                 }
                 }}]
GHC.Int.$fNumInt8_$cabs
  = \ (x_a4d1W :: Int8) ->
      case x_a4d1W of wild_X7q { I8# x1_a4d27 ->
      case >=# x1_a4d27 0# of {
        __DEFAULT -> GHC.Int.I8# (narrow8Int# (negateInt# x1_a4d27));
        1# -> wild_X7q
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt8 [InlPrag=NOUSERINLINE CONLIKE] :: Num Int8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Int8
                     GHC.Int.$fNumInt8_$c+
                     GHC.Int.$fNumInt8_$c-
                     GHC.Int.$fNumInt8_$c*
                     GHC.Int.$fNumInt8_$cnegate
                     GHC.Int.$fNumInt8_$cabs
                     GHC.Int.$fNumInt8_$csignum
                     GHC.Int.$fNumInt8_$cfromInteger]
GHC.Int.$fNumInt8
  = GHC.Num.C:Num
      @ Int8
      GHC.Int.$fNumInt8_$c+
      GHC.Int.$fNumInt8_$c-
      GHC.Int.$fNumInt8_$c*
      GHC.Int.$fNumInt8_$cnegate
      GHC.Int.$fNumInt8_$cabs
      GHC.Int.$fNumInt8_$csignum
      GHC.Int.$fNumInt8_$cfromInteger

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt12 :: Maybe Int
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt12 = GHC.Base.Just @ Int GHC.Int.$fBitsInt11

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cbitSizeMaybe :: Int8 -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Int.$fBitsInt12}]
GHC.Int.$fBitsInt8_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> GHC.Int.$fBitsInt12

-- RHS size: {terms: 16, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cbit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Int8
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once!] :: Int) ->
                 case i_a1A6g of { I# i#_a4d0T ->
                 case >=# i#_a4d0T 64# of {
                   __DEFAULT ->
                     GHC.Int.I8# (narrow8Int# (uncheckedIShiftL# 1# i#_a4d0T));
                   1# -> GHC.Int.I8# 0#
                 }
                 }}]
GHC.Int.$fBitsInt8_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# i#_a4d0T ->
      case >=# i#_a4d0T 64# of {
        __DEFAULT ->
          GHC.Int.I8# (narrow8Int# (uncheckedIShiftL# 1# i#_a4d0T));
        1# -> GHC.Int.$fBitsInt13
      }
      }

-- RHS size: {terms: 29, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: Int8 -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A6h [Occ=Once!] :: Int8)
                 (i_a1A6i [Occ=Once!] :: Int) ->
                 case x_a1A6h of { I8# x#_a4d0J [Occ=Once] ->
                 case i_a1A6i of { I# i#_a4d0T ->
                 case >=# i#_a4d0T 64# of {
                   __DEFAULT ->
                     neInt8
                       (GHC.Int.I8#
                          (word2Int#
                             (and#
                                (int2Word# x#_a4d0J)
                                (int2Word# (narrow8Int# (uncheckedIShiftL# 1# i#_a4d0T))))))
                       (GHC.Int.I8# 0#);
                   1# -> neInt8 (GHC.Int.I8# 0#) (GHC.Int.I8# 0#)
                 }
                 }
                 }}]
GHC.Int.$fBitsInt8_$ctestBit
  = \ (x_a1A6h :: Int8) (i_a1A6i :: Int) ->
      case x_a1A6h of { I8# x#_a4d0J ->
      case i_a1A6i of { I# i#_a4d0T ->
      case >=# i#_a4d0T 64# of {
        __DEFAULT ->
          case word2Int#
                 (and#
                    (int2Word# x#_a4d0J)
                    (int2Word# (narrow8Int# (uncheckedIShiftL# 1# i#_a4d0T))))
          of {
            __DEFAULT -> GHC.Types.True;
            0# -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 34, types: 8, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt8_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once!] :: Int8)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case x_a1A54 of { I8# x#_a4d10 ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 let {
                   x'#_a4d12 :: Word#
                   [LclId]
                   x'#_a4d12 = narrow8Word# (int2Word# x#_a4d10) } in
                 case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 7##)
                 of wild2_X6m {
                   __DEFAULT ->
                     GHC.Int.I8#
                       (narrow8Int#
                          (word2Int#
                             (or#
                                (uncheckedShiftL# x'#_a4d12 wild2_X6m)
                                (uncheckedShiftRL# x'#_a4d12 (-# 8# wild2_X6m)))));
                   0# -> GHC.Int.I8# x#_a4d10
                 }
                 }
                 }}]
GHC.Int.$fBitsInt8_$crotateR
  = \ (eta_B2 :: Int8) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X68 { I8# x#_a4d10 ->
      case eta1_B1 of { I# x1_i1AMT ->
      case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 7##)
      of wild2_X6m {
        __DEFAULT ->
          let {
            x'#_s4fBP [Dmd=<S,U>] :: Word#
            [LclId]
            x'#_s4fBP = narrow8Word# (int2Word# x#_a4d10) } in
          GHC.Int.I8#
            (narrow8Int#
               (word2Int#
                  (or#
                     (uncheckedShiftL# x'#_s4fBP wild2_X6m)
                     (uncheckedShiftRL# x'#_s4fBP (-# 8# wild2_X6m)))));
        0# -> wild_X68
      }
      }
      }

-- RHS size: {terms: 25, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Int8)
                 (i_a1A4T [Occ=Once!] :: Int) ->
                 case x_a1A4S of { I8# x#_a4d0N [Occ=Once*] ->
                 case i_a1A4T of { I# i#_a4d0T ->
                 case >=# i#_a4d0T 64# of {
                   __DEFAULT ->
                     GHC.Int.I8#
                       (word2Int#
                          (xor#
                             (int2Word# x#_a4d0N)
                             (int2Word# (narrow8Int# (uncheckedIShiftL# 1# i#_a4d0T)))));
                   1# -> GHC.Int.I8# x#_a4d0N
                 }
                 }
                 }}]
GHC.Int.$fBitsInt8_$ccomplementBit
  = \ (eta_B2 :: Int8) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6b { I8# x#_a4d0N ->
      case eta1_B1 of { I# i#_a4d0T ->
      case >=# i#_a4d0T 64# of {
        __DEFAULT ->
          GHC.Int.I8#
            (word2Int#
               (xor#
                  (int2Word# x#_a4d0N)
                  (int2Word# (narrow8Int# (uncheckedIShiftL# 1# i#_a4d0T)))));
        1# -> wild_X6b
      }
      }
      }

-- RHS size: {terms: 31, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Int8)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of { I8# x#_a4d0J [Occ=Once*] ->
                 case i_a1A4R of { I# i#_a4d0T ->
                 case >=# i#_a4d0T 64# of {
                   __DEFAULT ->
                     GHC.Int.I8#
                       (word2Int#
                          (and#
                             (int2Word# x#_a4d0J)
                             (not# (int2Word# (narrow8Int# (uncheckedIShiftL# 1# i#_a4d0T))))));
                   1# ->
                     GHC.Int.I8#
                       (word2Int# (and# (int2Word# x#_a4d0J) 18446744073709551615##))
                 }
                 }
                 }}]
GHC.Int.$fBitsInt8_$cclearBit
  = \ (eta_B2 :: Int8) (eta1_B1 :: Int) ->
      case eta_B2 of { I8# x#_a4d0J ->
      case eta1_B1 of { I# i#_a4d0T ->
      case >=# i#_a4d0T 64# of {
        __DEFAULT ->
          GHC.Int.I8#
            (word2Int#
               (and#
                  (int2Word# x#_a4d0J)
                  (not# (int2Word# (narrow8Int# (uncheckedIShiftL# 1# i#_a4d0T))))));
        1# ->
          GHC.Int.I8#
            (word2Int# (and# (int2Word# x#_a4d0J) 18446744073709551615##))
      }
      }
      }

-- RHS size: {terms: 25, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Int8)
                 (i_a1A4P [Occ=Once!] :: Int) ->
                 case x_a1A4O of { I8# x#_a4d0L [Occ=Once*] ->
                 case i_a1A4P of { I# i#_a4d0T ->
                 case >=# i#_a4d0T 64# of {
                   __DEFAULT ->
                     GHC.Int.I8#
                       (word2Int#
                          (or#
                             (int2Word# x#_a4d0L)
                             (int2Word# (narrow8Int# (uncheckedIShiftL# 1# i#_a4d0T)))));
                   1# -> GHC.Int.I8# x#_a4d0L
                 }
                 }
                 }}]
GHC.Int.$fBitsInt8_$csetBit
  = \ (eta_B2 :: Int8) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6c { I8# x#_a4d0L ->
      case eta1_B1 of { I# i#_a4d0T ->
      case >=# i#_a4d0T 64# of {
        __DEFAULT ->
          GHC.Int.I8#
            (word2Int#
               (or#
                  (int2Word# x#_a4d0L)
                  (int2Word# (narrow8Int# (uncheckedIShiftL# 1# i#_a4d0T)))));
        1# -> wild_X6c
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Int8 -> Int -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Int.$fBitsInt8_$crotate}]
GHC.Int.$fBitsInt8_$crotateL = GHC.Int.$fBitsInt8_$crotate

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt8 [InlPrag=NOUSERINLINE CONLIKE] :: Bits Int8
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Int8
                        GHC.Int.$fEqInt8
                        GHC.Int.$fBitsInt8_$c.&.
                        GHC.Int.$fBitsInt8_$c.|.
                        GHC.Int.$fBitsInt8_$cxor
                        GHC.Int.$fBitsInt8_$ccomplement
                        GHC.Int.$fBitsInt8_$cshift
                        GHC.Int.$fBitsInt8_$crotate
                        GHC.Int.$fBitsInt13
                        GHC.Int.$fBitsInt8_$cbit
                        GHC.Int.$fBitsInt8_$csetBit
                        GHC.Int.$fBitsInt8_$cclearBit
                        GHC.Int.$fBitsInt8_$ccomplementBit
                        GHC.Int.$fBitsInt8_$ctestBit
                        GHC.Int.$fBitsInt8_$cbitSizeMaybe
                        GHC.Int.$fBitsInt8_$cfiniteBitSize
                        GHC.Int.$fBitsInt8_$cisSigned
                        GHC.Int.$fBitsInt8_$cshiftL
                        GHC.Int.$fBitsInt8_$cunsafeShiftL
                        GHC.Int.$fBitsInt8_$cshiftR
                        GHC.Int.$fBitsInt8_$cunsafeShiftR
                        GHC.Int.$fBitsInt8_$crotateL
                        GHC.Int.$fBitsInt8_$crotateR
                        GHC.Int.$fBitsInt8_$cpopCount]
GHC.Int.$fBitsInt8
  = Data.Bits.C:Bits
      @ Int8
      GHC.Int.$fEqInt8
      GHC.Int.$fBitsInt8_$c.&.
      GHC.Int.$fBitsInt8_$c.|.
      GHC.Int.$fBitsInt8_$cxor
      GHC.Int.$fBitsInt8_$ccomplement
      GHC.Int.$fBitsInt8_$cshift
      GHC.Int.$fBitsInt8_$crotate
      GHC.Int.$fBitsInt13
      GHC.Int.$fBitsInt8_$cbit
      GHC.Int.$fBitsInt8_$csetBit
      GHC.Int.$fBitsInt8_$cclearBit
      GHC.Int.$fBitsInt8_$ccomplementBit
      GHC.Int.$fBitsInt8_$ctestBit
      GHC.Int.$fBitsInt8_$cbitSizeMaybe
      GHC.Int.$fBitsInt8_$cfiniteBitSize
      GHC.Int.$fBitsInt8_$cisSigned
      GHC.Int.$fBitsInt8_$cshiftL
      GHC.Int.$fBitsInt8_$cunsafeShiftL
      GHC.Int.$fBitsInt8_$cshiftR
      GHC.Int.$fBitsInt8_$cunsafeShiftR
      GHC.Int.$fBitsInt8_$crotateL
      GHC.Int.$fBitsInt8_$crotateR
      GHC.Int.$fBitsInt8_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt8 [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Int8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Int8
                              GHC.Int.$fBitsInt8
                              GHC.Int.$fBitsInt8_$cfiniteBitSize
                              GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros
                              GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros]
GHC.Int.$fFiniteBitsInt8
  = Data.Bits.C:FiniteBits
      @ Int8
      GHC.Int.$fBitsInt8
      GHC.Int.$fBitsInt8_$cfiniteBitSize
      GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros
      GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros

Rec {
-- RHS size: {terms: 20, types: 30, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt8_go [Occ=LoopBreaker]
  :: [(Int, String)] -> [(Int8, String)]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
GHC.Int.$fReadInt8_go
  = \ (ds_i1y1c :: [(Int, String)]) ->
      case ds_i1y1c of {
        [] -> GHC.Types.[] @ (Int8, String);
        : y_i1y1h ys_i1y1i ->
          case y_i1y1h of { (x_a4d19, r_a4d1a) ->
          GHC.Types.:
            @ (Int8, String)
            (case x_a4d19 of { I# x#_a4d3r ->
             GHC.Int.I8# (narrow8Int# x#_a4d3r)
             },
             r_a4d1a)
            (GHC.Int.$fReadInt8_go ys_i1y1i)
          }
      }
end Rec }

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt8_$creadsPrec :: Int -> ReadS Int8
[GblId,
 Arity=2,
 Str=<L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 90 0}]
GHC.Int.$fReadInt8_$creadsPrec
  = \ (p_a4d17 :: Int) (s_a4d18 :: String) ->
      GHC.Int.$fReadInt8_go
        (Text.ParserCombinators.ReadP.run
           @ Int
           (GHC.Read.$fReadInt_$sreadNumber
              GHC.Read.$fReadInt2
              p_a4d17
              @ Int
              (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Int))
           s_a4d18)

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt13
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Int8 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,U><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_X3tuA [Occ=Once]
                    :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_s3ofG)
                 (eta_B1 [Occ=Once]
                    :: Int8 -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ Int8 (GHC.Int.$fReadInt8_$creadsPrec n_X3tuA) @ b_s3ofG eta_B1
                 of
                 { (# ww1_s3oiG [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
                 }}]
GHC.Int.$fReadInt13
  = \ (n_X3tuA :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_s3ofG)
      (eta_B1 :: Int8 -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ Int8 (GHC.Int.$fReadInt8_$creadsPrec n_X3tuA) @ b_s3ofG eta_B1
      of
      { (# ww1_s3oiG #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fIxInt1 = GHC.Types.I# 0#

-- RHS size: {terms: 4, types: 5, coercions: 15, joins: 0/0}
GHC.Int.$fReadInt12 :: Text.ParserCombinators.ReadP.P [Int8]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
GHC.Int.$fReadInt12
  = ((((list
          @ Int8
          (GHC.Int.$fReadInt13
           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Int8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        <Int8>_R)
                   :: (Text.ParserCombinators.ReadPrec.Prec
                       -> forall b.
                          (Int8 -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)
                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int8 :: *))))
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Int8]>_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Int8] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [Int8] :: *)))
        GHC.Int.$fIxInt1)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Int8]>_R
             :: (Text.ParserCombinators.ReadP.ReadP [Int8] :: *)
                ~R# (forall b.
                     ([Int8] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)))
      @ [Int8]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [Int8])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt8_$creadList :: ReadS [Int8]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.Int.$fReadInt8_$creadList
  = Text.ParserCombinators.ReadP.run @ [Int8] GHC.Int.$fReadInt12

-- RHS size: {terms: 10, types: 19, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt11
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([Int8] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,A><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_s3ofG)
                 (w1_s3ofH [Occ=Once]
                    :: [Int8] -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ [Int8] GHC.Int.$fReadInt8_$creadList @ b_s3ofG w1_s3ofH
                 of
                 { (# ww1_s3oiG [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
                 }}]
GHC.Int.$fReadInt11
  = \ _ [Occ=Dead]
      (@ b_s3ofG)
      (w1_s3ofH :: [Int8] -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ [Int8] GHC.Int.$fReadInt8_$creadList @ b_s3ofG w1_s3ofH
      of
      { (# ww1_s3oiG #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
      }

-- RHS size: {terms: 5, types: 1, coercions: 20, joins: 0/0}
GHC.Int.$fReadInt8 [InlPrag=NOUSERINLINE CONLIKE] :: Read Int8
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: Int8
                       GHC.Int.$fReadInt8_$creadsPrec
                       GHC.Int.$fReadInt8_$creadList
                       GHC.Int.$fReadInt13
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                    <Int8>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int8 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int8 :: *))
                       GHC.Int.$fReadInt11
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int8]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <[Int8]>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int8] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [Int8] :: *))]
GHC.Int.$fReadInt8
  = GHC.Read.C:Read
      @ Int8
      GHC.Int.$fReadInt8_$creadsPrec
      GHC.Int.$fReadInt8_$creadList
      (GHC.Int.$fReadInt13
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                    <Int8>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int8 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int8 :: *)))
      (GHC.Int.$fReadInt11
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int8]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      <[Int8]>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int8] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [Int8] :: *)))

-- RHS size: {terms: 34, types: 15, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt8_$cquot [InlPrag=NOUSERINLINE[0]]
  :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iF4 [Occ=Once!] :: Int8)
                 (w1_s4iF5 [Occ=Once!] :: Int8) ->
                 case w_s4iF4 of { I8# ww1_s4iF8 [Occ=Once*] ->
                 case w1_s4iF5 of { I8# ww3_s4iFc [Occ=Once!] ->
                 case ww3_s4iFc of wild_XcX {
                   __DEFAULT ->
                     case quotInt# ww1_s4iF8 wild_XcX of wild1_X2a { __DEFAULT ->
                     GHC.Int.I8# (narrow8Int# wild1_X2a)
                     };
                   -1# ->
                     case ww1_s4iF8 of wild1_Xd5 {
                       __DEFAULT -> GHC.Int.I8# (narrow8Int# (quotInt# wild1_Xd5 -1#));
                       -128# -> case overflowError of { }
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt8_$cquot
  = \ (w_s4iF4 :: Int8) (w1_s4iF5 :: Int8) ->
      case w_s4iF4 of { I8# ww1_s4iF8 ->
      case w1_s4iF5 of { I8# ww3_s4iFc ->
      case ww3_s4iFc of wild_XcX {
        __DEFAULT ->
          case quotInt# ww1_s4iF8 wild_XcX of wild1_X2a { __DEFAULT ->
          GHC.Int.I8# (narrow8Int# wild1_X2a)
          };
        -1# ->
          case ww1_s4iF8 of wild1_Xd5 {
            __DEFAULT -> GHC.Int.I8# (narrow8Int# (quotInt# wild1_Xd5 -1#));
            -128# -> case overflowError of wild2_00 { }
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 21, types: 9, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt8_$crem :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eQB [Occ=Once!] :: Int8)
                 (y_a4d1n [Occ=Once!] :: Int8) ->
                 case ds_d4eQB of { I8# x#_a4d1m [Occ=Once] ->
                 case y_a4d1n of { I8# y#_a4d1o [Occ=Once!] ->
                 case y#_a4d1o of wild2_XcZ {
                   __DEFAULT ->
                     case remInt# x#_a4d1m wild2_XcZ of wild3_X2a { __DEFAULT ->
                     GHC.Int.I8# (narrow8Int# wild3_X2a)
                     };
                   0# -> divZeroError @ Int8
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt8_$crem
  = \ (ds_d4eQB :: Int8) (y_a4d1n :: Int8) ->
      case ds_d4eQB of { I8# x#_a4d1m ->
      case y_a4d1n of { I8# y#_a4d1o ->
      case y#_a4d1o of wild2_XcZ {
        __DEFAULT ->
          case remInt# x#_a4d1m wild2_XcZ of wild3_X2a { __DEFAULT ->
          GHC.Int.I8# (narrow8Int# wild3_X2a)
          };
        0# -> divZeroError @ Int8
      }
      }
      }

-- RHS size: {terms: 29, types: 12, coercions: 0, joins: 0/0}
GHC.Int.$w$cdiv3 [InlPrag=NOUSERINLINE[0]] :: Int# -> Int# -> Int#
[GblId,
 Arity=2,
 Str=<S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 81] 132 0}]
GHC.Int.$w$cdiv3
  = \ (ww_s4iFm :: Int#) (ww1_s4iFq :: Int#) ->
      case ww1_s4iFq of wild_Xd2 {
        __DEFAULT ->
          case divInt# ww_s4iFm wild_Xd2 of wild1_X2c { __DEFAULT ->
          narrow8Int# wild1_X2c
          };
        -1# ->
          case ww_s4iFm of wild1_Xda {
            __DEFAULT ->
              case divInt# wild1_Xda -1# of wild2_X2c { __DEFAULT ->
              narrow8Int# wild2_X2c
              };
            -128# -> case overflowError of wild2_00 { }
          };
        0# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt8_$cdiv [InlPrag=NOUSERINLINE[0]]
  :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iFi [Occ=Once!] :: Int8)
                 (w1_s4iFj [Occ=Once!] :: Int8) ->
                 case w_s4iFi of { I8# ww1_s4iFm [Occ=Once] ->
                 case w1_s4iFj of { I8# ww3_s4iFq [Occ=Once] ->
                 case GHC.Int.$w$cdiv3 ww1_s4iFm ww3_s4iFq of ww4_s4iFu
                 { __DEFAULT ->
                 GHC.Int.I8# ww4_s4iFu
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt8_$cdiv
  = \ (w_s4iFi :: Int8) (w1_s4iFj :: Int8) ->
      case w_s4iFi of { I8# ww1_s4iFm ->
      case w1_s4iFj of { I8# ww3_s4iFq ->
      case GHC.Int.$w$cdiv3 ww1_s4iFm ww3_s4iFq of ww4_s4iFu
      { __DEFAULT ->
      GHC.Int.I8# ww4_s4iFu
      }
      }
      }

-- RHS size: {terms: 22, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt8_$cmod [InlPrag=NOUSERINLINE[0]]
  :: Int8 -> Int8 -> Int8
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iFw [Occ=Once!] :: Int8)
                 (w1_s4iFx [Occ=Once!] :: Int8) ->
                 case w_s4iFw of { I8# ww1_s4iFA [Occ=Once] ->
                 case w1_s4iFx of { I8# ww3_s4iFE [Occ=Once!] ->
                 case ww3_s4iFE of wild_Xd4 {
                   __DEFAULT ->
                     case modInt# ww1_s4iFA wild_Xd4 of wild1_X2c { __DEFAULT ->
                     GHC.Int.I8# (narrow8Int# wild1_X2c)
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt8_$cmod
  = \ (w_s4iFw :: Int8) (w1_s4iFx :: Int8) ->
      case w_s4iFw of { I8# ww1_s4iFA ->
      case w1_s4iFx of { I8# ww3_s4iFE ->
      case ww3_s4iFE of wild_Xd4 {
        __DEFAULT ->
          case modInt# ww1_s4iFA wild_Xd4 of wild1_X2c { __DEFAULT ->
          GHC.Int.I8# (narrow8Int# wild1_X2c)
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
lvl6_r4kPx :: (Int8, Int8)
[GblId, Str=m, Unf=OtherCon []]
lvl6_r4kPx = (overflowError @ Int8, GHC.Int.$fBitsInt13)

-- RHS size: {terms: 44, types: 29, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt8_$cquotRem [InlPrag=NOUSERINLINE[0]]
  :: Int8 -> Int8 -> (Int8, Int8)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iFK [Occ=Once!] :: Int8)
                 (w1_s4iFL [Occ=Once!] :: Int8) ->
                 case w_s4iFK of { I8# ww1_s4iFO [Occ=Once*] ->
                 case w1_s4iFL of { I8# ww3_s4iFS [Occ=Once!] ->
                 case ww3_s4iFS of wild_Xd9 {
                   __DEFAULT ->
                     case quotRemInt# ww1_s4iFO wild_Xd9 of
                     { (# ipv_s4eZq [Occ=Once], ipv1_s4eZr [Occ=Once] #) ->
                     (GHC.Int.I8# (narrow8Int# ipv_s4eZq),
                      GHC.Int.I8# (narrow8Int# ipv1_s4eZr))
                     };
                   -1# ->
                     case ww1_s4iFO of wild1_Xdh {
                       __DEFAULT ->
                         case quotRemInt# wild1_Xdh -1# of
                         { (# ipv_s4eZq [Occ=Once], ipv1_s4eZr [Occ=Once] #) ->
                         (GHC.Int.I8# (narrow8Int# ipv_s4eZq),
                          GHC.Int.I8# (narrow8Int# ipv1_s4eZr))
                         };
                       -128# -> (overflowError @ Int8, GHC.Int.$fBitsInt13)
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt8_$cquotRem
  = \ (w_s4iFK :: Int8) (w1_s4iFL :: Int8) ->
      case w_s4iFK of { I8# ww1_s4iFO ->
      case w1_s4iFL of { I8# ww3_s4iFS ->
      case ww3_s4iFS of wild_Xd9 {
        __DEFAULT ->
          case quotRemInt# ww1_s4iFO wild_Xd9 of
          { (# ipv_s4eZq, ipv1_s4eZr #) ->
          (GHC.Int.I8# (narrow8Int# ipv_s4eZq),
           GHC.Int.I8# (narrow8Int# ipv1_s4eZr))
          };
        -1# ->
          case ww1_s4iFO of wild1_Xdh {
            __DEFAULT ->
              case quotRemInt# wild1_Xdh -1# of { (# ipv_s4eZq, ipv1_s4eZr #) ->
              (GHC.Int.I8# (narrow8Int# ipv_s4eZq),
               GHC.Int.I8# (narrow8Int# ipv1_s4eZr))
              };
            -128# -> lvl6_r4kPx
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 166, types: 101, coercions: 0, joins: 1/1}
GHC.Int.$w$cdivMod3 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> (# Int8, Int8 #)
[GblId,
 Arity=2,
 Str=<S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 363 30}]
GHC.Int.$w$cdivMod3
  = \ (ww_s4iG2 :: Int#) (ww1_s4iG6 :: Int#) ->
      case ww1_s4iG6 of wild_Xde {
        __DEFAULT ->
          join {
            $j_s4fM2 [Dmd=<L,1*U(U,U)>] :: (# Int8, Int8 #)
            [LclId[JoinId(0)]]
            $j_s4fM2
              = case ># ww_s4iG2 0# of {
                  __DEFAULT ->
                    case <# ww_s4iG2 0# of {
                      __DEFAULT ->
                        case quotRemInt# ww_s4iG2 wild_Xde of
                        { (# ipv_s4eZz, ipv1_s4eZA #) ->
                        (# GHC.Int.I8# (narrow8Int# ipv_s4eZz),
                           GHC.Int.I8# (narrow8Int# ipv1_s4eZA) #)
                        };
                      1# ->
                        case ># wild_Xde 0# of {
                          __DEFAULT ->
                            case quotRemInt# ww_s4iG2 wild_Xde of
                            { (# ipv_s4eZz, ipv1_s4eZA #) ->
                            (# GHC.Int.I8# (narrow8Int# ipv_s4eZz),
                               GHC.Int.I8# (narrow8Int# ipv1_s4eZA) #)
                            };
                          1# ->
                            case quotRemInt# (+# ww_s4iG2 1#) wild_Xde of
                            { (# ipv_i4eEn, ipv1_i4eEo #) ->
                            (# GHC.Int.I8# (narrow8Int# (-# ipv_i4eEn 1#)),
                               GHC.Int.I8# (narrow8Int# (-# (+# ipv1_i4eEo wild_Xde) 1#)) #)
                            }
                        }
                    };
                  1# ->
                    case <# wild_Xde 0# of {
                      __DEFAULT ->
                        case <# ww_s4iG2 0# of {
                          __DEFAULT ->
                            case quotRemInt# ww_s4iG2 wild_Xde of
                            { (# ipv_s4eZz, ipv1_s4eZA #) ->
                            (# GHC.Int.I8# (narrow8Int# ipv_s4eZz),
                               GHC.Int.I8# (narrow8Int# ipv1_s4eZA) #)
                            };
                          1# ->
                            case ># wild_Xde 0# of {
                              __DEFAULT ->
                                case quotRemInt# ww_s4iG2 wild_Xde of
                                { (# ipv_s4eZz, ipv1_s4eZA #) ->
                                (# GHC.Int.I8# (narrow8Int# ipv_s4eZz),
                                   GHC.Int.I8# (narrow8Int# ipv1_s4eZA) #)
                                };
                              1# ->
                                case quotRemInt# (+# ww_s4iG2 1#) wild_Xde of
                                { (# ipv_i4eEv, ipv1_i4eEw #) ->
                                (# GHC.Int.I8# (narrow8Int# (-# ipv_i4eEv 1#)),
                                   GHC.Int.I8# (narrow8Int# (-# (+# ipv1_i4eEw wild_Xde) 1#)) #)
                                }
                            }
                        };
                      1# ->
                        case quotRemInt# (-# ww_s4iG2 1#) wild_Xde of
                        { (# ipv_i4eEA, ipv1_i4eEB #) ->
                        (# GHC.Int.I8# (narrow8Int# (-# ipv_i4eEA 1#)),
                           GHC.Int.I8# (narrow8Int# (+# (+# ipv1_i4eEB wild_Xde) 1#)) #)
                        }
                    }
                } } in
          case wild_Xde of {
            __DEFAULT -> jump $j_s4fM2;
            -1# ->
              case ww_s4iG2 of {
                __DEFAULT -> jump $j_s4fM2;
                -128# -> (# overflowError @ Int8, GHC.Int.$fBitsInt13 #)
              }
          };
        0# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 16, types: 15, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt8_$cdivMod [InlPrag=NOUSERINLINE[0]]
  :: Int8 -> Int8 -> (Int8, Int8)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iFY [Occ=Once!] :: Int8)
                 (w1_s4iFZ [Occ=Once!] :: Int8) ->
                 case w_s4iFY of { I8# ww1_s4iG2 [Occ=Once] ->
                 case w1_s4iFZ of { I8# ww3_s4iG6 [Occ=Once] ->
                 case GHC.Int.$w$cdivMod3 ww1_s4iG2 ww3_s4iG6 of
                 { (# ww5_s4iKy [Occ=Once], ww6_s4iKz [Occ=Once] #) ->
                 (ww5_s4iKy, ww6_s4iKz)
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt8_$cdivMod
  = \ (w_s4iFY :: Int8) (w1_s4iFZ :: Int8) ->
      case w_s4iFY of { I8# ww1_s4iG2 ->
      case w1_s4iFZ of { I8# ww3_s4iG6 ->
      case GHC.Int.$w$cdivMod3 ww1_s4iG2 ww3_s4iG6 of
      { (# ww5_s4iKy, ww6_s4iKz #) ->
      (ww5_s4iKy, ww6_s4iKz)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fRealInt1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Int.$fRealInt1 = 1

-- RHS size: {terms: 15, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fRealInt8_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Int8 -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iGc [Occ=Once!] :: Int8) ->
                 case w_s4iGc of { I8# ww1_s4iGf [Occ=Once] ->
                 case GHC.Real.$w$sreduce
                        (timesInteger (smallInteger ww1_s4iGf) GHC.Int.$fRealInt1)
                        GHC.Int.$fRealInt1
                 of
                 { (# ww3_s4iKB [Occ=Once], ww4_s4iKC [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s4iKB ww4_s4iKC
                 }
                 }}]
GHC.Int.$fRealInt8_$ctoRational
  = \ (w_s4iGc :: Int8) ->
      case w_s4iGc of { I8# ww1_s4iGf ->
      case GHC.Real.$w$sreduce
             (timesInteger (smallInteger ww1_s4iGf) GHC.Int.$fRealInt1)
             GHC.Int.$fRealInt1
      of
      { (# ww3_s4iKB, ww4_s4iKC #) ->
      GHC.Real.:% @ Integer ww3_s4iKB ww4_s4iKC
      }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fRealInt8 [InlPrag=NOUSERINLINE CONLIKE] :: Real Int8
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Int8
                       GHC.Int.$fNumInt8
                       GHC.Int.$fOrdInt8
                       GHC.Int.$fRealInt8_$ctoRational]
GHC.Int.$fRealInt8
  = GHC.Real.C:Real
      @ Int8
      GHC.Int.$fNumInt8
      GHC.Int.$fOrdInt8
      GHC.Int.$fRealInt8_$ctoRational

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Int8
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Int8
                           GHC.Int.$fRealInt8
                           GHC.Int.$fEnumInt8
                           GHC.Int.$fIntegralInt8_$cquot
                           GHC.Int.$fIntegralInt8_$crem
                           GHC.Int.$fIntegralInt8_$cdiv
                           GHC.Int.$fIntegralInt8_$cmod
                           GHC.Int.$fIntegralInt8_$cquotRem
                           GHC.Int.$fIntegralInt8_$cdivMod
                           GHC.Int.$fIntegralInt8_$ctoInteger]
GHC.Int.$fIntegralInt8
  = GHC.Real.C:Integral
      @ Int8
      GHC.Int.$fRealInt8
      GHC.Int.$fEnumInt8
      GHC.Int.$fIntegralInt8_$cquot
      GHC.Int.$fIntegralInt8_$crem
      GHC.Int.$fIntegralInt8_$cdiv
      GHC.Int.$fIntegralInt8_$cmod
      GHC.Int.$fIntegralInt8_$cquotRem
      GHC.Int.$fIntegralInt8_$cdivMod
      GHC.Int.$fIntegralInt8_$ctoInteger

-- RHS size: {terms: 15, types: 13, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt8_$cunsafeIndex :: (Int8, Int8) -> Int8 -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),A)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eQc [Occ=Once!] :: (Int8, Int8))
                 (i_a4d1e [Occ=Once!] :: Int8) ->
                 case ds_d4eQc of { (m_a4d1d [Occ=Once!], _ [Occ=Dead]) ->
                 case i_a4d1e of { I8# x#_a4d3s [Occ=Once] ->
                 case m_a4d1d of { I8# x#1_X4dhg [Occ=Once] ->
                 GHC.Types.I# (-# x#_a4d3s x#1_X4dhg)
                 }
                 }
                 }}]
GHC.Int.$fIxInt8_$cunsafeIndex
  = \ (ds_d4eQc :: (Int8, Int8)) (i_a4d1e :: Int8) ->
      case ds_d4eQc of { (m_a4d1d, ds1_d4eQi) ->
      case i_a4d1e of { I8# x#_a4d3s ->
      case m_a4d1d of { I8# x#1_X4dhg ->
      GHC.Types.I# (-# x#_a4d3s x#1_X4dhg)
      }
      }
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt8_$crange :: (Int8, Int8) -> [Int8]
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eQ7 [Occ=Once!] :: (Int8, Int8)) ->
                 case ds_d4eQ7 of { (m_a4d1b [Occ=Once], n_a4d1c [Occ=Once]) ->
                 GHC.Int.$fEnumInt8_$cenumFromTo m_a4d1b n_a4d1c
                 }}]
GHC.Int.$fIxInt8_$crange
  = \ (ds_d4eQ7 :: (Int8, Int8)) ->
      case ds_d4eQ7 of { (m_a4d1b, n_a4d1c) ->
      GHC.Int.$fEnumInt8_$cenumFromTo m_a4d1b n_a4d1c
      }

-- RHS size: {terms: 23, types: 13, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt8_$crangeSize :: (Int8, Int8) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRl [Occ=Once!] :: (Int8, Int8)) ->
                 case b_a1KRl of { (_l_a1KRm [Occ=Once!], h_a1KRn [Occ=Once!]) ->
                 case _l_a1KRm of { I8# x_a4d2b ->
                 case h_a1KRn of { I8# y_a4d2c ->
                 case <=# x_a4d2b y_a4d2c of {
                   __DEFAULT -> GHC.Int.$fIxInt1;
                   1# -> GHC.Types.I# (+# (-# y_a4d2c x_a4d2b) 1#)
                 }
                 }
                 }
                 }}]
GHC.Int.$fIxInt8_$crangeSize
  = \ (b_a1KRl :: (Int8, Int8)) ->
      case b_a1KRl of { (_l_a1KRm, h_a1KRn) ->
      case _l_a1KRm of { I8# x_a4d2b ->
      case h_a1KRn of { I8# y_a4d2c ->
      case <=# x_a4d2b y_a4d2c of {
        __DEFAULT -> GHC.Int.$fIxInt1;
        1# -> GHC.Types.I# (+# (-# y_a4d2c x_a4d2b) 1#)
      }
      }
      }
      }

-- RHS size: {terms: 16, types: 12, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt8_$cunsafeRangeSize :: (Int8, Int8) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRo [Occ=Once!] :: (Int8, Int8)) ->
                 case b_a1KRo of { (_l_a1KRp [Occ=Once!], h_a1KRq [Occ=Once!]) ->
                 case h_a1KRq of { I8# x#_a4d3s [Occ=Once] ->
                 case _l_a1KRp of { I8# x#1_X4dhj [Occ=Once] ->
                 GHC.Types.I# (+# (-# x#_a4d3s x#1_X4dhj) 1#)
                 }
                 }
                 }}]
GHC.Int.$fIxInt8_$cunsafeRangeSize
  = \ (b_a1KRo :: (Int8, Int8)) ->
      case b_a1KRo of { (_l_a1KRp, h_a1KRq) ->
      case h_a1KRq of { I8# x#_a4d3s ->
      case _l_a1KRp of { I8# x#1_X4dhj ->
      GHC.Types.I# (+# (-# x#_a4d3s x#1_X4dhj) 1#)
      }
      }
      }

-- RHS size: {terms: 32, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt8_$cindex [InlPrag=INLINE (sat-args=2)]
  :: (Int8, Int8) -> Int8 -> Int
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (b_a1KRh [Occ=Once!] :: (Int8, Int8)) (i_a1KRi :: Int8) ->
                 case b_a1KRh of { (m_a4d1f, n_a4d1g [Occ=Once]) ->
                 case leInt8 m_a4d1f i_a1KRi of {
                   False -> hopelessIndexError;
                   True ->
                     case leInt8 i_a1KRi n_a4d1g of {
                       False -> hopelessIndexError;
                       True ->
                         case i_a1KRi of { I8# x#_a4d3s [Occ=Once] ->
                         case m_a4d1f of { I8# x#1_X4dhg [Occ=Once] ->
                         GHC.Types.I# (-# x#_a4d3s x#1_X4dhg)
                         }
                         }
                     }
                 }
                 }}]
GHC.Int.$fIxInt8_$cindex
  = \ (eta_B2 :: (Int8, Int8)) (eta1_B1 :: Int8) ->
      case eta_B2 of { (m_a4d1f, n_a4d1g) ->
      case m_a4d1f of { I8# x_a4d2b ->
      case eta1_B1 of { I8# y_a4d2c ->
      case <=# x_a4d2b y_a4d2c of {
        __DEFAULT -> hopelessIndexError;
        1# ->
          case n_a4d1g of { I8# y1_X4dfJ ->
          case <=# y_a4d2c y1_X4dfJ of {
            __DEFAULT -> hopelessIndexError;
            1# -> GHC.Types.I# (-# y_a4d2c x_a4d2b)
          }
          }
      }
      }
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt8 [InlPrag=NOUSERINLINE CONLIKE] :: Ix Int8
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Arr.C:Ix TYPE: Int8
                    GHC.Int.$fOrdInt8
                    GHC.Int.$fIxInt8_$crange
                    GHC.Int.$fIxInt8_$cindex
                    GHC.Int.$fIxInt8_$cunsafeIndex
                    GHC.Int.$fIxInt8_$cinRange
                    GHC.Int.$fIxInt8_$crangeSize
                    GHC.Int.$fIxInt8_$cunsafeRangeSize]
GHC.Int.$fIxInt8
  = GHC.Arr.C:Ix
      @ Int8
      GHC.Int.$fOrdInt8
      GHC.Int.$fIxInt8_$crange
      GHC.Int.$fIxInt8_$cindex
      GHC.Int.$fIxInt8_$cunsafeIndex
      GHC.Int.$fIxInt8_$cinRange
      GHC.Int.$fIxInt8_$crangeSize
      GHC.Int.$fIxInt8_$cunsafeRangeSize

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
eqInt16 [InlPrag=INLINE[1] (sat-args=2)] :: Int16 -> Int16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eAt [Occ=Once!] :: Int16)
                 (ds1_d4eAu [Occ=Once!] :: Int16) ->
                 case ds_d4eAt of { I16# x_a4d2d [Occ=Once] ->
                 case ds1_d4eAu of { I16# y_a4d2e [Occ=Once] ->
                 tagToEnum# @ Bool (==# x_a4d2d y_a4d2e)
                 }
                 }}]
eqInt16
  = \ (ds_d4eAt :: Int16) (ds1_d4eAu :: Int16) ->
      case ds_d4eAt of { I16# x_a4d2d ->
      case ds1_d4eAu of { I16# y_a4d2e ->
      tagToEnum# @ Bool (==# x_a4d2d y_a4d2e)
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEqInt16 [InlPrag=NOUSERINLINE CONLIKE] :: Eq Int16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ -> GHC.Classes.C:Eq TYPE: Int16 eqInt16 neInt16]
GHC.Int.$fEqInt16 = GHC.Classes.C:Eq @ Int16 eqInt16 neInt16

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
gtInt16 [InlPrag=INLINE[1] (sat-args=2)] :: Int16 -> Int16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eAf [Occ=Once!] :: Int16)
                 (ds1_d4eAg [Occ=Once!] :: Int16) ->
                 case ds_d4eAf of { I16# x_a4d2h [Occ=Once] ->
                 case ds1_d4eAg of { I16# y_a4d2i [Occ=Once] ->
                 tagToEnum# @ Bool (># x_a4d2h y_a4d2i)
                 }
                 }}]
gtInt16
  = \ (ds_d4eAf :: Int16) (ds1_d4eAg :: Int16) ->
      case ds_d4eAf of { I16# x_a4d2h ->
      case ds1_d4eAg of { I16# y_a4d2i ->
      tagToEnum# @ Bool (># x_a4d2h y_a4d2i)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
geInt16 [InlPrag=INLINE[1] (sat-args=2)] :: Int16 -> Int16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eA8 [Occ=Once!] :: Int16)
                 (ds1_d4eA9 [Occ=Once!] :: Int16) ->
                 case ds_d4eA8 of { I16# x_a4d2j [Occ=Once] ->
                 case ds1_d4eA9 of { I16# y_a4d2k [Occ=Once] ->
                 tagToEnum# @ Bool (>=# x_a4d2j y_a4d2k)
                 }
                 }}]
geInt16
  = \ (ds_d4eA8 :: Int16) (ds1_d4eA9 :: Int16) ->
      case ds_d4eA8 of { I16# x_a4d2j ->
      case ds1_d4eA9 of { I16# y_a4d2k ->
      tagToEnum# @ Bool (>=# x_a4d2j y_a4d2k)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
ltInt16 [InlPrag=INLINE[1] (sat-args=2)] :: Int16 -> Int16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eA1 [Occ=Once!] :: Int16)
                 (ds1_d4eA2 [Occ=Once!] :: Int16) ->
                 case ds_d4eA1 of { I16# x_a4d2l [Occ=Once] ->
                 case ds1_d4eA2 of { I16# y_a4d2m [Occ=Once] ->
                 tagToEnum# @ Bool (<# x_a4d2l y_a4d2m)
                 }
                 }}]
ltInt16
  = \ (ds_d4eA1 :: Int16) (ds1_d4eA2 :: Int16) ->
      case ds_d4eA1 of { I16# x_a4d2l ->
      case ds1_d4eA2 of { I16# y_a4d2m ->
      tagToEnum# @ Bool (<# x_a4d2l y_a4d2m)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
leInt16 [InlPrag=INLINE[1] (sat-args=2)] :: Int16 -> Int16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4ezU [Occ=Once!] :: Int16)
                 (ds1_d4ezV [Occ=Once!] :: Int16) ->
                 case ds_d4ezU of { I16# x_a4d2n [Occ=Once] ->
                 case ds1_d4ezV of { I16# y_a4d2o [Occ=Once] ->
                 tagToEnum# @ Bool (<=# x_a4d2n y_a4d2o)
                 }
                 }}]
leInt16
  = \ (ds_d4ezU :: Int16) (ds1_d4ezV :: Int16) ->
      case ds_d4ezU of { I16# x_a4d2n ->
      case ds1_d4ezV of { I16# y_a4d2o ->
      tagToEnum# @ Bool (<=# x_a4d2n y_a4d2o)
      }
      }

-- RHS size: {terms: 23, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt16_$ccompare :: Int16 -> Int16 -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fi2 [Occ=Once!] :: Int16)
                 (y_a1fi3 [Occ=Once!] :: Int16) ->
                 case x_a1fi2 of { I16# x1_a4d2d ->
                 case y_a1fi3 of { I16# y1_a4d2e ->
                 case ==# x1_a4d2d y1_a4d2e of {
                   __DEFAULT ->
                     case <=# x1_a4d2d y1_a4d2e of {
                       __DEFAULT -> GHC.Types.GT;
                       1# -> GHC.Types.LT
                     };
                   1# -> GHC.Types.EQ
                 }
                 }
                 }}]
GHC.Int.$fOrdInt16_$ccompare
  = \ (x_a1fi2 :: Int16) (y_a1fi3 :: Int16) ->
      case x_a1fi2 of { I16# x1_a4d2d ->
      case y_a1fi3 of { I16# y1_a4d2e ->
      case ==# x1_a4d2d y1_a4d2e of {
        __DEFAULT ->
          case <=# x1_a4d2d y1_a4d2e of {
            __DEFAULT -> GHC.Types.GT;
            1# -> GHC.Types.LT
          };
        1# -> GHC.Types.EQ
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt16_$cmax :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once!] :: Int16)
                 (y_a55e [Occ=Once!] :: Int16) ->
                 case x_a55d of wild_X8C { I16# x1_a4d2n [Occ=Once] ->
                 case y_a55e of wild1_X5 { I16# y1_a4d2o [Occ=Once] ->
                 case <=# x1_a4d2n y1_a4d2o of {
                   __DEFAULT -> wild_X8C;
                   1# -> wild1_X5
                 }
                 }
                 }}]
GHC.Int.$fOrdInt16_$cmax
  = \ (x_a55d :: Int16) (y_a55e :: Int16) ->
      case x_a55d of wild_X8C { I16# x1_a4d2n ->
      case y_a55e of wild1_X5 { I16# y1_a4d2o ->
      case <=# x1_a4d2n y1_a4d2o of {
        __DEFAULT -> wild_X8C;
        1# -> wild1_X5
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt16_$cmin :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m [Occ=Once!] :: Int16)
                 (y_a55n [Occ=Once!] :: Int16) ->
                 case x_a55m of wild_X8C { I16# x1_a4d2n [Occ=Once] ->
                 case y_a55n of wild1_X5 { I16# y1_a4d2o [Occ=Once] ->
                 case <=# x1_a4d2n y1_a4d2o of {
                   __DEFAULT -> wild1_X5;
                   1# -> wild_X8C
                 }
                 }
                 }}]
GHC.Int.$fOrdInt16_$cmin
  = \ (x_a55m :: Int16) (y_a55n :: Int16) ->
      case x_a55m of wild_X8C { I16# x1_a4d2n ->
      case y_a55n of wild1_X5 { I16# y1_a4d2o ->
      case <=# x1_a4d2n y1_a4d2o of {
        __DEFAULT -> wild1_X5;
        1# -> wild_X8C
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt16 [InlPrag=NOUSERINLINE CONLIKE] :: Ord Int16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Int16
                         GHC.Int.$fEqInt16
                         GHC.Int.$fOrdInt16_$ccompare
                         ltInt16
                         leInt16
                         gtInt16
                         geInt16
                         GHC.Int.$fOrdInt16_$cmax
                         GHC.Int.$fOrdInt16_$cmin]
GHC.Int.$fOrdInt16
  = GHC.Classes.C:Ord
      @ Int16
      GHC.Int.$fEqInt16
      GHC.Int.$fOrdInt16_$ccompare
      ltInt16
      leInt16
      gtInt16
      geInt16
      GHC.Int.$fOrdInt16_$cmax
      GHC.Int.$fOrdInt16_$cmin

-- RHS size: {terms: 25, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt16_$cinRange :: (Int16, Int16) -> Int16 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),1*U(U))><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eM5 [Occ=Once!] :: (Int16, Int16))
                 (i_a4cZX [Occ=Once!] :: Int16) ->
                 case ds_d4eM5 of { (m_a4cZV [Occ=Once!], n_a4cZW [Occ=Once!]) ->
                 case m_a4cZV of { I16# x_a4d2n [Occ=Once] ->
                 case i_a4cZX of { I16# y_a4d2o ->
                 case <=# x_a4d2n y_a4d2o of {
                   __DEFAULT -> GHC.Types.False;
                   1# ->
                     case n_a4cZW of { I16# y1_X4dg7 [Occ=Once] ->
                     tagToEnum# @ Bool (<=# y_a4d2o y1_X4dg7)
                     }
                 }
                 }
                 }
                 }}]
GHC.Int.$fIxInt16_$cinRange
  = \ (ds_d4eM5 :: (Int16, Int16)) (i_a4cZX :: Int16) ->
      case ds_d4eM5 of { (m_a4cZV, n_a4cZW) ->
      case m_a4cZV of { I16# x_a4d2n ->
      case i_a4cZX of { I16# y_a4d2o ->
      case <=# x_a4d2n y_a4d2o of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case n_a4cZW of { I16# y1_X4dg7 ->
          tagToEnum# @ Bool (<=# y_a4d2o y1_X4dg7)
          }
      }
      }
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt1 :: Int16
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fNumInt1 = GHC.Int.I16# 1#

-- RHS size: {terms: 17, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt16_$csignum :: Int16 -> Int16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4d0D [Occ=Once!] :: Int16) ->
                 case x_a4d0D of { I16# x1_a4d2h ->
                 case ># x1_a4d2h 0# of {
                   __DEFAULT ->
                     case x1_a4d2h of {
                       __DEFAULT -> GHC.Int.$fNumInt2;
                       0# -> GHC.Int.$fBitsInt3
                     };
                   1# -> GHC.Int.$fNumInt1
                 }
                 }}]
GHC.Int.$fNumInt16_$csignum
  = \ (x_a4d0D :: Int16) ->
      case x_a4d0D of { I16# x1_a4d2h ->
      case ># x1_a4d2h 0# of {
        __DEFAULT ->
          case x1_a4d2h of {
            __DEFAULT -> GHC.Int.$fNumInt2;
            0# -> GHC.Int.$fBitsInt3
          };
        1# -> GHC.Int.$fNumInt1
      }
      }

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt16_$cabs :: Int16 -> Int16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4d0C [Occ=Once!] :: Int16) ->
                 case x_a4d0C of wild_X8A { I16# x1_a4d2j ->
                 case >=# x1_a4d2j 0# of {
                   __DEFAULT -> GHC.Int.I16# (narrow16Int# (negateInt# x1_a4d2j));
                   1# -> wild_X8A
                 }
                 }}]
GHC.Int.$fNumInt16_$cabs
  = \ (x_a4d0C :: Int16) ->
      case x_a4d0C of wild_X8A { I16# x1_a4d2j ->
      case >=# x1_a4d2j 0# of {
        __DEFAULT -> GHC.Int.I16# (narrow16Int# (negateInt# x1_a4d2j));
        1# -> wild_X8A
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt16 [InlPrag=NOUSERINLINE CONLIKE] :: Num Int16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Int16
                     GHC.Int.$fNumInt16_$c+
                     GHC.Int.$fNumInt16_$c-
                     GHC.Int.$fNumInt16_$c*
                     GHC.Int.$fNumInt16_$cnegate
                     GHC.Int.$fNumInt16_$cabs
                     GHC.Int.$fNumInt16_$csignum
                     GHC.Int.$fNumInt16_$cfromInteger]
GHC.Int.$fNumInt16
  = GHC.Num.C:Num
      @ Int16
      GHC.Int.$fNumInt16_$c+
      GHC.Int.$fNumInt16_$c-
      GHC.Int.$fNumInt16_$c*
      GHC.Int.$fNumInt16_$cnegate
      GHC.Int.$fNumInt16_$cabs
      GHC.Int.$fNumInt16_$csignum
      GHC.Int.$fNumInt16_$cfromInteger

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt2 :: Maybe Int
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt2 = GHC.Base.Just @ Int GHC.Int.$fBitsInt1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cbitSizeMaybe :: Int16 -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Int.$fBitsInt2}]
GHC.Int.$fBitsInt16_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> GHC.Int.$fBitsInt2

-- RHS size: {terms: 16, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cbit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Int16
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once!] :: Int) ->
                 case i_a1A6g of { I# i#_a4cZz ->
                 case >=# i#_a4cZz 64# of {
                   __DEFAULT ->
                     GHC.Int.I16# (narrow16Int# (uncheckedIShiftL# 1# i#_a4cZz));
                   1# -> GHC.Int.I16# 0#
                 }
                 }}]
GHC.Int.$fBitsInt16_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# i#_a4cZz ->
      case >=# i#_a4cZz 64# of {
        __DEFAULT ->
          GHC.Int.I16# (narrow16Int# (uncheckedIShiftL# 1# i#_a4cZz));
        1# -> GHC.Int.$fBitsInt3
      }
      }

-- RHS size: {terms: 29, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: Int16 -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A6h [Occ=Once!] :: Int16)
                 (i_a1A6i [Occ=Once!] :: Int) ->
                 case x_a1A6h of { I16# x#_a4cZp [Occ=Once] ->
                 case i_a1A6i of { I# i#_a4cZz ->
                 case >=# i#_a4cZz 64# of {
                   __DEFAULT ->
                     neInt16
                       (GHC.Int.I16#
                          (word2Int#
                             (and#
                                (int2Word# x#_a4cZp)
                                (int2Word# (narrow16Int# (uncheckedIShiftL# 1# i#_a4cZz))))))
                       (GHC.Int.I16# 0#);
                   1# -> neInt16 (GHC.Int.I16# 0#) (GHC.Int.I16# 0#)
                 }
                 }
                 }}]
GHC.Int.$fBitsInt16_$ctestBit
  = \ (x_a1A6h :: Int16) (i_a1A6i :: Int) ->
      case x_a1A6h of { I16# x#_a4cZp ->
      case i_a1A6i of { I# i#_a4cZz ->
      case >=# i#_a4cZz 64# of {
        __DEFAULT ->
          case word2Int#
                 (and#
                    (int2Word# x#_a4cZp)
                    (int2Word# (narrow16Int# (uncheckedIShiftL# 1# i#_a4cZz))))
          of {
            __DEFAULT -> GHC.Types.True;
            0# -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 34, types: 8, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt16_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once!] :: Int16)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case x_a1A54 of { I16# x#_a4cZG ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 let {
                   x'#_a4cZI :: Word#
                   [LclId]
                   x'#_a4cZI = narrow16Word# (int2Word# x#_a4cZG) } in
                 case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 15##)
                 of wild2_X6I {
                   __DEFAULT ->
                     GHC.Int.I16#
                       (narrow16Int#
                          (word2Int#
                             (or#
                                (uncheckedShiftL# x'#_a4cZI wild2_X6I)
                                (uncheckedShiftRL# x'#_a4cZI (-# 16# wild2_X6I)))));
                   0# -> GHC.Int.I16# x#_a4cZG
                 }
                 }
                 }}]
GHC.Int.$fBitsInt16_$crotateR
  = \ (eta_B2 :: Int16) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6u { I16# x#_a4cZG ->
      case eta1_B1 of { I# x1_i1AMT ->
      case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 15##)
      of wild2_X6I {
        __DEFAULT ->
          let {
            x'#_s4fBH [Dmd=<S,U>] :: Word#
            [LclId]
            x'#_s4fBH = narrow16Word# (int2Word# x#_a4cZG) } in
          GHC.Int.I16#
            (narrow16Int#
               (word2Int#
                  (or#
                     (uncheckedShiftL# x'#_s4fBH wild2_X6I)
                     (uncheckedShiftRL# x'#_s4fBH (-# 16# wild2_X6I)))));
        0# -> wild_X6u
      }
      }
      }

-- RHS size: {terms: 25, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Int16)
                 (i_a1A4T [Occ=Once!] :: Int) ->
                 case x_a1A4S of { I16# x#_a4cZt [Occ=Once*] ->
                 case i_a1A4T of { I# i#_a4cZz ->
                 case >=# i#_a4cZz 64# of {
                   __DEFAULT ->
                     GHC.Int.I16#
                       (word2Int#
                          (xor#
                             (int2Word# x#_a4cZt)
                             (int2Word# (narrow16Int# (uncheckedIShiftL# 1# i#_a4cZz)))));
                   1# -> GHC.Int.I16# x#_a4cZt
                 }
                 }
                 }}]
GHC.Int.$fBitsInt16_$ccomplementBit
  = \ (eta_B2 :: Int16) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6x { I16# x#_a4cZt ->
      case eta1_B1 of { I# i#_a4cZz ->
      case >=# i#_a4cZz 64# of {
        __DEFAULT ->
          GHC.Int.I16#
            (word2Int#
               (xor#
                  (int2Word# x#_a4cZt)
                  (int2Word# (narrow16Int# (uncheckedIShiftL# 1# i#_a4cZz)))));
        1# -> wild_X6x
      }
      }
      }

-- RHS size: {terms: 31, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Int16)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of { I16# x#_a4cZp [Occ=Once*] ->
                 case i_a1A4R of { I# i#_a4cZz ->
                 case >=# i#_a4cZz 64# of {
                   __DEFAULT ->
                     GHC.Int.I16#
                       (word2Int#
                          (and#
                             (int2Word# x#_a4cZp)
                             (not#
                                (int2Word# (narrow16Int# (uncheckedIShiftL# 1# i#_a4cZz))))));
                   1# ->
                     GHC.Int.I16#
                       (word2Int# (and# (int2Word# x#_a4cZp) 18446744073709551615##))
                 }
                 }
                 }}]
GHC.Int.$fBitsInt16_$cclearBit
  = \ (eta_B2 :: Int16) (eta1_B1 :: Int) ->
      case eta_B2 of { I16# x#_a4cZp ->
      case eta1_B1 of { I# i#_a4cZz ->
      case >=# i#_a4cZz 64# of {
        __DEFAULT ->
          GHC.Int.I16#
            (word2Int#
               (and#
                  (int2Word# x#_a4cZp)
                  (not#
                     (int2Word# (narrow16Int# (uncheckedIShiftL# 1# i#_a4cZz))))));
        1# ->
          GHC.Int.I16#
            (word2Int# (and# (int2Word# x#_a4cZp) 18446744073709551615##))
      }
      }
      }

-- RHS size: {terms: 25, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Int16)
                 (i_a1A4P [Occ=Once!] :: Int) ->
                 case x_a1A4O of { I16# x#_a4cZr [Occ=Once*] ->
                 case i_a1A4P of { I# i#_a4cZz ->
                 case >=# i#_a4cZz 64# of {
                   __DEFAULT ->
                     GHC.Int.I16#
                       (word2Int#
                          (or#
                             (int2Word# x#_a4cZr)
                             (int2Word# (narrow16Int# (uncheckedIShiftL# 1# i#_a4cZz)))));
                   1# -> GHC.Int.I16# x#_a4cZr
                 }
                 }
                 }}]
GHC.Int.$fBitsInt16_$csetBit
  = \ (eta_B2 :: Int16) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6y { I16# x#_a4cZr ->
      case eta1_B1 of { I# i#_a4cZz ->
      case >=# i#_a4cZz 64# of {
        __DEFAULT ->
          GHC.Int.I16#
            (word2Int#
               (or#
                  (int2Word# x#_a4cZr)
                  (int2Word# (narrow16Int# (uncheckedIShiftL# 1# i#_a4cZz)))));
        1# -> wild_X6y
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Int16 -> Int -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Int.$fBitsInt16_$crotate}]
GHC.Int.$fBitsInt16_$crotateL = GHC.Int.$fBitsInt16_$crotate

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt16 [InlPrag=NOUSERINLINE CONLIKE] :: Bits Int16
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Int16
                        GHC.Int.$fEqInt16
                        GHC.Int.$fBitsInt16_$c.&.
                        GHC.Int.$fBitsInt16_$c.|.
                        GHC.Int.$fBitsInt16_$cxor
                        GHC.Int.$fBitsInt16_$ccomplement
                        GHC.Int.$fBitsInt16_$cshift
                        GHC.Int.$fBitsInt16_$crotate
                        GHC.Int.$fBitsInt3
                        GHC.Int.$fBitsInt16_$cbit
                        GHC.Int.$fBitsInt16_$csetBit
                        GHC.Int.$fBitsInt16_$cclearBit
                        GHC.Int.$fBitsInt16_$ccomplementBit
                        GHC.Int.$fBitsInt16_$ctestBit
                        GHC.Int.$fBitsInt16_$cbitSizeMaybe
                        GHC.Int.$fBitsInt16_$cfiniteBitSize
                        GHC.Int.$fBitsInt16_$cisSigned
                        GHC.Int.$fBitsInt16_$cshiftL
                        GHC.Int.$fBitsInt16_$cunsafeShiftL
                        GHC.Int.$fBitsInt16_$cshiftR
                        GHC.Int.$fBitsInt16_$cunsafeShiftR
                        GHC.Int.$fBitsInt16_$crotateL
                        GHC.Int.$fBitsInt16_$crotateR
                        GHC.Int.$fBitsInt16_$cpopCount]
GHC.Int.$fBitsInt16
  = Data.Bits.C:Bits
      @ Int16
      GHC.Int.$fEqInt16
      GHC.Int.$fBitsInt16_$c.&.
      GHC.Int.$fBitsInt16_$c.|.
      GHC.Int.$fBitsInt16_$cxor
      GHC.Int.$fBitsInt16_$ccomplement
      GHC.Int.$fBitsInt16_$cshift
      GHC.Int.$fBitsInt16_$crotate
      GHC.Int.$fBitsInt3
      GHC.Int.$fBitsInt16_$cbit
      GHC.Int.$fBitsInt16_$csetBit
      GHC.Int.$fBitsInt16_$cclearBit
      GHC.Int.$fBitsInt16_$ccomplementBit
      GHC.Int.$fBitsInt16_$ctestBit
      GHC.Int.$fBitsInt16_$cbitSizeMaybe
      GHC.Int.$fBitsInt16_$cfiniteBitSize
      GHC.Int.$fBitsInt16_$cisSigned
      GHC.Int.$fBitsInt16_$cshiftL
      GHC.Int.$fBitsInt16_$cunsafeShiftL
      GHC.Int.$fBitsInt16_$cshiftR
      GHC.Int.$fBitsInt16_$cunsafeShiftR
      GHC.Int.$fBitsInt16_$crotateL
      GHC.Int.$fBitsInt16_$crotateR
      GHC.Int.$fBitsInt16_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt16 [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Int16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Int16
                              GHC.Int.$fBitsInt16
                              GHC.Int.$fBitsInt16_$cfiniteBitSize
                              GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros
                              GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros]
GHC.Int.$fFiniteBitsInt16
  = Data.Bits.C:FiniteBits
      @ Int16
      GHC.Int.$fBitsInt16
      GHC.Int.$fBitsInt16_$cfiniteBitSize
      GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros
      GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros

Rec {
-- RHS size: {terms: 20, types: 30, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt16_go [Occ=LoopBreaker]
  :: [(Int, String)] -> [(Int16, String)]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
GHC.Int.$fReadInt16_go
  = \ (ds_i1y1c :: [(Int, String)]) ->
      case ds_i1y1c of {
        [] -> GHC.Types.[] @ (Int16, String);
        : y_i1y1h ys_i1y1i ->
          case y_i1y1h of { (x_a4cZP, r_a4cZQ) ->
          GHC.Types.:
            @ (Int16, String)
            (case x_a4cZP of { I# x#_a4d3i ->
             GHC.Int.I16# (narrow16Int# x#_a4d3i)
             },
             r_a4cZQ)
            (GHC.Int.$fReadInt16_go ys_i1y1i)
          }
      }
end Rec }

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt16_$creadsPrec :: Int -> ReadS Int16
[GblId,
 Arity=2,
 Str=<L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 90 0}]
GHC.Int.$fReadInt16_$creadsPrec
  = \ (p_a4cZN :: Int) (s_a4cZO :: String) ->
      GHC.Int.$fReadInt16_go
        (Text.ParserCombinators.ReadP.run
           @ Int
           (GHC.Read.$fReadInt_$sreadNumber
              GHC.Read.$fReadInt2
              p_a4cZN
              @ Int
              (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Int))
           s_a4cZO)

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt3
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Int16 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,U><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_X3tvK [Occ=Once]
                    :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_s3ofG)
                 (eta_B1 [Occ=Once]
                    :: Int16 -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ Int16 (GHC.Int.$fReadInt16_$creadsPrec n_X3tvK) @ b_s3ofG eta_B1
                 of
                 { (# ww1_s3oiG [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
                 }}]
GHC.Int.$fReadInt3
  = \ (n_X3tvK :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_s3ofG)
      (eta_B1 :: Int16 -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ Int16 (GHC.Int.$fReadInt16_$creadsPrec n_X3tvK) @ b_s3ofG eta_B1
      of
      { (# ww1_s3oiG #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
      }

-- RHS size: {terms: 4, types: 5, coercions: 15, joins: 0/0}
GHC.Int.$fReadInt2 :: Text.ParserCombinators.ReadP.P [Int16]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
GHC.Int.$fReadInt2
  = ((((list
          @ Int16
          (GHC.Int.$fReadInt3
           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Int16>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                         <Int16>_R)
                   :: (Text.ParserCombinators.ReadPrec.Prec
                       -> forall b.
                          (Int16 -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)
                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int16 :: *))))
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Int16]>_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Int16] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [Int16] :: *)))
        GHC.Int.$fIxInt1)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Int16]>_R
             :: (Text.ParserCombinators.ReadP.ReadP [Int16] :: *)
                ~R# (forall b.
                     ([Int16] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)))
      @ [Int16]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [Int16])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt16_$creadList :: ReadS [Int16]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.Int.$fReadInt16_$creadList
  = Text.ParserCombinators.ReadP.run @ [Int16] GHC.Int.$fReadInt2

-- RHS size: {terms: 10, types: 19, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([Int16] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,A><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_s3ofG)
                 (w1_s3ofH [Occ=Once]
                    :: [Int16] -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ [Int16] GHC.Int.$fReadInt16_$creadList @ b_s3ofG w1_s3ofH
                 of
                 { (# ww1_s3oiG [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
                 }}]
GHC.Int.$fReadInt1
  = \ _ [Occ=Dead]
      (@ b_s3ofG)
      (w1_s3ofH :: [Int16] -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ [Int16] GHC.Int.$fReadInt16_$creadList @ b_s3ofG w1_s3ofH
      of
      { (# ww1_s3oiG #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
      }

-- RHS size: {terms: 5, types: 1, coercions: 20, joins: 0/0}
GHC.Int.$fReadInt16 [InlPrag=NOUSERINLINE CONLIKE] :: Read Int16
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: Int16
                       GHC.Int.$fReadInt16_$creadsPrec
                       GHC.Int.$fReadInt16_$creadList
                       GHC.Int.$fReadInt3
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int16>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <Int16>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int16 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int16 :: *))
                       GHC.Int.$fReadInt1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int16]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       <[Int16]>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int16] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [Int16] :: *))]
GHC.Int.$fReadInt16
  = GHC.Read.C:Read
      @ Int16
      GHC.Int.$fReadInt16_$creadsPrec
      GHC.Int.$fReadInt16_$creadList
      (GHC.Int.$fReadInt3
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int16>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     <Int16>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int16 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int16 :: *)))
      (GHC.Int.$fReadInt1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int16]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <[Int16]>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int16] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [Int16] :: *)))

-- RHS size: {terms: 34, types: 15, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt16_$cquot [InlPrag=NOUSERINLINE[0]]
  :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iGo [Occ=Once!] :: Int16)
                 (w1_s4iGp [Occ=Once!] :: Int16) ->
                 case w_s4iGo of { I16# ww1_s4iGs [Occ=Once*] ->
                 case w1_s4iGp of { I16# ww3_s4iGw [Occ=Once!] ->
                 case ww3_s4iGw of wild_Xe9 {
                   __DEFAULT ->
                     case quotInt# ww1_s4iGs wild_Xe9 of wild1_X3d { __DEFAULT ->
                     GHC.Int.I16# (narrow16Int# wild1_X3d)
                     };
                   -1# ->
                     case ww1_s4iGs of wild1_Xeh {
                       __DEFAULT -> GHC.Int.I16# (narrow16Int# (quotInt# wild1_Xeh -1#));
                       -32768# -> case overflowError of { }
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt16_$cquot
  = \ (w_s4iGo :: Int16) (w1_s4iGp :: Int16) ->
      case w_s4iGo of { I16# ww1_s4iGs ->
      case w1_s4iGp of { I16# ww3_s4iGw ->
      case ww3_s4iGw of wild_Xe9 {
        __DEFAULT ->
          case quotInt# ww1_s4iGs wild_Xe9 of wild1_X3d { __DEFAULT ->
          GHC.Int.I16# (narrow16Int# wild1_X3d)
          };
        -1# ->
          case ww1_s4iGs of wild1_Xeh {
            __DEFAULT -> GHC.Int.I16# (narrow16Int# (quotInt# wild1_Xeh -1#));
            -32768# -> case overflowError of wild2_00 { }
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 21, types: 9, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt16_$crem :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eMn [Occ=Once!] :: Int16)
                 (y_a4d03 [Occ=Once!] :: Int16) ->
                 case ds_d4eMn of { I16# x#_a4d02 [Occ=Once] ->
                 case y_a4d03 of { I16# y#_a4d04 [Occ=Once!] ->
                 case y#_a4d04 of wild2_Xeb {
                   __DEFAULT ->
                     case remInt# x#_a4d02 wild2_Xeb of wild3_X3d { __DEFAULT ->
                     GHC.Int.I16# (narrow16Int# wild3_X3d)
                     };
                   0# -> divZeroError @ Int16
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt16_$crem
  = \ (ds_d4eMn :: Int16) (y_a4d03 :: Int16) ->
      case ds_d4eMn of { I16# x#_a4d02 ->
      case y_a4d03 of { I16# y#_a4d04 ->
      case y#_a4d04 of wild2_Xeb {
        __DEFAULT ->
          case remInt# x#_a4d02 wild2_Xeb of wild3_X3d { __DEFAULT ->
          GHC.Int.I16# (narrow16Int# wild3_X3d)
          };
        0# -> divZeroError @ Int16
      }
      }
      }

-- RHS size: {terms: 29, types: 12, coercions: 0, joins: 0/0}
GHC.Int.$w$cdiv [InlPrag=NOUSERINLINE[0]] :: Int# -> Int# -> Int#
[GblId,
 Arity=2,
 Str=<S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 81] 132 0}]
GHC.Int.$w$cdiv
  = \ (ww_s4iGG :: Int#) (ww1_s4iGK :: Int#) ->
      case ww1_s4iGK of wild_Xee {
        __DEFAULT ->
          case divInt# ww_s4iGG wild_Xee of wild1_X3f { __DEFAULT ->
          narrow16Int# wild1_X3f
          };
        -1# ->
          case ww_s4iGG of wild1_Xem {
            __DEFAULT ->
              case divInt# wild1_Xem -1# of wild2_X3f { __DEFAULT ->
              narrow16Int# wild2_X3f
              };
            -32768# -> case overflowError of wild2_00 { }
          };
        0# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt16_$cdiv [InlPrag=NOUSERINLINE[0]]
  :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iGC [Occ=Once!] :: Int16)
                 (w1_s4iGD [Occ=Once!] :: Int16) ->
                 case w_s4iGC of { I16# ww1_s4iGG [Occ=Once] ->
                 case w1_s4iGD of { I16# ww3_s4iGK [Occ=Once] ->
                 case GHC.Int.$w$cdiv ww1_s4iGG ww3_s4iGK of ww4_s4iGO
                 { __DEFAULT ->
                 GHC.Int.I16# ww4_s4iGO
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt16_$cdiv
  = \ (w_s4iGC :: Int16) (w1_s4iGD :: Int16) ->
      case w_s4iGC of { I16# ww1_s4iGG ->
      case w1_s4iGD of { I16# ww3_s4iGK ->
      case GHC.Int.$w$cdiv ww1_s4iGG ww3_s4iGK of ww4_s4iGO
      { __DEFAULT ->
      GHC.Int.I16# ww4_s4iGO
      }
      }
      }

-- RHS size: {terms: 22, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt16_$cmod [InlPrag=NOUSERINLINE[0]]
  :: Int16 -> Int16 -> Int16
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iGQ [Occ=Once!] :: Int16)
                 (w1_s4iGR [Occ=Once!] :: Int16) ->
                 case w_s4iGQ of { I16# ww1_s4iGU [Occ=Once] ->
                 case w1_s4iGR of { I16# ww3_s4iGY [Occ=Once!] ->
                 case ww3_s4iGY of wild_Xeg {
                   __DEFAULT ->
                     case modInt# ww1_s4iGU wild_Xeg of wild1_X3f { __DEFAULT ->
                     GHC.Int.I16# (narrow16Int# wild1_X3f)
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt16_$cmod
  = \ (w_s4iGQ :: Int16) (w1_s4iGR :: Int16) ->
      case w_s4iGQ of { I16# ww1_s4iGU ->
      case w1_s4iGR of { I16# ww3_s4iGY ->
      case ww3_s4iGY of wild_Xeg {
        __DEFAULT ->
          case modInt# ww1_s4iGU wild_Xeg of wild1_X3f { __DEFAULT ->
          GHC.Int.I16# (narrow16Int# wild1_X3f)
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
lvl7_r4kPy :: (Int16, Int16)
[GblId, Str=m, Unf=OtherCon []]
lvl7_r4kPy = (overflowError @ Int16, GHC.Int.$fBitsInt3)

-- RHS size: {terms: 44, types: 29, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt16_$cquotRem [InlPrag=NOUSERINLINE[0]]
  :: Int16 -> Int16 -> (Int16, Int16)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iH4 [Occ=Once!] :: Int16)
                 (w1_s4iH5 [Occ=Once!] :: Int16) ->
                 case w_s4iH4 of { I16# ww1_s4iH8 [Occ=Once*] ->
                 case w1_s4iH5 of { I16# ww3_s4iHc [Occ=Once!] ->
                 case ww3_s4iHc of wild_Xel {
                   __DEFAULT ->
                     case quotRemInt# ww1_s4iH8 wild_Xel of
                     { (# ipv_s4f1Z [Occ=Once], ipv1_s4f20 [Occ=Once] #) ->
                     (GHC.Int.I16# (narrow16Int# ipv_s4f1Z),
                      GHC.Int.I16# (narrow16Int# ipv1_s4f20))
                     };
                   -1# ->
                     case ww1_s4iH8 of wild1_Xet {
                       __DEFAULT ->
                         case quotRemInt# wild1_Xet -1# of
                         { (# ipv_s4f1Z [Occ=Once], ipv1_s4f20 [Occ=Once] #) ->
                         (GHC.Int.I16# (narrow16Int# ipv_s4f1Z),
                          GHC.Int.I16# (narrow16Int# ipv1_s4f20))
                         };
                       -32768# -> (overflowError @ Int16, GHC.Int.$fBitsInt3)
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt16_$cquotRem
  = \ (w_s4iH4 :: Int16) (w1_s4iH5 :: Int16) ->
      case w_s4iH4 of { I16# ww1_s4iH8 ->
      case w1_s4iH5 of { I16# ww3_s4iHc ->
      case ww3_s4iHc of wild_Xel {
        __DEFAULT ->
          case quotRemInt# ww1_s4iH8 wild_Xel of
          { (# ipv_s4f1Z, ipv1_s4f20 #) ->
          (GHC.Int.I16# (narrow16Int# ipv_s4f1Z),
           GHC.Int.I16# (narrow16Int# ipv1_s4f20))
          };
        -1# ->
          case ww1_s4iH8 of wild1_Xet {
            __DEFAULT ->
              case quotRemInt# wild1_Xet -1# of { (# ipv_s4f1Z, ipv1_s4f20 #) ->
              (GHC.Int.I16# (narrow16Int# ipv_s4f1Z),
               GHC.Int.I16# (narrow16Int# ipv1_s4f20))
              };
            -32768# -> lvl7_r4kPy
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 166, types: 101, coercions: 0, joins: 1/1}
GHC.Int.$w$cdivMod [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> (# Int16, Int16 #)
[GblId,
 Arity=2,
 Str=<S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 363 30}]
GHC.Int.$w$cdivMod
  = \ (ww_s4iHm :: Int#) (ww1_s4iHq :: Int#) ->
      case ww1_s4iHq of wild_Xeq {
        __DEFAULT ->
          join {
            $j_s4fOl [Dmd=<L,1*U(U,U)>] :: (# Int16, Int16 #)
            [LclId[JoinId(0)]]
            $j_s4fOl
              = case ># ww_s4iHm 0# of {
                  __DEFAULT ->
                    case <# ww_s4iHm 0# of {
                      __DEFAULT ->
                        case quotRemInt# ww_s4iHm wild_Xeq of
                        { (# ipv_s4f28, ipv1_s4f29 #) ->
                        (# GHC.Int.I16# (narrow16Int# ipv_s4f28),
                           GHC.Int.I16# (narrow16Int# ipv1_s4f29) #)
                        };
                      1# ->
                        case ># wild_Xeq 0# of {
                          __DEFAULT ->
                            case quotRemInt# ww_s4iHm wild_Xeq of
                            { (# ipv_s4f28, ipv1_s4f29 #) ->
                            (# GHC.Int.I16# (narrow16Int# ipv_s4f28),
                               GHC.Int.I16# (narrow16Int# ipv1_s4f29) #)
                            };
                          1# ->
                            case quotRemInt# (+# ww_s4iHm 1#) wild_Xeq of
                            { (# ipv_i4eEn, ipv1_i4eEo #) ->
                            (# GHC.Int.I16# (narrow16Int# (-# ipv_i4eEn 1#)),
                               GHC.Int.I16# (narrow16Int# (-# (+# ipv1_i4eEo wild_Xeq) 1#)) #)
                            }
                        }
                    };
                  1# ->
                    case <# wild_Xeq 0# of {
                      __DEFAULT ->
                        case <# ww_s4iHm 0# of {
                          __DEFAULT ->
                            case quotRemInt# ww_s4iHm wild_Xeq of
                            { (# ipv_s4f28, ipv1_s4f29 #) ->
                            (# GHC.Int.I16# (narrow16Int# ipv_s4f28),
                               GHC.Int.I16# (narrow16Int# ipv1_s4f29) #)
                            };
                          1# ->
                            case ># wild_Xeq 0# of {
                              __DEFAULT ->
                                case quotRemInt# ww_s4iHm wild_Xeq of
                                { (# ipv_s4f28, ipv1_s4f29 #) ->
                                (# GHC.Int.I16# (narrow16Int# ipv_s4f28),
                                   GHC.Int.I16# (narrow16Int# ipv1_s4f29) #)
                                };
                              1# ->
                                case quotRemInt# (+# ww_s4iHm 1#) wild_Xeq of
                                { (# ipv_i4eEv, ipv1_i4eEw #) ->
                                (# GHC.Int.I16# (narrow16Int# (-# ipv_i4eEv 1#)),
                                   GHC.Int.I16# (narrow16Int# (-# (+# ipv1_i4eEw wild_Xeq) 1#)) #)
                                }
                            }
                        };
                      1# ->
                        case quotRemInt# (-# ww_s4iHm 1#) wild_Xeq of
                        { (# ipv_i4eEA, ipv1_i4eEB #) ->
                        (# GHC.Int.I16# (narrow16Int# (-# ipv_i4eEA 1#)),
                           GHC.Int.I16# (narrow16Int# (+# (+# ipv1_i4eEB wild_Xeq) 1#)) #)
                        }
                    }
                } } in
          case wild_Xeq of {
            __DEFAULT -> jump $j_s4fOl;
            -1# ->
              case ww_s4iHm of {
                __DEFAULT -> jump $j_s4fOl;
                -32768# -> (# overflowError @ Int16, GHC.Int.$fBitsInt3 #)
              }
          };
        0# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 16, types: 15, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt16_$cdivMod [InlPrag=NOUSERINLINE[0]]
  :: Int16 -> Int16 -> (Int16, Int16)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iHi [Occ=Once!] :: Int16)
                 (w1_s4iHj [Occ=Once!] :: Int16) ->
                 case w_s4iHi of { I16# ww1_s4iHm [Occ=Once] ->
                 case w1_s4iHj of { I16# ww3_s4iHq [Occ=Once] ->
                 case GHC.Int.$w$cdivMod ww1_s4iHm ww3_s4iHq of
                 { (# ww5_s4iKH [Occ=Once], ww6_s4iKI [Occ=Once] #) ->
                 (ww5_s4iKH, ww6_s4iKI)
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt16_$cdivMod
  = \ (w_s4iHi :: Int16) (w1_s4iHj :: Int16) ->
      case w_s4iHi of { I16# ww1_s4iHm ->
      case w1_s4iHj of { I16# ww3_s4iHq ->
      case GHC.Int.$w$cdivMod ww1_s4iHm ww3_s4iHq of
      { (# ww5_s4iKH, ww6_s4iKI #) ->
      (ww5_s4iKH, ww6_s4iKI)
      }
      }
      }

-- RHS size: {terms: 15, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fRealInt16_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Int16 -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iHw [Occ=Once!] :: Int16) ->
                 case w_s4iHw of { I16# ww1_s4iHz [Occ=Once] ->
                 case GHC.Real.$w$sreduce
                        (timesInteger (smallInteger ww1_s4iHz) GHC.Int.$fRealInt1)
                        GHC.Int.$fRealInt1
                 of
                 { (# ww3_s4iKK [Occ=Once], ww4_s4iKL [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s4iKK ww4_s4iKL
                 }
                 }}]
GHC.Int.$fRealInt16_$ctoRational
  = \ (w_s4iHw :: Int16) ->
      case w_s4iHw of { I16# ww1_s4iHz ->
      case GHC.Real.$w$sreduce
             (timesInteger (smallInteger ww1_s4iHz) GHC.Int.$fRealInt1)
             GHC.Int.$fRealInt1
      of
      { (# ww3_s4iKK, ww4_s4iKL #) ->
      GHC.Real.:% @ Integer ww3_s4iKK ww4_s4iKL
      }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fRealInt16 [InlPrag=NOUSERINLINE CONLIKE] :: Real Int16
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Int16
                       GHC.Int.$fNumInt16
                       GHC.Int.$fOrdInt16
                       GHC.Int.$fRealInt16_$ctoRational]
GHC.Int.$fRealInt16
  = GHC.Real.C:Real
      @ Int16
      GHC.Int.$fNumInt16
      GHC.Int.$fOrdInt16
      GHC.Int.$fRealInt16_$ctoRational

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Int16
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Int16
                           GHC.Int.$fRealInt16
                           GHC.Int.$fEnumInt16
                           GHC.Int.$fIntegralInt16_$cquot
                           GHC.Int.$fIntegralInt16_$crem
                           GHC.Int.$fIntegralInt16_$cdiv
                           GHC.Int.$fIntegralInt16_$cmod
                           GHC.Int.$fIntegralInt16_$cquotRem
                           GHC.Int.$fIntegralInt16_$cdivMod
                           GHC.Int.$fIntegralInt16_$ctoInteger]
GHC.Int.$fIntegralInt16
  = GHC.Real.C:Integral
      @ Int16
      GHC.Int.$fRealInt16
      GHC.Int.$fEnumInt16
      GHC.Int.$fIntegralInt16_$cquot
      GHC.Int.$fIntegralInt16_$crem
      GHC.Int.$fIntegralInt16_$cdiv
      GHC.Int.$fIntegralInt16_$cmod
      GHC.Int.$fIntegralInt16_$cquotRem
      GHC.Int.$fIntegralInt16_$cdivMod
      GHC.Int.$fIntegralInt16_$ctoInteger

-- RHS size: {terms: 15, types: 13, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt16_$cunsafeIndex :: (Int16, Int16) -> Int16 -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),A)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eLY [Occ=Once!] :: (Int16, Int16))
                 (i_a4cZU [Occ=Once!] :: Int16) ->
                 case ds_d4eLY of { (m_a4cZT [Occ=Once!], _ [Occ=Dead]) ->
                 case i_a4cZU of { I16# x#_a4d3j [Occ=Once] ->
                 case m_a4cZT of { I16# x#1_X4dij [Occ=Once] ->
                 GHC.Types.I# (-# x#_a4d3j x#1_X4dij)
                 }
                 }
                 }}]
GHC.Int.$fIxInt16_$cunsafeIndex
  = \ (ds_d4eLY :: (Int16, Int16)) (i_a4cZU :: Int16) ->
      case ds_d4eLY of { (m_a4cZT, ds1_d4eM4) ->
      case i_a4cZU of { I16# x#_a4d3j ->
      case m_a4cZT of { I16# x#1_X4dij ->
      GHC.Types.I# (-# x#_a4d3j x#1_X4dij)
      }
      }
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt16_$crange :: (Int16, Int16) -> [Int16]
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eLT [Occ=Once!] :: (Int16, Int16)) ->
                 case ds_d4eLT of { (m_a4cZR [Occ=Once], n_a4cZS [Occ=Once]) ->
                 GHC.Int.$fEnumInt16_$cenumFromTo m_a4cZR n_a4cZS
                 }}]
GHC.Int.$fIxInt16_$crange
  = \ (ds_d4eLT :: (Int16, Int16)) ->
      case ds_d4eLT of { (m_a4cZR, n_a4cZS) ->
      GHC.Int.$fEnumInt16_$cenumFromTo m_a4cZR n_a4cZS
      }

-- RHS size: {terms: 23, types: 13, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt16_$crangeSize :: (Int16, Int16) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRl [Occ=Once!] :: (Int16, Int16)) ->
                 case b_a1KRl of { (_l_a1KRm [Occ=Once!], h_a1KRn [Occ=Once!]) ->
                 case _l_a1KRm of { I16# x_a4d2n ->
                 case h_a1KRn of { I16# y_a4d2o ->
                 case <=# x_a4d2n y_a4d2o of {
                   __DEFAULT -> GHC.Int.$fIxInt1;
                   1# -> GHC.Types.I# (+# (-# y_a4d2o x_a4d2n) 1#)
                 }
                 }
                 }
                 }}]
GHC.Int.$fIxInt16_$crangeSize
  = \ (b_a1KRl :: (Int16, Int16)) ->
      case b_a1KRl of { (_l_a1KRm, h_a1KRn) ->
      case _l_a1KRm of { I16# x_a4d2n ->
      case h_a1KRn of { I16# y_a4d2o ->
      case <=# x_a4d2n y_a4d2o of {
        __DEFAULT -> GHC.Int.$fIxInt1;
        1# -> GHC.Types.I# (+# (-# y_a4d2o x_a4d2n) 1#)
      }
      }
      }
      }

-- RHS size: {terms: 16, types: 12, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt16_$cunsafeRangeSize :: (Int16, Int16) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRo [Occ=Once!] :: (Int16, Int16)) ->
                 case b_a1KRo of { (_l_a1KRp [Occ=Once!], h_a1KRq [Occ=Once!]) ->
                 case h_a1KRq of { I16# x#_a4d3j [Occ=Once] ->
                 case _l_a1KRp of { I16# x#1_X4dim [Occ=Once] ->
                 GHC.Types.I# (+# (-# x#_a4d3j x#1_X4dim) 1#)
                 }
                 }
                 }}]
GHC.Int.$fIxInt16_$cunsafeRangeSize
  = \ (b_a1KRo :: (Int16, Int16)) ->
      case b_a1KRo of { (_l_a1KRp, h_a1KRq) ->
      case h_a1KRq of { I16# x#_a4d3j ->
      case _l_a1KRp of { I16# x#1_X4dim ->
      GHC.Types.I# (+# (-# x#_a4d3j x#1_X4dim) 1#)
      }
      }
      }

-- RHS size: {terms: 32, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt16_$cindex [InlPrag=INLINE (sat-args=2)]
  :: (Int16, Int16) -> Int16 -> Int
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (b_a1KRh [Occ=Once!] :: (Int16, Int16))
                 (i_a1KRi :: Int16) ->
                 case b_a1KRh of { (m_a4cZV, n_a4cZW [Occ=Once]) ->
                 case leInt16 m_a4cZV i_a1KRi of {
                   False -> hopelessIndexError;
                   True ->
                     case leInt16 i_a1KRi n_a4cZW of {
                       False -> hopelessIndexError;
                       True ->
                         case i_a1KRi of { I16# x#_a4d3j [Occ=Once] ->
                         case m_a4cZV of { I16# x#1_X4dij [Occ=Once] ->
                         GHC.Types.I# (-# x#_a4d3j x#1_X4dij)
                         }
                         }
                     }
                 }
                 }}]
GHC.Int.$fIxInt16_$cindex
  = \ (eta_B2 :: (Int16, Int16)) (eta1_B1 :: Int16) ->
      case eta_B2 of { (m_a4cZV, n_a4cZW) ->
      case m_a4cZV of { I16# x_a4d2n ->
      case eta1_B1 of { I16# y_a4d2o ->
      case <=# x_a4d2n y_a4d2o of {
        __DEFAULT -> hopelessIndexError;
        1# ->
          case n_a4cZW of { I16# y1_X4dh7 ->
          case <=# y_a4d2o y1_X4dh7 of {
            __DEFAULT -> hopelessIndexError;
            1# -> GHC.Types.I# (-# y_a4d2o x_a4d2n)
          }
          }
      }
      }
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt16 [InlPrag=NOUSERINLINE CONLIKE] :: Ix Int16
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Arr.C:Ix TYPE: Int16
                    GHC.Int.$fOrdInt16
                    GHC.Int.$fIxInt16_$crange
                    GHC.Int.$fIxInt16_$cindex
                    GHC.Int.$fIxInt16_$cunsafeIndex
                    GHC.Int.$fIxInt16_$cinRange
                    GHC.Int.$fIxInt16_$crangeSize
                    GHC.Int.$fIxInt16_$cunsafeRangeSize]
GHC.Int.$fIxInt16
  = GHC.Arr.C:Ix
      @ Int16
      GHC.Int.$fOrdInt16
      GHC.Int.$fIxInt16_$crange
      GHC.Int.$fIxInt16_$cindex
      GHC.Int.$fIxInt16_$cunsafeIndex
      GHC.Int.$fIxInt16_$cinRange
      GHC.Int.$fIxInt16_$crangeSize
      GHC.Int.$fIxInt16_$cunsafeRangeSize

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
eqInt32 [InlPrag=INLINE[1] (sat-args=2)] :: Int32 -> Int32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4ezN [Occ=Once!] :: Int32)
                 (ds1_d4ezO [Occ=Once!] :: Int32) ->
                 case ds_d4ezN of { I32# x_a4d2p [Occ=Once] ->
                 case ds1_d4ezO of { I32# y_a4d2q [Occ=Once] ->
                 tagToEnum# @ Bool (==# x_a4d2p y_a4d2q)
                 }
                 }}]
eqInt32
  = \ (ds_d4ezN :: Int32) (ds1_d4ezO :: Int32) ->
      case ds_d4ezN of { I32# x_a4d2p ->
      case ds1_d4ezO of { I32# y_a4d2q ->
      tagToEnum# @ Bool (==# x_a4d2p y_a4d2q)
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEqInt32 [InlPrag=NOUSERINLINE CONLIKE] :: Eq Int32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ -> GHC.Classes.C:Eq TYPE: Int32 eqInt32 neInt32]
GHC.Int.$fEqInt32 = GHC.Classes.C:Eq @ Int32 eqInt32 neInt32

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
gtInt32 [InlPrag=INLINE[1] (sat-args=2)] :: Int32 -> Int32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4ezz [Occ=Once!] :: Int32)
                 (ds1_d4ezA [Occ=Once!] :: Int32) ->
                 case ds_d4ezz of { I32# x_a4d2t [Occ=Once] ->
                 case ds1_d4ezA of { I32# y_a4d2u [Occ=Once] ->
                 tagToEnum# @ Bool (># x_a4d2t y_a4d2u)
                 }
                 }}]
gtInt32
  = \ (ds_d4ezz :: Int32) (ds1_d4ezA :: Int32) ->
      case ds_d4ezz of { I32# x_a4d2t ->
      case ds1_d4ezA of { I32# y_a4d2u ->
      tagToEnum# @ Bool (># x_a4d2t y_a4d2u)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
geInt32 [InlPrag=INLINE[1] (sat-args=2)] :: Int32 -> Int32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4ezs [Occ=Once!] :: Int32)
                 (ds1_d4ezt [Occ=Once!] :: Int32) ->
                 case ds_d4ezs of { I32# x_a4d2v [Occ=Once] ->
                 case ds1_d4ezt of { I32# y_a4d2w [Occ=Once] ->
                 tagToEnum# @ Bool (>=# x_a4d2v y_a4d2w)
                 }
                 }}]
geInt32
  = \ (ds_d4ezs :: Int32) (ds1_d4ezt :: Int32) ->
      case ds_d4ezs of { I32# x_a4d2v ->
      case ds1_d4ezt of { I32# y_a4d2w ->
      tagToEnum# @ Bool (>=# x_a4d2v y_a4d2w)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
ltInt32 [InlPrag=INLINE[1] (sat-args=2)] :: Int32 -> Int32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4ezl [Occ=Once!] :: Int32)
                 (ds1_d4ezm [Occ=Once!] :: Int32) ->
                 case ds_d4ezl of { I32# x_a4d2x [Occ=Once] ->
                 case ds1_d4ezm of { I32# y_a4d2y [Occ=Once] ->
                 tagToEnum# @ Bool (<# x_a4d2x y_a4d2y)
                 }
                 }}]
ltInt32
  = \ (ds_d4ezl :: Int32) (ds1_d4ezm :: Int32) ->
      case ds_d4ezl of { I32# x_a4d2x ->
      case ds1_d4ezm of { I32# y_a4d2y ->
      tagToEnum# @ Bool (<# x_a4d2x y_a4d2y)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
leInt32 [InlPrag=INLINE[1] (sat-args=2)] :: Int32 -> Int32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eze [Occ=Once!] :: Int32)
                 (ds1_d4ezf [Occ=Once!] :: Int32) ->
                 case ds_d4eze of { I32# x_a4d2z [Occ=Once] ->
                 case ds1_d4ezf of { I32# y_a4d2A [Occ=Once] ->
                 tagToEnum# @ Bool (<=# x_a4d2z y_a4d2A)
                 }
                 }}]
leInt32
  = \ (ds_d4eze :: Int32) (ds1_d4ezf :: Int32) ->
      case ds_d4eze of { I32# x_a4d2z ->
      case ds1_d4ezf of { I32# y_a4d2A ->
      tagToEnum# @ Bool (<=# x_a4d2z y_a4d2A)
      }
      }

-- RHS size: {terms: 23, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt32_$ccompare :: Int32 -> Int32 -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fi2 [Occ=Once!] :: Int32)
                 (y_a1fi3 [Occ=Once!] :: Int32) ->
                 case x_a1fi2 of { I32# x1_a4d2p ->
                 case y_a1fi3 of { I32# y1_a4d2q ->
                 case ==# x1_a4d2p y1_a4d2q of {
                   __DEFAULT ->
                     case <=# x1_a4d2p y1_a4d2q of {
                       __DEFAULT -> GHC.Types.GT;
                       1# -> GHC.Types.LT
                     };
                   1# -> GHC.Types.EQ
                 }
                 }
                 }}]
GHC.Int.$fOrdInt32_$ccompare
  = \ (x_a1fi2 :: Int32) (y_a1fi3 :: Int32) ->
      case x_a1fi2 of { I32# x1_a4d2p ->
      case y_a1fi3 of { I32# y1_a4d2q ->
      case ==# x1_a4d2p y1_a4d2q of {
        __DEFAULT ->
          case <=# x1_a4d2p y1_a4d2q of {
            __DEFAULT -> GHC.Types.GT;
            1# -> GHC.Types.LT
          };
        1# -> GHC.Types.EQ
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt32_$cmax :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once!] :: Int32)
                 (y_a55e [Occ=Once!] :: Int32) ->
                 case x_a55d of wild_X9M { I32# x1_a4d2z [Occ=Once] ->
                 case y_a55e of wild1_X5 { I32# y1_a4d2A [Occ=Once] ->
                 case <=# x1_a4d2z y1_a4d2A of {
                   __DEFAULT -> wild_X9M;
                   1# -> wild1_X5
                 }
                 }
                 }}]
GHC.Int.$fOrdInt32_$cmax
  = \ (x_a55d :: Int32) (y_a55e :: Int32) ->
      case x_a55d of wild_X9M { I32# x1_a4d2z ->
      case y_a55e of wild1_X5 { I32# y1_a4d2A ->
      case <=# x1_a4d2z y1_a4d2A of {
        __DEFAULT -> wild_X9M;
        1# -> wild1_X5
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt32_$cmin :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m [Occ=Once!] :: Int32)
                 (y_a55n [Occ=Once!] :: Int32) ->
                 case x_a55m of wild_X9M { I32# x1_a4d2z [Occ=Once] ->
                 case y_a55n of wild1_X5 { I32# y1_a4d2A [Occ=Once] ->
                 case <=# x1_a4d2z y1_a4d2A of {
                   __DEFAULT -> wild1_X5;
                   1# -> wild_X9M
                 }
                 }
                 }}]
GHC.Int.$fOrdInt32_$cmin
  = \ (x_a55m :: Int32) (y_a55n :: Int32) ->
      case x_a55m of wild_X9M { I32# x1_a4d2z ->
      case y_a55n of wild1_X5 { I32# y1_a4d2A ->
      case <=# x1_a4d2z y1_a4d2A of {
        __DEFAULT -> wild1_X5;
        1# -> wild_X9M
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt32 [InlPrag=NOUSERINLINE CONLIKE] :: Ord Int32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Int32
                         GHC.Int.$fEqInt32
                         GHC.Int.$fOrdInt32_$ccompare
                         ltInt32
                         leInt32
                         gtInt32
                         geInt32
                         GHC.Int.$fOrdInt32_$cmax
                         GHC.Int.$fOrdInt32_$cmin]
GHC.Int.$fOrdInt32
  = GHC.Classes.C:Ord
      @ Int32
      GHC.Int.$fEqInt32
      GHC.Int.$fOrdInt32_$ccompare
      ltInt32
      leInt32
      gtInt32
      geInt32
      GHC.Int.$fOrdInt32_$cmax
      GHC.Int.$fOrdInt32_$cmin

-- RHS size: {terms: 25, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt32_$cinRange :: (Int32, Int32) -> Int32 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),1*U(U))><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eG5 [Occ=Once!] :: (Int32, Int32))
                 (i_a4cY9 [Occ=Once!] :: Int32) ->
                 case ds_d4eG5 of { (m_a4cY7 [Occ=Once!], n_a4cY8 [Occ=Once!]) ->
                 case m_a4cY7 of { I32# x_a4d2z [Occ=Once] ->
                 case i_a4cY9 of { I32# y_a4d2A ->
                 case <=# x_a4d2z y_a4d2A of {
                   __DEFAULT -> GHC.Types.False;
                   1# ->
                     case n_a4cY8 of { I32# y1_X4dhv [Occ=Once] ->
                     tagToEnum# @ Bool (<=# y_a4d2A y1_X4dhv)
                     }
                 }
                 }
                 }
                 }}]
GHC.Int.$fIxInt32_$cinRange
  = \ (ds_d4eG5 :: (Int32, Int32)) (i_a4cY9 :: Int32) ->
      case ds_d4eG5 of { (m_a4cY7, n_a4cY8) ->
      case m_a4cY7 of { I32# x_a4d2z ->
      case i_a4cY9 of { I32# y_a4d2A ->
      case <=# x_a4d2z y_a4d2A of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case n_a4cY8 of { I32# y1_X4dhv ->
          tagToEnum# @ Bool (<=# y_a4d2A y1_X4dhv)
          }
      }
      }
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt3 :: Int32
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fNumInt3 = GHC.Int.I32# 1#

-- RHS size: {terms: 17, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt32_$csignum :: Int32 -> Int32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4cZj [Occ=Once!] :: Int32) ->
                 case x_a4cZj of { I32# x1_a4d2t ->
                 case ># x1_a4d2t 0# of {
                   __DEFAULT ->
                     case x1_a4d2t of {
                       __DEFAULT -> GHC.Int.$fNumInt4;
                       0# -> GHC.Int.$fBitsInt6
                     };
                   1# -> GHC.Int.$fNumInt3
                 }
                 }}]
GHC.Int.$fNumInt32_$csignum
  = \ (x_a4cZj :: Int32) ->
      case x_a4cZj of { I32# x1_a4d2t ->
      case ># x1_a4d2t 0# of {
        __DEFAULT ->
          case x1_a4d2t of {
            __DEFAULT -> GHC.Int.$fNumInt4;
            0# -> GHC.Int.$fBitsInt6
          };
        1# -> GHC.Int.$fNumInt3
      }
      }

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt32_$cabs :: Int32 -> Int32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4cZi [Occ=Once!] :: Int32) ->
                 case x_a4cZi of wild_X9K { I32# x1_a4d2v ->
                 case >=# x1_a4d2v 0# of {
                   __DEFAULT -> GHC.Int.I32# (narrow32Int# (negateInt# x1_a4d2v));
                   1# -> wild_X9K
                 }
                 }}]
GHC.Int.$fNumInt32_$cabs
  = \ (x_a4cZi :: Int32) ->
      case x_a4cZi of wild_X9K { I32# x1_a4d2v ->
      case >=# x1_a4d2v 0# of {
        __DEFAULT -> GHC.Int.I32# (narrow32Int# (negateInt# x1_a4d2v));
        1# -> wild_X9K
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt32 [InlPrag=NOUSERINLINE CONLIKE] :: Num Int32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Int32
                     GHC.Int.$fNumInt32_$c+
                     GHC.Int.$fNumInt32_$c-
                     GHC.Int.$fNumInt32_$c*
                     GHC.Int.$fNumInt32_$cnegate
                     GHC.Int.$fNumInt32_$cabs
                     GHC.Int.$fNumInt32_$csignum
                     GHC.Int.$fNumInt32_$cfromInteger]
GHC.Int.$fNumInt32
  = GHC.Num.C:Num
      @ Int32
      GHC.Int.$fNumInt32_$c+
      GHC.Int.$fNumInt32_$c-
      GHC.Int.$fNumInt32_$c*
      GHC.Int.$fNumInt32_$cnegate
      GHC.Int.$fNumInt32_$cabs
      GHC.Int.$fNumInt32_$csignum
      GHC.Int.$fNumInt32_$cfromInteger

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt5 :: Maybe Int
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt5 = GHC.Base.Just @ Int GHC.Int.$fBitsInt4

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cbitSizeMaybe :: Int32 -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Int.$fBitsInt5}]
GHC.Int.$fBitsInt32_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> GHC.Int.$fBitsInt5

-- RHS size: {terms: 16, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cbit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Int32
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once!] :: Int) ->
                 case i_a1A6g of { I# i#_a4cYn ->
                 case >=# i#_a4cYn 64# of {
                   __DEFAULT ->
                     GHC.Int.I32# (narrow32Int# (uncheckedIShiftL# 1# i#_a4cYn));
                   1# -> GHC.Int.I32# 0#
                 }
                 }}]
GHC.Int.$fBitsInt32_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# i#_a4cYn ->
      case >=# i#_a4cYn 64# of {
        __DEFAULT ->
          GHC.Int.I32# (narrow32Int# (uncheckedIShiftL# 1# i#_a4cYn));
        1# -> GHC.Int.$fBitsInt6
      }
      }

-- RHS size: {terms: 29, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: Int32 -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A6h [Occ=Once!] :: Int32)
                 (i_a1A6i [Occ=Once!] :: Int) ->
                 case x_a1A6h of { I32# x#_a4cYd [Occ=Once] ->
                 case i_a1A6i of { I# i#_a4cYn ->
                 case >=# i#_a4cYn 64# of {
                   __DEFAULT ->
                     neInt32
                       (GHC.Int.I32#
                          (word2Int#
                             (and#
                                (int2Word# x#_a4cYd)
                                (int2Word# (narrow32Int# (uncheckedIShiftL# 1# i#_a4cYn))))))
                       (GHC.Int.I32# 0#);
                   1# -> neInt32 (GHC.Int.I32# 0#) (GHC.Int.I32# 0#)
                 }
                 }
                 }}]
GHC.Int.$fBitsInt32_$ctestBit
  = \ (x_a1A6h :: Int32) (i_a1A6i :: Int) ->
      case x_a1A6h of { I32# x#_a4cYd ->
      case i_a1A6i of { I# i#_a4cYn ->
      case >=# i#_a4cYn 64# of {
        __DEFAULT ->
          case word2Int#
                 (and#
                    (int2Word# x#_a4cYd)
                    (int2Word# (narrow32Int# (uncheckedIShiftL# 1# i#_a4cYn))))
          of {
            __DEFAULT -> GHC.Types.True;
            0# -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 34, types: 8, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt32_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once!] :: Int32)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case x_a1A54 of { I32# x#_a4cYu ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 let {
                   x'#_a4cYw :: Word#
                   [LclId]
                   x'#_a4cYw = narrow32Word# (int2Word# x#_a4cYu) } in
                 case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 31##)
                 of wild2_X74 {
                   __DEFAULT ->
                     GHC.Int.I32#
                       (narrow32Int#
                          (word2Int#
                             (or#
                                (uncheckedShiftL# x'#_a4cYw wild2_X74)
                                (uncheckedShiftRL# x'#_a4cYw (-# 32# wild2_X74)))));
                   0# -> GHC.Int.I32# x#_a4cYu
                 }
                 }
                 }}]
GHC.Int.$fBitsInt32_$crotateR
  = \ (eta_B2 :: Int32) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6Q { I32# x#_a4cYu ->
      case eta1_B1 of { I# x1_i1AMT ->
      case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 31##)
      of wild2_X74 {
        __DEFAULT ->
          let {
            x'#_s4fBz [Dmd=<S,U>] :: Word#
            [LclId]
            x'#_s4fBz = narrow32Word# (int2Word# x#_a4cYu) } in
          GHC.Int.I32#
            (narrow32Int#
               (word2Int#
                  (or#
                     (uncheckedShiftL# x'#_s4fBz wild2_X74)
                     (uncheckedShiftRL# x'#_s4fBz (-# 32# wild2_X74)))));
        0# -> wild_X6Q
      }
      }
      }

-- RHS size: {terms: 25, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Int32)
                 (i_a1A4T [Occ=Once!] :: Int) ->
                 case x_a1A4S of { I32# x#_a4cYh [Occ=Once*] ->
                 case i_a1A4T of { I# i#_a4cYn ->
                 case >=# i#_a4cYn 64# of {
                   __DEFAULT ->
                     GHC.Int.I32#
                       (word2Int#
                          (xor#
                             (int2Word# x#_a4cYh)
                             (int2Word# (narrow32Int# (uncheckedIShiftL# 1# i#_a4cYn)))));
                   1# -> GHC.Int.I32# x#_a4cYh
                 }
                 }
                 }}]
GHC.Int.$fBitsInt32_$ccomplementBit
  = \ (eta_B2 :: Int32) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6T { I32# x#_a4cYh ->
      case eta1_B1 of { I# i#_a4cYn ->
      case >=# i#_a4cYn 64# of {
        __DEFAULT ->
          GHC.Int.I32#
            (word2Int#
               (xor#
                  (int2Word# x#_a4cYh)
                  (int2Word# (narrow32Int# (uncheckedIShiftL# 1# i#_a4cYn)))));
        1# -> wild_X6T
      }
      }
      }

-- RHS size: {terms: 31, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Int32)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of { I32# x#_a4cYd [Occ=Once*] ->
                 case i_a1A4R of { I# i#_a4cYn ->
                 case >=# i#_a4cYn 64# of {
                   __DEFAULT ->
                     GHC.Int.I32#
                       (word2Int#
                          (and#
                             (int2Word# x#_a4cYd)
                             (not#
                                (int2Word# (narrow32Int# (uncheckedIShiftL# 1# i#_a4cYn))))));
                   1# ->
                     GHC.Int.I32#
                       (word2Int# (and# (int2Word# x#_a4cYd) 18446744073709551615##))
                 }
                 }
                 }}]
GHC.Int.$fBitsInt32_$cclearBit
  = \ (eta_B2 :: Int32) (eta1_B1 :: Int) ->
      case eta_B2 of { I32# x#_a4cYd ->
      case eta1_B1 of { I# i#_a4cYn ->
      case >=# i#_a4cYn 64# of {
        __DEFAULT ->
          GHC.Int.I32#
            (word2Int#
               (and#
                  (int2Word# x#_a4cYd)
                  (not#
                     (int2Word# (narrow32Int# (uncheckedIShiftL# 1# i#_a4cYn))))));
        1# ->
          GHC.Int.I32#
            (word2Int# (and# (int2Word# x#_a4cYd) 18446744073709551615##))
      }
      }
      }

-- RHS size: {terms: 25, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Int32)
                 (i_a1A4P [Occ=Once!] :: Int) ->
                 case x_a1A4O of { I32# x#_a4cYf [Occ=Once*] ->
                 case i_a1A4P of { I# i#_a4cYn ->
                 case >=# i#_a4cYn 64# of {
                   __DEFAULT ->
                     GHC.Int.I32#
                       (word2Int#
                          (or#
                             (int2Word# x#_a4cYf)
                             (int2Word# (narrow32Int# (uncheckedIShiftL# 1# i#_a4cYn)))));
                   1# -> GHC.Int.I32# x#_a4cYf
                 }
                 }
                 }}]
GHC.Int.$fBitsInt32_$csetBit
  = \ (eta_B2 :: Int32) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X6U { I32# x#_a4cYf ->
      case eta1_B1 of { I# i#_a4cYn ->
      case >=# i#_a4cYn 64# of {
        __DEFAULT ->
          GHC.Int.I32#
            (word2Int#
               (or#
                  (int2Word# x#_a4cYf)
                  (int2Word# (narrow32Int# (uncheckedIShiftL# 1# i#_a4cYn)))));
        1# -> wild_X6U
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Int32 -> Int -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Int.$fBitsInt32_$crotate}]
GHC.Int.$fBitsInt32_$crotateL = GHC.Int.$fBitsInt32_$crotate

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt32 [InlPrag=NOUSERINLINE CONLIKE] :: Bits Int32
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Int32
                        GHC.Int.$fEqInt32
                        GHC.Int.$fBitsInt32_$c.&.
                        GHC.Int.$fBitsInt32_$c.|.
                        GHC.Int.$fBitsInt32_$cxor
                        GHC.Int.$fBitsInt32_$ccomplement
                        GHC.Int.$fBitsInt32_$cshift
                        GHC.Int.$fBitsInt32_$crotate
                        GHC.Int.$fBitsInt6
                        GHC.Int.$fBitsInt32_$cbit
                        GHC.Int.$fBitsInt32_$csetBit
                        GHC.Int.$fBitsInt32_$cclearBit
                        GHC.Int.$fBitsInt32_$ccomplementBit
                        GHC.Int.$fBitsInt32_$ctestBit
                        GHC.Int.$fBitsInt32_$cbitSizeMaybe
                        GHC.Int.$fBitsInt32_$cfiniteBitSize
                        GHC.Int.$fBitsInt32_$cisSigned
                        GHC.Int.$fBitsInt32_$cshiftL
                        GHC.Int.$fBitsInt32_$cunsafeShiftL
                        GHC.Int.$fBitsInt32_$cshiftR
                        GHC.Int.$fBitsInt32_$cunsafeShiftR
                        GHC.Int.$fBitsInt32_$crotateL
                        GHC.Int.$fBitsInt32_$crotateR
                        GHC.Int.$fBitsInt32_$cpopCount]
GHC.Int.$fBitsInt32
  = Data.Bits.C:Bits
      @ Int32
      GHC.Int.$fEqInt32
      GHC.Int.$fBitsInt32_$c.&.
      GHC.Int.$fBitsInt32_$c.|.
      GHC.Int.$fBitsInt32_$cxor
      GHC.Int.$fBitsInt32_$ccomplement
      GHC.Int.$fBitsInt32_$cshift
      GHC.Int.$fBitsInt32_$crotate
      GHC.Int.$fBitsInt6
      GHC.Int.$fBitsInt32_$cbit
      GHC.Int.$fBitsInt32_$csetBit
      GHC.Int.$fBitsInt32_$cclearBit
      GHC.Int.$fBitsInt32_$ccomplementBit
      GHC.Int.$fBitsInt32_$ctestBit
      GHC.Int.$fBitsInt32_$cbitSizeMaybe
      GHC.Int.$fBitsInt32_$cfiniteBitSize
      GHC.Int.$fBitsInt32_$cisSigned
      GHC.Int.$fBitsInt32_$cshiftL
      GHC.Int.$fBitsInt32_$cunsafeShiftL
      GHC.Int.$fBitsInt32_$cshiftR
      GHC.Int.$fBitsInt32_$cunsafeShiftR
      GHC.Int.$fBitsInt32_$crotateL
      GHC.Int.$fBitsInt32_$crotateR
      GHC.Int.$fBitsInt32_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt32 [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Int32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Int32
                              GHC.Int.$fBitsInt32
                              GHC.Int.$fBitsInt32_$cfiniteBitSize
                              GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros
                              GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros]
GHC.Int.$fFiniteBitsInt32
  = Data.Bits.C:FiniteBits
      @ Int32
      GHC.Int.$fBitsInt32
      GHC.Int.$fBitsInt32_$cfiniteBitSize
      GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros
      GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros

Rec {
-- RHS size: {terms: 20, types: 30, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt32_go [Occ=LoopBreaker]
  :: [(Int, String)] -> [(Int32, String)]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
GHC.Int.$fReadInt32_go
  = \ (ds_i1y1c :: [(Int, String)]) ->
      case ds_i1y1c of {
        [] -> GHC.Types.[] @ (Int32, String);
        : y_i1y1h ys_i1y1i ->
          case y_i1y1h of { (x_a4cYD, r_a4cYE) ->
          GHC.Types.:
            @ (Int32, String)
            (case x_a4cYD of { I# x#_a4d37 ->
             GHC.Int.I32# (narrow32Int# x#_a4d37)
             },
             r_a4cYE)
            (GHC.Int.$fReadInt32_go ys_i1y1i)
          }
      }
end Rec }

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt32_$creadsPrec :: Int -> ReadS Int32
[GblId,
 Arity=2,
 Str=<L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 90 0}]
GHC.Int.$fReadInt32_$creadsPrec
  = \ (p_a4cYB :: Int) (s_a4cYC :: String) ->
      GHC.Int.$fReadInt32_go
        (Text.ParserCombinators.ReadP.run
           @ Int
           (GHC.Read.$fReadInt_$sreadNumber
              GHC.Read.$fReadInt2
              p_a4cYB
              @ Int
              (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Int))
           s_a4cYC)

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt6
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Int32 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,U><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_X3twX [Occ=Once]
                    :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_s3ofG)
                 (eta_B1 [Occ=Once]
                    :: Int32 -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ Int32 (GHC.Int.$fReadInt32_$creadsPrec n_X3twX) @ b_s3ofG eta_B1
                 of
                 { (# ww1_s3oiG [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
                 }}]
GHC.Int.$fReadInt6
  = \ (n_X3twX :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_s3ofG)
      (eta_B1 :: Int32 -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ Int32 (GHC.Int.$fReadInt32_$creadsPrec n_X3twX) @ b_s3ofG eta_B1
      of
      { (# ww1_s3oiG #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
      }

-- RHS size: {terms: 4, types: 5, coercions: 15, joins: 0/0}
GHC.Int.$fReadInt5 :: Text.ParserCombinators.ReadP.P [Int32]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
GHC.Int.$fReadInt5
  = ((((list
          @ Int32
          (GHC.Int.$fReadInt6
           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Int32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                         <Int32>_R)
                   :: (Text.ParserCombinators.ReadPrec.Prec
                       -> forall b.
                          (Int32 -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)
                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int32 :: *))))
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Int32]>_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Int32] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [Int32] :: *)))
        GHC.Int.$fIxInt1)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Int32]>_R
             :: (Text.ParserCombinators.ReadP.ReadP [Int32] :: *)
                ~R# (forall b.
                     ([Int32] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)))
      @ [Int32]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [Int32])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt32_$creadList :: ReadS [Int32]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.Int.$fReadInt32_$creadList
  = Text.ParserCombinators.ReadP.run @ [Int32] GHC.Int.$fReadInt5

-- RHS size: {terms: 10, types: 19, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt4
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([Int32] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,A><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_s3ofG)
                 (w1_s3ofH [Occ=Once]
                    :: [Int32] -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ [Int32] GHC.Int.$fReadInt32_$creadList @ b_s3ofG w1_s3ofH
                 of
                 { (# ww1_s3oiG [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
                 }}]
GHC.Int.$fReadInt4
  = \ _ [Occ=Dead]
      (@ b_s3ofG)
      (w1_s3ofH :: [Int32] -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ [Int32] GHC.Int.$fReadInt32_$creadList @ b_s3ofG w1_s3ofH
      of
      { (# ww1_s3oiG #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
      }

-- RHS size: {terms: 5, types: 1, coercions: 20, joins: 0/0}
GHC.Int.$fReadInt32 [InlPrag=NOUSERINLINE CONLIKE] :: Read Int32
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: Int32
                       GHC.Int.$fReadInt32_$creadsPrec
                       GHC.Int.$fReadInt32_$creadList
                       GHC.Int.$fReadInt6
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <Int32>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int32 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int32 :: *))
                       GHC.Int.$fReadInt4
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       <[Int32]>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int32] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [Int32] :: *))]
GHC.Int.$fReadInt32
  = GHC.Read.C:Read
      @ Int32
      GHC.Int.$fReadInt32_$creadsPrec
      GHC.Int.$fReadInt32_$creadList
      (GHC.Int.$fReadInt6
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     <Int32>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int32 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int32 :: *)))
      (GHC.Int.$fReadInt4
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <[Int32]>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int32] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [Int32] :: *)))

-- RHS size: {terms: 34, types: 15, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt32_$cquot [InlPrag=NOUSERINLINE[0]]
  :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iHI [Occ=Once!] :: Int32)
                 (w1_s4iHJ [Occ=Once!] :: Int32) ->
                 case w_s4iHI of { I32# ww1_s4iHM [Occ=Once*] ->
                 case w1_s4iHJ of { I32# ww3_s4iHQ [Occ=Once!] ->
                 case ww3_s4iHQ of wild_Xfl {
                   __DEFAULT ->
                     case quotInt# ww1_s4iHM wild_Xfl of wild1_X4g { __DEFAULT ->
                     GHC.Int.I32# (narrow32Int# wild1_X4g)
                     };
                   -1# ->
                     case ww1_s4iHM of wild1_Xft {
                       __DEFAULT -> GHC.Int.I32# (narrow32Int# (quotInt# wild1_Xft -1#));
                       -2147483648# -> case overflowError of { }
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt32_$cquot
  = \ (w_s4iHI :: Int32) (w1_s4iHJ :: Int32) ->
      case w_s4iHI of { I32# ww1_s4iHM ->
      case w1_s4iHJ of { I32# ww3_s4iHQ ->
      case ww3_s4iHQ of wild_Xfl {
        __DEFAULT ->
          case quotInt# ww1_s4iHM wild_Xfl of wild1_X4g { __DEFAULT ->
          GHC.Int.I32# (narrow32Int# wild1_X4g)
          };
        -1# ->
          case ww1_s4iHM of wild1_Xft {
            __DEFAULT -> GHC.Int.I32# (narrow32Int# (quotInt# wild1_Xft -1#));
            -2147483648# -> case overflowError of wild2_00 { }
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 23, types: 9, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt32_$crem :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Str=<S,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eI6 [Occ=Once!] :: Int32)
                 (y_a4cYK [Occ=Once!] :: Int32) ->
                 case ds_d4eI6 of { I32# x#_a4cYJ [Occ=Once] ->
                 case y_a4cYK of { I32# y#_a4cYL [Occ=Once!] ->
                 case y#_a4cYL of wild2_Xfp {
                   __DEFAULT ->
                     case remInt# x#_a4cYJ wild2_Xfp of wild3_X4h { __DEFAULT ->
                     GHC.Int.I32# (narrow32Int# wild3_X4h)
                     };
                   -1# -> GHC.Int.$fBitsInt6;
                   0# -> divZeroError @ Int32
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt32_$crem
  = \ (ds_d4eI6 :: Int32) (y_a4cYK :: Int32) ->
      case ds_d4eI6 of { I32# x#_a4cYJ ->
      case y_a4cYK of { I32# y#_a4cYL ->
      case y#_a4cYL of wild2_Xfp {
        __DEFAULT ->
          case remInt# x#_a4cYJ wild2_Xfp of wild3_X4h { __DEFAULT ->
          GHC.Int.I32# (narrow32Int# wild3_X4h)
          };
        -1# -> GHC.Int.$fBitsInt6;
        0# -> divZeroError @ Int32
      }
      }
      }

-- RHS size: {terms: 29, types: 12, coercions: 0, joins: 0/0}
GHC.Int.$w$cdiv1 [InlPrag=NOUSERINLINE[0]] :: Int# -> Int# -> Int#
[GblId,
 Arity=2,
 Str=<S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 81] 132 0}]
GHC.Int.$w$cdiv1
  = \ (ww_s4iI0 :: Int#) (ww1_s4iI4 :: Int#) ->
      case ww1_s4iI4 of wild_Xfs {
        __DEFAULT ->
          case divInt# ww_s4iI0 wild_Xfs of wild1_X4i { __DEFAULT ->
          narrow32Int# wild1_X4i
          };
        -1# ->
          case ww_s4iI0 of wild1_XfA {
            __DEFAULT ->
              case divInt# wild1_XfA -1# of wild2_X4i { __DEFAULT ->
              narrow32Int# wild2_X4i
              };
            -2147483648# -> case overflowError of wild2_00 { }
          };
        0# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt32_$cdiv [InlPrag=NOUSERINLINE[0]]
  :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iHW [Occ=Once!] :: Int32)
                 (w1_s4iHX [Occ=Once!] :: Int32) ->
                 case w_s4iHW of { I32# ww1_s4iI0 [Occ=Once] ->
                 case w1_s4iHX of { I32# ww3_s4iI4 [Occ=Once] ->
                 case GHC.Int.$w$cdiv1 ww1_s4iI0 ww3_s4iI4 of ww4_s4iI8
                 { __DEFAULT ->
                 GHC.Int.I32# ww4_s4iI8
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt32_$cdiv
  = \ (w_s4iHW :: Int32) (w1_s4iHX :: Int32) ->
      case w_s4iHW of { I32# ww1_s4iI0 ->
      case w1_s4iHX of { I32# ww3_s4iI4 ->
      case GHC.Int.$w$cdiv1 ww1_s4iI0 ww3_s4iI4 of ww4_s4iI8
      { __DEFAULT ->
      GHC.Int.I32# ww4_s4iI8
      }
      }
      }

-- RHS size: {terms: 24, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt32_$cmod [InlPrag=NOUSERINLINE[0]]
  :: Int32 -> Int32 -> Int32
[GblId,
 Arity=2,
 Str=<S,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iIa [Occ=Once!] :: Int32)
                 (w1_s4iIb [Occ=Once!] :: Int32) ->
                 case w_s4iIa of { I32# ww1_s4iIe [Occ=Once] ->
                 case w1_s4iIb of { I32# ww3_s4iIi [Occ=Once!] ->
                 case ww3_s4iIi of wild_Xfw {
                   __DEFAULT ->
                     case modInt# ww1_s4iIe wild_Xfw of wild1_X4j { __DEFAULT ->
                     GHC.Int.I32# (narrow32Int# wild1_X4j)
                     };
                   -1# -> GHC.Int.I32# 0#;
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt32_$cmod
  = \ (w_s4iIa :: Int32) (w1_s4iIb :: Int32) ->
      case w_s4iIa of { I32# ww1_s4iIe ->
      case w1_s4iIb of { I32# ww3_s4iIi ->
      case ww3_s4iIi of wild_Xfw {
        __DEFAULT ->
          case modInt# ww1_s4iIe wild_Xfw of wild1_X4j { __DEFAULT ->
          GHC.Int.I32# (narrow32Int# wild1_X4j)
          };
        -1# -> GHC.Int.$fBitsInt6;
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
lvl8_r4kPz :: (Int32, Int32)
[GblId, Str=m, Unf=OtherCon []]
lvl8_r4kPz = (overflowError @ Int32, GHC.Int.$fBitsInt6)

-- RHS size: {terms: 44, types: 29, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt32_$cquotRem [InlPrag=NOUSERINLINE[0]]
  :: Int32 -> Int32 -> (Int32, Int32)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iIo [Occ=Once!] :: Int32)
                 (w1_s4iIp [Occ=Once!] :: Int32) ->
                 case w_s4iIo of { I32# ww1_s4iIs [Occ=Once*] ->
                 case w1_s4iIp of { I32# ww3_s4iIw [Occ=Once!] ->
                 case ww3_s4iIw of wild_XfB {
                   __DEFAULT ->
                     case quotRemInt# ww1_s4iIs wild_XfB of
                     { (# ipv_s4f4A [Occ=Once], ipv1_s4f4B [Occ=Once] #) ->
                     (GHC.Int.I32# (narrow32Int# ipv_s4f4A),
                      GHC.Int.I32# (narrow32Int# ipv1_s4f4B))
                     };
                   -1# ->
                     case ww1_s4iIs of wild1_XfJ {
                       __DEFAULT ->
                         case quotRemInt# wild1_XfJ -1# of
                         { (# ipv_s4f4A [Occ=Once], ipv1_s4f4B [Occ=Once] #) ->
                         (GHC.Int.I32# (narrow32Int# ipv_s4f4A),
                          GHC.Int.I32# (narrow32Int# ipv1_s4f4B))
                         };
                       -2147483648# -> (overflowError @ Int32, GHC.Int.$fBitsInt6)
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt32_$cquotRem
  = \ (w_s4iIo :: Int32) (w1_s4iIp :: Int32) ->
      case w_s4iIo of { I32# ww1_s4iIs ->
      case w1_s4iIp of { I32# ww3_s4iIw ->
      case ww3_s4iIw of wild_XfB {
        __DEFAULT ->
          case quotRemInt# ww1_s4iIs wild_XfB of
          { (# ipv_s4f4A, ipv1_s4f4B #) ->
          (GHC.Int.I32# (narrow32Int# ipv_s4f4A),
           GHC.Int.I32# (narrow32Int# ipv1_s4f4B))
          };
        -1# ->
          case ww1_s4iIs of wild1_XfJ {
            __DEFAULT ->
              case quotRemInt# wild1_XfJ -1# of { (# ipv_s4f4A, ipv1_s4f4B #) ->
              (GHC.Int.I32# (narrow32Int# ipv_s4f4A),
               GHC.Int.I32# (narrow32Int# ipv1_s4f4B))
              };
            -2147483648# -> lvl8_r4kPz
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 166, types: 101, coercions: 0, joins: 1/1}
GHC.Int.$w$cdivMod1 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> (# Int32, Int32 #)
[GblId,
 Arity=2,
 Str=<S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 363 30}]
GHC.Int.$w$cdivMod1
  = \ (ww_s4iIG :: Int#) (ww1_s4iIK :: Int#) ->
      case ww1_s4iIK of wild_XfG {
        __DEFAULT ->
          join {
            $j_s4fQG [Dmd=<L,1*U(U,U)>] :: (# Int32, Int32 #)
            [LclId[JoinId(0)]]
            $j_s4fQG
              = case ># ww_s4iIG 0# of {
                  __DEFAULT ->
                    case <# ww_s4iIG 0# of {
                      __DEFAULT ->
                        case quotRemInt# ww_s4iIG wild_XfG of
                        { (# ipv_s4f4J, ipv1_s4f4K #) ->
                        (# GHC.Int.I32# (narrow32Int# ipv_s4f4J),
                           GHC.Int.I32# (narrow32Int# ipv1_s4f4K) #)
                        };
                      1# ->
                        case ># wild_XfG 0# of {
                          __DEFAULT ->
                            case quotRemInt# ww_s4iIG wild_XfG of
                            { (# ipv_s4f4J, ipv1_s4f4K #) ->
                            (# GHC.Int.I32# (narrow32Int# ipv_s4f4J),
                               GHC.Int.I32# (narrow32Int# ipv1_s4f4K) #)
                            };
                          1# ->
                            case quotRemInt# (+# ww_s4iIG 1#) wild_XfG of
                            { (# ipv_i4eEn, ipv1_i4eEo #) ->
                            (# GHC.Int.I32# (narrow32Int# (-# ipv_i4eEn 1#)),
                               GHC.Int.I32# (narrow32Int# (-# (+# ipv1_i4eEo wild_XfG) 1#)) #)
                            }
                        }
                    };
                  1# ->
                    case <# wild_XfG 0# of {
                      __DEFAULT ->
                        case <# ww_s4iIG 0# of {
                          __DEFAULT ->
                            case quotRemInt# ww_s4iIG wild_XfG of
                            { (# ipv_s4f4J, ipv1_s4f4K #) ->
                            (# GHC.Int.I32# (narrow32Int# ipv_s4f4J),
                               GHC.Int.I32# (narrow32Int# ipv1_s4f4K) #)
                            };
                          1# ->
                            case ># wild_XfG 0# of {
                              __DEFAULT ->
                                case quotRemInt# ww_s4iIG wild_XfG of
                                { (# ipv_s4f4J, ipv1_s4f4K #) ->
                                (# GHC.Int.I32# (narrow32Int# ipv_s4f4J),
                                   GHC.Int.I32# (narrow32Int# ipv1_s4f4K) #)
                                };
                              1# ->
                                case quotRemInt# (+# ww_s4iIG 1#) wild_XfG of
                                { (# ipv_i4eEv, ipv1_i4eEw #) ->
                                (# GHC.Int.I32# (narrow32Int# (-# ipv_i4eEv 1#)),
                                   GHC.Int.I32# (narrow32Int# (-# (+# ipv1_i4eEw wild_XfG) 1#)) #)
                                }
                            }
                        };
                      1# ->
                        case quotRemInt# (-# ww_s4iIG 1#) wild_XfG of
                        { (# ipv_i4eEA, ipv1_i4eEB #) ->
                        (# GHC.Int.I32# (narrow32Int# (-# ipv_i4eEA 1#)),
                           GHC.Int.I32# (narrow32Int# (+# (+# ipv1_i4eEB wild_XfG) 1#)) #)
                        }
                    }
                } } in
          case wild_XfG of {
            __DEFAULT -> jump $j_s4fQG;
            -1# ->
              case ww_s4iIG of {
                __DEFAULT -> jump $j_s4fQG;
                -2147483648# -> (# overflowError @ Int32, GHC.Int.$fBitsInt6 #)
              }
          };
        0# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 16, types: 15, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt32_$cdivMod [InlPrag=NOUSERINLINE[0]]
  :: Int32 -> Int32 -> (Int32, Int32)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iIC [Occ=Once!] :: Int32)
                 (w1_s4iID [Occ=Once!] :: Int32) ->
                 case w_s4iIC of { I32# ww1_s4iIG [Occ=Once] ->
                 case w1_s4iID of { I32# ww3_s4iIK [Occ=Once] ->
                 case GHC.Int.$w$cdivMod1 ww1_s4iIG ww3_s4iIK of
                 { (# ww5_s4iKQ [Occ=Once], ww6_s4iKR [Occ=Once] #) ->
                 (ww5_s4iKQ, ww6_s4iKR)
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt32_$cdivMod
  = \ (w_s4iIC :: Int32) (w1_s4iID :: Int32) ->
      case w_s4iIC of { I32# ww1_s4iIG ->
      case w1_s4iID of { I32# ww3_s4iIK ->
      case GHC.Int.$w$cdivMod1 ww1_s4iIG ww3_s4iIK of
      { (# ww5_s4iKQ, ww6_s4iKR #) ->
      (ww5_s4iKQ, ww6_s4iKR)
      }
      }
      }

-- RHS size: {terms: 15, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fRealInt32_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Int32 -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iIQ [Occ=Once!] :: Int32) ->
                 case w_s4iIQ of { I32# ww1_s4iIT [Occ=Once] ->
                 case GHC.Real.$w$sreduce
                        (timesInteger (smallInteger ww1_s4iIT) GHC.Int.$fRealInt1)
                        GHC.Int.$fRealInt1
                 of
                 { (# ww3_s4iKT [Occ=Once], ww4_s4iKU [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s4iKT ww4_s4iKU
                 }
                 }}]
GHC.Int.$fRealInt32_$ctoRational
  = \ (w_s4iIQ :: Int32) ->
      case w_s4iIQ of { I32# ww1_s4iIT ->
      case GHC.Real.$w$sreduce
             (timesInteger (smallInteger ww1_s4iIT) GHC.Int.$fRealInt1)
             GHC.Int.$fRealInt1
      of
      { (# ww3_s4iKT, ww4_s4iKU #) ->
      GHC.Real.:% @ Integer ww3_s4iKT ww4_s4iKU
      }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fRealInt32 [InlPrag=NOUSERINLINE CONLIKE] :: Real Int32
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Int32
                       GHC.Int.$fNumInt32
                       GHC.Int.$fOrdInt32
                       GHC.Int.$fRealInt32_$ctoRational]
GHC.Int.$fRealInt32
  = GHC.Real.C:Real
      @ Int32
      GHC.Int.$fNumInt32
      GHC.Int.$fOrdInt32
      GHC.Int.$fRealInt32_$ctoRational

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Int32
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Int32
                           GHC.Int.$fRealInt32
                           GHC.Int.$fEnumInt32
                           GHC.Int.$fIntegralInt32_$cquot
                           GHC.Int.$fIntegralInt32_$crem
                           GHC.Int.$fIntegralInt32_$cdiv
                           GHC.Int.$fIntegralInt32_$cmod
                           GHC.Int.$fIntegralInt32_$cquotRem
                           GHC.Int.$fIntegralInt32_$cdivMod
                           GHC.Int.$fIntegralInt32_$ctoInteger]
GHC.Int.$fIntegralInt32
  = GHC.Real.C:Integral
      @ Int32
      GHC.Int.$fRealInt32
      GHC.Int.$fEnumInt32
      GHC.Int.$fIntegralInt32_$cquot
      GHC.Int.$fIntegralInt32_$crem
      GHC.Int.$fIntegralInt32_$cdiv
      GHC.Int.$fIntegralInt32_$cmod
      GHC.Int.$fIntegralInt32_$cquotRem
      GHC.Int.$fIntegralInt32_$cdivMod
      GHC.Int.$fIntegralInt32_$ctoInteger

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt32_$crange :: (Int32, Int32) -> [Int32]
[GblId,
 Arity=1,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eFT [Occ=Once!] :: (Int32, Int32)) ->
                 case ds_d4eFT of { (m_a4cY3 [Occ=Once], n_a4cY4 [Occ=Once]) ->
                 GHC.Int.$fEnumInt32_$cenumFromTo m_a4cY3 n_a4cY4
                 }}]
GHC.Int.$fIxInt32_$crange
  = \ (ds_d4eFT :: (Int32, Int32)) ->
      case ds_d4eFT of { (m_a4cY3, n_a4cY4) ->
      GHC.Int.$fEnumInt32_$cenumFromTo m_a4cY3 n_a4cY4
      }

-- RHS size: {terms: 15, types: 13, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt32_$cunsafeIndex :: (Int32, Int32) -> Int32 -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),A)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eFY [Occ=Once!] :: (Int32, Int32))
                 (i_a4cY6 [Occ=Once!] :: Int32) ->
                 case ds_d4eFY of { (m_a4cY5 [Occ=Once!], _ [Occ=Dead]) ->
                 case i_a4cY6 of { I32# x#_a4d38 [Occ=Once] ->
                 case m_a4cY5 of { I32# x#1_X4djp [Occ=Once] ->
                 GHC.Types.I# (-# x#_a4d38 x#1_X4djp)
                 }
                 }
                 }}]
GHC.Int.$fIxInt32_$cunsafeIndex
  = \ (ds_d4eFY :: (Int32, Int32)) (i_a4cY6 :: Int32) ->
      case ds_d4eFY of { (m_a4cY5, ds1_d4eG4) ->
      case i_a4cY6 of { I32# x#_a4d38 ->
      case m_a4cY5 of { I32# x#1_X4djp ->
      GHC.Types.I# (-# x#_a4d38 x#1_X4djp)
      }
      }
      }

-- RHS size: {terms: 23, types: 13, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt32_$crangeSize :: (Int32, Int32) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRl [Occ=Once!] :: (Int32, Int32)) ->
                 case b_a1KRl of { (_l_a1KRm [Occ=Once!], h_a1KRn [Occ=Once!]) ->
                 case _l_a1KRm of { I32# x_a4d2z ->
                 case h_a1KRn of { I32# y_a4d2A ->
                 case <=# x_a4d2z y_a4d2A of {
                   __DEFAULT -> GHC.Int.$fIxInt1;
                   1# -> GHC.Types.I# (+# (-# y_a4d2A x_a4d2z) 1#)
                 }
                 }
                 }
                 }}]
GHC.Int.$fIxInt32_$crangeSize
  = \ (b_a1KRl :: (Int32, Int32)) ->
      case b_a1KRl of { (_l_a1KRm, h_a1KRn) ->
      case _l_a1KRm of { I32# x_a4d2z ->
      case h_a1KRn of { I32# y_a4d2A ->
      case <=# x_a4d2z y_a4d2A of {
        __DEFAULT -> GHC.Int.$fIxInt1;
        1# -> GHC.Types.I# (+# (-# y_a4d2A x_a4d2z) 1#)
      }
      }
      }
      }

-- RHS size: {terms: 16, types: 12, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt32_$cunsafeRangeSize :: (Int32, Int32) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRo [Occ=Once!] :: (Int32, Int32)) ->
                 case b_a1KRo of { (_l_a1KRp [Occ=Once!], h_a1KRq [Occ=Once!]) ->
                 case h_a1KRq of { I32# x#_a4d38 [Occ=Once] ->
                 case _l_a1KRp of { I32# x#1_X4djr [Occ=Once] ->
                 GHC.Types.I# (+# (-# x#_a4d38 x#1_X4djr) 1#)
                 }
                 }
                 }}]
GHC.Int.$fIxInt32_$cunsafeRangeSize
  = \ (b_a1KRo :: (Int32, Int32)) ->
      case b_a1KRo of { (_l_a1KRp, h_a1KRq) ->
      case h_a1KRq of { I32# x#_a4d38 ->
      case _l_a1KRp of { I32# x#1_X4djr ->
      GHC.Types.I# (+# (-# x#_a4d38 x#1_X4djr) 1#)
      }
      }
      }

-- RHS size: {terms: 32, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt32_$cindex [InlPrag=INLINE (sat-args=2)]
  :: (Int32, Int32) -> Int32 -> Int
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (b_a1KRh [Occ=Once!] :: (Int32, Int32))
                 (i_a1KRi :: Int32) ->
                 case b_a1KRh of { (m_a4cY7, n_a4cY8 [Occ=Once]) ->
                 case leInt32 m_a4cY7 i_a1KRi of {
                   False -> hopelessIndexError;
                   True ->
                     case leInt32 i_a1KRi n_a4cY8 of {
                       False -> hopelessIndexError;
                       True ->
                         case i_a1KRi of { I32# x#_a4d38 [Occ=Once] ->
                         case m_a4cY7 of { I32# x#1_X4djp [Occ=Once] ->
                         GHC.Types.I# (-# x#_a4d38 x#1_X4djp)
                         }
                         }
                     }
                 }
                 }}]
GHC.Int.$fIxInt32_$cindex
  = \ (eta_B2 :: (Int32, Int32)) (eta1_B1 :: Int32) ->
      case eta_B2 of { (m_a4cY7, n_a4cY8) ->
      case m_a4cY7 of { I32# x_a4d2z ->
      case eta1_B1 of { I32# y_a4d2A ->
      case <=# x_a4d2z y_a4d2A of {
        __DEFAULT -> hopelessIndexError;
        1# ->
          case n_a4cY8 of { I32# y1_X4diz ->
          case <=# y_a4d2A y1_X4diz of {
            __DEFAULT -> hopelessIndexError;
            1# -> GHC.Types.I# (-# y_a4d2A x_a4d2z)
          }
          }
      }
      }
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt32 [InlPrag=NOUSERINLINE CONLIKE] :: Ix Int32
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Arr.C:Ix TYPE: Int32
                    GHC.Int.$fOrdInt32
                    GHC.Int.$fIxInt32_$crange
                    GHC.Int.$fIxInt32_$cindex
                    GHC.Int.$fIxInt32_$cunsafeIndex
                    GHC.Int.$fIxInt32_$cinRange
                    GHC.Int.$fIxInt32_$crangeSize
                    GHC.Int.$fIxInt32_$cunsafeRangeSize]
GHC.Int.$fIxInt32
  = GHC.Arr.C:Ix
      @ Int32
      GHC.Int.$fOrdInt32
      GHC.Int.$fIxInt32_$crange
      GHC.Int.$fIxInt32_$cindex
      GHC.Int.$fIxInt32_$cunsafeIndex
      GHC.Int.$fIxInt32_$cinRange
      GHC.Int.$fIxInt32_$crangeSize
      GHC.Int.$fIxInt32_$cunsafeRangeSize

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
eqInt64 [InlPrag=INLINE[1] (sat-args=2)] :: Int64 -> Int64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4ez7 [Occ=Once!] :: Int64)
                 (ds1_d4ez8 [Occ=Once!] :: Int64) ->
                 case ds_d4ez7 of { I64# x_a4d2B [Occ=Once] ->
                 case ds1_d4ez8 of { I64# y_a4d2C [Occ=Once] ->
                 tagToEnum# @ Bool (==# x_a4d2B y_a4d2C)
                 }
                 }}]
eqInt64
  = \ (ds_d4ez7 :: Int64) (ds1_d4ez8 :: Int64) ->
      case ds_d4ez7 of { I64# x_a4d2B ->
      case ds1_d4ez8 of { I64# y_a4d2C ->
      tagToEnum# @ Bool (==# x_a4d2B y_a4d2C)
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fEqInt64 [InlPrag=NOUSERINLINE CONLIKE] :: Eq Int64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ -> GHC.Classes.C:Eq TYPE: Int64 eqInt64 neInt64]
GHC.Int.$fEqInt64 = GHC.Classes.C:Eq @ Int64 eqInt64 neInt64

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
gtInt64 [InlPrag=INLINE[1] (sat-args=2)] :: Int64 -> Int64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eyT [Occ=Once!] :: Int64)
                 (ds1_d4eyU [Occ=Once!] :: Int64) ->
                 case ds_d4eyT of { I64# x_a4d2F [Occ=Once] ->
                 case ds1_d4eyU of { I64# y_a4d2G [Occ=Once] ->
                 tagToEnum# @ Bool (># x_a4d2F y_a4d2G)
                 }
                 }}]
gtInt64
  = \ (ds_d4eyT :: Int64) (ds1_d4eyU :: Int64) ->
      case ds_d4eyT of { I64# x_a4d2F ->
      case ds1_d4eyU of { I64# y_a4d2G ->
      tagToEnum# @ Bool (># x_a4d2F y_a4d2G)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
geInt64 [InlPrag=INLINE[1] (sat-args=2)] :: Int64 -> Int64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eyM [Occ=Once!] :: Int64)
                 (ds1_d4eyN [Occ=Once!] :: Int64) ->
                 case ds_d4eyM of { I64# x_a4d2H [Occ=Once] ->
                 case ds1_d4eyN of { I64# y_a4d2I [Occ=Once] ->
                 tagToEnum# @ Bool (>=# x_a4d2H y_a4d2I)
                 }
                 }}]
geInt64
  = \ (ds_d4eyM :: Int64) (ds1_d4eyN :: Int64) ->
      case ds_d4eyM of { I64# x_a4d2H ->
      case ds1_d4eyN of { I64# y_a4d2I ->
      tagToEnum# @ Bool (>=# x_a4d2H y_a4d2I)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
ltInt64 [InlPrag=INLINE[1] (sat-args=2)] :: Int64 -> Int64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eyF [Occ=Once!] :: Int64)
                 (ds1_d4eyG [Occ=Once!] :: Int64) ->
                 case ds_d4eyF of { I64# x_a4d2J [Occ=Once] ->
                 case ds1_d4eyG of { I64# y_a4d2K [Occ=Once] ->
                 tagToEnum# @ Bool (<# x_a4d2J y_a4d2K)
                 }
                 }}]
ltInt64
  = \ (ds_d4eyF :: Int64) (ds1_d4eyG :: Int64) ->
      case ds_d4eyF of { I64# x_a4d2J ->
      case ds1_d4eyG of { I64# y_a4d2K ->
      tagToEnum# @ Bool (<# x_a4d2J y_a4d2K)
      }
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
leInt64 [InlPrag=INLINE[1] (sat-args=2)] :: Int64 -> Int64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4eyy [Occ=Once!] :: Int64)
                 (ds1_d4eyz [Occ=Once!] :: Int64) ->
                 case ds_d4eyy of { I64# x_a4d2L [Occ=Once] ->
                 case ds1_d4eyz of { I64# y_a4d2M [Occ=Once] ->
                 tagToEnum# @ Bool (<=# x_a4d2L y_a4d2M)
                 }
                 }}]
leInt64
  = \ (ds_d4eyy :: Int64) (ds1_d4eyz :: Int64) ->
      case ds_d4eyy of { I64# x_a4d2L ->
      case ds1_d4eyz of { I64# y_a4d2M ->
      tagToEnum# @ Bool (<=# x_a4d2L y_a4d2M)
      }
      }

-- RHS size: {terms: 23, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt64_$ccompare :: Int64 -> Int64 -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fi2 [Occ=Once!] :: Int64)
                 (y_a1fi3 [Occ=Once!] :: Int64) ->
                 case x_a1fi2 of { I64# x1_a4d2B ->
                 case y_a1fi3 of { I64# y1_a4d2C ->
                 case ==# x1_a4d2B y1_a4d2C of {
                   __DEFAULT ->
                     case <=# x1_a4d2B y1_a4d2C of {
                       __DEFAULT -> GHC.Types.GT;
                       1# -> GHC.Types.LT
                     };
                   1# -> GHC.Types.EQ
                 }
                 }
                 }}]
GHC.Int.$fOrdInt64_$ccompare
  = \ (x_a1fi2 :: Int64) (y_a1fi3 :: Int64) ->
      case x_a1fi2 of { I64# x1_a4d2B ->
      case y_a1fi3 of { I64# y1_a4d2C ->
      case ==# x1_a4d2B y1_a4d2C of {
        __DEFAULT ->
          case <=# x1_a4d2B y1_a4d2C of {
            __DEFAULT -> GHC.Types.GT;
            1# -> GHC.Types.LT
          };
        1# -> GHC.Types.EQ
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt64_$cmax :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d [Occ=Once!] :: Int64)
                 (y_a55e [Occ=Once!] :: Int64) ->
                 case x_a55d of wild_XaW { I64# x1_a4d2L [Occ=Once] ->
                 case y_a55e of wild1_X5 { I64# y1_a4d2M [Occ=Once] ->
                 case <=# x1_a4d2L y1_a4d2M of {
                   __DEFAULT -> wild_XaW;
                   1# -> wild1_X5
                 }
                 }
                 }}]
GHC.Int.$fOrdInt64_$cmax
  = \ (x_a55d :: Int64) (y_a55e :: Int64) ->
      case x_a55d of wild_XaW { I64# x1_a4d2L ->
      case y_a55e of wild1_X5 { I64# y1_a4d2M ->
      case <=# x1_a4d2L y1_a4d2M of {
        __DEFAULT -> wild_XaW;
        1# -> wild1_X5
      }
      }
      }

-- RHS size: {terms: 16, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt64_$cmin :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m [Occ=Once!] :: Int64)
                 (y_a55n [Occ=Once!] :: Int64) ->
                 case x_a55m of wild_XaW { I64# x1_a4d2L [Occ=Once] ->
                 case y_a55n of wild1_X5 { I64# y1_a4d2M [Occ=Once] ->
                 case <=# x1_a4d2L y1_a4d2M of {
                   __DEFAULT -> wild1_X5;
                   1# -> wild_XaW
                 }
                 }
                 }}]
GHC.Int.$fOrdInt64_$cmin
  = \ (x_a55m :: Int64) (y_a55n :: Int64) ->
      case x_a55m of wild_XaW { I64# x1_a4d2L ->
      case y_a55n of wild1_X5 { I64# y1_a4d2M ->
      case <=# x1_a4d2L y1_a4d2M of {
        __DEFAULT -> wild1_X5;
        1# -> wild_XaW
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fOrdInt64 [InlPrag=NOUSERINLINE CONLIKE] :: Ord Int64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Int64
                         GHC.Int.$fEqInt64
                         GHC.Int.$fOrdInt64_$ccompare
                         ltInt64
                         leInt64
                         gtInt64
                         geInt64
                         GHC.Int.$fOrdInt64_$cmax
                         GHC.Int.$fOrdInt64_$cmin]
GHC.Int.$fOrdInt64
  = GHC.Classes.C:Ord
      @ Int64
      GHC.Int.$fEqInt64
      GHC.Int.$fOrdInt64_$ccompare
      ltInt64
      leInt64
      gtInt64
      geInt64
      GHC.Int.$fOrdInt64_$cmax
      GHC.Int.$fOrdInt64_$cmin

-- RHS size: {terms: 25, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt64_$cinRange :: (Int64, Int64) -> Int64 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),1*U(U))><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eBs [Occ=Once!] :: (Int64, Int64))
                 (i_a4cWQ [Occ=Once!] :: Int64) ->
                 case ds_d4eBs of { (m_a4cWO [Occ=Once!], n_a4cWP [Occ=Once!]) ->
                 case m_a4cWO of { I64# x_a4d2L [Occ=Once] ->
                 case i_a4cWQ of { I64# y_a4d2M ->
                 case <=# x_a4d2L y_a4d2M of {
                   __DEFAULT -> GHC.Types.False;
                   1# ->
                     case n_a4cWP of { I64# y1_X4diX [Occ=Once] ->
                     tagToEnum# @ Bool (<=# y_a4d2M y1_X4diX)
                     }
                 }
                 }
                 }
                 }}]
GHC.Int.$fIxInt64_$cinRange
  = \ (ds_d4eBs :: (Int64, Int64)) (i_a4cWQ :: Int64) ->
      case ds_d4eBs of { (m_a4cWO, n_a4cWP) ->
      case m_a4cWO of { I64# x_a4d2L ->
      case i_a4cWQ of { I64# y_a4d2M ->
      case <=# x_a4d2L y_a4d2M of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case n_a4cWP of { I64# y1_X4diX ->
          tagToEnum# @ Bool (<=# y_a4d2M y1_X4diX)
          }
      }
      }
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt5 :: Int64
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fNumInt5 = GHC.Int.I64# 1#

-- RHS size: {terms: 17, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt64_$csignum :: Int64 -> Int64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4cXZ [Occ=Once!] :: Int64) ->
                 case x_a4cXZ of { I64# x1_a4d2F ->
                 case ># x1_a4d2F 0# of {
                   __DEFAULT ->
                     case x1_a4d2F of {
                       __DEFAULT -> GHC.Int.$fNumInt6;
                       0# -> GHC.Int.$fBitsInt10
                     };
                   1# -> GHC.Int.$fNumInt5
                 }
                 }}]
GHC.Int.$fNumInt64_$csignum
  = \ (x_a4cXZ :: Int64) ->
      case x_a4cXZ of { I64# x1_a4d2F ->
      case ># x1_a4d2F 0# of {
        __DEFAULT ->
          case x1_a4d2F of {
            __DEFAULT -> GHC.Int.$fNumInt6;
            0# -> GHC.Int.$fBitsInt10
          };
        1# -> GHC.Int.$fNumInt5
      }
      }

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt64_$cabs :: Int64 -> Int64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4cXY [Occ=Once!] :: Int64) ->
                 case x_a4cXY of wild_XaU { I64# x1_a4d2H ->
                 case >=# x1_a4d2H 0# of {
                   __DEFAULT -> GHC.Int.I64# (negateInt# x1_a4d2H);
                   1# -> wild_XaU
                 }
                 }}]
GHC.Int.$fNumInt64_$cabs
  = \ (x_a4cXY :: Int64) ->
      case x_a4cXY of wild_XaU { I64# x1_a4d2H ->
      case >=# x1_a4d2H 0# of {
        __DEFAULT -> GHC.Int.I64# (negateInt# x1_a4d2H);
        1# -> wild_XaU
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fNumInt64 [InlPrag=NOUSERINLINE CONLIKE] :: Num Int64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Int64
                     GHC.Int.$fNumInt64_$c+
                     GHC.Int.$fNumInt64_$c-
                     GHC.Int.$fNumInt64_$c*
                     GHC.Int.$fNumInt64_$cnegate
                     GHC.Int.$fNumInt64_$cabs
                     GHC.Int.$fNumInt64_$csignum
                     GHC.Int.$fNumInt64_$cfromInteger]
GHC.Int.$fNumInt64
  = GHC.Num.C:Num
      @ Int64
      GHC.Int.$fNumInt64_$c+
      GHC.Int.$fNumInt64_$c-
      GHC.Int.$fNumInt64_$c*
      GHC.Int.$fNumInt64_$cnegate
      GHC.Int.$fNumInt64_$cabs
      GHC.Int.$fNumInt64_$csignum
      GHC.Int.$fNumInt64_$cfromInteger

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt9 :: Maybe Int
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$fBitsInt9 = GHC.Base.Just @ Int GHC.Int.$fBitsInt7

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cbitSizeMaybe :: Int64 -> Maybe Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Int.$fBitsInt9}]
GHC.Int.$fBitsInt64_$cbitSizeMaybe
  = \ _ [Occ=Dead] -> GHC.Int.$fBitsInt9

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cbit [InlPrag=INLINE (sat-args=0)]
  :: Int -> Int64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (i_a1A6g [Occ=Once!] :: Int) ->
                 case i_a1A6g of { I# i#_a4cX4 ->
                 case >=# i#_a4cX4 64# of {
                   __DEFAULT -> GHC.Int.I64# (uncheckedIShiftL# 1# i#_a4cX4);
                   1# -> GHC.Int.I64# 0#
                 }
                 }}]
GHC.Int.$fBitsInt64_$cbit
  = \ (i_a1A6g :: Int) ->
      case i_a1A6g of { I# i#_a4cX4 ->
      case >=# i#_a4cX4 64# of {
        __DEFAULT -> GHC.Int.I64# (uncheckedIShiftL# 1# i#_a4cX4);
        1# -> GHC.Int.$fBitsInt10
      }
      }

-- RHS size: {terms: 28, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$ctestBit [InlPrag=INLINE (sat-args=0)]
  :: Int64 -> Int -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A6h [Occ=Once!] :: Int64)
                 (i_a1A6i [Occ=Once!] :: Int) ->
                 case x_a1A6h of { I64# x#_a4cWU [Occ=Once] ->
                 case i_a1A6i of { I# i#_a4cX4 ->
                 case >=# i#_a4cX4 64# of {
                   __DEFAULT ->
                     neInt64
                       (GHC.Int.I64#
                          (word2Int#
                             (and#
                                (int2Word# x#_a4cWU) (int2Word# (uncheckedIShiftL# 1# i#_a4cX4)))))
                       (GHC.Int.I64# 0#);
                   1# -> neInt64 (GHC.Int.I64# 0#) (GHC.Int.I64# 0#)
                 }
                 }
                 }}]
GHC.Int.$fBitsInt64_$ctestBit
  = \ (x_a1A6h :: Int64) (i_a1A6i :: Int) ->
      case x_a1A6h of { I64# x#_a4cWU ->
      case i_a1A6i of { I# i#_a4cX4 ->
      case >=# i#_a4cX4 64# of {
        __DEFAULT ->
          case word2Int#
                 (and#
                    (int2Word# x#_a4cWU) (int2Word# (uncheckedIShiftL# 1# i#_a4cX4)))
          of {
            __DEFAULT -> GHC.Types.True;
            0# -> GHC.Types.False
          };
        1# -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 32, types: 8, coercions: 0, joins: 0/1}
GHC.Int.$fBitsInt64_$crotateR [InlPrag=INLINE (sat-args=2)]
  :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A54 [Occ=Once!] :: Int64)
                 (i_a1A55 [Occ=Once!] :: Int) ->
                 case x_a1A54 of { I64# x#_a4cXb ->
                 case i_a1A55 of { I# x1_i1AMT [Occ=Once] ->
                 let {
                   x'#_a4cXd :: Word#
                   [LclId]
                   x'#_a4cXd = int2Word# x#_a4cXb } in
                 case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 63##)
                 of wild2_X7r {
                   __DEFAULT ->
                     GHC.Int.I64#
                       (word2Int#
                          (or#
                             (uncheckedShiftL# x'#_a4cXd wild2_X7r)
                             (uncheckedShiftRL# x'#_a4cXd (-# 64# wild2_X7r))));
                   0# -> GHC.Int.I64# x#_a4cXb
                 }
                 }
                 }}]
GHC.Int.$fBitsInt64_$crotateR
  = \ (eta_B2 :: Int64) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X7d { I64# x#_a4cXb ->
      case eta1_B1 of { I# x1_i1AMT ->
      case word2Int# (and# (int2Word# (negateInt# x1_i1AMT)) 63##)
      of wild2_X7r {
        __DEFAULT ->
          let {
            x'#_s4fBr [Dmd=<S,U>] :: Word#
            [LclId]
            x'#_s4fBr = int2Word# x#_a4cXb } in
          GHC.Int.I64#
            (word2Int#
               (or#
                  (uncheckedShiftL# x'#_s4fBr wild2_X7r)
                  (uncheckedShiftRL# x'#_s4fBr (-# 64# wild2_X7r))));
        0# -> wild_X7d
      }
      }
      }

-- RHS size: {terms: 24, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$ccomplementBit [InlPrag=INLINE (sat-args=2)]
  :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4S [Occ=Once!] :: Int64)
                 (i_a1A4T [Occ=Once!] :: Int) ->
                 case x_a1A4S of { I64# x#_a4cWY [Occ=Once*] ->
                 case i_a1A4T of { I# i#_a4cX4 ->
                 case >=# i#_a4cX4 64# of {
                   __DEFAULT ->
                     GHC.Int.I64#
                       (word2Int#
                          (xor#
                             (int2Word# x#_a4cWY) (int2Word# (uncheckedIShiftL# 1# i#_a4cX4))));
                   1# -> GHC.Int.I64# x#_a4cWY
                 }
                 }
                 }}]
GHC.Int.$fBitsInt64_$ccomplementBit
  = \ (eta_B2 :: Int64) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X7g { I64# x#_a4cWY ->
      case eta1_B1 of { I# i#_a4cX4 ->
      case >=# i#_a4cX4 64# of {
        __DEFAULT ->
          GHC.Int.I64#
            (word2Int#
               (xor#
                  (int2Word# x#_a4cWY) (int2Word# (uncheckedIShiftL# 1# i#_a4cX4))));
        1# -> wild_X7g
      }
      }
      }

-- RHS size: {terms: 31, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$cclearBit [InlPrag=INLINE (sat-args=2)]
  :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4Q [Occ=Once!] :: Int64)
                 (i_a1A4R [Occ=Once!] :: Int) ->
                 case x_a1A4Q of { I64# x#_a4cWU [Occ=Once*] ->
                 case i_a1A4R of { I# i#_a4cX4 ->
                 case >=# i#_a4cX4 64# of {
                   __DEFAULT ->
                     GHC.Int.I64#
                       (word2Int#
                          (and#
                             (int2Word# x#_a4cWU)
                             (xor#
                                (int2Word# (uncheckedIShiftL# 1# i#_a4cX4))
                                18446744073709551615##)));
                   1# ->
                     GHC.Int.I64#
                       (word2Int# (and# (int2Word# x#_a4cWU) 18446744073709551615##))
                 }
                 }
                 }}]
GHC.Int.$fBitsInt64_$cclearBit
  = \ (eta_B2 :: Int64) (eta1_B1 :: Int) ->
      case eta_B2 of { I64# x#_a4cWU ->
      case eta1_B1 of { I# i#_a4cX4 ->
      case >=# i#_a4cX4 64# of {
        __DEFAULT ->
          GHC.Int.I64#
            (word2Int#
               (and#
                  (int2Word# x#_a4cWU)
                  (xor#
                     (int2Word# (uncheckedIShiftL# 1# i#_a4cX4))
                     18446744073709551615##)));
        1# ->
          GHC.Int.I64#
            (word2Int# (and# (int2Word# x#_a4cWU) 18446744073709551615##))
      }
      }
      }

-- RHS size: {terms: 24, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$csetBit [InlPrag=INLINE (sat-args=2)]
  :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a1A4O [Occ=Once!] :: Int64)
                 (i_a1A4P [Occ=Once!] :: Int) ->
                 case x_a1A4O of { I64# x#_a4cWW [Occ=Once*] ->
                 case i_a1A4P of { I# i#_a4cX4 ->
                 case >=# i#_a4cX4 64# of {
                   __DEFAULT ->
                     GHC.Int.I64#
                       (word2Int#
                          (or#
                             (int2Word# x#_a4cWW) (int2Word# (uncheckedIShiftL# 1# i#_a4cX4))));
                   1# -> GHC.Int.I64# x#_a4cWW
                 }
                 }
                 }}]
GHC.Int.$fBitsInt64_$csetBit
  = \ (eta_B2 :: Int64) (eta1_B1 :: Int) ->
      case eta_B2 of wild_X7h { I64# x#_a4cWW ->
      case eta1_B1 of { I# i#_a4cX4 ->
      case >=# i#_a4cX4 64# of {
        __DEFAULT ->
          GHC.Int.I64#
            (word2Int#
               (or#
                  (int2Word# x#_a4cWW) (int2Word# (uncheckedIShiftL# 1# i#_a4cX4))));
        1# -> wild_X7h
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64_$crotateL [InlPrag=INLINE (sat-args=2)]
  :: Int64 -> Int -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= GHC.Int.$fBitsInt64_$crotate}]
GHC.Int.$fBitsInt64_$crotateL = GHC.Int.$fBitsInt64_$crotate

-- RHS size: {terms: 24, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fBitsInt64 [InlPrag=NOUSERINLINE CONLIKE] :: Bits Int64
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: Int64
                        GHC.Int.$fEqInt64
                        GHC.Int.$fBitsInt64_$c.&.
                        GHC.Int.$fBitsInt64_$c.|.
                        GHC.Int.$fBitsInt64_$cxor
                        GHC.Int.$fBitsInt64_$ccomplement
                        GHC.Int.$fBitsInt64_$cshift
                        GHC.Int.$fBitsInt64_$crotate
                        GHC.Int.$fBitsInt10
                        GHC.Int.$fBitsInt64_$cbit
                        GHC.Int.$fBitsInt64_$csetBit
                        GHC.Int.$fBitsInt64_$cclearBit
                        GHC.Int.$fBitsInt64_$ccomplementBit
                        GHC.Int.$fBitsInt64_$ctestBit
                        GHC.Int.$fBitsInt64_$cbitSizeMaybe
                        GHC.Int.$fBitsInt64_$cfiniteBitSize
                        GHC.Int.$fBitsInt64_$cisSigned
                        GHC.Int.$fBitsInt64_$cshiftL
                        GHC.Int.$fBitsInt64_$cunsafeShiftL
                        GHC.Int.$fBitsInt64_$cshiftR
                        GHC.Int.$fBitsInt64_$cunsafeShiftR
                        GHC.Int.$fBitsInt64_$crotateL
                        GHC.Int.$fBitsInt64_$crotateR
                        GHC.Int.$fBitsInt64_$cpopCount]
GHC.Int.$fBitsInt64
  = Data.Bits.C:Bits
      @ Int64
      GHC.Int.$fEqInt64
      GHC.Int.$fBitsInt64_$c.&.
      GHC.Int.$fBitsInt64_$c.|.
      GHC.Int.$fBitsInt64_$cxor
      GHC.Int.$fBitsInt64_$ccomplement
      GHC.Int.$fBitsInt64_$cshift
      GHC.Int.$fBitsInt64_$crotate
      GHC.Int.$fBitsInt10
      GHC.Int.$fBitsInt64_$cbit
      GHC.Int.$fBitsInt64_$csetBit
      GHC.Int.$fBitsInt64_$cclearBit
      GHC.Int.$fBitsInt64_$ccomplementBit
      GHC.Int.$fBitsInt64_$ctestBit
      GHC.Int.$fBitsInt64_$cbitSizeMaybe
      GHC.Int.$fBitsInt64_$cfiniteBitSize
      GHC.Int.$fBitsInt64_$cisSigned
      GHC.Int.$fBitsInt64_$cshiftL
      GHC.Int.$fBitsInt64_$cunsafeShiftL
      GHC.Int.$fBitsInt64_$cshiftR
      GHC.Int.$fBitsInt64_$cunsafeShiftR
      GHC.Int.$fBitsInt64_$crotateL
      GHC.Int.$fBitsInt64_$crotateR
      GHC.Int.$fBitsInt64_$cpopCount

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fFiniteBitsInt64 [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits Int64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: Int64
                              GHC.Int.$fBitsInt64
                              GHC.Int.$fBitsInt64_$cfiniteBitSize
                              GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
                              GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros]
GHC.Int.$fFiniteBitsInt64
  = Data.Bits.C:FiniteBits
      @ Int64
      GHC.Int.$fBitsInt64
      GHC.Int.$fBitsInt64_$cfiniteBitSize
      GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
      GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros

Rec {
-- RHS size: {terms: 19, types: 30, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt64_go [Occ=LoopBreaker]
  :: [(Int, String)] -> [(Int64, String)]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
GHC.Int.$fReadInt64_go
  = \ (ds_i1y1c :: [(Int, String)]) ->
      case ds_i1y1c of {
        [] -> GHC.Types.[] @ (Int64, String);
        : y_i1y1h ys_i1y1i ->
          case y_i1y1h of { (x_a4cXk, r_a4cXl) ->
          GHC.Types.:
            @ (Int64, String)
            (case x_a4cXk of { I# x#_a4d2U -> GHC.Int.I64# x#_a4d2U }, r_a4cXl)
            (GHC.Int.$fReadInt64_go ys_i1y1i)
          }
      }
end Rec }

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt64_$creadsPrec :: Int -> ReadS Int64
[GblId,
 Arity=2,
 Str=<L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 90 0}]
GHC.Int.$fReadInt64_$creadsPrec
  = \ (p_a4cXi :: Int) (s_a4cXj :: String) ->
      GHC.Int.$fReadInt64_go
        (Text.ParserCombinators.ReadP.run
           @ Int
           (GHC.Read.$fReadInt_$sreadNumber
              GHC.Read.$fReadInt2
              p_a4cXi
              @ Int
              (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Int))
           s_a4cXj)

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt10
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Int64 -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,U><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_X3ty7 [Occ=Once]
                    :: Text.ParserCombinators.ReadPrec.Prec)
                 (@ b_s3ofG)
                 (eta_B1 [Occ=Once]
                    :: Int64 -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ Int64 (GHC.Int.$fReadInt64_$creadsPrec n_X3ty7) @ b_s3ofG eta_B1
                 of
                 { (# ww1_s3oiG [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
                 }}]
GHC.Int.$fReadInt10
  = \ (n_X3ty7 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_s3ofG)
      (eta_B1 :: Int64 -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ Int64 (GHC.Int.$fReadInt64_$creadsPrec n_X3ty7) @ b_s3ofG eta_B1
      of
      { (# ww1_s3oiG #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
      }

-- RHS size: {terms: 4, types: 5, coercions: 15, joins: 0/0}
GHC.Int.$fReadInt9 :: Text.ParserCombinators.ReadP.P [Int64]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
GHC.Int.$fReadInt9
  = ((((list
          @ Int64
          (GHC.Int.$fReadInt10
           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                         <Int64>_R)
                   :: (Text.ParserCombinators.ReadPrec.Prec
                       -> forall b.
                          (Int64 -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)
                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int64 :: *))))
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Int64]>_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Int64] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [Int64] :: *)))
        GHC.Int.$fIxInt1)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Int64]>_R
             :: (Text.ParserCombinators.ReadP.ReadP [Int64] :: *)
                ~R# (forall b.
                     ([Int64] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)))
      @ [Int64]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [Int64])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt64_$creadList :: ReadS [Int64]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.Int.$fReadInt64_$creadList
  = Text.ParserCombinators.ReadP.run @ [Int64] GHC.Int.$fReadInt9

-- RHS size: {terms: 10, types: 19, coercions: 0, joins: 0/0}
GHC.Int.$fReadInt7
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ([Int64] -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=2,
 Str=<L,A><L,C(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (@ b_s3ofG)
                 (w1_s3ofH [Occ=Once]
                    :: [Int64] -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ [Int64] GHC.Int.$fReadInt64_$creadList @ b_s3ofG w1_s3ofH
                 of
                 { (# ww1_s3oiG [Occ=Once] #) ->
                 Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
                 }}]
GHC.Int.$fReadInt7
  = \ _ [Occ=Dead]
      (@ b_s3ofG)
      (w1_s3ofH :: [Int64] -> Text.ParserCombinators.ReadP.P b_s3ofG) ->
      case Text.ParserCombinators.ReadP.$wreadS_to_P
             @ [Int64] GHC.Int.$fReadInt64_$creadList @ b_s3ofG w1_s3ofH
      of
      { (# ww1_s3oiG #) ->
      Text.ParserCombinators.ReadP.Look @ b_s3ofG ww1_s3oiG
      }

-- RHS size: {terms: 5, types: 1, coercions: 20, joins: 0/0}
GHC.Int.$fReadInt64 [InlPrag=NOUSERINLINE CONLIKE] :: Read Int64
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: Int64
                       GHC.Int.$fReadInt64_$creadsPrec
                       GHC.Int.$fReadInt64_$creadList
                       GHC.Int.$fReadInt10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <Int64>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int64 :: *))
                       GHC.Int.$fReadInt7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       <[Int64]>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [Int64] :: *))]
GHC.Int.$fReadInt64
  = GHC.Read.C:Read
      @ Int64
      GHC.Int.$fReadInt64_$creadsPrec
      GHC.Int.$fReadInt64_$creadList
      (GHC.Int.$fReadInt10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     <Int64>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Int64 :: *)))
      (GHC.Int.$fReadInt7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       <[Int64]>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [Int64] :: *)))

-- RHS size: {terms: 32, types: 15, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt64_$cquot [InlPrag=NOUSERINLINE[0]]
  :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iJ2 [Occ=Once!] :: Int64)
                 (w1_s4iJ3 [Occ=Once!] :: Int64) ->
                 case w_s4iJ2 of { I64# ww1_s4iJ6 [Occ=Once*] ->
                 case w1_s4iJ3 of { I64# ww3_s4iJa [Occ=Once!] ->
                 case ww3_s4iJa of wild_XgB {
                   __DEFAULT ->
                     case quotInt# ww1_s4iJ6 wild_XgB of ww4_s4iJe { __DEFAULT ->
                     GHC.Int.I64# ww4_s4iJe
                     };
                   -1# ->
                     case ww1_s4iJ6 of wild1_XgJ {
                       __DEFAULT -> GHC.Int.I64# (quotInt# wild1_XgJ -1#);
                       -9223372036854775808# -> case overflowError of { }
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt64_$cquot
  = \ (w_s4iJ2 :: Int64) (w1_s4iJ3 :: Int64) ->
      case w_s4iJ2 of { I64# ww1_s4iJ6 ->
      case w1_s4iJ3 of { I64# ww3_s4iJa ->
      case ww3_s4iJa of wild_XgB {
        __DEFAULT ->
          case quotInt# ww1_s4iJ6 wild_XgB of ww4_s4iJe { __DEFAULT ->
          GHC.Int.I64# ww4_s4iJe
          };
        -1# ->
          case ww1_s4iJ6 of wild1_XgJ {
            __DEFAULT -> GHC.Int.I64# (quotInt# wild1_XgJ -1#);
            -9223372036854775808# -> case overflowError of wild2_00 { }
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 22, types: 9, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt64_$crem :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Str=<S,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eDt [Occ=Once!] :: Int64)
                 (y_a4cXr [Occ=Once!] :: Int64) ->
                 case ds_d4eDt of { I64# x#_a4cXq [Occ=Once] ->
                 case y_a4cXr of { I64# y#_a4cXs [Occ=Once!] ->
                 case y#_a4cXs of wild2_XgF {
                   __DEFAULT ->
                     case remInt# x#_a4cXq wild2_XgF of wild3_X5k { __DEFAULT ->
                     GHC.Int.I64# wild3_X5k
                     };
                   -1# -> GHC.Int.$fBitsInt10;
                   0# -> divZeroError @ Int64
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt64_$crem
  = \ (ds_d4eDt :: Int64) (y_a4cXr :: Int64) ->
      case ds_d4eDt of { I64# x#_a4cXq ->
      case y_a4cXr of { I64# y#_a4cXs ->
      case y#_a4cXs of wild2_XgF {
        __DEFAULT ->
          case remInt# x#_a4cXq wild2_XgF of wild3_X5k { __DEFAULT ->
          GHC.Int.I64# wild3_X5k
          };
        -1# -> GHC.Int.$fBitsInt10;
        0# -> divZeroError @ Int64
      }
      }
      }

-- RHS size: {terms: 21, types: 10, coercions: 0, joins: 0/0}
GHC.Int.$w$cdiv2 [InlPrag=NOUSERINLINE[0]] :: Int# -> Int# -> Int#
[GblId,
 Arity=2,
 Str=<S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 70] 110 0}]
GHC.Int.$w$cdiv2
  = \ (ww_s4iJk :: Int#) (ww1_s4iJo :: Int#) ->
      case ww1_s4iJo of wild_XgI {
        __DEFAULT -> divInt# ww_s4iJk wild_XgI;
        -1# ->
          case ww_s4iJk of wild1_XgQ {
            __DEFAULT -> divInt# wild1_XgQ -1#;
            -9223372036854775808# -> case overflowError of wild2_00 { }
          };
        0# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt64_$cdiv [InlPrag=NOUSERINLINE[0]]
  :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iJg [Occ=Once!] :: Int64)
                 (w1_s4iJh [Occ=Once!] :: Int64) ->
                 case w_s4iJg of { I64# ww1_s4iJk [Occ=Once] ->
                 case w1_s4iJh of { I64# ww3_s4iJo [Occ=Once] ->
                 case GHC.Int.$w$cdiv2 ww1_s4iJk ww3_s4iJo of ww4_s4iJs
                 { __DEFAULT ->
                 GHC.Int.I64# ww4_s4iJs
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt64_$cdiv
  = \ (w_s4iJg :: Int64) (w1_s4iJh :: Int64) ->
      case w_s4iJg of { I64# ww1_s4iJk ->
      case w1_s4iJh of { I64# ww3_s4iJo ->
      case GHC.Int.$w$cdiv2 ww1_s4iJk ww3_s4iJo of ww4_s4iJs
      { __DEFAULT ->
      GHC.Int.I64# ww4_s4iJs
      }
      }
      }

-- RHS size: {terms: 23, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt64_$cmod [InlPrag=NOUSERINLINE[0]]
  :: Int64 -> Int64 -> Int64
[GblId,
 Arity=2,
 Str=<S,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iJu [Occ=Once!] :: Int64)
                 (w1_s4iJv [Occ=Once!] :: Int64) ->
                 case w_s4iJu of { I64# ww1_s4iJy [Occ=Once] ->
                 case w1_s4iJv of { I64# ww3_s4iJC [Occ=Once!] ->
                 case ww3_s4iJC of wild_XgM {
                   __DEFAULT ->
                     case modInt# ww1_s4iJy wild_XgM of ww4_s4iJG { __DEFAULT ->
                     GHC.Int.I64# ww4_s4iJG
                     };
                   -1# -> GHC.Int.I64# 0#;
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt64_$cmod
  = \ (w_s4iJu :: Int64) (w1_s4iJv :: Int64) ->
      case w_s4iJu of { I64# ww1_s4iJy ->
      case w1_s4iJv of { I64# ww3_s4iJC ->
      case ww3_s4iJC of wild_XgM {
        __DEFAULT ->
          case modInt# ww1_s4iJy wild_XgM of ww4_s4iJG { __DEFAULT ->
          GHC.Int.I64# ww4_s4iJG
          };
        -1# -> GHC.Int.$fBitsInt10;
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
lvl9_r4kPA :: (Int64, Int64)
[GblId, Str=m, Unf=OtherCon []]
lvl9_r4kPA = (overflowError @ Int64, GHC.Int.$fBitsInt10)

-- RHS size: {terms: 40, types: 29, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt64_$cquotRem [InlPrag=NOUSERINLINE[0]]
  :: Int64 -> Int64 -> (Int64, Int64)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iJI [Occ=Once!] :: Int64)
                 (w1_s4iJJ [Occ=Once!] :: Int64) ->
                 case w_s4iJI of { I64# ww1_s4iJM [Occ=Once*] ->
                 case w1_s4iJJ of { I64# ww3_s4iJQ [Occ=Once!] ->
                 case ww3_s4iJQ of wild_XgR {
                   __DEFAULT ->
                     case quotRemInt# ww1_s4iJM wild_XgR of
                     { (# ipv_s4f77 [Occ=Once], ipv1_s4f78 [Occ=Once] #) ->
                     (GHC.Int.I64# ipv_s4f77, GHC.Int.I64# ipv1_s4f78)
                     };
                   -1# ->
                     case ww1_s4iJM of wild1_XgZ {
                       __DEFAULT ->
                         case quotRemInt# wild1_XgZ -1# of
                         { (# ipv_s4f77 [Occ=Once], ipv1_s4f78 [Occ=Once] #) ->
                         (GHC.Int.I64# ipv_s4f77, GHC.Int.I64# ipv1_s4f78)
                         };
                       -9223372036854775808# ->
                         (overflowError @ Int64, GHC.Int.$fBitsInt10)
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt64_$cquotRem
  = \ (w_s4iJI :: Int64) (w1_s4iJJ :: Int64) ->
      case w_s4iJI of { I64# ww1_s4iJM ->
      case w1_s4iJJ of { I64# ww3_s4iJQ ->
      case ww3_s4iJQ of wild_XgR {
        __DEFAULT ->
          case quotRemInt# ww1_s4iJM wild_XgR of
          { (# ipv_s4f77, ipv1_s4f78 #) ->
          (GHC.Int.I64# ipv_s4f77, GHC.Int.I64# ipv1_s4f78)
          };
        -1# ->
          case ww1_s4iJM of wild1_XgZ {
            __DEFAULT ->
              case quotRemInt# wild1_XgZ -1# of { (# ipv_s4f77, ipv1_s4f78 #) ->
              (GHC.Int.I64# ipv_s4f77, GHC.Int.I64# ipv1_s4f78)
              };
            -9223372036854775808# -> lvl9_r4kPA
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 152, types: 101, coercions: 0, joins: 1/1}
GHC.Int.$w$cdivMod2 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Int# -> (# Int64, Int64 #)
[GblId,
 Arity=2,
 Str=<S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 349 30}]
GHC.Int.$w$cdivMod2
  = \ (ww_s4iK0 :: Int#) (ww1_s4iK4 :: Int#) ->
      case ww1_s4iK4 of wild_XgW {
        __DEFAULT ->
          join {
            $j_s4fT3 [Dmd=<L,1*U(U,U)>] :: (# Int64, Int64 #)
            [LclId[JoinId(0)]]
            $j_s4fT3
              = case ># ww_s4iK0 0# of {
                  __DEFAULT ->
                    case <# ww_s4iK0 0# of {
                      __DEFAULT ->
                        case quotRemInt# ww_s4iK0 wild_XgW of
                        { (# ipv_s4f7g, ipv1_s4f7h #) ->
                        (# GHC.Int.I64# ipv_s4f7g, GHC.Int.I64# ipv1_s4f7h #)
                        };
                      1# ->
                        case ># wild_XgW 0# of {
                          __DEFAULT ->
                            case quotRemInt# ww_s4iK0 wild_XgW of
                            { (# ipv_s4f7g, ipv1_s4f7h #) ->
                            (# GHC.Int.I64# ipv_s4f7g, GHC.Int.I64# ipv1_s4f7h #)
                            };
                          1# ->
                            case quotRemInt# (+# ww_s4iK0 1#) wild_XgW of
                            { (# ipv_i4eEn, ipv1_i4eEo #) ->
                            (# GHC.Int.I64# (-# ipv_i4eEn 1#),
                               GHC.Int.I64# (-# (+# ipv1_i4eEo wild_XgW) 1#) #)
                            }
                        }
                    };
                  1# ->
                    case <# wild_XgW 0# of {
                      __DEFAULT ->
                        case <# ww_s4iK0 0# of {
                          __DEFAULT ->
                            case quotRemInt# ww_s4iK0 wild_XgW of
                            { (# ipv_s4f7g, ipv1_s4f7h #) ->
                            (# GHC.Int.I64# ipv_s4f7g, GHC.Int.I64# ipv1_s4f7h #)
                            };
                          1# ->
                            case ># wild_XgW 0# of {
                              __DEFAULT ->
                                case quotRemInt# ww_s4iK0 wild_XgW of
                                { (# ipv_s4f7g, ipv1_s4f7h #) ->
                                (# GHC.Int.I64# ipv_s4f7g, GHC.Int.I64# ipv1_s4f7h #)
                                };
                              1# ->
                                case quotRemInt# (+# ww_s4iK0 1#) wild_XgW of
                                { (# ipv_i4eEv, ipv1_i4eEw #) ->
                                (# GHC.Int.I64# (-# ipv_i4eEv 1#),
                                   GHC.Int.I64# (-# (+# ipv1_i4eEw wild_XgW) 1#) #)
                                }
                            }
                        };
                      1# ->
                        case quotRemInt# (-# ww_s4iK0 1#) wild_XgW of
                        { (# ipv_i4eEA, ipv1_i4eEB #) ->
                        (# GHC.Int.I64# (-# ipv_i4eEA 1#),
                           GHC.Int.I64# (+# (+# ipv1_i4eEB wild_XgW) 1#) #)
                        }
                    }
                } } in
          case wild_XgW of {
            __DEFAULT -> jump $j_s4fT3;
            -1# ->
              case ww_s4iK0 of {
                __DEFAULT -> jump $j_s4fT3;
                -9223372036854775808# ->
                  (# overflowError @ Int64, GHC.Int.$fBitsInt10 #)
              }
          };
        0# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 16, types: 15, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt64_$cdivMod [InlPrag=NOUSERINLINE[0]]
  :: Int64 -> Int64 -> (Int64, Int64)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iJW [Occ=Once!] :: Int64)
                 (w1_s4iJX [Occ=Once!] :: Int64) ->
                 case w_s4iJW of { I64# ww1_s4iK0 [Occ=Once] ->
                 case w1_s4iJX of { I64# ww3_s4iK4 [Occ=Once] ->
                 case GHC.Int.$w$cdivMod2 ww1_s4iK0 ww3_s4iK4 of
                 { (# ww5_s4iKZ [Occ=Once], ww6_s4iL0 [Occ=Once] #) ->
                 (ww5_s4iKZ, ww6_s4iL0)
                 }
                 }
                 }}]
GHC.Int.$fIntegralInt64_$cdivMod
  = \ (w_s4iJW :: Int64) (w1_s4iJX :: Int64) ->
      case w_s4iJW of { I64# ww1_s4iK0 ->
      case w1_s4iJX of { I64# ww3_s4iK4 ->
      case GHC.Int.$w$cdivMod2 ww1_s4iK0 ww3_s4iK4 of
      { (# ww5_s4iKZ, ww6_s4iL0 #) ->
      (ww5_s4iKZ, ww6_s4iL0)
      }
      }
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt64_$crange :: (Int64, Int64) -> [Int64]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eBg [Occ=Once!] :: (Int64, Int64)) ->
                 case ds_d4eBg of { (m_a4cWK [Occ=Once], n_a4cWL [Occ=Once]) ->
                 GHC.Int.$fEnumInt64_$cenumFromTo m_a4cWK n_a4cWL
                 }}]
GHC.Int.$fIxInt64_$crange
  = \ (ds_d4eBg :: (Int64, Int64)) ->
      case ds_d4eBg of { (m_a4cWK, n_a4cWL) ->
      GHC.Int.$fEnumInt64_$cenumFromTo m_a4cWK n_a4cWL
      }

-- RHS size: {terms: 15, types: 11, coercions: 0, joins: 0/0}
GHC.Int.$fRealInt64_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Int64 -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4iKa [Occ=Once!] :: Int64) ->
                 case w_s4iKa of { I64# ww1_s4iKd [Occ=Once] ->
                 case GHC.Real.$w$sreduce
                        (timesInteger (smallInteger ww1_s4iKd) GHC.Int.$fRealInt1)
                        GHC.Int.$fRealInt1
                 of
                 { (# ww3_s4iL2 [Occ=Once], ww4_s4iL3 [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s4iL2 ww4_s4iL3
                 }
                 }}]
GHC.Int.$fRealInt64_$ctoRational
  = \ (w_s4iKa :: Int64) ->
      case w_s4iKa of { I64# ww1_s4iKd ->
      case GHC.Real.$w$sreduce
             (timesInteger (smallInteger ww1_s4iKd) GHC.Int.$fRealInt1)
             GHC.Int.$fRealInt1
      of
      { (# ww3_s4iL2, ww4_s4iL3 #) ->
      GHC.Real.:% @ Integer ww3_s4iL2 ww4_s4iL3
      }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fRealInt64 [InlPrag=NOUSERINLINE CONLIKE] :: Real Int64
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Int64
                       GHC.Int.$fNumInt64
                       GHC.Int.$fOrdInt64
                       GHC.Int.$fRealInt64_$ctoRational]
GHC.Int.$fRealInt64
  = GHC.Real.C:Real
      @ Int64
      GHC.Int.$fNumInt64
      GHC.Int.$fOrdInt64
      GHC.Int.$fRealInt64_$ctoRational

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fIntegralInt64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Int64
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Int64
                           GHC.Int.$fRealInt64
                           GHC.Int.$fEnumInt64
                           GHC.Int.$fIntegralInt64_$cquot
                           GHC.Int.$fIntegralInt64_$crem
                           GHC.Int.$fIntegralInt64_$cdiv
                           GHC.Int.$fIntegralInt64_$cmod
                           GHC.Int.$fIntegralInt64_$cquotRem
                           GHC.Int.$fIntegralInt64_$cdivMod
                           GHC.Int.$fIntegralInt64_$ctoInteger]
GHC.Int.$fIntegralInt64
  = GHC.Real.C:Integral
      @ Int64
      GHC.Int.$fRealInt64
      GHC.Int.$fEnumInt64
      GHC.Int.$fIntegralInt64_$cquot
      GHC.Int.$fIntegralInt64_$crem
      GHC.Int.$fIntegralInt64_$cdiv
      GHC.Int.$fIntegralInt64_$cmod
      GHC.Int.$fIntegralInt64_$cquotRem
      GHC.Int.$fIntegralInt64_$cdivMod
      GHC.Int.$fIntegralInt64_$ctoInteger

-- RHS size: {terms: 15, types: 13, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt64_$cunsafeIndex :: (Int64, Int64) -> Int64 -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)L),1*U(1*U(U),A)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4eBl [Occ=Once!] :: (Int64, Int64))
                 (i_a4cWN [Occ=Once!] :: Int64) ->
                 case ds_d4eBl of { (m_a4cWM [Occ=Once!], _ [Occ=Dead]) ->
                 case i_a4cWN of { I64# x#_a4d2V [Occ=Once] ->
                 case m_a4cWM of { I64# x#1_X4dks [Occ=Once] ->
                 GHC.Types.I# (-# x#_a4d2V x#1_X4dks)
                 }
                 }
                 }}]
GHC.Int.$fIxInt64_$cunsafeIndex
  = \ (ds_d4eBl :: (Int64, Int64)) (i_a4cWN :: Int64) ->
      case ds_d4eBl of { (m_a4cWM, ds1_d4eBr) ->
      case i_a4cWN of { I64# x#_a4d2V ->
      case m_a4cWM of { I64# x#1_X4dks ->
      GHC.Types.I# (-# x#_a4d2V x#1_X4dks)
      }
      }
      }

-- RHS size: {terms: 23, types: 13, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt64_$crangeSize :: (Int64, Int64) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRl [Occ=Once!] :: (Int64, Int64)) ->
                 case b_a1KRl of { (_l_a1KRm [Occ=Once!], h_a1KRn [Occ=Once!]) ->
                 case _l_a1KRm of { I64# x_a4d2L ->
                 case h_a1KRn of { I64# y_a4d2M ->
                 case <=# x_a4d2L y_a4d2M of {
                   __DEFAULT -> GHC.Int.$fIxInt1;
                   1# -> GHC.Types.I# (+# (-# y_a4d2M x_a4d2L) 1#)
                 }
                 }
                 }
                 }}]
GHC.Int.$fIxInt64_$crangeSize
  = \ (b_a1KRl :: (Int64, Int64)) ->
      case b_a1KRl of { (_l_a1KRm, h_a1KRn) ->
      case _l_a1KRm of { I64# x_a4d2L ->
      case h_a1KRn of { I64# y_a4d2M ->
      case <=# x_a4d2L y_a4d2M of {
        __DEFAULT -> GHC.Int.$fIxInt1;
        1# -> GHC.Types.I# (+# (-# y_a4d2M x_a4d2L) 1#)
      }
      }
      }
      }

-- RHS size: {terms: 16, types: 12, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt64_$cunsafeRangeSize :: (Int64, Int64) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_a1KRo [Occ=Once!] :: (Int64, Int64)) ->
                 case b_a1KRo of { (_l_a1KRp [Occ=Once!], h_a1KRq [Occ=Once!]) ->
                 case h_a1KRq of { I64# x#_a4d2V [Occ=Once] ->
                 case _l_a1KRp of { I64# x#1_X4dku [Occ=Once] ->
                 GHC.Types.I# (+# (-# x#_a4d2V x#1_X4dku) 1#)
                 }
                 }
                 }}]
GHC.Int.$fIxInt64_$cunsafeRangeSize
  = \ (b_a1KRo :: (Int64, Int64)) ->
      case b_a1KRo of { (_l_a1KRp, h_a1KRq) ->
      case h_a1KRq of { I64# x#_a4d2V ->
      case _l_a1KRp of { I64# x#1_X4dku ->
      GHC.Types.I# (+# (-# x#_a4d2V x#1_X4dku) 1#)
      }
      }
      }

-- RHS size: {terms: 32, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt64_$cindex [InlPrag=INLINE (sat-args=2)]
  :: (Int64, Int64) -> Int64 -> Int
[GblId,
 Arity=2,
 Str=<S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (b_a1KRh [Occ=Once!] :: (Int64, Int64))
                 (i_a1KRi :: Int64) ->
                 case b_a1KRh of { (m_a4cWO, n_a4cWP [Occ=Once]) ->
                 case leInt64 m_a4cWO i_a1KRi of {
                   False -> hopelessIndexError;
                   True ->
                     case leInt64 i_a1KRi n_a4cWP of {
                       False -> hopelessIndexError;
                       True ->
                         case i_a1KRi of { I64# x#_a4d2V [Occ=Once] ->
                         case m_a4cWO of { I64# x#1_X4dks [Occ=Once] ->
                         GHC.Types.I# (-# x#_a4d2V x#1_X4dks)
                         }
                         }
                     }
                 }
                 }}]
GHC.Int.$fIxInt64_$cindex
  = \ (eta_B2 :: (Int64, Int64)) (eta1_B1 :: Int64) ->
      case eta_B2 of { (m_a4cWO, n_a4cWP) ->
      case m_a4cWO of { I64# x_a4d2L ->
      case eta1_B1 of { I64# y_a4d2M ->
      case <=# x_a4d2L y_a4d2M of {
        __DEFAULT -> hopelessIndexError;
        1# ->
          case n_a4cWP of { I64# y1_X4dk1 ->
          case <=# y_a4d2M y1_X4dk1 of {
            __DEFAULT -> hopelessIndexError;
            1# -> GHC.Types.I# (-# y_a4d2M x_a4d2L)
          }
          }
      }
      }
      }
      }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fIxInt64 [InlPrag=NOUSERINLINE CONLIKE] :: Ix Int64
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Arr.C:Ix TYPE: Int64
                    GHC.Int.$fOrdInt64
                    GHC.Int.$fIxInt64_$crange
                    GHC.Int.$fIxInt64_$cindex
                    GHC.Int.$fIxInt64_$cunsafeIndex
                    GHC.Int.$fIxInt64_$cinRange
                    GHC.Int.$fIxInt64_$crangeSize
                    GHC.Int.$fIxInt64_$cunsafeRangeSize]
GHC.Int.$fIxInt64
  = GHC.Arr.C:Ix
      @ Int64
      GHC.Int.$fOrdInt64
      GHC.Int.$fIxInt64_$crange
      GHC.Int.$fIxInt64_$cindex
      GHC.Int.$fIxInt64_$cunsafeIndex
      GHC.Int.$fIxInt64_$cinRange
      GHC.Int.$fIxInt64_$crangeSize
      GHC.Int.$fIxInt64_$cunsafeRangeSize

-- RHS size: {terms: 18, types: 17, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt64_$cshowsPrec :: Int -> Int64 -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4cY1 [Occ=Once!] :: Int)
                 (x_a4cY2 [Occ=Once!] :: Int64)
                 (eta_B1 [Occ=Once] :: String) ->
                 case x_a4cY2 of { I64# x#_a4d2V [Occ=Once] ->
                 case p_a4cY1 of { I# ww1_i1MOV [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt ww1_i1MOV x#_a4d2V eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }
                 }}]
GHC.Int.$fShowInt64_$cshowsPrec
  = \ (p_a4cY1 :: Int) (x_a4cY2 :: Int64) (eta_B1 :: String) ->
      case x_a4cY2 of { I64# x#_a4d2V ->
      case p_a4cY1 of { I# ww1_i1MOV ->
      case GHC.Show.$wshowSignedInt ww1_i1MOV x#_a4d2V eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }
      }

-- RHS size: {terms: 13, types: 14, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt64_$cshow :: Int64 -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i1Jj2 [Occ=Once!] :: Int64) ->
                 case x_i1Jj2 of { I64# x#_a4d2V [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# x#_a4d2V (GHC.Types.[] @ Char) of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Int.$fShowInt64_$cshow
  = \ (x_i1Jj2 :: Int64) ->
      case x_i1Jj2 of { I64# x#_a4d2V ->
      case GHC.Show.$wshowSignedInt 0# x#_a4d2V (GHC.Types.[] @ Char) of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt3 :: Int64 -> String -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a4cY2 [Occ=Once!] :: Int64)
                 (eta_B1 [Occ=Once, OS=OneShot] :: String) ->
                 case x_a4cY2 of { I64# x#_a4d2V [Occ=Once] ->
                 case GHC.Show.$wshowSignedInt 0# x#_a4d2V eta_B1 of
                 { (# ww5_i1MP4 [Occ=Once], ww6_i1MP5 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
                 }
                 }}]
GHC.Int.$fShowInt3
  = \ (x_a4cY2 :: Int64) (eta_B1 [OS=OneShot] :: String) ->
      case x_a4cY2 of { I64# x#_a4d2V ->
      case GHC.Show.$wshowSignedInt 0# x#_a4d2V eta_B1 of
      { (# ww5_i1MP4, ww6_i1MP5 #) ->
      GHC.Types.: @ Char ww5_i1MP4 ww6_i1MP5
      }
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt64_$cshowList :: [Int64] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i1Mix [Occ=Once] :: [Int64])
                 (s_i1Miy [Occ=Once] :: String) ->
                 showList__ @ Int64 GHC.Int.$fShowInt3 ls_i1Mix s_i1Miy}]
GHC.Int.$fShowInt64_$cshowList
  = \ (ls_i1Mix :: [Int64]) (s_i1Miy :: String) ->
      showList__ @ Int64 GHC.Int.$fShowInt3 ls_i1Mix s_i1Miy

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Int.$fShowInt64 [InlPrag=NOUSERINLINE CONLIKE] :: Show Int64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Int64
                       GHC.Int.$fShowInt64_$cshowsPrec
                       GHC.Int.$fShowInt64_$cshow
                       GHC.Int.$fShowInt64_$cshowList]
GHC.Int.$fShowInt64
  = GHC.Show.C:Show
      @ Int64
      GHC.Int.$fShowInt64_$cshowsPrec
      GHC.Int.$fShowInt64_$cshow
      GHC.Int.$fShowInt64_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
uncheckedIShiftL64# :: Int# -> Int# -> Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= uncheckedIShiftL#}]
uncheckedIShiftL64# = uncheckedIShiftL#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
uncheckedIShiftRA64# :: Int# -> Int# -> Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= uncheckedIShiftRA#}]
uncheckedIShiftRA64# = uncheckedIShiftRA#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Int.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$trModule3 = GHC.Types.TrNameS GHC.Int.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Int.$trModule2 = "GHC.Int"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$trModule1 = GHC.Types.TrNameS GHC.Int.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Int.$trModule
  = GHC.Types.Module GHC.Int.$trModule3 GHC.Int.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r4kPB :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r4kPB
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcInt# (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt7 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$tcInt7 = GHC.Types.TrNameS GHC.Int.$tcInt9

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt8 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Int.$tcInt8
  = GHC.Types.TyCon
      1422706860619545536##
      2126344328513082648##
      GHC.Int.$trModule
      GHC.Int.$tcInt7
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_r4kPC :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_r4kPC
  = GHC.Types.KindRepTyConApp
      GHC.Int.$tcInt8 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I8#1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Int.$tc'I8#1 = GHC.Types.KindRepFun $krep_r4kPB $krep1_r4kPC

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I8#3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Int.$tc'I8#3 = "'I8#"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I8#2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$tc'I8#2 = GHC.Types.TrNameS GHC.Int.$tc'I8#3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I8# :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Int.$tc'I8#
  = GHC.Types.TyCon
      5349338056284818619##
      13298037281129101406##
      GHC.Int.$trModule
      GHC.Int.$tc'I8#2
      0#
      GHC.Int.$tc'I8#1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$tcInt1 = GHC.Types.TrNameS GHC.Int.$tcInt2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt16 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Int.$tcInt16
  = GHC.Types.TyCon
      16329117591681623238##
      13363230803330610095##
      GHC.Int.$trModule
      GHC.Int.$tcInt1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2_r4kPD :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_r4kPD
  = GHC.Types.KindRepTyConApp
      GHC.Int.$tcInt16 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I16#1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Int.$tc'I16#1 = GHC.Types.KindRepFun $krep_r4kPB $krep2_r4kPD

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I16#3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Int.$tc'I16#3 = "'I16#"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I16#2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$tc'I16#2 = GHC.Types.TrNameS GHC.Int.$tc'I16#3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I16# :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Int.$tc'I16#
  = GHC.Types.TyCon
      1077432500071562197##
      13676251251348512601##
      GHC.Int.$trModule
      GHC.Int.$tc'I16#2
      0#
      GHC.Int.$tc'I16#1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$tcInt3 = GHC.Types.TrNameS GHC.Int.$tcInt4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt32 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Int.$tcInt32
  = GHC.Types.TyCon
      5115671124548181797##
      6203735229629729265##
      GHC.Int.$trModule
      GHC.Int.$tcInt3
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3_r4kPE :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_r4kPE
  = GHC.Types.KindRepTyConApp
      GHC.Int.$tcInt32 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I32#1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Int.$tc'I32#1 = GHC.Types.KindRepFun $krep_r4kPB $krep3_r4kPE

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I32#3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Int.$tc'I32#3 = "'I32#"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I32#2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$tc'I32#2 = GHC.Types.TrNameS GHC.Int.$tc'I32#3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I32# :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Int.$tc'I32#
  = GHC.Types.TyCon
      14037617528454219662##
      2752255350980319305##
      GHC.Int.$trModule
      GHC.Int.$tc'I32#2
      0#
      GHC.Int.$tc'I32#1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt5 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$tcInt5 = GHC.Types.TrNameS GHC.Int.$tcInt6

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tcInt64 :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Int.$tcInt64
  = GHC.Types.TyCon
      15049343324344240059##
      14445320765379163718##
      GHC.Int.$trModule
      GHC.Int.$tcInt5
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep4_r4kPF :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_r4kPF
  = GHC.Types.KindRepTyConApp
      GHC.Int.$tcInt64 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I64#1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Int.$tc'I64#1 = GHC.Types.KindRepFun $krep_r4kPB $krep4_r4kPF

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I64#3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Int.$tc'I64#3 = "'I64#"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I64#2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Int.$tc'I64#2 = GHC.Types.TrNameS GHC.Int.$tc'I64#3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Int.$tc'I64# :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Int.$tc'I64#
  = GHC.Types.TyCon
      7755385358338959724##
      8520529638322167079##
      GHC.Int.$trModule
      GHC.Int.$tc'I64#2
      0#
      GHC.Int.$tc'I64#1


------ Local rules for imported ids --------
"properFraction/Double->(Int64,Double)"
    forall ($dRealFrac_a4dNq :: RealFrac Double)
           ($dIntegral_a4dNs :: Integral Int64).
      properFraction @ Double $dRealFrac_a4dNq @ Int64 $dIntegral_a4dNs
      = \ (x_a4d2N :: Double) ->
          case GHC.Float.$fRealFracDouble_$cproperFraction
                 @ Int GHC.Real.$fIntegralInt x_a4d2N
          of
          { (n_a4d2O, y_a4d2P) ->
          (fromIntegral
             @ Int @ Int64 GHC.Real.$fIntegralInt GHC.Int.$fNumInt64 n_a4d2O,
           y_a4d2P)
          }
"truncate/Double->Int64"
    forall ($dRealFrac_a4dO3 :: RealFrac Double)
           ($dIntegral_a4dO5 :: Integral Int64).
      truncate @ Double $dRealFrac_a4dO3 @ Int64 $dIntegral_a4dO5
      = . @ Int
          @ Int64
          @ Double
          (fromIntegral
             @ Int @ Int64 GHC.Real.$fIntegralInt GHC.Int.$fNumInt64)
          (GHC.Float.$fRealFracDouble_$ctruncate
             @ Int GHC.Real.$fIntegralInt)
"floor/Double->Int64"
    forall ($dRealFrac_a4dOH :: RealFrac Double)
           ($dIntegral_a4dOJ :: Integral Int64).
      floor @ Double $dRealFrac_a4dOH @ Int64 $dIntegral_a4dOJ
      = . @ Int
          @ Int64
          @ Double
          (fromIntegral
             @ Int @ Int64 GHC.Real.$fIntegralInt GHC.Int.$fNumInt64)
          (GHC.Float.$fRealFracDouble_$cfloor @ Int GHC.Real.$fIntegralInt)
"ceiling/Double->Int64"
    forall ($dRealFrac_a4dPl :: RealFrac Double)
           ($dIntegral_a4dPn :: Integral Int64).
      ceiling @ Double $dRealFrac_a4dPl @ Int64 $dIntegral_a4dPn
      = . @ Int
          @ Int64
          @ Double
          (fromIntegral
             @ Int @ Int64 GHC.Real.$fIntegralInt GHC.Int.$fNumInt64)
          (GHC.Float.$fRealFracDouble_$cceiling @ Int GHC.Real.$fIntegralInt)
"round/Double->Int64"
    forall ($dRealFrac_a4dPZ :: RealFrac Double)
           ($dIntegral_a4dQ1 :: Integral Int64).
      round @ Double $dRealFrac_a4dPZ @ Int64 $dIntegral_a4dQ1
      = . @ Int
          @ Int64
          @ Double
          (fromIntegral
             @ Int @ Int64 GHC.Real.$fIntegralInt GHC.Int.$fNumInt64)
          (GHC.Float.$fRealFracDouble_$cround @ Int GHC.Real.$fIntegralInt)
"properFraction/Float->(Int64,Float)"
    forall ($dRealFrac_a4dQD :: RealFrac Float)
           ($dIntegral_a4dQF :: Integral Int64).
      properFraction @ Float $dRealFrac_a4dQD @ Int64 $dIntegral_a4dQF
      = \ (x_a4d2Q :: Float) ->
          case GHC.Float.$fRealFracFloat_$cproperFraction
                 @ Int GHC.Real.$fIntegralInt x_a4d2Q
          of
          { (n_a4d2R, y_a4d2S) ->
          (fromIntegral
             @ Int @ Int64 GHC.Real.$fIntegralInt GHC.Int.$fNumInt64 n_a4d2R,
           y_a4d2S)
          }
"truncate/Float->Int64"
    forall ($dRealFrac_a4dRg :: RealFrac Float)
           ($dIntegral_a4dRi :: Integral Int64).
      truncate @ Float $dRealFrac_a4dRg @ Int64 $dIntegral_a4dRi
      = . @ Int
          @ Int64
          @ Float
          (fromIntegral
             @ Int @ Int64 GHC.Real.$fIntegralInt GHC.Int.$fNumInt64)
          (GHC.Float.$fRealFracFloat_$ctruncate @ Int GHC.Real.$fIntegralInt)
"floor/Float->Int64"
    forall ($dRealFrac_a4dRU :: RealFrac Float)
           ($dIntegral_a4dRW :: Integral Int64).
      floor @ Float $dRealFrac_a4dRU @ Int64 $dIntegral_a4dRW
      = . @ Int
          @ Int64
          @ Float
          (fromIntegral
             @ Int @ Int64 GHC.Real.$fIntegralInt GHC.Int.$fNumInt64)
          (GHC.Float.$fRealFracFloat_$cfloor @ Int GHC.Real.$fIntegralInt)
"ceiling/Float->Int64"
    forall ($dRealFrac_a4dSy :: RealFrac Float)
           ($dIntegral_a4dSA :: Integral Int64).
      ceiling @ Float $dRealFrac_a4dSy @ Int64 $dIntegral_a4dSA
      = . @ Int
          @ Int64
          @ Float
          (fromIntegral
             @ Int @ Int64 GHC.Real.$fIntegralInt GHC.Int.$fNumInt64)
          (GHC.Float.$fRealFracFloat_$cceiling @ Int GHC.Real.$fIntegralInt)
"round/Float->Int64"
    forall ($dRealFrac_a4dTc :: RealFrac Float)
           ($dIntegral_a4dTe :: Integral Int64).
      round @ Float $dRealFrac_a4dTc @ Int64 $dIntegral_a4dTe
      = . @ Int
          @ Int64
          @ Float
          (fromIntegral
             @ Int @ Int64 GHC.Real.$fIntegralInt GHC.Int.$fNumInt64)
          (GHC.Float.$fRealFracFloat_$cround @ Int GHC.Real.$fIntegralInt)
"fromIntegral/a->Int64"
    forall (@ a_a4dTU)
           ($dIntegral_a4dTR :: Integral a_a4dTU)
           ($dNum_a4dTS :: Num Int64).
      fromIntegral @ a_a4dTU @ Int64 $dIntegral_a4dTR $dNum_a4dTS
      = \ (x_a4d2T :: a_a4dTU) ->
          case fromIntegral
                 @ a_a4dTU @ Int $dIntegral_a4dTR GHC.Num.$fNumInt x_a4d2T
          of
          { I# x#_a4d2U ->
          GHC.Int.I64# x#_a4d2U
          }
"fromIntegral/Int64->a"
    forall (@ b_a4dU9)
           ($dIntegral_a4dUa :: Integral Int64)
           ($dNum_a4dUb :: Num b_a4dU9).
      fromIntegral @ Int64 @ b_a4dU9 $dIntegral_a4dUa $dNum_a4dUb
      = \ (ds_d4eSU :: Int64) ->
          case ds_d4eSU of { I64# x#_a4d2V ->
          fromIntegral
            @ Int
            @ b_a4dU9
            GHC.Real.$fIntegralInt
            $dNum_a4dUb
            (GHC.Types.I# x#_a4d2V)
          }
"properFraction/Double->(Int32,Double)"
    forall ($dRealFrac_a4dUq :: RealFrac Double)
           ($dIntegral_a4dUs :: Integral Int32).
      properFraction @ Double $dRealFrac_a4dUq @ Int32 $dIntegral_a4dUs
      = \ (x_a4d2W :: Double) ->
          case GHC.Float.$fRealFracDouble_$cproperFraction
                 @ Int GHC.Real.$fIntegralInt x_a4d2W
          of
          { (n_a4d2X, y_a4d2Y) ->
          (fromIntegral
             @ Int @ Int32 GHC.Real.$fIntegralInt GHC.Int.$fNumInt32 n_a4d2X,
           y_a4d2Y)
          }
"truncate/Double->Int32"
    forall ($dRealFrac_a4dV3 :: RealFrac Double)
           ($dIntegral_a4dV5 :: Integral Int32).
      truncate @ Double $dRealFrac_a4dV3 @ Int32 $dIntegral_a4dV5
      = . @ Int
          @ Int32
          @ Double
          (fromIntegral
             @ Int @ Int32 GHC.Real.$fIntegralInt GHC.Int.$fNumInt32)
          (GHC.Float.$fRealFracDouble_$ctruncate
             @ Int GHC.Real.$fIntegralInt)
"floor/Double->Int32"
    forall ($dRealFrac_a4dVH :: RealFrac Double)
           ($dIntegral_a4dVJ :: Integral Int32).
      floor @ Double $dRealFrac_a4dVH @ Int32 $dIntegral_a4dVJ
      = . @ Int
          @ Int32
          @ Double
          (fromIntegral
             @ Int @ Int32 GHC.Real.$fIntegralInt GHC.Int.$fNumInt32)
          (GHC.Float.$fRealFracDouble_$cfloor @ Int GHC.Real.$fIntegralInt)
"ceiling/Double->Int32"
    forall ($dRealFrac_a4dWl :: RealFrac Double)
           ($dIntegral_a4dWn :: Integral Int32).
      ceiling @ Double $dRealFrac_a4dWl @ Int32 $dIntegral_a4dWn
      = . @ Int
          @ Int32
          @ Double
          (fromIntegral
             @ Int @ Int32 GHC.Real.$fIntegralInt GHC.Int.$fNumInt32)
          (GHC.Float.$fRealFracDouble_$cceiling @ Int GHC.Real.$fIntegralInt)
"round/Double->Int32"
    forall ($dRealFrac_a4dWZ :: RealFrac Double)
           ($dIntegral_a4dX1 :: Integral Int32).
      round @ Double $dRealFrac_a4dWZ @ Int32 $dIntegral_a4dX1
      = . @ Int
          @ Int32
          @ Double
          (fromIntegral
             @ Int @ Int32 GHC.Real.$fIntegralInt GHC.Int.$fNumInt32)
          (GHC.Float.$fRealFracDouble_$cround @ Int GHC.Real.$fIntegralInt)
"properFraction/Float->(Int32,Float)"
    forall ($dRealFrac_a4dXD :: RealFrac Float)
           ($dIntegral_a4dXF :: Integral Int32).
      properFraction @ Float $dRealFrac_a4dXD @ Int32 $dIntegral_a4dXF
      = \ (x_a4d2Z :: Float) ->
          case GHC.Float.$fRealFracFloat_$cproperFraction
                 @ Int GHC.Real.$fIntegralInt x_a4d2Z
          of
          { (n_a4d30, y_a4d31) ->
          (fromIntegral
             @ Int @ Int32 GHC.Real.$fIntegralInt GHC.Int.$fNumInt32 n_a4d30,
           y_a4d31)
          }
"truncate/Float->Int32"
    forall ($dRealFrac_a4dYg :: RealFrac Float)
           ($dIntegral_a4dYi :: Integral Int32).
      truncate @ Float $dRealFrac_a4dYg @ Int32 $dIntegral_a4dYi
      = . @ Int
          @ Int32
          @ Float
          (fromIntegral
             @ Int @ Int32 GHC.Real.$fIntegralInt GHC.Int.$fNumInt32)
          (GHC.Float.$fRealFracFloat_$ctruncate @ Int GHC.Real.$fIntegralInt)
"floor/Float->Int32"
    forall ($dRealFrac_a4dYU :: RealFrac Float)
           ($dIntegral_a4dYW :: Integral Int32).
      floor @ Float $dRealFrac_a4dYU @ Int32 $dIntegral_a4dYW
      = . @ Int
          @ Int32
          @ Float
          (fromIntegral
             @ Int @ Int32 GHC.Real.$fIntegralInt GHC.Int.$fNumInt32)
          (GHC.Float.$fRealFracFloat_$cfloor @ Int GHC.Real.$fIntegralInt)
"ceiling/Float->Int32"
    forall ($dRealFrac_a4dZy :: RealFrac Float)
           ($dIntegral_a4dZA :: Integral Int32).
      ceiling @ Float $dRealFrac_a4dZy @ Int32 $dIntegral_a4dZA
      = . @ Int
          @ Int32
          @ Float
          (fromIntegral
             @ Int @ Int32 GHC.Real.$fIntegralInt GHC.Int.$fNumInt32)
          (GHC.Float.$fRealFracFloat_$cceiling @ Int GHC.Real.$fIntegralInt)
"round/Float->Int32"
    forall ($dRealFrac_a4e0c :: RealFrac Float)
           ($dIntegral_a4e0e :: Integral Int32).
      round @ Float $dRealFrac_a4e0c @ Int32 $dIntegral_a4e0e
      = . @ Int
          @ Int32
          @ Float
          (fromIntegral
             @ Int @ Int32 GHC.Real.$fIntegralInt GHC.Int.$fNumInt32)
          (GHC.Float.$fRealFracFloat_$cround @ Int GHC.Real.$fIntegralInt)
"fromIntegral/Word8->Int32"
    forall ($dIntegral_a4e0R :: Integral Word8)
           ($dNum_a4e0S :: Num Int32).
      fromIntegral @ Word8 @ Int32 $dIntegral_a4e0R $dNum_a4e0S
      = \ (ds_d4eTa :: Word8) ->
          case ds_d4eTa of { W8# x#_a4d32 ->
          GHC.Int.I32# (word2Int# x#_a4d32)
          }
"fromIntegral/Word16->Int32"
    forall ($dIntegral_a4e12 :: Integral Word16)
           ($dNum_a4e13 :: Num Int32).
      fromIntegral @ Word16 @ Int32 $dIntegral_a4e12 $dNum_a4e13
      = \ (ds_d4eTe :: Word16) ->
          case ds_d4eTe of { W16# x#_a4d33 ->
          GHC.Int.I32# (word2Int# x#_a4d33)
          }
"fromIntegral/Int8->Int32"
    forall ($dIntegral_a4e1d :: Integral Int8)
           ($dNum_a4e1e :: Num Int32).
      fromIntegral @ Int8 @ Int32 $dIntegral_a4e1d $dNum_a4e1e
      = \ (ds_d4eTi :: Int8) ->
          case ds_d4eTi of { I8# x#_a4d34 -> GHC.Int.I32# x#_a4d34 }
"fromIntegral/Int16->Int32"
    forall ($dIntegral_a4e1o :: Integral Int16)
           ($dNum_a4e1p :: Num Int32).
      fromIntegral @ Int16 @ Int32 $dIntegral_a4e1o $dNum_a4e1p
      = \ (ds_d4eTm :: Int16) ->
          case ds_d4eTm of { I16# x#_a4d35 -> GHC.Int.I32# x#_a4d35 }
"fromIntegral/Int32->Int32"
    forall ($dIntegral_a4e1z :: Integral Int32)
           ($dNum_a4e1A :: Num Int32).
      fromIntegral @ Int32 @ Int32 $dIntegral_a4e1z $dNum_a4e1A
      = id @ Int32
"fromIntegral/a->Int32"
    forall (@ a_a4e1V)
           ($dIntegral_a4e1S :: Integral a_a4e1V)
           ($dNum_a4e1T :: Num Int32).
      fromIntegral @ a_a4e1V @ Int32 $dIntegral_a4e1S $dNum_a4e1T
      = \ (x_a4d36 :: a_a4e1V) ->
          case fromIntegral
                 @ a_a4e1V @ Int $dIntegral_a4e1S GHC.Num.$fNumInt x_a4d36
          of
          { I# x#_a4d37 ->
          GHC.Int.I32# (narrow32Int# x#_a4d37)
          }
"fromIntegral/Int32->a"
    forall (@ b_a4e2a)
           ($dIntegral_a4e2b :: Integral Int32)
           ($dNum_a4e2c :: Num b_a4e2a).
      fromIntegral @ Int32 @ b_a4e2a $dIntegral_a4e2b $dNum_a4e2c
      = \ (ds_d4eTv :: Int32) ->
          case ds_d4eTv of { I32# x#_a4d38 ->
          fromIntegral
            @ Int
            @ b_a4e2a
            GHC.Real.$fIntegralInt
            $dNum_a4e2c
            (GHC.Types.I# x#_a4d38)
          }
"properFraction/Double->(Int16,Double)"
    forall ($dRealFrac_a4e2r :: RealFrac Double)
           ($dIntegral_a4e2t :: Integral Int16).
      properFraction @ Double $dRealFrac_a4e2r @ Int16 $dIntegral_a4e2t
      = \ (x_a4d39 :: Double) ->
          case GHC.Float.$fRealFracDouble_$cproperFraction
                 @ Int GHC.Real.$fIntegralInt x_a4d39
          of
          { (n_a4d3a, y_a4d3b) ->
          (fromIntegral
             @ Int @ Int16 GHC.Real.$fIntegralInt GHC.Int.$fNumInt16 n_a4d3a,
           y_a4d3b)
          }
"truncate/Double->Int16"
    forall ($dRealFrac_a4e34 :: RealFrac Double)
           ($dIntegral_a4e36 :: Integral Int16).
      truncate @ Double $dRealFrac_a4e34 @ Int16 $dIntegral_a4e36
      = . @ Int
          @ Int16
          @ Double
          (fromIntegral
             @ Int @ Int16 GHC.Real.$fIntegralInt GHC.Int.$fNumInt16)
          (GHC.Float.$fRealFracDouble_$ctruncate
             @ Int GHC.Real.$fIntegralInt)
"floor/Double->Int16"
    forall ($dRealFrac_a4e3I :: RealFrac Double)
           ($dIntegral_a4e3K :: Integral Int16).
      floor @ Double $dRealFrac_a4e3I @ Int16 $dIntegral_a4e3K
      = . @ Int
          @ Int16
          @ Double
          (fromIntegral
             @ Int @ Int16 GHC.Real.$fIntegralInt GHC.Int.$fNumInt16)
          (GHC.Float.$fRealFracDouble_$cfloor @ Int GHC.Real.$fIntegralInt)
"ceiling/Double->Int16"
    forall ($dRealFrac_a4e4m :: RealFrac Double)
           ($dIntegral_a4e4o :: Integral Int16).
      ceiling @ Double $dRealFrac_a4e4m @ Int16 $dIntegral_a4e4o
      = . @ Int
          @ Int16
          @ Double
          (fromIntegral
             @ Int @ Int16 GHC.Real.$fIntegralInt GHC.Int.$fNumInt16)
          (GHC.Float.$fRealFracDouble_$cceiling @ Int GHC.Real.$fIntegralInt)
"round/Double->Int16"
    forall ($dRealFrac_a4e50 :: RealFrac Double)
           ($dIntegral_a4e52 :: Integral Int16).
      round @ Double $dRealFrac_a4e50 @ Int16 $dIntegral_a4e52
      = . @ Int
          @ Int16
          @ Double
          (fromIntegral
             @ Int @ Int16 GHC.Real.$fIntegralInt GHC.Int.$fNumInt16)
          (GHC.Float.$fRealFracDouble_$cround @ Int GHC.Real.$fIntegralInt)
"properFraction/Float->(Int16,Float)"
    forall ($dRealFrac_a4e5E :: RealFrac Float)
           ($dIntegral_a4e5G :: Integral Int16).
      properFraction @ Float $dRealFrac_a4e5E @ Int16 $dIntegral_a4e5G
      = \ (x_a4d3c :: Float) ->
          case GHC.Float.$fRealFracFloat_$cproperFraction
                 @ Int GHC.Real.$fIntegralInt x_a4d3c
          of
          { (n_a4d3d, y_a4d3e) ->
          (fromIntegral
             @ Int @ Int16 GHC.Real.$fIntegralInt GHC.Int.$fNumInt16 n_a4d3d,
           y_a4d3e)
          }
"truncate/Float->Int16"
    forall ($dRealFrac_a4e6h :: RealFrac Float)
           ($dIntegral_a4e6j :: Integral Int16).
      truncate @ Float $dRealFrac_a4e6h @ Int16 $dIntegral_a4e6j
      = . @ Int
          @ Int16
          @ Float
          (fromIntegral
             @ Int @ Int16 GHC.Real.$fIntegralInt GHC.Int.$fNumInt16)
          (GHC.Float.$fRealFracFloat_$ctruncate @ Int GHC.Real.$fIntegralInt)
"floor/Float->Int16"
    forall ($dRealFrac_a4e6V :: RealFrac Float)
           ($dIntegral_a4e6X :: Integral Int16).
      floor @ Float $dRealFrac_a4e6V @ Int16 $dIntegral_a4e6X
      = . @ Int
          @ Int16
          @ Float
          (fromIntegral
             @ Int @ Int16 GHC.Real.$fIntegralInt GHC.Int.$fNumInt16)
          (GHC.Float.$fRealFracFloat_$cfloor @ Int GHC.Real.$fIntegralInt)
"ceiling/Float->Int16"
    forall ($dRealFrac_a4e7z :: RealFrac Float)
           ($dIntegral_a4e7B :: Integral Int16).
      ceiling @ Float $dRealFrac_a4e7z @ Int16 $dIntegral_a4e7B
      = . @ Int
          @ Int16
          @ Float
          (fromIntegral
             @ Int @ Int16 GHC.Real.$fIntegralInt GHC.Int.$fNumInt16)
          (GHC.Float.$fRealFracFloat_$cceiling @ Int GHC.Real.$fIntegralInt)
"round/Float->Int16"
    forall ($dRealFrac_a4e8d :: RealFrac Float)
           ($dIntegral_a4e8f :: Integral Int16).
      round @ Float $dRealFrac_a4e8d @ Int16 $dIntegral_a4e8f
      = . @ Int
          @ Int16
          @ Float
          (fromIntegral
             @ Int @ Int16 GHC.Real.$fIntegralInt GHC.Int.$fNumInt16)
          (GHC.Float.$fRealFracFloat_$cround @ Int GHC.Real.$fIntegralInt)
"fromIntegral/Word8->Int16"
    forall ($dIntegral_a4e8S :: Integral Word8)
           ($dNum_a4e8T :: Num Int16).
      fromIntegral @ Word8 @ Int16 $dIntegral_a4e8S $dNum_a4e8T
      = \ (ds_d4eTL :: Word8) ->
          case ds_d4eTL of { W8# x#_a4d3f ->
          GHC.Int.I16# (word2Int# x#_a4d3f)
          }
"fromIntegral/Int8->Int16"
    forall ($dIntegral_a4e93 :: Integral Int8)
           ($dNum_a4e94 :: Num Int16).
      fromIntegral @ Int8 @ Int16 $dIntegral_a4e93 $dNum_a4e94
      = \ (ds_d4eTP :: Int8) ->
          case ds_d4eTP of { I8# x#_a4d3g -> GHC.Int.I16# x#_a4d3g }
"fromIntegral/Int16->Int16"
    forall ($dIntegral_a4e9e :: Integral Int16)
           ($dNum_a4e9f :: Num Int16).
      fromIntegral @ Int16 @ Int16 $dIntegral_a4e9e $dNum_a4e9f
      = id @ Int16
"fromIntegral/a->Int16"
    forall (@ a_a4e9A)
           ($dIntegral_a4e9x :: Integral a_a4e9A)
           ($dNum_a4e9y :: Num Int16).
      fromIntegral @ a_a4e9A @ Int16 $dIntegral_a4e9x $dNum_a4e9y
      = \ (x_a4d3h :: a_a4e9A) ->
          case fromIntegral
                 @ a_a4e9A @ Int $dIntegral_a4e9x GHC.Num.$fNumInt x_a4d3h
          of
          { I# x#_a4d3i ->
          GHC.Int.I16# (narrow16Int# x#_a4d3i)
          }
"fromIntegral/Int16->a"
    forall (@ b_a4e9P)
           ($dIntegral_a4e9Q :: Integral Int16)
           ($dNum_a4e9R :: Num b_a4e9P).
      fromIntegral @ Int16 @ b_a4e9P $dIntegral_a4e9Q $dNum_a4e9R
      = \ (ds_d4eTY :: Int16) ->
          case ds_d4eTY of { I16# x#_a4d3j ->
          fromIntegral
            @ Int
            @ b_a4e9P
            GHC.Real.$fIntegralInt
            $dNum_a4e9R
            (GHC.Types.I# x#_a4d3j)
          }
"properFraction/Double->(Int8,Double)"
    forall ($dRealFrac_a4ea6 :: RealFrac Double)
           ($dIntegral_a4ea8 :: Integral Int8).
      properFraction @ Double $dRealFrac_a4ea6 @ Int8 $dIntegral_a4ea8
      = \ (x_a4d3k :: Double) ->
          case GHC.Float.$fRealFracDouble_$cproperFraction
                 @ Int GHC.Real.$fIntegralInt x_a4d3k
          of
          { (n_a4d3l, y_a4d3m) ->
          (fromIntegral
             @ Int @ Int8 GHC.Real.$fIntegralInt GHC.Int.$fNumInt8 n_a4d3l,
           y_a4d3m)
          }
"truncate/Double->Int8"
    forall ($dRealFrac_a4eaJ :: RealFrac Double)
           ($dIntegral_a4eaL :: Integral Int8).
      truncate @ Double $dRealFrac_a4eaJ @ Int8 $dIntegral_a4eaL
      = . @ Int
          @ Int8
          @ Double
          (fromIntegral
             @ Int @ Int8 GHC.Real.$fIntegralInt GHC.Int.$fNumInt8)
          (GHC.Float.$fRealFracDouble_$ctruncate
             @ Int GHC.Real.$fIntegralInt)
"floor/Double->Int8"
    forall ($dRealFrac_a4ebn :: RealFrac Double)
           ($dIntegral_a4ebp :: Integral Int8).
      floor @ Double $dRealFrac_a4ebn @ Int8 $dIntegral_a4ebp
      = . @ Int
          @ Int8
          @ Double
          (fromIntegral
             @ Int @ Int8 GHC.Real.$fIntegralInt GHC.Int.$fNumInt8)
          (GHC.Float.$fRealFracDouble_$cfloor @ Int GHC.Real.$fIntegralInt)
"ceiling/Double->Int8"
    forall ($dRealFrac_a4ec1 :: RealFrac Double)
           ($dIntegral_a4ec3 :: Integral Int8).
      ceiling @ Double $dRealFrac_a4ec1 @ Int8 $dIntegral_a4ec3
      = . @ Int
          @ Int8
          @ Double
          (fromIntegral
             @ Int @ Int8 GHC.Real.$fIntegralInt GHC.Int.$fNumInt8)
          (GHC.Float.$fRealFracDouble_$cceiling @ Int GHC.Real.$fIntegralInt)
"round/Double->Int8"
    forall ($dRealFrac_a4ecF :: RealFrac Double)
           ($dIntegral_a4ecH :: Integral Int8).
      round @ Double $dRealFrac_a4ecF @ Int8 $dIntegral_a4ecH
      = . @ Int
          @ Int8
          @ Double
          (fromIntegral
             @ Int @ Int8 GHC.Real.$fIntegralInt GHC.Int.$fNumInt8)
          (GHC.Float.$fRealFracDouble_$cround @ Int GHC.Real.$fIntegralInt)
"properFraction/Float->(Int8,Float)"
    forall ($dRealFrac_a4edj :: RealFrac Float)
           ($dIntegral_a4edl :: Integral Int8).
      properFraction @ Float $dRealFrac_a4edj @ Int8 $dIntegral_a4edl
      = \ (x_a4d3n :: Float) ->
          case GHC.Float.$fRealFracFloat_$cproperFraction
                 @ Int GHC.Real.$fIntegralInt x_a4d3n
          of
          { (n_a4d3o, y_a4d3p) ->
          (fromIntegral
             @ Int @ Int8 GHC.Real.$fIntegralInt GHC.Int.$fNumInt8 n_a4d3o,
           y_a4d3p)
          }
"truncate/Float->Int8"
    forall ($dRealFrac_a4edW :: RealFrac Float)
           ($dIntegral_a4edY :: Integral Int8).
      truncate @ Float $dRealFrac_a4edW @ Int8 $dIntegral_a4edY
      = . @ Int
          @ Int8
          @ Float
          (fromIntegral
             @ Int @ Int8 GHC.Real.$fIntegralInt GHC.Int.$fNumInt8)
          (GHC.Float.$fRealFracFloat_$ctruncate @ Int GHC.Real.$fIntegralInt)
"floor/Float->Int8"
    forall ($dRealFrac_a4eeA :: RealFrac Float)
           ($dIntegral_a4eeC :: Integral Int8).
      floor @ Float $dRealFrac_a4eeA @ Int8 $dIntegral_a4eeC
      = . @ Int
          @ Int8
          @ Float
          (fromIntegral
             @ Int @ Int8 GHC.Real.$fIntegralInt GHC.Int.$fNumInt8)
          (GHC.Float.$fRealFracFloat_$cfloor @ Int GHC.Real.$fIntegralInt)
"ceiling/Float->Int8"
    forall ($dRealFrac_a4efe :: RealFrac Float)
           ($dIntegral_a4efg :: Integral Int8).
      ceiling @ Float $dRealFrac_a4efe @ Int8 $dIntegral_a4efg
      = . @ Int
          @ Int8
          @ Float
          (fromIntegral
             @ Int @ Int8 GHC.Real.$fIntegralInt GHC.Int.$fNumInt8)
          (GHC.Float.$fRealFracFloat_$cceiling @ Int GHC.Real.$fIntegralInt)
"round/Float->Int8"
    forall ($dRealFrac_a4efS :: RealFrac Float)
           ($dIntegral_a4efU :: Integral Int8).
      round @ Float $dRealFrac_a4efS @ Int8 $dIntegral_a4efU
      = . @ Int
          @ Int8
          @ Float
          (fromIntegral
             @ Int @ Int8 GHC.Real.$fIntegralInt GHC.Int.$fNumInt8)
          (GHC.Float.$fRealFracFloat_$cround @ Int GHC.Real.$fIntegralInt)
"fromIntegral/Int8->Int8"
    forall ($dIntegral_a4egx :: Integral Int8)
           ($dNum_a4egy :: Num Int8).
      fromIntegral @ Int8 @ Int8 $dIntegral_a4egx $dNum_a4egy
      = id @ Int8
"fromIntegral/a->Int8"
    forall (@ a_a4egT)
           ($dIntegral_a4egQ :: Integral a_a4egT)
           ($dNum_a4egR :: Num Int8).
      fromIntegral @ a_a4egT @ Int8 $dIntegral_a4egQ $dNum_a4egR
      = \ (x_a4d3q :: a_a4egT) ->
          case fromIntegral
                 @ a_a4egT @ Int $dIntegral_a4egQ GHC.Num.$fNumInt x_a4d3q
          of
          { I# x#_a4d3r ->
          GHC.Int.I8# (narrow8Int# x#_a4d3r)
          }
"fromIntegral/Int8->a"
    forall (@ b_a4eh8)
           ($dIntegral_a4eh9 :: Integral Int8)
           ($dNum_a4eha :: Num b_a4eh8).
      fromIntegral @ Int8 @ b_a4eh8 $dIntegral_a4eh9 $dNum_a4eha
      = \ (ds_d4eUj :: Int8) ->
          case ds_d4eUj of { I8# x#_a4d3s ->
          fromIntegral
            @ Int
            @ b_a4eh8
            GHC.Real.$fIntegralInt
            $dNum_a4eha
            (GHC.Types.I# x#_a4d3s)
          }

