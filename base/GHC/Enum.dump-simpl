
==================== Tidy Core ====================
2018-03-16 15:55:37.155013915 UTC

Result size of Tidy Core
  = {terms: 8,668, types: 7,493, coercions: 24, joins: 15/191}

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
minBound :: forall a. Bounded a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for minBound: "Class op minBound"]
minBound
  = \ (@ a_aQgj) (v_B1 :: Bounded a_aQgj) ->
      case v_B1 of v_B1 { GHC.Enum.C:Bounded v_B2 v_B3 -> v_B2 }

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
maxBound :: forall a. Bounded a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for maxBound: "Class op maxBound"]
maxBound
  = \ (@ a_aQgj) (v_B1 :: Bounded a_aQgj) ->
      case v_B1 of v_B1 { GHC.Enum.C:Bounded v_B2 v_B3 -> v_B3 }

-- RHS size: {terms: 6, types: 30, coercions: 0, joins: 0/0}
succ :: forall a. Enum a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLL),U(U,A,A,A,A,A,A,A)>,
 RULES: Built in rule for succ: "Class op succ"]
succ
  = \ (@ a_aQga) (v_B1 :: Enum a_aQga) ->
      case v_B1 of v_B1
      { GHC.Enum.C:Enum v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 30, coercions: 0, joins: 0/0}
pred :: forall a. Enum a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>,
 RULES: Built in rule for pred: "Class op pred"]
pred
  = \ (@ a_aQga) (v_B1 :: Enum a_aQga) ->
      case v_B1 of v_B1
      { GHC.Enum.C:Enum v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 30, coercions: 0, joins: 0/0}
toEnum :: forall a. Enum a => Int -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLL),U(A,A,U,A,A,A,A,A)>,
 RULES: Built in rule for toEnum: "Class op toEnum"]
toEnum
  = \ (@ a_aQga) (v_B1 :: Enum a_aQga) ->
      case v_B1 of v_B1
      { GHC.Enum.C:Enum v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 30, coercions: 0, joins: 0/0}
fromEnum :: forall a. Enum a => a -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLL),U(A,A,A,U,A,A,A,A)>,
 RULES: Built in rule for fromEnum: "Class op fromEnum"]
fromEnum
  = \ (@ a_aQga) (v_B1 :: Enum a_aQga) ->
      case v_B1 of v_B1
      { GHC.Enum.C:Enum v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 30, coercions: 0, joins: 0/0}
enumFrom :: forall a. Enum a => a -> [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLL),U(A,A,A,A,U,A,A,A)>,
 RULES: Built in rule for enumFrom: "Class op enumFrom"]
enumFrom
  = \ (@ a_aQga) (v_B1 :: Enum a_aQga) ->
      case v_B1 of v_B1
      { GHC.Enum.C:Enum v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 ->
      v_B6
      }

-- RHS size: {terms: 6, types: 30, coercions: 0, joins: 0/0}
enumFromThen :: forall a. Enum a => a -> a -> [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLL),U(A,A,A,A,A,U,A,A)>,
 RULES: Built in rule for enumFromThen: "Class op enumFromThen"]
enumFromThen
  = \ (@ a_aQga) (v_B1 :: Enum a_aQga) ->
      case v_B1 of v_B1
      { GHC.Enum.C:Enum v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 ->
      v_B7
      }

-- RHS size: {terms: 6, types: 30, coercions: 0, joins: 0/0}
enumFromTo :: forall a. Enum a => a -> a -> [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSL),U(A,A,A,A,A,A,U,A)>,
 RULES: Built in rule for enumFromTo: "Class op enumFromTo"]
enumFromTo
  = \ (@ a_aQga) (v_B1 :: Enum a_aQga) ->
      case v_B1 of v_B1
      { GHC.Enum.C:Enum v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 ->
      v_B8
      }

-- RHS size: {terms: 6, types: 30, coercions: 0, joins: 0/0}
enumFromThenTo :: forall a. Enum a => a -> a -> a -> [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLS),U(A,A,A,A,A,A,A,U)>,
 RULES: Built in rule for enumFromThenTo: "Class op enumFromThenTo"]
enumFromThenTo
  = \ (@ a_aQga) (v_B1 :: Enum a_aQga) ->
      case v_B1 of v_B1
      { GHC.Enum.C:Enum v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 ->
      v_B9
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedChar_$cmaxBound :: Char
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$fBoundedChar_$cmaxBound = GHC.Types.C# '\1114111'#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedChar_$cminBound :: Char
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$fBoundedChar_$cminBound = GHC.Types.C# '\NUL'#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Char
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Char
                          GHC.Enum.$fBoundedChar_$cminBound
                          GHC.Enum.$fBoundedChar_$cmaxBound]
GHC.Enum.$fBoundedChar
  = GHC.Enum.C:Bounded
      @ Char
      GHC.Enum.$fBoundedChar_$cminBound
      GHC.Enum.$fBoundedChar_$cmaxBound

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedInt [InlPrag=NOUSERINLINE CONLIKE] :: Bounded Int
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ -> GHC.Enum.C:Bounded TYPE: Int minInt maxInt]
GHC.Enum.$fBoundedInt = GHC.Enum.C:Bounded @ Int minInt maxInt

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedWord_$cmaxBound :: Word
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$fBoundedWord_$cmaxBound
  = GHC.Types.W# 18446744073709551615##

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedWord_$cminBound :: Word
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$fBoundedWord_$cminBound = GHC.Types.W# 0##

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Word
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Word
                          GHC.Enum.$fBoundedWord_$cminBound
                          GHC.Enum.$fBoundedWord_$cmaxBound]
GHC.Enum.$fBoundedWord
  = GHC.Enum.C:Bounded
      @ Word
      GHC.Enum.$fBoundedWord_$cminBound
      GHC.Enum.$fBoundedWord_$cmaxBound

Rec {
-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()_many [Occ=LoopBreaker] :: [()]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
GHC.Enum.$fEnum()_many
  = GHC.Types.: @ () GHC.Tuple.() GHC.Enum.$fEnum()_many
end Rec }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()_$cenumFromThenTo :: () -> () -> () -> [()]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H><S,1*H>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRB4 [Occ=Once!] :: ())
                 (ds1_dRB5 [Occ=Once!] :: ())
                 (ds2_dRB6 [Occ=Once!] :: ()) ->
                 case ds_dRB4 of { () ->
                 case ds1_dRB5 of { () ->
                 case ds2_dRB6 of { () -> GHC.Enum.$fEnum()_many }
                 }
                 }}]
GHC.Enum.$fEnum()_$cenumFromThenTo
  = \ (ds_dRB4 :: ()) (ds1_dRB5 :: ()) (ds2_dRB6 :: ()) ->
      case ds_dRB4 of { () ->
      case ds1_dRB5 of { () ->
      case ds2_dRB6 of { () -> GHC.Enum.$fEnum()_many }
      }
      }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()1 :: [()]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Enum.$fEnum()1
  = GHC.Types.: @ () GHC.Tuple.() (GHC.Types.[] @ ())

-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()_$cenumFromTo :: () -> () -> [()]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRAV [Occ=Once!] :: ()) (ds1_dRAW [Occ=Once!] :: ()) ->
                 case ds_dRAV of { () ->
                 case ds1_dRAW of { () -> GHC.Enum.$fEnum()1 }
                 }}]
GHC.Enum.$fEnum()_$cenumFromTo
  = \ (ds_dRAV :: ()) (ds1_dRAW :: ()) ->
      case ds_dRAV of { () ->
      case ds1_dRAW of { () -> GHC.Enum.$fEnum()1 }
      }

-- RHS size: {terms: 9, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()_$cenumFromThen :: () -> () -> [()]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRAP [Occ=Once!] :: ()) (ds1_dRAQ [Occ=Once!] :: ()) ->
                 case ds_dRAP of { () ->
                 case ds1_dRAQ of { () -> GHC.Enum.$fEnum()_many }
                 }}]
GHC.Enum.$fEnum()_$cenumFromThen
  = \ (ds_dRAP :: ()) (ds1_dRAQ :: ()) ->
      case ds_dRAP of { () ->
      case ds1_dRAQ of { () -> GHC.Enum.$fEnum()_many }
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()_$cenumFrom :: () -> [()]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRAI [Occ=Once!] :: ()) ->
                 case ds_dRAI of { () -> GHC.Enum.$fEnum()1 }}]
GHC.Enum.$fEnum()_$cenumFrom
  = \ (ds_dRAI :: ()) -> case ds_dRAI of { () -> GHC.Enum.$fEnum()1 }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$fEnum()2 = GHC.Types.I# 0#

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()_$cfromEnum :: () -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRAF [Occ=Once!] :: ()) ->
                 case ds_dRAF of { () -> GHC.Enum.$fEnum()2 }}]
GHC.Enum.$fEnum()_$cfromEnum
  = \ (ds_dRAF :: ()) -> case ds_dRAF of { () -> GHC.Enum.$fEnum()2 }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_rUQG :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_rUQG = "Prelude.Enum.().toEnum: bad argument"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()3 :: ()
[GblId, Str=x]
GHC.Enum.$fEnum()3
  = errorWithoutStackTrace
      @ 'LiftedRep @ () (unpackCString# lvl_rUQG)

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()_$ctoEnum :: Int -> ()
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_aQha [Occ=Once!] :: Int) ->
                 case x_aQha of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> GHC.Enum.$fEnum()3;
                   0# -> GHC.Tuple.()
                 }
                 }}]
GHC.Enum.$fEnum()_$ctoEnum
  = \ (x_aQha :: Int) ->
      case x_aQha of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> GHC.Enum.$fEnum()3;
        0# -> GHC.Tuple.()
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Enum.$fEnum()5 = "Prelude.Enum.().pred: bad argument"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnum()4 = unpackCString# GHC.Enum.$fEnum()5

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()_$cpred :: () -> ()
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] ->
                 errorWithoutStackTrace @ 'LiftedRep @ () GHC.Enum.$fEnum()4}]
GHC.Enum.$fEnum()_$cpred
  = \ _ [Occ=Dead] ->
      errorWithoutStackTrace @ 'LiftedRep @ () GHC.Enum.$fEnum()4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Enum.$fEnum()7 = "Prelude.Enum.().succ: bad argument"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnum()6 = unpackCString# GHC.Enum.$fEnum()7

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum()_$csucc :: () -> ()
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] ->
                 errorWithoutStackTrace @ 'LiftedRep @ () GHC.Enum.$fEnum()6}]
GHC.Enum.$fEnum()_$csucc
  = \ _ [Occ=Dead] ->
      errorWithoutStackTrace @ 'LiftedRep @ () GHC.Enum.$fEnum()6

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnum() [InlPrag=NOUSERINLINE CONLIKE] :: Enum ()
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: ()
                       GHC.Enum.$fEnum()_$csucc
                       GHC.Enum.$fEnum()_$cpred
                       GHC.Enum.$fEnum()_$ctoEnum
                       GHC.Enum.$fEnum()_$cfromEnum
                       GHC.Enum.$fEnum()_$cenumFrom
                       GHC.Enum.$fEnum()_$cenumFromThen
                       GHC.Enum.$fEnum()_$cenumFromTo
                       GHC.Enum.$fEnum()_$cenumFromThenTo]
GHC.Enum.$fEnum()
  = GHC.Enum.C:Enum
      @ ()
      GHC.Enum.$fEnum()_$csucc
      GHC.Enum.$fEnum()_$cpred
      GHC.Enum.$fEnum()_$ctoEnum
      GHC.Enum.$fEnum()_$cfromEnum
      GHC.Enum.$fEnum()_$cenumFrom
      GHC.Enum.$fEnum()_$cenumFromThen
      GHC.Enum.$fEnum()_$cenumFromTo
      GHC.Enum.$fEnum()_$cenumFromThenTo

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$fEnumBool4 = GHC.Types.I# 1#

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool_$cfromEnum :: Bool -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRAq [Occ=Once!] :: Bool) ->
                 case ds_dRAq of {
                   False -> GHC.Enum.$fEnum()2;
                   True -> GHC.Enum.$fEnumBool4
                 }}]
GHC.Enum.$fEnumBool_$cfromEnum
  = \ (ds_dRAq :: Bool) ->
      case ds_dRAq of {
        False -> GHC.Enum.$fEnum()2;
        True -> GHC.Enum.$fEnumBool4
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1_rUQH :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl1_rUQH = "Prelude.Enum.Bool.toEnum: bad argument"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool1 :: Bool
[GblId, Str=x]
GHC.Enum.$fEnumBool1
  = errorWithoutStackTrace
      @ 'LiftedRep @ Bool (unpackCString# lvl1_rUQH)

-- RHS size: {terms: 12, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool_$ctoEnum :: Int -> Bool
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_aQh9 [Occ=Once!] :: Int) ->
                 case n_aQh9 of { I# x_a22G [Occ=Once!] ->
                 case x_a22G of {
                   __DEFAULT -> GHC.Enum.$fEnumBool1;
                   0# -> GHC.Types.False;
                   1# -> GHC.Types.True
                 }
                 }}]
GHC.Enum.$fEnumBool_$ctoEnum
  = \ (n_aQh9 :: Int) ->
      case n_aQh9 of { I# x_a22G ->
      case x_a22G of {
        __DEFAULT -> GHC.Enum.$fEnumBool1;
        0# -> GHC.Types.False;
        1# -> GHC.Types.True
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2_rUQI :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl2_rUQI = "Prelude.Enum.Bool.pred: bad argument"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool5 :: Bool
[GblId, Str=x]
GHC.Enum.$fEnumBool5
  = errorWithoutStackTrace
      @ 'LiftedRep @ Bool (unpackCString# lvl2_rUQI)

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool_$cpred :: Bool -> Bool
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRAh [Occ=Once!] :: Bool) ->
                 case ds_dRAh of {
                   False -> GHC.Enum.$fEnumBool5;
                   True -> GHC.Types.False
                 }}]
GHC.Enum.$fEnumBool_$cpred
  = \ (ds_dRAh :: Bool) ->
      case ds_dRAh of {
        False -> GHC.Enum.$fEnumBool5;
        True -> GHC.Types.False
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl3_rUQJ :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl3_rUQJ = "Prelude.Enum.Bool.succ: bad argument"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool6 :: Bool
[GblId, Str=x]
GHC.Enum.$fEnumBool6
  = errorWithoutStackTrace
      @ 'LiftedRep @ Bool (unpackCString# lvl3_rUQJ)

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool_$csucc :: Bool -> Bool
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRAd [Occ=Once!] :: Bool) ->
                 case ds_dRAd of {
                   False -> GHC.Types.True;
                   True -> GHC.Enum.$fEnumBool6
                 }}]
GHC.Enum.$fEnumBool_$csucc
  = \ (ds_dRAd :: Bool) ->
      case ds_dRAd of {
        False -> GHC.Types.True;
        True -> GHC.Enum.$fEnumBool6
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$fEnumOrdering4 = GHC.Types.I# 2#

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering_$cfromEnum :: Ordering -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRA6 [Occ=Once!] :: Ordering) ->
                 case ds_dRA6 of {
                   LT -> GHC.Enum.$fEnum()2;
                   EQ -> GHC.Enum.$fEnumBool4;
                   GT -> GHC.Enum.$fEnumOrdering4
                 }}]
GHC.Enum.$fEnumOrdering_$cfromEnum
  = \ (ds_dRA6 :: Ordering) ->
      case ds_dRA6 of {
        LT -> GHC.Enum.$fEnum()2;
        EQ -> GHC.Enum.$fEnumBool4;
        GT -> GHC.Enum.$fEnumOrdering4
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl4_rUQK :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl4_rUQK = "Prelude.Enum.Ordering.toEnum: bad argument"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering5 :: Ordering
[GblId, Str=x]
GHC.Enum.$fEnumOrdering5
  = errorWithoutStackTrace
      @ 'LiftedRep @ Ordering (unpackCString# lvl4_rUQK)

-- RHS size: {terms: 14, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering_$ctoEnum :: Int -> Ordering
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_aQh8 [Occ=Once!] :: Int) ->
                 case n_aQh8 of { I# x_a22G [Occ=Once!] ->
                 case x_a22G of {
                   __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                   0# -> GHC.Types.LT;
                   1# -> GHC.Types.EQ;
                   2# -> GHC.Types.GT
                 }
                 }}]
GHC.Enum.$fEnumOrdering_$ctoEnum
  = \ (n_aQh8 :: Int) ->
      case n_aQh8 of { I# x_a22G ->
      case x_a22G of {
        __DEFAULT -> GHC.Enum.$fEnumOrdering5;
        0# -> GHC.Types.LT;
        1# -> GHC.Types.EQ;
        2# -> GHC.Types.GT
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl5_rUQL :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl5_rUQL = "Prelude.Enum.Ordering.pred: bad argument"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering6 :: Ordering
[GblId, Str=x]
GHC.Enum.$fEnumOrdering6
  = errorWithoutStackTrace
      @ 'LiftedRep @ Ordering (unpackCString# lvl5_rUQL)

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering_$cpred :: Ordering -> Ordering
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRzT [Occ=Once!] :: Ordering) ->
                 case ds_dRzT of {
                   LT -> GHC.Enum.$fEnumOrdering6;
                   EQ -> GHC.Types.LT;
                   GT -> GHC.Types.EQ
                 }}]
GHC.Enum.$fEnumOrdering_$cpred
  = \ (ds_dRzT :: Ordering) ->
      case ds_dRzT of {
        LT -> GHC.Enum.$fEnumOrdering6;
        EQ -> GHC.Types.LT;
        GT -> GHC.Types.EQ
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl6_rUQM :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl6_rUQM = "Prelude.Enum.Ordering.succ: bad argument"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering7 :: Ordering
[GblId, Str=x]
GHC.Enum.$fEnumOrdering7
  = errorWithoutStackTrace
      @ 'LiftedRep @ Ordering (unpackCString# lvl6_rUQM)

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering_$csucc :: Ordering -> Ordering
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRzO [Occ=Once!] :: Ordering) ->
                 case ds_dRzO of {
                   LT -> GHC.Types.EQ;
                   EQ -> GHC.Types.GT;
                   GT -> GHC.Enum.$fEnumOrdering7
                 }}]
GHC.Enum.$fEnumOrdering_$csucc
  = \ (ds_dRzO :: Ordering) ->
      case ds_dRzO of {
        LT -> GHC.Types.EQ;
        EQ -> GHC.Types.GT;
        GT -> GHC.Enum.$fEnumOrdering7
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl7_rUQN :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl7_rUQN = "Prelude.Enum.Char.pred: bad argument"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumChar1 :: Char
[GblId, Str=x]
GHC.Enum.$fEnumChar1
  = errorWithoutStackTrace
      @ 'LiftedRep @ Char (unpackCString# lvl7_rUQN)

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumChar_$cpred :: Char -> Char
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRze [Occ=Once!] :: Char) ->
                 case ds_dRze of { C# c#_aQgZ ->
                 case ord# c#_aQgZ of {
                   __DEFAULT -> GHC.Types.C# (chr# (-# (ord# c#_aQgZ) 1#));
                   0# -> GHC.Enum.$fEnumChar1
                 }
                 }}]
GHC.Enum.$fEnumChar_$cpred
  = \ (ds_dRze :: Char) ->
      case ds_dRze of { C# c#_aQgZ ->
      case ord# c#_aQgZ of wild1_X40 {
        __DEFAULT -> GHC.Types.C# (chr# (-# wild1_X40 1#));
        0# -> GHC.Enum.$fEnumChar1
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl8_rUQO :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl8_rUQO = "Prelude.Enum.Char.succ: bad argument"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumChar2 :: Char
[GblId, Str=x]
GHC.Enum.$fEnumChar2
  = errorWithoutStackTrace
      @ 'LiftedRep @ Char (unpackCString# lvl8_rUQO)

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumChar_$csucc :: Char -> Char
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRz8 [Occ=Once!] :: Char) ->
                 case ds_dRz8 of { C# c#_aQgY ->
                 case ord# c#_aQgY of {
                   __DEFAULT -> GHC.Types.C# (chr# (+# (ord# c#_aQgY) 1#));
                   1114111# -> GHC.Enum.$fEnumChar2
                 }
                 }}]
GHC.Enum.$fEnumChar_$csucc
  = \ (ds_dRz8 :: Char) ->
      case ds_dRz8 of { C# c#_aQgY ->
      case ord# c#_aQgY of wild1_X41 {
        __DEFAULT -> GHC.Types.C# (chr# (+# wild1_X41 1#));
        1114111# -> GHC.Enum.$fEnumChar2
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInt_$cfromEnum :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (x_aQgO [Occ=Once] :: Int) -> x_aQgO}]
GHC.Enum.$fEnumInt_$cfromEnum = \ (x_aQgO :: Int) -> x_aQgO

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl9_rUQP :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl9_rUQP
  = "Prelude.Enum.pred{Int}: tried to take `pred' of minBound"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInt1 :: Int
[GblId, Str=x]
GHC.Enum.$fEnumInt1
  = errorWithoutStackTrace
      @ 'LiftedRep @ Int (unpackCString# lvl9_rUQP)

-- RHS size: {terms: 13, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInt_$cpred :: Int -> Int
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_aQgM [Occ=Once!] :: Int) ->
                 case x_aQgM of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of wild1_X6f {
                   __DEFAULT -> GHC.Types.I# (-# wild1_X6f 1#);
                   -9223372036854775808# -> GHC.Enum.$fEnumInt1
                 }
                 }}]
GHC.Enum.$fEnumInt_$cpred
  = \ (x_aQgM :: Int) ->
      case x_aQgM of { I# x1_a22G ->
      case x1_a22G of wild1_X6f {
        __DEFAULT -> GHC.Types.I# (-# wild1_X6f 1#);
        -9223372036854775808# -> GHC.Enum.$fEnumInt1
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl10_rUQQ :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl10_rUQQ
  = "Prelude.Enum.succ{Int}: tried to take `succ' of maxBound"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInt2 :: Int
[GblId, Str=x]
GHC.Enum.$fEnumInt2
  = errorWithoutStackTrace
      @ 'LiftedRep @ Int (unpackCString# lvl10_rUQQ)

-- RHS size: {terms: 13, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInt_$csucc :: Int -> Int
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_aQgL [Occ=Once!] :: Int) ->
                 case x_aQgL of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of wild1_X6h {
                   __DEFAULT -> GHC.Types.I# (+# wild1_X6h 1#);
                   9223372036854775807# -> GHC.Enum.$fEnumInt2
                 }
                 }}]
GHC.Enum.$fEnumInt_$csucc
  = \ (x_aQgL :: Int) ->
      case x_aQgL of { I# x1_a22G ->
      case x1_a22G of wild1_X6h {
        __DEFAULT -> GHC.Types.I# (+# wild1_X6h 1#);
        9223372036854775807# -> GHC.Enum.$fEnumInt2
      }
      }

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger_$cfromEnum :: Integer -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (n_aQgn [Occ=Once] :: Integer) ->
                 case integerToInt n_aQgn of wild_X41 { __DEFAULT ->
                 GHC.Types.I# wild_X41
                 }}]
GHC.Enum.$fEnumInteger_$cfromEnum
  = \ (n_aQgn :: Integer) ->
      case integerToInt n_aQgn of wild_X41 { __DEFAULT ->
      GHC.Types.I# wild_X41
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger_$ctoEnum :: Int -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dRxB [Occ=Once!] :: Int) ->
                 case ds_dRxB of { I# n_aQgm [Occ=Once] -> smallInteger n_aQgm }}]
GHC.Enum.$fEnumInteger_$ctoEnum
  = \ (ds_dRxB :: Int) ->
      case ds_dRxB of { I# n_aQgm -> smallInteger n_aQgm }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded() [InlPrag=NOUSERINLINE CONLIKE] :: Bounded ()
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: () GHC.Tuple.() GHC.Tuple.()]
GHC.Enum.$fBounded()
  = GHC.Enum.C:Bounded @ () GHC.Tuple.() GHC.Tuple.()

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,)_$cmaxBound
  :: forall a b. (Bounded a, Bounded b) => (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aRhJ)
                 (@ b_aRhK)
                 ($dBounded_aRhL [Occ=Once] :: Bounded a_aRhJ)
                 ($dBounded1_aRhM [Occ=Once] :: Bounded b_aRhK) ->
                 (maxBound @ a_aRhJ $dBounded_aRhL,
                  maxBound @ b_aRhK $dBounded1_aRhM)}]
GHC.Enum.$fBounded(,)_$cmaxBound
  = \ (@ a_aRhJ)
      (@ b_aRhK)
      ($dBounded_aRhL :: Bounded a_aRhJ)
      ($dBounded1_aRhM :: Bounded b_aRhK) ->
      (maxBound @ a_aRhJ $dBounded_aRhL,
       maxBound @ b_aRhK $dBounded1_aRhM)

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,)_$cminBound
  :: forall a b. (Bounded a, Bounded b) => (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aRhJ)
                 (@ b_aRhK)
                 ($dBounded_aRhL [Occ=Once] :: Bounded a_aRhJ)
                 ($dBounded1_aRhM [Occ=Once] :: Bounded b_aRhK) ->
                 (minBound @ a_aRhJ $dBounded_aRhL,
                  minBound @ b_aRhK $dBounded1_aRhM)}]
GHC.Enum.$fBounded(,)_$cminBound
  = \ (@ a_aRhJ)
      (@ b_aRhK)
      ($dBounded_aRhL :: Bounded a_aRhJ)
      ($dBounded1_aRhM :: Bounded b_aRhK) ->
      (minBound @ a_aRhJ $dBounded_aRhL,
       minBound @ b_aRhK $dBounded1_aRhM)

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Bounded a, Bounded b) => Bounded (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQnO)
             (@ b_aQnP)
             (v_B1 :: Bounded a_aQnO)
             (v1_B2 :: Bounded b_aQnP) ->
       GHC.Enum.C:Bounded TYPE: (a_aQnO, b_aQnP)
                          GHC.Enum.$fBounded(,)_$cminBound @ a_aQnO @ b_aQnP v_B1 v1_B2
                          GHC.Enum.$fBounded(,)_$cmaxBound @ a_aQnO @ b_aQnP v_B1 v1_B2]
GHC.Enum.$fBounded(,)
  = \ (@ a_aRhJ)
      (@ b_aRhK)
      ($dBounded_aRhL :: Bounded a_aRhJ)
      ($dBounded1_aRhM :: Bounded b_aRhK) ->
      GHC.Enum.C:Bounded
        @ (a_aRhJ, b_aRhK)
        (GHC.Enum.$fBounded(,)_$cminBound
           @ a_aRhJ @ b_aRhK $dBounded_aRhL $dBounded1_aRhM)
        (GHC.Enum.$fBounded(,)_$cmaxBound
           @ a_aRhJ @ b_aRhK $dBounded_aRhL $dBounded1_aRhM)

-- RHS size: {terms: 13, types: 18, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,)_$cmaxBound
  :: forall a b c. (Bounded a, Bounded b, Bounded c) => (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aRhb)
                 (@ b_aRhc)
                 (@ c_aRhd)
                 ($dBounded_aRhe [Occ=Once] :: Bounded a_aRhb)
                 ($dBounded1_aRhf [Occ=Once] :: Bounded b_aRhc)
                 ($dBounded2_aRhg [Occ=Once] :: Bounded c_aRhd) ->
                 (maxBound @ a_aRhb $dBounded_aRhe,
                  maxBound @ b_aRhc $dBounded1_aRhf,
                  maxBound @ c_aRhd $dBounded2_aRhg)}]
GHC.Enum.$fBounded(,,)_$cmaxBound
  = \ (@ a_aRhb)
      (@ b_aRhc)
      (@ c_aRhd)
      ($dBounded_aRhe :: Bounded a_aRhb)
      ($dBounded1_aRhf :: Bounded b_aRhc)
      ($dBounded2_aRhg :: Bounded c_aRhd) ->
      (maxBound @ a_aRhb $dBounded_aRhe,
       maxBound @ b_aRhc $dBounded1_aRhf,
       maxBound @ c_aRhd $dBounded2_aRhg)

-- RHS size: {terms: 13, types: 18, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,)_$cminBound
  :: forall a b c. (Bounded a, Bounded b, Bounded c) => (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aRhb)
                 (@ b_aRhc)
                 (@ c_aRhd)
                 ($dBounded_aRhe [Occ=Once] :: Bounded a_aRhb)
                 ($dBounded1_aRhf [Occ=Once] :: Bounded b_aRhc)
                 ($dBounded2_aRhg [Occ=Once] :: Bounded c_aRhd) ->
                 (minBound @ a_aRhb $dBounded_aRhe,
                  minBound @ b_aRhc $dBounded1_aRhf,
                  minBound @ c_aRhd $dBounded2_aRhg)}]
GHC.Enum.$fBounded(,,)_$cminBound
  = \ (@ a_aRhb)
      (@ b_aRhc)
      (@ c_aRhd)
      ($dBounded_aRhe :: Bounded a_aRhb)
      ($dBounded1_aRhf :: Bounded b_aRhc)
      ($dBounded2_aRhg :: Bounded c_aRhd) ->
      (minBound @ a_aRhb $dBounded_aRhe,
       minBound @ b_aRhc $dBounded1_aRhf,
       minBound @ c_aRhd $dBounded2_aRhg)

-- RHS size: {terms: 15, types: 22, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c.
     (Bounded a, Bounded b, Bounded c) =>
     Bounded (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQnL)
             (@ b_aQnM)
             (@ c_aQnN)
             (v_B1 :: Bounded a_aQnL)
             (v1_B2 :: Bounded b_aQnM)
             (v2_B3 :: Bounded c_aQnN) ->
       GHC.Enum.C:Bounded TYPE: (a_aQnL, b_aQnM, c_aQnN)
                          GHC.Enum.$fBounded(,,)_$cminBound
                            @ a_aQnL @ b_aQnM @ c_aQnN v_B1 v1_B2 v2_B3
                          GHC.Enum.$fBounded(,,)_$cmaxBound
                            @ a_aQnL @ b_aQnM @ c_aQnN v_B1 v1_B2 v2_B3]
GHC.Enum.$fBounded(,,)
  = \ (@ a_aRhb)
      (@ b_aRhc)
      (@ c_aRhd)
      ($dBounded_aRhe :: Bounded a_aRhb)
      ($dBounded1_aRhf :: Bounded b_aRhc)
      ($dBounded2_aRhg :: Bounded c_aRhd) ->
      GHC.Enum.C:Bounded
        @ (a_aRhb, b_aRhc, c_aRhd)
        (GHC.Enum.$fBounded(,,)_$cminBound
           @ a_aRhb
           @ b_aRhc
           @ c_aRhd
           $dBounded_aRhe
           $dBounded1_aRhf
           $dBounded2_aRhg)
        (GHC.Enum.$fBounded(,,)_$cmaxBound
           @ a_aRhb
           @ b_aRhc
           @ c_aRhd
           $dBounded_aRhe
           $dBounded1_aRhf
           $dBounded2_aRhg)

-- RHS size: {terms: 17, types: 24, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,)_$cmaxBound
  :: forall a b c d.
     (Bounded a, Bounded b, Bounded c, Bounded d) =>
     (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aRgv)
                 (@ b_aRgw)
                 (@ c_aRgx)
                 (@ d_aRgy)
                 ($dBounded_aRgz [Occ=Once] :: Bounded a_aRgv)
                 ($dBounded1_aRgA [Occ=Once] :: Bounded b_aRgw)
                 ($dBounded2_aRgB [Occ=Once] :: Bounded c_aRgx)
                 ($dBounded3_aRgC [Occ=Once] :: Bounded d_aRgy) ->
                 (maxBound @ a_aRgv $dBounded_aRgz,
                  maxBound @ b_aRgw $dBounded1_aRgA,
                  maxBound @ c_aRgx $dBounded2_aRgB,
                  maxBound @ d_aRgy $dBounded3_aRgC)}]
GHC.Enum.$fBounded(,,,)_$cmaxBound
  = \ (@ a_aRgv)
      (@ b_aRgw)
      (@ c_aRgx)
      (@ d_aRgy)
      ($dBounded_aRgz :: Bounded a_aRgv)
      ($dBounded1_aRgA :: Bounded b_aRgw)
      ($dBounded2_aRgB :: Bounded c_aRgx)
      ($dBounded3_aRgC :: Bounded d_aRgy) ->
      (maxBound @ a_aRgv $dBounded_aRgz,
       maxBound @ b_aRgw $dBounded1_aRgA,
       maxBound @ c_aRgx $dBounded2_aRgB,
       maxBound @ d_aRgy $dBounded3_aRgC)

-- RHS size: {terms: 17, types: 24, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,)_$cminBound
  :: forall a b c d.
     (Bounded a, Bounded b, Bounded c, Bounded d) =>
     (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aRgv)
                 (@ b_aRgw)
                 (@ c_aRgx)
                 (@ d_aRgy)
                 ($dBounded_aRgz [Occ=Once] :: Bounded a_aRgv)
                 ($dBounded1_aRgA [Occ=Once] :: Bounded b_aRgw)
                 ($dBounded2_aRgB [Occ=Once] :: Bounded c_aRgx)
                 ($dBounded3_aRgC [Occ=Once] :: Bounded d_aRgy) ->
                 (minBound @ a_aRgv $dBounded_aRgz,
                  minBound @ b_aRgw $dBounded1_aRgA,
                  minBound @ c_aRgx $dBounded2_aRgB,
                  minBound @ d_aRgy $dBounded3_aRgC)}]
GHC.Enum.$fBounded(,,,)_$cminBound
  = \ (@ a_aRgv)
      (@ b_aRgw)
      (@ c_aRgx)
      (@ d_aRgy)
      ($dBounded_aRgz :: Bounded a_aRgv)
      ($dBounded1_aRgA :: Bounded b_aRgw)
      ($dBounded2_aRgB :: Bounded c_aRgx)
      ($dBounded3_aRgC :: Bounded d_aRgy) ->
      (minBound @ a_aRgv $dBounded_aRgz,
       minBound @ b_aRgw $dBounded1_aRgA,
       minBound @ c_aRgx $dBounded2_aRgB,
       minBound @ d_aRgy $dBounded3_aRgC)

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (Bounded a, Bounded b, Bounded c, Bounded d) =>
     Bounded (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQnH)
             (@ b_aQnI)
             (@ c_aQnJ)
             (@ d_aQnK)
             (v_B1 :: Bounded a_aQnH)
             (v1_B2 :: Bounded b_aQnI)
             (v2_B3 :: Bounded c_aQnJ)
             (v3_B4 :: Bounded d_aQnK) ->
       GHC.Enum.C:Bounded TYPE: (a_aQnH, b_aQnI, c_aQnJ, d_aQnK)
                          GHC.Enum.$fBounded(,,,)_$cminBound
                            @ a_aQnH @ b_aQnI @ c_aQnJ @ d_aQnK v_B1 v1_B2 v2_B3 v3_B4
                          GHC.Enum.$fBounded(,,,)_$cmaxBound
                            @ a_aQnH @ b_aQnI @ c_aQnJ @ d_aQnK v_B1 v1_B2 v2_B3 v3_B4]
GHC.Enum.$fBounded(,,,)
  = \ (@ a_aRgv)
      (@ b_aRgw)
      (@ c_aRgx)
      (@ d_aRgy)
      ($dBounded_aRgz :: Bounded a_aRgv)
      ($dBounded1_aRgA :: Bounded b_aRgw)
      ($dBounded2_aRgB :: Bounded c_aRgx)
      ($dBounded3_aRgC :: Bounded d_aRgy) ->
      GHC.Enum.C:Bounded
        @ (a_aRgv, b_aRgw, c_aRgx, d_aRgy)
        (GHC.Enum.$fBounded(,,,)_$cminBound
           @ a_aRgv
           @ b_aRgw
           @ c_aRgx
           @ d_aRgy
           $dBounded_aRgz
           $dBounded1_aRgA
           $dBounded2_aRgB
           $dBounded3_aRgC)
        (GHC.Enum.$fBounded(,,,)_$cmaxBound
           @ a_aRgv
           @ b_aRgw
           @ c_aRgx
           @ d_aRgy
           $dBounded_aRgz
           $dBounded1_aRgA
           $dBounded2_aRgB
           $dBounded3_aRgC)

-- RHS size: {terms: 21, types: 30, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,)_$cmaxBound
  :: forall a b c d e.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) =>
     (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aRfH)
                 (@ b_aRfI)
                 (@ c_aRfJ)
                 (@ d_aRfK)
                 (@ e_aRfL)
                 ($dBounded_aRfM [Occ=Once] :: Bounded a_aRfH)
                 ($dBounded1_aRfN [Occ=Once] :: Bounded b_aRfI)
                 ($dBounded2_aRfO [Occ=Once] :: Bounded c_aRfJ)
                 ($dBounded3_aRfP [Occ=Once] :: Bounded d_aRfK)
                 ($dBounded4_aRfQ [Occ=Once] :: Bounded e_aRfL) ->
                 (maxBound @ a_aRfH $dBounded_aRfM,
                  maxBound @ b_aRfI $dBounded1_aRfN,
                  maxBound @ c_aRfJ $dBounded2_aRfO,
                  maxBound @ d_aRfK $dBounded3_aRfP,
                  maxBound @ e_aRfL $dBounded4_aRfQ)}]
GHC.Enum.$fBounded(,,,,)_$cmaxBound
  = \ (@ a_aRfH)
      (@ b_aRfI)
      (@ c_aRfJ)
      (@ d_aRfK)
      (@ e_aRfL)
      ($dBounded_aRfM :: Bounded a_aRfH)
      ($dBounded1_aRfN :: Bounded b_aRfI)
      ($dBounded2_aRfO :: Bounded c_aRfJ)
      ($dBounded3_aRfP :: Bounded d_aRfK)
      ($dBounded4_aRfQ :: Bounded e_aRfL) ->
      (maxBound @ a_aRfH $dBounded_aRfM,
       maxBound @ b_aRfI $dBounded1_aRfN,
       maxBound @ c_aRfJ $dBounded2_aRfO,
       maxBound @ d_aRfK $dBounded3_aRfP,
       maxBound @ e_aRfL $dBounded4_aRfQ)

-- RHS size: {terms: 21, types: 30, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,)_$cminBound
  :: forall a b c d e.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) =>
     (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aRfH)
                 (@ b_aRfI)
                 (@ c_aRfJ)
                 (@ d_aRfK)
                 (@ e_aRfL)
                 ($dBounded_aRfM [Occ=Once] :: Bounded a_aRfH)
                 ($dBounded1_aRfN [Occ=Once] :: Bounded b_aRfI)
                 ($dBounded2_aRfO [Occ=Once] :: Bounded c_aRfJ)
                 ($dBounded3_aRfP [Occ=Once] :: Bounded d_aRfK)
                 ($dBounded4_aRfQ [Occ=Once] :: Bounded e_aRfL) ->
                 (minBound @ a_aRfH $dBounded_aRfM,
                  minBound @ b_aRfI $dBounded1_aRfN,
                  minBound @ c_aRfJ $dBounded2_aRfO,
                  minBound @ d_aRfK $dBounded3_aRfP,
                  minBound @ e_aRfL $dBounded4_aRfQ)}]
GHC.Enum.$fBounded(,,,,)_$cminBound
  = \ (@ a_aRfH)
      (@ b_aRfI)
      (@ c_aRfJ)
      (@ d_aRfK)
      (@ e_aRfL)
      ($dBounded_aRfM :: Bounded a_aRfH)
      ($dBounded1_aRfN :: Bounded b_aRfI)
      ($dBounded2_aRfO :: Bounded c_aRfJ)
      ($dBounded3_aRfP :: Bounded d_aRfK)
      ($dBounded4_aRfQ :: Bounded e_aRfL) ->
      (minBound @ a_aRfH $dBounded_aRfM,
       minBound @ b_aRfI $dBounded1_aRfN,
       minBound @ c_aRfJ $dBounded2_aRfO,
       minBound @ d_aRfK $dBounded3_aRfP,
       minBound @ e_aRfL $dBounded4_aRfQ)

-- RHS size: {terms: 23, types: 36, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) =>
     Bounded (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQnC)
             (@ b_aQnD)
             (@ c_aQnE)
             (@ d_aQnF)
             (@ e_aQnG)
             (v_B1 :: Bounded a_aQnC)
             (v1_B2 :: Bounded b_aQnD)
             (v2_B3 :: Bounded c_aQnE)
             (v3_B4 :: Bounded d_aQnF)
             (v4_B5 :: Bounded e_aQnG) ->
       GHC.Enum.C:Bounded TYPE: (a_aQnC, b_aQnD, c_aQnE, d_aQnF, e_aQnG)
                          GHC.Enum.$fBounded(,,,,)_$cminBound
                            @ a_aQnC
                            @ b_aQnD
                            @ c_aQnE
                            @ d_aQnF
                            @ e_aQnG
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                          GHC.Enum.$fBounded(,,,,)_$cmaxBound
                            @ a_aQnC
                            @ b_aQnD
                            @ c_aQnE
                            @ d_aQnF
                            @ e_aQnG
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5]
GHC.Enum.$fBounded(,,,,)
  = \ (@ a_aRfH)
      (@ b_aRfI)
      (@ c_aRfJ)
      (@ d_aRfK)
      (@ e_aRfL)
      ($dBounded_aRfM :: Bounded a_aRfH)
      ($dBounded1_aRfN :: Bounded b_aRfI)
      ($dBounded2_aRfO :: Bounded c_aRfJ)
      ($dBounded3_aRfP :: Bounded d_aRfK)
      ($dBounded4_aRfQ :: Bounded e_aRfL) ->
      GHC.Enum.C:Bounded
        @ (a_aRfH, b_aRfI, c_aRfJ, d_aRfK, e_aRfL)
        (GHC.Enum.$fBounded(,,,,)_$cminBound
           @ a_aRfH
           @ b_aRfI
           @ c_aRfJ
           @ d_aRfK
           @ e_aRfL
           $dBounded_aRfM
           $dBounded1_aRfN
           $dBounded2_aRfO
           $dBounded3_aRfP
           $dBounded4_aRfQ)
        (GHC.Enum.$fBounded(,,,,)_$cmaxBound
           @ a_aRfH
           @ b_aRfI
           @ c_aRfJ
           @ d_aRfK
           @ e_aRfL
           $dBounded_aRfM
           $dBounded1_aRfN
           $dBounded2_aRfO
           $dBounded3_aRfP
           $dBounded4_aRfQ)

-- RHS size: {terms: 25, types: 36, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,)_$cmaxBound
  :: forall a b c d e f.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
      Bounded f) =>
     (a, b, c, d, e, f)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aReL)
                 (@ b_aReM)
                 (@ c_aReN)
                 (@ d_aReO)
                 (@ e_aReP)
                 (@ f_aReQ)
                 ($dBounded_aReR [Occ=Once] :: Bounded a_aReL)
                 ($dBounded1_aReS [Occ=Once] :: Bounded b_aReM)
                 ($dBounded2_aReT [Occ=Once] :: Bounded c_aReN)
                 ($dBounded3_aReU [Occ=Once] :: Bounded d_aReO)
                 ($dBounded4_aReV [Occ=Once] :: Bounded e_aReP)
                 ($dBounded5_aReW [Occ=Once] :: Bounded f_aReQ) ->
                 (maxBound @ a_aReL $dBounded_aReR,
                  maxBound @ b_aReM $dBounded1_aReS,
                  maxBound @ c_aReN $dBounded2_aReT,
                  maxBound @ d_aReO $dBounded3_aReU,
                  maxBound @ e_aReP $dBounded4_aReV,
                  maxBound @ f_aReQ $dBounded5_aReW)}]
GHC.Enum.$fBounded(,,,,,)_$cmaxBound
  = \ (@ a_aReL)
      (@ b_aReM)
      (@ c_aReN)
      (@ d_aReO)
      (@ e_aReP)
      (@ f_aReQ)
      ($dBounded_aReR :: Bounded a_aReL)
      ($dBounded1_aReS :: Bounded b_aReM)
      ($dBounded2_aReT :: Bounded c_aReN)
      ($dBounded3_aReU :: Bounded d_aReO)
      ($dBounded4_aReV :: Bounded e_aReP)
      ($dBounded5_aReW :: Bounded f_aReQ) ->
      (maxBound @ a_aReL $dBounded_aReR,
       maxBound @ b_aReM $dBounded1_aReS,
       maxBound @ c_aReN $dBounded2_aReT,
       maxBound @ d_aReO $dBounded3_aReU,
       maxBound @ e_aReP $dBounded4_aReV,
       maxBound @ f_aReQ $dBounded5_aReW)

-- RHS size: {terms: 25, types: 36, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,)_$cminBound
  :: forall a b c d e f.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
      Bounded f) =>
     (a, b, c, d, e, f)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aReL)
                 (@ b_aReM)
                 (@ c_aReN)
                 (@ d_aReO)
                 (@ e_aReP)
                 (@ f_aReQ)
                 ($dBounded_aReR [Occ=Once] :: Bounded a_aReL)
                 ($dBounded1_aReS [Occ=Once] :: Bounded b_aReM)
                 ($dBounded2_aReT [Occ=Once] :: Bounded c_aReN)
                 ($dBounded3_aReU [Occ=Once] :: Bounded d_aReO)
                 ($dBounded4_aReV [Occ=Once] :: Bounded e_aReP)
                 ($dBounded5_aReW [Occ=Once] :: Bounded f_aReQ) ->
                 (minBound @ a_aReL $dBounded_aReR,
                  minBound @ b_aReM $dBounded1_aReS,
                  minBound @ c_aReN $dBounded2_aReT,
                  minBound @ d_aReO $dBounded3_aReU,
                  minBound @ e_aReP $dBounded4_aReV,
                  minBound @ f_aReQ $dBounded5_aReW)}]
GHC.Enum.$fBounded(,,,,,)_$cminBound
  = \ (@ a_aReL)
      (@ b_aReM)
      (@ c_aReN)
      (@ d_aReO)
      (@ e_aReP)
      (@ f_aReQ)
      ($dBounded_aReR :: Bounded a_aReL)
      ($dBounded1_aReS :: Bounded b_aReM)
      ($dBounded2_aReT :: Bounded c_aReN)
      ($dBounded3_aReU :: Bounded d_aReO)
      ($dBounded4_aReV :: Bounded e_aReP)
      ($dBounded5_aReW :: Bounded f_aReQ) ->
      (minBound @ a_aReL $dBounded_aReR,
       minBound @ b_aReM $dBounded1_aReS,
       minBound @ c_aReN $dBounded2_aReT,
       minBound @ d_aReO $dBounded3_aReU,
       minBound @ e_aReP $dBounded4_aReV,
       minBound @ f_aReQ $dBounded5_aReW)

-- RHS size: {terms: 27, types: 43, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
      Bounded f) =>
     Bounded (a, b, c, d, e, f)
[GblId[DFunId],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQnw)
             (@ b_aQnx)
             (@ c_aQny)
             (@ d_aQnz)
             (@ e_aQnA)
             (@ f_aQnB)
             (v_B1 :: Bounded a_aQnw)
             (v1_B2 :: Bounded b_aQnx)
             (v2_B3 :: Bounded c_aQny)
             (v3_B4 :: Bounded d_aQnz)
             (v4_B5 :: Bounded e_aQnA)
             (v5_B6 :: Bounded f_aQnB) ->
       GHC.Enum.C:Bounded TYPE: (a_aQnw, b_aQnx, c_aQny, d_aQnz, e_aQnA,
                                 f_aQnB)
                          GHC.Enum.$fBounded(,,,,,)_$cminBound
                            @ a_aQnw
                            @ b_aQnx
                            @ c_aQny
                            @ d_aQnz
                            @ e_aQnA
                            @ f_aQnB
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                          GHC.Enum.$fBounded(,,,,,)_$cmaxBound
                            @ a_aQnw
                            @ b_aQnx
                            @ c_aQny
                            @ d_aQnz
                            @ e_aQnA
                            @ f_aQnB
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6]
GHC.Enum.$fBounded(,,,,,)
  = \ (@ a_aReL)
      (@ b_aReM)
      (@ c_aReN)
      (@ d_aReO)
      (@ e_aReP)
      (@ f_aReQ)
      ($dBounded_aReR :: Bounded a_aReL)
      ($dBounded1_aReS :: Bounded b_aReM)
      ($dBounded2_aReT :: Bounded c_aReN)
      ($dBounded3_aReU :: Bounded d_aReO)
      ($dBounded4_aReV :: Bounded e_aReP)
      ($dBounded5_aReW :: Bounded f_aReQ) ->
      GHC.Enum.C:Bounded
        @ (a_aReL, b_aReM, c_aReN, d_aReO, e_aReP, f_aReQ)
        (GHC.Enum.$fBounded(,,,,,)_$cminBound
           @ a_aReL
           @ b_aReM
           @ c_aReN
           @ d_aReO
           @ e_aReP
           @ f_aReQ
           $dBounded_aReR
           $dBounded1_aReS
           $dBounded2_aReT
           $dBounded3_aReU
           $dBounded4_aReV
           $dBounded5_aReW)
        (GHC.Enum.$fBounded(,,,,,)_$cmaxBound
           @ a_aReL
           @ b_aReM
           @ c_aReN
           @ d_aReO
           @ e_aReP
           @ f_aReQ
           $dBounded_aReR
           $dBounded1_aReS
           $dBounded2_aReT
           $dBounded3_aReU
           $dBounded4_aReV
           $dBounded5_aReW)

-- RHS size: {terms: 29, types: 42, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,)_$cmaxBound [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f g.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g) =>
     (a, b, c, d, e, f, g)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sTBz)
                 (@ b_sTBA)
                 (@ c_sTBB)
                 (@ d_sTBC)
                 (@ e_sTBD)
                 (@ f_sTBE)
                 (@ g_sTBF)
                 (w_sTBG [Occ=Once] :: Bounded a_sTBz)
                 (w1_sTBH [Occ=Once] :: Bounded b_sTBA)
                 (w2_sTBI [Occ=Once] :: Bounded c_sTBB)
                 (w3_sTBJ [Occ=Once] :: Bounded d_sTBC)
                 (w4_sTBK [Occ=Once] :: Bounded e_sTBD)
                 (w5_sTBL [Occ=Once] :: Bounded f_sTBE)
                 (w6_sTBM [Occ=Once] :: Bounded g_sTBF) ->
                 (maxBound @ a_sTBz w_sTBG, maxBound @ b_sTBA w1_sTBH,
                  maxBound @ c_sTBB w2_sTBI, maxBound @ d_sTBC w3_sTBJ,
                  maxBound @ e_sTBD w4_sTBK, maxBound @ f_sTBE w5_sTBL,
                  maxBound @ g_sTBF w6_sTBM)}]
GHC.Enum.$fBounded(,,,,,,)_$cmaxBound
  = \ (@ a_sTBz)
      (@ b_sTBA)
      (@ c_sTBB)
      (@ d_sTBC)
      (@ e_sTBD)
      (@ f_sTBE)
      (@ g_sTBF)
      (w_sTBG :: Bounded a_sTBz)
      (w1_sTBH :: Bounded b_sTBA)
      (w2_sTBI :: Bounded c_sTBB)
      (w3_sTBJ :: Bounded d_sTBC)
      (w4_sTBK :: Bounded e_sTBD)
      (w5_sTBL :: Bounded f_sTBE)
      (w6_sTBM :: Bounded g_sTBF) ->
      (maxBound @ a_sTBz w_sTBG, maxBound @ b_sTBA w1_sTBH,
       maxBound @ c_sTBB w2_sTBI, maxBound @ d_sTBC w3_sTBJ,
       maxBound @ e_sTBD w4_sTBK, maxBound @ f_sTBE w5_sTBL,
       maxBound @ g_sTBF w6_sTBM)

-- RHS size: {terms: 29, types: 42, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,)_$cminBound [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f g.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g) =>
     (a, b, c, d, e, f, g)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sTBR)
                 (@ b_sTBS)
                 (@ c_sTBT)
                 (@ d_sTBU)
                 (@ e_sTBV)
                 (@ f_sTBW)
                 (@ g_sTBX)
                 (w_sTBY [Occ=Once] :: Bounded a_sTBR)
                 (w1_sTBZ [Occ=Once] :: Bounded b_sTBS)
                 (w2_sTC0 [Occ=Once] :: Bounded c_sTBT)
                 (w3_sTC1 [Occ=Once] :: Bounded d_sTBU)
                 (w4_sTC2 [Occ=Once] :: Bounded e_sTBV)
                 (w5_sTC3 [Occ=Once] :: Bounded f_sTBW)
                 (w6_sTC4 [Occ=Once] :: Bounded g_sTBX) ->
                 (minBound @ a_sTBR w_sTBY, minBound @ b_sTBS w1_sTBZ,
                  minBound @ c_sTBT w2_sTC0, minBound @ d_sTBU w3_sTC1,
                  minBound @ e_sTBV w4_sTC2, minBound @ f_sTBW w5_sTC3,
                  minBound @ g_sTBX w6_sTC4)}]
GHC.Enum.$fBounded(,,,,,,)_$cminBound
  = \ (@ a_sTBR)
      (@ b_sTBS)
      (@ c_sTBT)
      (@ d_sTBU)
      (@ e_sTBV)
      (@ f_sTBW)
      (@ g_sTBX)
      (w_sTBY :: Bounded a_sTBR)
      (w1_sTBZ :: Bounded b_sTBS)
      (w2_sTC0 :: Bounded c_sTBT)
      (w3_sTC1 :: Bounded d_sTBU)
      (w4_sTC2 :: Bounded e_sTBV)
      (w5_sTC3 :: Bounded f_sTBW)
      (w6_sTC4 :: Bounded g_sTBX) ->
      (minBound @ a_sTBR w_sTBY, minBound @ b_sTBS w1_sTBZ,
       minBound @ c_sTBT w2_sTC0, minBound @ d_sTBU w3_sTC1,
       minBound @ e_sTBV w4_sTC2, minBound @ f_sTBW w5_sTC3,
       minBound @ g_sTBX w6_sTC4)

-- RHS size: {terms: 31, types: 50, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f g.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g) =>
     Bounded (a, b, c, d, e, f, g)
[GblId[DFunId],
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQnp)
             (@ b_aQnq)
             (@ c_aQnr)
             (@ d_aQns)
             (@ e_aQnt)
             (@ f_aQnu)
             (@ g_aQnv)
             (v_B1 :: Bounded a_aQnp)
             (v1_B2 :: Bounded b_aQnq)
             (v2_B3 :: Bounded c_aQnr)
             (v3_B4 :: Bounded d_aQns)
             (v4_B5 :: Bounded e_aQnt)
             (v5_B6 :: Bounded f_aQnu)
             (v6_B7 :: Bounded g_aQnv) ->
       GHC.Enum.C:Bounded TYPE: (a_aQnp, b_aQnq, c_aQnr, d_aQns, e_aQnt,
                                 f_aQnu, g_aQnv)
                          GHC.Enum.$fBounded(,,,,,,)_$cminBound
                            @ a_aQnp
                            @ b_aQnq
                            @ c_aQnr
                            @ d_aQns
                            @ e_aQnt
                            @ f_aQnu
                            @ g_aQnv
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                          GHC.Enum.$fBounded(,,,,,,)_$cmaxBound
                            @ a_aQnp
                            @ b_aQnq
                            @ c_aQnr
                            @ d_aQns
                            @ e_aQnt
                            @ f_aQnu
                            @ g_aQnv
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7]
GHC.Enum.$fBounded(,,,,,,)
  = \ (@ a_aRdH)
      (@ b_aRdI)
      (@ c_aRdJ)
      (@ d_aRdK)
      (@ e_aRdL)
      (@ f_aRdM)
      (@ g_aRdN)
      ($dBounded_aRdO :: Bounded a_aRdH)
      ($dBounded1_aRdP :: Bounded b_aRdI)
      ($dBounded2_aRdQ :: Bounded c_aRdJ)
      ($dBounded3_aRdR :: Bounded d_aRdK)
      ($dBounded4_aRdS :: Bounded e_aRdL)
      ($dBounded5_aRdT :: Bounded f_aRdM)
      ($dBounded6_aRdU :: Bounded g_aRdN) ->
      GHC.Enum.C:Bounded
        @ (a_aRdH, b_aRdI, c_aRdJ, d_aRdK, e_aRdL, f_aRdM, g_aRdN)
        (GHC.Enum.$fBounded(,,,,,,)_$cminBound
           @ a_aRdH
           @ b_aRdI
           @ c_aRdJ
           @ d_aRdK
           @ e_aRdL
           @ f_aRdM
           @ g_aRdN
           $dBounded_aRdO
           $dBounded1_aRdP
           $dBounded2_aRdQ
           $dBounded3_aRdR
           $dBounded4_aRdS
           $dBounded5_aRdT
           $dBounded6_aRdU)
        (GHC.Enum.$fBounded(,,,,,,)_$cmaxBound
           @ a_aRdH
           @ b_aRdI
           @ c_aRdJ
           @ d_aRdK
           @ e_aRdL
           @ f_aRdM
           @ g_aRdN
           $dBounded_aRdO
           $dBounded1_aRdP
           $dBounded2_aRdQ
           $dBounded3_aRdR
           $dBounded4_aRdS
           $dBounded5_aRdT
           $dBounded6_aRdU)

-- RHS size: {terms: 33, types: 48, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,)_$cmaxBound [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f g h.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h) =>
     (a, b, c, d, e, f, g, h)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sTC9)
                 (@ b_sTCa)
                 (@ c_sTCb)
                 (@ d_sTCc)
                 (@ e_sTCd)
                 (@ f_sTCe)
                 (@ g_sTCf)
                 (@ h_sTCg)
                 (w_sTCh [Occ=Once] :: Bounded a_sTC9)
                 (w1_sTCi [Occ=Once] :: Bounded b_sTCa)
                 (w2_sTCj [Occ=Once] :: Bounded c_sTCb)
                 (w3_sTCk [Occ=Once] :: Bounded d_sTCc)
                 (w4_sTCl [Occ=Once] :: Bounded e_sTCd)
                 (w5_sTCm [Occ=Once] :: Bounded f_sTCe)
                 (w6_sTCn [Occ=Once] :: Bounded g_sTCf)
                 (w7_sTCo [Occ=Once] :: Bounded h_sTCg) ->
                 (maxBound @ a_sTC9 w_sTCh, maxBound @ b_sTCa w1_sTCi,
                  maxBound @ c_sTCb w2_sTCj, maxBound @ d_sTCc w3_sTCk,
                  maxBound @ e_sTCd w4_sTCl, maxBound @ f_sTCe w5_sTCm,
                  maxBound @ g_sTCf w6_sTCn, maxBound @ h_sTCg w7_sTCo)}]
GHC.Enum.$fBounded(,,,,,,,)_$cmaxBound
  = \ (@ a_sTC9)
      (@ b_sTCa)
      (@ c_sTCb)
      (@ d_sTCc)
      (@ e_sTCd)
      (@ f_sTCe)
      (@ g_sTCf)
      (@ h_sTCg)
      (w_sTCh :: Bounded a_sTC9)
      (w1_sTCi :: Bounded b_sTCa)
      (w2_sTCj :: Bounded c_sTCb)
      (w3_sTCk :: Bounded d_sTCc)
      (w4_sTCl :: Bounded e_sTCd)
      (w5_sTCm :: Bounded f_sTCe)
      (w6_sTCn :: Bounded g_sTCf)
      (w7_sTCo :: Bounded h_sTCg) ->
      (maxBound @ a_sTC9 w_sTCh, maxBound @ b_sTCa w1_sTCi,
       maxBound @ c_sTCb w2_sTCj, maxBound @ d_sTCc w3_sTCk,
       maxBound @ e_sTCd w4_sTCl, maxBound @ f_sTCe w5_sTCm,
       maxBound @ g_sTCf w6_sTCn, maxBound @ h_sTCg w7_sTCo)

-- RHS size: {terms: 33, types: 48, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,)_$cminBound [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f g h.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h) =>
     (a, b, c, d, e, f, g, h)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sTCt)
                 (@ b_sTCu)
                 (@ c_sTCv)
                 (@ d_sTCw)
                 (@ e_sTCx)
                 (@ f_sTCy)
                 (@ g_sTCz)
                 (@ h_sTCA)
                 (w_sTCB [Occ=Once] :: Bounded a_sTCt)
                 (w1_sTCC [Occ=Once] :: Bounded b_sTCu)
                 (w2_sTCD [Occ=Once] :: Bounded c_sTCv)
                 (w3_sTCE [Occ=Once] :: Bounded d_sTCw)
                 (w4_sTCF [Occ=Once] :: Bounded e_sTCx)
                 (w5_sTCG [Occ=Once] :: Bounded f_sTCy)
                 (w6_sTCH [Occ=Once] :: Bounded g_sTCz)
                 (w7_sTCI [Occ=Once] :: Bounded h_sTCA) ->
                 (minBound @ a_sTCt w_sTCB, minBound @ b_sTCu w1_sTCC,
                  minBound @ c_sTCv w2_sTCD, minBound @ d_sTCw w3_sTCE,
                  minBound @ e_sTCx w4_sTCF, minBound @ f_sTCy w5_sTCG,
                  minBound @ g_sTCz w6_sTCH, minBound @ h_sTCA w7_sTCI)}]
GHC.Enum.$fBounded(,,,,,,,)_$cminBound
  = \ (@ a_sTCt)
      (@ b_sTCu)
      (@ c_sTCv)
      (@ d_sTCw)
      (@ e_sTCx)
      (@ f_sTCy)
      (@ g_sTCz)
      (@ h_sTCA)
      (w_sTCB :: Bounded a_sTCt)
      (w1_sTCC :: Bounded b_sTCu)
      (w2_sTCD :: Bounded c_sTCv)
      (w3_sTCE :: Bounded d_sTCw)
      (w4_sTCF :: Bounded e_sTCx)
      (w5_sTCG :: Bounded f_sTCy)
      (w6_sTCH :: Bounded g_sTCz)
      (w7_sTCI :: Bounded h_sTCA) ->
      (minBound @ a_sTCt w_sTCB, minBound @ b_sTCu w1_sTCC,
       minBound @ c_sTCv w2_sTCD, minBound @ d_sTCw w3_sTCE,
       minBound @ e_sTCx w4_sTCF, minBound @ f_sTCy w5_sTCG,
       minBound @ g_sTCz w6_sTCH, minBound @ h_sTCA w7_sTCI)

-- RHS size: {terms: 35, types: 57, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f g h.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h) =>
     Bounded (a, b, c, d, e, f, g, h)
[GblId[DFunId],
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQnh)
             (@ b_aQni)
             (@ c_aQnj)
             (@ d_aQnk)
             (@ e_aQnl)
             (@ f_aQnm)
             (@ g_aQnn)
             (@ h_aQno)
             (v_B1 :: Bounded a_aQnh)
             (v1_B2 :: Bounded b_aQni)
             (v2_B3 :: Bounded c_aQnj)
             (v3_B4 :: Bounded d_aQnk)
             (v4_B5 :: Bounded e_aQnl)
             (v5_B6 :: Bounded f_aQnm)
             (v6_B7 :: Bounded g_aQnn)
             (v7_B8 :: Bounded h_aQno) ->
       GHC.Enum.C:Bounded TYPE: (a_aQnh, b_aQni, c_aQnj, d_aQnk, e_aQnl,
                                 f_aQnm, g_aQnn, h_aQno)
                          GHC.Enum.$fBounded(,,,,,,,)_$cminBound
                            @ a_aQnh
                            @ b_aQni
                            @ c_aQnj
                            @ d_aQnk
                            @ e_aQnl
                            @ f_aQnm
                            @ g_aQnn
                            @ h_aQno
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                          GHC.Enum.$fBounded(,,,,,,,)_$cmaxBound
                            @ a_aQnh
                            @ b_aQni
                            @ c_aQnj
                            @ d_aQnk
                            @ e_aQnl
                            @ f_aQnm
                            @ g_aQnn
                            @ h_aQno
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8]
GHC.Enum.$fBounded(,,,,,,,)
  = \ (@ a_aRcv)
      (@ b_aRcw)
      (@ c_aRcx)
      (@ d_aRcy)
      (@ e_aRcz)
      (@ f_aRcA)
      (@ g_aRcB)
      (@ h_aRcC)
      ($dBounded_aRcD :: Bounded a_aRcv)
      ($dBounded1_aRcE :: Bounded b_aRcw)
      ($dBounded2_aRcF :: Bounded c_aRcx)
      ($dBounded3_aRcG :: Bounded d_aRcy)
      ($dBounded4_aRcH :: Bounded e_aRcz)
      ($dBounded5_aRcI :: Bounded f_aRcA)
      ($dBounded6_aRcJ :: Bounded g_aRcB)
      ($dBounded7_aRcK :: Bounded h_aRcC) ->
      GHC.Enum.C:Bounded
        @ (a_aRcv, b_aRcw, c_aRcx, d_aRcy, e_aRcz, f_aRcA, g_aRcB, h_aRcC)
        (GHC.Enum.$fBounded(,,,,,,,)_$cminBound
           @ a_aRcv
           @ b_aRcw
           @ c_aRcx
           @ d_aRcy
           @ e_aRcz
           @ f_aRcA
           @ g_aRcB
           @ h_aRcC
           $dBounded_aRcD
           $dBounded1_aRcE
           $dBounded2_aRcF
           $dBounded3_aRcG
           $dBounded4_aRcH
           $dBounded5_aRcI
           $dBounded6_aRcJ
           $dBounded7_aRcK)
        (GHC.Enum.$fBounded(,,,,,,,)_$cmaxBound
           @ a_aRcv
           @ b_aRcw
           @ c_aRcx
           @ d_aRcy
           @ e_aRcz
           @ f_aRcA
           @ g_aRcB
           @ h_aRcC
           $dBounded_aRcD
           $dBounded1_aRcE
           $dBounded2_aRcF
           $dBounded3_aRcG
           $dBounded4_aRcH
           $dBounded5_aRcI
           $dBounded6_aRcJ
           $dBounded7_aRcK)

-- RHS size: {terms: 37, types: 54, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,)_$cmaxBound [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f g h i.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i) =>
     (a, b, c, d, e, f, g, h, i)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sTCN)
                 (@ b_sTCO)
                 (@ c_sTCP)
                 (@ d_sTCQ)
                 (@ e_sTCR)
                 (@ f_sTCS)
                 (@ g_sTCT)
                 (@ h_sTCU)
                 (@ i_sTCV)
                 (w_sTCW [Occ=Once] :: Bounded a_sTCN)
                 (w1_sTCX [Occ=Once] :: Bounded b_sTCO)
                 (w2_sTCY [Occ=Once] :: Bounded c_sTCP)
                 (w3_sTCZ [Occ=Once] :: Bounded d_sTCQ)
                 (w4_sTD0 [Occ=Once] :: Bounded e_sTCR)
                 (w5_sTD1 [Occ=Once] :: Bounded f_sTCS)
                 (w6_sTD2 [Occ=Once] :: Bounded g_sTCT)
                 (w7_sTD3 [Occ=Once] :: Bounded h_sTCU)
                 (w8_sTD4 [Occ=Once] :: Bounded i_sTCV) ->
                 (maxBound @ a_sTCN w_sTCW, maxBound @ b_sTCO w1_sTCX,
                  maxBound @ c_sTCP w2_sTCY, maxBound @ d_sTCQ w3_sTCZ,
                  maxBound @ e_sTCR w4_sTD0, maxBound @ f_sTCS w5_sTD1,
                  maxBound @ g_sTCT w6_sTD2, maxBound @ h_sTCU w7_sTD3,
                  maxBound @ i_sTCV w8_sTD4)}]
GHC.Enum.$fBounded(,,,,,,,,)_$cmaxBound
  = \ (@ a_sTCN)
      (@ b_sTCO)
      (@ c_sTCP)
      (@ d_sTCQ)
      (@ e_sTCR)
      (@ f_sTCS)
      (@ g_sTCT)
      (@ h_sTCU)
      (@ i_sTCV)
      (w_sTCW :: Bounded a_sTCN)
      (w1_sTCX :: Bounded b_sTCO)
      (w2_sTCY :: Bounded c_sTCP)
      (w3_sTCZ :: Bounded d_sTCQ)
      (w4_sTD0 :: Bounded e_sTCR)
      (w5_sTD1 :: Bounded f_sTCS)
      (w6_sTD2 :: Bounded g_sTCT)
      (w7_sTD3 :: Bounded h_sTCU)
      (w8_sTD4 :: Bounded i_sTCV) ->
      (maxBound @ a_sTCN w_sTCW, maxBound @ b_sTCO w1_sTCX,
       maxBound @ c_sTCP w2_sTCY, maxBound @ d_sTCQ w3_sTCZ,
       maxBound @ e_sTCR w4_sTD0, maxBound @ f_sTCS w5_sTD1,
       maxBound @ g_sTCT w6_sTD2, maxBound @ h_sTCU w7_sTD3,
       maxBound @ i_sTCV w8_sTD4)

-- RHS size: {terms: 37, types: 54, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,)_$cminBound [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f g h i.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i) =>
     (a, b, c, d, e, f, g, h, i)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sTD9)
                 (@ b_sTDa)
                 (@ c_sTDb)
                 (@ d_sTDc)
                 (@ e_sTDd)
                 (@ f_sTDe)
                 (@ g_sTDf)
                 (@ h_sTDg)
                 (@ i_sTDh)
                 (w_sTDi [Occ=Once] :: Bounded a_sTD9)
                 (w1_sTDj [Occ=Once] :: Bounded b_sTDa)
                 (w2_sTDk [Occ=Once] :: Bounded c_sTDb)
                 (w3_sTDl [Occ=Once] :: Bounded d_sTDc)
                 (w4_sTDm [Occ=Once] :: Bounded e_sTDd)
                 (w5_sTDn [Occ=Once] :: Bounded f_sTDe)
                 (w6_sTDo [Occ=Once] :: Bounded g_sTDf)
                 (w7_sTDp [Occ=Once] :: Bounded h_sTDg)
                 (w8_sTDq [Occ=Once] :: Bounded i_sTDh) ->
                 (minBound @ a_sTD9 w_sTDi, minBound @ b_sTDa w1_sTDj,
                  minBound @ c_sTDb w2_sTDk, minBound @ d_sTDc w3_sTDl,
                  minBound @ e_sTDd w4_sTDm, minBound @ f_sTDe w5_sTDn,
                  minBound @ g_sTDf w6_sTDo, minBound @ h_sTDg w7_sTDp,
                  minBound @ i_sTDh w8_sTDq)}]
GHC.Enum.$fBounded(,,,,,,,,)_$cminBound
  = \ (@ a_sTD9)
      (@ b_sTDa)
      (@ c_sTDb)
      (@ d_sTDc)
      (@ e_sTDd)
      (@ f_sTDe)
      (@ g_sTDf)
      (@ h_sTDg)
      (@ i_sTDh)
      (w_sTDi :: Bounded a_sTD9)
      (w1_sTDj :: Bounded b_sTDa)
      (w2_sTDk :: Bounded c_sTDb)
      (w3_sTDl :: Bounded d_sTDc)
      (w4_sTDm :: Bounded e_sTDd)
      (w5_sTDn :: Bounded f_sTDe)
      (w6_sTDo :: Bounded g_sTDf)
      (w7_sTDp :: Bounded h_sTDg)
      (w8_sTDq :: Bounded i_sTDh) ->
      (minBound @ a_sTD9 w_sTDi, minBound @ b_sTDa w1_sTDj,
       minBound @ c_sTDb w2_sTDk, minBound @ d_sTDc w3_sTDl,
       minBound @ e_sTDd w4_sTDm, minBound @ f_sTDe w5_sTDn,
       minBound @ g_sTDf w6_sTDo, minBound @ h_sTDg w7_sTDp,
       minBound @ i_sTDh w8_sTDq)

-- RHS size: {terms: 39, types: 64, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f g h i.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i) =>
     Bounded (a, b, c, d, e, f, g, h, i)
[GblId[DFunId],
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQn8)
             (@ b_aQn9)
             (@ c_aQna)
             (@ d_aQnb)
             (@ e_aQnc)
             (@ f_aQnd)
             (@ g_aQne)
             (@ h_aQnf)
             (@ i_aQng)
             (v_B1 :: Bounded a_aQn8)
             (v1_B2 :: Bounded b_aQn9)
             (v2_B3 :: Bounded c_aQna)
             (v3_B4 :: Bounded d_aQnb)
             (v4_B5 :: Bounded e_aQnc)
             (v5_B6 :: Bounded f_aQnd)
             (v6_B7 :: Bounded g_aQne)
             (v7_B8 :: Bounded h_aQnf)
             (v8_B9 :: Bounded i_aQng) ->
       GHC.Enum.C:Bounded TYPE: (a_aQn8, b_aQn9, c_aQna, d_aQnb, e_aQnc,
                                 f_aQnd, g_aQne, h_aQnf, i_aQng)
                          GHC.Enum.$fBounded(,,,,,,,,)_$cminBound
                            @ a_aQn8
                            @ b_aQn9
                            @ c_aQna
                            @ d_aQnb
                            @ e_aQnc
                            @ f_aQnd
                            @ g_aQne
                            @ h_aQnf
                            @ i_aQng
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                          GHC.Enum.$fBounded(,,,,,,,,)_$cmaxBound
                            @ a_aQn8
                            @ b_aQn9
                            @ c_aQna
                            @ d_aQnb
                            @ e_aQnc
                            @ f_aQnd
                            @ g_aQne
                            @ h_aQnf
                            @ i_aQng
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9]
GHC.Enum.$fBounded(,,,,,,,,)
  = \ (@ a_aRbb)
      (@ b_aRbc)
      (@ c_aRbd)
      (@ d_aRbe)
      (@ e_aRbf)
      (@ f_aRbg)
      (@ g_aRbh)
      (@ h_aRbi)
      (@ i_aRbj)
      ($dBounded_aRbk :: Bounded a_aRbb)
      ($dBounded1_aRbl :: Bounded b_aRbc)
      ($dBounded2_aRbm :: Bounded c_aRbd)
      ($dBounded3_aRbn :: Bounded d_aRbe)
      ($dBounded4_aRbo :: Bounded e_aRbf)
      ($dBounded5_aRbp :: Bounded f_aRbg)
      ($dBounded6_aRbq :: Bounded g_aRbh)
      ($dBounded7_aRbr :: Bounded h_aRbi)
      ($dBounded8_aRbs :: Bounded i_aRbj) ->
      GHC.Enum.C:Bounded
        @ (a_aRbb, b_aRbc, c_aRbd, d_aRbe, e_aRbf, f_aRbg, g_aRbh, h_aRbi,
           i_aRbj)
        (GHC.Enum.$fBounded(,,,,,,,,)_$cminBound
           @ a_aRbb
           @ b_aRbc
           @ c_aRbd
           @ d_aRbe
           @ e_aRbf
           @ f_aRbg
           @ g_aRbh
           @ h_aRbi
           @ i_aRbj
           $dBounded_aRbk
           $dBounded1_aRbl
           $dBounded2_aRbm
           $dBounded3_aRbn
           $dBounded4_aRbo
           $dBounded5_aRbp
           $dBounded6_aRbq
           $dBounded7_aRbr
           $dBounded8_aRbs)
        (GHC.Enum.$fBounded(,,,,,,,,)_$cmaxBound
           @ a_aRbb
           @ b_aRbc
           @ c_aRbd
           @ d_aRbe
           @ e_aRbf
           @ f_aRbg
           @ g_aRbh
           @ h_aRbi
           @ i_aRbj
           $dBounded_aRbk
           $dBounded1_aRbl
           $dBounded2_aRbm
           $dBounded3_aRbn
           $dBounded4_aRbo
           $dBounded5_aRbp
           $dBounded6_aRbq
           $dBounded7_aRbr
           $dBounded8_aRbs)

-- RHS size: {terms: 41, types: 60, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,)_$cmaxBound [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f g h i j.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j) =>
     (a, b, c, d, e, f, g, h, i, j)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=10,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sTDv)
                 (@ b_sTDw)
                 (@ c_sTDx)
                 (@ d_sTDy)
                 (@ e_sTDz)
                 (@ f_sTDA)
                 (@ g_sTDB)
                 (@ h_sTDC)
                 (@ i_sTDD)
                 (@ j_sTDE)
                 (w_sTDF [Occ=Once] :: Bounded a_sTDv)
                 (w1_sTDG [Occ=Once] :: Bounded b_sTDw)
                 (w2_sTDH [Occ=Once] :: Bounded c_sTDx)
                 (w3_sTDI [Occ=Once] :: Bounded d_sTDy)
                 (w4_sTDJ [Occ=Once] :: Bounded e_sTDz)
                 (w5_sTDK [Occ=Once] :: Bounded f_sTDA)
                 (w6_sTDL [Occ=Once] :: Bounded g_sTDB)
                 (w7_sTDM [Occ=Once] :: Bounded h_sTDC)
                 (w8_sTDN [Occ=Once] :: Bounded i_sTDD)
                 (w9_sTDO [Occ=Once] :: Bounded j_sTDE) ->
                 (maxBound @ a_sTDv w_sTDF, maxBound @ b_sTDw w1_sTDG,
                  maxBound @ c_sTDx w2_sTDH, maxBound @ d_sTDy w3_sTDI,
                  maxBound @ e_sTDz w4_sTDJ, maxBound @ f_sTDA w5_sTDK,
                  maxBound @ g_sTDB w6_sTDL, maxBound @ h_sTDC w7_sTDM,
                  maxBound @ i_sTDD w8_sTDN, maxBound @ j_sTDE w9_sTDO)}]
GHC.Enum.$fBounded(,,,,,,,,,)_$cmaxBound
  = \ (@ a_sTDv)
      (@ b_sTDw)
      (@ c_sTDx)
      (@ d_sTDy)
      (@ e_sTDz)
      (@ f_sTDA)
      (@ g_sTDB)
      (@ h_sTDC)
      (@ i_sTDD)
      (@ j_sTDE)
      (w_sTDF :: Bounded a_sTDv)
      (w1_sTDG :: Bounded b_sTDw)
      (w2_sTDH :: Bounded c_sTDx)
      (w3_sTDI :: Bounded d_sTDy)
      (w4_sTDJ :: Bounded e_sTDz)
      (w5_sTDK :: Bounded f_sTDA)
      (w6_sTDL :: Bounded g_sTDB)
      (w7_sTDM :: Bounded h_sTDC)
      (w8_sTDN :: Bounded i_sTDD)
      (w9_sTDO :: Bounded j_sTDE) ->
      (maxBound @ a_sTDv w_sTDF, maxBound @ b_sTDw w1_sTDG,
       maxBound @ c_sTDx w2_sTDH, maxBound @ d_sTDy w3_sTDI,
       maxBound @ e_sTDz w4_sTDJ, maxBound @ f_sTDA w5_sTDK,
       maxBound @ g_sTDB w6_sTDL, maxBound @ h_sTDC w7_sTDM,
       maxBound @ i_sTDD w8_sTDN, maxBound @ j_sTDE w9_sTDO)

-- RHS size: {terms: 41, types: 60, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,)_$cminBound [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f g h i j.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j) =>
     (a, b, c, d, e, f, g, h, i, j)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=10,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sTDT)
                 (@ b_sTDU)
                 (@ c_sTDV)
                 (@ d_sTDW)
                 (@ e_sTDX)
                 (@ f_sTDY)
                 (@ g_sTDZ)
                 (@ h_sTE0)
                 (@ i_sTE1)
                 (@ j_sTE2)
                 (w_sTE3 [Occ=Once] :: Bounded a_sTDT)
                 (w1_sTE4 [Occ=Once] :: Bounded b_sTDU)
                 (w2_sTE5 [Occ=Once] :: Bounded c_sTDV)
                 (w3_sTE6 [Occ=Once] :: Bounded d_sTDW)
                 (w4_sTE7 [Occ=Once] :: Bounded e_sTDX)
                 (w5_sTE8 [Occ=Once] :: Bounded f_sTDY)
                 (w6_sTE9 [Occ=Once] :: Bounded g_sTDZ)
                 (w7_sTEa [Occ=Once] :: Bounded h_sTE0)
                 (w8_sTEb [Occ=Once] :: Bounded i_sTE1)
                 (w9_sTEc [Occ=Once] :: Bounded j_sTE2) ->
                 (minBound @ a_sTDT w_sTE3, minBound @ b_sTDU w1_sTE4,
                  minBound @ c_sTDV w2_sTE5, minBound @ d_sTDW w3_sTE6,
                  minBound @ e_sTDX w4_sTE7, minBound @ f_sTDY w5_sTE8,
                  minBound @ g_sTDZ w6_sTE9, minBound @ h_sTE0 w7_sTEa,
                  minBound @ i_sTE1 w8_sTEb, minBound @ j_sTE2 w9_sTEc)}]
GHC.Enum.$fBounded(,,,,,,,,,)_$cminBound
  = \ (@ a_sTDT)
      (@ b_sTDU)
      (@ c_sTDV)
      (@ d_sTDW)
      (@ e_sTDX)
      (@ f_sTDY)
      (@ g_sTDZ)
      (@ h_sTE0)
      (@ i_sTE1)
      (@ j_sTE2)
      (w_sTE3 :: Bounded a_sTDT)
      (w1_sTE4 :: Bounded b_sTDU)
      (w2_sTE5 :: Bounded c_sTDV)
      (w3_sTE6 :: Bounded d_sTDW)
      (w4_sTE7 :: Bounded e_sTDX)
      (w5_sTE8 :: Bounded f_sTDY)
      (w6_sTE9 :: Bounded g_sTDZ)
      (w7_sTEa :: Bounded h_sTE0)
      (w8_sTEb :: Bounded i_sTE1)
      (w9_sTEc :: Bounded j_sTE2) ->
      (minBound @ a_sTDT w_sTE3, minBound @ b_sTDU w1_sTE4,
       minBound @ c_sTDV w2_sTE5, minBound @ d_sTDW w3_sTE6,
       minBound @ e_sTDX w4_sTE7, minBound @ f_sTDY w5_sTE8,
       minBound @ g_sTDZ w6_sTE9, minBound @ h_sTE0 w7_sTEa,
       minBound @ i_sTE1 w8_sTEb, minBound @ j_sTE2 w9_sTEc)

-- RHS size: {terms: 43, types: 71, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f g h i j.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j) =>
     Bounded (a, b, c, d, e, f, g, h, i, j)
[GblId[DFunId],
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQmY)
             (@ b_aQmZ)
             (@ c_aQn0)
             (@ d_aQn1)
             (@ e_aQn2)
             (@ f_aQn3)
             (@ g_aQn4)
             (@ h_aQn5)
             (@ i_aQn6)
             (@ j_aQn7)
             (v_B1 :: Bounded a_aQmY)
             (v1_B2 :: Bounded b_aQmZ)
             (v2_B3 :: Bounded c_aQn0)
             (v3_B4 :: Bounded d_aQn1)
             (v4_B5 :: Bounded e_aQn2)
             (v5_B6 :: Bounded f_aQn3)
             (v6_B7 :: Bounded g_aQn4)
             (v7_B8 :: Bounded h_aQn5)
             (v8_B9 :: Bounded i_aQn6)
             (v9_Ba :: Bounded j_aQn7) ->
       GHC.Enum.C:Bounded TYPE: (a_aQmY, b_aQmZ, c_aQn0, d_aQn1, e_aQn2,
                                 f_aQn3, g_aQn4, h_aQn5, i_aQn6, j_aQn7)
                          GHC.Enum.$fBounded(,,,,,,,,,)_$cminBound
                            @ a_aQmY
                            @ b_aQmZ
                            @ c_aQn0
                            @ d_aQn1
                            @ e_aQn2
                            @ f_aQn3
                            @ g_aQn4
                            @ h_aQn5
                            @ i_aQn6
                            @ j_aQn7
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                          GHC.Enum.$fBounded(,,,,,,,,,)_$cmaxBound
                            @ a_aQmY
                            @ b_aQmZ
                            @ c_aQn0
                            @ d_aQn1
                            @ e_aQn2
                            @ f_aQn3
                            @ g_aQn4
                            @ h_aQn5
                            @ i_aQn6
                            @ j_aQn7
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba]
GHC.Enum.$fBounded(,,,,,,,,,)
  = \ (@ a_aR9J)
      (@ b_aR9K)
      (@ c_aR9L)
      (@ d_aR9M)
      (@ e_aR9N)
      (@ f_aR9O)
      (@ g_aR9P)
      (@ h_aR9Q)
      (@ i_aR9R)
      (@ j_aR9S)
      ($dBounded_aR9T :: Bounded a_aR9J)
      ($dBounded1_aR9U :: Bounded b_aR9K)
      ($dBounded2_aR9V :: Bounded c_aR9L)
      ($dBounded3_aR9W :: Bounded d_aR9M)
      ($dBounded4_aR9X :: Bounded e_aR9N)
      ($dBounded5_aR9Y :: Bounded f_aR9O)
      ($dBounded6_aR9Z :: Bounded g_aR9P)
      ($dBounded7_aRa0 :: Bounded h_aR9Q)
      ($dBounded8_aRa1 :: Bounded i_aR9R)
      ($dBounded9_aRa2 :: Bounded j_aR9S) ->
      GHC.Enum.C:Bounded
        @ (a_aR9J, b_aR9K, c_aR9L, d_aR9M, e_aR9N, f_aR9O, g_aR9P, h_aR9Q,
           i_aR9R, j_aR9S)
        (GHC.Enum.$fBounded(,,,,,,,,,)_$cminBound
           @ a_aR9J
           @ b_aR9K
           @ c_aR9L
           @ d_aR9M
           @ e_aR9N
           @ f_aR9O
           @ g_aR9P
           @ h_aR9Q
           @ i_aR9R
           @ j_aR9S
           $dBounded_aR9T
           $dBounded1_aR9U
           $dBounded2_aR9V
           $dBounded3_aR9W
           $dBounded4_aR9X
           $dBounded5_aR9Y
           $dBounded6_aR9Z
           $dBounded7_aRa0
           $dBounded8_aRa1
           $dBounded9_aRa2)
        (GHC.Enum.$fBounded(,,,,,,,,,)_$cmaxBound
           @ a_aR9J
           @ b_aR9K
           @ c_aR9L
           @ d_aR9M
           @ e_aR9N
           @ f_aR9O
           @ g_aR9P
           @ h_aR9Q
           @ i_aR9R
           @ j_aR9S
           $dBounded_aR9T
           $dBounded1_aR9U
           $dBounded2_aR9V
           $dBounded3_aR9W
           $dBounded4_aR9X
           $dBounded5_aR9Y
           $dBounded6_aR9Z
           $dBounded7_aRa0
           $dBounded8_aRa1
           $dBounded9_aRa2)

-- RHS size: {terms: 45, types: 66, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,)_$cmaxBound
  :: forall a b c d e f g h i j k.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k) =>
     (a, b, c, d, e, f, g, h, i, j, k)
[GblId,
 Arity=11,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30 30 30 30 30] 230 120}]
GHC.Enum.$fBounded(,,,,,,,,,,)_$cmaxBound
  = \ (@ a_aR89)
      (@ b_aR8a)
      (@ c_aR8b)
      (@ d_aR8c)
      (@ e_aR8d)
      (@ f_aR8e)
      (@ g_aR8f)
      (@ h_aR8g)
      (@ i_aR8h)
      (@ j_aR8i)
      (@ k_aR8j)
      ($dBounded_aR8k :: Bounded a_aR89)
      ($dBounded1_aR8l :: Bounded b_aR8a)
      ($dBounded2_aR8m :: Bounded c_aR8b)
      ($dBounded3_aR8n :: Bounded d_aR8c)
      ($dBounded4_aR8o :: Bounded e_aR8d)
      ($dBounded5_aR8p :: Bounded f_aR8e)
      ($dBounded6_aR8q :: Bounded g_aR8f)
      ($dBounded7_aR8r :: Bounded h_aR8g)
      ($dBounded8_aR8s :: Bounded i_aR8h)
      ($dBounded9_aR8t :: Bounded j_aR8i)
      ($dBounded10_aR8u :: Bounded k_aR8j) ->
      (maxBound @ a_aR89 $dBounded_aR8k,
       maxBound @ b_aR8a $dBounded1_aR8l,
       maxBound @ c_aR8b $dBounded2_aR8m,
       maxBound @ d_aR8c $dBounded3_aR8n,
       maxBound @ e_aR8d $dBounded4_aR8o,
       maxBound @ f_aR8e $dBounded5_aR8p,
       maxBound @ g_aR8f $dBounded6_aR8q,
       maxBound @ h_aR8g $dBounded7_aR8r,
       maxBound @ i_aR8h $dBounded8_aR8s,
       maxBound @ j_aR8i $dBounded9_aR8t,
       maxBound @ k_aR8j $dBounded10_aR8u)

-- RHS size: {terms: 45, types: 66, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,)_$cminBound
  :: forall a b c d e f g h i j k.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k) =>
     (a, b, c, d, e, f, g, h, i, j, k)
[GblId,
 Arity=11,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30 30 30 30 30] 230 120}]
GHC.Enum.$fBounded(,,,,,,,,,,)_$cminBound
  = \ (@ a_aR89)
      (@ b_aR8a)
      (@ c_aR8b)
      (@ d_aR8c)
      (@ e_aR8d)
      (@ f_aR8e)
      (@ g_aR8f)
      (@ h_aR8g)
      (@ i_aR8h)
      (@ j_aR8i)
      (@ k_aR8j)
      ($dBounded_aR8k :: Bounded a_aR89)
      ($dBounded1_aR8l :: Bounded b_aR8a)
      ($dBounded2_aR8m :: Bounded c_aR8b)
      ($dBounded3_aR8n :: Bounded d_aR8c)
      ($dBounded4_aR8o :: Bounded e_aR8d)
      ($dBounded5_aR8p :: Bounded f_aR8e)
      ($dBounded6_aR8q :: Bounded g_aR8f)
      ($dBounded7_aR8r :: Bounded h_aR8g)
      ($dBounded8_aR8s :: Bounded i_aR8h)
      ($dBounded9_aR8t :: Bounded j_aR8i)
      ($dBounded10_aR8u :: Bounded k_aR8j) ->
      (minBound @ a_aR89 $dBounded_aR8k,
       minBound @ b_aR8a $dBounded1_aR8l,
       minBound @ c_aR8b $dBounded2_aR8m,
       minBound @ d_aR8c $dBounded3_aR8n,
       minBound @ e_aR8d $dBounded4_aR8o,
       minBound @ f_aR8e $dBounded5_aR8p,
       minBound @ g_aR8f $dBounded6_aR8q,
       minBound @ h_aR8g $dBounded7_aR8r,
       minBound @ i_aR8h $dBounded8_aR8s,
       minBound @ j_aR8i $dBounded9_aR8t,
       minBound @ k_aR8j $dBounded10_aR8u)

-- RHS size: {terms: 47, types: 78, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f g h i j k.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k) =>
     Bounded (a, b, c, d, e, f, g, h, i, j, k)
[GblId[DFunId],
 Arity=11,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQmN)
             (@ b_aQmO)
             (@ c_aQmP)
             (@ d_aQmQ)
             (@ e_aQmR)
             (@ f_aQmS)
             (@ g_aQmT)
             (@ h_aQmU)
             (@ i_aQmV)
             (@ j_aQmW)
             (@ k_aQmX)
             (v_B1 :: Bounded a_aQmN)
             (v1_B2 :: Bounded b_aQmO)
             (v2_B3 :: Bounded c_aQmP)
             (v3_B4 :: Bounded d_aQmQ)
             (v4_B5 :: Bounded e_aQmR)
             (v5_B6 :: Bounded f_aQmS)
             (v6_B7 :: Bounded g_aQmT)
             (v7_B8 :: Bounded h_aQmU)
             (v8_B9 :: Bounded i_aQmV)
             (v9_Ba :: Bounded j_aQmW)
             (v10_Bb :: Bounded k_aQmX) ->
       GHC.Enum.C:Bounded TYPE: (a_aQmN, b_aQmO, c_aQmP, d_aQmQ, e_aQmR,
                                 f_aQmS, g_aQmT, h_aQmU, i_aQmV, j_aQmW, k_aQmX)
                          GHC.Enum.$fBounded(,,,,,,,,,,)_$cminBound
                            @ a_aQmN
                            @ b_aQmO
                            @ c_aQmP
                            @ d_aQmQ
                            @ e_aQmR
                            @ f_aQmS
                            @ g_aQmT
                            @ h_aQmU
                            @ i_aQmV
                            @ j_aQmW
                            @ k_aQmX
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                            v10_Bb
                          GHC.Enum.$fBounded(,,,,,,,,,,)_$cmaxBound
                            @ a_aQmN
                            @ b_aQmO
                            @ c_aQmP
                            @ d_aQmQ
                            @ e_aQmR
                            @ f_aQmS
                            @ g_aQmT
                            @ h_aQmU
                            @ i_aQmV
                            @ j_aQmW
                            @ k_aQmX
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                            v10_Bb]
GHC.Enum.$fBounded(,,,,,,,,,,)
  = \ (@ a_aR89)
      (@ b_aR8a)
      (@ c_aR8b)
      (@ d_aR8c)
      (@ e_aR8d)
      (@ f_aR8e)
      (@ g_aR8f)
      (@ h_aR8g)
      (@ i_aR8h)
      (@ j_aR8i)
      (@ k_aR8j)
      ($dBounded_aR8k :: Bounded a_aR89)
      ($dBounded1_aR8l :: Bounded b_aR8a)
      ($dBounded2_aR8m :: Bounded c_aR8b)
      ($dBounded3_aR8n :: Bounded d_aR8c)
      ($dBounded4_aR8o :: Bounded e_aR8d)
      ($dBounded5_aR8p :: Bounded f_aR8e)
      ($dBounded6_aR8q :: Bounded g_aR8f)
      ($dBounded7_aR8r :: Bounded h_aR8g)
      ($dBounded8_aR8s :: Bounded i_aR8h)
      ($dBounded9_aR8t :: Bounded j_aR8i)
      ($dBounded10_aR8u :: Bounded k_aR8j) ->
      GHC.Enum.C:Bounded
        @ (a_aR89, b_aR8a, c_aR8b, d_aR8c, e_aR8d, f_aR8e, g_aR8f, h_aR8g,
           i_aR8h, j_aR8i, k_aR8j)
        (GHC.Enum.$fBounded(,,,,,,,,,,)_$cminBound
           @ a_aR89
           @ b_aR8a
           @ c_aR8b
           @ d_aR8c
           @ e_aR8d
           @ f_aR8e
           @ g_aR8f
           @ h_aR8g
           @ i_aR8h
           @ j_aR8i
           @ k_aR8j
           $dBounded_aR8k
           $dBounded1_aR8l
           $dBounded2_aR8m
           $dBounded3_aR8n
           $dBounded4_aR8o
           $dBounded5_aR8p
           $dBounded6_aR8q
           $dBounded7_aR8r
           $dBounded8_aR8s
           $dBounded9_aR8t
           $dBounded10_aR8u)
        (GHC.Enum.$fBounded(,,,,,,,,,,)_$cmaxBound
           @ a_aR89
           @ b_aR8a
           @ c_aR8b
           @ d_aR8c
           @ e_aR8d
           @ f_aR8e
           @ g_aR8f
           @ h_aR8g
           @ i_aR8h
           @ j_aR8i
           @ k_aR8j
           $dBounded_aR8k
           $dBounded1_aR8l
           $dBounded2_aR8m
           $dBounded3_aR8n
           $dBounded4_aR8o
           $dBounded5_aR8p
           $dBounded6_aR8q
           $dBounded7_aR8r
           $dBounded8_aR8s
           $dBounded9_aR8t
           $dBounded10_aR8u)

-- RHS size: {terms: 49, types: 72, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,)_$cmaxBound
  :: forall a b c d e f g h i j k l.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
      Bounded l) =>
     (a, b, c, d, e, f, g, h, i, j, k, l)
[GblId,
 Arity=12,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30 30 30 30 30 30] 250 130}]
GHC.Enum.$fBounded(,,,,,,,,,,,)_$cmaxBound
  = \ (@ a_aR6r)
      (@ b_aR6s)
      (@ c_aR6t)
      (@ d_aR6u)
      (@ e_aR6v)
      (@ f_aR6w)
      (@ g_aR6x)
      (@ h_aR6y)
      (@ i_aR6z)
      (@ j_aR6A)
      (@ k_aR6B)
      (@ l_aR6C)
      ($dBounded_aR6D :: Bounded a_aR6r)
      ($dBounded1_aR6E :: Bounded b_aR6s)
      ($dBounded2_aR6F :: Bounded c_aR6t)
      ($dBounded3_aR6G :: Bounded d_aR6u)
      ($dBounded4_aR6H :: Bounded e_aR6v)
      ($dBounded5_aR6I :: Bounded f_aR6w)
      ($dBounded6_aR6J :: Bounded g_aR6x)
      ($dBounded7_aR6K :: Bounded h_aR6y)
      ($dBounded8_aR6L :: Bounded i_aR6z)
      ($dBounded9_aR6M :: Bounded j_aR6A)
      ($dBounded10_aR6N :: Bounded k_aR6B)
      ($dBounded11_aR6O :: Bounded l_aR6C) ->
      (maxBound @ a_aR6r $dBounded_aR6D,
       maxBound @ b_aR6s $dBounded1_aR6E,
       maxBound @ c_aR6t $dBounded2_aR6F,
       maxBound @ d_aR6u $dBounded3_aR6G,
       maxBound @ e_aR6v $dBounded4_aR6H,
       maxBound @ f_aR6w $dBounded5_aR6I,
       maxBound @ g_aR6x $dBounded6_aR6J,
       maxBound @ h_aR6y $dBounded7_aR6K,
       maxBound @ i_aR6z $dBounded8_aR6L,
       maxBound @ j_aR6A $dBounded9_aR6M,
       maxBound @ k_aR6B $dBounded10_aR6N,
       maxBound @ l_aR6C $dBounded11_aR6O)

-- RHS size: {terms: 49, types: 72, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,)_$cminBound
  :: forall a b c d e f g h i j k l.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
      Bounded l) =>
     (a, b, c, d, e, f, g, h, i, j, k, l)
[GblId,
 Arity=12,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30 30 30 30 30 30] 250 130}]
GHC.Enum.$fBounded(,,,,,,,,,,,)_$cminBound
  = \ (@ a_aR6r)
      (@ b_aR6s)
      (@ c_aR6t)
      (@ d_aR6u)
      (@ e_aR6v)
      (@ f_aR6w)
      (@ g_aR6x)
      (@ h_aR6y)
      (@ i_aR6z)
      (@ j_aR6A)
      (@ k_aR6B)
      (@ l_aR6C)
      ($dBounded_aR6D :: Bounded a_aR6r)
      ($dBounded1_aR6E :: Bounded b_aR6s)
      ($dBounded2_aR6F :: Bounded c_aR6t)
      ($dBounded3_aR6G :: Bounded d_aR6u)
      ($dBounded4_aR6H :: Bounded e_aR6v)
      ($dBounded5_aR6I :: Bounded f_aR6w)
      ($dBounded6_aR6J :: Bounded g_aR6x)
      ($dBounded7_aR6K :: Bounded h_aR6y)
      ($dBounded8_aR6L :: Bounded i_aR6z)
      ($dBounded9_aR6M :: Bounded j_aR6A)
      ($dBounded10_aR6N :: Bounded k_aR6B)
      ($dBounded11_aR6O :: Bounded l_aR6C) ->
      (minBound @ a_aR6r $dBounded_aR6D,
       minBound @ b_aR6s $dBounded1_aR6E,
       minBound @ c_aR6t $dBounded2_aR6F,
       minBound @ d_aR6u $dBounded3_aR6G,
       minBound @ e_aR6v $dBounded4_aR6H,
       minBound @ f_aR6w $dBounded5_aR6I,
       minBound @ g_aR6x $dBounded6_aR6J,
       minBound @ h_aR6y $dBounded7_aR6K,
       minBound @ i_aR6z $dBounded8_aR6L,
       minBound @ j_aR6A $dBounded9_aR6M,
       minBound @ k_aR6B $dBounded10_aR6N,
       minBound @ l_aR6C $dBounded11_aR6O)

-- RHS size: {terms: 51, types: 85, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f g h i j k l.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
      Bounded l) =>
     Bounded (a, b, c, d, e, f, g, h, i, j, k, l)
[GblId[DFunId],
 Arity=12,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQmB)
             (@ b_aQmC)
             (@ c_aQmD)
             (@ d_aQmE)
             (@ e_aQmF)
             (@ f_aQmG)
             (@ g_aQmH)
             (@ h_aQmI)
             (@ i_aQmJ)
             (@ j_aQmK)
             (@ k_aQmL)
             (@ l_aQmM)
             (v_B1 :: Bounded a_aQmB)
             (v1_B2 :: Bounded b_aQmC)
             (v2_B3 :: Bounded c_aQmD)
             (v3_B4 :: Bounded d_aQmE)
             (v4_B5 :: Bounded e_aQmF)
             (v5_B6 :: Bounded f_aQmG)
             (v6_B7 :: Bounded g_aQmH)
             (v7_B8 :: Bounded h_aQmI)
             (v8_B9 :: Bounded i_aQmJ)
             (v9_Ba :: Bounded j_aQmK)
             (v10_Bb :: Bounded k_aQmL)
             (v11_Bc :: Bounded l_aQmM) ->
       GHC.Enum.C:Bounded TYPE: (a_aQmB, b_aQmC, c_aQmD, d_aQmE, e_aQmF,
                                 f_aQmG, g_aQmH, h_aQmI, i_aQmJ, j_aQmK, k_aQmL, l_aQmM)
                          GHC.Enum.$fBounded(,,,,,,,,,,,)_$cminBound
                            @ a_aQmB
                            @ b_aQmC
                            @ c_aQmD
                            @ d_aQmE
                            @ e_aQmF
                            @ f_aQmG
                            @ g_aQmH
                            @ h_aQmI
                            @ i_aQmJ
                            @ j_aQmK
                            @ k_aQmL
                            @ l_aQmM
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                            v10_Bb
                            v11_Bc
                          GHC.Enum.$fBounded(,,,,,,,,,,,)_$cmaxBound
                            @ a_aQmB
                            @ b_aQmC
                            @ c_aQmD
                            @ d_aQmE
                            @ e_aQmF
                            @ f_aQmG
                            @ g_aQmH
                            @ h_aQmI
                            @ i_aQmJ
                            @ j_aQmK
                            @ k_aQmL
                            @ l_aQmM
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                            v10_Bb
                            v11_Bc]
GHC.Enum.$fBounded(,,,,,,,,,,,)
  = \ (@ a_aR6r)
      (@ b_aR6s)
      (@ c_aR6t)
      (@ d_aR6u)
      (@ e_aR6v)
      (@ f_aR6w)
      (@ g_aR6x)
      (@ h_aR6y)
      (@ i_aR6z)
      (@ j_aR6A)
      (@ k_aR6B)
      (@ l_aR6C)
      ($dBounded_aR6D :: Bounded a_aR6r)
      ($dBounded1_aR6E :: Bounded b_aR6s)
      ($dBounded2_aR6F :: Bounded c_aR6t)
      ($dBounded3_aR6G :: Bounded d_aR6u)
      ($dBounded4_aR6H :: Bounded e_aR6v)
      ($dBounded5_aR6I :: Bounded f_aR6w)
      ($dBounded6_aR6J :: Bounded g_aR6x)
      ($dBounded7_aR6K :: Bounded h_aR6y)
      ($dBounded8_aR6L :: Bounded i_aR6z)
      ($dBounded9_aR6M :: Bounded j_aR6A)
      ($dBounded10_aR6N :: Bounded k_aR6B)
      ($dBounded11_aR6O :: Bounded l_aR6C) ->
      GHC.Enum.C:Bounded
        @ (a_aR6r, b_aR6s, c_aR6t, d_aR6u, e_aR6v, f_aR6w, g_aR6x, h_aR6y,
           i_aR6z, j_aR6A, k_aR6B, l_aR6C)
        (GHC.Enum.$fBounded(,,,,,,,,,,,)_$cminBound
           @ a_aR6r
           @ b_aR6s
           @ c_aR6t
           @ d_aR6u
           @ e_aR6v
           @ f_aR6w
           @ g_aR6x
           @ h_aR6y
           @ i_aR6z
           @ j_aR6A
           @ k_aR6B
           @ l_aR6C
           $dBounded_aR6D
           $dBounded1_aR6E
           $dBounded2_aR6F
           $dBounded3_aR6G
           $dBounded4_aR6H
           $dBounded5_aR6I
           $dBounded6_aR6J
           $dBounded7_aR6K
           $dBounded8_aR6L
           $dBounded9_aR6M
           $dBounded10_aR6N
           $dBounded11_aR6O)
        (GHC.Enum.$fBounded(,,,,,,,,,,,)_$cmaxBound
           @ a_aR6r
           @ b_aR6s
           @ c_aR6t
           @ d_aR6u
           @ e_aR6v
           @ f_aR6w
           @ g_aR6x
           @ h_aR6y
           @ i_aR6z
           @ j_aR6A
           @ k_aR6B
           @ l_aR6C
           $dBounded_aR6D
           $dBounded1_aR6E
           $dBounded2_aR6F
           $dBounded3_aR6G
           $dBounded4_aR6H
           $dBounded5_aR6I
           $dBounded6_aR6J
           $dBounded7_aR6K
           $dBounded8_aR6L
           $dBounded9_aR6M
           $dBounded10_aR6N
           $dBounded11_aR6O)

-- RHS size: {terms: 53, types: 78, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,,)_$cmaxBound
  :: forall a b c d e f g h i j k l m.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l,
      Bounded m) =>
     (a, b, c, d, e, f, g, h, i, j, k, l, m)
[GblId,
 Arity=13,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30 30 30 30 30 30 30] 270 140}]
GHC.Enum.$fBounded(,,,,,,,,,,,,)_$cmaxBound
  = \ (@ a_aR4B)
      (@ b_aR4C)
      (@ c_aR4D)
      (@ d_aR4E)
      (@ e_aR4F)
      (@ f_aR4G)
      (@ g_aR4H)
      (@ h_aR4I)
      (@ i_aR4J)
      (@ j_aR4K)
      (@ k_aR4L)
      (@ l_aR4M)
      (@ m_aR4N)
      ($dBounded_aR4O :: Bounded a_aR4B)
      ($dBounded1_aR4P :: Bounded b_aR4C)
      ($dBounded2_aR4Q :: Bounded c_aR4D)
      ($dBounded3_aR4R :: Bounded d_aR4E)
      ($dBounded4_aR4S :: Bounded e_aR4F)
      ($dBounded5_aR4T :: Bounded f_aR4G)
      ($dBounded6_aR4U :: Bounded g_aR4H)
      ($dBounded7_aR4V :: Bounded h_aR4I)
      ($dBounded8_aR4W :: Bounded i_aR4J)
      ($dBounded9_aR4X :: Bounded j_aR4K)
      ($dBounded10_aR4Y :: Bounded k_aR4L)
      ($dBounded11_aR4Z :: Bounded l_aR4M)
      ($dBounded12_aR50 :: Bounded m_aR4N) ->
      (maxBound @ a_aR4B $dBounded_aR4O,
       maxBound @ b_aR4C $dBounded1_aR4P,
       maxBound @ c_aR4D $dBounded2_aR4Q,
       maxBound @ d_aR4E $dBounded3_aR4R,
       maxBound @ e_aR4F $dBounded4_aR4S,
       maxBound @ f_aR4G $dBounded5_aR4T,
       maxBound @ g_aR4H $dBounded6_aR4U,
       maxBound @ h_aR4I $dBounded7_aR4V,
       maxBound @ i_aR4J $dBounded8_aR4W,
       maxBound @ j_aR4K $dBounded9_aR4X,
       maxBound @ k_aR4L $dBounded10_aR4Y,
       maxBound @ l_aR4M $dBounded11_aR4Z,
       maxBound @ m_aR4N $dBounded12_aR50)

-- RHS size: {terms: 53, types: 78, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,,)_$cminBound
  :: forall a b c d e f g h i j k l m.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l,
      Bounded m) =>
     (a, b, c, d, e, f, g, h, i, j, k, l, m)
[GblId,
 Arity=13,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30 30 30 30 30 30 30] 270 140}]
GHC.Enum.$fBounded(,,,,,,,,,,,,)_$cminBound
  = \ (@ a_aR4B)
      (@ b_aR4C)
      (@ c_aR4D)
      (@ d_aR4E)
      (@ e_aR4F)
      (@ f_aR4G)
      (@ g_aR4H)
      (@ h_aR4I)
      (@ i_aR4J)
      (@ j_aR4K)
      (@ k_aR4L)
      (@ l_aR4M)
      (@ m_aR4N)
      ($dBounded_aR4O :: Bounded a_aR4B)
      ($dBounded1_aR4P :: Bounded b_aR4C)
      ($dBounded2_aR4Q :: Bounded c_aR4D)
      ($dBounded3_aR4R :: Bounded d_aR4E)
      ($dBounded4_aR4S :: Bounded e_aR4F)
      ($dBounded5_aR4T :: Bounded f_aR4G)
      ($dBounded6_aR4U :: Bounded g_aR4H)
      ($dBounded7_aR4V :: Bounded h_aR4I)
      ($dBounded8_aR4W :: Bounded i_aR4J)
      ($dBounded9_aR4X :: Bounded j_aR4K)
      ($dBounded10_aR4Y :: Bounded k_aR4L)
      ($dBounded11_aR4Z :: Bounded l_aR4M)
      ($dBounded12_aR50 :: Bounded m_aR4N) ->
      (minBound @ a_aR4B $dBounded_aR4O,
       minBound @ b_aR4C $dBounded1_aR4P,
       minBound @ c_aR4D $dBounded2_aR4Q,
       minBound @ d_aR4E $dBounded3_aR4R,
       minBound @ e_aR4F $dBounded4_aR4S,
       minBound @ f_aR4G $dBounded5_aR4T,
       minBound @ g_aR4H $dBounded6_aR4U,
       minBound @ h_aR4I $dBounded7_aR4V,
       minBound @ i_aR4J $dBounded8_aR4W,
       minBound @ j_aR4K $dBounded9_aR4X,
       minBound @ k_aR4L $dBounded10_aR4Y,
       minBound @ l_aR4M $dBounded11_aR4Z,
       minBound @ m_aR4N $dBounded12_aR50)

-- RHS size: {terms: 55, types: 92, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f g h i j k l m.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l,
      Bounded m) =>
     Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m)
[GblId[DFunId],
 Arity=13,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQmo)
             (@ b_aQmp)
             (@ c_aQmq)
             (@ d_aQmr)
             (@ e_aQms)
             (@ f_aQmt)
             (@ g_aQmu)
             (@ h_aQmv)
             (@ i_aQmw)
             (@ j_aQmx)
             (@ k_aQmy)
             (@ l_aQmz)
             (@ m_aQmA)
             (v_B1 :: Bounded a_aQmo)
             (v1_B2 :: Bounded b_aQmp)
             (v2_B3 :: Bounded c_aQmq)
             (v3_B4 :: Bounded d_aQmr)
             (v4_B5 :: Bounded e_aQms)
             (v5_B6 :: Bounded f_aQmt)
             (v6_B7 :: Bounded g_aQmu)
             (v7_B8 :: Bounded h_aQmv)
             (v8_B9 :: Bounded i_aQmw)
             (v9_Ba :: Bounded j_aQmx)
             (v10_Bb :: Bounded k_aQmy)
             (v11_Bc :: Bounded l_aQmz)
             (v12_Bd :: Bounded m_aQmA) ->
       GHC.Enum.C:Bounded TYPE: (a_aQmo, b_aQmp, c_aQmq, d_aQmr, e_aQms,
                                 f_aQmt, g_aQmu, h_aQmv, i_aQmw, j_aQmx, k_aQmy, l_aQmz, m_aQmA)
                          GHC.Enum.$fBounded(,,,,,,,,,,,,)_$cminBound
                            @ a_aQmo
                            @ b_aQmp
                            @ c_aQmq
                            @ d_aQmr
                            @ e_aQms
                            @ f_aQmt
                            @ g_aQmu
                            @ h_aQmv
                            @ i_aQmw
                            @ j_aQmx
                            @ k_aQmy
                            @ l_aQmz
                            @ m_aQmA
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                            v10_Bb
                            v11_Bc
                            v12_Bd
                          GHC.Enum.$fBounded(,,,,,,,,,,,,)_$cmaxBound
                            @ a_aQmo
                            @ b_aQmp
                            @ c_aQmq
                            @ d_aQmr
                            @ e_aQms
                            @ f_aQmt
                            @ g_aQmu
                            @ h_aQmv
                            @ i_aQmw
                            @ j_aQmx
                            @ k_aQmy
                            @ l_aQmz
                            @ m_aQmA
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                            v10_Bb
                            v11_Bc
                            v12_Bd]
GHC.Enum.$fBounded(,,,,,,,,,,,,)
  = \ (@ a_aR4B)
      (@ b_aR4C)
      (@ c_aR4D)
      (@ d_aR4E)
      (@ e_aR4F)
      (@ f_aR4G)
      (@ g_aR4H)
      (@ h_aR4I)
      (@ i_aR4J)
      (@ j_aR4K)
      (@ k_aR4L)
      (@ l_aR4M)
      (@ m_aR4N)
      ($dBounded_aR4O :: Bounded a_aR4B)
      ($dBounded1_aR4P :: Bounded b_aR4C)
      ($dBounded2_aR4Q :: Bounded c_aR4D)
      ($dBounded3_aR4R :: Bounded d_aR4E)
      ($dBounded4_aR4S :: Bounded e_aR4F)
      ($dBounded5_aR4T :: Bounded f_aR4G)
      ($dBounded6_aR4U :: Bounded g_aR4H)
      ($dBounded7_aR4V :: Bounded h_aR4I)
      ($dBounded8_aR4W :: Bounded i_aR4J)
      ($dBounded9_aR4X :: Bounded j_aR4K)
      ($dBounded10_aR4Y :: Bounded k_aR4L)
      ($dBounded11_aR4Z :: Bounded l_aR4M)
      ($dBounded12_aR50 :: Bounded m_aR4N) ->
      GHC.Enum.C:Bounded
        @ (a_aR4B, b_aR4C, c_aR4D, d_aR4E, e_aR4F, f_aR4G, g_aR4H, h_aR4I,
           i_aR4J, j_aR4K, k_aR4L, l_aR4M, m_aR4N)
        (GHC.Enum.$fBounded(,,,,,,,,,,,,)_$cminBound
           @ a_aR4B
           @ b_aR4C
           @ c_aR4D
           @ d_aR4E
           @ e_aR4F
           @ f_aR4G
           @ g_aR4H
           @ h_aR4I
           @ i_aR4J
           @ j_aR4K
           @ k_aR4L
           @ l_aR4M
           @ m_aR4N
           $dBounded_aR4O
           $dBounded1_aR4P
           $dBounded2_aR4Q
           $dBounded3_aR4R
           $dBounded4_aR4S
           $dBounded5_aR4T
           $dBounded6_aR4U
           $dBounded7_aR4V
           $dBounded8_aR4W
           $dBounded9_aR4X
           $dBounded10_aR4Y
           $dBounded11_aR4Z
           $dBounded12_aR50)
        (GHC.Enum.$fBounded(,,,,,,,,,,,,)_$cmaxBound
           @ a_aR4B
           @ b_aR4C
           @ c_aR4D
           @ d_aR4E
           @ e_aR4F
           @ f_aR4G
           @ g_aR4H
           @ h_aR4I
           @ i_aR4J
           @ j_aR4K
           @ k_aR4L
           @ l_aR4M
           @ m_aR4N
           $dBounded_aR4O
           $dBounded1_aR4P
           $dBounded2_aR4Q
           $dBounded3_aR4R
           $dBounded4_aR4S
           $dBounded5_aR4T
           $dBounded6_aR4U
           $dBounded7_aR4V
           $dBounded8_aR4W
           $dBounded9_aR4X
           $dBounded10_aR4Y
           $dBounded11_aR4Z
           $dBounded12_aR50)

-- RHS size: {terms: 57, types: 84, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,,,)_$cmaxBound
  :: forall a b c d e f g h i j k l m n.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l,
      Bounded m, Bounded n) =>
     (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
[GblId,
 Arity=14,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30 30 30 30 30 30 30 30] 290 150}]
GHC.Enum.$fBounded(,,,,,,,,,,,,,)_$cmaxBound
  = \ (@ a_aR2D)
      (@ b_aR2E)
      (@ c_aR2F)
      (@ d_aR2G)
      (@ e_aR2H)
      (@ f_aR2I)
      (@ g_aR2J)
      (@ h_aR2K)
      (@ i_aR2L)
      (@ j_aR2M)
      (@ k_aR2N)
      (@ l_aR2O)
      (@ m_aR2P)
      (@ n_aR2Q)
      ($dBounded_aR2R :: Bounded a_aR2D)
      ($dBounded1_aR2S :: Bounded b_aR2E)
      ($dBounded2_aR2T :: Bounded c_aR2F)
      ($dBounded3_aR2U :: Bounded d_aR2G)
      ($dBounded4_aR2V :: Bounded e_aR2H)
      ($dBounded5_aR2W :: Bounded f_aR2I)
      ($dBounded6_aR2X :: Bounded g_aR2J)
      ($dBounded7_aR2Y :: Bounded h_aR2K)
      ($dBounded8_aR2Z :: Bounded i_aR2L)
      ($dBounded9_aR30 :: Bounded j_aR2M)
      ($dBounded10_aR31 :: Bounded k_aR2N)
      ($dBounded11_aR32 :: Bounded l_aR2O)
      ($dBounded12_aR33 :: Bounded m_aR2P)
      ($dBounded13_aR34 :: Bounded n_aR2Q) ->
      (maxBound @ a_aR2D $dBounded_aR2R,
       maxBound @ b_aR2E $dBounded1_aR2S,
       maxBound @ c_aR2F $dBounded2_aR2T,
       maxBound @ d_aR2G $dBounded3_aR2U,
       maxBound @ e_aR2H $dBounded4_aR2V,
       maxBound @ f_aR2I $dBounded5_aR2W,
       maxBound @ g_aR2J $dBounded6_aR2X,
       maxBound @ h_aR2K $dBounded7_aR2Y,
       maxBound @ i_aR2L $dBounded8_aR2Z,
       maxBound @ j_aR2M $dBounded9_aR30,
       maxBound @ k_aR2N $dBounded10_aR31,
       maxBound @ l_aR2O $dBounded11_aR32,
       maxBound @ m_aR2P $dBounded12_aR33,
       maxBound @ n_aR2Q $dBounded13_aR34)

-- RHS size: {terms: 57, types: 84, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,,,)_$cminBound
  :: forall a b c d e f g h i j k l m n.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l,
      Bounded m, Bounded n) =>
     (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
[GblId,
 Arity=14,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30 30 30 30 30 30 30 30] 290 150}]
GHC.Enum.$fBounded(,,,,,,,,,,,,,)_$cminBound
  = \ (@ a_aR2D)
      (@ b_aR2E)
      (@ c_aR2F)
      (@ d_aR2G)
      (@ e_aR2H)
      (@ f_aR2I)
      (@ g_aR2J)
      (@ h_aR2K)
      (@ i_aR2L)
      (@ j_aR2M)
      (@ k_aR2N)
      (@ l_aR2O)
      (@ m_aR2P)
      (@ n_aR2Q)
      ($dBounded_aR2R :: Bounded a_aR2D)
      ($dBounded1_aR2S :: Bounded b_aR2E)
      ($dBounded2_aR2T :: Bounded c_aR2F)
      ($dBounded3_aR2U :: Bounded d_aR2G)
      ($dBounded4_aR2V :: Bounded e_aR2H)
      ($dBounded5_aR2W :: Bounded f_aR2I)
      ($dBounded6_aR2X :: Bounded g_aR2J)
      ($dBounded7_aR2Y :: Bounded h_aR2K)
      ($dBounded8_aR2Z :: Bounded i_aR2L)
      ($dBounded9_aR30 :: Bounded j_aR2M)
      ($dBounded10_aR31 :: Bounded k_aR2N)
      ($dBounded11_aR32 :: Bounded l_aR2O)
      ($dBounded12_aR33 :: Bounded m_aR2P)
      ($dBounded13_aR34 :: Bounded n_aR2Q) ->
      (minBound @ a_aR2D $dBounded_aR2R,
       minBound @ b_aR2E $dBounded1_aR2S,
       minBound @ c_aR2F $dBounded2_aR2T,
       minBound @ d_aR2G $dBounded3_aR2U,
       minBound @ e_aR2H $dBounded4_aR2V,
       minBound @ f_aR2I $dBounded5_aR2W,
       minBound @ g_aR2J $dBounded6_aR2X,
       minBound @ h_aR2K $dBounded7_aR2Y,
       minBound @ i_aR2L $dBounded8_aR2Z,
       minBound @ j_aR2M $dBounded9_aR30,
       minBound @ k_aR2N $dBounded10_aR31,
       minBound @ l_aR2O $dBounded11_aR32,
       minBound @ m_aR2P $dBounded12_aR33,
       minBound @ n_aR2Q $dBounded13_aR34)

-- RHS size: {terms: 59, types: 99, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f g h i j k l m n.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l,
      Bounded m, Bounded n) =>
     Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
[GblId[DFunId],
 Arity=14,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQma)
             (@ b_aQmb)
             (@ c_aQmc)
             (@ d_aQmd)
             (@ e_aQme)
             (@ f_aQmf)
             (@ g_aQmg)
             (@ h_aQmh)
             (@ i_aQmi)
             (@ j_aQmj)
             (@ k_aQmk)
             (@ l_aQml)
             (@ m_aQmm)
             (@ n_aQmn)
             (v_B1 :: Bounded a_aQma)
             (v1_B2 :: Bounded b_aQmb)
             (v2_B3 :: Bounded c_aQmc)
             (v3_B4 :: Bounded d_aQmd)
             (v4_B5 :: Bounded e_aQme)
             (v5_B6 :: Bounded f_aQmf)
             (v6_B7 :: Bounded g_aQmg)
             (v7_B8 :: Bounded h_aQmh)
             (v8_B9 :: Bounded i_aQmi)
             (v9_Ba :: Bounded j_aQmj)
             (v10_Bb :: Bounded k_aQmk)
             (v11_Bc :: Bounded l_aQml)
             (v12_Bd :: Bounded m_aQmm)
             (v13_Be :: Bounded n_aQmn) ->
       GHC.Enum.C:Bounded TYPE: (a_aQma, b_aQmb, c_aQmc, d_aQmd, e_aQme,
                                 f_aQmf, g_aQmg, h_aQmh, i_aQmi, j_aQmj, k_aQmk, l_aQml, m_aQmm,
                                 n_aQmn)
                          GHC.Enum.$fBounded(,,,,,,,,,,,,,)_$cminBound
                            @ a_aQma
                            @ b_aQmb
                            @ c_aQmc
                            @ d_aQmd
                            @ e_aQme
                            @ f_aQmf
                            @ g_aQmg
                            @ h_aQmh
                            @ i_aQmi
                            @ j_aQmj
                            @ k_aQmk
                            @ l_aQml
                            @ m_aQmm
                            @ n_aQmn
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                            v10_Bb
                            v11_Bc
                            v12_Bd
                            v13_Be
                          GHC.Enum.$fBounded(,,,,,,,,,,,,,)_$cmaxBound
                            @ a_aQma
                            @ b_aQmb
                            @ c_aQmc
                            @ d_aQmd
                            @ e_aQme
                            @ f_aQmf
                            @ g_aQmg
                            @ h_aQmh
                            @ i_aQmi
                            @ j_aQmj
                            @ k_aQmk
                            @ l_aQml
                            @ m_aQmm
                            @ n_aQmn
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                            v10_Bb
                            v11_Bc
                            v12_Bd
                            v13_Be]
GHC.Enum.$fBounded(,,,,,,,,,,,,,)
  = \ (@ a_aR2D)
      (@ b_aR2E)
      (@ c_aR2F)
      (@ d_aR2G)
      (@ e_aR2H)
      (@ f_aR2I)
      (@ g_aR2J)
      (@ h_aR2K)
      (@ i_aR2L)
      (@ j_aR2M)
      (@ k_aR2N)
      (@ l_aR2O)
      (@ m_aR2P)
      (@ n_aR2Q)
      ($dBounded_aR2R :: Bounded a_aR2D)
      ($dBounded1_aR2S :: Bounded b_aR2E)
      ($dBounded2_aR2T :: Bounded c_aR2F)
      ($dBounded3_aR2U :: Bounded d_aR2G)
      ($dBounded4_aR2V :: Bounded e_aR2H)
      ($dBounded5_aR2W :: Bounded f_aR2I)
      ($dBounded6_aR2X :: Bounded g_aR2J)
      ($dBounded7_aR2Y :: Bounded h_aR2K)
      ($dBounded8_aR2Z :: Bounded i_aR2L)
      ($dBounded9_aR30 :: Bounded j_aR2M)
      ($dBounded10_aR31 :: Bounded k_aR2N)
      ($dBounded11_aR32 :: Bounded l_aR2O)
      ($dBounded12_aR33 :: Bounded m_aR2P)
      ($dBounded13_aR34 :: Bounded n_aR2Q) ->
      GHC.Enum.C:Bounded
        @ (a_aR2D, b_aR2E, c_aR2F, d_aR2G, e_aR2H, f_aR2I, g_aR2J, h_aR2K,
           i_aR2L, j_aR2M, k_aR2N, l_aR2O, m_aR2P, n_aR2Q)
        (GHC.Enum.$fBounded(,,,,,,,,,,,,,)_$cminBound
           @ a_aR2D
           @ b_aR2E
           @ c_aR2F
           @ d_aR2G
           @ e_aR2H
           @ f_aR2I
           @ g_aR2J
           @ h_aR2K
           @ i_aR2L
           @ j_aR2M
           @ k_aR2N
           @ l_aR2O
           @ m_aR2P
           @ n_aR2Q
           $dBounded_aR2R
           $dBounded1_aR2S
           $dBounded2_aR2T
           $dBounded3_aR2U
           $dBounded4_aR2V
           $dBounded5_aR2W
           $dBounded6_aR2X
           $dBounded7_aR2Y
           $dBounded8_aR2Z
           $dBounded9_aR30
           $dBounded10_aR31
           $dBounded11_aR32
           $dBounded12_aR33
           $dBounded13_aR34)
        (GHC.Enum.$fBounded(,,,,,,,,,,,,,)_$cmaxBound
           @ a_aR2D
           @ b_aR2E
           @ c_aR2F
           @ d_aR2G
           @ e_aR2H
           @ f_aR2I
           @ g_aR2J
           @ h_aR2K
           @ i_aR2L
           @ j_aR2M
           @ k_aR2N
           @ l_aR2O
           @ m_aR2P
           @ n_aR2Q
           $dBounded_aR2R
           $dBounded1_aR2S
           $dBounded2_aR2T
           $dBounded3_aR2U
           $dBounded4_aR2V
           $dBounded5_aR2W
           $dBounded6_aR2X
           $dBounded7_aR2Y
           $dBounded8_aR2Z
           $dBounded9_aR30
           $dBounded10_aR31
           $dBounded11_aR32
           $dBounded12_aR33
           $dBounded13_aR34)

-- RHS size: {terms: 61, types: 90, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,,,,)_$cmaxBound
  :: forall a b c d e f g h i j k l m n o.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l,
      Bounded m, Bounded n, Bounded o) =>
     (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
[GblId,
 Arity=15,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)><L,1*U(A,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30 30 30 30 30 30 30 30 30] 310 160}]
GHC.Enum.$fBounded(,,,,,,,,,,,,,,)_$cmaxBound
  = \ (@ a_aR0x)
      (@ b_aR0y)
      (@ c_aR0z)
      (@ d_aR0A)
      (@ e_aR0B)
      (@ f_aR0C)
      (@ g_aR0D)
      (@ h_aR0E)
      (@ i_aR0F)
      (@ j_aR0G)
      (@ k_aR0H)
      (@ l_aR0I)
      (@ m_aR0J)
      (@ n_aR0K)
      (@ o_aR0L)
      ($dBounded_aR0M :: Bounded a_aR0x)
      ($dBounded1_aR0N :: Bounded b_aR0y)
      ($dBounded2_aR0O :: Bounded c_aR0z)
      ($dBounded3_aR0P :: Bounded d_aR0A)
      ($dBounded4_aR0Q :: Bounded e_aR0B)
      ($dBounded5_aR0R :: Bounded f_aR0C)
      ($dBounded6_aR0S :: Bounded g_aR0D)
      ($dBounded7_aR0T :: Bounded h_aR0E)
      ($dBounded8_aR0U :: Bounded i_aR0F)
      ($dBounded9_aR0V :: Bounded j_aR0G)
      ($dBounded10_aR0W :: Bounded k_aR0H)
      ($dBounded11_aR0X :: Bounded l_aR0I)
      ($dBounded12_aR0Y :: Bounded m_aR0J)
      ($dBounded13_aR0Z :: Bounded n_aR0K)
      ($dBounded14_aR10 :: Bounded o_aR0L) ->
      (maxBound @ a_aR0x $dBounded_aR0M,
       maxBound @ b_aR0y $dBounded1_aR0N,
       maxBound @ c_aR0z $dBounded2_aR0O,
       maxBound @ d_aR0A $dBounded3_aR0P,
       maxBound @ e_aR0B $dBounded4_aR0Q,
       maxBound @ f_aR0C $dBounded5_aR0R,
       maxBound @ g_aR0D $dBounded6_aR0S,
       maxBound @ h_aR0E $dBounded7_aR0T,
       maxBound @ i_aR0F $dBounded8_aR0U,
       maxBound @ j_aR0G $dBounded9_aR0V,
       maxBound @ k_aR0H $dBounded10_aR0W,
       maxBound @ l_aR0I $dBounded11_aR0X,
       maxBound @ m_aR0J $dBounded12_aR0Y,
       maxBound @ n_aR0K $dBounded13_aR0Z,
       maxBound @ o_aR0L $dBounded14_aR10)

-- RHS size: {terms: 61, types: 90, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,,,,)_$cminBound
  :: forall a b c d e f g h i j k l m n o.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l,
      Bounded m, Bounded n, Bounded o) =>
     (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
[GblId,
 Arity=15,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30 30 30 30 30 30 30 30 30] 310 160}]
GHC.Enum.$fBounded(,,,,,,,,,,,,,,)_$cminBound
  = \ (@ a_aR0x)
      (@ b_aR0y)
      (@ c_aR0z)
      (@ d_aR0A)
      (@ e_aR0B)
      (@ f_aR0C)
      (@ g_aR0D)
      (@ h_aR0E)
      (@ i_aR0F)
      (@ j_aR0G)
      (@ k_aR0H)
      (@ l_aR0I)
      (@ m_aR0J)
      (@ n_aR0K)
      (@ o_aR0L)
      ($dBounded_aR0M :: Bounded a_aR0x)
      ($dBounded1_aR0N :: Bounded b_aR0y)
      ($dBounded2_aR0O :: Bounded c_aR0z)
      ($dBounded3_aR0P :: Bounded d_aR0A)
      ($dBounded4_aR0Q :: Bounded e_aR0B)
      ($dBounded5_aR0R :: Bounded f_aR0C)
      ($dBounded6_aR0S :: Bounded g_aR0D)
      ($dBounded7_aR0T :: Bounded h_aR0E)
      ($dBounded8_aR0U :: Bounded i_aR0F)
      ($dBounded9_aR0V :: Bounded j_aR0G)
      ($dBounded10_aR0W :: Bounded k_aR0H)
      ($dBounded11_aR0X :: Bounded l_aR0I)
      ($dBounded12_aR0Y :: Bounded m_aR0J)
      ($dBounded13_aR0Z :: Bounded n_aR0K)
      ($dBounded14_aR10 :: Bounded o_aR0L) ->
      (minBound @ a_aR0x $dBounded_aR0M,
       minBound @ b_aR0y $dBounded1_aR0N,
       minBound @ c_aR0z $dBounded2_aR0O,
       minBound @ d_aR0A $dBounded3_aR0P,
       minBound @ e_aR0B $dBounded4_aR0Q,
       minBound @ f_aR0C $dBounded5_aR0R,
       minBound @ g_aR0D $dBounded6_aR0S,
       minBound @ h_aR0E $dBounded7_aR0T,
       minBound @ i_aR0F $dBounded8_aR0U,
       minBound @ j_aR0G $dBounded9_aR0V,
       minBound @ k_aR0H $dBounded10_aR0W,
       minBound @ l_aR0I $dBounded11_aR0X,
       minBound @ m_aR0J $dBounded12_aR0Y,
       minBound @ n_aR0K $dBounded13_aR0Z,
       minBound @ o_aR0L $dBounded14_aR10)

-- RHS size: {terms: 63, types: 106, coercions: 0, joins: 0/0}
GHC.Enum.$fBounded(,,,,,,,,,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f g h i j k l m n o.
     (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f,
      Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l,
      Bounded m, Bounded n, Bounded o) =>
     Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
[GblId[DFunId],
 Arity=15,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_aQlV)
             (@ b_aQlW)
             (@ c_aQlX)
             (@ d_aQlY)
             (@ e_aQlZ)
             (@ f_aQm0)
             (@ g_aQm1)
             (@ h_aQm2)
             (@ i_aQm3)
             (@ j_aQm4)
             (@ k_aQm5)
             (@ l_aQm6)
             (@ m_aQm7)
             (@ n_aQm8)
             (@ o_aQm9)
             (v_B1 :: Bounded a_aQlV)
             (v1_B2 :: Bounded b_aQlW)
             (v2_B3 :: Bounded c_aQlX)
             (v3_B4 :: Bounded d_aQlY)
             (v4_B5 :: Bounded e_aQlZ)
             (v5_B6 :: Bounded f_aQm0)
             (v6_B7 :: Bounded g_aQm1)
             (v7_B8 :: Bounded h_aQm2)
             (v8_B9 :: Bounded i_aQm3)
             (v9_Ba :: Bounded j_aQm4)
             (v10_Bb :: Bounded k_aQm5)
             (v11_Bc :: Bounded l_aQm6)
             (v12_Bd :: Bounded m_aQm7)
             (v13_Be :: Bounded n_aQm8)
             (v14_Bf :: Bounded o_aQm9) ->
       GHC.Enum.C:Bounded TYPE: (a_aQlV, b_aQlW, c_aQlX, d_aQlY, e_aQlZ,
                                 f_aQm0, g_aQm1, h_aQm2, i_aQm3, j_aQm4, k_aQm5, l_aQm6, m_aQm7,
                                 n_aQm8, o_aQm9)
                          GHC.Enum.$fBounded(,,,,,,,,,,,,,,)_$cminBound
                            @ a_aQlV
                            @ b_aQlW
                            @ c_aQlX
                            @ d_aQlY
                            @ e_aQlZ
                            @ f_aQm0
                            @ g_aQm1
                            @ h_aQm2
                            @ i_aQm3
                            @ j_aQm4
                            @ k_aQm5
                            @ l_aQm6
                            @ m_aQm7
                            @ n_aQm8
                            @ o_aQm9
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                            v10_Bb
                            v11_Bc
                            v12_Bd
                            v13_Be
                            v14_Bf
                          GHC.Enum.$fBounded(,,,,,,,,,,,,,,)_$cmaxBound
                            @ a_aQlV
                            @ b_aQlW
                            @ c_aQlX
                            @ d_aQlY
                            @ e_aQlZ
                            @ f_aQm0
                            @ g_aQm1
                            @ h_aQm2
                            @ i_aQm3
                            @ j_aQm4
                            @ k_aQm5
                            @ l_aQm6
                            @ m_aQm7
                            @ n_aQm8
                            @ o_aQm9
                            v_B1
                            v1_B2
                            v2_B3
                            v3_B4
                            v4_B5
                            v5_B6
                            v6_B7
                            v7_B8
                            v8_B9
                            v9_Ba
                            v10_Bb
                            v11_Bc
                            v12_Bd
                            v13_Be
                            v14_Bf]
GHC.Enum.$fBounded(,,,,,,,,,,,,,,)
  = \ (@ a_aR0x)
      (@ b_aR0y)
      (@ c_aR0z)
      (@ d_aR0A)
      (@ e_aR0B)
      (@ f_aR0C)
      (@ g_aR0D)
      (@ h_aR0E)
      (@ i_aR0F)
      (@ j_aR0G)
      (@ k_aR0H)
      (@ l_aR0I)
      (@ m_aR0J)
      (@ n_aR0K)
      (@ o_aR0L)
      ($dBounded_aR0M :: Bounded a_aR0x)
      ($dBounded1_aR0N :: Bounded b_aR0y)
      ($dBounded2_aR0O :: Bounded c_aR0z)
      ($dBounded3_aR0P :: Bounded d_aR0A)
      ($dBounded4_aR0Q :: Bounded e_aR0B)
      ($dBounded5_aR0R :: Bounded f_aR0C)
      ($dBounded6_aR0S :: Bounded g_aR0D)
      ($dBounded7_aR0T :: Bounded h_aR0E)
      ($dBounded8_aR0U :: Bounded i_aR0F)
      ($dBounded9_aR0V :: Bounded j_aR0G)
      ($dBounded10_aR0W :: Bounded k_aR0H)
      ($dBounded11_aR0X :: Bounded l_aR0I)
      ($dBounded12_aR0Y :: Bounded m_aR0J)
      ($dBounded13_aR0Z :: Bounded n_aR0K)
      ($dBounded14_aR10 :: Bounded o_aR0L) ->
      GHC.Enum.C:Bounded
        @ (a_aR0x, b_aR0y, c_aR0z, d_aR0A, e_aR0B, f_aR0C, g_aR0D, h_aR0E,
           i_aR0F, j_aR0G, k_aR0H, l_aR0I, m_aR0J, n_aR0K, o_aR0L)
        (GHC.Enum.$fBounded(,,,,,,,,,,,,,,)_$cminBound
           @ a_aR0x
           @ b_aR0y
           @ c_aR0z
           @ d_aR0A
           @ e_aR0B
           @ f_aR0C
           @ g_aR0D
           @ h_aR0E
           @ i_aR0F
           @ j_aR0G
           @ k_aR0H
           @ l_aR0I
           @ m_aR0J
           @ n_aR0K
           @ o_aR0L
           $dBounded_aR0M
           $dBounded1_aR0N
           $dBounded2_aR0O
           $dBounded3_aR0P
           $dBounded4_aR0Q
           $dBounded5_aR0R
           $dBounded6_aR0S
           $dBounded7_aR0T
           $dBounded8_aR0U
           $dBounded9_aR0V
           $dBounded10_aR0W
           $dBounded11_aR0X
           $dBounded12_aR0Y
           $dBounded13_aR0Z
           $dBounded14_aR10)
        (GHC.Enum.$fBounded(,,,,,,,,,,,,,,)_$cmaxBound
           @ a_aR0x
           @ b_aR0y
           @ c_aR0z
           @ d_aR0A
           @ e_aR0B
           @ f_aR0C
           @ g_aR0D
           @ h_aR0E
           @ i_aR0F
           @ j_aR0G
           @ k_aR0H
           @ l_aR0I
           @ m_aR0J
           @ n_aR0K
           @ o_aR0L
           $dBounded_aR0M
           $dBounded1_aR0N
           $dBounded2_aR0O
           $dBounded3_aR0P
           $dBounded4_aR0Q
           $dBounded5_aR0R
           $dBounded6_aR0S
           $dBounded7_aR0T
           $dBounded8_aR0U
           $dBounded9_aR0V
           $dBounded10_aR0W
           $dBounded11_aR0X
           $dBounded12_aR0Y
           $dBounded13_aR0Z
           $dBounded14_aR10)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Bool
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Bool GHC.Types.False GHC.Types.True]
GHC.Enum.$fBoundedBool
  = GHC.Enum.C:Bounded @ Bool GHC.Types.False GHC.Types.True

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded Ordering
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: Ordering GHC.Types.LT GHC.Types.GT]
GHC.Enum.$fBoundedOrdering
  = GHC.Enum.C:Bounded @ Ordering GHC.Types.LT GHC.Types.GT

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedVecCount [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded VecCount
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: VecCount GHC.Types.Vec2 GHC.Types.Vec64]
GHC.Enum.$fBoundedVecCount
  = GHC.Enum.C:Bounded @ VecCount GHC.Types.Vec2 GHC.Types.Vec64

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fBoundedVecElem [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded VecElem
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: VecElem
                          GHC.Types.Int8ElemRep
                          GHC.Types.DoubleElemRep]
GHC.Enum.$fBoundedVecElem
  = GHC.Enum.C:Bounded
      @ VecElem GHC.Types.Int8ElemRep GHC.Types.DoubleElemRep

-- RHS size: {terms: 14, types: 9, coercions: 0, joins: 0/0}
GHC.Enum.$dmpred :: forall a. Enum a => a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLLLL),U(A,A,1*C1(U),1*C1(U(U)),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aQga) ($dEnum_aQVO :: Enum a_aQga) ->
                 let {
                   f_inLG [Occ=OnceL!] :: Int -> a_aQga
                   [LclId]
                   f_inLG = toEnum @ a_aQga $dEnum_aQVO } in
                 let {
                   g_XnQB [Occ=OnceL!] :: a_aQga -> Int
                   [LclId]
                   g_XnQB = fromEnum @ a_aQga $dEnum_aQVO } in
                 \ (x_XnQF [Occ=Once] :: a_aQga) ->
                   f_inLG
                     (case g_XnQB x_XnQF of { I# x1_alHd [Occ=Once] ->
                      GHC.Types.I# (-# x1_alHd 1#)
                      })}]
GHC.Enum.$dmpred
  = \ (@ a_aQga) ($dEnum_aQVO :: Enum a_aQga) (eta_B1 :: a_aQga) ->
      toEnum
        @ a_aQga
        $dEnum_aQVO
        (case fromEnum @ a_aQga $dEnum_aQVO eta_B1 of { I# x_alHd ->
         GHC.Types.I# (-# x_alHd 1#)
         })

-- RHS size: {terms: 14, types: 9, coercions: 0, joins: 0/0}
GHC.Enum.$dmsucc :: forall a. Enum a => a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLLLL),U(A,A,1*C1(U),1*C1(U(U)),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aQga) ($dEnum_aQVO :: Enum a_aQga) ->
                 let {
                   f_inLG [Occ=OnceL!] :: Int -> a_aQga
                   [LclId]
                   f_inLG = toEnum @ a_aQga $dEnum_aQVO } in
                 let {
                   g_XnQE [Occ=OnceL!] :: a_aQga -> Int
                   [LclId]
                   g_XnQE = fromEnum @ a_aQga $dEnum_aQVO } in
                 \ (x_XnQI [Occ=Once] :: a_aQga) ->
                   f_inLG
                     (case g_XnQE x_XnQI of { I# x1_alHb [Occ=Once] ->
                      GHC.Types.I# (+# x1_alHb 1#)
                      })}]
GHC.Enum.$dmsucc
  = \ (@ a_aQga) ($dEnum_aQVO :: Enum a_aQga) (eta_B1 :: a_aQga) ->
      toEnum
        @ a_aQga
        $dEnum_aQVO
        (case fromEnum @ a_aQga $dEnum_aQVO eta_B1 of { I# x_alHb ->
         GHC.Types.I# (+# x_alHb 1#)
         })

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl11_rUQR :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl11_rUQR = "Enum.toEnum{"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl12_rUQS :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl12_rUQS = "}: tag ("#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl13_rUQT :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl13_rUQT = ") is outside of bounds "#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl14_rUQU :: [Char]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
lvl14_rUQU
  = GHC.Types.: @ Char GHC.Show.$fShow(,)2 (GHC.Types.[] @ Char)

-- RHS size: {terms: 41, types: 31, coercions: 0, joins: 0/0}
GHC.Enum.$wtoEnumError [InlPrag=NOINLINE]
  :: forall a b. Show a => String -> Int# -> a -> a -> b
[GblId,
 Arity=5,
 Str=<B,U(C(C1(U)),A,A)><B,1*U><B,U><B,U><B,U>x,
 Unf=OtherCon []]
GHC.Enum.$wtoEnumError
  = \ (@ a_sTIt)
      (@ b_sTIu)
      (w_sTIv :: Show a_sTIt)
      (w1_sTIw :: String)
      (ww_sTIB :: Int#)
      (ww1_sTIF :: a_sTIt)
      (ww2_sTIG :: a_sTIt) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ b_sTIu
        (unpackAppendCString#
           lvl11_rUQR
           (++
              @ Char
              w1_sTIw
              (unpackAppendCString#
                 lvl12_rUQS
                 (case GHC.Show.$wshowSignedInt 0# ww_sTIB (GHC.Types.[] @ Char) of
                  { (# ww5_sBh6, ww6_sBh7 #) ->
                  ++
                    @ Char
                    (GHC.Types.: @ Char ww5_sBh6 ww6_sBh7)
                    (unpackAppendCString#
                       lvl13_rUQT
                       (GHC.Types.:
                          @ Char
                          GHC.Show.$fShow(,)4
                          (GHC.Show.$fShow(,)_go1
                             (GHC.Types.:
                                @ ShowS
                                (showsPrec @ a_sTIt w_sTIv GHC.Show.$fShow(,)1 ww1_sTIF)
                                (GHC.Types.:
                                   @ ShowS
                                   (showsPrec @ a_sTIt w_sTIv GHC.Show.$fShow(,)1 ww2_sTIG)
                                   (GHC.Types.[] @ ShowS)))
                             lvl14_rUQU)))
                  }))))

-- RHS size: {terms: 18, types: 20, coercions: 0, joins: 0/0}
toEnumError [InlPrag=NOUSERINLINE[0]]
  :: forall a b. Show a => String -> Int -> (a, a) -> b
[GblId,
 Arity=4,
 Str=<B,U(C(C1(U)),A,A)><B,1*U><B,1*U(U)><B,1*U(U,U)>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sTIt)
                 (@ b_sTIu)
                 (w_sTIv [Occ=Once] :: Show a_sTIt)
                 (w1_sTIw [Occ=Once] :: String)
                 (w2_sTIx [Occ=Once!] :: Int)
                 (w3_sTIy [Occ=Once!] :: (a_sTIt, a_sTIt)) ->
                 case w2_sTIx of { I# ww1_sTIB [Occ=Once] ->
                 case w3_sTIy of { (ww3_sTIF [Occ=Once], ww4_sTIG [Occ=Once]) ->
                 GHC.Enum.$wtoEnumError
                   @ a_sTIt @ b_sTIu w_sTIv w1_sTIw ww1_sTIB ww3_sTIF ww4_sTIG
                 }
                 }}]
toEnumError
  = \ (@ a_sTIt)
      (@ b_sTIu)
      (w_sTIv :: Show a_sTIt)
      (w1_sTIw :: String)
      (w2_sTIx :: Int)
      (w3_sTIy :: (a_sTIt, a_sTIt)) ->
      case w2_sTIx of { I# ww1_sTIB ->
      case w3_sTIy of { (ww3_sTIF, ww4_sTIG) ->
      GHC.Enum.$wtoEnumError
        @ a_sTIt @ b_sTIu w_sTIv w1_sTIw ww1_sTIB ww3_sTIF ww4_sTIG
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl15_rUQV :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl15_rUQV = ") is outside of Int's bounds "#

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
lvl16_rUQW :: String -> [Char]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []]
lvl16_rUQW
  = \ (w2_sB4V :: String) ->
      case GHC.Show.$wshowSignedInt 0# -9223372036854775808# w2_sB4V of
      { (# ww5_sBh6, ww6_sBh7 #) ->
      GHC.Types.: @ Char ww5_sBh6 ww6_sBh7
      }

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
lvl17_rUQX :: String -> [Char]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []]
lvl17_rUQX
  = \ (w2_sB4V :: String) ->
      case GHC.Show.$wshowSignedInt 0# 9223372036854775807# w2_sB4V of
      { (# ww5_sBh6, ww6_sBh7 #) ->
      GHC.Types.: @ Char ww5_sBh6 ww6_sBh7
      }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl18_rUQY :: [ShowS]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
lvl18_rUQY = GHC.Types.: @ ShowS lvl17_rUQX (GHC.Types.[] @ ShowS)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl19_rUQZ :: [ShowS]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
lvl19_rUQZ = GHC.Types.: @ ShowS lvl16_rUQW lvl18_rUQY

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
lvl20_rUR0 :: String
[GblId]
lvl20_rUR0 = GHC.Show.$fShow(,)_go1 lvl19_rUQZ lvl14_rUQU

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl21_rUR1 :: [Char]
[GblId, Str=m2, Unf=OtherCon []]
lvl21_rUR1 = GHC.Types.: @ Char GHC.Show.$fShow(,)4 lvl20_rUR0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
lvl22_rUR2 :: [Char]
[GblId]
lvl22_rUR2 = unpackAppendCString# lvl15_rUQV lvl21_rUR1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl23_rUR3 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl23_rUR3 = "Enum.fromEnum{"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl24_rUR4 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl24_rUR4 = "}: value ("#

-- RHS size: {terms: 17, types: 13, coercions: 0, joins: 0/0}
fromEnumError [InlPrag=NOINLINE]
  :: forall a b. Show a => String -> a -> b
[GblId,
 Arity=3,
 Str=<B,1*U(A,1*C1(U),A)><B,1*U><B,U>x,
 Unf=OtherCon []]
fromEnumError
  = \ (@ a_aQTg)
      (@ b_aQTh)
      ($dShow_aQTj :: Show a_aQTg)
      (eta_B2 :: String)
      (eta1_B1 :: a_aQTg) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ b_aQTh
        (unpackAppendCString#
           lvl23_rUR3
           (++
              @ Char
              eta_B2
              (unpackAppendCString#
                 lvl24_rUR4
                 (++ @ Char (show @ a_aQTg $dShow_aQTj eta1_B1) lvl22_rUR2))))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl25_rUR5 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl25_rUR5 = "Enum.succ{"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl26_rUR6 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl26_rUR6 = "}: tried to take `succ' of maxBound"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl27_rUR7 :: [Char]
[GblId]
lvl27_rUR7 = unpackCString# lvl26_rUR6

-- RHS size: {terms: 8, types: 6, coercions: 0, joins: 0/0}
succError [InlPrag=NOINLINE] :: forall a. String -> a
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
succError
  = \ (@ a_aQT8) (inst_ty_aQhN :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ a_aQT8
        (unpackAppendCString#
           lvl25_rUR5 (++ @ Char inst_ty_aQhN lvl27_rUR7))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl28_rUR8 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl28_rUR8 = "Enum.pred{"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl29_rUR9 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl29_rUR9 = "}: tried to take `pred' of minBound"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl30_rURa :: [Char]
[GblId]
lvl30_rURa = unpackCString# lvl29_rUR9

-- RHS size: {terms: 8, types: 6, coercions: 0, joins: 0/0}
predError [InlPrag=NOINLINE] :: forall a. String -> a
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
predError
  = \ (@ a_aQT0) (inst_ty_aQhO :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ a_aQT0
        (unpackAppendCString#
           lvl28_rUR8 (++ @ Char inst_ty_aQhO lvl30_rURa))

Rec {
-- RHS size: {terms: 24, types: 12, coercions: 0, joins: 0/1}
eftCharFB [InlPrag=INLINE[0] (sat-args=4), Occ=LoopBreaker!]
  :: forall a. (Char -> a -> a) -> a -> Int# -> Int# -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_aQSJ)
                 (c_aQhP [Occ=OnceL!] :: Char -> a_aQSJ -> a_aQSJ)
                 (n_aQhQ [Occ=OnceL] :: a_aQSJ)
                 (x0_aQhR [Occ=Once] :: Int#)
                 (y_aQhS [Occ=OnceL] :: Int#) ->
                 letrec {
                   go_aQSN [Occ=LoopBreaker] :: Int# -> a_aQSJ
                   [LclId, Arity=1, Unf=OtherCon []]
                   go_aQSN
                     = \ (x_aQhU :: Int#) ->
                         case ># x_aQhU y_aQhS of {
                           __DEFAULT ->
                             c_aQhP (GHC.Types.C# (chr# x_aQhU)) (go_aQSN (+# x_aQhU 1#));
                           1# -> n_aQhQ
                         }; } in
                 go_aQSN x0_aQhR}]
eftCharFB
  = \ (@ a_aQSJ)
      (c_aQhP :: Char -> a_aQSJ -> a_aQSJ)
      (n_aQhQ :: a_aQSJ)
      (x0_aQhR :: Int#)
      (y_aQhS :: Int#) ->
      letrec {
        go_sRXo [Occ=LoopBreaker] :: Int# -> a_aQSJ
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_sRXo
          = \ (x_aQhU :: Int#) ->
              case ># x_aQhU y_aQhS of {
                __DEFAULT ->
                  c_aQhP (GHC.Types.C# (chr# x_aQhU)) (go_sRXo (+# x_aQhU 1#));
                1# -> n_aQhQ
              }; } in
      go_sRXo x0_aQhR

-- RHS size: {terms: 18, types: 5, coercions: 0, joins: 0/0}
eftChar [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: Int# -> Int# -> String
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []]
eftChar
  = \ (x_aQhV :: Int#) (y_aQhW :: Int#) ->
      case ># x_aQhV y_aQhW of {
        __DEFAULT ->
          GHC.Types.:
            @ Char
            (GHC.Types.C# (chr# x_aQhV))
            (eftChar (+# x_aQhV 1#) y_aQhW);
        1# -> GHC.Types.[] @ Char
      }
end Rec }

-- RHS size: {terms: 8, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumChar_$cenumFrom [InlPrag=INLINE (sat-args=1)]
  :: Char -> [Char]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRzm [Occ=Once!] :: Char) ->
                 case ds_dRzm of { C# x_aQh0 [Occ=Once] ->
                 build
                   @ Char
                   (\ (@ b_aRrZ)
                      (c_aQlK [Occ=Once, OS=OneShot] :: Char -> b_aRrZ -> b_aRrZ)
                      (n_aQlL [Occ=Once, OS=OneShot] :: b_aRrZ) ->
                      eftCharFB @ b_aRrZ c_aQlK n_aQlL (ord# x_aQh0) 1114111#)
                 }}]
GHC.Enum.$fEnumChar_$cenumFrom
  = \ (ds_dRzm :: Char) ->
      case ds_dRzm of { C# x_aQh0 -> eftChar (ord# x_aQh0) 1114111# }

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumChar_$cenumFromTo [InlPrag=INLINE (sat-args=2)]
  :: Char -> Char -> [Char]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRzx [Occ=Once!] :: Char)
                 (ds1_dRzy [Occ=Once!] :: Char) ->
                 case ds_dRzx of { C# x_aQh1 [Occ=Once] ->
                 case ds1_dRzy of { C# y_aQh2 [Occ=Once] ->
                 build
                   @ Char
                   (\ (@ b_aRrZ)
                      (c_aQlK [Occ=Once, OS=OneShot] :: Char -> b_aRrZ -> b_aRrZ)
                      (n_aQlL [Occ=Once, OS=OneShot] :: b_aRrZ) ->
                      eftCharFB @ b_aRrZ c_aQlK n_aQlL (ord# x_aQh1) (ord# y_aQh2))
                 }
                 }}]
GHC.Enum.$fEnumChar_$cenumFromTo
  = \ (ds_dRzx :: Char) (ds1_dRzy :: Char) ->
      case ds_dRzx of { C# x_aQh1 ->
      case ds1_dRzy of { C# y_aQh2 ->
      eftChar (ord# x_aQh1) (ord# y_aQh2)
      }
      }

-- RHS size: {terms: 25, types: 13, coercions: 0, joins: 0/1}
go_up_char_fb
  :: forall a. (Char -> a -> a) -> a -> Int# -> Int# -> Int# -> a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 0 0] 122 0}]
go_up_char_fb
  = \ (@ a_aQRO)
      (c_aQif :: Char -> a_aQRO -> a_aQRO)
      (n_aQig :: a_aQRO)
      (x0_aQih :: Int#)
      (delta_aQii :: Int#)
      (lim_aQij :: Int#) ->
      letrec {
        go_up_sRXm [Occ=LoopBreaker] :: Int# -> a_aQRO
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_up_sRXm
          = \ (x_aQil :: Int#) ->
              case ># x_aQil lim_aQij of {
                __DEFAULT ->
                  c_aQif
                    (GHC.Types.C# (chr# x_aQil)) (go_up_sRXm (+# x_aQil delta_aQii));
                1# -> n_aQig
              }; } in
      go_up_sRXm x0_aQih

-- RHS size: {terms: 25, types: 13, coercions: 0, joins: 0/1}
go_dn_char_fb
  :: forall a. (Char -> a -> a) -> a -> Int# -> Int# -> Int# -> a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 0 0] 122 0}]
go_dn_char_fb
  = \ (@ a_aQRx)
      (c_aQim :: Char -> a_aQRx -> a_aQRx)
      (n_aQin :: a_aQRx)
      (x0_aQio :: Int#)
      (delta_aQip :: Int#)
      (lim_aQiq :: Int#) ->
      letrec {
        go_dn_sRXk [Occ=LoopBreaker] :: Int# -> a_aQRx
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_dn_sRXk
          = \ (x_aQis :: Int#) ->
              case <# x_aQis lim_aQiq of {
                __DEFAULT ->
                  c_aQim
                    (GHC.Types.C# (chr# x_aQis)) (go_dn_sRXk (+# x_aQis delta_aQip));
                1# -> n_aQin
              }; } in
      go_dn_sRXk x0_aQio

-- RHS size: {terms: 22, types: 10, coercions: 0, joins: 0/1}
go_up_char_list :: Int# -> Int# -> Int# -> String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 102 0}]
go_up_char_list
  = \ (x0_aQit :: Int#) (delta_aQiu :: Int#) (lim_aQiv :: Int#) ->
      letrec {
        go_up_sRXi [Occ=LoopBreaker] :: Int# -> [Char]
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_up_sRXi
          = \ (x_aQix :: Int#) ->
              case ># x_aQix lim_aQiv of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Char
                    (GHC.Types.C# (chr# x_aQix))
                    (go_up_sRXi (+# x_aQix delta_aQiu));
                1# -> GHC.Types.[] @ Char
              }; } in
      go_up_sRXi x0_aQit

-- RHS size: {terms: 22, types: 10, coercions: 0, joins: 0/1}
go_dn_char_list :: Int# -> Int# -> Int# -> String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 102 0}]
go_dn_char_list
  = \ (x0_aQiy :: Int#) (delta_aQiz :: Int#) (lim_aQiA :: Int#) ->
      letrec {
        go_dn_sRXg [Occ=LoopBreaker] :: Int# -> [Char]
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_dn_sRXg
          = \ (x_aQiC :: Int#) ->
              case <# x_aQiC lim_aQiA of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Char
                    (GHC.Types.C# (chr# x_aQiC))
                    (go_dn_sRXg (+# x_aQiC delta_aQiz));
                1# -> GHC.Types.[] @ Char
              }; } in
      go_dn_sRXg x0_aQiy

Rec {
-- RHS size: {terms: 28, types: 13, coercions: 0, joins: 0/1}
efdtCharFB [InlPrag=INLINE[0] (sat-args=5), Occ=LoopBreaker!]
  :: forall a. (Char -> a -> a) -> a -> Int# -> Int# -> Int# -> a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_aQSd)
                 (c_aQi5 [Occ=Once*] :: Char -> a_aQSd -> a_aQSd)
                 (n_aQi6 [Occ=Once*] :: a_aQSd)
                 (x1_aQi7 :: Int#)
                 (x2_aQi8 [Occ=Once] :: Int#)
                 (lim_aQi9 [Occ=Once*] :: Int#) ->
                 let {
                   delta_aQia :: Int#
                   [LclId]
                   delta_aQia = -# x2_aQi8 x1_aQi7 } in
                 case >=# delta_aQia 0# of {
                   __DEFAULT ->
                     go_dn_char_fb @ a_aQSd c_aQi5 n_aQi6 x1_aQi7 delta_aQia lim_aQi9;
                   1# ->
                     go_up_char_fb @ a_aQSd c_aQi5 n_aQi6 x1_aQi7 delta_aQia lim_aQi9
                 }}]
efdtCharFB
  = \ (@ a_aQSd)
      (c_aQi5 :: Char -> a_aQSd -> a_aQSd)
      (n_aQi6 :: a_aQSd)
      (x1_aQi7 :: Int#)
      (x2_aQi8 :: Int#)
      (lim_aQi9 :: Int#) ->
      let {
        delta_sRXc [Dmd=<S,U>] :: Int#
        [LclId]
        delta_sRXc = -# x2_aQi8 x1_aQi7 } in
      case >=# delta_sRXc 0# of {
        __DEFAULT ->
          go_dn_char_fb @ a_aQSd c_aQi5 n_aQi6 x1_aQi7 delta_sRXc lim_aQi9;
        1# ->
          go_up_char_fb @ a_aQSd c_aQi5 n_aQi6 x1_aQi7 delta_sRXc lim_aQi9
      }

-- RHS size: {terms: 21, types: 5, coercions: 0, joins: 0/1}
efdtChar [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: Int# -> Int# -> Int# -> String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 102 0}]
efdtChar
  = \ (x1_aQib :: Int#) (x2_aQic :: Int#) (lim_aQid :: Int#) ->
      let {
        delta_sRXe [Dmd=<S,U>] :: Int#
        [LclId]
        delta_sRXe = -# x2_aQic x1_aQib } in
      case >=# delta_sRXe 0# of {
        __DEFAULT -> go_dn_char_list x1_aQib delta_sRXe lim_aQid;
        1# -> go_up_char_list x1_aQib delta_sRXe lim_aQid
      }
end Rec }

-- RHS size: {terms: 70, types: 28, coercions: 0, joins: 0/6}
GHC.Enum.$fEnumChar_$cenumFromThenTo [InlPrag=INLINE (sat-args=3)]
  :: Char -> Char -> Char -> [Char]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRzE [Occ=Once!] :: Char)
                 (ds1_dRzF [Occ=Once!] :: Char)
                 (ds2_dRzG [Occ=Once!] :: Char) ->
                 case ds_dRzE of { C# x1_aQh5 [Occ=Once] ->
                 case ds1_dRzF of { C# x2_aQh6 [Occ=Once] ->
                 case ds2_dRzG of { C# y_aQh7 [Occ=Once] ->
                 build
                   @ Char
                   (\ (@ b_aRsv)
                      (c_aQlT [Occ=Once, OS=OneShot] :: Char -> b_aRsv -> b_aRsv)
                      (n_aQlU [Occ=Once, OS=OneShot] :: b_aRsv) ->
                      efdtCharFB
                        @ b_aRsv c_aQlT n_aQlU (ord# x1_aQh5) (ord# x2_aQh6) (ord# y_aQh7))
                 }
                 }
                 }}]
GHC.Enum.$fEnumChar_$cenumFromThenTo
  = \ (ds_dRzE :: Char) (ds1_dRzF :: Char) (ds2_dRzG :: Char) ->
      case ds_dRzE of { C# x1_aQh5 ->
      case ds1_dRzF of { C# x2_aQh6 ->
      case ds2_dRzG of { C# y_aQh7 ->
      let {
        x4_aQib [Dmd=<S,U>] :: Int#
        [LclId]
        x4_aQib = ord# x1_aQh5 } in
      let {
        delta_sRXe [Dmd=<S,U>] :: Int#
        [LclId]
        delta_sRXe = -# (ord# x2_aQh6) x4_aQib } in
      case >=# delta_sRXe 0# of {
        __DEFAULT ->
          let {
            lim_aQiA [Dmd=<S,U>] :: Int#
            [LclId]
            lim_aQiA = ord# y_aQh7 } in
          letrec {
            go_dn_sRXg [Occ=LoopBreaker] :: Int# -> [Char]
            [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
            go_dn_sRXg
              = \ (x_aQiC :: Int#) ->
                  case <# x_aQiC lim_aQiA of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ Char
                        (GHC.Types.C# (chr# x_aQiC))
                        (go_dn_sRXg (+# x_aQiC delta_sRXe));
                    1# -> GHC.Types.[] @ Char
                  }; } in
          go_dn_sRXg x4_aQib;
        1# ->
          let {
            lim_aQiv [Dmd=<S,U>] :: Int#
            [LclId]
            lim_aQiv = ord# y_aQh7 } in
          letrec {
            go_up_sRXi [Occ=LoopBreaker] :: Int# -> [Char]
            [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
            go_up_sRXi
              = \ (x_aQix :: Int#) ->
                  case ># x_aQix lim_aQiv of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ Char
                        (GHC.Types.C# (chr# x_aQix))
                        (go_up_sRXi (+# x_aQix delta_sRXe));
                    1# -> GHC.Types.[] @ Char
                  }; } in
          go_up_sRXi x4_aQib
      }
      }
      }
      }

Rec {
-- RHS size: {terms: 27, types: 12, coercions: 0, joins: 0/1}
efdCharFB [InlPrag=INLINE[0] (sat-args=4), Occ=LoopBreaker!]
  :: forall a. (Char -> a -> a) -> a -> Int# -> Int# -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_aQSw)
                 (c_aQhX [Occ=Once*] :: Char -> a_aQSw -> a_aQSw)
                 (n_aQhY [Occ=Once*] :: a_aQSw)
                 (x1_aQhZ :: Int#)
                 (x2_aQi0 [Occ=Once] :: Int#) ->
                 let {
                   delta_aQi1 :: Int#
                   [LclId]
                   delta_aQi1 = -# x2_aQi0 x1_aQhZ } in
                 case >=# delta_aQi1 0# of {
                   __DEFAULT ->
                     go_dn_char_fb @ a_aQSw c_aQhX n_aQhY x1_aQhZ delta_aQi1 0#;
                   1# ->
                     go_up_char_fb @ a_aQSw c_aQhX n_aQhY x1_aQhZ delta_aQi1 1114111#
                 }}]
efdCharFB
  = \ (@ a_aQSw)
      (c_aQhX :: Char -> a_aQSw -> a_aQSw)
      (n_aQhY :: a_aQSw)
      (x1_aQhZ :: Int#)
      (x2_aQi0 :: Int#) ->
      let {
        delta_sRX8 [Dmd=<S,U>] :: Int#
        [LclId]
        delta_sRX8 = -# x2_aQi0 x1_aQhZ } in
      case >=# delta_sRX8 0# of {
        __DEFAULT ->
          go_dn_char_fb @ a_aQSw c_aQhX n_aQhY x1_aQhZ delta_sRX8 0#;
        1# ->
          go_up_char_fb @ a_aQSw c_aQhX n_aQhY x1_aQhZ delta_sRX8 1114111#
      }

-- RHS size: {terms: 20, types: 4, coercions: 0, joins: 0/1}
efdChar [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: Int# -> Int# -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 102 0}]
efdChar
  = \ (x1_aQi2 :: Int#) (x2_aQi3 :: Int#) ->
      let {
        delta_sRXa [Dmd=<S,U>] :: Int#
        [LclId]
        delta_sRXa = -# x2_aQi3 x1_aQi2 } in
      case >=# delta_sRXa 0# of {
        __DEFAULT -> go_dn_char_list x1_aQi2 delta_sRXa 0#;
        1# -> go_up_char_list x1_aQi2 delta_sRXa 1114111#
      }
end Rec }

-- RHS size: {terms: 30, types: 9, coercions: 0, joins: 0/2}
GHC.Enum.$fEnumChar_$cenumFromThen [InlPrag=INLINE (sat-args=2)]
  :: Char -> Char -> [Char]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRzq [Occ=Once!] :: Char)
                 (ds1_dRzr [Occ=Once!] :: Char) ->
                 case ds_dRzq of { C# x1_aQh3 [Occ=Once] ->
                 case ds1_dRzr of { C# x2_aQh4 [Occ=Once] ->
                 build
                   @ Char
                   (\ (@ b_aRse)
                      (c_aQlO [Occ=Once, OS=OneShot] :: Char -> b_aRse -> b_aRse)
                      (n_aQlP [Occ=Once, OS=OneShot] :: b_aRse) ->
                      efdCharFB @ b_aRse c_aQlO n_aQlP (ord# x1_aQh3) (ord# x2_aQh4))
                 }
                 }}]
GHC.Enum.$fEnumChar_$cenumFromThen
  = \ (ds_dRzq :: Char) (ds1_dRzr :: Char) ->
      case ds_dRzq of { C# x1_aQh3 ->
      case ds1_dRzr of { C# x2_aQh4 ->
      let {
        x4_aQi2 [Dmd=<S,U>] :: Int#
        [LclId]
        x4_aQi2 = ord# x1_aQh3 } in
      let {
        delta_sRXa [Dmd=<S,U>] :: Int#
        [LclId]
        delta_sRXa = -# (ord# x2_aQh4) x4_aQi2 } in
      case >=# delta_sRXa 0# of {
        __DEFAULT -> go_dn_char_list x4_aQi2 delta_sRXa 0#;
        1# -> go_up_char_list x4_aQi2 delta_sRXa 1114111#
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumChar [InlPrag=NOUSERINLINE CONLIKE] :: Enum Char
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Char
                       GHC.Enum.$fEnumChar_$csucc
                       GHC.Enum.$fEnumChar_$cpred
                       chr
                       ord
                       GHC.Enum.$fEnumChar_$cenumFrom
                       GHC.Enum.$fEnumChar_$cenumFromThen
                       GHC.Enum.$fEnumChar_$cenumFromTo
                       GHC.Enum.$fEnumChar_$cenumFromThenTo]
GHC.Enum.$fEnumChar
  = GHC.Enum.C:Enum
      @ Char
      GHC.Enum.$fEnumChar_$csucc
      GHC.Enum.$fEnumChar_$cpred
      chr
      ord
      GHC.Enum.$fEnumChar_$cenumFrom
      GHC.Enum.$fEnumChar_$cenumFromThen
      GHC.Enum.$fEnumChar_$cenumFromTo
      GHC.Enum.$fEnumChar_$cenumFromThenTo

Rec {
-- RHS size: {terms: 27, types: 11, coercions: 0, joins: 0/1}
eftInt [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: Int# -> Int# -> [Int]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 123 10}]
eftInt
  = \ (x0_aQiD :: Int#) (y_aQiE :: Int#) ->
      case ># x0_aQiD y_aQiE of {
        __DEFAULT ->
          letrec {
            go_sRX4 [Occ=LoopBreaker] :: Int# -> [Int]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_sRX4
              = \ (x_aQiG :: Int#) ->
                  GHC.Types.:
                    @ Int
                    (GHC.Types.I# x_aQiG)
                    (case ==# x_aQiG y_aQiE of {
                       __DEFAULT -> go_sRX4 (+# x_aQiG 1#);
                       1# -> GHC.Types.[] @ Int
                     }); } in
          go_sRX4 x0_aQiD;
        1# -> GHC.Types.[] @ Int
      }

-- RHS size: {terms: 30, types: 13, coercions: 0, joins: 0/1}
eftIntFB [InlPrag=INLINE[0] (sat-args=4), Occ=LoopBreaker!]
  :: forall r. (Int -> r -> r) -> r -> Int# -> Int# -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ r_aQQr)
                 (c_aQiH [Occ=OnceL!] :: Int -> r_aQQr -> r_aQQr)
                 (n_aQiI [Occ=OnceL*] :: r_aQQr)
                 (x0_aQiJ :: Int#)
                 (y_aQiK :: Int#) ->
                 case ># x0_aQiJ y_aQiK of {
                   __DEFAULT ->
                     letrec {
                       go_aQQv [Occ=LoopBreaker] :: Int# -> r_aQQr
                       [LclId, Arity=1, Unf=OtherCon []]
                       go_aQQv
                         = \ (x_aQiM :: Int#) ->
                             c_aQiH
                               (GHC.Types.I# x_aQiM)
                               (case ==# x_aQiM y_aQiK of {
                                  __DEFAULT -> go_aQQv (+# x_aQiM 1#);
                                  1# -> n_aQiI
                                }); } in
                     go_aQQv x0_aQiJ;
                   1# -> n_aQiI
                 }}]
eftIntFB
  = \ (@ r_aQQr)
      (c_aQiH :: Int -> r_aQQr -> r_aQQr)
      (n_aQiI :: r_aQQr)
      (x0_aQiJ :: Int#)
      (y_aQiK :: Int#) ->
      case ># x0_aQiJ y_aQiK of {
        __DEFAULT ->
          letrec {
            go_sRX6 [Occ=LoopBreaker] :: Int# -> r_aQQr
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_sRX6
              = \ (x_aQiM :: Int#) ->
                  c_aQiH
                    (GHC.Types.I# x_aQiM)
                    (case ==# x_aQiM y_aQiK of {
                       __DEFAULT -> go_sRX6 (+# x_aQiM 1#);
                       1# -> n_aQiI
                     }); } in
          go_sRX6 x0_aQiJ;
        1# -> n_aQiI
      }
end Rec }

Rec {
-- RHS size: {terms: 21, types: 5, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering_go [Occ=LoopBreaker] :: Int# -> [Ordering]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumOrdering_go
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ Ordering
        (case x_aQiM of {
           __DEFAULT -> GHC.Enum.$fEnumOrdering5;
           0# -> GHC.Types.LT;
           1# -> GHC.Types.EQ;
           2# -> GHC.Types.GT
         })
        (case x_aQiM of wild_X7v {
           __DEFAULT -> GHC.Enum.$fEnumOrdering_go (+# wild_X7v 1#);
           2# -> GHC.Types.[] @ Ordering
         })
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering3 :: [Ordering]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumOrdering3 = GHC.Enum.$fEnumOrdering_go 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering2 :: [Ordering]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumOrdering2 = GHC.Enum.$fEnumOrdering_go 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering1 :: [Ordering]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumOrdering1 = GHC.Enum.$fEnumOrdering_go 2#

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering_$cenumFrom :: Ordering -> [Ordering]
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [40] 30 0}]
GHC.Enum.$fEnumOrdering_$cenumFrom
  = \ (n_aQhD :: Ordering) ->
      case n_aQhD of {
        LT -> GHC.Enum.$fEnumOrdering3;
        EQ -> GHC.Enum.$fEnumOrdering2;
        GT -> GHC.Enum.$fEnumOrdering1
      }

Rec {
-- RHS size: {terms: 21, types: 5, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering_go2 [Occ=LoopBreaker] :: Int# -> [Ordering]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumOrdering_go2
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ Ordering
        (case x_aQiM of {
           __DEFAULT -> GHC.Enum.$fEnumOrdering5;
           0# -> GHC.Types.LT;
           1# -> GHC.Types.EQ;
           2# -> GHC.Types.GT
         })
        (case x_aQiM of wild_X7C {
           __DEFAULT -> GHC.Enum.$fEnumOrdering_go2 (+# wild_X7C 1#);
           0# -> GHC.Types.[] @ Ordering
         })
end Rec }

Rec {
-- RHS size: {terms: 21, types: 5, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering_go1 [Occ=LoopBreaker] :: Int# -> [Ordering]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumOrdering_go1
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ Ordering
        (case x_aQiM of {
           __DEFAULT -> GHC.Enum.$fEnumOrdering5;
           0# -> GHC.Types.LT;
           1# -> GHC.Types.EQ;
           2# -> GHC.Types.GT
         })
        (case x_aQiM of wild_X7C {
           __DEFAULT -> GHC.Enum.$fEnumOrdering_go1 (+# wild_X7C 1#);
           1# -> GHC.Types.[] @ Ordering
         })
end Rec }

-- RHS size: {terms: 47, types: 14, coercions: 0, joins: 1/1}
GHC.Enum.$fEnumOrdering_$cenumFromTo
  :: Ordering -> Ordering -> [Ordering]
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [48 122] 195 0}]
GHC.Enum.$fEnumOrdering_$cenumFromTo
  = \ (x_aQge :: Ordering) (y_aQgf :: Ordering) ->
      join {
        $j_sS20 [Dmd=<C(S),1*C1(U)>] :: Int# -> [Ordering]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sS20 (x1_aQgR [OS=OneShot] :: Int#)
          = case y_aQgf of {
              LT ->
                case ># x1_aQgR 0# of {
                  __DEFAULT -> GHC.Enum.$fEnumOrdering_go2 x1_aQgR;
                  1# -> GHC.Types.[] @ Ordering
                };
              EQ ->
                case ># x1_aQgR 1# of {
                  __DEFAULT -> GHC.Enum.$fEnumOrdering_go1 x1_aQgR;
                  1# -> GHC.Types.[] @ Ordering
                };
              GT ->
                case ># x1_aQgR 2# of {
                  __DEFAULT -> GHC.Enum.$fEnumOrdering_go x1_aQgR;
                  1# -> GHC.Types.[] @ Ordering
                }
            } } in
      case x_aQge of {
        LT -> jump $j_sS20 0#;
        EQ -> jump $j_sS20 1#;
        GT -> jump $j_sS20 2#
      }

Rec {
-- RHS size: {terms: 19, types: 5, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool_go [Occ=LoopBreaker] :: Int# -> [Bool]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumBool_go
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ Bool
        (case x_aQiM of {
           __DEFAULT -> GHC.Enum.$fEnumBool1;
           0# -> GHC.Types.False;
           1# -> GHC.Types.True
         })
        (case x_aQiM of wild_X7x {
           __DEFAULT -> GHC.Enum.$fEnumBool_go (+# wild_X7x 1#);
           1# -> GHC.Types.[] @ Bool
         })
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool3 :: [Bool]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumBool3 = GHC.Enum.$fEnumBool_go 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool2 :: [Bool]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumBool2 = GHC.Enum.$fEnumBool_go 1#

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool_$cenumFrom :: Bool -> [Bool]
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
GHC.Enum.$fEnumBool_$cenumFrom
  = \ (n_aQhD :: Bool) ->
      case n_aQhD of {
        False -> GHC.Enum.$fEnumBool3;
        True -> GHC.Enum.$fEnumBool2
      }

Rec {
-- RHS size: {terms: 19, types: 5, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool_go1 [Occ=LoopBreaker] :: Int# -> [Bool]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumBool_go1
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ Bool
        (case x_aQiM of {
           __DEFAULT -> GHC.Enum.$fEnumBool1;
           0# -> GHC.Types.False;
           1# -> GHC.Types.True
         })
        (case x_aQiM of wild_X7E {
           __DEFAULT -> GHC.Enum.$fEnumBool_go1 (+# wild_X7E 1#);
           0# -> GHC.Types.[] @ Bool
         })
end Rec }

-- RHS size: {terms: 34, types: 12, coercions: 0, joins: 1/1}
GHC.Enum.$fEnumBool_$cenumFromTo :: Bool -> Bool -> [Bool]
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [34 71] 130 0}]
GHC.Enum.$fEnumBool_$cenumFromTo
  = \ (x_aQge :: Bool) (y_aQgf :: Bool) ->
      join {
        $j_sS24 [Dmd=<C(S),1*C1(U)>] :: Int# -> [Bool]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sS24 (x1_aQgR [OS=OneShot] :: Int#)
          = case y_aQgf of {
              False ->
                case ># x1_aQgR 0# of {
                  __DEFAULT -> GHC.Enum.$fEnumBool_go1 x1_aQgR;
                  1# -> GHC.Types.[] @ Bool
                };
              True ->
                case ># x1_aQgR 1# of {
                  __DEFAULT -> GHC.Enum.$fEnumBool_go x1_aQgR;
                  1# -> GHC.Types.[] @ Bool
                }
            } } in
      case x_aQge of {
        False -> jump $j_sS24 0#;
        True -> jump $j_sS24 1#
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInt_$cenumFrom [InlPrag=INLINE (sat-args=1)]
  :: Int -> [Int]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRyE [Occ=Once!] :: Int) ->
                 case ds_dRyE of { I# x_aQgP [Occ=Once] ->
                 build
                   @ Int
                   (\ (@ b_aRrF)
                      (c_aQlG [Occ=Once, OS=OneShot] :: Int -> b_aRrF -> b_aRrF)
                      (n_aQlH [Occ=Once, OS=OneShot] :: b_aRrF) ->
                      eftIntFB @ b_aRrF c_aQlG n_aQlH x_aQgP 9223372036854775807#)
                 }}]
GHC.Enum.$fEnumInt_$cenumFrom
  = \ (ds_dRyE :: Int) ->
      case ds_dRyE of { I# x_aQgP -> eftInt x_aQgP 9223372036854775807# }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInt_$cenumFromTo [InlPrag=INLINE (sat-args=2)]
  :: Int -> Int -> [Int]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRyR [Occ=Once!] :: Int)
                 (ds1_dRyS [Occ=Once!] :: Int) ->
                 case ds_dRyR of { I# x_aQgR [Occ=Once] ->
                 case ds1_dRyS of { I# y_aQgS [Occ=Once] ->
                 build
                   @ Int
                   (\ (@ b_aRrF)
                      (c_aQlG [Occ=Once, OS=OneShot] :: Int -> b_aRrF -> b_aRrF)
                      (n_aQlH [Occ=Once, OS=OneShot] :: b_aRrF) ->
                      eftIntFB @ b_aRrF c_aQlG n_aQlH x_aQgR y_aQgS)
                 }
                 }}]
GHC.Enum.$fEnumInt_$cenumFromTo
  = \ (ds_dRyR :: Int) (ds1_dRyS :: Int) ->
      case ds_dRyR of { I# x_aQgR ->
      case ds1_dRyS of { I# y_aQgS -> eftInt x_aQgR y_aQgS }
      }

-- RHS size: {terms: 52, types: 19, coercions: 0, joins: 0/3}
efdtIntUp :: Int# -> Int# -> Int# -> [Int]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 206 70}]
efdtIntUp
  = \ (x1_aQiZ :: Int#) (x2_aQj0 :: Int#) (y_aQj1 :: Int#) ->
      case <# y_aQj1 x2_aQj0 of {
        __DEFAULT ->
          GHC.Types.:
            @ Int
            (GHC.Types.I# x1_aQiZ)
            (let {
               delta_sRX2 [Dmd=<S,U>] :: Int#
               [LclId]
               delta_sRX2 = -# x2_aQj0 x1_aQiZ } in
             let {
               y'_sRX1 [Dmd=<S,U>] :: Int#
               [LclId]
               y'_sRX1 = -# y_aQj1 delta_sRX2 } in
             letrec {
               go_up_sRX0 [Occ=LoopBreaker] :: Int# -> [Int]
               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
               go_up_sRX0
                 = \ (x_aQj5 :: Int#) ->
                     case ># x_aQj5 y'_sRX1 of {
                       __DEFAULT ->
                         GHC.Types.:
                           @ Int (GHC.Types.I# x_aQj5) (go_up_sRX0 (+# x_aQj5 delta_sRX2));
                       1# -> GHC.Types.: @ Int (GHC.Types.I# x_aQj5) (GHC.Types.[] @ Int)
                     }; } in
             go_up_sRX0 x2_aQj0);
        1# ->
          case <# y_aQj1 x1_aQiZ of {
            __DEFAULT ->
              GHC.Types.: @ Int (GHC.Types.I# x1_aQiZ) (GHC.Types.[] @ Int);
            1# -> GHC.Types.[] @ Int
          }
      }

-- RHS size: {terms: 55, types: 17, coercions: 0, joins: 0/3}
efdtIntUpFB [InlPrag=INLINE[0] (sat-args=5)]
  :: forall r. (Int -> r -> r) -> r -> Int# -> Int# -> Int# -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ r_aQPf)
                 (c_aQj6 :: Int -> r_aQPf -> r_aQPf)
                 (n_aQj7 [Occ=OnceL*] :: r_aQPf)
                 (x1_aQj8 :: Int#)
                 (x2_aQj9 :: Int#)
                 (y_aQja :: Int#) ->
                 case <# y_aQja x2_aQj9 of {
                   __DEFAULT ->
                     let {
                       delta_aQjb :: Int#
                       [LclId]
                       delta_aQjb = -# x2_aQj9 x1_aQj8 } in
                     let {
                       y'_aQjc [Occ=OnceL] :: Int#
                       [LclId]
                       y'_aQjc = -# y_aQja delta_aQjb } in
                     c_aQj6
                       (GHC.Types.I# x1_aQj8)
                       (letrec {
                          go_up_aQPx [Occ=LoopBreaker] :: Int# -> r_aQPf
                          [LclId, Arity=1, Unf=OtherCon []]
                          go_up_aQPx
                            = \ (x_aQje :: Int#) ->
                                case ># x_aQje y'_aQjc of {
                                  __DEFAULT ->
                                    c_aQj6
                                      (GHC.Types.I# x_aQje) (go_up_aQPx (+# x_aQje delta_aQjb));
                                  1# -> c_aQj6 (GHC.Types.I# x_aQje) n_aQj7
                                }; } in
                        go_up_aQPx x2_aQj9);
                   1# ->
                     case <# y_aQja x1_aQj8 of {
                       __DEFAULT -> c_aQj6 (GHC.Types.I# x1_aQj8) n_aQj7;
                       1# -> n_aQj7
                     }
                 }}]
efdtIntUpFB
  = \ (@ r_aQPf)
      (c_aQj6 :: Int -> r_aQPf -> r_aQPf)
      (n_aQj7 :: r_aQPf)
      (x1_aQj8 :: Int#)
      (x2_aQj9 :: Int#)
      (y_aQja :: Int#) ->
      case <# y_aQja x2_aQj9 of {
        __DEFAULT ->
          c_aQj6
            (GHC.Types.I# x1_aQj8)
            (let {
               delta_sRWW [Dmd=<S,U>] :: Int#
               [LclId]
               delta_sRWW = -# x2_aQj9 x1_aQj8 } in
             let {
               y'_sRWV [Dmd=<S,U>] :: Int#
               [LclId]
               y'_sRWV = -# y_aQja delta_sRWW } in
             letrec {
               go_up_sRWU [Occ=LoopBreaker] :: Int# -> r_aQPf
               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
               go_up_sRWU
                 = \ (x_aQje :: Int#) ->
                     case ># x_aQje y'_sRWV of {
                       __DEFAULT ->
                         c_aQj6 (GHC.Types.I# x_aQje) (go_up_sRWU (+# x_aQje delta_sRWW));
                       1# -> c_aQj6 (GHC.Types.I# x_aQje) n_aQj7
                     }; } in
             go_up_sRWU x2_aQj9);
        1# ->
          case <# y_aQja x1_aQj8 of {
            __DEFAULT -> c_aQj6 (GHC.Types.I# x1_aQj8) n_aQj7;
            1# -> n_aQj7
          }
      }

-- RHS size: {terms: 52, types: 19, coercions: 0, joins: 0/3}
efdtIntDn :: Int# -> Int# -> Int# -> [Int]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 206 70}]
efdtIntDn
  = \ (x1_aQjf :: Int#) (x2_aQjg :: Int#) (y_aQjh :: Int#) ->
      case ># y_aQjh x2_aQjg of {
        __DEFAULT ->
          GHC.Types.:
            @ Int
            (GHC.Types.I# x1_aQjf)
            (let {
               delta_sRWQ [Dmd=<S,U>] :: Int#
               [LclId]
               delta_sRWQ = -# x2_aQjg x1_aQjf } in
             let {
               y'_sRWP [Dmd=<S,U>] :: Int#
               [LclId]
               y'_sRWP = -# y_aQjh delta_sRWQ } in
             letrec {
               go_dn_sRWO [Occ=LoopBreaker] :: Int# -> [Int]
               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
               go_dn_sRWO
                 = \ (x_aQjl :: Int#) ->
                     case <# x_aQjl y'_sRWP of {
                       __DEFAULT ->
                         GHC.Types.:
                           @ Int (GHC.Types.I# x_aQjl) (go_dn_sRWO (+# x_aQjl delta_sRWQ));
                       1# -> GHC.Types.: @ Int (GHC.Types.I# x_aQjl) (GHC.Types.[] @ Int)
                     }; } in
             go_dn_sRWO x2_aQjg);
        1# ->
          case ># y_aQjh x1_aQjf of {
            __DEFAULT ->
              GHC.Types.: @ Int (GHC.Types.I# x1_aQjf) (GHC.Types.[] @ Int);
            1# -> GHC.Types.[] @ Int
          }
      }

-- RHS size: {terms: 16, types: 3, coercions: 0, joins: 0/0}
efdInt :: Int# -> Int# -> [Int]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 101 0}]
efdInt
  = \ (x1_aQiN :: Int#) (x2_aQiO :: Int#) ->
      case >=# x2_aQiO x1_aQiN of {
        __DEFAULT -> efdtIntDn x1_aQiN x2_aQiO -9223372036854775808#;
        1# -> efdtIntUp x1_aQiN x2_aQiO 9223372036854775807#
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInt_$cenumFromThen [InlPrag=INLINE (sat-args=2)]
  :: Int -> Int -> [Int]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRyK [Occ=Once!] :: Int)
                 (ds1_dRyL [Occ=Once!] :: Int) ->
                 case ds_dRyK of { I# x1_aQgT [Occ=Once] ->
                 case ds1_dRyL of { I# x2_aQgU [Occ=Once] ->
                 efdInt x1_aQgT x2_aQgU
                 }
                 }}]
GHC.Enum.$fEnumInt_$cenumFromThen
  = \ (ds_dRyK :: Int) (ds1_dRyL :: Int) ->
      case ds_dRyK of { I# x1_aQgT ->
      case ds1_dRyL of { I# x2_aQgU -> efdInt x1_aQgT x2_aQgU }
      }

-- RHS size: {terms: 55, types: 17, coercions: 0, joins: 0/3}
efdtIntDnFB [InlPrag=INLINE[0] (sat-args=5)]
  :: forall r. (Int -> r -> r) -> r -> Int# -> Int# -> Int# -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ r_aQOd)
                 (c_aQjm :: Int -> r_aQOd -> r_aQOd)
                 (n_aQjn [Occ=OnceL*] :: r_aQOd)
                 (x1_aQjo :: Int#)
                 (x2_aQjp :: Int#)
                 (y_aQjq :: Int#) ->
                 case ># y_aQjq x2_aQjp of {
                   __DEFAULT ->
                     let {
                       delta_aQjr :: Int#
                       [LclId]
                       delta_aQjr = -# x2_aQjp x1_aQjo } in
                     let {
                       y'_aQjs [Occ=OnceL] :: Int#
                       [LclId]
                       y'_aQjs = -# y_aQjq delta_aQjr } in
                     c_aQjm
                       (GHC.Types.I# x1_aQjo)
                       (letrec {
                          go_dn_aQOv [Occ=LoopBreaker] :: Int# -> r_aQOd
                          [LclId, Arity=1, Unf=OtherCon []]
                          go_dn_aQOv
                            = \ (x_aQju :: Int#) ->
                                case <# x_aQju y'_aQjs of {
                                  __DEFAULT ->
                                    c_aQjm
                                      (GHC.Types.I# x_aQju) (go_dn_aQOv (+# x_aQju delta_aQjr));
                                  1# -> c_aQjm (GHC.Types.I# x_aQju) n_aQjn
                                }; } in
                        go_dn_aQOv x2_aQjp);
                   1# ->
                     case ># y_aQjq x1_aQjo of {
                       __DEFAULT -> c_aQjm (GHC.Types.I# x1_aQjo) n_aQjn;
                       1# -> n_aQjn
                     }
                 }}]
efdtIntDnFB
  = \ (@ r_aQOd)
      (c_aQjm :: Int -> r_aQOd -> r_aQOd)
      (n_aQjn :: r_aQOd)
      (x1_aQjo :: Int#)
      (x2_aQjp :: Int#)
      (y_aQjq :: Int#) ->
      case ># y_aQjq x2_aQjp of {
        __DEFAULT ->
          c_aQjm
            (GHC.Types.I# x1_aQjo)
            (let {
               delta_sRWK [Dmd=<S,U>] :: Int#
               [LclId]
               delta_sRWK = -# x2_aQjp x1_aQjo } in
             let {
               y'_sRWJ [Dmd=<S,U>] :: Int#
               [LclId]
               y'_sRWJ = -# y_aQjq delta_sRWK } in
             letrec {
               go_dn_sRWI [Occ=LoopBreaker] :: Int# -> r_aQOd
               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
               go_dn_sRWI
                 = \ (x_aQju :: Int#) ->
                     case <# x_aQju y'_sRWJ of {
                       __DEFAULT ->
                         c_aQjm (GHC.Types.I# x_aQju) (go_dn_sRWI (+# x_aQju delta_sRWK));
                       1# -> c_aQjm (GHC.Types.I# x_aQju) n_aQjn
                     }; } in
             go_dn_sRWI x2_aQjp);
        1# ->
          case ># y_aQjq x1_aQjo of {
            __DEFAULT -> c_aQjm (GHC.Types.I# x1_aQjo) n_aQjn;
            1# -> n_aQjn
          }
      }

Rec {
-- RHS size: {terms: 17, types: 4, coercions: 0, joins: 0/0}
efdtInt [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: Int# -> Int# -> Int# -> [Int]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 101 0}]
efdtInt
  = \ (x1_aQiR :: Int#) (x2_aQiS :: Int#) (y_aQiT :: Int#) ->
      case >=# x2_aQiS x1_aQiR of {
        __DEFAULT -> efdtIntDn x1_aQiR x2_aQiS y_aQiT;
        1# -> efdtIntUp x1_aQiR x2_aQiS y_aQiT
      }

-- RHS size: {terms: 24, types: 12, coercions: 0, joins: 0/0}
efdtIntFB [InlPrag=INLINE[0] (sat-args=5), Occ=LoopBreaker!]
  :: forall r. (Int -> r -> r) -> r -> Int# -> Int# -> Int# -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ r_aQQh)
                 (c_aQiU [Occ=Once*] :: Int -> r_aQQh -> r_aQQh)
                 (n_aQiV [Occ=Once*] :: r_aQQh)
                 (x1_aQiW :: Int#)
                 (x2_aQiX :: Int#)
                 (y_aQiY [Occ=Once*] :: Int#) ->
                 case >=# x2_aQiX x1_aQiW of {
                   __DEFAULT ->
                     efdtIntDnFB @ r_aQQh c_aQiU n_aQiV x1_aQiW x2_aQiX y_aQiY;
                   1# -> efdtIntUpFB @ r_aQQh c_aQiU n_aQiV x1_aQiW x2_aQiX y_aQiY
                 }}]
efdtIntFB
  = \ (@ r_aQQh)
      (c_aQiU :: Int -> r_aQQh -> r_aQQh)
      (n_aQiV :: r_aQQh)
      (x1_aQiW :: Int#)
      (x2_aQiX :: Int#)
      (y_aQiY :: Int#) ->
      case >=# x2_aQiX x1_aQiW of {
        __DEFAULT ->
          efdtIntDnFB @ r_aQQh c_aQiU n_aQiV x1_aQiW x2_aQiX y_aQiY;
        1# -> efdtIntUpFB @ r_aQQh c_aQiU n_aQiV x1_aQiW x2_aQiX y_aQiY
      }
end Rec }

-- RHS size: {terms: 538, types: 137, coercions: 0, joins: 2/20}
GHC.Enum.$fEnumOrdering_$cenumFromThenTo
  :: Ordering -> Ordering -> Ordering -> [Ordering]
[GblId, Arity=3, Str=<S,1*U><S,1*U><S,1*U>, Unf=OtherCon []]
GHC.Enum.$fEnumOrdering_$cenumFromThenTo
  = \ (x1_aQgg :: Ordering)
      (x2_aQgh :: Ordering)
      (y_aQgi :: Ordering) ->
      join {
        $j_sS2F [Dmd=<C(S),1*C1(U)>] :: Int# -> [Ordering]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sS2F (x4_aQgV [OS=OneShot] :: Int#)
          = join {
              $j1_sS2D [Dmd=<C(S),1*C1(U)>] :: Int# -> [Ordering]
              [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
              $j1_sS2D (x5_aQgW [OS=OneShot] :: Int#)
                = case y_aQgi of {
                    LT ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 0# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Ordering
                                (case x4_aQgV of {
                                   __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                   0# -> GHC.Types.LT;
                                   1# -> GHC.Types.EQ;
                                   2# -> GHC.Types.GT
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 0# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [Ordering]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQju of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQju of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (GHC.Types.[] @ Ordering)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 0# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ Ordering
                                    (case x4_aQgV of {
                                       __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                       0# -> GHC.Types.LT;
                                       1# -> GHC.Types.EQ;
                                       2# -> GHC.Types.GT
                                     })
                                    (GHC.Types.[] @ Ordering);
                                1# -> GHC.Types.[] @ Ordering
                              }
                          };
                        1# ->
                          case <# 0# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Ordering
                                (case x4_aQgV of {
                                   __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                   0# -> GHC.Types.LT;
                                   1# -> GHC.Types.EQ;
                                   2# -> GHC.Types.GT
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 0# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [Ordering]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQje of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQje of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (GHC.Types.[] @ Ordering)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 0# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ Ordering
                                    (case x4_aQgV of {
                                       __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                       0# -> GHC.Types.LT;
                                       1# -> GHC.Types.EQ;
                                       2# -> GHC.Types.GT
                                     })
                                    (GHC.Types.[] @ Ordering);
                                1# -> GHC.Types.[] @ Ordering
                              }
                          }
                      };
                    EQ ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 1# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Ordering
                                (case x4_aQgV of {
                                   __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                   0# -> GHC.Types.LT;
                                   1# -> GHC.Types.EQ;
                                   2# -> GHC.Types.GT
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 1# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [Ordering]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQju of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQju of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (GHC.Types.[] @ Ordering)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 1# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ Ordering
                                    (case x4_aQgV of {
                                       __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                       0# -> GHC.Types.LT;
                                       1# -> GHC.Types.EQ;
                                       2# -> GHC.Types.GT
                                     })
                                    (GHC.Types.[] @ Ordering);
                                1# -> GHC.Types.[] @ Ordering
                              }
                          };
                        1# ->
                          case <# 1# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Ordering
                                (case x4_aQgV of {
                                   __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                   0# -> GHC.Types.LT;
                                   1# -> GHC.Types.EQ;
                                   2# -> GHC.Types.GT
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 1# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [Ordering]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQje of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQje of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (GHC.Types.[] @ Ordering)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 1# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ Ordering
                                    (case x4_aQgV of {
                                       __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                       0# -> GHC.Types.LT;
                                       1# -> GHC.Types.EQ;
                                       2# -> GHC.Types.GT
                                     })
                                    (GHC.Types.[] @ Ordering);
                                1# -> GHC.Types.[] @ Ordering
                              }
                          }
                      };
                    GT ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 2# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Ordering
                                (case x4_aQgV of {
                                   __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                   0# -> GHC.Types.LT;
                                   1# -> GHC.Types.EQ;
                                   2# -> GHC.Types.GT
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 2# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [Ordering]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQju of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQju of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (GHC.Types.[] @ Ordering)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 2# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ Ordering
                                    (case x4_aQgV of {
                                       __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                       0# -> GHC.Types.LT;
                                       1# -> GHC.Types.EQ;
                                       2# -> GHC.Types.GT
                                     })
                                    (GHC.Types.[] @ Ordering);
                                1# -> GHC.Types.[] @ Ordering
                              }
                          };
                        1# ->
                          case <# 2# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Ordering
                                (case x4_aQgV of {
                                   __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                   0# -> GHC.Types.LT;
                                   1# -> GHC.Types.EQ;
                                   2# -> GHC.Types.GT
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 2# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [Ordering]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQje of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ Ordering
                                               (case x_aQje of {
                                                  __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                                  0# -> GHC.Types.LT;
                                                  1# -> GHC.Types.EQ;
                                                  2# -> GHC.Types.GT
                                                })
                                               (GHC.Types.[] @ Ordering)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 2# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ Ordering
                                    (case x4_aQgV of {
                                       __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                       0# -> GHC.Types.LT;
                                       1# -> GHC.Types.EQ;
                                       2# -> GHC.Types.GT
                                     })
                                    (GHC.Types.[] @ Ordering);
                                1# -> GHC.Types.[] @ Ordering
                              }
                          }
                      }
                  } } in
            case x2_aQgh of {
              LT -> jump $j1_sS2D 0#;
              EQ -> jump $j1_sS2D 1#;
              GT -> jump $j1_sS2D 2#
            } } in
      case x1_aQgg of {
        LT -> jump $j_sS2F 0#;
        EQ -> jump $j_sS2F 1#;
        GT -> jump $j_sS2F 2#
      }

-- RHS size: {terms: 331, types: 96, coercions: 0, joins: 2/14}
GHC.Enum.$fEnumBool_$cenumFromThenTo
  :: Bool -> Bool -> Bool -> [Bool]
[GblId, Arity=3, Str=<S,1*U><S,1*U><S,1*U>, Unf=OtherCon []]
GHC.Enum.$fEnumBool_$cenumFromThenTo
  = \ (x1_aQgg :: Bool) (x2_aQgh :: Bool) (y_aQgi :: Bool) ->
      join {
        $j_sS2K [Dmd=<C(S),1*C1(U)>] :: Int# -> [Bool]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sS2K (x4_aQgV [OS=OneShot] :: Int#)
          = join {
              $j1_sS2I [Dmd=<C(S),1*C1(U)>] :: Int# -> [Bool]
              [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
              $j1_sS2I (x5_aQgW [OS=OneShot] :: Int#)
                = case y_aQgi of {
                    False ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 0# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Bool
                                (case x4_aQgV of {
                                   __DEFAULT -> GHC.Enum.$fEnumBool1;
                                   0# -> GHC.Types.False;
                                   1# -> GHC.Types.True
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 0# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [Bool]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ Bool
                                               (case x_aQju of {
                                                  __DEFAULT -> GHC.Enum.$fEnumBool1;
                                                  0# -> GHC.Types.False;
                                                  1# -> GHC.Types.True
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ Bool
                                               (case x_aQju of {
                                                  __DEFAULT -> GHC.Enum.$fEnumBool1;
                                                  0# -> GHC.Types.False;
                                                  1# -> GHC.Types.True
                                                })
                                               (GHC.Types.[] @ Bool)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 0# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ Bool
                                    (case x4_aQgV of {
                                       __DEFAULT -> GHC.Enum.$fEnumBool1;
                                       0# -> GHC.Types.False;
                                       1# -> GHC.Types.True
                                     })
                                    (GHC.Types.[] @ Bool);
                                1# -> GHC.Types.[] @ Bool
                              }
                          };
                        1# ->
                          case <# 0# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Bool
                                (case x4_aQgV of {
                                   __DEFAULT -> GHC.Enum.$fEnumBool1;
                                   0# -> GHC.Types.False;
                                   1# -> GHC.Types.True
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 0# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [Bool]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ Bool
                                               (case x_aQje of {
                                                  __DEFAULT -> GHC.Enum.$fEnumBool1;
                                                  0# -> GHC.Types.False;
                                                  1# -> GHC.Types.True
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ Bool
                                               (case x_aQje of {
                                                  __DEFAULT -> GHC.Enum.$fEnumBool1;
                                                  0# -> GHC.Types.False;
                                                  1# -> GHC.Types.True
                                                })
                                               (GHC.Types.[] @ Bool)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 0# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ Bool
                                    (case x4_aQgV of {
                                       __DEFAULT -> GHC.Enum.$fEnumBool1;
                                       0# -> GHC.Types.False;
                                       1# -> GHC.Types.True
                                     })
                                    (GHC.Types.[] @ Bool);
                                1# -> GHC.Types.[] @ Bool
                              }
                          }
                      };
                    True ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 1# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Bool
                                (case x4_aQgV of {
                                   __DEFAULT -> GHC.Enum.$fEnumBool1;
                                   0# -> GHC.Types.False;
                                   1# -> GHC.Types.True
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 1# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [Bool]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ Bool
                                               (case x_aQju of {
                                                  __DEFAULT -> GHC.Enum.$fEnumBool1;
                                                  0# -> GHC.Types.False;
                                                  1# -> GHC.Types.True
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ Bool
                                               (case x_aQju of {
                                                  __DEFAULT -> GHC.Enum.$fEnumBool1;
                                                  0# -> GHC.Types.False;
                                                  1# -> GHC.Types.True
                                                })
                                               (GHC.Types.[] @ Bool)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 1# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ Bool
                                    (case x4_aQgV of {
                                       __DEFAULT -> GHC.Enum.$fEnumBool1;
                                       0# -> GHC.Types.False;
                                       1# -> GHC.Types.True
                                     })
                                    (GHC.Types.[] @ Bool);
                                1# -> GHC.Types.[] @ Bool
                              }
                          };
                        1# ->
                          case <# 1# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Bool
                                (case x4_aQgV of {
                                   __DEFAULT -> GHC.Enum.$fEnumBool1;
                                   0# -> GHC.Types.False;
                                   1# -> GHC.Types.True
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 1# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [Bool]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ Bool
                                               (case x_aQje of {
                                                  __DEFAULT -> GHC.Enum.$fEnumBool1;
                                                  0# -> GHC.Types.False;
                                                  1# -> GHC.Types.True
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ Bool
                                               (case x_aQje of {
                                                  __DEFAULT -> GHC.Enum.$fEnumBool1;
                                                  0# -> GHC.Types.False;
                                                  1# -> GHC.Types.True
                                                })
                                               (GHC.Types.[] @ Bool)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 1# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ Bool
                                    (case x4_aQgV of {
                                       __DEFAULT -> GHC.Enum.$fEnumBool1;
                                       0# -> GHC.Types.False;
                                       1# -> GHC.Types.True
                                     })
                                    (GHC.Types.[] @ Bool);
                                1# -> GHC.Types.[] @ Bool
                              }
                          }
                      }
                  } } in
            case x2_aQgh of {
              False -> jump $j1_sS2I 0#;
              True -> jump $j1_sS2I 1#
            } } in
      case x1_aQgg of {
        False -> jump $j_sS2K 0#;
        True -> jump $j_sS2K 1#
      }

-- RHS size: {terms: 16, types: 9, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInt_$cenumFromThenTo [InlPrag=INLINE (sat-args=3)]
  :: Int -> Int -> Int -> [Int]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRyY [Occ=Once!] :: Int)
                 (ds1_dRyZ [Occ=Once!] :: Int)
                 (ds2_dRz0 [Occ=Once!] :: Int) ->
                 case ds_dRyY of { I# x1_aQgV [Occ=Once] ->
                 case ds1_dRyZ of { I# x2_aQgW [Occ=Once] ->
                 case ds2_dRz0 of { I# y_aQgX [Occ=Once] ->
                 build
                   @ Int
                   (\ (@ b_aRrl)
                      (c_aQlC [Occ=Once, OS=OneShot] :: Int -> b_aRrl -> b_aRrl)
                      (n_aQlD [Occ=Once, OS=OneShot] :: b_aRrl) ->
                      efdtIntFB @ b_aRrl c_aQlC n_aQlD x1_aQgV x2_aQgW y_aQgX)
                 }
                 }
                 }}]
GHC.Enum.$fEnumInt_$cenumFromThenTo
  = \ (ds_dRyY :: Int) (ds1_dRyZ :: Int) (ds2_dRz0 :: Int) ->
      case ds_dRyY of { I# x1_aQgV ->
      case ds1_dRyZ of { I# x2_aQgW ->
      case ds2_dRz0 of { I# y_aQgX -> efdtInt x1_aQgV x2_aQgW y_aQgX }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInt [InlPrag=NOUSERINLINE CONLIKE] :: Enum Int
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Int
                       GHC.Enum.$fEnumInt_$csucc
                       GHC.Enum.$fEnumInt_$cpred
                       GHC.Enum.$fEnumInt_$cfromEnum
                       GHC.Enum.$fEnumInt_$cfromEnum
                       GHC.Enum.$fEnumInt_$cenumFrom
                       GHC.Enum.$fEnumInt_$cenumFromThen
                       GHC.Enum.$fEnumInt_$cenumFromTo
                       GHC.Enum.$fEnumInt_$cenumFromThenTo]
GHC.Enum.$fEnumInt
  = GHC.Enum.C:Enum
      @ Int
      GHC.Enum.$fEnumInt_$csucc
      GHC.Enum.$fEnumInt_$cpred
      GHC.Enum.$fEnumInt_$cfromEnum
      GHC.Enum.$fEnumInt_$cfromEnum
      GHC.Enum.$fEnumInt_$cenumFrom
      GHC.Enum.$fEnumInt_$cenumFromThen
      GHC.Enum.$fEnumInt_$cenumFromTo
      GHC.Enum.$fEnumInt_$cenumFromThenTo

-- RHS size: {terms: 143, types: 63, coercions: 0, joins: 0/6}
boundedEnumFromThen
  :: forall a. (Enum a, Bounded a) => a -> a -> [a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(S(S))LLLL),U(A,A,C(U),C(U(U)),A,A,A,A)><L,1*U(1*U,1*U)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [360 60 0 0] 833 140}]
boundedEnumFromThen
  = \ (@ a_aQU6)
      ($dEnum_aQU8 :: Enum a_aQU6)
      ($dBounded_aQU9 :: Bounded a_aQU6)
      (n1_aQhE :: a_aQU6)
      (n2_aQhF :: a_aQU6) ->
      case fromEnum @ a_aQU6 $dEnum_aQU8 n2_aQhF of { I# x_alMY ->
      case fromEnum @ a_aQU6 $dEnum_aQU8 n1_aQhE of wild1_alN0
      { I# y_alN2 ->
      case >=# x_alMY y_alN2 of lwild_sSgN {
        __DEFAULT ->
          case fromEnum
                 @ a_aQU6 $dEnum_aQU8 (minBound @ a_aQU6 $dBounded_aQU9)
          of
          { I# y1_aQgX ->
          case ># y1_aQgX x_alMY of {
            __DEFAULT ->
              GHC.Types.:
                @ a_aQU6
                (toEnum @ a_aQU6 $dEnum_aQU8 wild1_alN0)
                (let {
                   delta_aQjr [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_aQjr = -# x_alMY y_alN2 } in
                 let {
                   y'_aQjs [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_aQjs = -# y1_aQgX delta_aQjr } in
                 letrec {
                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [a_aQU6]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_dn_aQOv
                     = \ (x1_aQju :: Int#) ->
                         case <# x1_aQju y'_aQjs of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ a_aQU6
                               (toEnum @ a_aQU6 $dEnum_aQU8 (GHC.Types.I# x1_aQju))
                               (go_dn_aQOv (+# x1_aQju delta_aQjr));
                           1# ->
                             GHC.Types.:
                               @ a_aQU6
                               (toEnum @ a_aQU6 $dEnum_aQU8 (GHC.Types.I# x1_aQju))
                               (GHC.Types.[] @ a_aQU6)
                         }; } in
                 go_dn_aQOv x_alMY);
            1# ->
              case ># y1_aQgX y_alN2 of {
                __DEFAULT ->
                  GHC.Types.:
                    @ a_aQU6
                    (toEnum @ a_aQU6 $dEnum_aQU8 wild1_alN0)
                    (GHC.Types.[] @ a_aQU6);
                1# -> GHC.Types.[] @ a_aQU6
              }
          }
          };
        1# ->
          case fromEnum
                 @ a_aQU6 $dEnum_aQU8 (maxBound @ a_aQU6 $dBounded_aQU9)
          of
          { I# y1_aQgX ->
          case <# y1_aQgX x_alMY of {
            __DEFAULT ->
              GHC.Types.:
                @ a_aQU6
                (toEnum @ a_aQU6 $dEnum_aQU8 wild1_alN0)
                (let {
                   delta_aQjb [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_aQjb = -# x_alMY y_alN2 } in
                 let {
                   y'_aQjc [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_aQjc = -# y1_aQgX delta_aQjb } in
                 letrec {
                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [a_aQU6]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_up_aQPx
                     = \ (x1_aQje :: Int#) ->
                         case ># x1_aQje y'_aQjc of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ a_aQU6
                               (toEnum @ a_aQU6 $dEnum_aQU8 (GHC.Types.I# x1_aQje))
                               (go_up_aQPx (+# x1_aQje delta_aQjb));
                           1# ->
                             GHC.Types.:
                               @ a_aQU6
                               (toEnum @ a_aQU6 $dEnum_aQU8 (GHC.Types.I# x1_aQje))
                               (GHC.Types.[] @ a_aQU6)
                         }; } in
                 go_up_aQPx x_alMY);
            1# ->
              case <# y1_aQgX y_alN2 of {
                __DEFAULT ->
                  GHC.Types.:
                    @ a_aQU6
                    (toEnum @ a_aQU6 $dEnum_aQU8 wild1_alN0)
                    (GHC.Types.[] @ a_aQU6);
                1# -> GHC.Types.[] @ a_aQU6
              }
          }
          }
      }
      }
      }

-- RHS size: {terms: 174, types: 53, coercions: 0, joins: 2/8}
GHC.Enum.$fEnumBool_$cenumFromThen :: Bool -> Bool -> [Bool]
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [34 34] 649 0}]
GHC.Enum.$fEnumBool_$cenumFromThen
  = \ (n1_aQhE :: Bool) (n2_aQhF :: Bool) ->
      join {
        $j_sSlu [Dmd=<C(S),1*C1(U)>] :: Int# -> [Bool]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sSlu (x_alMY [OS=OneShot] :: Int#)
          = join {
              $j1_sSls [Dmd=<C(S),1*C1(U)>] :: Int# -> [Bool]
              [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
              $j1_sSls (y_alN2 [OS=OneShot] :: Int#)
                = case >=# x_alMY y_alN2 of {
                    __DEFAULT ->
                      case ># 0# x_alMY of {
                        __DEFAULT ->
                          GHC.Types.:
                            @ Bool
                            (case y_alN2 of {
                               __DEFAULT -> GHC.Enum.$fEnumBool1;
                               0# -> GHC.Types.False;
                               1# -> GHC.Types.True
                             })
                            (let {
                               delta_aQjr [Dmd=<S,U>] :: Int#
                               [LclId]
                               delta_aQjr = -# x_alMY y_alN2 } in
                             let {
                               y'_aQjs [Dmd=<S,U>] :: Int#
                               [LclId]
                               y'_aQjs = -# 0# delta_aQjr } in
                             letrec {
                               go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [Bool]
                               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                               go_dn_aQOv
                                 = \ (x1_aQju :: Int#) ->
                                     case <# x1_aQju y'_aQjs of {
                                       __DEFAULT ->
                                         GHC.Types.:
                                           @ Bool
                                           (case x1_aQju of {
                                              __DEFAULT -> GHC.Enum.$fEnumBool1;
                                              0# -> GHC.Types.False;
                                              1# -> GHC.Types.True
                                            })
                                           (go_dn_aQOv (+# x1_aQju delta_aQjr));
                                       1# ->
                                         GHC.Types.:
                                           @ Bool
                                           (case x1_aQju of {
                                              __DEFAULT -> GHC.Enum.$fEnumBool1;
                                              0# -> GHC.Types.False;
                                              1# -> GHC.Types.True
                                            })
                                           (GHC.Types.[] @ Bool)
                                     }; } in
                             go_dn_aQOv x_alMY);
                        1# ->
                          case ># 0# y_alN2 of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Bool
                                (case y_alN2 of {
                                   __DEFAULT -> GHC.Enum.$fEnumBool1;
                                   0# -> GHC.Types.False;
                                   1# -> GHC.Types.True
                                 })
                                (GHC.Types.[] @ Bool);
                            1# -> GHC.Types.[] @ Bool
                          }
                      };
                    1# ->
                      case <# 1# x_alMY of {
                        __DEFAULT ->
                          GHC.Types.:
                            @ Bool
                            (case y_alN2 of {
                               __DEFAULT -> GHC.Enum.$fEnumBool1;
                               0# -> GHC.Types.False;
                               1# -> GHC.Types.True
                             })
                            (let {
                               delta_aQjb [Dmd=<S,U>] :: Int#
                               [LclId]
                               delta_aQjb = -# x_alMY y_alN2 } in
                             let {
                               y'_aQjc [Dmd=<S,U>] :: Int#
                               [LclId]
                               y'_aQjc = -# 1# delta_aQjb } in
                             letrec {
                               go_up_aQPx [Occ=LoopBreaker] :: Int# -> [Bool]
                               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                               go_up_aQPx
                                 = \ (x1_aQje :: Int#) ->
                                     case ># x1_aQje y'_aQjc of {
                                       __DEFAULT ->
                                         GHC.Types.:
                                           @ Bool
                                           (case x1_aQje of {
                                              __DEFAULT -> GHC.Enum.$fEnumBool1;
                                              0# -> GHC.Types.False;
                                              1# -> GHC.Types.True
                                            })
                                           (go_up_aQPx (+# x1_aQje delta_aQjb));
                                       1# ->
                                         GHC.Types.:
                                           @ Bool
                                           (case x1_aQje of {
                                              __DEFAULT -> GHC.Enum.$fEnumBool1;
                                              0# -> GHC.Types.False;
                                              1# -> GHC.Types.True
                                            })
                                           (GHC.Types.[] @ Bool)
                                     }; } in
                             go_up_aQPx x_alMY);
                        1# ->
                          case <# 1# y_alN2 of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Bool
                                (case y_alN2 of {
                                   __DEFAULT -> GHC.Enum.$fEnumBool1;
                                   0# -> GHC.Types.False;
                                   1# -> GHC.Types.True
                                 })
                                (GHC.Types.[] @ Bool);
                            1# -> GHC.Types.[] @ Bool
                          }
                      }
                  } } in
            case n1_aQhE of {
              False -> jump $j1_sSls 0#;
              True -> jump $j1_sSls 1#
            } } in
      case n2_aQhF of {
        False -> jump $j_sSlu 0#;
        True -> jump $j_sSlu 1#
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumBool [InlPrag=NOUSERINLINE CONLIKE] :: Enum Bool
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Bool
                       GHC.Enum.$fEnumBool_$csucc
                       GHC.Enum.$fEnumBool_$cpred
                       GHC.Enum.$fEnumBool_$ctoEnum
                       GHC.Enum.$fEnumBool_$cfromEnum
                       GHC.Enum.$fEnumBool_$cenumFrom
                       GHC.Enum.$fEnumBool_$cenumFromThen
                       GHC.Enum.$fEnumBool_$cenumFromTo
                       GHC.Enum.$fEnumBool_$cenumFromThenTo]
GHC.Enum.$fEnumBool
  = GHC.Enum.C:Enum
      @ Bool
      GHC.Enum.$fEnumBool_$csucc
      GHC.Enum.$fEnumBool_$cpred
      GHC.Enum.$fEnumBool_$ctoEnum
      GHC.Enum.$fEnumBool_$cfromEnum
      GHC.Enum.$fEnumBool_$cenumFrom
      GHC.Enum.$fEnumBool_$cenumFromThen
      GHC.Enum.$fEnumBool_$cenumFromTo
      GHC.Enum.$fEnumBool_$cenumFromThenTo

-- RHS size: {terms: 196, types: 53, coercions: 0, joins: 2/8}
GHC.Enum.$fEnumOrdering_$cenumFromThen
  :: Ordering -> Ordering -> [Ordering]
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
GHC.Enum.$fEnumOrdering_$cenumFromThen
  = \ (n1_aQhE :: Ordering) (n2_aQhF :: Ordering) ->
      join {
        $j_sSlz [Dmd=<C(S),1*C1(U)>] :: Int# -> [Ordering]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sSlz (x_alMY [OS=OneShot] :: Int#)
          = join {
              $j1_sSlx [Dmd=<C(S),1*C1(U)>] :: Int# -> [Ordering]
              [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
              $j1_sSlx (y_alN2 [OS=OneShot] :: Int#)
                = case >=# x_alMY y_alN2 of {
                    __DEFAULT ->
                      case ># 0# x_alMY of {
                        __DEFAULT ->
                          GHC.Types.:
                            @ Ordering
                            (case y_alN2 of {
                               __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                               0# -> GHC.Types.LT;
                               1# -> GHC.Types.EQ;
                               2# -> GHC.Types.GT
                             })
                            (let {
                               delta_aQjr [Dmd=<S,U>] :: Int#
                               [LclId]
                               delta_aQjr = -# x_alMY y_alN2 } in
                             let {
                               y'_aQjs [Dmd=<S,U>] :: Int#
                               [LclId]
                               y'_aQjs = -# 0# delta_aQjr } in
                             letrec {
                               go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [Ordering]
                               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                               go_dn_aQOv
                                 = \ (x1_aQju :: Int#) ->
                                     case <# x1_aQju y'_aQjs of {
                                       __DEFAULT ->
                                         GHC.Types.:
                                           @ Ordering
                                           (case x1_aQju of {
                                              __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                              0# -> GHC.Types.LT;
                                              1# -> GHC.Types.EQ;
                                              2# -> GHC.Types.GT
                                            })
                                           (go_dn_aQOv (+# x1_aQju delta_aQjr));
                                       1# ->
                                         GHC.Types.:
                                           @ Ordering
                                           (case x1_aQju of {
                                              __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                              0# -> GHC.Types.LT;
                                              1# -> GHC.Types.EQ;
                                              2# -> GHC.Types.GT
                                            })
                                           (GHC.Types.[] @ Ordering)
                                     }; } in
                             go_dn_aQOv x_alMY);
                        1# ->
                          case ># 0# y_alN2 of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Ordering
                                (case y_alN2 of {
                                   __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                   0# -> GHC.Types.LT;
                                   1# -> GHC.Types.EQ;
                                   2# -> GHC.Types.GT
                                 })
                                (GHC.Types.[] @ Ordering);
                            1# -> GHC.Types.[] @ Ordering
                          }
                      };
                    1# ->
                      case <# 2# x_alMY of {
                        __DEFAULT ->
                          GHC.Types.:
                            @ Ordering
                            (case y_alN2 of {
                               __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                               0# -> GHC.Types.LT;
                               1# -> GHC.Types.EQ;
                               2# -> GHC.Types.GT
                             })
                            (let {
                               delta_aQjb [Dmd=<S,U>] :: Int#
                               [LclId]
                               delta_aQjb = -# x_alMY y_alN2 } in
                             let {
                               y'_aQjc [Dmd=<S,U>] :: Int#
                               [LclId]
                               y'_aQjc = -# 2# delta_aQjb } in
                             letrec {
                               go_up_aQPx [Occ=LoopBreaker] :: Int# -> [Ordering]
                               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                               go_up_aQPx
                                 = \ (x1_aQje :: Int#) ->
                                     case ># x1_aQje y'_aQjc of {
                                       __DEFAULT ->
                                         GHC.Types.:
                                           @ Ordering
                                           (case x1_aQje of {
                                              __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                              0# -> GHC.Types.LT;
                                              1# -> GHC.Types.EQ;
                                              2# -> GHC.Types.GT
                                            })
                                           (go_up_aQPx (+# x1_aQje delta_aQjb));
                                       1# ->
                                         GHC.Types.:
                                           @ Ordering
                                           (case x1_aQje of {
                                              __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                              0# -> GHC.Types.LT;
                                              1# -> GHC.Types.EQ;
                                              2# -> GHC.Types.GT
                                            })
                                           (GHC.Types.[] @ Ordering)
                                     }; } in
                             go_up_aQPx x_alMY);
                        1# ->
                          case <# 2# y_alN2 of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ Ordering
                                (case y_alN2 of {
                                   __DEFAULT -> GHC.Enum.$fEnumOrdering5;
                                   0# -> GHC.Types.LT;
                                   1# -> GHC.Types.EQ;
                                   2# -> GHC.Types.GT
                                 })
                                (GHC.Types.[] @ Ordering);
                            1# -> GHC.Types.[] @ Ordering
                          }
                      }
                  } } in
            case n1_aQhE of {
              LT -> jump $j1_sSlx 0#;
              EQ -> jump $j1_sSlx 1#;
              GT -> jump $j1_sSlx 2#
            } } in
      case n2_aQhF of {
        LT -> jump $j_sSlz 0#;
        EQ -> jump $j_sSlz 1#;
        GT -> jump $j_sSlz 2#
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum Ordering
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Ordering
                       GHC.Enum.$fEnumOrdering_$csucc
                       GHC.Enum.$fEnumOrdering_$cpred
                       GHC.Enum.$fEnumOrdering_$ctoEnum
                       GHC.Enum.$fEnumOrdering_$cfromEnum
                       GHC.Enum.$fEnumOrdering_$cenumFrom
                       GHC.Enum.$fEnumOrdering_$cenumFromThen
                       GHC.Enum.$fEnumOrdering_$cenumFromTo
                       GHC.Enum.$fEnumOrdering_$cenumFromThenTo]
GHC.Enum.$fEnumOrdering
  = GHC.Enum.C:Enum
      @ Ordering
      GHC.Enum.$fEnumOrdering_$csucc
      GHC.Enum.$fEnumOrdering_$cpred
      GHC.Enum.$fEnumOrdering_$ctoEnum
      GHC.Enum.$fEnumOrdering_$cfromEnum
      GHC.Enum.$fEnumOrdering_$cenumFrom
      GHC.Enum.$fEnumOrdering_$cenumFromThen
      GHC.Enum.$fEnumOrdering_$cenumFromTo
      GHC.Enum.$fEnumOrdering_$cenumFromThenTo

-- RHS size: {terms: 42, types: 24, coercions: 0, joins: 0/1}
boundedEnumFrom :: forall a. (Enum a, Bounded a) => a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S(S))LLLL),U(A,A,C(U),C(U(U)),A,A,A,A)><L,1*U(A,1*U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 30 0] 253 10}]
boundedEnumFrom
  = \ (@ a_aQUT)
      ($dEnum_aQUV :: Enum a_aQUT)
      ($dBounded_aQUW :: Bounded a_aQUT)
      (n_aQhD :: a_aQUT) ->
      case fromEnum @ a_aQUT $dEnum_aQUV n_aQhD of { I# x_aQgR ->
      case fromEnum
             @ a_aQUT $dEnum_aQUV (maxBound @ a_aQUT $dBounded_aQUW)
      of
      { I# y_aQgS ->
      case ># x_aQgR y_aQgS of {
        __DEFAULT ->
          letrec {
            go_aQQv [Occ=LoopBreaker] :: Int# -> [a_aQUT]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_aQQv
              = \ (x1_aQiM :: Int#) ->
                  GHC.Types.:
                    @ a_aQUT
                    (toEnum @ a_aQUT $dEnum_aQUV (GHC.Types.I# x1_aQiM))
                    (case ==# x1_aQiM y_aQgS of {
                       __DEFAULT -> go_aQQv (+# x1_aQiM 1#);
                       1# -> GHC.Types.[] @ a_aQUT
                     }); } in
          go_aQQv x_aQgR;
        1# -> GHC.Types.[] @ a_aQUT
      }
      }
      }

-- RHS size: {terms: 26, types: 16, coercions: 0, joins: 0/1}
GHC.Enum.$dmenumFrom :: forall a. Enum a => a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S(S))LLLL),U(A,A,C(U),1*C1(U(U)),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aQga)
                 ($dEnum_aQVO :: Enum a_aQga)
                 (x_aQgb [Occ=Once] :: a_aQga) ->
                 build
                   @ a_aQga
                   (\ (@ b1_iREh)
                      (c_iREi [Occ=Once, OS=OneShot] :: a_aQga -> b1_iREh -> b1_iREh)
                      (n_iREj [Occ=Once, OS=OneShot] :: b1_iREh) ->
                      case fromEnum @ a_aQga $dEnum_aQVO x_aQgb of
                      { I# x1_aQgP [Occ=Once] ->
                      eftIntFB
                        @ b1_iREh
                        (mapFB
                           @ a_aQga @ b1_iREh @ Int c_iREi (toEnum @ a_aQga $dEnum_aQVO))
                        n_iREj
                        x1_aQgP
                        9223372036854775807#
                      })}]
GHC.Enum.$dmenumFrom
  = \ (@ a_aQga) ($dEnum_aQVO :: Enum a_aQga) (x_aQgb :: a_aQga) ->
      case fromEnum @ a_aQga $dEnum_aQVO x_aQgb of { I# x1_aQgP ->
      letrec {
        go_aQQv [Occ=LoopBreaker] :: Int# -> [a_aQga]
        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
        go_aQQv
          = \ (x2_aQiM :: Int#) ->
              GHC.Types.:
                @ a_aQga
                (toEnum @ a_aQga $dEnum_aQVO (GHC.Types.I# x2_aQiM))
                (case x2_aQiM of wild1_X82 {
                   __DEFAULT -> go_aQQv (+# wild1_X82 1#);
                   9223372036854775807# -> GHC.Types.[] @ a_aQga
                 }); } in
      go_aQQv x1_aQgP
      }

-- RHS size: {terms: 20, types: 15, coercions: 0, joins: 0/0}
GHC.Enum.$dmenumFromThen :: forall a. Enum a => a -> a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S(S))LLLL),U(A,A,1*C(U),C(U(U)),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aQga)
                 ($dEnum_aQVO :: Enum a_aQga)
                 (x_aQgc [Occ=Once] :: a_aQga)
                 (y_aQgd [Occ=Once] :: a_aQga) ->
                 build
                   @ a_aQga
                   (\ (@ b1_iREh)
                      (c_iREi [Occ=Once, OS=OneShot] :: a_aQga -> b1_iREh -> b1_iREh)
                      (n_iREj [Occ=Once, OS=OneShot] :: b1_iREh) ->
                      case fromEnum @ a_aQga $dEnum_aQVO x_aQgc of
                      { I# x1_aQgT [Occ=Once] ->
                      case fromEnum @ a_aQga $dEnum_aQVO y_aQgd of
                      { I# x2_aQgU [Occ=Once] ->
                      foldr
                        @ Int
                        @ b1_iREh
                        (mapFB
                           @ a_aQga @ b1_iREh @ Int c_iREi (toEnum @ a_aQga $dEnum_aQVO))
                        n_iREj
                        (efdInt x1_aQgT x2_aQgU)
                      }
                      })}]
GHC.Enum.$dmenumFromThen
  = \ (@ a_aQga)
      ($dEnum_aQVO :: Enum a_aQga)
      (x_aQgc :: a_aQga)
      (y_aQgd :: a_aQga) ->
      case fromEnum @ a_aQga $dEnum_aQVO x_aQgc of { I# x1_aQgT ->
      case fromEnum @ a_aQga $dEnum_aQVO y_aQgd of { I# x2_aQgU ->
      map
        @ Int
        @ a_aQga
        (toEnum @ a_aQga $dEnum_aQVO)
        (efdInt x1_aQgT x2_aQgU)
      }
      }

-- RHS size: {terms: 41, types: 22, coercions: 0, joins: 0/1}
GHC.Enum.$dmenumFromTo :: forall a. Enum a => a -> a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S(S))LLLL),U(A,A,C(U),C(U(U)),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aQga)
                 ($dEnum_aQVO :: Enum a_aQga)
                 (x_aQge [Occ=Once] :: a_aQga)
                 (y_aQgf [Occ=Once] :: a_aQga) ->
                 build
                   @ a_aQga
                   (\ (@ b1_iREh)
                      (c_iREi [Occ=Once, OS=OneShot] :: a_aQga -> b1_iREh -> b1_iREh)
                      (n_iREj [Occ=Once, OS=OneShot] :: b1_iREh) ->
                      case fromEnum @ a_aQga $dEnum_aQVO x_aQge of
                      { I# x1_aQgR [Occ=Once] ->
                      case fromEnum @ a_aQga $dEnum_aQVO y_aQgf of
                      { I# y1_aQgS [Occ=Once] ->
                      eftIntFB
                        @ b1_iREh
                        (mapFB
                           @ a_aQga @ b1_iREh @ Int c_iREi (toEnum @ a_aQga $dEnum_aQVO))
                        n_iREj
                        x1_aQgR
                        y1_aQgS
                      }
                      })}]
GHC.Enum.$dmenumFromTo
  = \ (@ a_aQga)
      ($dEnum_aQVO :: Enum a_aQga)
      (x_aQge :: a_aQga)
      (y_aQgf :: a_aQga) ->
      case fromEnum @ a_aQga $dEnum_aQVO x_aQge of { I# x1_aQgR ->
      case fromEnum @ a_aQga $dEnum_aQVO y_aQgf of { I# y1_aQgS ->
      case ># x1_aQgR y1_aQgS of {
        __DEFAULT ->
          letrec {
            go_aQQv [Occ=LoopBreaker] :: Int# -> [a_aQga]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_aQQv
              = \ (x2_aQiM :: Int#) ->
                  GHC.Types.:
                    @ a_aQga
                    (toEnum @ a_aQga $dEnum_aQVO (GHC.Types.I# x2_aQiM))
                    (case ==# x2_aQiM y1_aQgS of {
                       __DEFAULT -> go_aQQv (+# x2_aQiM 1#);
                       1# -> GHC.Types.[] @ a_aQga
                     }); } in
          go_aQQv x1_aQgR;
        1# -> GHC.Types.[] @ a_aQga
      }
      }
      }

-- RHS size: {terms: 136, types: 57, coercions: 0, joins: 0/6}
GHC.Enum.$dmenumFromThenTo
  :: forall a. Enum a => a -> a -> a -> [a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLC(S(S))LLLL),U(A,A,C(U),C(U(U)),A,A,A,A)><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_aQga)
                 ($dEnum_aQVO :: Enum a_aQga)
                 (x1_aQgg [Occ=Once] :: a_aQga)
                 (x2_aQgh [Occ=Once] :: a_aQga)
                 (y_aQgi [Occ=Once] :: a_aQga) ->
                 build
                   @ a_aQga
                   (\ (@ b1_iREh)
                      (c_iREi [Occ=Once, OS=OneShot] :: a_aQga -> b1_iREh -> b1_iREh)
                      (n_iREj [Occ=Once, OS=OneShot] :: b1_iREh) ->
                      case fromEnum @ a_aQga $dEnum_aQVO x1_aQgg of
                      { I# x4_aQgV [Occ=Once] ->
                      case fromEnum @ a_aQga $dEnum_aQVO x2_aQgh of
                      { I# x5_aQgW [Occ=Once] ->
                      case fromEnum @ a_aQga $dEnum_aQVO y_aQgi of
                      { I# y1_aQgX [Occ=Once] ->
                      efdtIntFB
                        @ b1_iREh
                        (mapFB
                           @ a_aQga @ b1_iREh @ Int c_iREi (toEnum @ a_aQga $dEnum_aQVO))
                        n_iREj
                        x4_aQgV
                        x5_aQgW
                        y1_aQgX
                      }
                      }
                      })}]
GHC.Enum.$dmenumFromThenTo
  = \ (@ a_aQga)
      ($dEnum_aQVO :: Enum a_aQga)
      (x1_aQgg :: a_aQga)
      (x2_aQgh :: a_aQga)
      (y_aQgi :: a_aQga) ->
      case fromEnum @ a_aQga $dEnum_aQVO x1_aQgg of wild_X5x
      { I# x4_aQgV ->
      case fromEnum @ a_aQga $dEnum_aQVO x2_aQgh of { I# x5_aQgW ->
      case fromEnum @ a_aQga $dEnum_aQVO y_aQgi of { I# y1_aQgX ->
      case >=# x5_aQgW x4_aQgV of {
        __DEFAULT ->
          case ># y1_aQgX x5_aQgW of {
            __DEFAULT ->
              GHC.Types.:
                @ a_aQga
                (toEnum @ a_aQga $dEnum_aQVO wild_X5x)
                (let {
                   delta_aQjr [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                 let {
                   y'_aQjs [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_aQjs = -# y1_aQgX delta_aQjr } in
                 letrec {
                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [a_aQga]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_dn_aQOv
                     = \ (x_aQju :: Int#) ->
                         case <# x_aQju y'_aQjs of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ a_aQga
                               (toEnum @ a_aQga $dEnum_aQVO (GHC.Types.I# x_aQju))
                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                           1# ->
                             GHC.Types.:
                               @ a_aQga
                               (toEnum @ a_aQga $dEnum_aQVO (GHC.Types.I# x_aQju))
                               (GHC.Types.[] @ a_aQga)
                         }; } in
                 go_dn_aQOv x5_aQgW);
            1# ->
              case ># y1_aQgX x4_aQgV of {
                __DEFAULT ->
                  GHC.Types.:
                    @ a_aQga
                    (toEnum @ a_aQga $dEnum_aQVO wild_X5x)
                    (GHC.Types.[] @ a_aQga);
                1# -> GHC.Types.[] @ a_aQga
              }
          };
        1# ->
          case <# y1_aQgX x5_aQgW of {
            __DEFAULT ->
              GHC.Types.:
                @ a_aQga
                (toEnum @ a_aQga $dEnum_aQVO wild_X5x)
                (let {
                   delta_aQjb [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                 let {
                   y'_aQjc [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_aQjc = -# y1_aQgX delta_aQjb } in
                 letrec {
                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [a_aQga]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_up_aQPx
                     = \ (x_aQje :: Int#) ->
                         case ># x_aQje y'_aQjc of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ a_aQga
                               (toEnum @ a_aQga $dEnum_aQVO (GHC.Types.I# x_aQje))
                               (go_up_aQPx (+# x_aQje delta_aQjb));
                           1# ->
                             GHC.Types.:
                               @ a_aQga
                               (toEnum @ a_aQga $dEnum_aQVO (GHC.Types.I# x_aQje))
                               (GHC.Types.[] @ a_aQga)
                         }; } in
                 go_up_aQPx x5_aQgW);
            1# ->
              case <# y1_aQgX x4_aQgV of {
                __DEFAULT ->
                  GHC.Types.:
                    @ a_aQga
                    (toEnum @ a_aQga $dEnum_aQVO wild_X5x)
                    (GHC.Types.[] @ a_aQga);
                1# -> GHC.Types.[] @ a_aQga
              }
          }
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl31_rURb :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl31_rURb = "Word"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl32_rURc :: [Char]
[GblId]
lvl32_rURc = unpackCString# lvl31_rURb

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord1 :: Word -> Int
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Enum.$fEnumWord1
  = \ (x_aQgA :: Word) ->
      fromEnumError @ Word @ Int GHC.Show.$fShowWord lvl32_rURc x_aQgA

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord_$cfromEnum :: Word -> Int
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_aQgA [Occ=Once!] :: Word) ->
                 case x_aQgA of wild_X5O { W# x#_aQgB ->
                 case leWord# x#_aQgB 9223372036854775807## of {
                   __DEFAULT -> GHC.Enum.$fEnumWord1 wild_X5O;
                   1# -> GHC.Types.I# (word2Int# x#_aQgB)
                 }
                 }}]
GHC.Enum.$fEnumWord_$cfromEnum
  = \ (x_aQgA :: Word) ->
      case x_aQgA of wild_X5O { W# x#_aQgB ->
      case leWord# x#_aQgB 9223372036854775807## of {
        __DEFAULT -> GHC.Enum.$fEnumWord1 wild_X5O;
        1# -> GHC.Types.I# (word2Int# x#_aQgB)
      }
      }

Rec {
-- RHS size: {terms: 27, types: 11, coercions: 0, joins: 0/1}
eftWord [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: Word# -> Word# -> [Word]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 123 10}]
eftWord
  = \ (x0_aQjw :: Word#) (y_aQjx :: Word#) ->
      case gtWord# x0_aQjw y_aQjx of {
        __DEFAULT ->
          letrec {
            go_sRWy [Occ=LoopBreaker] :: Word# -> [Word]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_sRWy
              = \ (x_aQjz :: Word#) ->
                  GHC.Types.:
                    @ Word
                    (GHC.Types.W# x_aQjz)
                    (case eqWord# x_aQjz y_aQjx of {
                       __DEFAULT -> go_sRWy (plusWord# x_aQjz 1##);
                       1# -> GHC.Types.[] @ Word
                     }); } in
          go_sRWy x0_aQjw;
        1# -> GHC.Types.[] @ Word
      }

-- RHS size: {terms: 30, types: 13, coercions: 0, joins: 0/1}
eftWordFB [InlPrag=INLINE[0] (sat-args=4), Occ=LoopBreaker!]
  :: forall r. (Word -> r -> r) -> r -> Word# -> Word# -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ r_aQND)
                 (c_aQjA [Occ=OnceL!] :: Word -> r_aQND -> r_aQND)
                 (n_aQjB [Occ=OnceL*] :: r_aQND)
                 (x0_aQjC :: Word#)
                 (y_aQjD :: Word#) ->
                 case gtWord# x0_aQjC y_aQjD of {
                   __DEFAULT ->
                     letrec {
                       go_aQNH [Occ=LoopBreaker] :: Word# -> r_aQND
                       [LclId, Arity=1, Unf=OtherCon []]
                       go_aQNH
                         = \ (x_aQjF :: Word#) ->
                             c_aQjA
                               (GHC.Types.W# x_aQjF)
                               (case eqWord# x_aQjF y_aQjD of {
                                  __DEFAULT -> go_aQNH (plusWord# x_aQjF 1##);
                                  1# -> n_aQjB
                                }); } in
                     go_aQNH x0_aQjC;
                   1# -> n_aQjB
                 }}]
eftWordFB
  = \ (@ r_aQND)
      (c_aQjA :: Word -> r_aQND -> r_aQND)
      (n_aQjB :: r_aQND)
      (x0_aQjC :: Word#)
      (y_aQjD :: Word#) ->
      case gtWord# x0_aQjC y_aQjD of {
        __DEFAULT ->
          letrec {
            go_sRWA [Occ=LoopBreaker] :: Word# -> r_aQND
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_sRWA
              = \ (x_aQjF :: Word#) ->
                  c_aQjA
                    (GHC.Types.W# x_aQjF)
                    (case eqWord# x_aQjF y_aQjD of {
                       __DEFAULT -> go_sRWA (plusWord# x_aQjF 1##);
                       1# -> n_aQjB
                     }); } in
          go_sRWA x0_aQjC;
        1# -> n_aQjB
      }
end Rec }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord_$cenumFrom [InlPrag=INLINE (sat-args=1)]
  :: Word -> [Word]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRy2 [Occ=Once!] :: Word) ->
                 case ds_dRy2 of { W# x#_aQgC [Occ=Once] ->
                 build
                   @ Word
                   (\ (@ b_aRqZ)
                      (c_aQlx [Occ=Once, OS=OneShot] :: Word -> b_aRqZ -> b_aRqZ)
                      (n_aQly [Occ=Once, OS=OneShot] :: b_aRqZ) ->
                      eftWordFB @ b_aRqZ c_aQlx n_aQly x#_aQgC 18446744073709551615##)
                 }}]
GHC.Enum.$fEnumWord_$cenumFrom
  = \ (ds_dRy2 :: Word) ->
      case ds_dRy2 of { W# x#_aQgC ->
      eftWord x#_aQgC 18446744073709551615##
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord_$cenumFromTo [InlPrag=INLINE (sat-args=2)]
  :: Word -> Word -> [Word]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRyf [Occ=Once!] :: Word)
                 (ds1_dRyg [Occ=Once!] :: Word) ->
                 case ds_dRyf of { W# x_aQgE [Occ=Once] ->
                 case ds1_dRyg of { W# y_aQgF [Occ=Once] ->
                 build
                   @ Word
                   (\ (@ b_aRqZ)
                      (c_aQlx [Occ=Once, OS=OneShot] :: Word -> b_aRqZ -> b_aRqZ)
                      (n_aQly [Occ=Once, OS=OneShot] :: b_aRqZ) ->
                      eftWordFB @ b_aRqZ c_aQlx n_aQly x_aQgE y_aQgF)
                 }
                 }}]
GHC.Enum.$fEnumWord_$cenumFromTo
  = \ (ds_dRyf :: Word) (ds1_dRyg :: Word) ->
      case ds_dRyf of { W# x_aQgE ->
      case ds1_dRyg of { W# y_aQgF -> eftWord x_aQgE y_aQgF }
      }

-- RHS size: {terms: 52, types: 19, coercions: 0, joins: 0/3}
efdtWordUp :: Word# -> Word# -> Word# -> [Word]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 206 70}]
efdtWordUp
  = \ (x1_aQjS :: Word#) (x2_aQjT :: Word#) (y_aQjU :: Word#) ->
      case ltWord# y_aQjU x2_aQjT of {
        __DEFAULT ->
          GHC.Types.:
            @ Word
            (GHC.Types.W# x1_aQjS)
            (let {
               delta_sRWw [Dmd=<S,U>] :: Word#
               [LclId]
               delta_sRWw = minusWord# x2_aQjT x1_aQjS } in
             let {
               y'_sRWv [Dmd=<S,U>] :: Word#
               [LclId]
               y'_sRWv = minusWord# y_aQjU delta_sRWw } in
             letrec {
               go_up_sRWu [Occ=LoopBreaker] :: Word# -> [Word]
               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
               go_up_sRWu
                 = \ (x_aQjY :: Word#) ->
                     case gtWord# x_aQjY y'_sRWv of {
                       __DEFAULT ->
                         GHC.Types.:
                           @ Word
                           (GHC.Types.W# x_aQjY)
                           (go_up_sRWu (plusWord# x_aQjY delta_sRWw));
                       1# ->
                         GHC.Types.: @ Word (GHC.Types.W# x_aQjY) (GHC.Types.[] @ Word)
                     }; } in
             go_up_sRWu x2_aQjT);
        1# ->
          case ltWord# y_aQjU x1_aQjS of {
            __DEFAULT ->
              GHC.Types.: @ Word (GHC.Types.W# x1_aQjS) (GHC.Types.[] @ Word);
            1# -> GHC.Types.[] @ Word
          }
      }

-- RHS size: {terms: 55, types: 17, coercions: 0, joins: 0/3}
efdtWordUpFB [InlPrag=INLINE[0] (sat-args=5)]
  :: forall r. (Word -> r -> r) -> r -> Word# -> Word# -> Word# -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ r_aQMn)
                 (c_aQjZ :: Word -> r_aQMn -> r_aQMn)
                 (n_aQk0 [Occ=OnceL*] :: r_aQMn)
                 (x1_aQk1 :: Word#)
                 (x2_aQk2 :: Word#)
                 (y_aQk3 :: Word#) ->
                 case ltWord# y_aQk3 x2_aQk2 of {
                   __DEFAULT ->
                     let {
                       delta_aQk4 :: Word#
                       [LclId]
                       delta_aQk4 = minusWord# x2_aQk2 x1_aQk1 } in
                     let {
                       y'_aQk5 [Occ=OnceL] :: Word#
                       [LclId]
                       y'_aQk5 = minusWord# y_aQk3 delta_aQk4 } in
                     c_aQjZ
                       (GHC.Types.W# x1_aQk1)
                       (letrec {
                          go_up_aQMF [Occ=LoopBreaker] :: Word# -> r_aQMn
                          [LclId, Arity=1, Unf=OtherCon []]
                          go_up_aQMF
                            = \ (x_aQk7 :: Word#) ->
                                case gtWord# x_aQk7 y'_aQk5 of {
                                  __DEFAULT ->
                                    c_aQjZ
                                      (GHC.Types.W# x_aQk7)
                                      (go_up_aQMF (plusWord# x_aQk7 delta_aQk4));
                                  1# -> c_aQjZ (GHC.Types.W# x_aQk7) n_aQk0
                                }; } in
                        go_up_aQMF x2_aQk2);
                   1# ->
                     case ltWord# y_aQk3 x1_aQk1 of {
                       __DEFAULT -> c_aQjZ (GHC.Types.W# x1_aQk1) n_aQk0;
                       1# -> n_aQk0
                     }
                 }}]
efdtWordUpFB
  = \ (@ r_aQMn)
      (c_aQjZ :: Word -> r_aQMn -> r_aQMn)
      (n_aQk0 :: r_aQMn)
      (x1_aQk1 :: Word#)
      (x2_aQk2 :: Word#)
      (y_aQk3 :: Word#) ->
      case ltWord# y_aQk3 x2_aQk2 of {
        __DEFAULT ->
          c_aQjZ
            (GHC.Types.W# x1_aQk1)
            (let {
               delta_sRWq [Dmd=<S,U>] :: Word#
               [LclId]
               delta_sRWq = minusWord# x2_aQk2 x1_aQk1 } in
             let {
               y'_sRWp [Dmd=<S,U>] :: Word#
               [LclId]
               y'_sRWp = minusWord# y_aQk3 delta_sRWq } in
             letrec {
               go_up_sRWo [Occ=LoopBreaker] :: Word# -> r_aQMn
               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
               go_up_sRWo
                 = \ (x_aQk7 :: Word#) ->
                     case gtWord# x_aQk7 y'_sRWp of {
                       __DEFAULT ->
                         c_aQjZ
                           (GHC.Types.W# x_aQk7) (go_up_sRWo (plusWord# x_aQk7 delta_sRWq));
                       1# -> c_aQjZ (GHC.Types.W# x_aQk7) n_aQk0
                     }; } in
             go_up_sRWo x2_aQk2);
        1# ->
          case ltWord# y_aQk3 x1_aQk1 of {
            __DEFAULT -> c_aQjZ (GHC.Types.W# x1_aQk1) n_aQk0;
            1# -> n_aQk0
          }
      }

-- RHS size: {terms: 52, types: 19, coercions: 0, joins: 0/3}
efdtWordDn :: Word# -> Word# -> Word# -> [Word]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 206 70}]
efdtWordDn
  = \ (x1_aQk8 :: Word#) (x2_aQk9 :: Word#) (y_aQka :: Word#) ->
      case gtWord# y_aQka x2_aQk9 of {
        __DEFAULT ->
          GHC.Types.:
            @ Word
            (GHC.Types.W# x1_aQk8)
            (let {
               delta_sRWk [Dmd=<S,U>] :: Word#
               [LclId]
               delta_sRWk = minusWord# x2_aQk9 x1_aQk8 } in
             let {
               y'_sRWj [Dmd=<S,U>] :: Word#
               [LclId]
               y'_sRWj = minusWord# y_aQka delta_sRWk } in
             letrec {
               go_dn_sRWi [Occ=LoopBreaker] :: Word# -> [Word]
               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
               go_dn_sRWi
                 = \ (x_aQke :: Word#) ->
                     case ltWord# x_aQke y'_sRWj of {
                       __DEFAULT ->
                         GHC.Types.:
                           @ Word
                           (GHC.Types.W# x_aQke)
                           (go_dn_sRWi (plusWord# x_aQke delta_sRWk));
                       1# ->
                         GHC.Types.: @ Word (GHC.Types.W# x_aQke) (GHC.Types.[] @ Word)
                     }; } in
             go_dn_sRWi x2_aQk9);
        1# ->
          case gtWord# y_aQka x1_aQk8 of {
            __DEFAULT ->
              GHC.Types.: @ Word (GHC.Types.W# x1_aQk8) (GHC.Types.[] @ Word);
            1# -> GHC.Types.[] @ Word
          }
      }

-- RHS size: {terms: 55, types: 17, coercions: 0, joins: 0/3}
efdtWordDnFB [InlPrag=INLINE[0] (sat-args=5)]
  :: forall r. (Word -> r -> r) -> r -> Word# -> Word# -> Word# -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ r_aQLl)
                 (c_aQkf :: Word -> r_aQLl -> r_aQLl)
                 (n_aQkg [Occ=OnceL*] :: r_aQLl)
                 (x1_aQkh :: Word#)
                 (x2_aQki :: Word#)
                 (y_aQkj :: Word#) ->
                 case gtWord# y_aQkj x2_aQki of {
                   __DEFAULT ->
                     let {
                       delta_aQkk :: Word#
                       [LclId]
                       delta_aQkk = minusWord# x2_aQki x1_aQkh } in
                     let {
                       y'_aQkl [Occ=OnceL] :: Word#
                       [LclId]
                       y'_aQkl = minusWord# y_aQkj delta_aQkk } in
                     c_aQkf
                       (GHC.Types.W# x1_aQkh)
                       (letrec {
                          go_dn_aQLD [Occ=LoopBreaker] :: Word# -> r_aQLl
                          [LclId, Arity=1, Unf=OtherCon []]
                          go_dn_aQLD
                            = \ (x_aQkn :: Word#) ->
                                case ltWord# x_aQkn y'_aQkl of {
                                  __DEFAULT ->
                                    c_aQkf
                                      (GHC.Types.W# x_aQkn)
                                      (go_dn_aQLD (plusWord# x_aQkn delta_aQkk));
                                  1# -> c_aQkf (GHC.Types.W# x_aQkn) n_aQkg
                                }; } in
                        go_dn_aQLD x2_aQki);
                   1# ->
                     case gtWord# y_aQkj x1_aQkh of {
                       __DEFAULT -> c_aQkf (GHC.Types.W# x1_aQkh) n_aQkg;
                       1# -> n_aQkg
                     }
                 }}]
efdtWordDnFB
  = \ (@ r_aQLl)
      (c_aQkf :: Word -> r_aQLl -> r_aQLl)
      (n_aQkg :: r_aQLl)
      (x1_aQkh :: Word#)
      (x2_aQki :: Word#)
      (y_aQkj :: Word#) ->
      case gtWord# y_aQkj x2_aQki of {
        __DEFAULT ->
          c_aQkf
            (GHC.Types.W# x1_aQkh)
            (let {
               delta_sRWe [Dmd=<S,U>] :: Word#
               [LclId]
               delta_sRWe = minusWord# x2_aQki x1_aQkh } in
             let {
               y'_sRWd [Dmd=<S,U>] :: Word#
               [LclId]
               y'_sRWd = minusWord# y_aQkj delta_sRWe } in
             letrec {
               go_dn_sRWc [Occ=LoopBreaker] :: Word# -> r_aQLl
               [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
               go_dn_sRWc
                 = \ (x_aQkn :: Word#) ->
                     case ltWord# x_aQkn y'_sRWd of {
                       __DEFAULT ->
                         c_aQkf
                           (GHC.Types.W# x_aQkn) (go_dn_sRWc (plusWord# x_aQkn delta_sRWe));
                       1# -> c_aQkf (GHC.Types.W# x_aQkn) n_aQkg
                     }; } in
             go_dn_sRWc x2_aQki);
        1# ->
          case gtWord# y_aQkj x1_aQkh of {
            __DEFAULT -> c_aQkf (GHC.Types.W# x1_aQkh) n_aQkg;
            1# -> n_aQkg
          }
      }

Rec {
-- RHS size: {terms: 17, types: 4, coercions: 0, joins: 0/0}
efdtWord [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: Word# -> Word# -> Word# -> [Word]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 101 0}]
efdtWord
  = \ (x1_aQjK :: Word#) (x2_aQjL :: Word#) (y_aQjM :: Word#) ->
      case geWord# x2_aQjL x1_aQjK of {
        __DEFAULT -> efdtWordDn x1_aQjK x2_aQjL y_aQjM;
        1# -> efdtWordUp x1_aQjK x2_aQjL y_aQjM
      }

-- RHS size: {terms: 24, types: 12, coercions: 0, joins: 0/0}
efdtWordFB [InlPrag=INLINE[0] (sat-args=5), Occ=LoopBreaker!]
  :: forall r. (Word -> r -> r) -> r -> Word# -> Word# -> Word# -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ r_aQNp)
                 (c_aQjN [Occ=Once*] :: Word -> r_aQNp -> r_aQNp)
                 (n_aQjO [Occ=Once*] :: r_aQNp)
                 (x1_aQjP :: Word#)
                 (x2_aQjQ :: Word#)
                 (y_aQjR [Occ=Once*] :: Word#) ->
                 case geWord# x2_aQjQ x1_aQjP of {
                   __DEFAULT ->
                     efdtWordDnFB @ r_aQNp c_aQjN n_aQjO x1_aQjP x2_aQjQ y_aQjR;
                   1# -> efdtWordUpFB @ r_aQNp c_aQjN n_aQjO x1_aQjP x2_aQjQ y_aQjR
                 }}]
efdtWordFB
  = \ (@ r_aQNp)
      (c_aQjN :: Word -> r_aQNp -> r_aQNp)
      (n_aQjO :: r_aQNp)
      (x1_aQjP :: Word#)
      (x2_aQjQ :: Word#)
      (y_aQjR :: Word#) ->
      case geWord# x2_aQjQ x1_aQjP of {
        __DEFAULT ->
          efdtWordDnFB @ r_aQNp c_aQjN n_aQjO x1_aQjP x2_aQjQ y_aQjR;
        1# -> efdtWordUpFB @ r_aQNp c_aQjN n_aQjO x1_aQjP x2_aQjQ y_aQjR
      }
end Rec }

-- RHS size: {terms: 16, types: 9, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord_$cenumFromThenTo [InlPrag=INLINE (sat-args=3)]
  :: Word -> Word -> Word -> [Word]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRym [Occ=Once!] :: Word)
                 (ds1_dRyn [Occ=Once!] :: Word)
                 (ds2_dRyo [Occ=Once!] :: Word) ->
                 case ds_dRym of { W# x1_aQgI [Occ=Once] ->
                 case ds1_dRyn of { W# x2_aQgJ [Occ=Once] ->
                 case ds2_dRyo of { W# y_aQgK [Occ=Once] ->
                 build
                   @ Word
                   (\ (@ b_aRqF)
                      (c_aQlt [Occ=Once, OS=OneShot] :: Word -> b_aRqF -> b_aRqF)
                      (n_aQlu [Occ=Once, OS=OneShot] :: b_aRqF) ->
                      efdtWordFB @ b_aRqF c_aQlt n_aQlu x1_aQgI x2_aQgJ y_aQgK)
                 }
                 }
                 }}]
GHC.Enum.$fEnumWord_$cenumFromThenTo
  = \ (ds_dRym :: Word) (ds1_dRyn :: Word) (ds2_dRyo :: Word) ->
      case ds_dRym of { W# x1_aQgI ->
      case ds1_dRyn of { W# x2_aQgJ ->
      case ds2_dRyo of { W# y_aQgK -> efdtWord x1_aQgI x2_aQgJ y_aQgK }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Enum.$fEnumInteger1 = 1

-- RHS size: {terms: 19, types: 9, coercions: 0, joins: 0/1}
enumDeltaToInteger1 [InlPrag=NOINLINE[1]]
  :: Integer -> Integer -> [Integer]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 150 0}]
enumDeltaToInteger1
  = \ (x0_aQkJ :: Integer) (lim_aQkK :: Integer) ->
      letrec {
        go_sRW8 [Occ=LoopBreaker] :: Integer -> [Integer]
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_sRW8
          = \ (x_aQkM :: Integer) ->
              case gtInteger# x_aQkM lim_aQkK of {
                __DEFAULT ->
                  GHC.Types.:
                    @ Integer
                    x_aQkM
                    (go_sRW8 (plusInteger x_aQkM GHC.Enum.$fEnumInteger1));
                1# -> GHC.Types.[] @ Integer
              }; } in
      go_sRW8 x0_aQkJ

-- RHS size: {terms: 22, types: 12, coercions: 0, joins: 0/1}
enumDeltaToInteger1FB [InlPrag=INLINE[0] (sat-args=4)]
  :: forall a. (Integer -> a -> a) -> a -> Integer -> Integer -> a
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_aQKk)
                 (c_aQkA [Occ=OnceL!] :: Integer -> a_aQKk -> a_aQKk)
                 (n_aQkB [Occ=OnceL] :: a_aQKk)
                 (x0_aQkC [Occ=Once] :: Integer)
                 (lim_aQkD [Occ=OnceL] :: Integer) ->
                 letrec {
                   go_aQKo [Occ=LoopBreaker] :: Integer -> a_aQKk
                   [LclId, Arity=1, Unf=OtherCon []]
                   go_aQKo
                     = \ (x_aQkF :: Integer) ->
                         case gtInteger# x_aQkF lim_aQkD of {
                           __DEFAULT -> c_aQkA x_aQkF (go_aQKo (plusInteger x_aQkF 1));
                           1# -> n_aQkB
                         }; } in
                 go_aQKo x0_aQkC}]
enumDeltaToInteger1FB
  = \ (@ a_aQKk)
      (c_aQkA :: Integer -> a_aQKk -> a_aQKk)
      (n_aQkB :: a_aQKk)
      (x0_aQkC :: Integer)
      (lim_aQkD :: Integer) ->
      letrec {
        go_sRW6 [Occ=LoopBreaker] :: Integer -> a_aQKk
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_sRW6
          = \ (x_aQkF :: Integer) ->
              case gtInteger# x_aQkF lim_aQkD of {
                __DEFAULT ->
                  c_aQkA
                    x_aQkF (go_sRW6 (plusInteger x_aQkF GHC.Enum.$fEnumInteger1));
                1# -> n_aQkB
              }; } in
      go_sRW6 x0_aQkC

-- RHS size: {terms: 23, types: 13, coercions: 0, joins: 0/1}
up_fb
  :: forall a.
     (Integer -> a -> a) -> a -> Integer -> Integer -> Integer -> a
[GblId,
 Arity=5,
 Str=<L,C(C1(U))><L,U><S,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 0 0] 170 0}]
up_fb
  = \ (@ a_aQJk)
      (c_aQkN :: Integer -> a_aQJk -> a_aQJk)
      (n_aQkO :: a_aQJk)
      (x0_aQkP :: Integer)
      (delta_aQkQ :: Integer)
      (lim_aQkR :: Integer) ->
      letrec {
        go_sRW4 [Occ=LoopBreaker] :: Integer -> a_aQJk
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_sRW4
          = \ (x_aQkT :: Integer) ->
              case gtInteger# x_aQkT lim_aQkR of {
                __DEFAULT ->
                  c_aQkN x_aQkT (go_sRW4 (plusInteger x_aQkT delta_aQkQ));
                1# -> n_aQkO
              }; } in
      go_sRW4 x0_aQkP

-- RHS size: {terms: 23, types: 13, coercions: 0, joins: 0/1}
dn_fb
  :: forall a.
     (Integer -> a -> a) -> a -> Integer -> Integer -> Integer -> a
[GblId,
 Arity=5,
 Str=<L,C(C1(U))><L,U><S,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 0 0] 170 0}]
dn_fb
  = \ (@ a_aQIT)
      (c_aQkU :: Integer -> a_aQIT -> a_aQIT)
      (n_aQkV :: a_aQIT)
      (x0_aQkW :: Integer)
      (delta_aQkX :: Integer)
      (lim_aQkY :: Integer) ->
      letrec {
        go_sRW2 [Occ=LoopBreaker] :: Integer -> a_aQIT
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_sRW2
          = \ (x_aQl0 :: Integer) ->
              case ltInteger# x_aQl0 lim_aQkY of {
                __DEFAULT ->
                  c_aQkU x_aQl0 (go_sRW2 (plusInteger x_aQl0 delta_aQkX));
                1# -> n_aQkV
              }; } in
      go_sRW2 x0_aQkW

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecElem_$cfromEnum :: VecElem -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_aQwj [Occ=Once] :: VecElem) ->
                 case a_aQwj of x1_iRtE { __DEFAULT ->
                 case dataToTag# @ VecElem x1_iRtE of a#_aQwk { __DEFAULT ->
                 GHC.Types.I# a#_aQwk
                 }
                 }}]
GHC.Enum.$fEnumVecElem_$cfromEnum
  = \ (a_aQwj :: VecElem) ->
      case dataToTag# @ VecElem a_aQwj of a#_aQwk { __DEFAULT ->
      GHC.Types.I# a#_aQwk
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl33_rURd :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl33_rURd = "error"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl34_rURe :: [Char]
[GblId]
lvl34_rURe = unpackCString# lvl33_rURd

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl35_rURf :: [Char]
[GblId]
lvl35_rURf = unpackCString# GHC.Enum.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Enum.$trModule2 = "GHC.Enum"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl36_rURg :: [Char]
[GblId]
lvl36_rURg = unpackCString# GHC.Enum.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl37_rURh :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl37_rURh = "./GHC/Enum.hs"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl38_rURi :: [Char]
[GblId]
lvl38_rURi = unpackCString# lvl37_rURh

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl39_rURj :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl39_rURj = GHC.Types.I# 890#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl40_rURk :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl40_rURk = GHC.Types.I# 31#

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
lvl41_rURl :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []]
lvl41_rURl
  = GHC.Stack.Types.SrcLoc
      lvl35_rURf
      lvl36_rURg
      lvl38_rURi
      lvl39_rURj
      GHC.Enum.$fEnumBool4
      lvl39_rURj
      lvl40_rURk

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
lvl42_rURm :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []]
lvl42_rURm
  = GHC.Stack.Types.PushCallStack
      lvl34_rURe lvl41_rURl GHC.Stack.Types.EmptyCallStack

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl43_rURn :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl43_rURn
  = "pred{VecElem}: tried to take `pred' of first tag in enumeration"#

-- RHS size: {terms: 4, types: 2, coercions: 4, joins: 0/0}
GHC.Enum.$fEnumVecElem1 :: VecElem
[GblId, Str=x]
GHC.Enum.$fEnumVecElem1
  = error
      @ 'LiftedRep
      @ VecElem
      (lvl42_rURm
       `cast` (Sym (GHC.Classes.N:IP[0]
                        <"callStack">_N <GHC.Stack.Types.CallStack>_N)
               :: (GHC.Stack.Types.CallStack :: *)
                  ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))
      (unpackCString# lvl43_rURn)

-- RHS size: {terms: 14, types: 5, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecElem_$cpred :: VecElem -> VecElem
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_aQwa [Occ=Once!] :: VecElem) ->
                 case a_aQwa of x1_iRtE {
                   __DEFAULT ->
                     case dataToTag# @ VecElem x1_iRtE of a#_aQwb { __DEFAULT ->
                     tagToEnum# @ VecElem (+# a#_aQwb -1#)
                     };
                   Int8ElemRep -> GHC.Enum.$fEnumVecElem1
                 }}]
GHC.Enum.$fEnumVecElem_$cpred
  = \ (a_aQwa :: VecElem) ->
      case a_aQwa of x1_iRtE {
        __DEFAULT ->
          case dataToTag# @ VecElem x1_iRtE of a#_aQwb { __DEFAULT ->
          tagToEnum# @ VecElem (+# a#_aQwb -1#)
          };
        Int8ElemRep -> GHC.Enum.$fEnumVecElem1
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl44_rURo :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl44_rURo
  = "succ{VecElem}: tried to take `succ' of last tag in enumeration"#

-- RHS size: {terms: 4, types: 2, coercions: 4, joins: 0/0}
GHC.Enum.$fEnumVecElem2 :: VecElem
[GblId, Str=x]
GHC.Enum.$fEnumVecElem2
  = error
      @ 'LiftedRep
      @ VecElem
      (lvl42_rURm
       `cast` (Sym (GHC.Classes.N:IP[0]
                        <"callStack">_N <GHC.Stack.Types.CallStack>_N)
               :: (GHC.Stack.Types.CallStack :: *)
                  ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))
      (unpackCString# lvl44_rURo)

-- RHS size: {terms: 14, types: 5, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecElem_$csucc :: VecElem -> VecElem
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_aQw8 [Occ=Once!] :: VecElem) ->
                 case a_aQw8 of x1_iRtE {
                   __DEFAULT ->
                     case dataToTag# @ VecElem x1_iRtE of a#_aQw9 { __DEFAULT ->
                     tagToEnum# @ VecElem (+# a#_aQw9 1#)
                     };
                   DoubleElemRep -> GHC.Enum.$fEnumVecElem2
                 }}]
GHC.Enum.$fEnumVecElem_$csucc
  = \ (a_aQw8 :: VecElem) ->
      case a_aQw8 of x1_iRtE {
        __DEFAULT ->
          case dataToTag# @ VecElem x1_iRtE of a#_aQw9 { __DEFAULT ->
          tagToEnum# @ VecElem (+# a#_aQw9 1#)
          };
        DoubleElemRep -> GHC.Enum.$fEnumVecElem2
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl45_rURp :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl45_rURp = ") is outside of enumeration's range (0,"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl46_rURq :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl46_rURq = ")"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl47_rURr :: [Char]
[GblId]
lvl47_rURr = unpackCString# lvl46_rURq

-- RHS size: {terms: 9, types: 10, coercions: 0, joins: 0/0}
lvl48_rURs :: [Char]
[GblId]
lvl48_rURs
  = case GHC.Show.$wshowSignedInt 0# 9# lvl47_rURr of
    { (# ww5_sBh6, ww6_sBh7 #) ->
    GHC.Types.: @ Char ww5_sBh6 ww6_sBh7
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
lvl49_rURt :: [Char]
[GblId]
lvl49_rURt = unpackAppendCString# lvl45_rURp lvl48_rURs

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl50_rURu :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl50_rURu = "toEnum{VecElem}: tag ("#

-- RHS size: {terms: 14, types: 13, coercions: 4, joins: 0/0}
GHC.Enum.$wlvl1 [InlPrag=NOUSERINLINE[0]] :: Int# -> VecElem
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Enum.$wlvl1
  = \ (ww_sTLu :: Int#) ->
      error
        @ 'LiftedRep
        @ VecElem
        (lvl42_rURm
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: (GHC.Stack.Types.CallStack :: *)
                    ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))
        (unpackAppendCString#
           lvl50_rURu
           (case GHC.Show.$wshowSignedInt 0# ww_sTLu lvl49_rURt of
            { (# ww5_sBh6, ww6_sBh7 #) ->
            GHC.Types.: @ Char ww5_sBh6 ww6_sBh7
            }))

-- RHS size: {terms: 19, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$w$ctoEnum1 [InlPrag=NOUSERINLINE[0]] :: Int# -> VecElem
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 83 0}]
GHC.Enum.$w$ctoEnum1
  = \ (ww_sTLA :: Int#) ->
      case >=# ww_sTLA 0# of {
        __DEFAULT -> GHC.Enum.$wlvl1 ww_sTLA;
        1# ->
          case <=# ww_sTLA 9# of {
            __DEFAULT -> GHC.Enum.$wlvl1 ww_sTLA;
            1# -> tagToEnum# @ VecElem ww_sTLA
          }
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecElem_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: Int -> VecElem
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sTLx [Occ=Once!] :: Int) ->
                 case w_sTLx of { I# ww1_sTLA [Occ=Once] ->
                 GHC.Enum.$w$ctoEnum1 ww1_sTLA
                 }}]
GHC.Enum.$fEnumVecElem_$ctoEnum
  = \ (w_sTLx :: Int) ->
      case w_sTLx of { I# ww1_sTLA -> GHC.Enum.$w$ctoEnum1 ww1_sTLA }

Rec {
-- RHS size: {terms: 13, types: 5, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecElem_go [Occ=LoopBreaker] :: Int# -> [VecElem]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumVecElem_go
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ VecElem
        (tagToEnum# @ VecElem x_aQiM)
        (case x_aQiM of wild_X8S {
           __DEFAULT -> GHC.Enum.$fEnumVecElem_go (+# wild_X8S 1#);
           9# -> GHC.Types.[] @ VecElem
         })
end Rec }

-- RHS size: {terms: 14, types: 5, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecElem_$cenumFrom :: VecElem -> [VecElem]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 42 10}]
GHC.Enum.$fEnumVecElem_$cenumFrom
  = \ (a_aQwd :: VecElem) ->
      case dataToTag# @ VecElem a_aQwd of a#_aQwe { __DEFAULT ->
      case ># a#_aQwe 9# of {
        __DEFAULT -> GHC.Enum.$fEnumVecElem_go a#_aQwe;
        1# -> GHC.Types.[] @ VecElem
      }
      }

-- RHS size: {terms: 224, types: 89, coercions: 0, joins: 0/12}
GHC.Enum.$fEnumVecElem_$cenumFromThen
  :: VecElem -> VecElem -> [VecElem]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 745 280}]
GHC.Enum.$fEnumVecElem_$cenumFromThen
  = \ (a_aQwf :: VecElem) (b_aQwg :: VecElem) ->
      case dataToTag# @ VecElem a_aQwf of a#_aQwh { __DEFAULT ->
      case dataToTag# @ VecElem b_aQwg of b#_aQwi { __DEFAULT ->
      case ># a#_aQwh b#_aQwi of {
        __DEFAULT ->
          case >=# b#_aQwi a#_aQwh of {
            __DEFAULT ->
              case ># 9# b#_aQwi of {
                __DEFAULT ->
                  GHC.Types.:
                    @ VecElem
                    (tagToEnum# @ VecElem a#_aQwh)
                    (let {
                       delta_aQjr [Dmd=<S,U>] :: Int#
                       [LclId]
                       delta_aQjr = -# b#_aQwi a#_aQwh } in
                     let {
                       y'_aQjs [Dmd=<S,U>] :: Int#
                       [LclId]
                       y'_aQjs = -# 9# delta_aQjr } in
                     letrec {
                       go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecElem]
                       [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                       go_dn_aQOv
                         = \ (x_aQju :: Int#) ->
                             case <# x_aQju y'_aQjs of {
                               __DEFAULT ->
                                 GHC.Types.:
                                   @ VecElem
                                   (tagToEnum# @ VecElem x_aQju)
                                   (go_dn_aQOv (+# x_aQju delta_aQjr));
                               1# ->
                                 GHC.Types.:
                                   @ VecElem (tagToEnum# @ VecElem x_aQju) (GHC.Types.[] @ VecElem)
                             }; } in
                     go_dn_aQOv b#_aQwi);
                1# ->
                  case ># 9# a#_aQwh of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ VecElem (tagToEnum# @ VecElem a#_aQwh) (GHC.Types.[] @ VecElem);
                    1# -> GHC.Types.[] @ VecElem
                  }
              };
            1# ->
              case <# 9# b#_aQwi of {
                __DEFAULT ->
                  GHC.Types.:
                    @ VecElem
                    (tagToEnum# @ VecElem a#_aQwh)
                    (let {
                       delta_aQjb [Dmd=<S,U>] :: Int#
                       [LclId]
                       delta_aQjb = -# b#_aQwi a#_aQwh } in
                     let {
                       y'_aQjc [Dmd=<S,U>] :: Int#
                       [LclId]
                       y'_aQjc = -# 9# delta_aQjb } in
                     letrec {
                       go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecElem]
                       [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                       go_up_aQPx
                         = \ (x_aQje :: Int#) ->
                             case ># x_aQje y'_aQjc of {
                               __DEFAULT ->
                                 GHC.Types.:
                                   @ VecElem
                                   (tagToEnum# @ VecElem x_aQje)
                                   (go_up_aQPx (+# x_aQje delta_aQjb));
                               1# ->
                                 GHC.Types.:
                                   @ VecElem (tagToEnum# @ VecElem x_aQje) (GHC.Types.[] @ VecElem)
                             }; } in
                     go_up_aQPx b#_aQwi);
                1# ->
                  case <# 9# a#_aQwh of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ VecElem (tagToEnum# @ VecElem a#_aQwh) (GHC.Types.[] @ VecElem);
                    1# -> GHC.Types.[] @ VecElem
                  }
              }
          };
        1# ->
          case >=# b#_aQwi a#_aQwh of {
            __DEFAULT ->
              case ># 0# b#_aQwi of {
                __DEFAULT ->
                  GHC.Types.:
                    @ VecElem
                    (tagToEnum# @ VecElem a#_aQwh)
                    (let {
                       delta_aQjr [Dmd=<S,U>] :: Int#
                       [LclId]
                       delta_aQjr = -# b#_aQwi a#_aQwh } in
                     let {
                       y'_aQjs [Dmd=<S,U>] :: Int#
                       [LclId]
                       y'_aQjs = -# 0# delta_aQjr } in
                     letrec {
                       go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecElem]
                       [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                       go_dn_aQOv
                         = \ (x_aQju :: Int#) ->
                             case <# x_aQju y'_aQjs of {
                               __DEFAULT ->
                                 GHC.Types.:
                                   @ VecElem
                                   (tagToEnum# @ VecElem x_aQju)
                                   (go_dn_aQOv (+# x_aQju delta_aQjr));
                               1# ->
                                 GHC.Types.:
                                   @ VecElem (tagToEnum# @ VecElem x_aQju) (GHC.Types.[] @ VecElem)
                             }; } in
                     go_dn_aQOv b#_aQwi);
                1# ->
                  case ># 0# a#_aQwh of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ VecElem (tagToEnum# @ VecElem a#_aQwh) (GHC.Types.[] @ VecElem);
                    1# -> GHC.Types.[] @ VecElem
                  }
              };
            1# ->
              case <# 0# b#_aQwi of {
                __DEFAULT ->
                  GHC.Types.:
                    @ VecElem
                    (tagToEnum# @ VecElem a#_aQwh)
                    (let {
                       delta_aQjb [Dmd=<S,U>] :: Int#
                       [LclId]
                       delta_aQjb = -# b#_aQwi a#_aQwh } in
                     let {
                       y'_aQjc [Dmd=<S,U>] :: Int#
                       [LclId]
                       y'_aQjc = -# 0# delta_aQjb } in
                     letrec {
                       go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecElem]
                       [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                       go_up_aQPx
                         = \ (x_aQje :: Int#) ->
                             case ># x_aQje y'_aQjc of {
                               __DEFAULT ->
                                 GHC.Types.:
                                   @ VecElem
                                   (tagToEnum# @ VecElem x_aQje)
                                   (go_up_aQPx (+# x_aQje delta_aQjb));
                               1# ->
                                 GHC.Types.:
                                   @ VecElem (tagToEnum# @ VecElem x_aQje) (GHC.Types.[] @ VecElem)
                             }; } in
                     go_up_aQPx b#_aQwi);
                1# ->
                  case <# 0# a#_aQwh of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ VecElem (tagToEnum# @ VecElem a#_aQwh) (GHC.Types.[] @ VecElem);
                    1# -> GHC.Types.[] @ VecElem
                  }
              }
          }
      }
      }
      }

-- RHS size: {terms: 51, types: 18, coercions: 0, joins: 0/1}
GHC.Enum.$fEnumVecElem_$cenumFromTo
  :: VecElem -> VecElem -> [VecElem]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 198 10}]
GHC.Enum.$fEnumVecElem_$cenumFromTo
  = \ (x_aQge :: VecElem) (y_aQgf :: VecElem) ->
      case dataToTag# @ VecElem x_aQge of a#_aQwk { __DEFAULT ->
      case dataToTag# @ VecElem y_aQgf of a#1_XQIc { __DEFAULT ->
      case ># a#_aQwk a#1_XQIc of {
        __DEFAULT ->
          letrec {
            go_aQQv [Occ=LoopBreaker] :: Int# -> [VecElem]
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            go_aQQv
              = \ (x1_aQiM :: Int#) ->
                  GHC.Types.:
                    @ VecElem
                    (case >=# x1_aQiM 0# of {
                       __DEFAULT -> GHC.Enum.$wlvl1 x1_aQiM;
                       1# ->
                         case <=# x1_aQiM 9# of {
                           __DEFAULT -> GHC.Enum.$wlvl1 x1_aQiM;
                           1# -> tagToEnum# @ VecElem x1_aQiM
                         }
                     })
                    (case ==# x1_aQiM a#1_XQIc of {
                       __DEFAULT -> go_aQQv (+# x1_aQiM 1#);
                       1# -> GHC.Types.[] @ VecElem
                     }); } in
          go_aQQv a#_aQwk;
        1# -> GHC.Types.[] @ VecElem
      }
      }
      }

-- RHS size: {terms: 247, types: 66, coercions: 0, joins: 0/6}
GHC.Enum.$fEnumVecElem_$cenumFromThenTo
  :: VecElem -> VecElem -> VecElem -> [VecElem]
[GblId, Arity=3, Str=<S,U><S,U><S,U>, Unf=OtherCon []]
GHC.Enum.$fEnumVecElem_$cenumFromThenTo
  = \ (x1_aQgg :: VecElem)
      (x2_aQgh :: VecElem)
      (y_aQgi :: VecElem) ->
      case dataToTag# @ VecElem x1_aQgg of a#_aQwk { __DEFAULT ->
      case dataToTag# @ VecElem x2_aQgh of a#1_XQIe { __DEFAULT ->
      case dataToTag# @ VecElem y_aQgi of a#2_XQIl { __DEFAULT ->
      case >=# a#1_XQIe a#_aQwk of {
        __DEFAULT ->
          case ># a#2_XQIl a#1_XQIe of {
            __DEFAULT ->
              GHC.Types.:
                @ VecElem
                (case >=# a#_aQwk 0# of {
                   __DEFAULT -> GHC.Enum.$wlvl1 a#_aQwk;
                   1# ->
                     case <=# a#_aQwk 9# of {
                       __DEFAULT -> GHC.Enum.$wlvl1 a#_aQwk;
                       1# -> tagToEnum# @ VecElem a#_aQwk
                     }
                 })
                (let {
                   delta_aQjr [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_aQjr = -# a#1_XQIe a#_aQwk } in
                 let {
                   y'_aQjs [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_aQjs = -# a#2_XQIl delta_aQjr } in
                 letrec {
                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecElem]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_dn_aQOv
                     = \ (x_aQju :: Int#) ->
                         case <# x_aQju y'_aQjs of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ VecElem
                               (case >=# x_aQju 0# of {
                                  __DEFAULT -> GHC.Enum.$wlvl1 x_aQju;
                                  1# ->
                                    case <=# x_aQju 9# of {
                                      __DEFAULT -> GHC.Enum.$wlvl1 x_aQju;
                                      1# -> tagToEnum# @ VecElem x_aQju
                                    }
                                })
                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                           1# ->
                             GHC.Types.:
                               @ VecElem
                               (case >=# x_aQju 0# of {
                                  __DEFAULT -> GHC.Enum.$wlvl1 x_aQju;
                                  1# ->
                                    case <=# x_aQju 9# of {
                                      __DEFAULT -> GHC.Enum.$wlvl1 x_aQju;
                                      1# -> tagToEnum# @ VecElem x_aQju
                                    }
                                })
                               (GHC.Types.[] @ VecElem)
                         }; } in
                 go_dn_aQOv a#1_XQIe);
            1# ->
              case ># a#2_XQIl a#_aQwk of {
                __DEFAULT ->
                  GHC.Types.:
                    @ VecElem
                    (case >=# a#_aQwk 0# of {
                       __DEFAULT -> GHC.Enum.$wlvl1 a#_aQwk;
                       1# ->
                         case <=# a#_aQwk 9# of {
                           __DEFAULT -> GHC.Enum.$wlvl1 a#_aQwk;
                           1# -> tagToEnum# @ VecElem a#_aQwk
                         }
                     })
                    (GHC.Types.[] @ VecElem);
                1# -> GHC.Types.[] @ VecElem
              }
          };
        1# ->
          case <# a#2_XQIl a#1_XQIe of {
            __DEFAULT ->
              GHC.Types.:
                @ VecElem
                (case >=# a#_aQwk 0# of {
                   __DEFAULT -> GHC.Enum.$wlvl1 a#_aQwk;
                   1# ->
                     case <=# a#_aQwk 9# of {
                       __DEFAULT -> GHC.Enum.$wlvl1 a#_aQwk;
                       1# -> tagToEnum# @ VecElem a#_aQwk
                     }
                 })
                (let {
                   delta_aQjb [Dmd=<S,U>] :: Int#
                   [LclId]
                   delta_aQjb = -# a#1_XQIe a#_aQwk } in
                 let {
                   y'_aQjc [Dmd=<S,U>] :: Int#
                   [LclId]
                   y'_aQjc = -# a#2_XQIl delta_aQjb } in
                 letrec {
                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecElem]
                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                   go_up_aQPx
                     = \ (x_aQje :: Int#) ->
                         case ># x_aQje y'_aQjc of {
                           __DEFAULT ->
                             GHC.Types.:
                               @ VecElem
                               (case >=# x_aQje 0# of {
                                  __DEFAULT -> GHC.Enum.$wlvl1 x_aQje;
                                  1# ->
                                    case <=# x_aQje 9# of {
                                      __DEFAULT -> GHC.Enum.$wlvl1 x_aQje;
                                      1# -> tagToEnum# @ VecElem x_aQje
                                    }
                                })
                               (go_up_aQPx (+# x_aQje delta_aQjb));
                           1# ->
                             GHC.Types.:
                               @ VecElem
                               (case >=# x_aQje 0# of {
                                  __DEFAULT -> GHC.Enum.$wlvl1 x_aQje;
                                  1# ->
                                    case <=# x_aQje 9# of {
                                      __DEFAULT -> GHC.Enum.$wlvl1 x_aQje;
                                      1# -> tagToEnum# @ VecElem x_aQje
                                    }
                                })
                               (GHC.Types.[] @ VecElem)
                         }; } in
                 go_up_aQPx a#1_XQIe);
            1# ->
              case <# a#2_XQIl a#_aQwk of {
                __DEFAULT ->
                  GHC.Types.:
                    @ VecElem
                    (case >=# a#_aQwk 0# of {
                       __DEFAULT -> GHC.Enum.$wlvl1 a#_aQwk;
                       1# ->
                         case <=# a#_aQwk 9# of {
                           __DEFAULT -> GHC.Enum.$wlvl1 a#_aQwk;
                           1# -> tagToEnum# @ VecElem a#_aQwk
                         }
                     })
                    (GHC.Types.[] @ VecElem);
                1# -> GHC.Types.[] @ VecElem
              }
          }
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecElem [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum VecElem
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: VecElem
                       GHC.Enum.$fEnumVecElem_$csucc
                       GHC.Enum.$fEnumVecElem_$cpred
                       GHC.Enum.$fEnumVecElem_$ctoEnum
                       GHC.Enum.$fEnumVecElem_$cfromEnum
                       GHC.Enum.$fEnumVecElem_$cenumFrom
                       GHC.Enum.$fEnumVecElem_$cenumFromThen
                       GHC.Enum.$fEnumVecElem_$cenumFromTo
                       GHC.Enum.$fEnumVecElem_$cenumFromThenTo]
GHC.Enum.$fEnumVecElem
  = GHC.Enum.C:Enum
      @ VecElem
      GHC.Enum.$fEnumVecElem_$csucc
      GHC.Enum.$fEnumVecElem_$cpred
      GHC.Enum.$fEnumVecElem_$ctoEnum
      GHC.Enum.$fEnumVecElem_$cfromEnum
      GHC.Enum.$fEnumVecElem_$cenumFrom
      GHC.Enum.$fEnumVecElem_$cenumFromThen
      GHC.Enum.$fEnumVecElem_$cenumFromTo
      GHC.Enum.$fEnumVecElem_$cenumFromThenTo

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl51_rURv :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl51_rURv = GHC.Types.I# 3#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl52_rURw :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl52_rURw = GHC.Types.I# 4#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl53_rURx :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl53_rURx = GHC.Types.I# 5#

-- RHS size: {terms: 15, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: VecCount -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sTLT [Occ=Once!] :: VecCount) ->
                 case w_sTLT of {
                   Vec2 -> GHC.Types.I# 0#;
                   Vec4 -> GHC.Types.I# 1#;
                   Vec8 -> GHC.Types.I# 2#;
                   Vec16 -> GHC.Types.I# 3#;
                   Vec32 -> GHC.Types.I# 4#;
                   Vec64 -> GHC.Types.I# 5#
                 }}]
GHC.Enum.$fEnumVecCount_$cfromEnum
  = \ (w_sTLT :: VecCount) ->
      case w_sTLT of {
        Vec2 -> GHC.Enum.$fEnum()2;
        Vec4 -> GHC.Enum.$fEnumBool4;
        Vec8 -> GHC.Enum.$fEnumOrdering4;
        Vec16 -> lvl51_rURv;
        Vec32 -> lvl52_rURw;
        Vec64 -> lvl53_rURx
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl54_rURy :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl54_rURy = GHC.Types.I# 885#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl55_rURz :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl55_rURz = GHC.Types.I# 32#

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
lvl56_rURA :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []]
lvl56_rURA
  = GHC.Stack.Types.SrcLoc
      lvl35_rURf
      lvl36_rURg
      lvl38_rURi
      lvl54_rURy
      GHC.Enum.$fEnumBool4
      lvl54_rURy
      lvl55_rURz

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
lvl57_rURB :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []]
lvl57_rURB
  = GHC.Stack.Types.PushCallStack
      lvl34_rURe lvl56_rURA GHC.Stack.Types.EmptyCallStack

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl58_rURC :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl58_rURC
  = "pred{VecCount}: tried to take `pred' of first tag in enumeration"#

-- RHS size: {terms: 4, types: 2, coercions: 4, joins: 0/0}
GHC.Enum.$fEnumVecCount7 :: VecCount
[GblId, Str=x]
GHC.Enum.$fEnumVecCount7
  = error
      @ 'LiftedRep
      @ VecCount
      (lvl57_rURB
       `cast` (Sym (GHC.Classes.N:IP[0]
                        <"callStack">_N <GHC.Stack.Types.CallStack>_N)
               :: (GHC.Stack.Types.CallStack :: *)
                  ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))
      (unpackCString# lvl58_rURC)

-- RHS size: {terms: 15, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_$cpred :: VecCount -> VecCount
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_aQwn [Occ=Once!] :: VecCount) ->
                 case a_aQwn of {
                   Vec2 -> GHC.Enum.$fEnumVecCount7;
                   Vec4 -> GHC.Types.Vec2;
                   Vec8 -> GHC.Types.Vec4;
                   Vec16 -> GHC.Types.Vec8;
                   Vec32 -> GHC.Types.Vec16;
                   Vec64 -> GHC.Types.Vec32
                 }}]
GHC.Enum.$fEnumVecCount_$cpred
  = \ (a_aQwn :: VecCount) ->
      case a_aQwn of {
        Vec2 -> GHC.Enum.$fEnumVecCount7;
        Vec4 -> GHC.Types.Vec2;
        Vec8 -> GHC.Types.Vec4;
        Vec16 -> GHC.Types.Vec8;
        Vec32 -> GHC.Types.Vec16;
        Vec64 -> GHC.Types.Vec32
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl59_rURD :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl59_rURD
  = "succ{VecCount}: tried to take `succ' of last tag in enumeration"#

-- RHS size: {terms: 4, types: 2, coercions: 4, joins: 0/0}
GHC.Enum.$fEnumVecCount8 :: VecCount
[GblId, Str=x]
GHC.Enum.$fEnumVecCount8
  = error
      @ 'LiftedRep
      @ VecCount
      (lvl57_rURB
       `cast` (Sym (GHC.Classes.N:IP[0]
                        <"callStack">_N <GHC.Stack.Types.CallStack>_N)
               :: (GHC.Stack.Types.CallStack :: *)
                  ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))
      (unpackCString# lvl59_rURD)

-- RHS size: {terms: 15, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_$csucc :: VecCount -> VecCount
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_aQwl [Occ=Once!] :: VecCount) ->
                 case a_aQwl of {
                   Vec2 -> GHC.Types.Vec4;
                   Vec4 -> GHC.Types.Vec8;
                   Vec8 -> GHC.Types.Vec16;
                   Vec16 -> GHC.Types.Vec32;
                   Vec32 -> GHC.Types.Vec64;
                   Vec64 -> GHC.Enum.$fEnumVecCount8
                 }}]
GHC.Enum.$fEnumVecCount_$csucc
  = \ (a_aQwl :: VecCount) ->
      case a_aQwl of {
        Vec2 -> GHC.Types.Vec4;
        Vec4 -> GHC.Types.Vec8;
        Vec8 -> GHC.Types.Vec16;
        Vec16 -> GHC.Types.Vec32;
        Vec32 -> GHC.Types.Vec64;
        Vec64 -> GHC.Enum.$fEnumVecCount8
      }

-- RHS size: {terms: 9, types: 10, coercions: 0, joins: 0/0}
lvl60_rURE :: [Char]
[GblId]
lvl60_rURE
  = case GHC.Show.$wshowSignedInt 0# 5# lvl47_rURr of
    { (# ww5_sBh6, ww6_sBh7 #) ->
    GHC.Types.: @ Char ww5_sBh6 ww6_sBh7
    }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
lvl61_rURF :: [Char]
[GblId]
lvl61_rURF = unpackAppendCString# lvl45_rURp lvl60_rURE

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl62_rURG :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl62_rURG = "toEnum{VecCount}: tag ("#

-- RHS size: {terms: 14, types: 13, coercions: 4, joins: 0/0}
GHC.Enum.$wlvl [InlPrag=NOUSERINLINE[0]] :: Int# -> VecCount
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Enum.$wlvl
  = \ (ww_sTM1 :: Int#) ->
      error
        @ 'LiftedRep
        @ VecCount
        (lvl57_rURB
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: (GHC.Stack.Types.CallStack :: *)
                    ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))
        (unpackAppendCString#
           lvl62_rURG
           (case GHC.Show.$wshowSignedInt 0# ww_sTM1 lvl61_rURF of
            { (# ww5_sBh6, ww6_sBh7 #) ->
            GHC.Types.: @ Char ww5_sBh6 ww6_sBh7
            }))

-- RHS size: {terms: 19, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$w$ctoEnum [InlPrag=NOUSERINLINE[0]] :: Int# -> VecCount
[GblId,
 Arity=1,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 83 0}]
GHC.Enum.$w$ctoEnum
  = \ (ww_sTM7 :: Int#) ->
      case >=# ww_sTM7 0# of {
        __DEFAULT -> GHC.Enum.$wlvl ww_sTM7;
        1# ->
          case <=# ww_sTM7 5# of {
            __DEFAULT -> GHC.Enum.$wlvl ww_sTM7;
            1# -> tagToEnum# @ VecCount ww_sTM7
          }
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: Int -> VecCount
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sTM4 [Occ=Once!] :: Int) ->
                 case w_sTM4 of { I# ww1_sTM7 [Occ=Once] ->
                 GHC.Enum.$w$ctoEnum ww1_sTM7
                 }}]
GHC.Enum.$fEnumVecCount_$ctoEnum
  = \ (w_sTM4 :: Int) ->
      case w_sTM4 of { I# ww1_sTM7 -> GHC.Enum.$w$ctoEnum ww1_sTM7 }

Rec {
-- RHS size: {terms: 13, types: 5, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_go6 [Occ=LoopBreaker] :: Int# -> [VecCount]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumVecCount_go6
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ VecCount
        (tagToEnum# @ VecCount x_aQiM)
        (case x_aQiM of wild_X9g {
           __DEFAULT -> GHC.Enum.$fEnumVecCount_go6 (+# wild_X9g 1#);
           5# -> GHC.Types.[] @ VecCount
         })
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount6 :: [VecCount]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumVecCount6 = GHC.Enum.$fEnumVecCount_go6 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount5 :: [VecCount]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumVecCount5 = GHC.Enum.$fEnumVecCount_go6 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount4 :: [VecCount]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumVecCount4 = GHC.Enum.$fEnumVecCount_go6 2#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount3 :: [VecCount]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumVecCount3 = GHC.Enum.$fEnumVecCount_go6 3#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount2 :: [VecCount]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumVecCount2 = GHC.Enum.$fEnumVecCount_go6 4#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount1 :: [VecCount]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$fEnumVecCount1 = GHC.Enum.$fEnumVecCount_go6 5#

-- RHS size: {terms: 15, types: 2, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_$cenumFrom :: VecCount -> [VecCount]
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [70] 60 0}]
GHC.Enum.$fEnumVecCount_$cenumFrom
  = \ (a_aQwq :: VecCount) ->
      case a_aQwq of {
        Vec2 -> GHC.Enum.$fEnumVecCount6;
        Vec4 -> GHC.Enum.$fEnumVecCount5;
        Vec8 -> GHC.Enum.$fEnumVecCount4;
        Vec16 -> GHC.Enum.$fEnumVecCount3;
        Vec32 -> GHC.Enum.$fEnumVecCount2;
        Vec64 -> GHC.Enum.$fEnumVecCount1
      }

-- RHS size: {terms: 260, types: 95, coercions: 0, joins: 2/14}
GHC.Enum.$fEnumVecCount_$cenumFromThen
  :: VecCount -> VecCount -> [VecCount]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []]
GHC.Enum.$fEnumVecCount_$cenumFromThen
  = \ (a_aQws :: VecCount) (b_aQwt :: VecCount) ->
      join {
        $j_sS4X [Dmd=<C(S),1*C1(U)>] :: Int# -> [VecCount]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sS4X (a#_aQwu [OS=OneShot]
                   :: Int#
                   Unf=OtherCon [])
          = join {
              $j1_sS4V [Dmd=<C(S),1*C1(U)>] :: Int# -> [VecCount]
              [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
              $j1_sS4V (b#_aQwv [OS=OneShot]
                          :: Int#
                          Unf=OtherCon [])
                = case ># a#_aQwu b#_aQwv of {
                    __DEFAULT ->
                      case >=# b#_aQwv a#_aQwu of {
                        __DEFAULT ->
                          case ># 5# b#_aQwv of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (tagToEnum# @ VecCount a#_aQwu)
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# b#_aQwv a#_aQwu } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 5# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (tagToEnum# @ VecCount x_aQju)
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (tagToEnum# @ VecCount x_aQju)
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_dn_aQOv b#_aQwv);
                            1# ->
                              case ># 5# a#_aQwu of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (tagToEnum# @ VecCount a#_aQwu)
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          };
                        1# ->
                          case <# 5# b#_aQwv of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (tagToEnum# @ VecCount a#_aQwu)
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# b#_aQwv a#_aQwu } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 5# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (tagToEnum# @ VecCount x_aQje)
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (tagToEnum# @ VecCount x_aQje)
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_up_aQPx b#_aQwv);
                            1# ->
                              case <# 5# a#_aQwu of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (tagToEnum# @ VecCount a#_aQwu)
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          }
                      };
                    1# ->
                      case >=# b#_aQwv a#_aQwu of {
                        __DEFAULT ->
                          case ># 0# b#_aQwv of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (tagToEnum# @ VecCount a#_aQwu)
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# b#_aQwv a#_aQwu } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 0# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (tagToEnum# @ VecCount x_aQju)
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (tagToEnum# @ VecCount x_aQju)
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_dn_aQOv b#_aQwv);
                            1# ->
                              case ># 0# a#_aQwu of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (tagToEnum# @ VecCount a#_aQwu)
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          };
                        1# ->
                          case <# 0# b#_aQwv of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (tagToEnum# @ VecCount a#_aQwu)
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# b#_aQwv a#_aQwu } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 0# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (tagToEnum# @ VecCount x_aQje)
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (tagToEnum# @ VecCount x_aQje)
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_up_aQPx b#_aQwv);
                            1# ->
                              case <# 0# a#_aQwu of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (tagToEnum# @ VecCount a#_aQwu)
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          }
                      }
                  } } in
            case b_aQwt of {
              Vec2 -> jump $j1_sS4V 0#;
              Vec4 -> jump $j1_sS4V 1#;
              Vec8 -> jump $j1_sS4V 2#;
              Vec16 -> jump $j1_sS4V 3#;
              Vec32 -> jump $j1_sS4V 4#;
              Vec64 -> jump $j1_sS4V 5#
            } } in
      case a_aQws of {
        Vec2 -> jump $j_sS4X 0#;
        Vec4 -> jump $j_sS4X 1#;
        Vec8 -> jump $j_sS4X 2#;
        Vec16 -> jump $j_sS4X 3#;
        Vec32 -> jump $j_sS4X 4#;
        Vec64 -> jump $j_sS4X 5#
      }

Rec {
-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_go5 [Occ=LoopBreaker] :: Int# -> [VecCount]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumVecCount_go5
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ VecCount
        (case >=# x_aQiM 0# of {
           __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
           1# ->
             case <=# x_aQiM 5# of {
               __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
               1# -> tagToEnum# @ VecCount x_aQiM
             }
         })
        (case x_aQiM of wild_X9o {
           __DEFAULT -> GHC.Enum.$fEnumVecCount_go5 (+# wild_X9o 1#);
           0# -> GHC.Types.[] @ VecCount
         })
end Rec }

Rec {
-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_go4 [Occ=LoopBreaker] :: Int# -> [VecCount]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumVecCount_go4
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ VecCount
        (case >=# x_aQiM 0# of {
           __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
           1# ->
             case <=# x_aQiM 5# of {
               __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
               1# -> tagToEnum# @ VecCount x_aQiM
             }
         })
        (case x_aQiM of wild_X9o {
           __DEFAULT -> GHC.Enum.$fEnumVecCount_go4 (+# wild_X9o 1#);
           1# -> GHC.Types.[] @ VecCount
         })
end Rec }

Rec {
-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_go3 [Occ=LoopBreaker] :: Int# -> [VecCount]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumVecCount_go3
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ VecCount
        (case >=# x_aQiM 0# of {
           __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
           1# ->
             case <=# x_aQiM 5# of {
               __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
               1# -> tagToEnum# @ VecCount x_aQiM
             }
         })
        (case x_aQiM of wild_X9o {
           __DEFAULT -> GHC.Enum.$fEnumVecCount_go3 (+# wild_X9o 1#);
           2# -> GHC.Types.[] @ VecCount
         })
end Rec }

Rec {
-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_go2 [Occ=LoopBreaker] :: Int# -> [VecCount]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumVecCount_go2
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ VecCount
        (case >=# x_aQiM 0# of {
           __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
           1# ->
             case <=# x_aQiM 5# of {
               __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
               1# -> tagToEnum# @ VecCount x_aQiM
             }
         })
        (case x_aQiM of wild_X9o {
           __DEFAULT -> GHC.Enum.$fEnumVecCount_go2 (+# wild_X9o 1#);
           3# -> GHC.Types.[] @ VecCount
         })
end Rec }

Rec {
-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_go1 [Occ=LoopBreaker] :: Int# -> [VecCount]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumVecCount_go1
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ VecCount
        (case >=# x_aQiM 0# of {
           __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
           1# ->
             case <=# x_aQiM 5# of {
               __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
               1# -> tagToEnum# @ VecCount x_aQiM
             }
         })
        (case x_aQiM of wild_X9o {
           __DEFAULT -> GHC.Enum.$fEnumVecCount_go1 (+# wild_X9o 1#);
           4# -> GHC.Types.[] @ VecCount
         })
end Rec }

Rec {
-- RHS size: {terms: 29, types: 7, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount_go [Occ=LoopBreaker] :: Int# -> [VecCount]
[GblId, Arity=1, Str=<L,U>m2, Unf=OtherCon []]
GHC.Enum.$fEnumVecCount_go
  = \ (x_aQiM :: Int#) ->
      GHC.Types.:
        @ VecCount
        (case >=# x_aQiM 0# of {
           __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
           1# ->
             case <=# x_aQiM 5# of {
               __DEFAULT -> GHC.Enum.$wlvl x_aQiM;
               1# -> tagToEnum# @ VecCount x_aQiM
             }
         })
        (case x_aQiM of wild_X9o {
           __DEFAULT -> GHC.Enum.$fEnumVecCount_go (+# wild_X9o 1#);
           5# -> GHC.Types.[] @ VecCount
         })
end Rec }

-- RHS size: {terms: 86, types: 20, coercions: 0, joins: 1/1}
GHC.Enum.$fEnumVecCount_$cenumFromTo
  :: VecCount -> VecCount -> [VecCount]
[GblId,
 Arity=2,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 275] 390 0}]
GHC.Enum.$fEnumVecCount_$cenumFromTo
  = \ (x_aQge :: VecCount) (y_aQgf :: VecCount) ->
      join {
        $j_sS50 [Dmd=<C(S),1*C1(U)>] :: Int# -> [VecCount]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sS50 (x1_aQgR [OS=OneShot] :: Int#)
          = case y_aQgf of {
              Vec2 ->
                case ># x1_aQgR 0# of {
                  __DEFAULT -> GHC.Enum.$fEnumVecCount_go5 x1_aQgR;
                  1# -> GHC.Types.[] @ VecCount
                };
              Vec4 ->
                case ># x1_aQgR 1# of {
                  __DEFAULT -> GHC.Enum.$fEnumVecCount_go4 x1_aQgR;
                  1# -> GHC.Types.[] @ VecCount
                };
              Vec8 ->
                case ># x1_aQgR 2# of {
                  __DEFAULT -> GHC.Enum.$fEnumVecCount_go3 x1_aQgR;
                  1# -> GHC.Types.[] @ VecCount
                };
              Vec16 ->
                case ># x1_aQgR 3# of {
                  __DEFAULT -> GHC.Enum.$fEnumVecCount_go2 x1_aQgR;
                  1# -> GHC.Types.[] @ VecCount
                };
              Vec32 ->
                case ># x1_aQgR 4# of {
                  __DEFAULT -> GHC.Enum.$fEnumVecCount_go1 x1_aQgR;
                  1# -> GHC.Types.[] @ VecCount
                };
              Vec64 ->
                case ># x1_aQgR 5# of {
                  __DEFAULT -> GHC.Enum.$fEnumVecCount_go x1_aQgR;
                  1# -> GHC.Types.[] @ VecCount
                }
            } } in
      case x_aQge of {
        Vec2 -> jump $j_sS50 0#;
        Vec4 -> jump $j_sS50 1#;
        Vec8 -> jump $j_sS50 2#;
        Vec16 -> jump $j_sS50 3#;
        Vec32 -> jump $j_sS50 4#;
        Vec64 -> jump $j_sS50 5#
      }

-- RHS size: {terms: 1,447, types: 356, coercions: 0, joins: 2/38}
GHC.Enum.$fEnumVecCount_$cenumFromThenTo
  :: VecCount -> VecCount -> VecCount -> [VecCount]
[GblId, Arity=3, Str=<S,1*U><S,1*U><S,1*U>, Unf=OtherCon []]
GHC.Enum.$fEnumVecCount_$cenumFromThenTo
  = \ (x1_aQgg :: VecCount)
      (x2_aQgh :: VecCount)
      (y_aQgi :: VecCount) ->
      join {
        $j_sS55 [Dmd=<C(S),1*C1(U)>] :: Int# -> [VecCount]
        [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
        $j_sS55 (x4_aQgV [OS=OneShot] :: Int#)
          = join {
              $j1_sS53 [Dmd=<C(S),1*C1(U)>] :: Int# -> [VecCount]
              [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
              $j1_sS53 (x5_aQgW [OS=OneShot] :: Int#)
                = case y_aQgi of {
                    Vec2 ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 0# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 0# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 0# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          };
                        1# ->
                          case <# 0# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 0# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 0# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          }
                      };
                    Vec4 ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 1# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 1# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 1# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          };
                        1# ->
                          case <# 1# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 1# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 1# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          }
                      };
                    Vec8 ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 2# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 2# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 2# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          };
                        1# ->
                          case <# 2# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 2# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 2# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          }
                      };
                    Vec16 ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 3# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 3# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 3# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          };
                        1# ->
                          case <# 3# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 3# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 3# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          }
                      };
                    Vec32 ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 4# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 4# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 4# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          };
                        1# ->
                          case <# 4# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 4# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 4# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          }
                      };
                    Vec64 ->
                      case >=# x5_aQgW x4_aQgV of {
                        __DEFAULT ->
                          case ># 5# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjr [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjr = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjs [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjs = -# 5# delta_aQjr } in
                                 letrec {
                                   go_dn_aQOv [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_dn_aQOv
                                     = \ (x_aQju :: Int#) ->
                                         case <# x_aQju y'_aQjs of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (go_dn_aQOv (+# x_aQju delta_aQjr));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQju 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                  1# ->
                                                    case <=# x_aQju 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQju;
                                                      1# -> tagToEnum# @ VecCount x_aQju
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_dn_aQOv x5_aQgW);
                            1# ->
                              case ># 5# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          };
                        1# ->
                          case <# 5# x5_aQgW of {
                            __DEFAULT ->
                              GHC.Types.:
                                @ VecCount
                                (case >=# x4_aQgV 0# of {
                                   __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                   1# ->
                                     case <=# x4_aQgV 5# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# -> tagToEnum# @ VecCount x4_aQgV
                                     }
                                 })
                                (let {
                                   delta_aQjb [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   delta_aQjb = -# x5_aQgW x4_aQgV } in
                                 let {
                                   y'_aQjc [Dmd=<S,U>] :: Int#
                                   [LclId]
                                   y'_aQjc = -# 5# delta_aQjb } in
                                 letrec {
                                   go_up_aQPx [Occ=LoopBreaker] :: Int# -> [VecCount]
                                   [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                                   go_up_aQPx
                                     = \ (x_aQje :: Int#) ->
                                         case ># x_aQje y'_aQjc of {
                                           __DEFAULT ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (go_up_aQPx (+# x_aQje delta_aQjb));
                                           1# ->
                                             GHC.Types.:
                                               @ VecCount
                                               (case >=# x_aQje 0# of {
                                                  __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                  1# ->
                                                    case <=# x_aQje 5# of {
                                                      __DEFAULT -> GHC.Enum.$wlvl x_aQje;
                                                      1# -> tagToEnum# @ VecCount x_aQje
                                                    }
                                                })
                                               (GHC.Types.[] @ VecCount)
                                         }; } in
                                 go_up_aQPx x5_aQgW);
                            1# ->
                              case <# 5# x4_aQgV of {
                                __DEFAULT ->
                                  GHC.Types.:
                                    @ VecCount
                                    (case >=# x4_aQgV 0# of {
                                       __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                       1# ->
                                         case <=# x4_aQgV 5# of {
                                           __DEFAULT -> GHC.Enum.$wlvl x4_aQgV;
                                           1# -> tagToEnum# @ VecCount x4_aQgV
                                         }
                                     })
                                    (GHC.Types.[] @ VecCount);
                                1# -> GHC.Types.[] @ VecCount
                              }
                          }
                      }
                  } } in
            case x2_aQgh of {
              Vec2 -> jump $j1_sS53 0#;
              Vec4 -> jump $j1_sS53 1#;
              Vec8 -> jump $j1_sS53 2#;
              Vec16 -> jump $j1_sS53 3#;
              Vec32 -> jump $j1_sS53 4#;
              Vec64 -> jump $j1_sS53 5#
            } } in
      case x1_aQgg of {
        Vec2 -> jump $j_sS55 0#;
        Vec4 -> jump $j_sS55 1#;
        Vec8 -> jump $j_sS55 2#;
        Vec16 -> jump $j_sS55 3#;
        Vec32 -> jump $j_sS55 4#;
        Vec64 -> jump $j_sS55 5#
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumVecCount [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum VecCount
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: VecCount
                       GHC.Enum.$fEnumVecCount_$csucc
                       GHC.Enum.$fEnumVecCount_$cpred
                       GHC.Enum.$fEnumVecCount_$ctoEnum
                       GHC.Enum.$fEnumVecCount_$cfromEnum
                       GHC.Enum.$fEnumVecCount_$cenumFrom
                       GHC.Enum.$fEnumVecCount_$cenumFromThen
                       GHC.Enum.$fEnumVecCount_$cenumFromTo
                       GHC.Enum.$fEnumVecCount_$cenumFromThenTo]
GHC.Enum.$fEnumVecCount
  = GHC.Enum.C:Enum
      @ VecCount
      GHC.Enum.$fEnumVecCount_$csucc
      GHC.Enum.$fEnumVecCount_$cpred
      GHC.Enum.$fEnumVecCount_$ctoEnum
      GHC.Enum.$fEnumVecCount_$cfromEnum
      GHC.Enum.$fEnumVecCount_$cenumFrom
      GHC.Enum.$fEnumVecCount_$cenumFromThen
      GHC.Enum.$fEnumVecCount_$cenumFromTo
      GHC.Enum.$fEnumVecCount_$cenumFromThenTo

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$trModule3 = GHC.Types.TrNameS GHC.Enum.$trModule4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$trModule1 = GHC.Types.TrNameS GHC.Enum.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Enum.$trModule
  = GHC.Types.Module GHC.Enum.$trModule3 GHC.Enum.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_rURH :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_rURH
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcInt (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_rURI :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_rURI
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tcBounded1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Enum.$tcBounded1
  = GHC.Types.KindRepFun GHC.Types.krep$* $krep1_rURI

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2_rURJ :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_rURJ = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3_rURK :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep3_rURK = GHC.Types.KindRepFun $krep2_rURJ $krep2_rURJ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_rURL :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep4_rURL = GHC.Types.KindRepFun $krep2_rURJ $krep_rURH

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_rURM :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep5_rURM = GHC.Types.KindRepFun $krep_rURH $krep2_rURJ

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep6_rURN :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep6_rURN
  = GHC.Types.: @ KindRep $krep2_rURJ (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7_rURO :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep7_rURO = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep6_rURN

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_rURP :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep8_rURP = GHC.Types.KindRepFun $krep2_rURJ $krep7_rURO

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_rURQ :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep9_rURQ = GHC.Types.KindRepFun $krep2_rURJ $krep8_rURP

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_rURR :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep10_rURR = GHC.Types.KindRepFun $krep2_rURJ $krep9_rURQ

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tcBounded3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Enum.$tcBounded3 = "Bounded"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tcBounded2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$tcBounded2 = GHC.Types.TrNameS GHC.Enum.$tcBounded3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tcBounded :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Enum.$tcBounded
  = GHC.Types.TyCon
      15333921930693502724##
      670716372614077232##
      GHC.Enum.$trModule
      GHC.Enum.$tcBounded2
      0#
      GHC.Enum.$tcBounded1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_rURS :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep11_rURS
  = GHC.Types.KindRepTyConApp GHC.Enum.$tcBounded $krep6_rURN

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_rURT :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep12_rURT = GHC.Types.KindRepFun $krep2_rURJ $krep11_rURS

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tc'C:Bounded1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Enum.$tc'C:Bounded1
  = GHC.Types.KindRepFun $krep2_rURJ $krep12_rURT

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tc'C:Bounded3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Enum.$tc'C:Bounded3 = "'C:Bounded"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tc'C:Bounded2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$tc'C:Bounded2 = GHC.Types.TrNameS GHC.Enum.$tc'C:Bounded3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tc'C:Bounded :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Enum.$tc'C:Bounded
  = GHC.Types.TyCon
      11653779171057733320##
      7915017773108857797##
      GHC.Enum.$trModule
      GHC.Enum.$tc'C:Bounded2
      1#
      GHC.Enum.$tc'C:Bounded1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tcEnum2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Enum.$tcEnum2 = "Enum"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tcEnum1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$tcEnum1 = GHC.Types.TrNameS GHC.Enum.$tcEnum2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tcEnum :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Enum.$tcEnum
  = GHC.Types.TyCon
      1732763130676021359##
      12945953424921799467##
      GHC.Enum.$trModule
      GHC.Enum.$tcEnum1
      0#
      GHC.Enum.$tcBounded1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13_rURU :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep13_rURU
  = GHC.Types.KindRepTyConApp GHC.Enum.$tcEnum $krep6_rURN

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep14_rURV :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep14_rURV = GHC.Types.KindRepFun $krep10_rURR $krep13_rURU

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep15_rURW :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep15_rURW = GHC.Types.KindRepFun $krep9_rURQ $krep14_rURV

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep16_rURX :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep16_rURX = GHC.Types.KindRepFun $krep9_rURQ $krep15_rURW

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep17_rURY :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep17_rURY = GHC.Types.KindRepFun $krep8_rURP $krep16_rURX

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep18_rURZ :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep18_rURZ = GHC.Types.KindRepFun $krep4_rURL $krep17_rURY

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep19_rUS0 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep19_rUS0 = GHC.Types.KindRepFun $krep5_rURM $krep18_rURZ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep20_rUS1 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep20_rUS1 = GHC.Types.KindRepFun $krep3_rURK $krep19_rUS0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tc'C:Enum1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Enum.$tc'C:Enum1
  = GHC.Types.KindRepFun $krep3_rURK $krep20_rUS1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tc'C:Enum3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Enum.$tc'C:Enum3 = "'C:Enum"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tc'C:Enum2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Enum.$tc'C:Enum2 = GHC.Types.TrNameS GHC.Enum.$tc'C:Enum3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$tc'C:Enum :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Enum.$tc'C:Enum
  = GHC.Types.TyCon
      1558011785351316622##
      1214604065930072985##
      GHC.Enum.$trModule
      GHC.Enum.$tc'C:Enum2
      1#
      GHC.Enum.$tc'C:Enum1

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord4 :: Word
[GblId, Str=x]
GHC.Enum.$fEnumWord4 = succError @ Word lvl32_rURc

-- RHS size: {terms: 13, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord_$csucc :: Word -> Word
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_aQgw [Occ=Once!] :: Word) ->
                 case x_aQgw of { W# x1_aRJ2 [Occ=Once!] ->
                 case x1_aRJ2 of wild1_Xar {
                   __DEFAULT -> GHC.Types.W# (plusWord# wild1_Xar 1##);
                   18446744073709551615## -> GHC.Enum.$fEnumWord4
                 }
                 }}]
GHC.Enum.$fEnumWord_$csucc
  = \ (x_aQgw :: Word) ->
      case x_aQgw of { W# x1_aRJ2 ->
      case x1_aRJ2 of wild1_Xar {
        __DEFAULT -> GHC.Types.W# (plusWord# wild1_Xar 1##);
        18446744073709551615## -> GHC.Enum.$fEnumWord4
      }
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord3 :: Word
[GblId, Str=x]
GHC.Enum.$fEnumWord3 = predError @ Word lvl32_rURc

-- RHS size: {terms: 13, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord_$cpred :: Word -> Word
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_aQgx [Occ=Once!] :: Word) ->
                 case x_aQgx of { W# x1_aRJ2 [Occ=Once!] ->
                 case x1_aRJ2 of wild1_Xat {
                   __DEFAULT -> GHC.Types.W# (minusWord# wild1_Xat 1##);
                   0## -> GHC.Enum.$fEnumWord3
                 }
                 }}]
GHC.Enum.$fEnumWord_$cpred
  = \ (x_aQgx :: Word) ->
      case x_aQgx of { W# x1_aRJ2 ->
      case x1_aRJ2 of wild1_Xat {
        __DEFAULT -> GHC.Types.W# (minusWord# wild1_Xat 1##);
        0## -> GHC.Enum.$fEnumWord3
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$wlvl2 [InlPrag=NOUSERINLINE[0]] :: Int# -> Word
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
GHC.Enum.$wlvl2
  = \ (ww_sTMS :: Int#) ->
      GHC.Enum.$wtoEnumError
        @ Word
        @ Word
        GHC.Show.$fShowWord
        lvl32_rURc
        ww_sTMS
        GHC.Enum.$fBoundedWord_$cminBound
        GHC.Enum.$fBoundedWord_$cmaxBound

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord2 [InlPrag=NOUSERINLINE[0]] :: Int -> Word
[GblId,
 Arity=1,
 Str=<B,1*U(U)>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sTMP [Occ=Once!] :: Int) ->
                 case w_sTMP of { I# ww1_sTMS [Occ=Once] ->
                 GHC.Enum.$wlvl2 ww1_sTMS
                 }}]
GHC.Enum.$fEnumWord2
  = \ (w_sTMP :: Int) ->
      case w_sTMP of { I# ww1_sTMS -> GHC.Enum.$wlvl2 ww1_sTMS }

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord_$ctoEnum :: Int -> Word
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_aQgy [Occ=Once!] :: Int) ->
                 case i_aQgy of wild_X8H { I# i#_aQgz ->
                 case >=# i#_aQgz 0# of {
                   __DEFAULT -> GHC.Enum.$fEnumWord2 wild_X8H;
                   1# -> GHC.Types.W# (int2Word# i#_aQgz)
                 }
                 }}]
GHC.Enum.$fEnumWord_$ctoEnum
  = \ (i_aQgy :: Int) ->
      case i_aQgy of { I# i#_aQgz ->
      case >=# i#_aQgz 0# of {
        __DEFAULT -> GHC.Enum.$wlvl2 i#_aQgz;
        1# -> GHC.Types.W# (int2Word# i#_aQgz)
      }
      }

-- RHS size: {terms: 16, types: 3, coercions: 0, joins: 0/0}
efdWord :: Word# -> Word# -> [Word]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 101 0}]
efdWord
  = \ (x1_aQjG :: Word#) (x2_aQjH :: Word#) ->
      case geWord# x2_aQjH x1_aQjG of {
        __DEFAULT -> efdtWordDn x1_aQjG x2_aQjH 0##;
        1# -> efdtWordUp x1_aQjG x2_aQjH 18446744073709551615##
      }

-- RHS size: {terms: 11, types: 6, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord_$cenumFromThen [InlPrag=INLINE (sat-args=2)]
  :: Word -> Word -> [Word]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dRy8 [Occ=Once!] :: Word)
                 (ds1_dRy9 [Occ=Once!] :: Word) ->
                 case ds_dRy8 of { W# x1_aQgG [Occ=Once] ->
                 case ds1_dRy9 of { W# x2_aQgH [Occ=Once] ->
                 efdWord x1_aQgG x2_aQgH
                 }
                 }}]
GHC.Enum.$fEnumWord_$cenumFromThen
  = \ (ds_dRy8 :: Word) (ds1_dRy9 :: Word) ->
      case ds_dRy8 of { W# x1_aQgG ->
      case ds1_dRy9 of { W# x2_aQgH -> efdWord x1_aQgG x2_aQgH }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumWord [InlPrag=NOUSERINLINE CONLIKE] :: Enum Word
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Word
                       GHC.Enum.$fEnumWord_$csucc
                       GHC.Enum.$fEnumWord_$cpred
                       GHC.Enum.$fEnumWord_$ctoEnum
                       GHC.Enum.$fEnumWord_$cfromEnum
                       GHC.Enum.$fEnumWord_$cenumFrom
                       GHC.Enum.$fEnumWord_$cenumFromThen
                       GHC.Enum.$fEnumWord_$cenumFromTo
                       GHC.Enum.$fEnumWord_$cenumFromThenTo]
GHC.Enum.$fEnumWord
  = GHC.Enum.C:Enum
      @ Word
      GHC.Enum.$fEnumWord_$csucc
      GHC.Enum.$fEnumWord_$cpred
      GHC.Enum.$fEnumWord_$ctoEnum
      GHC.Enum.$fEnumWord_$cfromEnum
      GHC.Enum.$fEnumWord_$cenumFrom
      GHC.Enum.$fEnumWord_$cenumFromThen
      GHC.Enum.$fEnumWord_$cenumFromTo
      GHC.Enum.$fEnumWord_$cenumFromThenTo

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger_$csucc :: Integer -> Integer
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_aQgk [Occ=Once] :: Integer) ->
                 plusInteger x_aQgk GHC.Enum.$fEnumInteger1}]
GHC.Enum.$fEnumInteger_$csucc
  = \ (x_aQgk :: Integer) ->
      plusInteger x_aQgk GHC.Enum.$fEnumInteger1

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger_$cpred :: Integer -> Integer
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_aQgl [Occ=Once] :: Integer) ->
                 minusInteger x_aQgl GHC.Enum.$fEnumInteger1}]
GHC.Enum.$fEnumInteger_$cpred
  = \ (x_aQgl :: Integer) ->
      minusInteger x_aQgl GHC.Enum.$fEnumInteger1

Rec {
-- RHS size: {terms: 17, types: 18, coercions: 0, joins: 0/0}
GHC.Enum.$wenumDeltaInteger [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: Integer -> Integer -> (# Integer, [Integer] #)
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
GHC.Enum.$wenumDeltaInteger
  = \ (w_sTMX :: Integer) (w1_sTMY :: Integer) ->
      case w_sTMX of x_XQnU { __DEFAULT ->
      (# x_XQnU,
         case GHC.Enum.$wenumDeltaInteger
                (plusInteger x_XQnU w1_sTMY) w1_sTMY
         of
         { (# ww1_sTOn, ww2_sTOo #) ->
         GHC.Types.: @ Integer ww1_sTOn ww2_sTOo
         } #)
      }
end Rec }

Rec {
-- RHS size: {terms: 17, types: 11, coercions: 0, joins: 0/1}
enumDeltaIntegerFB [InlPrag=INLINE[0] (sat-args=3),
                    Occ=LoopBreaker!]
  :: forall b. (Integer -> b -> b) -> Integer -> Integer -> b
[GblId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_aQL1)
                 (c_aQko [Occ=OnceL!] :: Integer -> b_aQL1 -> b_aQL1)
                 (x0_aQkp [Occ=Once] :: Integer)
                 (d_aQkq [Occ=OnceL] :: Integer) ->
                 letrec {
                   go_aQL5 [Occ=LoopBreaker] :: Integer -> b_aQL1
                   [LclId, Arity=1, Unf=OtherCon []]
                   go_aQL5
                     = \ (x_aQks [Occ=Once] :: Integer) ->
                         case x_aQks of x1_XQkz { __DEFAULT ->
                         c_aQko x1_XQkz (go_aQL5 (plusInteger x1_XQkz d_aQkq))
                         }; } in
                 go_aQL5 x0_aQkp}]
enumDeltaIntegerFB
  = \ (@ b_aQL1)
      (c_aQko :: Integer -> b_aQL1 -> b_aQL1)
      (x0_aQkp :: Integer)
      (d_aQkq :: Integer) ->
      letrec {
        go_sRW0 [Occ=LoopBreaker] :: Integer -> b_aQL1
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_sRW0
          = \ (x_aQks :: Integer) ->
              case x_aQks of x1_XQnX { __DEFAULT ->
              c_aQko x1_XQnX (go_sRW0 (plusInteger x1_XQnX d_aQkq))
              }; } in
      go_sRW0 x0_aQkp

-- RHS size: {terms: 10, types: 12, coercions: 0, joins: 0/0}
enumDeltaInteger [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: Integer -> Integer -> [Integer]
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sTMX [Occ=Once] :: Integer)
                 (w1_sTMY [Occ=Once] :: Integer) ->
                 case GHC.Enum.$wenumDeltaInteger w_sTMX w1_sTMY of
                 { (# ww1_sTOn [Occ=Once], ww2_sTOo [Occ=Once] #) ->
                 GHC.Types.: @ Integer ww1_sTOn ww2_sTOo
                 }}]
enumDeltaInteger
  = \ (w_sTMX :: Integer) (w1_sTMY :: Integer) ->
      case GHC.Enum.$wenumDeltaInteger w_sTMX w1_sTMY of
      { (# ww1_sTOn, ww2_sTOo #) ->
      GHC.Types.: @ Integer ww1_sTOn ww2_sTOo
      }
end Rec }

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger_$cenumFrom [InlPrag=INLINE (sat-args=1)]
  :: Integer -> [Integer]
[GblId,
 Arity=1,
 Str=<S,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_aQgo [Occ=Once] :: Integer) ->
                 build
                   @ Integer
                   (\ (@ b_aRps)
                      (c_aQld [Occ=Once, OS=OneShot] :: Integer -> b_aRps -> b_aRps)
                      _ [Occ=Dead, OS=OneShot] ->
                      enumDeltaIntegerFB @ b_aRps c_aQld x_aQgo 1)}]
GHC.Enum.$fEnumInteger_$cenumFrom
  = \ (x_aQgo :: Integer) ->
      case GHC.Enum.$wenumDeltaInteger x_aQgo GHC.Enum.$fEnumInteger1 of
      { (# ww1_sTOn, ww2_sTOo #) ->
      GHC.Types.: @ Integer ww1_sTOn ww2_sTOo
      }

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger_$cenumFromThen [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Integer -> [Integer]
[GblId,
 Arity=2,
 Str=<S,U><L,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_aQgp :: Integer) (y_aQgq [Occ=Once] :: Integer) ->
                 build
                   @ Integer
                   (\ (@ b_aRps)
                      (c_aQld [Occ=Once, OS=OneShot] :: Integer -> b_aRps -> b_aRps)
                      _ [Occ=Dead, OS=OneShot] ->
                      enumDeltaIntegerFB
                        @ b_aRps c_aQld x_aQgp (minusInteger y_aQgq x_aQgp))}]
GHC.Enum.$fEnumInteger_$cenumFromThen
  = \ (eta_B2 :: Integer) (eta1_B1 :: Integer) ->
      case GHC.Enum.$wenumDeltaInteger
             eta_B2 (minusInteger eta1_B1 eta_B2)
      of
      { (# ww1_sTOn, ww2_sTOo #) ->
      GHC.Types.: @ Integer ww1_sTOn ww2_sTOo
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger2 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Enum.$fEnumInteger2 = 0

Rec {
-- RHS size: {terms: 43, types: 18, coercions: 0, joins: 0/2}
enumDeltaToInteger [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: Integer -> Integer -> Integer -> [Integer]
[GblId,
 Arity=3,
 Str=<S,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 350 0}]
enumDeltaToInteger
  = \ (x_aQkG :: Integer)
      (delta_aQkH :: Integer)
      (lim_aQkI :: Integer) ->
      case geInteger# delta_aQkH GHC.Enum.$fEnumInteger2 of {
        __DEFAULT ->
          letrec {
            go_sRVW [Occ=LoopBreaker] :: Integer -> [Integer]
            [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
            go_sRVW
              = \ (x1_aQla :: Integer) ->
                  case ltInteger# x1_aQla lim_aQkI of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ Integer x1_aQla (go_sRVW (plusInteger x1_aQla delta_aQkH));
                    1# -> GHC.Types.[] @ Integer
                  }; } in
          go_sRVW x_aQkG;
        1# ->
          letrec {
            go_sRVY [Occ=LoopBreaker] :: Integer -> [Integer]
            [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
            go_sRVY
              = \ (x1_aQl5 :: Integer) ->
                  case gtInteger# x1_aQl5 lim_aQkI of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ Integer x1_aQl5 (go_sRVY (plusInteger x1_aQl5 delta_aQkH));
                    1# -> GHC.Types.[] @ Integer
                  }; } in
          go_sRVY x_aQkG
      }

-- RHS size: {terms: 24, types: 12, coercions: 0, joins: 0/0}
enumDeltaToIntegerFB [InlPrag=INLINE[0] (sat-args=5),
                      Occ=LoopBreaker!]
  :: forall a.
     (Integer -> a -> a) -> a -> Integer -> Integer -> Integer -> a
[GblId,
 Arity=5,
 Str=<L,C(C1(U))><L,U><S,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_aQKN)
                 (c_aQkv [Occ=Once*] :: Integer -> a_aQKN -> a_aQKN)
                 (n_aQkw [Occ=Once*] :: a_aQKN)
                 (x_aQkx [Occ=Once*] :: Integer)
                 (delta_aQky :: Integer)
                 (lim_aQkz [Occ=Once*] :: Integer) ->
                 case geInteger# delta_aQky 0 of {
                   __DEFAULT ->
                     dn_fb @ a_aQKN c_aQkv n_aQkw x_aQkx delta_aQky lim_aQkz;
                   1# -> up_fb @ a_aQKN c_aQkv n_aQkw x_aQkx delta_aQky lim_aQkz
                 }}]
enumDeltaToIntegerFB
  = \ (@ a_aQKN)
      (eta_B5 :: Integer -> a_aQKN -> a_aQKN)
      (eta1_B4 :: a_aQKN)
      (eta2_B3 :: Integer)
      (eta3_B2 :: Integer)
      (eta4_B1 :: Integer) ->
      case geInteger# eta3_B2 GHC.Enum.$fEnumInteger2 of {
        __DEFAULT -> dn_fb @ a_aQKN eta_B5 eta1_B4 eta2_B3 eta3_B2 eta4_B1;
        1# -> up_fb @ a_aQKN eta_B5 eta1_B4 eta2_B3 eta3_B2 eta4_B1
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger_$cenumFromTo [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Integer -> [Integer]
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_aQgr [Occ=Once] :: Integer)
                 (lim_aQgs [Occ=Once] :: Integer) ->
                 build
                   @ Integer
                   (\ (@ b_aRpY)
                      (c_aQll [Occ=Once, OS=OneShot] :: Integer -> b_aRpY -> b_aRpY)
                      (n_aQlm [Occ=Once, OS=OneShot] :: b_aRpY) ->
                      enumDeltaToInteger1FB @ b_aRpY c_aQll n_aQlm x_aQgr lim_aQgs)}]
GHC.Enum.$fEnumInteger_$cenumFromTo = enumDeltaToInteger1

-- RHS size: {terms: 9, types: 3, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger_$cenumFromThenTo [InlPrag=INLINE (sat-args=3)]
  :: Integer -> Integer -> Integer -> [Integer]
[GblId,
 Arity=3,
 Str=<S,U><S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_aQgt :: Integer)
                 (y_aQgu [Occ=Once] :: Integer)
                 (lim_aQgv [Occ=Once] :: Integer) ->
                 build
                   @ Integer
                   (\ (@ b_aRpJ)
                      (c_aQlh [Occ=Once, OS=OneShot] :: Integer -> b_aRpJ -> b_aRpJ)
                      (n_aQli [Occ=Once, OS=OneShot] :: b_aRpJ) ->
                      enumDeltaToIntegerFB
                        @ b_aRpJ
                        c_aQlh
                        n_aQli
                        x_aQgt
                        (minusInteger y_aQgu x_aQgt)
                        lim_aQgv)}]
GHC.Enum.$fEnumInteger_$cenumFromThenTo
  = \ (eta_B3 :: Integer)
      (eta1_B2 :: Integer)
      (eta2_B1 :: Integer) ->
      enumDeltaToInteger eta_B3 (minusInteger eta1_B2 eta_B3) eta2_B1

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
GHC.Enum.$fEnumInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum Integer
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Integer
                       GHC.Enum.$fEnumInteger_$csucc
                       GHC.Enum.$fEnumInteger_$cpred
                       GHC.Enum.$fEnumInteger_$ctoEnum
                       GHC.Enum.$fEnumInteger_$cfromEnum
                       GHC.Enum.$fEnumInteger_$cenumFrom
                       GHC.Enum.$fEnumInteger_$cenumFromThen
                       GHC.Enum.$fEnumInteger_$cenumFromTo
                       GHC.Enum.$fEnumInteger_$cenumFromThenTo]
GHC.Enum.$fEnumInteger
  = GHC.Enum.C:Enum
      @ Integer
      GHC.Enum.$fEnumInteger_$csucc
      GHC.Enum.$fEnumInteger_$cpred
      GHC.Enum.$fEnumInteger_$ctoEnum
      GHC.Enum.$fEnumInteger_$cfromEnum
      GHC.Enum.$fEnumInteger_$cenumFrom
      GHC.Enum.$fEnumInteger_$cenumFromThen
      GHC.Enum.$fEnumInteger_$cenumFromTo
      GHC.Enum.$fEnumInteger_$cenumFromThenTo


------ Local rules for imported ids --------
"eftCharList" [1]
    forall.
      eftCharFB @ [Char] (GHC.Types.: @ Char) (GHC.Types.[] @ Char)
      = eftChar
"eftChar" [~1]
    forall (x_aQlI :: Int#) (y_aQlJ :: Int#).
      eftChar x_aQlI y_aQlJ
      = build
          @ Char
          (\ (@ b_aRrZ)
             (c_aQlK [OS=OneShot] :: Char -> b_aRrZ -> b_aRrZ)
             (n_aQlL [OS=OneShot] :: b_aRrZ) ->
             eftCharFB @ b_aRrZ c_aQlK n_aQlL x_aQlI y_aQlJ)
"efdtCharList" [1]
    forall.
      efdtCharFB @ [Char] (GHC.Types.: @ Char) (GHC.Types.[] @ Char)
      = efdtChar
"efdtChar" [~1]
    forall (x1_aQlQ :: Int#) (x2_aQlR :: Int#) (l_aQlS :: Int#).
      efdtChar x1_aQlQ x2_aQlR l_aQlS
      = build
          @ Char
          (\ (@ b_aRsv)
             (c_aQlT [OS=OneShot] :: Char -> b_aRsv -> b_aRsv)
             (n_aQlU [OS=OneShot] :: b_aRsv) ->
             efdtCharFB @ b_aRsv c_aQlT n_aQlU x1_aQlQ x2_aQlR l_aQlS)
"efdCharList" [1]
    forall.
      efdCharFB @ [Char] (GHC.Types.: @ Char) (GHC.Types.[] @ Char)
      = efdChar
"efdChar" [~1]
    forall (x1_aQlM :: Int#) (x2_aQlN :: Int#).
      efdChar x1_aQlM x2_aQlN
      = build
          @ Char
          (\ (@ b_aRse)
             (c_aQlO [OS=OneShot] :: Char -> b_aRse -> b_aRse)
             (n_aQlP [OS=OneShot] :: b_aRse) ->
             efdCharFB @ b_aRse c_aQlO n_aQlP x1_aQlM x2_aQlN)
"eftInt" [~1]
    forall (x_aQlE :: Int#) (y_aQlF :: Int#).
      eftInt x_aQlE y_aQlF
      = build
          @ Int
          (\ (@ b_aRrF)
             (c_aQlG [OS=OneShot] :: Int -> b_aRrF -> b_aRrF)
             (n_aQlH [OS=OneShot] :: b_aRrF) ->
             eftIntFB @ b_aRrF c_aQlG n_aQlH x_aQlE y_aQlF)
"eftIntList" [1]
    forall.
      eftIntFB @ [Int] (GHC.Types.: @ Int) (GHC.Types.[] @ Int)
      = eftInt
"efdtInt" [~1]
    forall (x1_aQlz :: Int#) (x2_aQlA :: Int#) (y_aQlB :: Int#).
      efdtInt x1_aQlz x2_aQlA y_aQlB
      = build
          @ Int
          (\ (@ b_aRrl)
             (c_aQlC [OS=OneShot] :: Int -> b_aRrl -> b_aRrl)
             (n_aQlD [OS=OneShot] :: b_aRrl) ->
             efdtIntFB @ b_aRrl c_aQlC n_aQlD x1_aQlz x2_aQlA y_aQlB)
"efdtIntUpList" [1]
    forall.
      efdtIntFB @ [Int] (GHC.Types.: @ Int) (GHC.Types.[] @ Int)
      = efdtInt
"eftWord" [~1]
    forall (x_aQlv :: Word#) (y_aQlw :: Word#).
      eftWord x_aQlv y_aQlw
      = build
          @ Word
          (\ (@ b_aRqZ)
             (c_aQlx [OS=OneShot] :: Word -> b_aRqZ -> b_aRqZ)
             (n_aQly [OS=OneShot] :: b_aRqZ) ->
             eftWordFB @ b_aRqZ c_aQlx n_aQly x_aQlv y_aQlw)
"eftWordList" [1]
    forall.
      eftWordFB @ [Word] (GHC.Types.: @ Word) (GHC.Types.[] @ Word)
      = eftWord
"efdtWord" [~1]
    forall (x1_aQlq :: Word#) (x2_aQlr :: Word#) (y_aQls :: Word#).
      efdtWord x1_aQlq x2_aQlr y_aQls
      = build
          @ Word
          (\ (@ b_aRqF)
             (c_aQlt [OS=OneShot] :: Word -> b_aRqF -> b_aRqF)
             (n_aQlu [OS=OneShot] :: b_aRqF) ->
             efdtWordFB @ b_aRqF c_aQlt n_aQlu x1_aQlq x2_aQlr y_aQls)
"efdtWordUpList" [1]
    forall.
      efdtWordFB @ [Word] (GHC.Types.: @ Word) (GHC.Types.[] @ Word)
      = efdtWord
"enumDeltaToInteger1" [1]
    forall.
      enumDeltaToInteger1FB @ [Integer]
                            (GHC.Types.: @ Integer)
                            (GHC.Types.[] @ Integer)
      = enumDeltaToInteger1
"enumDeltaInteger" [1]
    forall.
      enumDeltaIntegerFB @ [Integer] (GHC.Types.: @ Integer)
      = enumDeltaInteger
"enumDeltaInteger" [~1]
    forall (x_aQlb :: Integer) (y_aQlc :: Integer).
      enumDeltaInteger x_aQlb y_aQlc
      = build
          @ Integer
          (\ (@ b_aRps)
             (c_aQld [OS=OneShot] :: Integer -> b_aRps -> b_aRps)
             _ [Occ=Dead, OS=OneShot] ->
             enumDeltaIntegerFB @ b_aRps c_aQld x_aQlb y_aQlc)
"efdtInteger1" [~1]
    forall (x_aQlj :: Integer) (l_aQlk :: Integer).
      enumDeltaToInteger x_aQlj 1 l_aQlk
      = build
          @ Integer
          (\ (@ b_aRpY)
             (c_aQll [OS=OneShot] :: Integer -> b_aRpY -> b_aRpY)
             (n_aQlm [OS=OneShot] :: b_aRpY) ->
             enumDeltaToInteger1FB @ b_aRpY c_aQll n_aQlm x_aQlj l_aQlk)
"efdtInteger" [~1]
    forall (x_aQle :: Integer) (d_aQlf :: Integer) (l_aQlg :: Integer).
      enumDeltaToInteger x_aQle d_aQlf l_aQlg
      = build
          @ Integer
          (\ (@ b_aRpJ)
             (c_aQlh [OS=OneShot] :: Integer -> b_aRpJ -> b_aRpJ)
             (n_aQli [OS=OneShot] :: b_aRpJ) ->
             enumDeltaToIntegerFB @ b_aRpJ c_aQlh n_aQli x_aQle d_aQlf l_aQlg)
"enumDeltaToInteger" [1]
    forall.
      enumDeltaToIntegerFB @ [Integer]
                           (GHC.Types.: @ Integer)
                           (GHC.Types.[] @ Integer)
      = enumDeltaToInteger
"enumDeltaToInteger1FB" [1]
    forall (@ a_aRqe)
           (c_aQln :: Integer -> a_aRqe -> a_aRqe)
           (n_aQlo :: a_aRqe)
           (x_aQlp :: Integer).
      enumDeltaToIntegerFB @ a_aRqe c_aQln n_aQlo x_aQlp 1
      = enumDeltaToInteger1FB @ a_aRqe c_aQln n_aQlo x_aQlp

