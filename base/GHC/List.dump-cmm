
==================== Output Cmm ====================
2018-03-16 15:55:06.296153514 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:06.297471938 UTC

[section ""data" . $wunsafeDrop_ru8P_closure" {
     $wunsafeDrop_ru8P_closure:
         const $wunsafeDrop_ru8P_info;
 },
 $wunsafeDrop_ru8P_entry() //  [R2, R3]
         { info_tbl: [(culQ,
                       label: $wunsafeDrop_ru8P_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       culQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto culR; else goto uum5;
       culR: // global
           R3 = R3;
           R2 = R2;
           R1 = $wunsafeDrop_ru8P_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uum5: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _culG() args: 0, res: 0, upd: 0;
     }
 },
 _culG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       culG: // global
           I64[Sp - 8] = block_culJ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uum7; else goto culK;
       uum7: // global
           call _culJ(R1) args: 0, res: 0, upd: 0;
       culK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _culJ() //  [R1]
         { info_tbl: [(culJ,
                       label: block_culJ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       culJ: // global
           if (R1 & 7 == 1) goto culN; else goto culO;
       culN: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       culO: // global
           _su9x::P64 = P64[R1 + 14];
           _su9y::I64 = I64[Sp + 8];
           if (_su9y::I64 != 1) goto cum1; else goto cum2;
       cum1: // global
           I64[Sp + 8] = _su9y::I64 - 1;
           P64[Sp + 16] = _su9x::P64;
           Sp = Sp + 8;
           call _culG() args: 0, res: 0, upd: 0;
       cum2: // global
           R1 = _su9x::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.299126628 UTC

[section ""data" . GHC.List.drop_closure" {
     GHC.List.drop_closure:
         const GHC.List.drop_info;
 },
 GHC.List.drop_entry() //  [R2, R3]
         { info_tbl: [(cumh,
                       label: GHC.List.drop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cumh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cumi; else goto cumj;
       cumi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.drop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cumj: // global
           I64[Sp - 16] = block_cume_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uums; else goto cumf;
       uums: // global
           call _cume(R1) args: 0, res: 0, upd: 0;
       cumf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cume() //  [R1]
         { info_tbl: [(cume,
                       label: block_cume_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cume: // global
           _su9B::P64 = P64[Sp + 8];
           _su9D::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_su9D::I64, 0)) goto cumq; else goto cumr;
       cumq: // global
           R3 = _su9B::P64;
           R2 = _su9D::I64;
           Sp = Sp + 16;
           call $wunsafeDrop_ru8P_entry(R3, R2) args: 8, res: 0, upd: 8;
       cumr: // global
           R1 = _su9B::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.308403608 UTC

[section ""data" . GHC.List.$wsplitAt'_closure" {
     GHC.List.$wsplitAt'_closure:
         const GHC.List.$wsplitAt'_info;
 },
 ds2_su9N_entry() //  [R1]
         { info_tbl: [(cumQ,
                       label: ds2_su9N_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cumQ: // global
           _su9N::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cumW; else goto cumX;
       cumX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cumZ; else goto cumY;
       cumZ: // global
           HpAlloc = 16;
           goto cumW;
       cumW: // global
           R1 = _su9N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cumY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _su9N::P64;
           _su9J::P64 = P64[_su9N::P64 + 16];
           _su9O::I64 = I64[_su9N::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _su9O::I64;
           I64[Sp - 24] = block_cumT_info;
           R3 = _su9J::P64;
           R2 = Hp - 7;
           Sp = Sp - 24;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cumT() //  [R1, R2]
         { info_tbl: [(cumT,
                       label: block_cumT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cumT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cun2; else goto cun1;
       cun2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cun1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wsplitAt'_entry() //  [R2, R3]
         { info_tbl: [(cun7,
                       label: GHC.List.$wsplitAt'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cun7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cun8; else goto cun9;
       cun8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wsplitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cun9: // global
           I64[Sp - 16] = block_cumx_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uunp; else goto cumy;
       uunp: // global
           call _cumx(R1) args: 0, res: 0, upd: 0;
       cumy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cumx() //  [R1]
         { info_tbl: [(cumx,
                       label: block_cumx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cumx: // global
           if (R1 & 7 == 1) goto cun4; else goto cun5;
       cun4: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cun5: // global
           I64[Sp - 8] = block_cumD_info;
           _su9I::P64 = P64[R1 + 6];
           _su9J::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _su9J::P64;
           P64[Sp + 8] = _su9I::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuno; else goto cumE;
       uuno: // global
           call _cumD(R1) args: 0, res: 0, upd: 0;
       cumE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cumD() //  [R1]
         { info_tbl: [(cumD,
                       label: block_cumD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cumD: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cunf; else goto cune;
       cunf: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cune: // global
           _su9I::P64 = P64[Sp + 16];
           _su9J::P64 = P64[Sp + 8];
           _su9M::I64 = I64[R1 + 7];
           if (_su9M::I64 != 1) goto cunk; else goto cunn;
       cunk: // global
           I64[Hp - 96] = ds2_su9N_info;
           P64[Hp - 80] = _su9J::P64;
           I64[Hp - 72] = _su9M::I64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cumK::P64 = Hp - 96;
           P64[Hp - 48] = _cumK::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cumK::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _su9I::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cunn: // global
           I64[Hp - 96] = :_con_info;
           P64[Hp - 88] = _su9I::P64;
           P64[Hp - 80] = GHC.Types.[]_closure+1;
           _cunm::P64 = Hp - 94;
           Hp = Hp - 80;
           R2 = _su9J::P64;
           R1 = _cunm::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.31117664 UTC

[section ""data" . GHC.List.splitAt_splitAt'_closure" {
     GHC.List.splitAt_splitAt'_closure:
         const GHC.List.splitAt_splitAt'_info;
 },
 GHC.List.splitAt_splitAt'_entry() //  [R2, R3]
         { info_tbl: [(cunx,
                       label: GHC.List.splitAt_splitAt'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cunx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cuny; else goto cunz;
       cuny: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_splitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cunz: // global
           I64[Sp - 8] = block_cunu_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cunu() //  [R1, R2]
         { info_tbl: [(cunu,
                       label: block_cunu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cunu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cunC; else goto cunB;
       cunC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cunB: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.312643088 UTC

[section ""data" . GHC.List.splitAt_closure" {
     GHC.List.splitAt_closure:
         const GHC.List.splitAt_info;
 },
 GHC.List.splitAt_entry() //  [R2, R3]
         { info_tbl: [(cunK,
                       label: GHC.List.splitAt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cunK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cunL; else goto cunM;
       cunL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cunM: // global
           I64[Sp - 16] = block_cunH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuo6; else goto cunI;
       uuo6: // global
           call _cunH(R1) args: 0, res: 0, upd: 0;
       cunI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cunH() //  [R1]
         { info_tbl: [(cunH,
                       label: block_cunH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cunH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cunR; else goto cunQ;
       cunR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cunQ: // global
           _sua9::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto cunZ; else goto cuo5;
       cunZ: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_cunV_info;
           R3 = _sua9::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
       cuo5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = _sua9::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cunV() //  [R1, R2]
         { info_tbl: [(cunV,
                       label: block_cunV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cunV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuo2; else goto cuo1;
       cuo2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cuo1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.314081744 UTC

[section ""cstring" . GHC.List.$trModule4_bytes" {
     GHC.List.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.314604948 UTC

[section ""data" . GHC.List.$trModule3_closure" {
     GHC.List.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.315131779 UTC

[section ""cstring" . GHC.List.$trModule2_bytes" {
     GHC.List.$trModule2_bytes:
         I8[] [71,72,67,46,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.315677428 UTC

[section ""data" . GHC.List.$trModule1_closure" {
     GHC.List.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.316234571 UTC

[section ""data" . GHC.List.$trModule_closure" {
     GHC.List.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.List.$trModule3_closure+1;
         const GHC.List.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.317365115 UTC

[section ""data" . GHC.List.init1_closure" {
     GHC.List.init1_closure:
         const GHC.List.init1_info;
 },
 sat_sual_entry() //  [R1]
         { info_tbl: [(cuol,
                       label: sat_sual_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuol: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuom; else goto cuon;
       cuom: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuon: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.init1_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.init1_entry() //  [R2, R3]
         { info_tbl: [(cuos,
                       label: GHC.List.init1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuos: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuot; else goto cuou;
       cuot: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.init1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuou: // global
           I64[Sp - 16] = block_cuob_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuoB; else goto cuoc;
       uuoB: // global
           call _cuob(R1) args: 0, res: 0, upd: 0;
       cuoc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuob() //  [R1]
         { info_tbl: [(cuob,
                       label: block_cuob_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuob: // global
           if (R1 & 7 == 1) goto cuop; else goto cuoq;
       cuop: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuoq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cuoA; else goto cuoz;
       cuoA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuoz: // global
           _suaj::P64 = P64[R1 + 6];
           _suak::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sual_info;
           P64[Hp - 32] = _suaj::P64;
           P64[Hp - 24] = _suak::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.318793694 UTC

[section ""cstring" . lvl_ru8Q_bytes" {
     lvl_ru8Q_bytes:
         I8[] [58,32,101,109,112,116,121,32,108,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.319511723 UTC

[section ""data" . lvl1_ru8R_closure" {
     lvl1_ru8R_closure:
         const lvl1_ru8R_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ru8R_entry() //  [R1]
         { info_tbl: [(cuoI,
                       label: lvl1_ru8R_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuoI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuoJ; else goto cuoK;
       cuoJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuoK: // global
           (_cuoF::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuoF::I64 == 0) goto cuoH; else goto cuoG;
       cuoH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuoG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuoF::I64;
           R2 = lvl_ru8Q_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.32038591 UTC

[section ""cstring" . GHC.List.!!4_bytes" {
     GHC.List.!!4_bytes:
         I8[] [80,114,101,108,117,100,101,46]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.321089678 UTC

[section ""data" . GHC.List.prel_list_str_closure" {
     GHC.List.prel_list_str_closure:
         const GHC.List.prel_list_str_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.prel_list_str_entry() //  [R1]
         { info_tbl: [(cuoR,
                       label: GHC.List.prel_list_str_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuoR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuoS; else goto cuoT;
       cuoS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuoT: // global
           (_cuoO::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuoO::I64 == 0) goto cuoQ; else goto cuoP;
       cuoQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuoP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuoO::I64;
           R2 = GHC.List.!!4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.322343851 UTC

[section ""data" . GHC.List.errorEmptyList_closure" {
     GHC.List.errorEmptyList_closure:
         const GHC.List.errorEmptyList_info;
         const 0;
 },
 sat_suan_entry() //  [R1]
         { info_tbl: [(cup2,
                       label: sat_suan_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cup2: // global
           R3 = lvl1_ru8R_closure;
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.errorEmptyList_entry() //  [R2]
         { info_tbl: [(cup7,
                       label: GHC.List.errorEmptyList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cup7: // global
           _suam::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cup8; else goto cup9;
       cup9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cupb; else goto cupa;
       cupb: // global
           HpAlloc = 24;
           goto cup8;
       cup8: // global
           R2 = _suam::P64;
           R1 = GHC.List.errorEmptyList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cupa: // global
           I64[Hp - 16] = sat_suan_info;
           P64[Hp] = _suam::P64;
           I64[Sp - 8] = block_cup5_info;
           R3 = Hp - 16;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cup5() //  [R1]
         { info_tbl: [(cup5,
                       label: block_cup5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cup5: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.32408037 UTC

[section ""cstring" . lvl2_ru8S_bytes" {
     lvl2_ru8S_bytes:
         I8[] [33,33,58,32,110,101,103,97,116,105,118,101,32,105,110,100,101,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.324789157 UTC

[section ""data" . lvl3_ru8T_closure" {
     lvl3_ru8T_closure:
         const lvl3_ru8T_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_ru8T_entry() //  [R1]
         { info_tbl: [(cupm,
                       label: lvl3_ru8T_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cupm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cupn; else goto cupo;
       cupn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cupo: // global
           (_cupj::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cupj::I64 == 0) goto cupl; else goto cupk;
       cupl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cupk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cupj::I64;
           R2 = lvl2_ru8S_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.325967925 UTC

[section ""data" . GHC.List.negIndex_closure" {
     GHC.List.negIndex_closure:
         const GHC.List.negIndex_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.negIndex_entry() //  [R1]
         { info_tbl: [(cupx,
                       label: GHC.List.negIndex_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cupx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cupy; else goto cupz;
       cupy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cupz: // global
           (_cups::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cups::I64 == 0) goto cupu; else goto cupt;
       cupu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cupt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cups::I64;
           I64[Sp - 24] = block_cupv_info;
           R3 = lvl3_ru8T_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cupv() //  [R1]
         { info_tbl: [(cupv,
                       label: block_cupv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cupv: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.326911732 UTC

[section ""cstring" . GHC.List.!!3_bytes" {
     GHC.List.!!3_bytes:
         I8[] [33,33,58,32,105,110,100,101,120,32,116,111,111,32,108,97,114,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.327618787 UTC

[section ""data" . GHC.List.!!2_closure" {
     GHC.List.!!2_closure:
         const GHC.List.!!2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!2_entry() //  [R1]
         { info_tbl: [(cupJ,
                       label: GHC.List.!!2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cupJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cupK; else goto cupL;
       cupK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cupL: // global
           (_cupG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cupG::I64 == 0) goto cupI; else goto cupH;
       cupI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cupH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cupG::I64;
           R2 = GHC.List.!!3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.328641954 UTC

[section ""data" . GHC.List.!!1_closure" {
     GHC.List.!!1_closure:
         const GHC.List.!!1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!1_entry() //  [R1]
         { info_tbl: [(cupS,
                       label: GHC.List.!!1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cupS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cupT; else goto cupU;
       cupT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cupU: // global
           (_cupP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cupP::I64 == 0) goto cupR; else goto cupQ;
       cupR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cupQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cupP::I64;
           R3 = GHC.List.!!2_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.329653544 UTC

[section ""data" . GHC.List.tooLarge_closure" {
     GHC.List.tooLarge_closure:
         const GHC.List.tooLarge_info;
         const 0;
 },
 GHC.List.tooLarge_entry() //  []
         { info_tbl: [(cupZ,
                       label: GHC.List.tooLarge_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cupZ: // global
           R2 = GHC.List.!!1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.330484492 UTC

[section ""data" . poly_exit_ru8U_closure" {
     poly_exit_ru8U_closure:
         const poly_exit_ru8U_info;
         const 0;
         const 0;
         const 0;
 },
 poly_exit_ru8U_entry() //  [R1]
         { info_tbl: [(cuq8,
                       label: poly_exit_ru8U_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuq8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuq9; else goto cuqa;
       cuq9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuqa: // global
           (_cuq5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuq5::I64 == 0) goto cuq7; else goto cuq6;
       cuq7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuq6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuq5::I64;
           R2 = GHC.List.!!1_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.331795097 UTC

[section ""data" . poly_$wgo_ru8V_closure" {
     poly_$wgo_ru8V_closure:
         const poly_$wgo_ru8V_info;
         const 0;
 },
 poly_$wgo_ru8V_entry() //  [R2, R3]
         { info_tbl: [(cuqm,
                       label: poly_$wgo_ru8V_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuqm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuqn; else goto uuqB;
       cuqn: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_$wgo_ru8V_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uuqB: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cuqc() args: 0, res: 0, upd: 0;
     }
 },
 _cuqc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuqc: // global
           _suar::P64 = P64[Sp];
           I64[Sp] = block_cuqf_info;
           R1 = _suar::P64;
           if (R1 & 7 != 0) goto uuqD; else goto cuqg;
       uuqD: // global
           call _cuqf(R1) args: 0, res: 0, upd: 0;
       cuqg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuqf() //  [R1]
         { info_tbl: [(cuqf,
                       label: block_cuqf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuqf: // global
           if (R1 & 7 == 1) goto cuqj; else goto cuqk;
       cuqj: // global
           R1 = poly_exit_ru8U_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cuqk: // global
           _suaw::I64 = I64[Sp + 8];
           if (_suaw::I64 != 0) goto cuqx; else goto cuqy;
       cuqx: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _suaw::I64 - 1;
           call _cuqc() args: 0, res: 0, upd: 0;
       cuqy: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.333201043 UTC

[section ""data" . GHC.List.$w!!_closure" {
     GHC.List.$w!!_closure:
         const GHC.List.$w!!_info;
         const 0;
 },
 GHC.List.$w!!_entry() //  [R2, R3]
         { info_tbl: [(cuqP,
                       label: GHC.List.$w!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuqP: // global
           if (%MO_S_Ge_W64(R3, 0)) goto cuqN; else goto cuqO;
       cuqN: // global
           R3 = R3;
           R2 = R2;
           call poly_$wgo_ru8V_entry(R3, R2) args: 8, res: 0, upd: 8;
       cuqO: // global
           R1 = GHC.List.negIndex_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.334223927 UTC

[section ""data" . GHC.List.!!_closure" {
     GHC.List.!!_closure:
         const GHC.List.!!_info;
         const 0;
 },
 GHC.List.!!_entry() //  [R2, R3]
         { info_tbl: [(cuqZ,
                       label: GHC.List.!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuqZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cur0; else goto cur1;
       cur0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.!!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cur1: // global
           I64[Sp - 16] = block_cuqW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uur5; else goto cuqX;
       uur5: // global
           call _cuqW(R1) args: 0, res: 0, upd: 0;
       cuqX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuqW() //  [R1]
         { info_tbl: [(cuqW,
                       label: block_cuqW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuqW: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$w!!_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.335221748 UTC

[section ""cstring" . lvl4_ru8W_bytes" {
     lvl4_ru8W_bytes:
         I8[] [99,121,99,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.33591882 UTC

[section ""data" . lvl5_ru8X_closure" {
     lvl5_ru8X_closure:
         const lvl5_ru8X_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_ru8X_entry() //  [R1]
         { info_tbl: [(curc,
                       label: lvl5_ru8X_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       curc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto curd; else goto cure;
       curd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cure: // global
           (_cur9::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cur9::I64 == 0) goto curb; else goto cura;
       curb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cura: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cur9::I64;
           R2 = lvl4_ru8W_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.336939872 UTC

[section ""data" . GHC.List.cycle1_closure" {
     GHC.List.cycle1_closure:
         const GHC.List.cycle1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.cycle1_entry() //  [R1]
         { info_tbl: [(curl,
                       label: GHC.List.cycle1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       curl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto curm; else goto curn;
       curm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       curn: // global
           (_curi::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_curi::I64 == 0) goto curk; else goto curj;
       curk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       curj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _curi::I64;
           R2 = lvl5_ru8X_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.338281676 UTC

[section ""data" . GHC.List.cycle_closure" {
     GHC.List.cycle_closure:
         const GHC.List.cycle_info;
         const 0;
 },
 xs'_suaJ_entry() //  [R1]
         { info_tbl: [(curC,
                       label: xs'_suaJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       curC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto curD; else goto curE;
       curD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       curE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.cycle_entry() //  [R2]
         { info_tbl: [(curJ,
                       label: GHC.List.cycle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       curJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto curK; else goto curL;
       curK: // global
           R2 = R2;
           R1 = GHC.List.cycle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       curL: // global
           I64[Sp - 8] = block_curs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uurR; else goto curt;
       uurR: // global
           call _curs(R1) args: 0, res: 0, upd: 0;
       curt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _curs() //  [R1]
         { info_tbl: [(curs,
                       label: block_curs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       curs: // global
           if (R1 & 7 == 1) goto curG; else goto curH;
       curG: // global
           R1 = GHC.List.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       curH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto curQ; else goto curP;
       curQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       curP: // global
           I64[Hp - 16] = xs'_suaJ_info;
           P64[Hp] = R1;
           R1 = (Hp + -16) & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.340307558 UTC

[section ""cstring" . lvl6_ru8Y_bytes" {
     lvl6_ru8Y_bytes:
         I8[] [102,111,108,100,114,49]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.341079729 UTC

[section ""data" . lvl7_ru8Z_closure" {
     lvl7_ru8Z_closure:
         const lvl7_ru8Z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_ru8Z_entry() //  [R1]
         { info_tbl: [(curY,
                       label: lvl7_ru8Z_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       curY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto curZ; else goto cus0;
       curZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cus0: // global
           (_curV::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_curV::I64 == 0) goto curX; else goto curW;
       curX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       curW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _curV::I64;
           R2 = lvl6_ru8Y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.342483588 UTC

[section ""data" . lvl8_ru90_closure" {
     lvl8_ru90_closure:
         const lvl8_ru90_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_ru90_entry() //  [R1]
         { info_tbl: [(cus7,
                       label: lvl8_ru90_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cus7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cus8; else goto cus9;
       cus8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cus9: // global
           (_cus4::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cus4::I64 == 0) goto cus6; else goto cus5;
       cus6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cus5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cus4::I64;
           R2 = lvl7_ru8Z_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.344009824 UTC

[section ""data" . GHC.List.foldr1_closure" {
     GHC.List.foldr1_closure:
         const GHC.List.foldr1_info;
         const 0;
 },
 go2_suaM_entry() //  [R1, R2]
         { info_tbl: [(cusq,
                       label: go2_suaM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cusq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cusr; else goto cuss;
       cusr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuss: // global
           I64[Sp - 24] = block_cusj_info;
           _suaM::P64 = R1;
           _suaK::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _suaK::P64;
           P64[Sp - 8] = _suaM::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uusQ; else goto cusk;
       uusQ: // global
           call _cusj(R1) args: 0, res: 0, upd: 0;
       cusk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cusj() //  [R1]
         { info_tbl: [(cusj,
                       label: block_cusj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cusj: // global
           if (R1 & 7 == 1) goto cusn; else goto cuso;
       cusn: // global
           R1 = lvl8_ru90_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cuso: // global
           I64[Sp - 8] = block_cusy_info;
           _suaP::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _suaP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uusP; else goto cusA;
       uusP: // global
           call _cusy(R1) args: 0, res: 0, upd: 0;
       cusA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cusy() //  [R1]
         { info_tbl: [(cusy,
                       label: block_cusy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cusy: // global
           _suaP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cusG; else goto cusK;
       cusG: // global
           R1 = _suaP::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cusK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cusN; else goto cusM;
       cusN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cusM: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = _suaP::P64;
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.foldr1_entry() //  [R2, R3]
         { info_tbl: [(cusR,
                       label: GHC.List.foldr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cusR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cusV; else goto cusU;
       cusV: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cusU: // global
           I64[Hp - 8] = go2_suaM_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_suaM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.345750242 UTC

[section ""cstring" . lvl9_ru91_bytes" {
     lvl9_ru91_bytes:
         I8[] [105,110,105,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.346461339 UTC

[section ""data" . lvl10_ru92_closure" {
     lvl10_ru92_closure:
         const lvl10_ru92_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ru92_entry() //  [R1]
         { info_tbl: [(cut2,
                       label: lvl10_ru92_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cut2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cut3; else goto cut4;
       cut3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cut4: // global
           (_cusZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cusZ::I64 == 0) goto cut1; else goto cut0;
       cut1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cut0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cusZ::I64;
           R2 = lvl9_ru91_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.347444777 UTC

[section ""data" . GHC.List.init2_closure" {
     GHC.List.init2_closure:
         const GHC.List.init2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.init2_entry() //  [R1]
         { info_tbl: [(cutb,
                       label: GHC.List.init2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cutb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cutc; else goto cutd;
       cutc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cutd: // global
           (_cut8::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cut8::I64 == 0) goto cuta; else goto cut9;
       cuta: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cut9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cut8::I64;
           R2 = lvl10_ru92_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.348607795 UTC

[section ""data" . GHC.List.init_closure" {
     GHC.List.init_closure:
         const GHC.List.init_info;
         const 0;
 },
 GHC.List.init_entry() //  [R2]
         { info_tbl: [(cutp,
                       label: GHC.List.init_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cutp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cutq; else goto cutr;
       cutq: // global
           R2 = R2;
           R1 = GHC.List.init_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cutr: // global
           I64[Sp - 8] = block_cuti_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuty; else goto cutj;
       uuty: // global
           call _cuti(R1) args: 0, res: 0, upd: 0;
       cutj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuti() //  [R1]
         { info_tbl: [(cuti,
                       label: block_cuti_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuti: // global
           if (R1 & 7 == 1) goto cutm; else goto cutn;
       cutm: // global
           R1 = GHC.List.init2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cutn: // global
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.List.init1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.349728942 UTC

[section ""cstring" . lvl11_ru93_bytes" {
     lvl11_ru93_bytes:
         I8[] [108,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.350385521 UTC

[section ""data" . lvl12_ru94_closure" {
     lvl12_ru94_closure:
         const lvl12_ru94_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ru94_entry() //  [R1]
         { info_tbl: [(cutF,
                       label: lvl12_ru94_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cutF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cutG; else goto cutH;
       cutG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cutH: // global
           (_cutC::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cutC::I64 == 0) goto cutE; else goto cutD;
       cutE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cutD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cutC::I64;
           R2 = lvl11_ru93_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.351406282 UTC

[section ""data" . GHC.List.lastError_closure" {
     GHC.List.lastError_closure:
         const GHC.List.lastError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.lastError_entry() //  [R1]
         { info_tbl: [(cutO,
                       label: GHC.List.lastError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cutO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cutP; else goto cutQ;
       cutP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cutQ: // global
           (_cutL::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cutL::I64 == 0) goto cutN; else goto cutM;
       cutN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cutM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cutL::I64;
           R2 = lvl12_ru94_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.352655807 UTC

[section ""data" . poly_go_ru95_closure" {
     poly_go_ru95_closure:
         const poly_go_ru95_info;
 },
 poly_go_ru95_entry() //  [R2, R3]
         { info_tbl: [(cuu2,
                       label: poly_go_ru95_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuu2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuu3; else goto uuub;
       cuu3: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_go_ru95_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uuub: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cutS() args: 0, res: 0, upd: 0;
     }
 },
 _cutS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cutS: // global
           _suaZ::P64 = P64[Sp];
           I64[Sp] = block_cutV_info;
           R1 = _suaZ::P64;
           if (R1 & 7 != 0) goto uuud; else goto cutW;
       uuud: // global
           call _cutV(R1) args: 0, res: 0, upd: 0;
       cutW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cutV() //  [R1]
         { info_tbl: [(cutV,
                       label: block_cutV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cutV: // global
           if (R1 & 7 == 1) goto cutZ; else goto cuu0;
       cutZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cuu0: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cutS() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.353943038 UTC

[section ""data" . GHC.List.last_closure" {
     GHC.List.last_closure:
         const GHC.List.last_info;
         const 0;
 },
 GHC.List.last_entry() //  [R2]
         { info_tbl: [(cuuk,
                       label: GHC.List.last_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuuk: // global
           R3 = GHC.List.lastError_closure;
           R2 = R2;
           call poly_go_ru95_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.354673191 UTC

[section ""cstring" . lvl13_ru96_bytes" {
     lvl13_ru96_bytes:
         I8[] [116,97,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.355424114 UTC

[section ""data" . lvl14_ru97_closure" {
     lvl14_ru97_closure:
         const lvl14_ru97_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ru97_entry() //  [R1]
         { info_tbl: [(cuut,
                       label: lvl14_ru97_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuut: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuuu; else goto cuuv;
       cuuu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuuv: // global
           (_cuuq::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuuq::I64 == 0) goto cuus; else goto cuur;
       cuus: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuur: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuuq::I64;
           R2 = lvl13_ru96_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.357085437 UTC

[section ""data" . GHC.List.scanl2_closure" {
     GHC.List.scanl2_closure:
         const GHC.List.scanl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.scanl2_entry() //  [R1]
         { info_tbl: [(cuuC,
                       label: GHC.List.scanl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuuC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuuD; else goto cuuE;
       cuuD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuuE: // global
           (_cuuz::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuuz::I64 == 0) goto cuuB; else goto cuuA;
       cuuB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuuA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuuz::I64;
           R2 = lvl14_ru97_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.358309484 UTC

[section ""data" . GHC.List.tail_closure" {
     GHC.List.tail_closure:
         const GHC.List.tail_info;
         const 0;
 },
 GHC.List.tail_entry() //  [R2]
         { info_tbl: [(cuuQ,
                       label: GHC.List.tail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuuQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cuuR; else goto cuuS;
       cuuR: // global
           R2 = R2;
           R1 = GHC.List.tail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuuS: // global
           I64[Sp - 8] = block_cuuJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuuZ; else goto cuuK;
       uuuZ: // global
           call _cuuJ(R1) args: 0, res: 0, upd: 0;
       cuuK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuuJ() //  [R1]
         { info_tbl: [(cuuJ,
                       label: block_cuuJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuuJ: // global
           if (R1 & 7 == 1) goto cuuN; else goto cuuO;
       cuuN: // global
           R1 = GHC.List.scanl2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cuuO: // global
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.359344561 UTC

[section ""cstring" . lvl15_ru98_bytes" {
     lvl15_ru98_bytes:
         I8[] [104,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.360038521 UTC

[section ""data" . lvl16_ru99_closure" {
     lvl16_ru99_closure:
         const lvl16_ru99_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_ru99_entry() //  [R1]
         { info_tbl: [(cuv6,
                       label: lvl16_ru99_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuv6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuv7; else goto cuv8;
       cuv7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuv8: // global
           (_cuv3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuv3::I64 == 0) goto cuv5; else goto cuv4;
       cuv5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuv4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuv3::I64;
           R2 = lvl15_ru98_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.36104556 UTC

[section ""data" . GHC.List.badHead_closure" {
     GHC.List.badHead_closure:
         const GHC.List.badHead_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.badHead_entry() //  [R1]
         { info_tbl: [(cuvf,
                       label: GHC.List.badHead_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuvf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuvg; else goto cuvh;
       cuvg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuvh: // global
           (_cuvc::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuvc::I64 == 0) goto cuve; else goto cuvd;
       cuve: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuvd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuvc::I64;
           R2 = lvl16_ru99_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.362534951 UTC

[section ""data" . GHC.List.head_closure" {
     GHC.List.head_closure:
         const GHC.List.head_info;
         const 0;
 },
 GHC.List.head_entry() //  [R2]
         { info_tbl: [(cuvt,
                       label: GHC.List.head_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuvt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cuvu; else goto cuvv;
       cuvu: // global
           R2 = R2;
           R1 = GHC.List.head_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuvv: // global
           I64[Sp - 8] = block_cuvm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuvC; else goto cuvn;
       uuvC: // global
           call _cuvm(R1) args: 0, res: 0, upd: 0;
       cuvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuvm() //  [R1]
         { info_tbl: [(cuvm,
                       label: block_cuvm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuvm: // global
           if (R1 & 7 == 1) goto cuvq; else goto cuvr;
       cuvq: // global
           R1 = GHC.List.badHead_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cuvr: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.363548803 UTC

[section ""cstring" . lvl17_ru9a_bytes" {
     lvl17_ru9a_bytes:
         I8[] [109,97,120,105,109,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.364214627 UTC

[section ""data" . lvl18_ru9b_closure" {
     lvl18_ru9b_closure:
         const lvl18_ru9b_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_ru9b_entry() //  [R1]
         { info_tbl: [(cuvJ,
                       label: lvl18_ru9b_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuvJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuvK; else goto cuvL;
       cuvK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuvL: // global
           (_cuvG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuvG::I64 == 0) goto cuvI; else goto cuvH;
       cuvI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuvH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuvG::I64;
           R2 = lvl17_ru9a_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.365224082 UTC

[section ""data" . GHC.List.maximum1_closure" {
     GHC.List.maximum1_closure:
         const GHC.List.maximum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum1_entry() //  [R1]
         { info_tbl: [(cuvS,
                       label: GHC.List.maximum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuvS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuvT; else goto cuvU;
       cuvT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuvU: // global
           (_cuvP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuvP::I64 == 0) goto cuvR; else goto cuvQ;
       cuvR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuvQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuvP::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.366281744 UTC

[section ""data" . GHC.List.maximum2_closure" {
     GHC.List.maximum2_closure:
         const GHC.List.maximum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum2_entry() //  [R1]
         { info_tbl: [(cuw1,
                       label: GHC.List.maximum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuw1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuw2; else goto cuw3;
       cuw2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuw3: // global
           (_cuvY::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuvY::I64 == 0) goto cuw0; else goto cuvZ;
       cuw0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuvZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuvY::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.367279699 UTC

[section ""data" . lvl19_ru9c_closure" {
     lvl19_ru9c_closure:
         const lvl19_ru9c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_ru9c_entry() //  [R1]
         { info_tbl: [(cuwa,
                       label: lvl19_ru9c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuwa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuwb; else goto cuwc;
       cuwb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuwc: // global
           (_cuw7::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuw7::I64 == 0) goto cuw9; else goto cuw8;
       cuw9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuw8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuw7::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.368690371 UTC

[section ""data" . GHC.List.maximum_go_closure" {
     GHC.List.maximum_go_closure:
         const GHC.List.maximum_go_info;
 },
 GHC.List.maximum_go_entry() //  [R2, R3]
         { info_tbl: [(cuwo,
                       label: GHC.List.maximum_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuwo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cuwp; else goto uuwI;
       cuwp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uuwI: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cuwe() args: 0, res: 0, upd: 0;
     }
 },
 _cuwe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuwe: // global
           _subd::P64 = P64[Sp];
           I64[Sp] = block_cuwh_info;
           R1 = _subd::P64;
           if (R1 & 7 != 0) goto uuwL; else goto cuwi;
       uuwL: // global
           call _cuwh(R1) args: 0, res: 0, upd: 0;
       cuwi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuwh() //  [R1]
         { info_tbl: [(cuwh,
                       label: block_cuwh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuwh: // global
           _sube::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cuwl; else goto cuwm;
       cuwl: // global
           R1 = _sube::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cuwm: // global
           I64[Sp - 16] = block_cuww_info;
           _subg::P64 = P64[R1 + 6];
           R3 = _subg::P64;
           R2 = _sube::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _subg::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cuww() //  [R1]
         { info_tbl: [(cuww,
                       label: block_cuww_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuww: // global
           _subh::P64 = P64[Sp + 8];
           if (R1 == 1) goto cuwH; else goto cuwD;
       cuwH: // global
           _sube::P64 = P64[Sp + 16];
           P64[Sp + 16] = _subh::P64;
           P64[Sp + 24] = _sube::P64;
           Sp = Sp + 16;
           goto uuwO;
       cuwD: // global
           P64[Sp + 16] = _subh::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uuwO;
       uuwO: // global
           call _cuwe() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.37040199 UTC

[section ""data" . GHC.List.maximum_$smaximum_closure" {
     GHC.List.maximum_$smaximum_closure:
         const GHC.List.maximum_$smaximum_info;
         const 0;
 },
 GHC.List.maximum_$smaximum_entry() //  [R2]
         { info_tbl: [(cux0,
                       label: GHC.List.maximum_$smaximum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cux0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cux1; else goto cux2;
       cux1: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cux2: // global
           I64[Sp - 8] = block_cuwT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uux9; else goto cuwU;
       uux9: // global
           call _cuwT(R1) args: 0, res: 0, upd: 0;
       cuwU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuwT() //  [R1]
         { info_tbl: [(cuwT,
                       label: block_cuwT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuwT: // global
           if (R1 & 7 == 1) goto cuwX; else goto cuwY;
       cuwX: // global
           R1 = GHC.List.maximum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cuwY: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.maximum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.371487627 UTC

[section ""cstring" . lvl20_ru9d_bytes" {
     lvl20_ru9d_bytes:
         I8[] [109,105,110,105,109,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.372821117 UTC

[section ""data" . lvl21_ru9e_closure" {
     lvl21_ru9e_closure:
         const lvl21_ru9e_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_ru9e_entry() //  [R1]
         { info_tbl: [(cuxg,
                       label: lvl21_ru9e_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuxg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuxh; else goto cuxi;
       cuxh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuxi: // global
           (_cuxd::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuxd::I64 == 0) goto cuxf; else goto cuxe;
       cuxf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuxe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuxd::I64;
           R2 = lvl20_ru9d_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.374191902 UTC

[section ""data" . GHC.List.minimum1_closure" {
     GHC.List.minimum1_closure:
         const GHC.List.minimum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum1_entry() //  [R1]
         { info_tbl: [(cuxp,
                       label: GHC.List.minimum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuxp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuxq; else goto cuxr;
       cuxq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuxr: // global
           (_cuxm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuxm::I64 == 0) goto cuxo; else goto cuxn;
       cuxo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuxn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuxm::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.375192449 UTC

[section ""data" . GHC.List.minimum2_closure" {
     GHC.List.minimum2_closure:
         const GHC.List.minimum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum2_entry() //  [R1]
         { info_tbl: [(cuxy,
                       label: GHC.List.minimum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuxy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuxz; else goto cuxA;
       cuxz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuxA: // global
           (_cuxv::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuxv::I64 == 0) goto cuxx; else goto cuxw;
       cuxx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuxw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuxv::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.376225137 UTC

[section ""data" . lvl22_ru9f_closure" {
     lvl22_ru9f_closure:
         const lvl22_ru9f_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ru9f_entry() //  [R1]
         { info_tbl: [(cuxH,
                       label: lvl22_ru9f_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuxH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuxI; else goto cuxJ;
       cuxI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuxJ: // global
           (_cuxE::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuxE::I64 == 0) goto cuxG; else goto cuxF;
       cuxG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuxF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuxE::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.377774112 UTC

[section ""data" . GHC.List.minimum_go_closure" {
     GHC.List.minimum_go_closure:
         const GHC.List.minimum_go_info;
 },
 GHC.List.minimum_go_entry() //  [R2, R3]
         { info_tbl: [(cuxV,
                       label: GHC.List.minimum_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuxV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cuxW; else goto uuyf;
       cuxW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uuyf: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cuxL() args: 0, res: 0, upd: 0;
     }
 },
 _cuxL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuxL: // global
           _subn::P64 = P64[Sp];
           I64[Sp] = block_cuxO_info;
           R1 = _subn::P64;
           if (R1 & 7 != 0) goto uuyi; else goto cuxP;
       uuyi: // global
           call _cuxO(R1) args: 0, res: 0, upd: 0;
       cuxP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuxO() //  [R1]
         { info_tbl: [(cuxO,
                       label: block_cuxO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuxO: // global
           _subo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cuxS; else goto cuxT;
       cuxS: // global
           R1 = _subo::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cuxT: // global
           I64[Sp - 16] = block_cuy3_info;
           _subq::P64 = P64[R1 + 6];
           R3 = _subq::P64;
           R2 = _subo::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _subq::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cuy3() //  [R1]
         { info_tbl: [(cuy3,
                       label: block_cuy3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuy3: // global
           _subr::P64 = P64[Sp + 8];
           if (R1 == 1) goto cuye; else goto cuya;
       cuye: // global
           P64[Sp + 16] = _subr::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uuyl;
       cuya: // global
           _subo::P64 = P64[Sp + 16];
           P64[Sp + 16] = _subr::P64;
           P64[Sp + 24] = _subo::P64;
           Sp = Sp + 16;
           goto uuyl;
       uuyl: // global
           call _cuxL() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.380436861 UTC

[section ""data" . GHC.List.minimum_$sminimum_closure" {
     GHC.List.minimum_$sminimum_closure:
         const GHC.List.minimum_$sminimum_info;
         const 0;
 },
 GHC.List.minimum_$sminimum_entry() //  [R2]
         { info_tbl: [(cuyx,
                       label: GHC.List.minimum_$sminimum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuyx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cuyy; else goto cuyz;
       cuyy: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuyz: // global
           I64[Sp - 8] = block_cuyq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuyG; else goto cuyr;
       uuyG: // global
           call _cuyq(R1) args: 0, res: 0, upd: 0;
       cuyr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuyq() //  [R1]
         { info_tbl: [(cuyq,
                       label: block_cuyq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuyq: // global
           if (R1 & 7 == 1) goto cuyu; else goto cuyv;
       cuyu: // global
           R1 = GHC.List.minimum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cuyv: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.minimum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.382784929 UTC

[section ""data" . GHC.List.$wgo_closure" {
     GHC.List.$wgo_closure:
         const GHC.List.$wgo_info;
 },
 GHC.List.$wgo_entry() //  [R2, R3]
         { info_tbl: [(cuyS,
                       label: GHC.List.$wgo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuyS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuyT; else goto uuzc;
       cuyT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uuzc: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cuyI() args: 0, res: 0, upd: 0;
     }
 },
 _cuyI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuyI: // global
           _subx::P64 = P64[Sp];
           I64[Sp] = block_cuyL_info;
           R1 = _subx::P64;
           if (R1 & 7 != 0) goto uuzf; else goto cuyM;
       uuzf: // global
           call _cuyL(R1) args: 0, res: 0, upd: 0;
       cuyM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuyL() //  [R1]
         { info_tbl: [(cuyL,
                       label: block_cuyL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuyL: // global
           if (R1 & 7 == 1) goto cuyP; else goto cuyQ;
       cuyP: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuyQ: // global
           I64[Sp - 8] = block_cuz0_info;
           _subB::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _subB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuzg; else goto cuz2;
       uuzg: // global
           call _cuz0(R1) args: 0, res: 0, upd: 0;
       cuz2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuz0() //  [R1]
         { info_tbl: [(cuz0,
                       label: block_cuz0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuz0: // global
           _suby::I64 = I64[Sp + 16];
           _subB::P64 = P64[Sp + 8];
           _subD::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_suby::I64,
                            _subD::I64)) goto cuza; else goto cuzb;
       cuza: // global
           P64[Sp + 8] = _subB::P64;
           I64[Sp + 16] = _suby::I64;
           Sp = Sp + 8;
           goto uuzj;
       cuzb: // global
           P64[Sp + 8] = _subB::P64;
           I64[Sp + 16] = _subD::I64;
           Sp = Sp + 8;
           goto uuzj;
       uuzj: // global
           call _cuyI() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.384877357 UTC

[section ""data" . GHC.List.maximum_$smaximum1_closure" {
     GHC.List.maximum_$smaximum1_closure:
         const GHC.List.maximum_$smaximum1_info;
         const 0;
 },
 GHC.List.maximum_$smaximum1_entry() //  [R2]
         { info_tbl: [(cuzv,
                       label: GHC.List.maximum_$smaximum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuzv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuzw; else goto cuzx;
       cuzw: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuzx: // global
           I64[Sp - 8] = block_cuzo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuzT; else goto cuzp;
       uuzT: // global
           call _cuzo(R1) args: 0, res: 0, upd: 0;
       cuzp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuzo() //  [R1]
         { info_tbl: [(cuzo,
                       label: block_cuzo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuzo: // global
           if (R1 & 7 == 1) goto cuzs; else goto cuzt;
       cuzs: // global
           R1 = GHC.List.maximum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cuzt: // global
           I64[Sp - 8] = block_cuzD_info;
           _subI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _subI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuzS; else goto cuzE;
       uuzS: // global
           call _cuzD(R1) args: 0, res: 0, upd: 0;
       cuzE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuzD() //  [R1]
         { info_tbl: [(cuzD,
                       label: block_cuzD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuzD: // global
           _subI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cuzI_info;
           R3 = I64[R1 + 7];
           R2 = _subI::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cuzI() //  [R1]
         { info_tbl: [(cuzI,
                       label: block_cuzI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuzI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cuzR; else goto cuzQ;
       cuzR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cuzQ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.387135903 UTC

[section ""data" . GHC.List.maximum_closure" {
     GHC.List.maximum_closure:
         const GHC.List.maximum_info;
         const 0;
 },
 sat_subX_entry() //  [R1]
         { info_tbl: [(cuAj,
                       label: sat_subX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuAj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cuAk; else goto cuAl;
       cuAk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuAl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.max_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.List.maximum_entry() //  [R2, R3]
         { info_tbl: [(cuAq,
                       label: GHC.List.maximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuAq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cuAr; else goto cuAs;
       cuAr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuAs: // global
           I64[Sp - 16] = block_cuzY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuAL; else goto cuzZ;
       uuAL: // global
           call _cuzY(R1) args: 0, res: 0, upd: 0;
       cuzZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuzY() //  [R1]
         { info_tbl: [(cuzY,
                       label: block_cuzY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuzY: // global
           if (R1 & 7 == 1) goto cuAn; else goto cuAo;
       cuAn: // global
           R1 = lvl19_ru9c_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cuAo: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cuA7() args: 0, res: 0, upd: 0;
     }
 },
 _cuA7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuA7: // global
           I64[Sp - 8] = block_cuA9_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuAJ; else goto cuAa;
       uuAJ: // global
           call _cuA9(R1) args: 0, res: 0, upd: 0;
       cuAa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuA9() //  [R1]
         { info_tbl: [(cuA9,
                       label: block_cuA9_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuA9: // global
           _subT::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cuAA; else goto cuAB;
       cuAA: // global
           R1 = _subT::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cuAB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cuAE; else goto cuAD;
       cuAE: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuAD: // global
           _subV::P64 = P64[R1 + 6];
           _subW::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_subX_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _subT::P64;
           P64[Hp] = _subV::P64;
           P64[Sp + 16] = _subW::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cuA7() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.389527948 UTC

[section ""data" . GHC.List.$wgo1_closure" {
     GHC.List.$wgo1_closure:
         const GHC.List.$wgo1_info;
 },
 GHC.List.$wgo1_entry() //  [R2, R3]
         { info_tbl: [(cuAX,
                       label: GHC.List.$wgo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuAX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuAY; else goto uuBh;
       cuAY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uuBh: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cuAN() args: 0, res: 0, upd: 0;
     }
 },
 _cuAN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuAN: // global
           _subY::P64 = P64[Sp];
           I64[Sp] = block_cuAQ_info;
           R1 = _subY::P64;
           if (R1 & 7 != 0) goto uuBk; else goto cuAR;
       uuBk: // global
           call _cuAQ(R1) args: 0, res: 0, upd: 0;
       cuAR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuAQ() //  [R1]
         { info_tbl: [(cuAQ,
                       label: block_cuAQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuAQ: // global
           if (R1 & 7 == 1) goto cuAU; else goto cuAV;
       cuAU: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuAV: // global
           I64[Sp - 8] = block_cuB5_info;
           _suc2::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _suc2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuBl; else goto cuB7;
       uuBl: // global
           call _cuB5(R1) args: 0, res: 0, upd: 0;
       cuB7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuB5() //  [R1]
         { info_tbl: [(cuB5,
                       label: block_cuB5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuB5: // global
           _subZ::I64 = I64[Sp + 16];
           _suc2::P64 = P64[Sp + 8];
           _suc4::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_subZ::I64,
                            _suc4::I64)) goto cuBf; else goto cuBg;
       cuBf: // global
           P64[Sp + 8] = _suc2::P64;
           I64[Sp + 16] = _suc4::I64;
           Sp = Sp + 8;
           goto uuBo;
       cuBg: // global
           P64[Sp + 8] = _suc2::P64;
           I64[Sp + 16] = _subZ::I64;
           Sp = Sp + 8;
           goto uuBo;
       uuBo: // global
           call _cuAN() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.392270953 UTC

[section ""data" . GHC.List.minimum_$sminimum1_closure" {
     GHC.List.minimum_$sminimum1_closure:
         const GHC.List.minimum_$sminimum1_info;
         const 0;
 },
 GHC.List.minimum_$sminimum1_entry() //  [R2]
         { info_tbl: [(cuBA,
                       label: GHC.List.minimum_$sminimum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuBA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuBB; else goto cuBC;
       cuBB: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuBC: // global
           I64[Sp - 8] = block_cuBt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuBY; else goto cuBu;
       uuBY: // global
           call _cuBt(R1) args: 0, res: 0, upd: 0;
       cuBu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuBt() //  [R1]
         { info_tbl: [(cuBt,
                       label: block_cuBt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuBt: // global
           if (R1 & 7 == 1) goto cuBx; else goto cuBy;
       cuBx: // global
           R1 = GHC.List.minimum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cuBy: // global
           I64[Sp - 8] = block_cuBI_info;
           _suc9::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _suc9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuBX; else goto cuBJ;
       uuBX: // global
           call _cuBI(R1) args: 0, res: 0, upd: 0;
       cuBJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuBI() //  [R1]
         { info_tbl: [(cuBI,
                       label: block_cuBI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuBI: // global
           _suc9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cuBN_info;
           R3 = I64[R1 + 7];
           R2 = _suc9::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cuBN() //  [R1]
         { info_tbl: [(cuBN,
                       label: block_cuBN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuBN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cuBW; else goto cuBV;
       cuBW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cuBV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.395021378 UTC

[section ""data" . GHC.List.minimum_closure" {
     GHC.List.minimum_closure:
         const GHC.List.minimum_info;
         const 0;
 },
 sat_suco_entry() //  [R1]
         { info_tbl: [(cuCo,
                       label: sat_suco_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuCo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cuCp; else goto cuCq;
       cuCp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuCq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.min_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.List.minimum_entry() //  [R2, R3]
         { info_tbl: [(cuCv,
                       label: GHC.List.minimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuCv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cuCw; else goto cuCx;
       cuCw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuCx: // global
           I64[Sp - 16] = block_cuC3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuCQ; else goto cuC4;
       uuCQ: // global
           call _cuC3(R1) args: 0, res: 0, upd: 0;
       cuC4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuC3() //  [R1]
         { info_tbl: [(cuC3,
                       label: block_cuC3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuC3: // global
           if (R1 & 7 == 1) goto cuCs; else goto cuCt;
       cuCs: // global
           R1 = lvl22_ru9f_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cuCt: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cuCc() args: 0, res: 0, upd: 0;
     }
 },
 _cuCc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuCc: // global
           I64[Sp - 8] = block_cuCe_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuCO; else goto cuCf;
       uuCO: // global
           call _cuCe(R1) args: 0, res: 0, upd: 0;
       cuCf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuCe() //  [R1]
         { info_tbl: [(cuCe,
                       label: block_cuCe_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuCe: // global
           _suck::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cuCF; else goto cuCG;
       cuCF: // global
           R1 = _suck::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cuCG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cuCJ; else goto cuCI;
       cuCJ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuCI: // global
           _sucm::P64 = P64[R1 + 6];
           _sucn::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_suco_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _suck::P64;
           P64[Hp] = _sucm::P64;
           P64[Sp + 16] = _sucn::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cuCc() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.396849359 UTC

[section ""cstring" . lvl23_ru9g_bytes" {
     lvl23_ru9g_bytes:
         I8[] [102,111,108,100,108,49,39]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.397626502 UTC

[section ""data" . lvl24_ru9h_closure" {
     lvl24_ru9h_closure:
         const lvl24_ru9h_info;
         const 0;
         const 0;
         const 0;
 },
 lvl24_ru9h_entry() //  [R1]
         { info_tbl: [(cuCX,
                       label: lvl24_ru9h_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuCX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuCY; else goto cuCZ;
       cuCY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuCZ: // global
           (_cuCU::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuCU::I64 == 0) goto cuCW; else goto cuCV;
       cuCW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuCV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuCU::I64;
           R2 = lvl23_ru9g_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.398640164 UTC

[section ""data" . GHC.List.foldl1'1_closure" {
     GHC.List.foldl1'1_closure:
         const GHC.List.foldl1'1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl1'1_entry() //  [R1]
         { info_tbl: [(cuD6,
                       label: GHC.List.foldl1'1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuD6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuD7; else goto cuD8;
       cuD7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuD8: // global
           (_cuD3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuD3::I64 == 0) goto cuD5; else goto cuD4;
       cuD5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuD4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuD3::I64;
           R2 = lvl24_ru9h_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.399516238 UTC

[section ""cstring" . lvl25_ru9i_bytes" {
     lvl25_ru9i_bytes:
         I8[] [102,111,108,100,108,49]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.400245025 UTC

[section ""data" . lvl26_ru9j_closure" {
     lvl26_ru9j_closure:
         const lvl26_ru9j_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_ru9j_entry() //  [R1]
         { info_tbl: [(cuDf,
                       label: lvl26_ru9j_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuDf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuDg; else goto cuDh;
       cuDg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuDh: // global
           (_cuDc::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuDc::I64 == 0) goto cuDe; else goto cuDd;
       cuDe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuDd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuDc::I64;
           R2 = lvl25_ru9i_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.401233109 UTC

[section ""data" . GHC.List.foldl2_closure" {
     GHC.List.foldl2_closure:
         const GHC.List.foldl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl2_entry() //  [R1]
         { info_tbl: [(cuDo,
                       label: GHC.List.foldl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuDo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuDp; else goto cuDq;
       cuDp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuDq: // global
           (_cuDl::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cuDl::I64 == 0) goto cuDn; else goto cuDm;
       cuDn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cuDm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cuDl::I64;
           R2 = lvl26_ru9j_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.403024747 UTC

[section ""data" . $wgo2_ru9k_closure" {
     $wgo2_ru9k_closure:
         const $wgo2_ru9k_info;
 },
 ds_sucx_entry() //  [R1]
         { info_tbl: [(cuDN,
                       label: ds_sucx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuDN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuDO; else goto cuDP;
       cuDO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuDP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cuDK_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cuDK() //  [R1, R2, R3]
         { info_tbl: [(cuDK,
                       label: block_cuDK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuDK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cuDS; else goto cuDR;
       cuDS: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 24;
       cuDR: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo2_ru9k_entry() //  [R2]
         { info_tbl: [(cuDX,
                       label: $wgo2_ru9k_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuDX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuDY; else goto cuDZ;
       cuDY: // global
           R2 = R2;
           R1 = $wgo2_ru9k_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuDZ: // global
           I64[Sp - 8] = block_cuDv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuEd; else goto cuDw;
       uuEd: // global
           call _cuDv(R1) args: 0, res: 0, upd: 0;
       cuDw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuDv() //  [R1]
         { info_tbl: [(cuDv,
                       label: block_cuDv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuDv: // global
           if (R1 & 7 == 1) goto cuDU; else goto cuDV;
       cuDU: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuDV: // global
           I64[Sp - 8] = block_cuDB_info;
           _sucs::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sucs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuEc; else goto cuDC;
       uuEc: // global
           call _cuDB(R1) args: 0, res: 0, upd: 0;
       cuDC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuDB() //  [R1]
         { info_tbl: [(cuDB,
                       label: block_cuDB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuDB: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cuEb; else goto cuEa;
       cuEb: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuEa: // global
           _sucu::P64 = P64[R1 + 7];
           _sucv::P64 = P64[R1 + 15];
           _sucw::P64 = P64[R1 + 23];
           I64[Hp - 160] = ds_sucx_info;
           P64[Hp - 144] = P64[Sp + 8];
           I64[Hp - 136] = stg_sel_2_upd_info;
           _cuDG::P64 = Hp - 160;
           P64[Hp - 120] = _cuDG::P64;
           I64[Hp - 112] = :_con_info;
           P64[Hp - 104] = _sucw::P64;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _cuDG::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sucv::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cuDG::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sucu::P64;
           P64[Hp] = Hp - 40;
           R3 = Hp - 110;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.405360683 UTC

[section ""data" . go_ru9l_closure" {
     go_ru9l_closure:
         const go_ru9l_info;
 },
 go_ru9l_entry() //  [R2]
         { info_tbl: [(cuEl,
                       label: go_ru9l_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuEl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cuEm; else goto cuEn;
       cuEm: // global
           R2 = R2;
           R1 = go_ru9l_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuEn: // global
           I64[Sp - 8] = block_cuEi_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cuEi() //  [R1, R2, R3]
         { info_tbl: [(cuEi,
                       label: block_cuEi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuEi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cuEq; else goto cuEp;
       cuEq: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cuEp: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.406522444 UTC

[section ""data" . GHC.List.unzip3_closure" {
     GHC.List.unzip3_closure:
         const GHC.List.unzip3_info;
 },
 GHC.List.unzip3_entry() //  [R2]
         { info_tbl: [(cuEv,
                       label: GHC.List.unzip3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuEv: // global
           R2 = R2;
           call go_ru9l_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.409659356 UTC

[section ""data" . $wgo3_ru9m_closure" {
     $wgo3_ru9m_closure:
         const $wgo3_ru9m_info;
 },
 ds_sud6_entry() //  [R1]
         { info_tbl: [(cuEU,
                       label: ds_sud6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuEU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuEV; else goto cuEW;
       cuEV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuEW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cuER_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cuER() //  [R1, R2]
         { info_tbl: [(cuER,
                       label: block_cuER_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuER: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuEZ; else goto cuEY;
       cuEZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cuEY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo3_ru9m_entry() //  [R2]
         { info_tbl: [(cuF4,
                       label: $wgo3_ru9m_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuF4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuF5; else goto cuF6;
       cuF5: // global
           R2 = R2;
           R1 = $wgo3_ru9m_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuF6: // global
           I64[Sp - 8] = block_cuEC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuFi; else goto cuED;
       uuFi: // global
           call _cuEC(R1) args: 0, res: 0, upd: 0;
       cuED: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuEC() //  [R1]
         { info_tbl: [(cuEC,
                       label: block_cuEC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuEC: // global
           if (R1 & 7 == 1) goto cuF1; else goto cuF2;
       cuF1: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cuF2: // global
           I64[Sp - 8] = block_cuEI_info;
           _sud2::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sud2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuFh; else goto cuEJ;
       uuFh: // global
           call _cuEI(R1) args: 0, res: 0, upd: 0;
       cuEJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuEI() //  [R1]
         { info_tbl: [(cuEI,
                       label: block_cuEI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuEI: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cuFg; else goto cuFf;
       cuFg: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuFf: // global
           _sud4::P64 = P64[R1 + 7];
           _sud5::P64 = P64[R1 + 15];
           I64[Hp - 112] = ds_sud6_info;
           P64[Hp - 96] = P64[Sp + 8];
           I64[Hp - 88] = stg_sel_1_upd_info;
           _cuEN::P64 = Hp - 112;
           P64[Hp - 72] = _cuEN::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sud5::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cuEN::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sud4::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.413151454 UTC

[section ""data" . go1_ru9n_closure" {
     go1_ru9n_closure:
         const go1_ru9n_info;
 },
 go1_ru9n_entry() //  [R2]
         { info_tbl: [(cuFq,
                       label: go1_ru9n_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuFq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cuFr; else goto cuFs;
       cuFr: // global
           R2 = R2;
           R1 = go1_ru9n_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuFs: // global
           I64[Sp - 8] = block_cuFn_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cuFn() //  [R1, R2]
         { info_tbl: [(cuFn,
                       label: block_cuFn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuFn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuFv; else goto cuFu;
       cuFv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cuFu: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.414923184 UTC

[section ""data" . GHC.List.unzip_closure" {
     GHC.List.unzip_closure:
         const GHC.List.unzip_info;
 },
 GHC.List.unzip_entry() //  [R2]
         { info_tbl: [(cuFA,
                       label: GHC.List.unzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuFA: // global
           R2 = R2;
           call go1_ru9n_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.417452917 UTC

[section ""data" . GHC.List.zipWith3_closure" {
     GHC.List.zipWith3_closure:
         const GHC.List.zipWith3_info;
 },
 go2_suds_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cuFT,
                       label: go2_suds_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuFT: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cuFU; else goto cuFV;
       cuFU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuFV: // global
           I64[Sp - 40] = block_cuFM_info;
           _suds::P64 = R1;
           _sudo::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 32] = _sudo::P64;
           P64[Sp - 24] = _suds::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uuGC; else goto cuFN;
       uuGC: // global
           call _cuFM(R1) args: 0, res: 0, upd: 0;
       cuFN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuFM() //  [R1]
         { info_tbl: [(cuFM,
                       label: block_cuFM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuFM: // global
           if (R1 & 7 == 1) goto uuGx; else goto cuFR;
       uuGx: // global
           Sp = Sp + 40;
           call _cuGl() args: 0, res: 0, upd: 0;
       cuFR: // global
           I64[Sp - 8] = block_cuG1_info;
           _sudx::P64 = P64[R1 + 6];
           _sudy::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sudy::P64;
           P64[Sp + 24] = _sudx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuGA; else goto cuG3;
       uuGA: // global
           call _cuG1(R1) args: 0, res: 0, upd: 0;
       cuG3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuG1() //  [R1]
         { info_tbl: [(cuG1,
                       label: block_cuG1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuG1: // global
           if (R1 & 7 == 1) goto uuGy; else goto cuGe;
       uuGy: // global
           Sp = Sp + 48;
           call _cuGl() args: 0, res: 0, upd: 0;
       cuGe: // global
           I64[Sp - 8] = block_cuGc_info;
           _sudA::P64 = P64[R1 + 6];
           _sudB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sudB::P64;
           P64[Sp + 40] = _sudA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuGD; else goto cuGf;
       uuGD: // global
           call _cuGc(R1) args: 0, res: 0, upd: 0;
       cuGf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuGc() //  [R1]
         { info_tbl: [(cuGc,
                       label: block_cuGc_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuGc: // global
           if (R1 & 7 == 1) goto uuGz; else goto cuGr;
       uuGz: // global
           Sp = Sp + 56;
           call _cuGl() args: 0, res: 0, upd: 0;
       cuGr: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cuGu; else goto cuGt;
       cuGu: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuGt: // global
           _sudD::P64 = P64[R1 + 6];
           _sudE::P64 = P64[R1 + 14];
           I64[Hp - 112] = stg_ap_4_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 16];
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sudE::P64;
           I64[Hp - 64] = stg_ap_4_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = _sudD::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cuGl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuGl: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cuGG,
                       label: GHC.List.zipWith3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuGG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cuGK; else goto cuGJ;
       cuGK: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuGJ: // global
           I64[Hp - 8] = go2_suds_info;
           P64[Hp] = R2;
           _sudq::P64 = R4;
           R4 = R5;
           _sudp::P64 = R3;
           R3 = _sudq::P64;
           R2 = _sudp::P64;
           R1 = Hp - 5;
           call go2_suds_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.420011079 UTC

[section ""data" . GHC.List.zipWithFB_closure" {
     GHC.List.zipWithFB_closure:
         const GHC.List.zipWithFB_info;
 },
 GHC.List.zipWithFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cuGQ,
                       label: GHC.List.zipWithFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuGQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cuGU; else goto cuGT;
       cuGU: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWithFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuGT: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R3 = R6;
           _sudH::P64 = R2;
           R2 = Hp - 32;
           R1 = _sudH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.421838769 UTC

[section ""data" . GHC.List.zip3_closure" {
     GHC.List.zip3_closure:
         const GHC.List.zip3_info;
 },
 sat_sue0_entry() //  [R1]
         { info_tbl: [(cuHl,
                       label: sat_sue0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuHl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuHm; else goto cuHn;
       cuHm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuHn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.zip3_entry() //  [R2, R3, R4]
         { info_tbl: [(cuHs,
                       label: GHC.List.zip3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuHs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cuHt; else goto cuHu;
       cuHt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuHu: // global
           I64[Sp - 24] = block_cuGZ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uuHY; else goto cuH0;
       uuHY: // global
           call _cuGZ(R1) args: 0, res: 0, upd: 0;
       cuH0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuGZ() //  [R1]
         { info_tbl: [(cuGZ,
                       label: block_cuGZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuGZ: // global
           if (R1 & 7 == 1) goto uuHQ; else goto cuHq;
       uuHQ: // global
           Sp = Sp + 24;
           call _cuHH() args: 0, res: 0, upd: 0;
       cuHq: // global
           I64[Sp - 8] = block_cuH5_info;
           _sudR::P64 = P64[R1 + 6];
           _sudS::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sudS::P64;
           P64[Sp + 8] = _sudR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuHT; else goto cuH6;
       uuHT: // global
           call _cuH5(R1) args: 0, res: 0, upd: 0;
       cuH6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuH5() //  [R1]
         { info_tbl: [(cuH5,
                       label: block_cuH5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuH5: // global
           if (R1 & 7 == 1) goto uuHR; else goto cuHD;
       uuHR: // global
           Sp = Sp + 32;
           call _cuHH() args: 0, res: 0, upd: 0;
       cuHD: // global
           I64[Sp - 8] = block_cuHb_info;
           _sudU::P64 = P64[R1 + 6];
           _sudV::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sudV::P64;
           P64[Sp + 24] = _sudU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuHV; else goto cuHc;
       uuHV: // global
           call _cuHb(R1) args: 0, res: 0, upd: 0;
       cuHc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuHb() //  [R1]
         { info_tbl: [(cuHb,
                       label: block_cuHb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuHb: // global
           if (R1 & 7 == 1) goto uuHS; else goto cuHK;
       uuHS: // global
           Sp = Sp + 40;
           call _cuHH() args: 0, res: 0, upd: 0;
       cuHK: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cuHN; else goto cuHM;
       cuHN: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuHM: // global
           _sudX::P64 = P64[R1 + 6];
           _sudY::P64 = P64[R1 + 14];
           I64[Hp - 88] = sat_sue0_info;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sudY::P64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sudX::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 47;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cuHH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuHH: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.424174318 UTC

[section ""data" . GHC.List.zipFB_closure" {
     GHC.List.zipFB_closure:
         const GHC.List.zipFB_info;
 },
 GHC.List.zipFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cuI4,
                       label: GHC.List.zipFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuI4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuI8; else goto cuI7;
       cuI8: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuI7: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _sue1::P64 = R2;
           R2 = Hp - 15;
           R1 = _sue1::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.42552568 UTC

[section ""data" . GHC.List.foldr2_left_closure" {
     GHC.List.foldr2_left_closure:
         const GHC.List.foldr2_left_info;
 },
 GHC.List.foldr2_left_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cuIk,
                       label: GHC.List.foldr2_left_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuIk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cuIl; else goto cuIm;
       cuIl: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_left_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuIm: // global
           I64[Sp - 40] = block_cuId_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uuIw; else goto cuIe;
       uuIw: // global
           call _cuId(R1) args: 0, res: 0, upd: 0;
       cuIe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuId() //  [R1]
         { info_tbl: [(cuId,
                       label: block_cuId_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuId: // global
           if (R1 & 7 == 1) goto cuIh; else goto cuIi;
       cuIh: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cuIi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cuIv; else goto cuIu;
       cuIv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuIu: // global
           _suec::P64 = P64[R1 + 6];
           _sued::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sued::P64;
           R4 = Hp - 24;
           R3 = _suec::P64;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.430012048 UTC

[section ""data" . GHC.List.zip_closure" {
     GHC.List.zip_closure:
         const GHC.List.zip_info;
 },
 sat_sueo_entry() //  [R1]
         { info_tbl: [(cuIR,
                       label: sat_sueo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuIR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuIS; else goto cuIT;
       cuIS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuIT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.zip_entry() //  [R2, R3]
         { info_tbl: [(cuIY,
                       label: GHC.List.zip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuIY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuIZ; else goto cuJ0;
       cuIZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuJ0: // global
           I64[Sp - 16] = block_cuIB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuJk; else goto cuIC;
       uuJk: // global
           call _cuIB(R1) args: 0, res: 0, upd: 0;
       cuIC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuIB() //  [R1]
         { info_tbl: [(cuIB,
                       label: block_cuIB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuIB: // global
           if (R1 & 7 == 1) goto uuJf; else goto cuIW;
       uuJf: // global
           Sp = Sp + 16;
           call _cuJ7() args: 0, res: 0, upd: 0;
       cuIW: // global
           I64[Sp - 8] = block_cuIH_info;
           _suei::P64 = P64[R1 + 6];
           _suej::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _suej::P64;
           P64[Sp + 8] = _suei::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuJh; else goto cuII;
       uuJh: // global
           call _cuIH(R1) args: 0, res: 0, upd: 0;
       cuII: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuIH() //  [R1]
         { info_tbl: [(cuIH,
                       label: block_cuIH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuIH: // global
           if (R1 & 7 == 1) goto uuJg; else goto cuJa;
       uuJg: // global
           Sp = Sp + 24;
           call _cuJ7() args: 0, res: 0, upd: 0;
       cuJa: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cuJd; else goto cuJc;
       cuJd: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuJc: // global
           _suel::P64 = P64[R1 + 6];
           _suem::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sueo_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _suem::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _suel::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cuJ7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuJ7: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.zipWith_closure" {
     GHC.List.zipWith_closure:
         const GHC.List.zipWith_info;
 },
 go2_sues_entry() //  [R1, R2, R3]
         { info_tbl: [(cuJB,
                       label: go2_sues_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuJB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cuJC; else goto cuJD;
       cuJC: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuJD: // global
           I64[Sp - 32] = block_cuJu_info;
           _sues::P64 = R1;
           _suep::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 24] = _suep::P64;
           P64[Sp - 16] = _sues::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uuK6; else goto cuJv;
       uuK6: // global
           call _cuJu(R1) args: 0, res: 0, upd: 0;
       cuJv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuJu() //  [R1]
         { info_tbl: [(cuJu,
                       label: block_cuJu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuJu: // global
           if (R1 & 7 == 1) goto uuK2; else goto cuJz;
       uuK2: // global
           Sp = Sp + 32;
           call _cuJR() args: 0, res: 0, upd: 0;
       cuJz: // global
           I64[Sp - 8] = block_cuJJ_info;
           _suew::P64 = P64[R1 + 6];
           _suex::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _suex::P64;
           P64[Sp + 24] = _suew::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuK4; else goto cuJL;
       uuK4: // global
           call _cuJJ(R1) args: 0, res: 0, upd: 0;
       cuJL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuJJ() //  [R1]
         { info_tbl: [(cuJJ,
                       label: block_cuJJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuJJ: // global
           if (R1 & 7 == 1) goto uuK3; else goto cuJX;
       uuK3: // global
           Sp = Sp + 40;
           call _cuJR() args: 0, res: 0, upd: 0;
       cuJX: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cuK0; else goto cuJZ;
       cuK0: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuJZ: // global
           _suez::P64 = P64[R1 + 6];
           _sueA::P64 = P64[R1 + 14];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sueA::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _suez::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cuJR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuJR: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cuK8,
                       label: GHC.List.zipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuK8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cuKc; else goto cuKb;
       cuKc: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuKb: // global
           I64[Hp - 8] = go2_sues_info;
           P64[Hp] = R2;
           _sueq::P64 = R3;
           R3 = R4;
           R2 = _sueq::P64;
           R1 = Hp - 6;
           call go2_sues_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.foldr2_closure" {
     GHC.List.foldr2_closure:
         const GHC.List.foldr2_info;
 },
 go2_sueH_entry() //  [R1, R2, R3]
         { info_tbl: [(cuKt,
                       label: go2_sueH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuKt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cuKu; else goto cuKv;
       cuKu: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuKv: // global
           I64[Sp - 40] = block_cuKm_info;
           _sueH::P64 = R1;
           _sueD::P64 = P64[R1 + 6];
           _sueE::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _sueD::P64;
           P64[Sp - 24] = _sueE::P64;
           P64[Sp - 16] = _sueH::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uuKW; else goto cuKn;
       uuKW: // global
           call _cuKm(R1) args: 0, res: 0, upd: 0;
       cuKn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuKm() //  [R1]
         { info_tbl: [(cuKm,
                       label: block_cuKm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuKm: // global
           if (R1 & 7 == 1) goto uuKS; else goto cuKr;
       uuKS: // global
           Sp = Sp + 16;
           call _cuKJ() args: 0, res: 0, upd: 0;
       cuKr: // global
           I64[Sp - 8] = block_cuKB_info;
           _sueL::P64 = P64[R1 + 6];
           _sueM::P64 = P64[R1 + 14];
           R1 = P64[Sp + 32];
           P64[Sp] = _sueM::P64;
           P64[Sp + 32] = _sueL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuKU; else goto cuKD;
       uuKU: // global
           call _cuKB(R1) args: 0, res: 0, upd: 0;
       cuKD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuKB() //  [R1]
         { info_tbl: [(cuKB,
                       label: block_cuKB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuKB: // global
           if (R1 & 7 == 1) goto uuKT; else goto cuKN;
       uuKT: // global
           Sp = Sp + 24;
           call _cuKJ() args: 0, res: 0, upd: 0;
       cuKN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cuKQ; else goto cuKP;
       cuKQ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuKP: // global
           _sueO::P64 = P64[R1 + 6];
           _sueP::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sueP::P64;
           R4 = Hp - 32;
           R3 = _sueO::P64;
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 16];
           Sp = Sp + 48;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cuKJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuKJ: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.foldr2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cuKY,
                       label: GHC.List.foldr2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuKY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuL2; else goto cuL1;
       cuL2: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuL1: // global
           I64[Hp - 16] = go2_sueH_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 14;
           call go2_sueH_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.434975652 UTC

[section ""data" . GHC.List.concat_go_closure" {
     GHC.List.concat_go_closure:
         const GHC.List.concat_go_info;
 },
 sat_sueV_entry() //  [R1]
         { info_tbl: [(cuLh,
                       label: sat_sueV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuLh: // global
           R2 = P64[R1 + 16];
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.concat_go_entry() //  [R2]
         { info_tbl: [(cuLo,
                       label: GHC.List.concat_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuLo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cuLp; else goto cuLq;
       cuLp: // global
           R2 = R2;
           R1 = GHC.List.concat_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuLq: // global
           I64[Sp - 8] = block_cuL7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuLw; else goto cuL8;
       uuLw: // global
           call _cuL7(R1) args: 0, res: 0, upd: 0;
       cuL8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuL7() //  [R1]
         { info_tbl: [(cuL7,
                       label: block_cuL7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuL7: // global
           if (R1 & 7 == 1) goto cuLl; else goto cuLm;
       cuLl: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuLm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuLv; else goto cuLu;
       cuLv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuLu: // global
           _sueT::P64 = P64[R1 + 6];
           _sueU::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sueV_info;
           P64[Hp] = _sueU::P64;
           R3 = Hp - 16;
           R2 = _sueT::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.436332007 UTC

[section ""data" . GHC.List.concat_closure" {
     GHC.List.concat_closure:
         const GHC.List.concat_info;
 },
 GHC.List.concat_entry() //  [R2]
         { info_tbl: [(cuLB,
                       label: GHC.List.concat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuLB: // global
           R2 = R2;
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.43775499 UTC

[section ""data" . GHC.List.concatMap_closure" {
     GHC.List.concatMap_closure:
         const GHC.List.concatMap_info;
 },
 sat_suf4_entry() //  [R1]
         { info_tbl: [(cuLX,
                       label: sat_suf4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuLX: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go2_sueY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_sueY_entry() //  [R1, R2]
         { info_tbl: [(cuM4,
                       label: go2_sueY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuM4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuM5; else goto cuM6;
       cuM5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuM6: // global
           I64[Sp - 24] = block_cuLN_info;
           _sueY::P64 = R1;
           _sueW::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sueW::P64;
           P64[Sp - 8] = _sueY::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uuMh; else goto cuLO;
       uuMh: // global
           call _cuLN(R1) args: 0, res: 0, upd: 0;
       cuLO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuLN() //  [R1]
         { info_tbl: [(cuLN,
                       label: block_cuLN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuLN: // global
           if (R1 & 7 == 1) goto cuM1; else goto cuM2;
       cuM1: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuM2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cuMc; else goto cuMb;
       cuMc: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuMb: // global
           _suf1::P64 = P64[R1 + 6];
           _suf2::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_suf4_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _suf2::P64;
           _sueW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cuM9_info;
           R2 = _suf1::P64;
           R1 = _sueW::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuM9() //  [R1]
         { info_tbl: [(cuM9,
                       label: block_cuM9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuM9: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.concatMap_entry() //  [R2, R3]
         { info_tbl: [(cuMi,
                       label: GHC.List.concatMap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuMi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cuMm; else goto cuMl;
       cuMm: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.concatMap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuMl: // global
           I64[Hp - 8] = go2_sueY_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_sueY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.440123209 UTC

[section ""data" . GHC.List.lookup_closure" {
     GHC.List.lookup_closure:
         const GHC.List.lookup_info;
 },
 GHC.List.lookup_entry() //  [R2, R3, R4]
         { info_tbl: [(cuMy,
                       label: GHC.List.lookup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuMy: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cuMz; else goto uuN2;
       cuMz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lookup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uuN2: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cuMo() args: 0, res: 0, upd: 0;
     }
 },
 _cuMo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuMo: // global
           I64[Sp - 8] = block_cuMr_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuN4; else goto cuMs;
       uuN4: // global
           call _cuMr(R1) args: 0, res: 0, upd: 0;
       cuMs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuMr() //  [R1]
         { info_tbl: [(cuMr,
                       label: block_cuMr_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuMr: // global
           if (R1 & 7 == 1) goto cuMv; else goto cuMw;
       cuMv: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuMw: // global
           I64[Sp] = block_cuMG_info;
           _sufa::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sufa::P64;
           if (R1 & 7 != 0) goto uuN5; else goto cuMI;
       uuN5: // global
           call _cuMG(R1) args: 0, res: 0, upd: 0;
       cuMI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuMG() //  [R1]
         { info_tbl: [(cuMG,
                       label: block_cuMG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuMG: // global
           I64[Sp - 8] = block_cuMM_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cuMM() //  [R1]
         { info_tbl: [(cuMM,
                       label: block_cuMM_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuMM: // global
           if (R1 & 7 == 1) goto cuMT; else goto cuMX;
       cuMT: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 16;
           call _cuMo() args: 0, res: 0, upd: 0;
       cuMX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cuN0; else goto cuMZ;
       cuN0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuMZ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.44237687 UTC

[section ""data" . GHC.List.notElem_closure" {
     GHC.List.notElem_closure:
         const GHC.List.notElem_info;
 },
 GHC.List.notElem_entry() //  [R2, R3, R4]
         { info_tbl: [(cuNj,
                       label: GHC.List.notElem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuNj: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cuNk; else goto uuNE;
       cuNk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.notElem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uuNE: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cuN9() args: 0, res: 0, upd: 0;
     }
 },
 _cuN9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuN9: // global
           I64[Sp - 8] = block_cuNc_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuNG; else goto cuNd;
       uuNG: // global
           call _cuNc(R1) args: 0, res: 0, upd: 0;
       cuNd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuNc() //  [R1]
         { info_tbl: [(cuNc,
                       label: block_cuNc_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuNc: // global
           if (R1 & 7 == 1) goto cuNg; else goto cuNh;
       cuNg: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuNh: // global
           I64[Sp] = block_cuNr_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes./=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cuNr() //  [R1]
         { info_tbl: [(cuNr,
                       label: block_cuNr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuNr: // global
           if (R1 & 7 == 1) goto cuNy; else goto cuNC;
       cuNy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuNC: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cuN9() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.444321998 UTC

[section ""data" . GHC.List.elem_closure" {
     GHC.List.elem_closure:
         const GHC.List.elem_info;
 },
 GHC.List.elem_entry() //  [R2, R3, R4]
         { info_tbl: [(cuNU,
                       label: GHC.List.elem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuNU: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cuNV; else goto uuOf;
       cuNV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.elem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uuOf: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cuNK() args: 0, res: 0, upd: 0;
     }
 },
 _cuNK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuNK: // global
           I64[Sp - 8] = block_cuNN_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuOh; else goto cuNO;
       uuOh: // global
           call _cuNN(R1) args: 0, res: 0, upd: 0;
       cuNO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuNN() //  [R1]
         { info_tbl: [(cuNN,
                       label: block_cuNN_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuNN: // global
           if (R1 & 7 == 1) goto cuNR; else goto cuNS;
       cuNR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuNS: // global
           I64[Sp] = block_cuO2_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cuO2() //  [R1]
         { info_tbl: [(cuO2,
                       label: block_cuO2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuO2: // global
           if (R1 & 7 == 1) goto cuO9; else goto cuOd;
       cuO9: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cuNK() args: 0, res: 0, upd: 0;
       cuOd: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.447021013 UTC

[section ""data" . GHC.List.all_closure" {
     GHC.List.all_closure:
         const GHC.List.all_info;
 },
 GHC.List.all_entry() //  [R2, R3]
         { info_tbl: [(cuOv,
                       label: GHC.List.all_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuOv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuOw; else goto uuOQ;
       cuOw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.all_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uuOQ: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cuOl() args: 0, res: 0, upd: 0;
     }
 },
 _cuOl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuOl: // global
           I64[Sp - 8] = block_cuOo_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuOS; else goto cuOp;
       uuOS: // global
           call _cuOo(R1) args: 0, res: 0, upd: 0;
       cuOp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuOo() //  [R1]
         { info_tbl: [(cuOo,
                       label: block_cuOo_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuOo: // global
           if (R1 & 7 == 1) goto cuOs; else goto cuOt;
       cuOs: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuOt: // global
           I64[Sp] = block_cuOD_info;
           R2 = P64[R1 + 6];
           _sufx::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sufx::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuOD() //  [R1]
         { info_tbl: [(cuOD,
                       label: block_cuOD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuOD: // global
           if (R1 & 7 == 1) goto cuOK; else goto cuOO;
       cuOK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuOO: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cuOl() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.448810742 UTC

[section ""data" . GHC.List.any_closure" {
     GHC.List.any_closure:
         const GHC.List.any_info;
 },
 GHC.List.any_entry() //  [R2, R3]
         { info_tbl: [(cuP6,
                       label: GHC.List.any_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuP6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuP7; else goto uuPr;
       cuP7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.any_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uuPr: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cuOW() args: 0, res: 0, upd: 0;
     }
 },
 _cuOW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuOW: // global
           I64[Sp - 8] = block_cuOZ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuPt; else goto cuP0;
       uuPt: // global
           call _cuOZ(R1) args: 0, res: 0, upd: 0;
       cuP0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuOZ() //  [R1]
         { info_tbl: [(cuOZ,
                       label: block_cuOZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuOZ: // global
           if (R1 & 7 == 1) goto cuP3; else goto cuP4;
       cuP3: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuP4: // global
           I64[Sp] = block_cuPe_info;
           R2 = P64[R1 + 6];
           _sufD::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sufD::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuPe() //  [R1]
         { info_tbl: [(cuPe,
                       label: block_cuPe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuPe: // global
           if (R1 & 7 == 1) goto cuPl; else goto cuPp;
       cuPl: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cuOW() args: 0, res: 0, upd: 0;
       cuPp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.450605804 UTC

[section ""data" . GHC.List.or_closure" {
     GHC.List.or_closure:
         const GHC.List.or_info;
 },
 GHC.List.or_entry() //  [R2]
         { info_tbl: [(cuPH,
                       label: GHC.List.or_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuPH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuPI; else goto uuQ3;
       cuPI: // global
           R2 = R2;
           R1 = GHC.List.or_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uuQ3: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cuPx() args: 0, res: 0, upd: 0;
     }
 },
 _cuPx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuPx: // global
           _sufF::P64 = P64[Sp];
           I64[Sp] = block_cuPA_info;
           R1 = _sufF::P64;
           if (R1 & 7 != 0) goto uuQ5; else goto cuPB;
       uuQ5: // global
           call _cuPA(R1) args: 0, res: 0, upd: 0;
       cuPB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuPA() //  [R1]
         { info_tbl: [(cuPA,
                       label: block_cuPA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuPA: // global
           if (R1 & 7 == 1) goto cuPE; else goto cuPF;
       cuPE: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuPF: // global
           I64[Sp - 8] = block_cuPP_info;
           _sufI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sufI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuQ6; else goto cuPR;
       uuQ6: // global
           call _cuPP(R1) args: 0, res: 0, upd: 0;
       cuPR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuPP() //  [R1]
         { info_tbl: [(cuPP,
                       label: block_cuPP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuPP: // global
           if (R1 & 7 == 1) goto cuPX; else goto cuQ1;
       cuPX: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cuPx() args: 0, res: 0, upd: 0;
       cuQ1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.452393195 UTC

[section ""data" . GHC.List.and_closure" {
     GHC.List.and_closure:
         const GHC.List.and_info;
 },
 GHC.List.and_entry() //  [R2]
         { info_tbl: [(cuQk,
                       label: GHC.List.and_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuQk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuQl; else goto uuQG;
       cuQl: // global
           R2 = R2;
           R1 = GHC.List.and_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uuQG: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cuQa() args: 0, res: 0, upd: 0;
     }
 },
 _cuQa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuQa: // global
           _sufK::P64 = P64[Sp];
           I64[Sp] = block_cuQd_info;
           R1 = _sufK::P64;
           if (R1 & 7 != 0) goto uuQI; else goto cuQe;
       uuQI: // global
           call _cuQd(R1) args: 0, res: 0, upd: 0;
       cuQe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuQd() //  [R1]
         { info_tbl: [(cuQd,
                       label: block_cuQd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuQd: // global
           if (R1 & 7 == 1) goto cuQh; else goto cuQi;
       cuQh: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuQi: // global
           I64[Sp - 8] = block_cuQs_info;
           _sufN::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sufN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuQJ; else goto cuQu;
       uuQJ: // global
           call _cuQs(R1) args: 0, res: 0, upd: 0;
       cuQu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuQs() //  [R1]
         { info_tbl: [(cuQs,
                       label: block_cuQs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuQs: // global
           if (R1 & 7 == 1) goto cuQA; else goto cuQE;
       cuQA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuQE: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cuQa() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.454170675 UTC

[section ""data" . GHC.List.reverse1_closure" {
     GHC.List.reverse1_closure:
         const GHC.List.reverse1_info;
 },
 GHC.List.reverse1_entry() //  [R2, R3]
         { info_tbl: [(cuR1,
                       label: GHC.List.reverse1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuR1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuR2; else goto uuR9;
       cuR2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.reverse1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uuR9: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cuQN() args: 0, res: 0, upd: 0;
     }
 },
 _cuQN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuQN: // global
           _sufP::P64 = P64[Sp];
           I64[Sp] = block_cuQQ_info;
           R1 = _sufP::P64;
           if (R1 & 7 != 0) goto uuRb; else goto cuQR;
       uuRb: // global
           call _cuQQ(R1) args: 0, res: 0, upd: 0;
       cuQR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuQQ() //  [R1]
         { info_tbl: [(cuQQ,
                       label: block_cuQQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuQQ: // global
           _sufQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cuQY; else goto cuQZ;
       cuQY: // global
           R1 = _sufQ::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cuQZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuR8; else goto cuR7;
       cuR8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuR7: // global
           _sufS::P64 = P64[R1 + 6];
           _sufT::P64 = P64[R1 + 14];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sufS::P64;
           P64[Hp] = _sufQ::P64;
           P64[Sp] = _sufT::P64;
           P64[Sp + 8] = Hp - 14;
           call _cuQN() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.455494465 UTC

[section ""data" . GHC.List.reverse_closure" {
     GHC.List.reverse_closure:
         const GHC.List.reverse_info;
 },
 GHC.List.reverse_entry() //  [R2]
         { info_tbl: [(cuRi,
                       label: GHC.List.reverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuRi: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.45695971 UTC

[section ""data" . GHC.List.$wbreak_closure" {
     GHC.List.$wbreak_closure:
         const GHC.List.$wbreak_info;
 },
 ds_sug2_entry() //  [R1]
         { info_tbl: [(cuRG,
                       label: ds_sug2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuRG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuRH; else goto cuRI;
       cuRH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuRI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cuRD_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cuRD() //  [R1, R2]
         { info_tbl: [(cuRD,
                       label: block_cuRD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuRD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuRL; else goto cuRK;
       cuRL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cuRK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wbreak_entry() //  [R2, R3]
         { info_tbl: [(cuRQ,
                       label: GHC.List.$wbreak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuRQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cuRR; else goto cuRS;
       cuRR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wbreak_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuRS: // global
           I64[Sp - 16] = block_cuRp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuS9; else goto cuRq;
       uuS9: // global
           call _cuRp(R1) args: 0, res: 0, upd: 0;
       cuRq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuRp() //  [R1]
         { info_tbl: [(cuRp,
                       label: block_cuRp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuRp: // global
           if (R1 & 7 == 1) goto cuRN; else goto cuRO;
       cuRN: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cuRO: // global
           I64[Sp - 24] = block_cuRv_info;
           _sufZ::P64 = P64[R1 + 6];
           R2 = _sufZ::P64;
           _sufY::P64 = R1;
           _sug0::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sufZ::P64;
           P64[Sp - 8] = _sug0::P64;
           P64[Sp] = _sufY::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuRv() //  [R1]
         { info_tbl: [(cuRv,
                       label: block_cuRv_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuRv: // global
           if (R1 & 7 == 1) goto cuS0; else goto cuS7;
       cuS0: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cuS3; else goto cuS2;
       cuS3: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuS2: // global
           I64[Hp - 96] = ds_sug2_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cuRz::P64 = Hp - 96;
           P64[Hp - 48] = _cuRz::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cuRz::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cuS7: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.459420653 UTC

[section ""data" . GHC.List.break_closure" {
     GHC.List.break_closure:
         const GHC.List.break_info;
 },
 GHC.List.break_entry() //  [R2, R3]
         { info_tbl: [(cuSh,
                       label: GHC.List.break_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuSh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cuSi; else goto cuSj;
       cuSi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.break_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuSj: // global
           I64[Sp - 8] = block_cuSe_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cuSe() //  [R1, R2]
         { info_tbl: [(cuSe,
                       label: block_cuSe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuSe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuSm; else goto cuSl;
       cuSm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cuSl: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.461292024 UTC

[section ""data" . GHC.List.$wspan_closure" {
     GHC.List.$wspan_closure:
         const GHC.List.$wspan_info;
 },
 ds_sugq_entry() //  [R1]
         { info_tbl: [(cuSJ,
                       label: ds_sugq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuSJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuSK; else goto cuSL;
       cuSK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuSL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cuSG_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cuSG() //  [R1, R2]
         { info_tbl: [(cuSG,
                       label: block_cuSG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuSG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuSO; else goto cuSN;
       cuSO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cuSN: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wspan_entry() //  [R2, R3]
         { info_tbl: [(cuST,
                       label: GHC.List.$wspan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuST: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cuSU; else goto cuSV;
       cuSU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wspan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuSV: // global
           I64[Sp - 16] = block_cuSr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuTb; else goto cuSs;
       uuTb: // global
           call _cuSr(R1) args: 0, res: 0, upd: 0;
       cuSs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuSr() //  [R1]
         { info_tbl: [(cuSr,
                       label: block_cuSr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuSr: // global
           if (R1 & 7 == 1) goto cuSQ; else goto cuSR;
       cuSQ: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cuSR: // global
           I64[Sp - 24] = block_cuSx_info;
           _sugn::P64 = P64[R1 + 6];
           R2 = _sugn::P64;
           _sugm::P64 = R1;
           _sugo::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sugn::P64;
           P64[Sp - 8] = _sugo::P64;
           P64[Sp] = _sugm::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuSx() //  [R1]
         { info_tbl: [(cuSx,
                       label: block_cuSx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuSx: // global
           if (R1 & 7 == 1) goto cuT2; else goto cuT6;
       cuT2: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cuT6: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cuT9; else goto cuT8;
       cuT9: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuT8: // global
           I64[Hp - 96] = ds_sugq_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cuSC::P64 = Hp - 96;
           P64[Hp - 48] = _cuSC::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cuSC::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.464239813 UTC

[section ""data" . GHC.List.span_closure" {
     GHC.List.span_closure:
         const GHC.List.span_info;
 },
 GHC.List.span_entry() //  [R2, R3]
         { info_tbl: [(cuTj,
                       label: GHC.List.span_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuTj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cuTk; else goto cuTl;
       cuTk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.span_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuTl: // global
           I64[Sp - 8] = block_cuTg_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cuTg() //  [R1, R2]
         { info_tbl: [(cuTg,
                       label: block_cuTg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuTg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuTo; else goto cuTn;
       cuTo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cuTn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.465861823 UTC

[section ""data" . GHC.List.takeFB_closure" {
     GHC.List.takeFB_closure:
         const GHC.List.takeFB_info;
 },
 sat_sugS_entry() //  [R1]
         { info_tbl: [(cuTG,
                       label: sat_sugS_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuTG: // global
           _sugS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cuTJ; else goto cuTK;
       cuTK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cuTM; else goto cuTL;
       cuTM: // global
           HpAlloc = 16;
           goto cuTJ;
       cuTJ: // global
           R1 = _sugS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuTL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sugS::P64;
           _sugL::P64 = P64[_sugS::P64 + 16];
           _sugQ::I64 = I64[_sugS::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sugQ::I64;
           R2 = Hp - 7;
           R1 = _sugL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.takeFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cuTN,
                       label: GHC.List.takeFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuTN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cuTO; else goto cuTP;
       cuTO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuTP: // global
           I64[Sp - 40] = block_cuTt_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uuTW; else goto cuTu;
       uuTW: // global
           call _cuTt(R1) args: 0, res: 0, upd: 0;
       cuTu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuTt() //  [R1]
         { info_tbl: [(cuTt,
                       label: block_cuTt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuTt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cuTS; else goto cuTR;
       cuTS: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuTR: // global
           _sugI::P64 = P64[Sp + 8];
           _sugK::P64 = P64[Sp + 24];
           _sugP::I64 = I64[R1 + 7];
           if (_sugP::I64 != 1) goto cuTU; else goto cuTV;
       cuTU: // global
           I64[Hp - 24] = sat_sugS_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = _sugP::I64;
           R3 = Hp - 24;
           R2 = _sugK::P64;
           R1 = _sugI::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuTV: // global
           Hp = Hp - 32;
           R3 = P64[Sp + 16];
           R2 = _sugK::P64;
           R1 = _sugI::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.467690912 UTC

[section ""data" . GHC.List.flipSeqTake_closure" {
     GHC.List.flipSeqTake_closure:
         const GHC.List.flipSeqTake_info;
 },
 GHC.List.flipSeqTake_entry() //  [R2, R3]
         { info_tbl: [(cuU4,
                       label: GHC.List.flipSeqTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuU4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuU5; else goto cuU6;
       cuU5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuU6: // global
           I64[Sp - 16] = block_cuU1_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuUa; else goto cuU2;
       uuUa: // global
           call _cuU1() args: 0, res: 0, upd: 0;
       cuU2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuU1() //  []
         { info_tbl: [(cuU1,
                       label: block_cuU1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuU1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.469185264 UTC

[section ""data" . GHC.List.$wunsafeTake_closure" {
     GHC.List.$wunsafeTake_closure:
         const GHC.List.$wunsafeTake_info;
 },
 sat_suh4_entry() //  [R1]
         { info_tbl: [(cuUt,
                       label: sat_suh4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuUt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuUu; else goto cuUv;
       cuUu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuUv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24] - 1;
           Sp = Sp - 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wunsafeTake_entry() //  [R2, R3]
         { info_tbl: [(cuUA,
                       label: GHC.List.$wunsafeTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuUA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuUB; else goto cuUC;
       cuUB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wunsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuUC: // global
           I64[Sp - 16] = block_cuUf_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuUO; else goto cuUg;
       uuUO: // global
           call _cuUf(R1) args: 0, res: 0, upd: 0;
       cuUg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuUf() //  [R1]
         { info_tbl: [(cuUf,
                       label: block_cuUf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuUf: // global
           if (R1 & 7 == 1) goto cuUx; else goto cuUy;
       cuUx: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuUy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cuUH; else goto cuUG;
       cuUH: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuUG: // global
           _suh0::P64 = P64[R1 + 6];
           _suh2::I64 = I64[Sp + 8];
           if (_suh2::I64 != 1) goto cuUK; else goto cuUN;
       cuUK: // global
           _suh1::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_suh4_info;
           P64[Hp - 32] = _suh1::P64;
           I64[Hp - 24] = _suh2::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suh0::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuUN: // global
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = _suh0::P64;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cuUM::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cuUM::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.471157134 UTC

[section ""data" . GHC.List.unsafeTake_closure" {
     GHC.List.unsafeTake_closure:
         const GHC.List.unsafeTake_info;
 },
 GHC.List.unsafeTake_entry() //  [R2, R3]
         { info_tbl: [(cuUW,
                       label: GHC.List.unsafeTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuUW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuUX; else goto cuUY;
       cuUX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.unsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuUY: // global
           I64[Sp - 16] = block_cuUT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuV2; else goto cuUU;
       uuV2: // global
           call _cuUT(R1) args: 0, res: 0, upd: 0;
       cuUU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuUT() //  [R1]
         { info_tbl: [(cuUT,
                       label: block_cuUT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuUT: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.472445313 UTC

[section ""data" . GHC.List.take_closure" {
     GHC.List.take_closure:
         const GHC.List.take_info;
 },
 GHC.List.take_entry() //  [R2, R3]
         { info_tbl: [(cuVa,
                       label: GHC.List.take_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuVa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuVb; else goto cuVc;
       cuVb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.take_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuVc: // global
           I64[Sp - 16] = block_cuV7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuVl; else goto cuV8;
       uuVl: // global
           call _cuV7(R1) args: 0, res: 0, upd: 0;
       cuV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuV7() //  [R1]
         { info_tbl: [(cuV7,
                       label: block_cuV7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuV7: // global
           _suhc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _suhc::I64)) goto cuVj; else goto cuVk;
       cuVj: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuVk: // global
           R3 = P64[Sp + 8];
           R2 = _suhc::I64;
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.474041561 UTC

[section ""data" . GHC.List.dropWhile_closure" {
     GHC.List.dropWhile_closure:
         const GHC.List.dropWhile_info;
 },
 GHC.List.dropWhile_entry() //  [R2, R3]
         { info_tbl: [(cuVx,
                       label: GHC.List.dropWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuVx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cuVy; else goto uuVS;
       cuVy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.dropWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uuVS: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cuVn() args: 0, res: 0, upd: 0;
     }
 },
 _cuVn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuVn: // global
           I64[Sp - 8] = block_cuVq_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uuVU; else goto cuVr;
       uuVU: // global
           call _cuVq(R1) args: 0, res: 0, upd: 0;
       cuVr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuVq() //  [R1]
         { info_tbl: [(cuVq,
                       label: block_cuVq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuVq: // global
           if (R1 & 7 == 1) goto cuVu; else goto cuVv;
       cuVu: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuVv: // global
           I64[Sp - 8] = block_cuVF_info;
           R2 = P64[R1 + 6];
           _suhg::P64 = R1;
           _suhi::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _suhi::P64;
           P64[Sp + 16] = _suhg::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuVF() //  [R1]
         { info_tbl: [(cuVF,
                       label: block_cuVF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuVF: // global
           if (R1 & 7 == 1) goto cuVM; else goto cuVQ;
       cuVM: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cuVQ: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cuVn() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.475744631 UTC

[section ""data" . GHC.List.takeWhileFB_closure" {
     GHC.List.takeWhileFB_closure:
         const GHC.List.takeWhileFB_info;
 },
 GHC.List.takeWhileFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cuW7,
                       label: GHC.List.takeWhileFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuW7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cuW8; else goto cuW9;
       cuW8: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhileFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuW9: // global
           I64[Sp - 40] = block_cuW1_info;
           _suhk::P64 = R2;
           R2 = R5;
           R1 = _suhk::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuW1() //  [R1]
         { info_tbl: [(cuW1,
                       label: block_cuW1_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuW1: // global
           if (R1 & 7 == 1) goto cuW4; else goto cuW5;
       cuW4: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cuW5: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.477558111 UTC

[section ""data" . GHC.List.takeWhile_closure" {
     GHC.List.takeWhile_closure:
         const GHC.List.takeWhile_info;
 },
 sat_suhw_entry() //  [R1]
         { info_tbl: [(cuWz,
                       label: sat_suhw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuWz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuWA; else goto cuWB;
       cuWA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuWB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.takeWhile_entry() //  [R2, R3]
         { info_tbl: [(cuWG,
                       label: GHC.List.takeWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuWG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cuWH; else goto cuWI;
       cuWH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuWI: // global
           I64[Sp - 16] = block_cuWk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuX0; else goto cuWl;
       uuX0: // global
           call _cuWk(R1) args: 0, res: 0, upd: 0;
       cuWl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuWk() //  [R1]
         { info_tbl: [(cuWk,
                       label: block_cuWk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuWk: // global
           if (R1 & 7 == 1) goto uuWW; else goto cuWE;
       uuWW: // global
           Sp = Sp + 16;
           call _cuWP() args: 0, res: 0, upd: 0;
       cuWE: // global
           I64[Sp - 16] = block_cuWq_info;
           _suht::P64 = P64[R1 + 6];
           R2 = _suht::P64;
           _suhu::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _suhu::P64;
           P64[Sp] = _suht::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuWq() //  [R1]
         { info_tbl: [(cuWq,
                       label: block_cuWq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuWq: // global
           if (R1 & 7 == 1) goto uuWX; else goto cuWR;
       uuWX: // global
           Sp = Sp + 32;
           call _cuWP() args: 0, res: 0, upd: 0;
       cuWR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cuWU; else goto cuWT;
       cuWU: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuWT: // global
           I64[Hp - 48] = sat_suhw_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cuWP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuWP: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.480292746 UTC

[section ""data" . GHC.List.repeat_closure" {
     GHC.List.repeat_closure:
         const GHC.List.repeat_info;
 },
 GHC.List.repeat_entry() //  [R2]
         { info_tbl: [(cuX6,
                       label: GHC.List.repeat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuX6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuXa; else goto cuX9;
       cuXa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.List.repeat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuX9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           _cuX5::P64 = Hp - 14;
           P64[Hp] = _cuX5::P64;
           R1 = _cuX5::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.repeatFB_closure" {
     GHC.List.repeatFB_closure:
         const GHC.List.repeatFB_info;
 },
 GHC.List.repeatFB_entry() //  [R2, R3]
         { info_tbl: [(cuXg,
                       label: GHC.List.repeatFB_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuXg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cuXk; else goto cuXj;
       cuXk: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.repeatFB_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuXj: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           _cuXf::P64 = Hp - 32;
           P64[Hp] = _cuXf::P64;
           R1 = _cuXf::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.482189965 UTC

[section ""data" . GHC.List.replicate_closure" {
     GHC.List.replicate_closure:
         const GHC.List.replicate_info;
 },
 sat_suhM_entry() //  [R1]
         { info_tbl: [(cuXM,
                       label: sat_suhM_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuXM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuXN; else goto cuXO;
       cuXN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuXO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_suhI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_suhI_entry() //  [R1, R2]
         { info_tbl: [(cuXS,
                       label: $wxs_suhI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuXS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cuXW; else goto cuXV;
       cuXW: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuXV: // global
           if (R2 == 1) goto cuXR; else goto cuXQ;
       cuXR: // global
           _suhH::P64 = P64[R1 + 15];
           Hp = Hp - 56;
           R1 = _suhH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuXQ: // global
           _suhD::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_suhM_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suhD::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.replicate_entry() //  [R2, R3]
         { info_tbl: [(cuXY,
                       label: GHC.List.replicate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuXY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cuXZ; else goto cuY0;
       cuXZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.replicate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuY0: // global
           I64[Sp - 16] = block_cuXp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uuY7; else goto cuXq;
       uuY7: // global
           call _cuXp(R1) args: 0, res: 0, upd: 0;
       cuXq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuXp() //  [R1]
         { info_tbl: [(cuXp,
                       label: block_cuXp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuXp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cuY3; else goto cuY2;
       cuY3: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuY2: // global
           _suhF::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _suhF::I64)) goto cuY5; else goto cuY6;
       cuY5: // global
           Hp = Hp - 48;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cuY6: // global
           I64[Hp - 40] = :_con_info;
           _suhD::P64 = P64[Sp + 8];
           P64[Hp - 32] = _suhD::P64;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = $wxs_suhI_info;
           P64[Hp - 8] = _suhD::P64;
           P64[Hp] = Hp - 38;
           R2 = _suhF::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call $wxs_suhI_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.484470693 UTC

[section ""data" . GHC.List.$witerate'_closure" {
     GHC.List.$witerate'_closure:
         const GHC.List.$witerate'_info;
 },
 sat_suhT_entry() //  [R1]
         { info_tbl: [(cuYl,
                       label: sat_suhT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuYl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuYm; else goto cuYn;
       cuYm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuYn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cuYi_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cuYi() //  [R1, R2]
         { info_tbl: [(cuYi,
                       label: block_cuYi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuYi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuYq; else goto cuYp;
       cuYq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cuYp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$witerate'_entry() //  [R2, R3]
         { info_tbl: [(cuYr,
                       label: GHC.List.$witerate'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuYr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cuYs; else goto cuYt;
       cuYs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuYt: // global
           I64[Sp - 24] = block_cuYc_info;
           _suhN::P64 = R2;
           R2 = R3;
           R1 = _suhN::P64;
           P64[Sp - 16] = _suhN::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuYc() //  [R1]
         { info_tbl: [(cuYc,
                       label: block_cuYc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuYc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cuYw; else goto cuYv;
       cuYw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuYv: // global
           I64[Hp - 24] = sat_suhT_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = Hp - 24;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.486655958 UTC

[section ""data" . GHC.List.iterate'FB_closure" {
     GHC.List.iterate'FB_closure:
         const GHC.List.iterate'FB_info;
 },
 go2_suhX_entry() //  [R1, R2]
         { info_tbl: [(cuYJ,
                       label: go2_suhX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuYJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cuYK; else goto cuYL;
       cuYK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuYL: // global
           I64[Sp - 32] = block_cuYG_info;
           _suhY::P64 = R2;
           R2 = R2;
           _suhX::P64 = R1;
           _suhU::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 24] = _suhU::P64;
           P64[Sp - 16] = _suhX::P64;
           P64[Sp - 8] = _suhY::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cuYG() //  [R1]
         { info_tbl: [(cuYG,
                       label: block_cuYG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuYG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cuYO; else goto cuYN;
       cuYO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cuYN: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.iterate'FB_entry() //  [R2, R3, R4]
         { info_tbl: [(cuYP,
                       label: GHC.List.iterate'FB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuYP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuYT; else goto cuYS;
       cuYT: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'FB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuYS: // global
           I64[Hp - 16] = go2_suhX_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_suhX_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.iterate'_closure" {
     GHC.List.iterate'_closure:
         const GHC.List.iterate'_info;
 },
 GHC.List.iterate'_entry() //  [R2, R3]
         { info_tbl: [(cuZ1,
                       label: GHC.List.iterate'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuZ1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cuZ2; else goto cuZ3;
       cuZ2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuZ3: // global
           I64[Sp - 8] = block_cuYY_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cuYY() //  [R1, R2]
         { info_tbl: [(cuYY,
                       label: block_cuYY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuYY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuZ6; else goto cuZ5;
       cuZ6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cuZ5: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.488953938 UTC

[section ""data" . GHC.List.$witerate_closure" {
     GHC.List.$witerate_closure:
         const GHC.List.$witerate_info;
 },
 sat_suic_entry() //  [R1]
         { info_tbl: [(cuZj,
                       label: sat_suic_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuZj: // global
           _suic::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cuZk; else goto cuZl;
       cuZl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cuZn; else goto cuZm;
       cuZn: // global
           HpAlloc = 32;
           goto cuZk;
       cuZk: // global
           R1 = _suic::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuZm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suic::P64;
           _sui6::P64 = P64[_suic::P64 + 16];
           _sui7::P64 = P64[_suic::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sui6::P64;
           P64[Hp] = _sui7::P64;
           I64[Sp - 24] = block_cuZg_info;
           R3 = Hp - 24;
           R2 = _sui6::P64;
           Sp = Sp - 24;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cuZg() //  [R1, R2]
         { info_tbl: [(cuZg,
                       label: block_cuZg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuZg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuZq; else goto cuZp;
       cuZq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cuZp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$witerate_entry() //  [R2, R3]
         { info_tbl: [(cuZr,
                       label: GHC.List.$witerate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuZr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cuZv; else goto cuZu;
       cuZv: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cuZu: // global
           I64[Hp - 24] = sat_suic_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.491160651 UTC

[section ""data" . GHC.List.iterateFB_closure" {
     GHC.List.iterateFB_closure:
         const GHC.List.iterateFB_info;
 },
 sat_suij_entry() //  [R1]
         { info_tbl: [(cuZK,
                       label: sat_suij_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuZK: // global
           _suij::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cuZL; else goto cuZM;
       cuZM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cuZO; else goto cuZN;
       cuZO: // global
           HpAlloc = 32;
           goto cuZL;
       cuZL: // global
           R1 = _suij::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cuZN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suij::P64;
           _suie::P64 = P64[_suij::P64 + 16];
           _suig::P64 = P64[_suij::P64 + 24];
           _suih::P64 = P64[_suij::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _suie::P64;
           P64[Hp] = _suih::P64;
           R2 = Hp - 24;
           R1 = _suig::P64;
           Sp = Sp - 16;
           call go2_suig_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go2_suig_entry() //  [R1, R2]
         { info_tbl: [(cuZP,
                       label: go2_suig_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuZP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cuZT; else goto cuZS;
       cuZT: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cuZS: // global
           _suid::P64 = P64[R1 + 7];
           _suie::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_suij_info;
           P64[Hp - 16] = _suie::P64;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = R2;
           R1 = _suid::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.iterateFB_entry() //  [R2, R3, R4]
         { info_tbl: [(cuZU,
                       label: GHC.List.iterateFB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cuZU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cuZY; else goto cuZX;
       cuZY: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterateFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cuZX: // global
           I64[Hp - 16] = go2_suig_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_suig_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.iterate_closure" {
     GHC.List.iterate_closure:
         const GHC.List.iterate_info;
 },
 GHC.List.iterate_entry() //  [R2, R3]
         { info_tbl: [(cv06,
                       label: GHC.List.iterate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv06: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cv07; else goto cv08;
       cv07: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cv08: // global
           I64[Sp - 8] = block_cv03_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cv03() //  [R1, R2]
         { info_tbl: [(cv03,
                       label: block_cv03_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv03: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cv0b; else goto cv0a;
       cv0b: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cv0a: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.49312445 UTC

[section ""cstring" . lvl27_ru9o_bytes" {
     lvl27_ru9o_bytes:
         I8[] [71,72,67,47,76,105,115,116,46,104,115,58,52,49,49,58,51,52,45,53,53,124,113,115,64,40,113,32,58,32,95,41]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.494041776 UTC

[section ""data" . lvl28_ru9p_closure" {
     lvl28_ru9p_closure:
         const lvl28_ru9p_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_ru9p_entry() //  [R1]
         { info_tbl: [(cv0i,
                       label: lvl28_ru9p_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv0i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv0j; else goto cv0k;
       cv0j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv0k: // global
           (_cv0f::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cv0f::I64 == 0) goto cv0h; else goto cv0g;
       cv0h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cv0g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cv0f::I64;
           R2 = lvl27_ru9o_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.496676781 UTC

[section ""data" . GHC.List.scanr1_closure" {
     GHC.List.scanr1_closure:
         const GHC.List.scanr1_info;
         const 0;
 },
 ds3_suix_entry() //  [R1]
         { info_tbl: [(cv0L,
                       label: ds3_suix_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv0L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cv0M; else goto cv0N;
       cv0M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv0N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cv0F_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.scanr1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cv0F() //  [R1]
         { info_tbl: [(cv0F,
                       label: block_cv0F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv0F: // global
           if (R1 & 7 == 1) goto cv0I; else goto cv0J;
       cv0I: // global
           R1 = lvl28_ru9p_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cv0J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cv0W; else goto cv0V;
       cv0W: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cv0V: // global
           _suiz::P64 = P64[R1 + 6];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _suiz::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_suiF_entry() //  [R1]
         { info_tbl: [(cv13,
                       label: sat_suiF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv13: // global
           _suiF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cv14; else goto cv15;
       cv15: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cv17; else goto cv16;
       cv17: // global
           HpAlloc = 24;
           goto cv14;
       cv14: // global
           R1 = _suiF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv16: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suiF::P64;
           _suip::P64 = P64[_suiF::P64 + 16];
           _suis::P64 = P64[_suiF::P64 + 24];
           _suix::P64 = P64[_suiF::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _suix::P64;
           R3 = Hp - 16;
           R2 = _suis::P64;
           R1 = _suip::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.scanr1_entry() //  [R2, R3]
         { info_tbl: [(cv1c,
                       label: GHC.List.scanr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv1c: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cv1d; else goto cv1e;
       cv1d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cv1e: // global
           I64[Sp - 16] = block_cv0p_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uv1w; else goto cv0q;
       uv1w: // global
           call _cv0p(R1) args: 0, res: 0, upd: 0;
       cv0q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv0p() //  [R1]
         { info_tbl: [(cv0p,
                       label: block_cv0p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv0p: // global
           if (R1 & 7 == 1) goto cv19; else goto cv1a;
       cv19: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cv1a: // global
           I64[Sp - 8] = block_cv0v_info;
           _suis::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _suis::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uv1v; else goto cv0w;
       uv1v: // global
           call _cv0v(R1) args: 0, res: 0, upd: 0;
       cv0w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv0v() //  [R1]
         { info_tbl: [(cv0v,
                       label: block_cv0v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv0v: // global
           _suis::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cv1l; else goto cv1q;
       cv1l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cv1o; else goto cv1n;
       cv1o: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cv1n: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suis::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cv1q: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cv1t; else goto cv1s;
       cv1t: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cv1s: // global
           I64[Hp - 112] = ds3_suix_info;
           _suip::P64 = P64[Sp + 16];
           P64[Hp - 96] = _suip::P64;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = stg_sel_0_upd_info;
           _cv0B::P64 = Hp - 112;
           P64[Hp - 64] = _cv0B::P64;
           I64[Hp - 56] = sat_suiF_info;
           P64[Hp - 40] = _suip::P64;
           P64[Hp - 32] = _suis::P64;
           P64[Hp - 24] = _cv0B::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.499544016 UTC

[section ""data" . GHC.List.scanrFB_closure" {
     GHC.List.scanrFB_closure:
         const GHC.List.scanrFB_info;
 },
 GHC.List.scanrFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cv1E,
                       label: GHC.List.scanrFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv1E: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cv1K; else goto cv1L;
       cv1K: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanrFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv1L: // global
           I64[Sp - 32] = block_cv1B_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uv1P; else goto cv1C;
       uv1P: // global
           call _cv1B(R1) args: 0, res: 0, upd: 0;
       cv1C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv1B() //  [R1]
         { info_tbl: [(cv1B,
                       label: block_cv1B_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv1B: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cv1O; else goto cv1N;
       cv1O: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cv1N: // global
           _suiP::P64 = P64[R1 + 7];
           _suiQ::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _suiP::P64;
           P64[Hp - 64] = _suiQ::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _suiP::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.501554946 UTC

[section ""data" . GHC.List.$wscanr_closure" {
     GHC.List.$wscanr_closure:
         const GHC.List.$wscanr_info;
 },
 ds_suiZ_entry() //  [R1]
         { info_tbl: [(cv28,
                       label: ds_suiZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv28: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cv29; else goto cv2a;
       cv29: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv2a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cv24_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cv24() //  [R1, R2]
         { info_tbl: [(cv24,
                       label: block_cv24_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv24: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cv2d; else goto cv2c;
       cv2d: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cv2c: // global
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_suj8_entry() //  [R1]
         { info_tbl: [(cv2k,
                       label: sat_suj8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv2k: // global
           _suj8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cv2l; else goto cv2m;
       cv2m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cv2o; else goto cv2n;
       cv2o: // global
           HpAlloc = 24;
           goto cv2l;
       cv2l: // global
           R1 = _suj8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv2n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suj8::P64;
           _suiT::P64 = P64[_suj8::P64 + 16];
           _suiX::P64 = P64[_suj8::P64 + 24];
           _suiZ::P64 = P64[_suj8::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _suiZ::P64;
           R3 = Hp - 16;
           R2 = _suiX::P64;
           R1 = _suiT::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanr_entry() //  [R2, R3, R4]
         { info_tbl: [(cv2t,
                       label: GHC.List.$wscanr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv2t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cv2u; else goto cv2v;
       cv2u: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv2v: // global
           I64[Sp - 24] = block_cv1U_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uv2B; else goto cv1V;
       uv2B: // global
           call _cv1U(R1) args: 0, res: 0, upd: 0;
       cv1V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv1U() //  [R1]
         { info_tbl: [(cv1U,
                       label: block_cv1U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv1U: // global
           _suiU::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cv2q; else goto cv2r;
       cv2q: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _suiU::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cv2r: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cv2A; else goto cv2z;
       cv2A: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cv2z: // global
           _suiX::P64 = P64[R1 + 6];
           _suiY::P64 = P64[R1 + 14];
           I64[Hp - 96] = ds_suiZ_info;
           _suiT::P64 = P64[Sp + 8];
           P64[Hp - 80] = _suiT::P64;
           P64[Hp - 72] = _suiU::P64;
           P64[Hp - 64] = _suiY::P64;
           I64[Hp - 56] = stg_sel_0_upd_info;
           _cv20::P64 = Hp - 96;
           P64[Hp - 40] = _cv20::P64;
           I64[Hp - 32] = sat_suj8_info;
           P64[Hp - 16] = _suiT::P64;
           P64[Hp - 8] = _suiX::P64;
           P64[Hp] = _cv20::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.504146929 UTC

[section ""data" . GHC.List.strictUncurryScanr_closure" {
     GHC.List.strictUncurryScanr_closure:
         const GHC.List.strictUncurryScanr_info;
 },
 GHC.List.strictUncurryScanr_entry() //  [R2, R3]
         { info_tbl: [(cv2J,
                       label: GHC.List.strictUncurryScanr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv2J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv2K; else goto cv2L;
       cv2K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.strictUncurryScanr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cv2L: // global
           I64[Sp - 16] = block_cv2G_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uv2P; else goto cv2H;
       uv2P: // global
           call _cv2G(R1) args: 0, res: 0, upd: 0;
       cv2H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv2G() //  [R1]
         { info_tbl: [(cv2G,
                       label: block_cv2G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv2G: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.scanr_closure" {
     GHC.List.scanr_closure:
         const GHC.List.scanr_info;
 },
 GHC.List.scanr_entry() //  [R2, R3, R4]
         { info_tbl: [(cv2X,
                       label: GHC.List.scanr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv2X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cv2Y; else goto cv2Z;
       cv2Y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv2Z: // global
           I64[Sp - 8] = block_cv2U_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cv2U() //  [R1, R2]
         { info_tbl: [(cv2U,
                       label: block_cv2U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv2U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cv32; else goto cv31;
       cv32: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cv31: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.505826538 UTC

[section ""data" . GHC.List.flipSeqScanl'_closure" {
     GHC.List.flipSeqScanl'_closure:
         const GHC.List.flipSeqScanl'_info;
 },
 GHC.List.flipSeqScanl'_entry() //  [R2, R3]
         { info_tbl: [(cv39,
                       label: GHC.List.flipSeqScanl'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv39: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv3a; else goto cv3b;
       cv3a: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqScanl'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cv3b: // global
           I64[Sp - 16] = block_cv37_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv37() //  []
         { info_tbl: [(cv37,
                       label: block_cv37_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv37: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.507061197 UTC

[section ""data" . GHC.List.scanlFB'_closure" {
     GHC.List.scanlFB'_closure:
         const GHC.List.scanlFB'_info;
 },
 GHC.List.scanlFB'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cv3k,
                       label: GHC.List.scanlFB'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv3k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cv3l; else goto cv3m;
       cv3l: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv3m: // global
           I64[Sp - 24] = block_cv3h_info;
           _sujs::P64 = R3;
           R3 = R4;
           _sujr::P64 = R2;
           R2 = R6;
           R1 = _sujr::P64;
           P64[Sp - 16] = _sujs::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv3h() //  [R1]
         { info_tbl: [(cv3h,
                       label: block_cv3h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv3h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cv3p; else goto cv3o;
       cv3p: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cv3o: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.508844798 UTC

[section ""data" . GHC.List.$wscanlGo'_closure" {
     GHC.List.$wscanlGo'_closure:
         const GHC.List.$wscanlGo'_info;
 },
 sat_sujJ_entry() //  [R1]
         { info_tbl: [(cv3H,
                       label: sat_sujJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv3H: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cv3I; else goto cv3J;
       cv3I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv3J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cv3A_info;
           _sujy::P64 = P64[R1 + 16];
           _sujB::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sujy::P64;
           P64[Sp - 24] = _sujB::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uv3Z; else goto cv3B;
       uv3Z: // global
           call _cv3A(R1) args: 0, res: 0, upd: 0;
       cv3B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cv3A() //  [R1]
         { info_tbl: [(cv3A,
                       label: block_cv3A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv3A: // global
           if (R1 & 7 == 1) goto cv3E; else goto cv3F;
       cv3E: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cv3F: // global
           I64[Sp] = block_cv3P_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           _sujE::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sujE::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cv3P() //  [R1]
         { info_tbl: [(cv3P,
                       label: block_cv3P_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv3P: // global
           _sujE::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cv3R_info;
           R4 = _sujE::P64;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanlGo'_entry(R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _cv3R() //  [R1, R2]
         { info_tbl: [(cv3R,
                       label: block_cv3R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv3R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cv3Y; else goto cv3X;
       cv3Y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cv3X: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanlGo'_entry() //  [R2, R3, R4]
         { info_tbl: [(cv40,
                       label: GHC.List.$wscanlGo'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv40: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cv41; else goto cv42;
       cv41: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv42: // global
           I64[Sp - 24] = block_cv3u_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv3u() //  [R1]
         { info_tbl: [(cv3u,
                       label: block_cv3u_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv3u: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cv45; else goto cv44;
       cv45: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cv44: // global
           I64[Hp - 32] = sat_sujJ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = Hp - 32;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.511458885 UTC

[section ""data" . GHC.List.scanl'_scanlGo'_closure" {
     GHC.List.scanl'_scanlGo'_closure:
         const GHC.List.scanl'_scanlGo'_info;
 },
 GHC.List.scanl'_scanlGo'_entry() //  [R2, R3, R4]
         { info_tbl: [(cv4d,
                       label: GHC.List.scanl'_scanlGo'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv4d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cv4e; else goto cv4f;
       cv4e: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl'_scanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv4f: // global
           I64[Sp - 8] = block_cv4a_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo'_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cv4a() //  [R1, R2]
         { info_tbl: [(cv4a,
                       label: block_cv4a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv4a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cv4i; else goto cv4h;
       cv4i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cv4h: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.513398752 UTC

[section ""data" . GHC.List.scanl'_closure" {
     GHC.List.scanl'_closure:
         const GHC.List.scanl'_info;
 },
 GHC.List.scanl'_entry() //  [R2, R3, R4]
         { info_tbl: [(cv4n,
                       label: GHC.List.scanl'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv4n: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl'_scanlGo'_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.514210316 UTC

[section ""data" . GHC.List.constScanl_closure" {
     GHC.List.constScanl_closure:
         const GHC.List.constScanl_info;
 },
 GHC.List.constScanl_entry() //  [R2, R3]
         { info_tbl: [(cv4u,
                       label: GHC.List.constScanl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv4u: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.515120905 UTC

[section ""data" . GHC.List.scanlFB_closure" {
     GHC.List.scanlFB_closure:
         const GHC.List.scanlFB_info;
 },
 GHC.List.scanlFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cv4D,
                       label: GHC.List.scanlFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv4D: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cv4H; else goto cv4G;
       cv4H: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv4G: // global
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R6;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R5;
           _cv4B::P64 = Hp - 64;
           P64[Hp] = _cv4B::P64;
           _sujR::P64 = R3;
           R3 = Hp - 24;
           R2 = _cv4B::P64;
           R1 = _sujR::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.516708773 UTC

[section ""data" . GHC.List.$wscanlGo_closure" {
     GHC.List.$wscanlGo_closure:
         const GHC.List.$wscanlGo_info;
 },
 sat_suk7_entry() //  [R1]
         { info_tbl: [(cv4X,
                       label: sat_suk7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv4X: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cv4Y; else goto cv4Z;
       cv4Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv4Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cv4Q_info;
           _sujX::P64 = P64[R1 + 16];
           _sujY::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sujX::P64;
           P64[Sp - 24] = _sujY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uv5f; else goto cv4R;
       uv5f: // global
           call _cv4Q(R1) args: 0, res: 0, upd: 0;
       cv4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cv4Q() //  [R1]
         { info_tbl: [(cv4Q,
                       label: block_cv4Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv4Q: // global
           if (R1 & 7 == 1) goto cv4U; else goto cv4V;
       cv4U: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cv4V: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cv5b; else goto cv5a;
       cv5b: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cv5a: // global
           _suk1::P64 = P64[R1 + 6];
           _suk2::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           _sujX::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sujX::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _suk1::P64;
           I64[Sp + 16] = block_cv56_info;
           R4 = _suk2::P64;
           R3 = Hp - 32;
           R2 = _sujX::P64;
           Sp = Sp + 16;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cv56() //  [R1, R2]
         { info_tbl: [(cv56,
                       label: block_cv56_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv56: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cv5e; else goto cv5d;
       cv5e: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cv5d: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanlGo_entry() //  [R2, R3, R4]
         { info_tbl: [(cv5g,
                       label: GHC.List.$wscanlGo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv5g: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cv5k; else goto cv5j;
       cv5k: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv5j: // global
           I64[Hp - 32] = sat_suk7_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.518804051 UTC

[section ""data" . GHC.List.scanl_scanlGo_closure" {
     GHC.List.scanl_scanlGo_closure:
         const GHC.List.scanl_scanlGo_info;
 },
 GHC.List.scanl_scanlGo_entry() //  [R2, R3, R4]
         { info_tbl: [(cv5s,
                       label: GHC.List.scanl_scanlGo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv5s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cv5t; else goto cv5u;
       cv5t: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl_scanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv5u: // global
           I64[Sp - 8] = block_cv5p_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cv5p() //  [R1, R2]
         { info_tbl: [(cv5p,
                       label: block_cv5p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv5p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cv5x; else goto cv5w;
       cv5x: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cv5w: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.519967545 UTC

[section ""data" . GHC.List.scanl_closure" {
     GHC.List.scanl_closure:
         const GHC.List.scanl_info;
 },
 GHC.List.scanl_entry() //  [R2, R3, R4]
         { info_tbl: [(cv5C,
                       label: GHC.List.scanl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv5C: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl_scanlGo_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.521208385 UTC

[section ""data" . GHC.List.scanl1_closure" {
     GHC.List.scanl1_closure:
         const GHC.List.scanl1_info;
 },
 sat_sukm_entry() //  [R1]
         { info_tbl: [(cv5V,
                       label: sat_sukm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv5V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cv5W; else goto cv5X;
       cv5W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv5X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cv5T_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cv5T() //  [R2]
         { info_tbl: [(cv5T,
                       label: block_cv5T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv5T: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.scanl1_entry() //  [R2, R3]
         { info_tbl: [(cv63,
                       label: GHC.List.scanl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv63: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv64; else goto cv65;
       cv64: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cv65: // global
           I64[Sp - 16] = block_cv5J_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uv6c; else goto cv5K;
       uv6c: // global
           call _cv5J(R1) args: 0, res: 0, upd: 0;
       cv5K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv5J() //  [R1]
         { info_tbl: [(cv5J,
                       label: block_cv5J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv5J: // global
           if (R1 & 7 == 1) goto cv60; else goto cv61;
       cv60: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cv61: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cv6b; else goto cv6a;
       cv6b: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cv6a: // global
           _sukh::P64 = P64[R1 + 6];
           _suki::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sukm_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sukh::P64;
           P64[Hp - 24] = _suki::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sukh::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.523474034 UTC

[section ""data" . GHC.List.foldl'_closure" {
     GHC.List.foldl'_closure:
         const GHC.List.foldl'_info;
 },
 GHC.List.foldl'_entry() //  [R2, R3, R4]
         { info_tbl: [(cv6j,
                       label: GHC.List.foldl'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv6j: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cv6k; else goto cv6l;
       cv6k: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv6l: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cv6n() args: 0, res: 0, upd: 0;
     }
 },
 _cv6n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv6n: // global
           I64[Sp - 8] = block_cv6p_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uv6M; else goto cv6r;
       uv6M: // global
           call _cv6p(R1) args: 0, res: 0, upd: 0;
       cv6r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv6p() //  [R1]
         { info_tbl: [(cv6p,
                       label: block_cv6p_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv6p: // global
           _suks::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cv6x; else goto cv6E;
       cv6x: // global
           R1 = _suks::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cv6E: // global
           I64[Sp] = block_cv6A_info;
           _suku::P64 = P64[R1 + 6];
           _sukv::P64 = P64[R1 + 14];
           R1 = _suks::P64;
           P64[Sp + 16] = _sukv::P64;
           P64[Sp + 24] = _suku::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv6A() //  [R1]
         { info_tbl: [(cv6A,
                       label: block_cv6A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv6A: // global
           I64[Sp] = block_cv6C_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           R1 = P64[Sp + 8];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv6C() //  [R1]
         { info_tbl: [(cv6C,
                       label: block_cv6C_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv6C: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cv6n() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.525221983 UTC

[section ""data" . GHC.List.foldl1'_closure" {
     GHC.List.foldl1'_closure:
         const GHC.List.foldl1'_info;
         const 0;
 },
 GHC.List.foldl1'_entry() //  [R2, R3]
         { info_tbl: [(cv6Z,
                       label: GHC.List.foldl1'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv6Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv70; else goto cv71;
       cv70: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cv71: // global
           I64[Sp - 16] = block_cv6S_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uv78; else goto cv6T;
       uv78: // global
           call _cv6S(R1) args: 0, res: 0, upd: 0;
       cv6T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv6S() //  [R1]
         { info_tbl: [(cv6S,
                       label: block_cv6S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv6S: // global
           if (R1 & 7 == 1) goto cv6W; else goto cv6X;
       cv6W: // global
           R1 = GHC.List.foldl1'1_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cv6X: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl'_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.526389156 UTC

[section ""data" . sat_sukD_closure" {
     sat_sukD_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.526932899 UTC

[section ""data" . sat_sukE_closure" {
     sat_sukE_closure:
         const :_con_info;
         const sat_sukD_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.52773901 UTC

[section ""data" . lvl29_ru9q_closure" {
     lvl29_ru9q_closure:
         const lvl29_ru9q_info;
         const 0;
         const 0;
         const 0;
 },
 lvl29_ru9q_entry() //  [R1]
         { info_tbl: [(cv7f,
                       label: lvl29_ru9q_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv7f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv7g; else goto cv7h;
       cv7g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv7h: // global
           (_cv7c::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cv7c::I64 == 0) goto cv7e; else goto cv7d;
       cv7e: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cv7d: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cv7c::I64;
           R3 = sat_sukE_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.529500164 UTC

[section ""data" . lvl30_ru9r_closure" {
     lvl30_ru9r_closure:
         const lvl30_ru9r_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_ru9r_entry() //  [R1]
         { info_tbl: [(cv7o,
                       label: lvl30_ru9r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv7o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv7p; else goto cv7q;
       cv7p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv7q: // global
           (_cv7l::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cv7l::I64 == 0) goto cv7n; else goto cv7m;
       cv7n: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cv7m: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cv7l::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.530883684 UTC

[section ""data" . GHC.List.foldl_closure" {
     GHC.List.foldl_closure:
         const GHC.List.foldl_info;
 },
 GHC.List.foldl_entry() //  [R2, R3, R4]
         { info_tbl: [(cv7H,
                       label: GHC.List.foldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv7H: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cv7I; else goto cv7J;
       cv7I: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv7J: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cv7y() args: 0, res: 0, upd: 0;
     }
 },
 _cv7y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv7y: // global
           I64[Sp - 8] = block_cv7A_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uv7W; else goto cv7B;
       uv7W: // global
           call _cv7A(R1) args: 0, res: 0, upd: 0;
       cv7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv7A() //  [R1]
         { info_tbl: [(cv7A,
                       label: block_cv7A_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv7A: // global
           _sukK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cv7O; else goto cv7P;
       cv7O: // global
           R1 = _sukK::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cv7P: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cv7S; else goto cv7R;
       cv7S: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cv7R: // global
           _sukM::P64 = P64[R1 + 6];
           _sukN::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sukK::P64;
           P64[Hp] = _sukM::P64;
           P64[Sp + 16] = _sukN::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call _cv7y() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.532590026 UTC

[section ""data" . GHC.List.sum_closure" {
     GHC.List.sum_closure:
         const GHC.List.sum_info;
         const 0;
 },
 sat_sukR_entry() //  [R1]
         { info_tbl: [(cv87,
                       label: sat_sukR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv87: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cv88; else goto cv89;
       cv88: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv89: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl30_ru9r_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sukQ_entry() //  [R1]
         { info_tbl: [(cv8e,
                       label: sat_sukQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv8e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv8f; else goto cv8g;
       cv8f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv8g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.sum_entry() //  [R2]
         { info_tbl: [(cv8h,
                       label: GHC.List.sum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv8h: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cv8l; else goto cv8k;
       cv8l: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.sum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cv8k: // global
           I64[Hp - 40] = sat_sukR_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sukQ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.534483148 UTC

[section ""data" . GHC.List.product_closure" {
     GHC.List.product_closure:
         const GHC.List.product_info;
         const 0;
 },
 sat_sukU_entry() //  [R1]
         { info_tbl: [(cv8u,
                       label: sat_sukU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv8u: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cv8v; else goto cv8w;
       cv8v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv8w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl29_ru9q_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sukT_entry() //  [R1]
         { info_tbl: [(cv8B,
                       label: sat_sukT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv8B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv8C; else goto cv8D;
       cv8C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv8D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.product_entry() //  [R2]
         { info_tbl: [(cv8E,
                       label: GHC.List.product_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv8E: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cv8I; else goto cv8H;
       cv8I: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.product_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cv8H: // global
           I64[Hp - 40] = sat_sukU_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sukT_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.536037885 UTC

[section ""data" . GHC.List.foldl1_closure" {
     GHC.List.foldl1_closure:
         const GHC.List.foldl1_info;
         const 0;
 },
 GHC.List.foldl1_entry() //  [R2, R3]
         { info_tbl: [(cv8U,
                       label: GHC.List.foldl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv8U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv8V; else goto cv8W;
       cv8V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cv8W: // global
           I64[Sp - 16] = block_cv8N_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uv93; else goto cv8O;
       uv93: // global
           call _cv8N(R1) args: 0, res: 0, upd: 0;
       cv8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv8N() //  [R1]
         { info_tbl: [(cv8N,
                       label: block_cv8N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv8N: // global
           if (R1 & 7 == 1) goto cv8R; else goto cv8S;
       cv8R: // global
           R1 = GHC.List.foldl2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cv8S: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.537430513 UTC

[section ""data" . GHC.List.filterFB_closure" {
     GHC.List.filterFB_closure:
         const GHC.List.filterFB_info;
 },
 GHC.List.filterFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cv9e,
                       label: GHC.List.filterFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv9e: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cv9f; else goto cv9g;
       cv9f: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filterFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cv9g: // global
           I64[Sp - 32] = block_cv98_info;
           _sul0::P64 = R2;
           R2 = R4;
           R1 = R3;
           P64[Sp - 24] = _sul0::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv98() //  [R1]
         { info_tbl: [(cv98,
                       label: block_cv98_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv98: // global
           _sul3::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cv9b; else goto cv9c;
       cv9b: // global
           R1 = _sul3::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cv9c: // global
           R3 = _sul3::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.539179325 UTC

[section ""data" . GHC.List.filter_closure" {
     GHC.List.filter_closure:
         const GHC.List.filter_info;
 },
 sat_sulb_entry() //  [R1]
         { info_tbl: [(cv9G,
                       label: sat_sulb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv9G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cv9H; else goto cv9I;
       cv9H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cv9I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.filter_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.filter_entry() //  [R2, R3]
         { info_tbl: [(cv9N,
                       label: GHC.List.filter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv9N: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cv9O; else goto uva3;
       cv9O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filter_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uva3: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cv9o() args: 0, res: 0, upd: 0;
     }
 },
 _cv9o() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv9o: // global
           I64[Sp - 8] = block_cv9r_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uva5; else goto cv9s;
       uva5: // global
           call _cv9r(R1) args: 0, res: 0, upd: 0;
       cv9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv9r() //  [R1]
         { info_tbl: [(cv9r,
                       label: block_cv9r_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv9r: // global
           if (R1 & 7 == 1) goto cv9K; else goto cv9L;
       cv9K: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cv9L: // global
           I64[Sp - 8] = block_cv9x_info;
           _sul8::P64 = P64[R1 + 6];
           R2 = _sul8::P64;
           _sul9::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sul9::P64;
           P64[Sp + 16] = _sul8::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cv9x() //  [R1]
         { info_tbl: [(cv9x,
                       label: block_cv9x_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cv9x: // global
           _sul5::P64 = P64[Sp + 16];
           _sul9::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cv9W; else goto cv9Y;
       cv9W: // global
           P64[Sp + 16] = _sul5::P64;
           P64[Sp + 24] = _sul9::P64;
           Sp = Sp + 16;
           call _cv9o() args: 0, res: 0, upd: 0;
       cv9Y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cva1; else goto cva0;
       cva1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cva0: // global
           I64[Hp - 48] = sat_sulb_info;
           P64[Hp - 32] = _sul5::P64;
           P64[Hp - 24] = _sul9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.541046952 UTC

[section ""data" . GHC.List.idLength_closure" {
     GHC.List.idLength_closure:
         const GHC.List.idLength_info;
 },
 GHC.List.idLength_entry() //  [R2]
         { info_tbl: [(cvac,
                       label: GHC.List.idLength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvac: // global
           R2 = R2;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.542107331 UTC

[section ""data" . GHC.List.lengthFB_closure" {
     GHC.List.lengthFB_closure:
         const GHC.List.lengthFB_info;
 },
 GHC.List.lengthFB_entry() //  [R2, R3, R4]
         { info_tbl: [(cvam,
                       label: GHC.List.lengthFB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvam: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvat; else goto cvau;
       cvat: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lengthFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvau: // global
           I64[Sp - 16] = block_cvaj_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvay; else goto cvak;
       uvay: // global
           call _cvaj(R1) args: 0, res: 0, upd: 0;
       cvak: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvaj() //  [R1]
         { info_tbl: [(cvaj,
                       label: block_cvaj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvaj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvax; else goto cvaw;
       cvax: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvaw: // global
           _sulh::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sulh::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.543575158 UTC

[section ""data" . GHC.List.$wlenAcc_closure" {
     GHC.List.$wlenAcc_closure:
         const GHC.List.$wlenAcc_info;
 },
 GHC.List.$wlenAcc_entry() //  [R2, R3]
         { info_tbl: [(cvaK,
                       label: GHC.List.$wlenAcc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvaK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvaL; else goto uvaU;
       cvaL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wlenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvaU: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvaA() args: 0, res: 0, upd: 0;
     }
 },
 _cvaA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvaA: // global
           _sulj::P64 = P64[Sp];
           I64[Sp] = block_cvaD_info;
           R1 = _sulj::P64;
           if (R1 & 7 != 0) goto uvaW; else goto cvaE;
       uvaW: // global
           call _cvaD(R1) args: 0, res: 0, upd: 0;
       cvaE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvaD() //  [R1]
         { info_tbl: [(cvaD,
                       label: block_cvaD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvaD: // global
           _sulk::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cvaH; else goto cvaI;
       cvaH: // global
           R1 = _sulk::I64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvaI: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _sulk::I64 + 1;
           call _cvaA() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.545727625 UTC

[section ""data" . GHC.List.lenAcc_closure" {
     GHC.List.lenAcc_closure:
         const GHC.List.lenAcc_info;
 },
 GHC.List.lenAcc_entry() //  [R2, R3]
         { info_tbl: [(cvb6,
                       label: GHC.List.lenAcc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvb6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvbe; else goto cvbf;
       cvbe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvbf: // global
           I64[Sp - 16] = block_cvb3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvbk; else goto cvb4;
       uvbk: // global
           call _cvb3(R1) args: 0, res: 0, upd: 0;
       cvb4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvb3() //  [R1]
         { info_tbl: [(cvb3,
                       label: block_cvb3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvb3: // global
           _sulp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cvb9_info;
           R3 = I64[R1 + 7];
           R2 = _sulp::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvb9() //  [R1]
         { info_tbl: [(cvb9,
                       label: block_cvb9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvb9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvbj; else goto cvbi;
       cvbj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cvbi: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.547088124 UTC

[section ""data" . GHC.List.length_closure" {
     GHC.List.length_closure:
         const GHC.List.length_info;
 },
 GHC.List.length_entry() //  [R2]
         { info_tbl: [(cvbr,
                       label: GHC.List.length_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvbr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvbv; else goto cvbw;
       cvbv: // global
           R2 = R2;
           R1 = GHC.List.length_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvbw: // global
           I64[Sp - 8] = block_cvbp_info;
           R3 = 0;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvbp() //  [R1]
         { info_tbl: [(cvbp,
                       label: block_cvbp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvbp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvbz; else goto cvby;
       cvbz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cvby: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.548272605 UTC

[section ""data" . GHC.List.null_closure" {
     GHC.List.null_closure:
         const GHC.List.null_info;
 },
 GHC.List.null_entry() //  [R2]
         { info_tbl: [(cvbL,
                       label: GHC.List.null_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvbL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvbM; else goto cvbN;
       cvbM: // global
           R2 = R2;
           R1 = GHC.List.null_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvbN: // global
           I64[Sp - 8] = block_cvbE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvbU; else goto cvbF;
       uvbU: // global
           call _cvbE(R1) args: 0, res: 0, upd: 0;
       cvbF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvbE() //  [R1]
         { info_tbl: [(cvbE,
                       label: block_cvbE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvbE: // global
           if (R1 & 7 == 1) goto cvbI; else goto cvbJ;
       cvbI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvbJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.549591862 UTC

[section ""data" . GHC.List.uncons_closure" {
     GHC.List.uncons_closure:
         const GHC.List.uncons_info;
 },
 GHC.List.uncons_entry() //  [R2]
         { info_tbl: [(cvc6,
                       label: GHC.List.uncons_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvc6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvc7; else goto cvc8;
       cvc7: // global
           R2 = R2;
           R1 = GHC.List.uncons_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvc8: // global
           I64[Sp - 8] = block_cvbZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvcj; else goto cvc0;
       uvcj: // global
           call _cvbZ(R1) args: 0, res: 0, upd: 0;
       cvc0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvbZ() //  [R1]
         { info_tbl: [(cvbZ,
                       label: block_cvbZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvbZ: // global
           if (R1 & 7 == 1) goto cvc3; else goto cvc4;
       cvc3: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvc4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvci; else goto cvch;
       cvci: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvch: // global
           _sulC::P64 = P64[R1 + 6];
           _sulD::P64 = P64[R1 + 14];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = _sulC::P64;
           P64[Hp - 16] = _sulD::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.550760388 UTC

[section ""relreadonly" . Supf_srt" {
     Supf_srt:
         const lvl1_ru8R_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.List.errorEmptyList_closure;
         const GHC.List.prel_list_str_closure;
         const lvl3_ru8T_closure;
         const GHC.List.!!2_closure;
         const GHC.List.!!1_closure;
         const poly_exit_ru8U_closure;
         const poly_$wgo_ru8V_closure;
         const GHC.List.negIndex_closure;
         const GHC.List.!!_closure;
         const GHC.List.$w!!_closure;
         const lvl5_ru8X_closure;
         const GHC.List.cycle_closure;
         const GHC.List.cycle1_closure;
         const lvl7_ru8Z_closure;
         const lvl8_ru90_closure;
         const GHC.List.foldr1_closure;
         const lvl10_ru92_closure;
         const GHC.List.init_closure;
         const GHC.List.init2_closure;
         const lvl12_ru94_closure;
         const GHC.List.lastError_closure;
         const lvl14_ru97_closure;
         const GHC.List.tail_closure;
         const GHC.List.scanl2_closure;
         const lvl16_ru99_closure;
         const GHC.List.head_closure;
         const GHC.List.badHead_closure;
         const lvl18_ru9b_closure;
         const GHC.List.maximum_$smaximum_closure;
         const GHC.List.maximum1_closure;
         const lvl21_ru9e_closure;
         const GHC.List.minimum_$sminimum_closure;
         const GHC.List.minimum1_closure;
         const GHC.List.maximum_$smaximum1_closure;
         const GHC.List.maximum2_closure;
         const GHC.List.maximum_closure;
         const lvl19_ru9c_closure;
         const GHC.List.minimum_$sminimum1_closure;
         const GHC.List.minimum2_closure;
         const GHC.List.minimum_closure;
         const lvl22_ru9f_closure;
         const lvl24_ru9h_closure;
         const GHC.List.errorEmptyList_closure;
         const lvl26_ru9j_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.List.scanr1_closure;
         const lvl28_ru9p_closure;
         const GHC.List.foldl1'_closure;
         const GHC.List.foldl1'1_closure;
         const sat_sukE_closure;
         const lvl30_ru9r_closure;
         const GHC.List.sum_closure;
         const lvl29_ru9q_closure;
         const GHC.List.product_closure;
         const GHC.List.foldl1_closure;
         const GHC.List.foldl2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.551607558 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:06.552546046 UTC

[section ""data" . $wunsafeDrop_ru8P_closure" {
     $wunsafeDrop_ru8P_closure:
         const $wunsafeDrop_ru8P_info;
 },
 $wunsafeDrop_ru8P_entry() //  [R2, R3]
         { info_tbl: [(cvcv,
                       label: $wunsafeDrop_ru8P_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvcv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvcw; else goto uvcK;
       cvcw: // global
           R3 = R3;
           R2 = R2;
           R1 = $wunsafeDrop_ru8P_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvcK: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvcl() args: 0, res: 0, upd: 0;
     }
 },
 _cvcl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvcl: // global
           I64[Sp - 8] = block_cvco_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvcM; else goto cvcp;
       uvcM: // global
           call _cvco(R1) args: 0, res: 0, upd: 0;
       cvcp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvco() //  [R1]
         { info_tbl: [(cvco,
                       label: block_cvco_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvco: // global
           if (R1 & 7 == 1) goto cvcs; else goto cvct;
       cvcs: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvct: // global
           _su9x::P64 = P64[R1 + 14];
           _su9y::I64 = I64[Sp + 8];
           if (_su9y::I64 != 1) goto cvcG; else goto cvcH;
       cvcG: // global
           I64[Sp + 8] = _su9y::I64 - 1;
           P64[Sp + 16] = _su9x::P64;
           Sp = Sp + 8;
           call _cvcl() args: 0, res: 0, upd: 0;
       cvcH: // global
           R1 = _su9x::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.554090825 UTC

[section ""data" . GHC.List.drop_closure" {
     GHC.List.drop_closure:
         const GHC.List.drop_info;
 },
 GHC.List.drop_entry() //  [R2, R3]
         { info_tbl: [(cvcW,
                       label: GHC.List.drop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvcW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvcX; else goto cvcY;
       cvcX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.drop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvcY: // global
           I64[Sp - 16] = block_cvcT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvd7; else goto cvcU;
       uvd7: // global
           call _cvcT(R1) args: 0, res: 0, upd: 0;
       cvcU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvcT() //  [R1]
         { info_tbl: [(cvcT,
                       label: block_cvcT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvcT: // global
           _su9B::P64 = P64[Sp + 8];
           _su9D::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_su9D::I64, 0)) goto cvd5; else goto cvd6;
       cvd5: // global
           R3 = _su9B::P64;
           R2 = _su9D::I64;
           Sp = Sp + 16;
           call $wunsafeDrop_ru8P_entry(R3, R2) args: 8, res: 0, upd: 8;
       cvd6: // global
           R1 = _su9B::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.555981654 UTC

[section ""data" . GHC.List.$wsplitAt'_closure" {
     GHC.List.$wsplitAt'_closure:
         const GHC.List.$wsplitAt'_info;
 },
 ds2_su9N_entry() //  [R1]
         { info_tbl: [(cvdv,
                       label: ds2_su9N_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvdv: // global
           _su9N::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cvdB; else goto cvdC;
       cvdC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvdE; else goto cvdD;
       cvdE: // global
           HpAlloc = 16;
           goto cvdB;
       cvdB: // global
           R1 = _su9N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvdD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _su9N::P64;
           _su9J::P64 = P64[_su9N::P64 + 16];
           _su9O::I64 = I64[_su9N::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _su9O::I64;
           I64[Sp - 24] = block_cvdy_info;
           R3 = _su9J::P64;
           R2 = Hp - 7;
           Sp = Sp - 24;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvdy() //  [R1, R2]
         { info_tbl: [(cvdy,
                       label: block_cvdy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvdy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvdH; else goto cvdG;
       cvdH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cvdG: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wsplitAt'_entry() //  [R2, R3]
         { info_tbl: [(cvdM,
                       label: GHC.List.$wsplitAt'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvdM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvdN; else goto cvdO;
       cvdN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wsplitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvdO: // global
           I64[Sp - 16] = block_cvdc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uve4; else goto cvdd;
       uve4: // global
           call _cvdc(R1) args: 0, res: 0, upd: 0;
       cvdd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvdc() //  [R1]
         { info_tbl: [(cvdc,
                       label: block_cvdc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvdc: // global
           if (R1 & 7 == 1) goto cvdJ; else goto cvdK;
       cvdJ: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cvdK: // global
           I64[Sp - 8] = block_cvdi_info;
           _su9I::P64 = P64[R1 + 6];
           _su9J::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _su9J::P64;
           P64[Sp + 8] = _su9I::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uve3; else goto cvdj;
       uve3: // global
           call _cvdi(R1) args: 0, res: 0, upd: 0;
       cvdj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvdi() //  [R1]
         { info_tbl: [(cvdi,
                       label: block_cvdi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvdi: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cvdU; else goto cvdT;
       cvdU: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvdT: // global
           _su9I::P64 = P64[Sp + 16];
           _su9J::P64 = P64[Sp + 8];
           _su9M::I64 = I64[R1 + 7];
           if (_su9M::I64 != 1) goto cvdZ; else goto cve2;
       cvdZ: // global
           I64[Hp - 96] = ds2_su9N_info;
           P64[Hp - 80] = _su9J::P64;
           I64[Hp - 72] = _su9M::I64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cvdp::P64 = Hp - 96;
           P64[Hp - 48] = _cvdp::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cvdp::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _su9I::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cve2: // global
           I64[Hp - 96] = :_con_info;
           P64[Hp - 88] = _su9I::P64;
           P64[Hp - 80] = GHC.Types.[]_closure+1;
           _cve1::P64 = Hp - 94;
           Hp = Hp - 80;
           R2 = _su9J::P64;
           R1 = _cve1::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.558806647 UTC

[section ""data" . GHC.List.splitAt_splitAt'_closure" {
     GHC.List.splitAt_splitAt'_closure:
         const GHC.List.splitAt_splitAt'_info;
 },
 GHC.List.splitAt_splitAt'_entry() //  [R2, R3]
         { info_tbl: [(cvec,
                       label: GHC.List.splitAt_splitAt'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvec: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cved; else goto cvee;
       cved: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_splitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvee: // global
           I64[Sp - 8] = block_cve9_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cve9() //  [R1, R2]
         { info_tbl: [(cve9,
                       label: block_cve9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cve9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cveh; else goto cveg;
       cveh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cveg: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.560303844 UTC

[section ""data" . GHC.List.splitAt_closure" {
     GHC.List.splitAt_closure:
         const GHC.List.splitAt_info;
 },
 GHC.List.splitAt_entry() //  [R2, R3]
         { info_tbl: [(cvep,
                       label: GHC.List.splitAt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvep: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cveq; else goto cver;
       cveq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cver: // global
           I64[Sp - 16] = block_cvem_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uveL; else goto cven;
       uveL: // global
           call _cvem(R1) args: 0, res: 0, upd: 0;
       cven: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvem() //  [R1]
         { info_tbl: [(cvem,
                       label: block_cvem_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvem: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvew; else goto cvev;
       cvew: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvev: // global
           _sua9::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto cveE; else goto cveK;
       cveE: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_cveA_info;
           R3 = _sua9::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
       cveK: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = _sua9::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cveA() //  [R1, R2]
         { info_tbl: [(cveA,
                       label: block_cveA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cveA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cveH; else goto cveG;
       cveH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cveG: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.562441003 UTC

[section ""cstring" . GHC.List.$trModule4_bytes" {
     GHC.List.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.562988421 UTC

[section ""data" . GHC.List.$trModule3_closure" {
     GHC.List.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.563543897 UTC

[section ""cstring" . GHC.List.$trModule2_bytes" {
     GHC.List.$trModule2_bytes:
         I8[] [71,72,67,46,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.5640916 UTC

[section ""data" . GHC.List.$trModule1_closure" {
     GHC.List.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.564613496 UTC

[section ""data" . GHC.List.$trModule_closure" {
     GHC.List.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.List.$trModule3_closure+1;
         const GHC.List.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.565786714 UTC

[section ""data" . GHC.List.init1_closure" {
     GHC.List.init1_closure:
         const GHC.List.init1_info;
 },
 sat_sual_entry() //  [R1]
         { info_tbl: [(cvf0,
                       label: sat_sual_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvf0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvf1; else goto cvf2;
       cvf1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvf2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.init1_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.init1_entry() //  [R2, R3]
         { info_tbl: [(cvf7,
                       label: GHC.List.init1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvf7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvf8; else goto cvf9;
       cvf8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.init1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvf9: // global
           I64[Sp - 16] = block_cveQ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvfg; else goto cveR;
       uvfg: // global
           call _cveQ(R1) args: 0, res: 0, upd: 0;
       cveR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cveQ() //  [R1]
         { info_tbl: [(cveQ,
                       label: block_cveQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cveQ: // global
           if (R1 & 7 == 1) goto cvf4; else goto cvf5;
       cvf4: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvf5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cvff; else goto cvfe;
       cvff: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvfe: // global
           _suaj::P64 = P64[R1 + 6];
           _suak::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sual_info;
           P64[Hp - 32] = _suaj::P64;
           P64[Hp - 24] = _suak::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.567200027 UTC

[section ""cstring" . lvl_ru8Q_bytes" {
     lvl_ru8Q_bytes:
         I8[] [58,32,101,109,112,116,121,32,108,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.567918166 UTC

[section ""data" . lvl1_ru8R_closure" {
     lvl1_ru8R_closure:
         const lvl1_ru8R_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ru8R_entry() //  [R1]
         { info_tbl: [(cvfn,
                       label: lvl1_ru8R_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvfn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvfo; else goto cvfp;
       cvfo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvfp: // global
           (_cvfk::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvfk::I64 == 0) goto cvfm; else goto cvfl;
       cvfm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvfl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvfk::I64;
           R2 = lvl_ru8Q_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.568801559 UTC

[section ""cstring" . GHC.List.!!4_bytes" {
     GHC.List.!!4_bytes:
         I8[] [80,114,101,108,117,100,101,46]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.569741143 UTC

[section ""data" . GHC.List.prel_list_str_closure" {
     GHC.List.prel_list_str_closure:
         const GHC.List.prel_list_str_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.prel_list_str_entry() //  [R1]
         { info_tbl: [(cvfw,
                       label: GHC.List.prel_list_str_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvfw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvfx; else goto cvfy;
       cvfx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvfy: // global
           (_cvft::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvft::I64 == 0) goto cvfv; else goto cvfu;
       cvfv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvfu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvft::I64;
           R2 = GHC.List.!!4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.570875187 UTC

[section ""data" . GHC.List.errorEmptyList_closure" {
     GHC.List.errorEmptyList_closure:
         const GHC.List.errorEmptyList_info;
         const 0;
 },
 sat_suan_entry() //  [R1]
         { info_tbl: [(cvfH,
                       label: sat_suan_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvfH: // global
           R3 = lvl1_ru8R_closure;
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.errorEmptyList_entry() //  [R2]
         { info_tbl: [(cvfM,
                       label: GHC.List.errorEmptyList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvfM: // global
           _suam::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cvfN; else goto cvfO;
       cvfO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvfQ; else goto cvfP;
       cvfQ: // global
           HpAlloc = 24;
           goto cvfN;
       cvfN: // global
           R2 = _suam::P64;
           R1 = GHC.List.errorEmptyList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvfP: // global
           I64[Hp - 16] = sat_suan_info;
           P64[Hp] = _suam::P64;
           I64[Sp - 8] = block_cvfK_info;
           R3 = Hp - 16;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvfK() //  [R1]
         { info_tbl: [(cvfK,
                       label: block_cvfK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvfK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.572039544 UTC

[section ""cstring" . lvl2_ru8S_bytes" {
     lvl2_ru8S_bytes:
         I8[] [33,33,58,32,110,101,103,97,116,105,118,101,32,105,110,100,101,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.572737551 UTC

[section ""data" . lvl3_ru8T_closure" {
     lvl3_ru8T_closure:
         const lvl3_ru8T_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_ru8T_entry() //  [R1]
         { info_tbl: [(cvg0,
                       label: lvl3_ru8T_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvg0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvg1; else goto cvg2;
       cvg1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvg2: // global
           (_cvfX::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvfX::I64 == 0) goto cvfZ; else goto cvfY;
       cvfZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvfY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvfX::I64;
           R2 = lvl2_ru8S_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.573852437 UTC

[section ""data" . GHC.List.negIndex_closure" {
     GHC.List.negIndex_closure:
         const GHC.List.negIndex_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.negIndex_entry() //  [R1]
         { info_tbl: [(cvgb,
                       label: GHC.List.negIndex_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvgb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvgc; else goto cvgd;
       cvgc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvgd: // global
           (_cvg6::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvg6::I64 == 0) goto cvg8; else goto cvg7;
       cvg8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvg7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvg6::I64;
           I64[Sp - 24] = block_cvg9_info;
           R3 = lvl3_ru8T_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvg9() //  [R1]
         { info_tbl: [(cvg9,
                       label: block_cvg9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvg9: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.574897893 UTC

[section ""cstring" . GHC.List.!!3_bytes" {
     GHC.List.!!3_bytes:
         I8[] [33,33,58,32,105,110,100,101,120,32,116,111,111,32,108,97,114,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.576232724 UTC

[section ""data" . GHC.List.!!2_closure" {
     GHC.List.!!2_closure:
         const GHC.List.!!2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!2_entry() //  [R1]
         { info_tbl: [(cvgn,
                       label: GHC.List.!!2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvgn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvgo; else goto cvgp;
       cvgo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvgp: // global
           (_cvgk::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvgk::I64 == 0) goto cvgm; else goto cvgl;
       cvgm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvgl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvgk::I64;
           R2 = GHC.List.!!3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.577300244 UTC

[section ""data" . GHC.List.!!1_closure" {
     GHC.List.!!1_closure:
         const GHC.List.!!1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!1_entry() //  [R1]
         { info_tbl: [(cvgw,
                       label: GHC.List.!!1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvgw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvgx; else goto cvgy;
       cvgx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvgy: // global
           (_cvgt::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvgt::I64 == 0) goto cvgv; else goto cvgu;
       cvgv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvgu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvgt::I64;
           R3 = GHC.List.!!2_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.578277307 UTC

[section ""data" . GHC.List.tooLarge_closure" {
     GHC.List.tooLarge_closure:
         const GHC.List.tooLarge_info;
         const 0;
 },
 GHC.List.tooLarge_entry() //  []
         { info_tbl: [(cvgD,
                       label: GHC.List.tooLarge_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvgD: // global
           R2 = GHC.List.!!1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.579130434 UTC

[section ""data" . poly_exit_ru8U_closure" {
     poly_exit_ru8U_closure:
         const poly_exit_ru8U_info;
         const 0;
         const 0;
         const 0;
 },
 poly_exit_ru8U_entry() //  [R1]
         { info_tbl: [(cvgM,
                       label: poly_exit_ru8U_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvgM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvgN; else goto cvgO;
       cvgN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvgO: // global
           (_cvgJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvgJ::I64 == 0) goto cvgL; else goto cvgK;
       cvgL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvgK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvgJ::I64;
           R2 = GHC.List.!!1_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.580426855 UTC

[section ""data" . poly_$wgo_ru8V_closure" {
     poly_$wgo_ru8V_closure:
         const poly_$wgo_ru8V_info;
         const 0;
 },
 poly_$wgo_ru8V_entry() //  [R2, R3]
         { info_tbl: [(cvh0,
                       label: poly_$wgo_ru8V_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvh0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvh1; else goto uvhf;
       cvh1: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_$wgo_ru8V_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvhf: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvgQ() args: 0, res: 0, upd: 0;
     }
 },
 _cvgQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvgQ: // global
           _suar::P64 = P64[Sp];
           I64[Sp] = block_cvgT_info;
           R1 = _suar::P64;
           if (R1 & 7 != 0) goto uvhh; else goto cvgU;
       uvhh: // global
           call _cvgT(R1) args: 0, res: 0, upd: 0;
       cvgU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvgT() //  [R1]
         { info_tbl: [(cvgT,
                       label: block_cvgT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvgT: // global
           if (R1 & 7 == 1) goto cvgX; else goto cvgY;
       cvgX: // global
           R1 = poly_exit_ru8U_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvgY: // global
           _suaw::I64 = I64[Sp + 8];
           if (_suaw::I64 != 0) goto cvhb; else goto cvhc;
       cvhb: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _suaw::I64 - 1;
           call _cvgQ() args: 0, res: 0, upd: 0;
       cvhc: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.582114777 UTC

[section ""data" . GHC.List.$w!!_closure" {
     GHC.List.$w!!_closure:
         const GHC.List.$w!!_info;
         const 0;
 },
 GHC.List.$w!!_entry() //  [R2, R3]
         { info_tbl: [(cvht,
                       label: GHC.List.$w!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvht: // global
           if (%MO_S_Ge_W64(R3, 0)) goto cvhr; else goto cvhs;
       cvhr: // global
           R3 = R3;
           R2 = R2;
           call poly_$wgo_ru8V_entry(R3, R2) args: 8, res: 0, upd: 8;
       cvhs: // global
           R1 = GHC.List.negIndex_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.583099988 UTC

[section ""data" . GHC.List.!!_closure" {
     GHC.List.!!_closure:
         const GHC.List.!!_info;
         const 0;
 },
 GHC.List.!!_entry() //  [R2, R3]
         { info_tbl: [(cvhD,
                       label: GHC.List.!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvhD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvhE; else goto cvhF;
       cvhE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.!!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvhF: // global
           I64[Sp - 16] = block_cvhA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvhJ; else goto cvhB;
       uvhJ: // global
           call _cvhA(R1) args: 0, res: 0, upd: 0;
       cvhB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvhA() //  [R1]
         { info_tbl: [(cvhA,
                       label: block_cvhA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvhA: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$w!!_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.584098894 UTC

[section ""cstring" . lvl4_ru8W_bytes" {
     lvl4_ru8W_bytes:
         I8[] [99,121,99,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.584861693 UTC

[section ""data" . lvl5_ru8X_closure" {
     lvl5_ru8X_closure:
         const lvl5_ru8X_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_ru8X_entry() //  [R1]
         { info_tbl: [(cvhQ,
                       label: lvl5_ru8X_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvhQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvhR; else goto cvhS;
       cvhR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvhS: // global
           (_cvhN::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvhN::I64 == 0) goto cvhP; else goto cvhO;
       cvhP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvhO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvhN::I64;
           R2 = lvl4_ru8W_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.58591268 UTC

[section ""data" . GHC.List.cycle1_closure" {
     GHC.List.cycle1_closure:
         const GHC.List.cycle1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.cycle1_entry() //  [R1]
         { info_tbl: [(cvhZ,
                       label: GHC.List.cycle1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvhZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvi0; else goto cvi1;
       cvi0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvi1: // global
           (_cvhW::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvhW::I64 == 0) goto cvhY; else goto cvhX;
       cvhY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvhX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvhW::I64;
           R2 = lvl5_ru8X_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.587227925 UTC

[section ""data" . GHC.List.cycle_closure" {
     GHC.List.cycle_closure:
         const GHC.List.cycle_info;
         const 0;
 },
 xs'_suaJ_entry() //  [R1]
         { info_tbl: [(cvig,
                       label: xs'_suaJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvig: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvih; else goto cvii;
       cvih: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvii: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.cycle_entry() //  [R2]
         { info_tbl: [(cvin,
                       label: GHC.List.cycle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvin: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvio; else goto cvip;
       cvio: // global
           R2 = R2;
           R1 = GHC.List.cycle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvip: // global
           I64[Sp - 8] = block_cvi6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uviv; else goto cvi7;
       uviv: // global
           call _cvi6(R1) args: 0, res: 0, upd: 0;
       cvi7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvi6() //  [R1]
         { info_tbl: [(cvi6,
                       label: block_cvi6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvi6: // global
           if (R1 & 7 == 1) goto cvik; else goto cvil;
       cvik: // global
           R1 = GHC.List.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvil: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cviu; else goto cvit;
       cviu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvit: // global
           I64[Hp - 16] = xs'_suaJ_info;
           P64[Hp] = R1;
           R1 = (Hp + -16) & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.588572304 UTC

[section ""cstring" . lvl6_ru8Y_bytes" {
     lvl6_ru8Y_bytes:
         I8[] [102,111,108,100,114,49]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.589291167 UTC

[section ""data" . lvl7_ru8Z_closure" {
     lvl7_ru8Z_closure:
         const lvl7_ru8Z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_ru8Z_entry() //  [R1]
         { info_tbl: [(cviC,
                       label: lvl7_ru8Z_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cviC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cviD; else goto cviE;
       cviD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cviE: // global
           (_cviz::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cviz::I64 == 0) goto cviB; else goto cviA;
       cviB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cviA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cviz::I64;
           R2 = lvl6_ru8Y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.590355706 UTC

[section ""data" . lvl8_ru90_closure" {
     lvl8_ru90_closure:
         const lvl8_ru90_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_ru90_entry() //  [R1]
         { info_tbl: [(cviL,
                       label: lvl8_ru90_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cviL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cviM; else goto cviN;
       cviM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cviN: // global
           (_cviI::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cviI::I64 == 0) goto cviK; else goto cviJ;
       cviK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cviJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cviI::I64;
           R2 = lvl7_ru8Z_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.592589485 UTC

[section ""data" . GHC.List.foldr1_closure" {
     GHC.List.foldr1_closure:
         const GHC.List.foldr1_info;
         const 0;
 },
 go2_suaM_entry() //  [R1, R2]
         { info_tbl: [(cvj4,
                       label: go2_suaM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvj4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvj5; else goto cvj6;
       cvj5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvj6: // global
           I64[Sp - 24] = block_cviX_info;
           _suaM::P64 = R1;
           _suaK::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _suaK::P64;
           P64[Sp - 8] = _suaM::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uvju; else goto cviY;
       uvju: // global
           call _cviX(R1) args: 0, res: 0, upd: 0;
       cviY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cviX() //  [R1]
         { info_tbl: [(cviX,
                       label: block_cviX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cviX: // global
           if (R1 & 7 == 1) goto cvj1; else goto cvj2;
       cvj1: // global
           R1 = lvl8_ru90_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvj2: // global
           I64[Sp - 8] = block_cvjc_info;
           _suaP::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _suaP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvjt; else goto cvje;
       uvjt: // global
           call _cvjc(R1) args: 0, res: 0, upd: 0;
       cvje: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvjc() //  [R1]
         { info_tbl: [(cvjc,
                       label: block_cvjc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvjc: // global
           _suaP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cvjk; else goto cvjo;
       cvjk: // global
           R1 = _suaP::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvjo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvjr; else goto cvjq;
       cvjr: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvjq: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = _suaP::P64;
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.foldr1_entry() //  [R2, R3]
         { info_tbl: [(cvjv,
                       label: GHC.List.foldr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvjv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvjz; else goto cvjy;
       cvjz: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvjy: // global
           I64[Hp - 8] = go2_suaM_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_suaM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.594589426 UTC

[section ""cstring" . lvl9_ru91_bytes" {
     lvl9_ru91_bytes:
         I8[] [105,110,105,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.595274893 UTC

[section ""data" . lvl10_ru92_closure" {
     lvl10_ru92_closure:
         const lvl10_ru92_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ru92_entry() //  [R1]
         { info_tbl: [(cvjG,
                       label: lvl10_ru92_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvjG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvjH; else goto cvjI;
       cvjH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvjI: // global
           (_cvjD::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvjD::I64 == 0) goto cvjF; else goto cvjE;
       cvjF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvjE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvjD::I64;
           R2 = lvl9_ru91_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.596292968 UTC

[section ""data" . GHC.List.init2_closure" {
     GHC.List.init2_closure:
         const GHC.List.init2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.init2_entry() //  [R1]
         { info_tbl: [(cvjP,
                       label: GHC.List.init2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvjP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvjQ; else goto cvjR;
       cvjQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvjR: // global
           (_cvjM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvjM::I64 == 0) goto cvjO; else goto cvjN;
       cvjO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvjN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvjM::I64;
           R2 = lvl10_ru92_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.597478096 UTC

[section ""data" . GHC.List.init_closure" {
     GHC.List.init_closure:
         const GHC.List.init_info;
         const 0;
 },
 GHC.List.init_entry() //  [R2]
         { info_tbl: [(cvk3,
                       label: GHC.List.init_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvk3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvk4; else goto cvk5;
       cvk4: // global
           R2 = R2;
           R1 = GHC.List.init_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvk5: // global
           I64[Sp - 8] = block_cvjW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvkc; else goto cvjX;
       uvkc: // global
           call _cvjW(R1) args: 0, res: 0, upd: 0;
       cvjX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvjW() //  [R1]
         { info_tbl: [(cvjW,
                       label: block_cvjW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvjW: // global
           if (R1 & 7 == 1) goto cvk0; else goto cvk1;
       cvk0: // global
           R1 = GHC.List.init2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvk1: // global
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.List.init1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.59850957 UTC

[section ""cstring" . lvl11_ru93_bytes" {
     lvl11_ru93_bytes:
         I8[] [108,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.599197955 UTC

[section ""data" . lvl12_ru94_closure" {
     lvl12_ru94_closure:
         const lvl12_ru94_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ru94_entry() //  [R1]
         { info_tbl: [(cvkj,
                       label: lvl12_ru94_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvkj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvkk; else goto cvkl;
       cvkk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvkl: // global
           (_cvkg::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvkg::I64 == 0) goto cvki; else goto cvkh;
       cvki: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvkh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvkg::I64;
           R2 = lvl11_ru93_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.600215912 UTC

[section ""data" . GHC.List.lastError_closure" {
     GHC.List.lastError_closure:
         const GHC.List.lastError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.lastError_entry() //  [R1]
         { info_tbl: [(cvks,
                       label: GHC.List.lastError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvks: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvkt; else goto cvku;
       cvkt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvku: // global
           (_cvkp::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvkp::I64 == 0) goto cvkr; else goto cvkq;
       cvkr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvkq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvkp::I64;
           R2 = lvl12_ru94_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.601458993 UTC

[section ""data" . poly_go_ru95_closure" {
     poly_go_ru95_closure:
         const poly_go_ru95_info;
 },
 poly_go_ru95_entry() //  [R2, R3]
         { info_tbl: [(cvkG,
                       label: poly_go_ru95_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvkG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvkH; else goto uvkP;
       cvkH: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_go_ru95_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvkP: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvkw() args: 0, res: 0, upd: 0;
     }
 },
 _cvkw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvkw: // global
           _suaZ::P64 = P64[Sp];
           I64[Sp] = block_cvkz_info;
           R1 = _suaZ::P64;
           if (R1 & 7 != 0) goto uvkR; else goto cvkA;
       uvkR: // global
           call _cvkz(R1) args: 0, res: 0, upd: 0;
       cvkA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvkz() //  [R1]
         { info_tbl: [(cvkz,
                       label: block_cvkz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvkz: // global
           if (R1 & 7 == 1) goto cvkD; else goto cvkE;
       cvkD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvkE: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cvkw() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.602704104 UTC

[section ""data" . GHC.List.last_closure" {
     GHC.List.last_closure:
         const GHC.List.last_info;
         const 0;
 },
 GHC.List.last_entry() //  [R2]
         { info_tbl: [(cvkY,
                       label: GHC.List.last_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvkY: // global
           R3 = GHC.List.lastError_closure;
           R2 = R2;
           call poly_go_ru95_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.603408546 UTC

[section ""cstring" . lvl13_ru96_bytes" {
     lvl13_ru96_bytes:
         I8[] [116,97,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.604119173 UTC

[section ""data" . lvl14_ru97_closure" {
     lvl14_ru97_closure:
         const lvl14_ru97_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ru97_entry() //  [R1]
         { info_tbl: [(cvl7,
                       label: lvl14_ru97_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvl7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvl8; else goto cvl9;
       cvl8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvl9: // global
           (_cvl4::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvl4::I64 == 0) goto cvl6; else goto cvl5;
       cvl6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvl5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvl4::I64;
           R2 = lvl13_ru96_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.605133268 UTC

[section ""data" . GHC.List.scanl2_closure" {
     GHC.List.scanl2_closure:
         const GHC.List.scanl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.scanl2_entry() //  [R1]
         { info_tbl: [(cvlg,
                       label: GHC.List.scanl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvlg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvlh; else goto cvli;
       cvlh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvli: // global
           (_cvld::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvld::I64 == 0) goto cvlf; else goto cvle;
       cvlf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvle: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvld::I64;
           R2 = lvl14_ru97_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.606541606 UTC

[section ""data" . GHC.List.tail_closure" {
     GHC.List.tail_closure:
         const GHC.List.tail_info;
         const 0;
 },
 GHC.List.tail_entry() //  [R2]
         { info_tbl: [(cvlu,
                       label: GHC.List.tail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvlu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvlv; else goto cvlw;
       cvlv: // global
           R2 = R2;
           R1 = GHC.List.tail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvlw: // global
           I64[Sp - 8] = block_cvln_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvlD; else goto cvlo;
       uvlD: // global
           call _cvln(R1) args: 0, res: 0, upd: 0;
       cvlo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvln() //  [R1]
         { info_tbl: [(cvln,
                       label: block_cvln_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvln: // global
           if (R1 & 7 == 1) goto cvlr; else goto cvls;
       cvlr: // global
           R1 = GHC.List.scanl2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvls: // global
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.608226418 UTC

[section ""cstring" . lvl15_ru98_bytes" {
     lvl15_ru98_bytes:
         I8[] [104,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.6089731 UTC

[section ""data" . lvl16_ru99_closure" {
     lvl16_ru99_closure:
         const lvl16_ru99_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_ru99_entry() //  [R1]
         { info_tbl: [(cvlK,
                       label: lvl16_ru99_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvlK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvlL; else goto cvlM;
       cvlL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvlM: // global
           (_cvlH::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvlH::I64 == 0) goto cvlJ; else goto cvlI;
       cvlJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvlI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvlH::I64;
           R2 = lvl15_ru98_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.610020381 UTC

[section ""data" . GHC.List.badHead_closure" {
     GHC.List.badHead_closure:
         const GHC.List.badHead_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.badHead_entry() //  [R1]
         { info_tbl: [(cvlT,
                       label: GHC.List.badHead_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvlT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvlU; else goto cvlV;
       cvlU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvlV: // global
           (_cvlQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvlQ::I64 == 0) goto cvlS; else goto cvlR;
       cvlS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvlR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvlQ::I64;
           R2 = lvl16_ru99_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.611149213 UTC

[section ""data" . GHC.List.head_closure" {
     GHC.List.head_closure:
         const GHC.List.head_info;
         const 0;
 },
 GHC.List.head_entry() //  [R2]
         { info_tbl: [(cvm7,
                       label: GHC.List.head_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvm7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvm8; else goto cvm9;
       cvm8: // global
           R2 = R2;
           R1 = GHC.List.head_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvm9: // global
           I64[Sp - 8] = block_cvm0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvmg; else goto cvm1;
       uvmg: // global
           call _cvm0(R1) args: 0, res: 0, upd: 0;
       cvm1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvm0() //  [R1]
         { info_tbl: [(cvm0,
                       label: block_cvm0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvm0: // global
           if (R1 & 7 == 1) goto cvm4; else goto cvm5;
       cvm4: // global
           R1 = GHC.List.badHead_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvm5: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.612164018 UTC

[section ""cstring" . lvl17_ru9a_bytes" {
     lvl17_ru9a_bytes:
         I8[] [109,97,120,105,109,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.612874584 UTC

[section ""data" . lvl18_ru9b_closure" {
     lvl18_ru9b_closure:
         const lvl18_ru9b_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_ru9b_entry() //  [R1]
         { info_tbl: [(cvmn,
                       label: lvl18_ru9b_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvmn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvmo; else goto cvmp;
       cvmo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvmp: // global
           (_cvmk::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvmk::I64 == 0) goto cvmm; else goto cvml;
       cvmm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvml: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvmk::I64;
           R2 = lvl17_ru9a_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.613905049 UTC

[section ""data" . GHC.List.maximum1_closure" {
     GHC.List.maximum1_closure:
         const GHC.List.maximum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum1_entry() //  [R1]
         { info_tbl: [(cvmw,
                       label: GHC.List.maximum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvmw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvmx; else goto cvmy;
       cvmx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvmy: // global
           (_cvmt::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvmt::I64 == 0) goto cvmv; else goto cvmu;
       cvmv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvmu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvmt::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.614970746 UTC

[section ""data" . GHC.List.maximum2_closure" {
     GHC.List.maximum2_closure:
         const GHC.List.maximum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum2_entry() //  [R1]
         { info_tbl: [(cvmF,
                       label: GHC.List.maximum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvmF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvmG; else goto cvmH;
       cvmG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvmH: // global
           (_cvmC::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvmC::I64 == 0) goto cvmE; else goto cvmD;
       cvmE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvmD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvmC::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.616028986 UTC

[section ""data" . lvl19_ru9c_closure" {
     lvl19_ru9c_closure:
         const lvl19_ru9c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_ru9c_entry() //  [R1]
         { info_tbl: [(cvmO,
                       label: lvl19_ru9c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvmO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvmP; else goto cvmQ;
       cvmP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvmQ: // global
           (_cvmL::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvmL::I64 == 0) goto cvmN; else goto cvmM;
       cvmN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvmM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvmL::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.617733179 UTC

[section ""data" . GHC.List.maximum_go_closure" {
     GHC.List.maximum_go_closure:
         const GHC.List.maximum_go_info;
 },
 GHC.List.maximum_go_entry() //  [R2, R3]
         { info_tbl: [(cvn2,
                       label: GHC.List.maximum_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvn2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvn3; else goto uvnm;
       cvn3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvnm: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvmS() args: 0, res: 0, upd: 0;
     }
 },
 _cvmS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvmS: // global
           _subd::P64 = P64[Sp];
           I64[Sp] = block_cvmV_info;
           R1 = _subd::P64;
           if (R1 & 7 != 0) goto uvnp; else goto cvmW;
       uvnp: // global
           call _cvmV(R1) args: 0, res: 0, upd: 0;
       cvmW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvmV() //  [R1]
         { info_tbl: [(cvmV,
                       label: block_cvmV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvmV: // global
           _sube::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cvmZ; else goto cvn0;
       cvmZ: // global
           R1 = _sube::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvn0: // global
           I64[Sp - 16] = block_cvna_info;
           _subg::P64 = P64[R1 + 6];
           R3 = _subg::P64;
           R2 = _sube::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _subg::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvna() //  [R1]
         { info_tbl: [(cvna,
                       label: block_cvna_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvna: // global
           _subh::P64 = P64[Sp + 8];
           if (R1 == 1) goto cvnl; else goto cvnh;
       cvnl: // global
           _sube::P64 = P64[Sp + 16];
           P64[Sp + 16] = _subh::P64;
           P64[Sp + 24] = _sube::P64;
           Sp = Sp + 16;
           goto uvns;
       cvnh: // global
           P64[Sp + 16] = _subh::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uvns;
       uvns: // global
           call _cvmS() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.61944343 UTC

[section ""data" . GHC.List.maximum_$smaximum_closure" {
     GHC.List.maximum_$smaximum_closure:
         const GHC.List.maximum_$smaximum_info;
         const 0;
 },
 GHC.List.maximum_$smaximum_entry() //  [R2]
         { info_tbl: [(cvnE,
                       label: GHC.List.maximum_$smaximum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvnE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvnF; else goto cvnG;
       cvnF: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvnG: // global
           I64[Sp - 8] = block_cvnx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvnN; else goto cvny;
       uvnN: // global
           call _cvnx(R1) args: 0, res: 0, upd: 0;
       cvny: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvnx() //  [R1]
         { info_tbl: [(cvnx,
                       label: block_cvnx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvnx: // global
           if (R1 & 7 == 1) goto cvnB; else goto cvnC;
       cvnB: // global
           R1 = GHC.List.maximum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvnC: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.maximum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.620507152 UTC

[section ""cstring" . lvl20_ru9d_bytes" {
     lvl20_ru9d_bytes:
         I8[] [109,105,110,105,109,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.621271071 UTC

[section ""data" . lvl21_ru9e_closure" {
     lvl21_ru9e_closure:
         const lvl21_ru9e_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_ru9e_entry() //  [R1]
         { info_tbl: [(cvnU,
                       label: lvl21_ru9e_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvnU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvnV; else goto cvnW;
       cvnV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvnW: // global
           (_cvnR::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvnR::I64 == 0) goto cvnT; else goto cvnS;
       cvnT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvnS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvnR::I64;
           R2 = lvl20_ru9d_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.622316935 UTC

[section ""data" . GHC.List.minimum1_closure" {
     GHC.List.minimum1_closure:
         const GHC.List.minimum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum1_entry() //  [R1]
         { info_tbl: [(cvo3,
                       label: GHC.List.minimum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvo3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvo4; else goto cvo5;
       cvo4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvo5: // global
           (_cvo0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvo0::I64 == 0) goto cvo2; else goto cvo1;
       cvo2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvo1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvo0::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.624003027 UTC

[section ""data" . GHC.List.minimum2_closure" {
     GHC.List.minimum2_closure:
         const GHC.List.minimum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum2_entry() //  [R1]
         { info_tbl: [(cvoc,
                       label: GHC.List.minimum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvoc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvod; else goto cvoe;
       cvod: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvoe: // global
           (_cvo9::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvo9::I64 == 0) goto cvob; else goto cvoa;
       cvob: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvoa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvo9::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.625022099 UTC

[section ""data" . lvl22_ru9f_closure" {
     lvl22_ru9f_closure:
         const lvl22_ru9f_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ru9f_entry() //  [R1]
         { info_tbl: [(cvol,
                       label: lvl22_ru9f_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvol: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvom; else goto cvon;
       cvom: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvon: // global
           (_cvoi::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvoi::I64 == 0) goto cvok; else goto cvoj;
       cvok: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvoj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvoi::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.626395826 UTC

[section ""data" . GHC.List.minimum_go_closure" {
     GHC.List.minimum_go_closure:
         const GHC.List.minimum_go_info;
 },
 GHC.List.minimum_go_entry() //  [R2, R3]
         { info_tbl: [(cvoz,
                       label: GHC.List.minimum_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvoz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvoA; else goto uvoT;
       cvoA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvoT: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvop() args: 0, res: 0, upd: 0;
     }
 },
 _cvop() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvop: // global
           _subn::P64 = P64[Sp];
           I64[Sp] = block_cvos_info;
           R1 = _subn::P64;
           if (R1 & 7 != 0) goto uvoW; else goto cvot;
       uvoW: // global
           call _cvos(R1) args: 0, res: 0, upd: 0;
       cvot: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvos() //  [R1]
         { info_tbl: [(cvos,
                       label: block_cvos_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvos: // global
           _subo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cvow; else goto cvox;
       cvow: // global
           R1 = _subo::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvox: // global
           I64[Sp - 16] = block_cvoH_info;
           _subq::P64 = P64[R1 + 6];
           R3 = _subq::P64;
           R2 = _subo::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _subq::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvoH() //  [R1]
         { info_tbl: [(cvoH,
                       label: block_cvoH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvoH: // global
           _subr::P64 = P64[Sp + 8];
           if (R1 == 1) goto cvoS; else goto cvoO;
       cvoS: // global
           P64[Sp + 16] = _subr::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uvoZ;
       cvoO: // global
           _subo::P64 = P64[Sp + 16];
           P64[Sp + 16] = _subr::P64;
           P64[Sp + 24] = _subo::P64;
           Sp = Sp + 16;
           goto uvoZ;
       uvoZ: // global
           call _cvop() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.628086064 UTC

[section ""data" . GHC.List.minimum_$sminimum_closure" {
     GHC.List.minimum_$sminimum_closure:
         const GHC.List.minimum_$sminimum_info;
         const 0;
 },
 GHC.List.minimum_$sminimum_entry() //  [R2]
         { info_tbl: [(cvpb,
                       label: GHC.List.minimum_$sminimum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvpb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvpc; else goto cvpd;
       cvpc: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvpd: // global
           I64[Sp - 8] = block_cvp4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvpk; else goto cvp5;
       uvpk: // global
           call _cvp4(R1) args: 0, res: 0, upd: 0;
       cvp5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvp4() //  [R1]
         { info_tbl: [(cvp4,
                       label: block_cvp4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvp4: // global
           if (R1 & 7 == 1) goto cvp8; else goto cvp9;
       cvp8: // global
           R1 = GHC.List.minimum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvp9: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.minimum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.629645257 UTC

[section ""data" . GHC.List.$wgo_closure" {
     GHC.List.$wgo_closure:
         const GHC.List.$wgo_info;
 },
 GHC.List.$wgo_entry() //  [R2, R3]
         { info_tbl: [(cvpw,
                       label: GHC.List.$wgo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvpw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvpx; else goto uvpQ;
       cvpx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvpQ: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvpm() args: 0, res: 0, upd: 0;
     }
 },
 _cvpm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvpm: // global
           _subx::P64 = P64[Sp];
           I64[Sp] = block_cvpp_info;
           R1 = _subx::P64;
           if (R1 & 7 != 0) goto uvpT; else goto cvpq;
       uvpT: // global
           call _cvpp(R1) args: 0, res: 0, upd: 0;
       cvpq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvpp() //  [R1]
         { info_tbl: [(cvpp,
                       label: block_cvpp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvpp: // global
           if (R1 & 7 == 1) goto cvpt; else goto cvpu;
       cvpt: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvpu: // global
           I64[Sp - 8] = block_cvpE_info;
           _subB::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _subB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvpU; else goto cvpG;
       uvpU: // global
           call _cvpE(R1) args: 0, res: 0, upd: 0;
       cvpG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvpE() //  [R1]
         { info_tbl: [(cvpE,
                       label: block_cvpE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvpE: // global
           _suby::I64 = I64[Sp + 16];
           _subB::P64 = P64[Sp + 8];
           _subD::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_suby::I64,
                            _subD::I64)) goto cvpO; else goto cvpP;
       cvpO: // global
           P64[Sp + 8] = _subB::P64;
           I64[Sp + 16] = _suby::I64;
           Sp = Sp + 8;
           goto uvpX;
       cvpP: // global
           P64[Sp + 8] = _subB::P64;
           I64[Sp + 16] = _subD::I64;
           Sp = Sp + 8;
           goto uvpX;
       uvpX: // global
           call _cvpm() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.631511736 UTC

[section ""data" . GHC.List.maximum_$smaximum1_closure" {
     GHC.List.maximum_$smaximum1_closure:
         const GHC.List.maximum_$smaximum1_info;
         const 0;
 },
 GHC.List.maximum_$smaximum1_entry() //  [R2]
         { info_tbl: [(cvq9,
                       label: GHC.List.maximum_$smaximum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvq9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvqa; else goto cvqb;
       cvqa: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvqb: // global
           I64[Sp - 8] = block_cvq2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvqx; else goto cvq3;
       uvqx: // global
           call _cvq2(R1) args: 0, res: 0, upd: 0;
       cvq3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvq2() //  [R1]
         { info_tbl: [(cvq2,
                       label: block_cvq2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvq2: // global
           if (R1 & 7 == 1) goto cvq6; else goto cvq7;
       cvq6: // global
           R1 = GHC.List.maximum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvq7: // global
           I64[Sp - 8] = block_cvqh_info;
           _subI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _subI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvqw; else goto cvqi;
       uvqw: // global
           call _cvqh(R1) args: 0, res: 0, upd: 0;
       cvqi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvqh() //  [R1]
         { info_tbl: [(cvqh,
                       label: block_cvqh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvqh: // global
           _subI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cvqm_info;
           R3 = I64[R1 + 7];
           R2 = _subI::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvqm() //  [R1]
         { info_tbl: [(cvqm,
                       label: block_cvqm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvqm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvqv; else goto cvqu;
       cvqv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cvqu: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.633751061 UTC

[section ""data" . GHC.List.maximum_closure" {
     GHC.List.maximum_closure:
         const GHC.List.maximum_info;
         const 0;
 },
 sat_subX_entry() //  [R1]
         { info_tbl: [(cvqX,
                       label: sat_subX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvqX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvqY; else goto cvqZ;
       cvqY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvqZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.max_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.List.maximum_entry() //  [R2, R3]
         { info_tbl: [(cvr4,
                       label: GHC.List.maximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvr4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvr5; else goto cvr6;
       cvr5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvr6: // global
           I64[Sp - 16] = block_cvqC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvrp; else goto cvqD;
       uvrp: // global
           call _cvqC(R1) args: 0, res: 0, upd: 0;
       cvqD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvqC() //  [R1]
         { info_tbl: [(cvqC,
                       label: block_cvqC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvqC: // global
           if (R1 & 7 == 1) goto cvr1; else goto cvr2;
       cvr1: // global
           R1 = lvl19_ru9c_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvr2: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cvqL() args: 0, res: 0, upd: 0;
     }
 },
 _cvqL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvqL: // global
           I64[Sp - 8] = block_cvqN_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvrn; else goto cvqO;
       uvrn: // global
           call _cvqN(R1) args: 0, res: 0, upd: 0;
       cvqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvqN() //  [R1]
         { info_tbl: [(cvqN,
                       label: block_cvqN_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvqN: // global
           _subT::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cvre; else goto cvrf;
       cvre: // global
           R1 = _subT::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvrf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvri; else goto cvrh;
       cvri: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvrh: // global
           _subV::P64 = P64[R1 + 6];
           _subW::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_subX_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _subT::P64;
           P64[Hp] = _subV::P64;
           P64[Sp + 16] = _subW::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cvqL() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.636105356 UTC

[section ""data" . GHC.List.$wgo1_closure" {
     GHC.List.$wgo1_closure:
         const GHC.List.$wgo1_info;
 },
 GHC.List.$wgo1_entry() //  [R2, R3]
         { info_tbl: [(cvrB,
                       label: GHC.List.$wgo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvrB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvrC; else goto uvrV;
       cvrC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvrV: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvrr() args: 0, res: 0, upd: 0;
     }
 },
 _cvrr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvrr: // global
           _subY::P64 = P64[Sp];
           I64[Sp] = block_cvru_info;
           R1 = _subY::P64;
           if (R1 & 7 != 0) goto uvrY; else goto cvrv;
       uvrY: // global
           call _cvru(R1) args: 0, res: 0, upd: 0;
       cvrv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvru() //  [R1]
         { info_tbl: [(cvru,
                       label: block_cvru_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvru: // global
           if (R1 & 7 == 1) goto cvry; else goto cvrz;
       cvry: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvrz: // global
           I64[Sp - 8] = block_cvrJ_info;
           _suc2::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _suc2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvrZ; else goto cvrL;
       uvrZ: // global
           call _cvrJ(R1) args: 0, res: 0, upd: 0;
       cvrL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvrJ() //  [R1]
         { info_tbl: [(cvrJ,
                       label: block_cvrJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvrJ: // global
           _subZ::I64 = I64[Sp + 16];
           _suc2::P64 = P64[Sp + 8];
           _suc4::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_subZ::I64,
                            _suc4::I64)) goto cvrT; else goto cvrU;
       cvrT: // global
           P64[Sp + 8] = _suc2::P64;
           I64[Sp + 16] = _suc4::I64;
           Sp = Sp + 8;
           goto uvs2;
       cvrU: // global
           P64[Sp + 8] = _suc2::P64;
           I64[Sp + 16] = _subZ::I64;
           Sp = Sp + 8;
           goto uvs2;
       uvs2: // global
           call _cvrr() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.638044667 UTC

[section ""data" . GHC.List.minimum_$sminimum1_closure" {
     GHC.List.minimum_$sminimum1_closure:
         const GHC.List.minimum_$sminimum1_info;
         const 0;
 },
 GHC.List.minimum_$sminimum1_entry() //  [R2]
         { info_tbl: [(cvse,
                       label: GHC.List.minimum_$sminimum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvse: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvsf; else goto cvsg;
       cvsf: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvsg: // global
           I64[Sp - 8] = block_cvs7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvsC; else goto cvs8;
       uvsC: // global
           call _cvs7(R1) args: 0, res: 0, upd: 0;
       cvs8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvs7() //  [R1]
         { info_tbl: [(cvs7,
                       label: block_cvs7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvs7: // global
           if (R1 & 7 == 1) goto cvsb; else goto cvsc;
       cvsb: // global
           R1 = GHC.List.minimum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvsc: // global
           I64[Sp - 8] = block_cvsm_info;
           _suc9::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _suc9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvsB; else goto cvsn;
       uvsB: // global
           call _cvsm(R1) args: 0, res: 0, upd: 0;
       cvsn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvsm() //  [R1]
         { info_tbl: [(cvsm,
                       label: block_cvsm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvsm: // global
           _suc9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cvsr_info;
           R3 = I64[R1 + 7];
           R2 = _suc9::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvsr() //  [R1]
         { info_tbl: [(cvsr,
                       label: block_cvsr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvsr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvsA; else goto cvsz;
       cvsA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cvsz: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.641046144 UTC

[section ""data" . GHC.List.minimum_closure" {
     GHC.List.minimum_closure:
         const GHC.List.minimum_info;
         const 0;
 },
 sat_suco_entry() //  [R1]
         { info_tbl: [(cvt2,
                       label: sat_suco_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvt2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvt3; else goto cvt4;
       cvt3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvt4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.min_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.List.minimum_entry() //  [R2, R3]
         { info_tbl: [(cvt9,
                       label: GHC.List.minimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvt9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvta; else goto cvtb;
       cvta: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvtb: // global
           I64[Sp - 16] = block_cvsH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvtu; else goto cvsI;
       uvtu: // global
           call _cvsH(R1) args: 0, res: 0, upd: 0;
       cvsI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvsH() //  [R1]
         { info_tbl: [(cvsH,
                       label: block_cvsH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvsH: // global
           if (R1 & 7 == 1) goto cvt6; else goto cvt7;
       cvt6: // global
           R1 = lvl22_ru9f_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvt7: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cvsQ() args: 0, res: 0, upd: 0;
     }
 },
 _cvsQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvsQ: // global
           I64[Sp - 8] = block_cvsS_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvts; else goto cvsT;
       uvts: // global
           call _cvsS(R1) args: 0, res: 0, upd: 0;
       cvsT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvsS() //  [R1]
         { info_tbl: [(cvsS,
                       label: block_cvsS_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvsS: // global
           _suck::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cvtj; else goto cvtk;
       cvtj: // global
           R1 = _suck::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvtk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvtn; else goto cvtm;
       cvtn: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvtm: // global
           _sucm::P64 = P64[R1 + 6];
           _sucn::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_suco_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _suck::P64;
           P64[Hp] = _sucm::P64;
           P64[Sp + 16] = _sucn::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cvsQ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.642843062 UTC

[section ""cstring" . lvl23_ru9g_bytes" {
     lvl23_ru9g_bytes:
         I8[] [102,111,108,100,108,49,39]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.643576952 UTC

[section ""data" . lvl24_ru9h_closure" {
     lvl24_ru9h_closure:
         const lvl24_ru9h_info;
         const 0;
         const 0;
         const 0;
 },
 lvl24_ru9h_entry() //  [R1]
         { info_tbl: [(cvtB,
                       label: lvl24_ru9h_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvtB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvtC; else goto cvtD;
       cvtC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvtD: // global
           (_cvty::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvty::I64 == 0) goto cvtA; else goto cvtz;
       cvtA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvtz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvty::I64;
           R2 = lvl23_ru9g_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.644608581 UTC

[section ""data" . GHC.List.foldl1'1_closure" {
     GHC.List.foldl1'1_closure:
         const GHC.List.foldl1'1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl1'1_entry() //  [R1]
         { info_tbl: [(cvtK,
                       label: GHC.List.foldl1'1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvtK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvtL; else goto cvtM;
       cvtL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvtM: // global
           (_cvtH::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvtH::I64 == 0) goto cvtJ; else goto cvtI;
       cvtJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvtI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvtH::I64;
           R2 = lvl24_ru9h_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.645546566 UTC

[section ""cstring" . lvl25_ru9i_bytes" {
     lvl25_ru9i_bytes:
         I8[] [102,111,108,100,108,49]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.646245822 UTC

[section ""data" . lvl26_ru9j_closure" {
     lvl26_ru9j_closure:
         const lvl26_ru9j_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_ru9j_entry() //  [R1]
         { info_tbl: [(cvtT,
                       label: lvl26_ru9j_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvtT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvtU; else goto cvtV;
       cvtU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvtV: // global
           (_cvtQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvtQ::I64 == 0) goto cvtS; else goto cvtR;
       cvtS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvtR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvtQ::I64;
           R2 = lvl25_ru9i_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.647267865 UTC

[section ""data" . GHC.List.foldl2_closure" {
     GHC.List.foldl2_closure:
         const GHC.List.foldl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl2_entry() //  [R1]
         { info_tbl: [(cvu2,
                       label: GHC.List.foldl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvu2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvu3; else goto cvu4;
       cvu3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvu4: // global
           (_cvtZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvtZ::I64 == 0) goto cvu1; else goto cvu0;
       cvu1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvu0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvtZ::I64;
           R2 = lvl26_ru9j_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.648945785 UTC

[section ""data" . $wgo2_ru9k_closure" {
     $wgo2_ru9k_closure:
         const $wgo2_ru9k_info;
 },
 ds_sucx_entry() //  [R1]
         { info_tbl: [(cvur,
                       label: ds_sucx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvur: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvus; else goto cvut;
       cvus: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvut: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cvuo_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvuo() //  [R1, R2, R3]
         { info_tbl: [(cvuo,
                       label: block_cvuo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvuo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvuw; else goto cvuv;
       cvuw: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 24;
       cvuv: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo2_ru9k_entry() //  [R2]
         { info_tbl: [(cvuB,
                       label: $wgo2_ru9k_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvuB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvuC; else goto cvuD;
       cvuC: // global
           R2 = R2;
           R1 = $wgo2_ru9k_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvuD: // global
           I64[Sp - 8] = block_cvu9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvuR; else goto cvua;
       uvuR: // global
           call _cvu9(R1) args: 0, res: 0, upd: 0;
       cvua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvu9() //  [R1]
         { info_tbl: [(cvu9,
                       label: block_cvu9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvu9: // global
           if (R1 & 7 == 1) goto cvuy; else goto cvuz;
       cvuy: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvuz: // global
           I64[Sp - 8] = block_cvuf_info;
           _sucs::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sucs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvuQ; else goto cvug;
       uvuQ: // global
           call _cvuf(R1) args: 0, res: 0, upd: 0;
       cvug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvuf() //  [R1]
         { info_tbl: [(cvuf,
                       label: block_cvuf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvuf: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cvuP; else goto cvuO;
       cvuP: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvuO: // global
           _sucu::P64 = P64[R1 + 7];
           _sucv::P64 = P64[R1 + 15];
           _sucw::P64 = P64[R1 + 23];
           I64[Hp - 160] = ds_sucx_info;
           P64[Hp - 144] = P64[Sp + 8];
           I64[Hp - 136] = stg_sel_2_upd_info;
           _cvuk::P64 = Hp - 160;
           P64[Hp - 120] = _cvuk::P64;
           I64[Hp - 112] = :_con_info;
           P64[Hp - 104] = _sucw::P64;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _cvuk::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sucv::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cvuk::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sucu::P64;
           P64[Hp] = Hp - 40;
           R3 = Hp - 110;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.65155455 UTC

[section ""data" . go_ru9l_closure" {
     go_ru9l_closure:
         const go_ru9l_info;
 },
 go_ru9l_entry() //  [R2]
         { info_tbl: [(cvuZ,
                       label: go_ru9l_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvuZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvv0; else goto cvv1;
       cvv0: // global
           R2 = R2;
           R1 = go_ru9l_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvv1: // global
           I64[Sp - 8] = block_cvuW_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvuW() //  [R1, R2, R3]
         { info_tbl: [(cvuW,
                       label: block_cvuW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvuW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvv4; else goto cvv3;
       cvv4: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cvv3: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.652645314 UTC

[section ""data" . GHC.List.unzip3_closure" {
     GHC.List.unzip3_closure:
         const GHC.List.unzip3_info;
 },
 GHC.List.unzip3_entry() //  [R2]
         { info_tbl: [(cvv9,
                       label: GHC.List.unzip3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvv9: // global
           R2 = R2;
           call go_ru9l_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.65407565 UTC

[section ""data" . $wgo3_ru9m_closure" {
     $wgo3_ru9m_closure:
         const $wgo3_ru9m_info;
 },
 ds_sud6_entry() //  [R1]
         { info_tbl: [(cvvy,
                       label: ds_sud6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvvy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvvz; else goto cvvA;
       cvvz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvvA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cvvv_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvvv() //  [R1, R2]
         { info_tbl: [(cvvv,
                       label: block_cvvv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvvv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvvD; else goto cvvC;
       cvvD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cvvC: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo3_ru9m_entry() //  [R2]
         { info_tbl: [(cvvI,
                       label: $wgo3_ru9m_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvvI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvvJ; else goto cvvK;
       cvvJ: // global
           R2 = R2;
           R1 = $wgo3_ru9m_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvvK: // global
           I64[Sp - 8] = block_cvvg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvvW; else goto cvvh;
       uvvW: // global
           call _cvvg(R1) args: 0, res: 0, upd: 0;
       cvvh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvvg() //  [R1]
         { info_tbl: [(cvvg,
                       label: block_cvvg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvvg: // global
           if (R1 & 7 == 1) goto cvvF; else goto cvvG;
       cvvF: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cvvG: // global
           I64[Sp - 8] = block_cvvm_info;
           _sud2::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sud2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvvV; else goto cvvn;
       uvvV: // global
           call _cvvm(R1) args: 0, res: 0, upd: 0;
       cvvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvvm() //  [R1]
         { info_tbl: [(cvvm,
                       label: block_cvvm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvvm: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cvvU; else goto cvvT;
       cvvU: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvvT: // global
           _sud4::P64 = P64[R1 + 7];
           _sud5::P64 = P64[R1 + 15];
           I64[Hp - 112] = ds_sud6_info;
           P64[Hp - 96] = P64[Sp + 8];
           I64[Hp - 88] = stg_sel_1_upd_info;
           _cvvr::P64 = Hp - 112;
           P64[Hp - 72] = _cvvr::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sud5::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cvvr::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sud4::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.656951327 UTC

[section ""data" . go1_ru9n_closure" {
     go1_ru9n_closure:
         const go1_ru9n_info;
 },
 go1_ru9n_entry() //  [R2]
         { info_tbl: [(cvw4,
                       label: go1_ru9n_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvw4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvw5; else goto cvw6;
       cvw5: // global
           R2 = R2;
           R1 = go1_ru9n_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvw6: // global
           I64[Sp - 8] = block_cvw1_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvw1() //  [R1, R2]
         { info_tbl: [(cvw1,
                       label: block_cvw1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvw1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvw9; else goto cvw8;
       cvw9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cvw8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.658375397 UTC

[section ""data" . GHC.List.unzip_closure" {
     GHC.List.unzip_closure:
         const GHC.List.unzip_info;
 },
 GHC.List.unzip_entry() //  [R2]
         { info_tbl: [(cvwe,
                       label: GHC.List.unzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvwe: // global
           R2 = R2;
           call go1_ru9n_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.660041847 UTC

[section ""data" . GHC.List.zipWith3_closure" {
     GHC.List.zipWith3_closure:
         const GHC.List.zipWith3_info;
 },
 go2_suds_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cvwx,
                       label: go2_suds_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvwx: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cvwy; else goto cvwz;
       cvwy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvwz: // global
           I64[Sp - 40] = block_cvwq_info;
           _suds::P64 = R1;
           _sudo::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 32] = _sudo::P64;
           P64[Sp - 24] = _suds::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uvxg; else goto cvwr;
       uvxg: // global
           call _cvwq(R1) args: 0, res: 0, upd: 0;
       cvwr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvwq() //  [R1]
         { info_tbl: [(cvwq,
                       label: block_cvwq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvwq: // global
           if (R1 & 7 == 1) goto uvxb; else goto cvwv;
       uvxb: // global
           Sp = Sp + 40;
           call _cvwZ() args: 0, res: 0, upd: 0;
       cvwv: // global
           I64[Sp - 8] = block_cvwF_info;
           _sudx::P64 = P64[R1 + 6];
           _sudy::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sudy::P64;
           P64[Sp + 24] = _sudx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvxe; else goto cvwH;
       uvxe: // global
           call _cvwF(R1) args: 0, res: 0, upd: 0;
       cvwH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvwF() //  [R1]
         { info_tbl: [(cvwF,
                       label: block_cvwF_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvwF: // global
           if (R1 & 7 == 1) goto uvxc; else goto cvwS;
       uvxc: // global
           Sp = Sp + 48;
           call _cvwZ() args: 0, res: 0, upd: 0;
       cvwS: // global
           I64[Sp - 8] = block_cvwQ_info;
           _sudA::P64 = P64[R1 + 6];
           _sudB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sudB::P64;
           P64[Sp + 40] = _sudA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvxh; else goto cvwT;
       uvxh: // global
           call _cvwQ(R1) args: 0, res: 0, upd: 0;
       cvwT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvwQ() //  [R1]
         { info_tbl: [(cvwQ,
                       label: block_cvwQ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvwQ: // global
           if (R1 & 7 == 1) goto uvxd; else goto cvx5;
       uvxd: // global
           Sp = Sp + 56;
           call _cvwZ() args: 0, res: 0, upd: 0;
       cvx5: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cvx8; else goto cvx7;
       cvx8: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvx7: // global
           _sudD::P64 = P64[R1 + 6];
           _sudE::P64 = P64[R1 + 14];
           I64[Hp - 112] = stg_ap_4_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 16];
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sudE::P64;
           I64[Hp - 64] = stg_ap_4_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = _sudD::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cvwZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvwZ: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cvxk,
                       label: GHC.List.zipWith3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvxk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvxo; else goto cvxn;
       cvxo: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvxn: // global
           I64[Hp - 8] = go2_suds_info;
           P64[Hp] = R2;
           _sudq::P64 = R4;
           R4 = R5;
           _sudp::P64 = R3;
           R3 = _sudq::P64;
           R2 = _sudp::P64;
           R1 = Hp - 5;
           call go2_suds_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.662595171 UTC

[section ""data" . GHC.List.zipWithFB_closure" {
     GHC.List.zipWithFB_closure:
         const GHC.List.zipWithFB_info;
 },
 GHC.List.zipWithFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cvxu,
                       label: GHC.List.zipWithFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvxu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvxy; else goto cvxx;
       cvxy: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWithFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvxx: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R3 = R6;
           _sudH::P64 = R2;
           R2 = Hp - 32;
           R1 = _sudH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.664362776 UTC

[section ""data" . GHC.List.zip3_closure" {
     GHC.List.zip3_closure:
         const GHC.List.zip3_info;
 },
 sat_sue0_entry() //  [R1]
         { info_tbl: [(cvxZ,
                       label: sat_sue0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvxZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvy0; else goto cvy1;
       cvy0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvy1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.zip3_entry() //  [R2, R3, R4]
         { info_tbl: [(cvy6,
                       label: GHC.List.zip3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvy6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvy7; else goto cvy8;
       cvy7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvy8: // global
           I64[Sp - 24] = block_cvxD_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uvyC; else goto cvxE;
       uvyC: // global
           call _cvxD(R1) args: 0, res: 0, upd: 0;
       cvxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvxD() //  [R1]
         { info_tbl: [(cvxD,
                       label: block_cvxD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvxD: // global
           if (R1 & 7 == 1) goto uvyu; else goto cvy4;
       uvyu: // global
           Sp = Sp + 24;
           call _cvyl() args: 0, res: 0, upd: 0;
       cvy4: // global
           I64[Sp - 8] = block_cvxJ_info;
           _sudR::P64 = P64[R1 + 6];
           _sudS::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sudS::P64;
           P64[Sp + 8] = _sudR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvyx; else goto cvxK;
       uvyx: // global
           call _cvxJ(R1) args: 0, res: 0, upd: 0;
       cvxK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvxJ() //  [R1]
         { info_tbl: [(cvxJ,
                       label: block_cvxJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvxJ: // global
           if (R1 & 7 == 1) goto uvyv; else goto cvyh;
       uvyv: // global
           Sp = Sp + 32;
           call _cvyl() args: 0, res: 0, upd: 0;
       cvyh: // global
           I64[Sp - 8] = block_cvxP_info;
           _sudU::P64 = P64[R1 + 6];
           _sudV::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sudV::P64;
           P64[Sp + 24] = _sudU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvyz; else goto cvxQ;
       uvyz: // global
           call _cvxP(R1) args: 0, res: 0, upd: 0;
       cvxQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvxP() //  [R1]
         { info_tbl: [(cvxP,
                       label: block_cvxP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvxP: // global
           if (R1 & 7 == 1) goto uvyw; else goto cvyo;
       uvyw: // global
           Sp = Sp + 40;
           call _cvyl() args: 0, res: 0, upd: 0;
       cvyo: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cvyr; else goto cvyq;
       cvyr: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvyq: // global
           _sudX::P64 = P64[R1 + 6];
           _sudY::P64 = P64[R1 + 14];
           I64[Hp - 88] = sat_sue0_info;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sudY::P64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sudX::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 47;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cvyl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvyl: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.66678968 UTC

[section ""data" . GHC.List.zipFB_closure" {
     GHC.List.zipFB_closure:
         const GHC.List.zipFB_info;
 },
 GHC.List.zipFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cvyI,
                       label: GHC.List.zipFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvyI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvyM; else goto cvyL;
       cvyM: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvyL: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _sue1::P64 = R2;
           R2 = Hp - 15;
           R1 = _sue1::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.668018636 UTC

[section ""data" . GHC.List.foldr2_left_closure" {
     GHC.List.foldr2_left_closure:
         const GHC.List.foldr2_left_info;
 },
 GHC.List.foldr2_left_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cvyY,
                       label: GHC.List.foldr2_left_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvyY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvyZ; else goto cvz0;
       cvyZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_left_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvz0: // global
           I64[Sp - 40] = block_cvyR_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uvza; else goto cvyS;
       uvza: // global
           call _cvyR(R1) args: 0, res: 0, upd: 0;
       cvyS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvyR() //  [R1]
         { info_tbl: [(cvyR,
                       label: block_cvyR_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvyR: // global
           if (R1 & 7 == 1) goto cvyV; else goto cvyW;
       cvyV: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvyW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvz9; else goto cvz8;
       cvz9: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvz8: // global
           _suec::P64 = P64[R1 + 6];
           _sued::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sued::P64;
           R4 = Hp - 24;
           R3 = _suec::P64;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.671584915 UTC

[section ""data" . GHC.List.zip_closure" {
     GHC.List.zip_closure:
         const GHC.List.zip_info;
 },
 sat_sueo_entry() //  [R1]
         { info_tbl: [(cvzv,
                       label: sat_sueo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvzv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvzw; else goto cvzx;
       cvzw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvzx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.zip_entry() //  [R2, R3]
         { info_tbl: [(cvzC,
                       label: GHC.List.zip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvzC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvzD; else goto cvzE;
       cvzD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvzE: // global
           I64[Sp - 16] = block_cvzf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvzY; else goto cvzg;
       uvzY: // global
           call _cvzf(R1) args: 0, res: 0, upd: 0;
       cvzg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvzf() //  [R1]
         { info_tbl: [(cvzf,
                       label: block_cvzf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvzf: // global
           if (R1 & 7 == 1) goto uvzT; else goto cvzA;
       uvzT: // global
           Sp = Sp + 16;
           call _cvzL() args: 0, res: 0, upd: 0;
       cvzA: // global
           I64[Sp - 8] = block_cvzl_info;
           _suei::P64 = P64[R1 + 6];
           _suej::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _suej::P64;
           P64[Sp + 8] = _suei::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvzV; else goto cvzm;
       uvzV: // global
           call _cvzl(R1) args: 0, res: 0, upd: 0;
       cvzm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvzl() //  [R1]
         { info_tbl: [(cvzl,
                       label: block_cvzl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvzl: // global
           if (R1 & 7 == 1) goto uvzU; else goto cvzO;
       uvzU: // global
           Sp = Sp + 24;
           call _cvzL() args: 0, res: 0, upd: 0;
       cvzO: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cvzR; else goto cvzQ;
       cvzR: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvzQ: // global
           _suel::P64 = P64[R1 + 6];
           _suem::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sueo_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _suem::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _suel::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cvzL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvzL: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.zipWith_closure" {
     GHC.List.zipWith_closure:
         const GHC.List.zipWith_info;
 },
 go2_sues_entry() //  [R1, R2, R3]
         { info_tbl: [(cvAf,
                       label: go2_sues_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvAf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvAg; else goto cvAh;
       cvAg: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvAh: // global
           I64[Sp - 32] = block_cvA8_info;
           _sues::P64 = R1;
           _suep::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 24] = _suep::P64;
           P64[Sp - 16] = _sues::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uvAK; else goto cvA9;
       uvAK: // global
           call _cvA8(R1) args: 0, res: 0, upd: 0;
       cvA9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvA8() //  [R1]
         { info_tbl: [(cvA8,
                       label: block_cvA8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvA8: // global
           if (R1 & 7 == 1) goto uvAG; else goto cvAd;
       uvAG: // global
           Sp = Sp + 32;
           call _cvAv() args: 0, res: 0, upd: 0;
       cvAd: // global
           I64[Sp - 8] = block_cvAn_info;
           _suew::P64 = P64[R1 + 6];
           _suex::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _suex::P64;
           P64[Sp + 24] = _suew::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvAI; else goto cvAp;
       uvAI: // global
           call _cvAn(R1) args: 0, res: 0, upd: 0;
       cvAp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvAn() //  [R1]
         { info_tbl: [(cvAn,
                       label: block_cvAn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvAn: // global
           if (R1 & 7 == 1) goto uvAH; else goto cvAB;
       uvAH: // global
           Sp = Sp + 40;
           call _cvAv() args: 0, res: 0, upd: 0;
       cvAB: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cvAE; else goto cvAD;
       cvAE: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvAD: // global
           _suez::P64 = P64[R1 + 6];
           _sueA::P64 = P64[R1 + 14];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sueA::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _suez::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cvAv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvAv: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cvAM,
                       label: GHC.List.zipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvAM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvAQ; else goto cvAP;
       cvAQ: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvAP: // global
           I64[Hp - 8] = go2_sues_info;
           P64[Hp] = R2;
           _sueq::P64 = R3;
           R3 = R4;
           R2 = _sueq::P64;
           R1 = Hp - 6;
           call go2_sues_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.foldr2_closure" {
     GHC.List.foldr2_closure:
         const GHC.List.foldr2_info;
 },
 go2_sueH_entry() //  [R1, R2, R3]
         { info_tbl: [(cvB7,
                       label: go2_sueH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvB7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cvB8; else goto cvB9;
       cvB8: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvB9: // global
           I64[Sp - 40] = block_cvB0_info;
           _sueH::P64 = R1;
           _sueD::P64 = P64[R1 + 6];
           _sueE::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _sueD::P64;
           P64[Sp - 24] = _sueE::P64;
           P64[Sp - 16] = _sueH::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uvBA; else goto cvB1;
       uvBA: // global
           call _cvB0(R1) args: 0, res: 0, upd: 0;
       cvB1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvB0() //  [R1]
         { info_tbl: [(cvB0,
                       label: block_cvB0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvB0: // global
           if (R1 & 7 == 1) goto uvBw; else goto cvB5;
       uvBw: // global
           Sp = Sp + 16;
           call _cvBn() args: 0, res: 0, upd: 0;
       cvB5: // global
           I64[Sp - 8] = block_cvBf_info;
           _sueL::P64 = P64[R1 + 6];
           _sueM::P64 = P64[R1 + 14];
           R1 = P64[Sp + 32];
           P64[Sp] = _sueM::P64;
           P64[Sp + 32] = _sueL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvBy; else goto cvBh;
       uvBy: // global
           call _cvBf(R1) args: 0, res: 0, upd: 0;
       cvBh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvBf() //  [R1]
         { info_tbl: [(cvBf,
                       label: block_cvBf_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvBf: // global
           if (R1 & 7 == 1) goto uvBx; else goto cvBr;
       uvBx: // global
           Sp = Sp + 24;
           call _cvBn() args: 0, res: 0, upd: 0;
       cvBr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvBu; else goto cvBt;
       cvBu: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvBt: // global
           _sueO::P64 = P64[R1 + 6];
           _sueP::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sueP::P64;
           R4 = Hp - 32;
           R3 = _sueO::P64;
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 16];
           Sp = Sp + 48;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cvBn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvBn: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.foldr2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cvBC,
                       label: GHC.List.foldr2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvBC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvBG; else goto cvBF;
       cvBG: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvBF: // global
           I64[Hp - 16] = go2_sueH_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 14;
           call go2_sueH_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.67799923 UTC

[section ""data" . GHC.List.concat_go_closure" {
     GHC.List.concat_go_closure:
         const GHC.List.concat_go_info;
 },
 sat_sueV_entry() //  [R1]
         { info_tbl: [(cvBV,
                       label: sat_sueV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvBV: // global
           R2 = P64[R1 + 16];
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.concat_go_entry() //  [R2]
         { info_tbl: [(cvC2,
                       label: GHC.List.concat_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvC2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvC3; else goto cvC4;
       cvC3: // global
           R2 = R2;
           R1 = GHC.List.concat_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvC4: // global
           I64[Sp - 8] = block_cvBL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvCa; else goto cvBM;
       uvCa: // global
           call _cvBL(R1) args: 0, res: 0, upd: 0;
       cvBM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvBL() //  [R1]
         { info_tbl: [(cvBL,
                       label: block_cvBL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvBL: // global
           if (R1 & 7 == 1) goto cvBZ; else goto cvC0;
       cvBZ: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvC0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvC9; else goto cvC8;
       cvC9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvC8: // global
           _sueT::P64 = P64[R1 + 6];
           _sueU::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sueV_info;
           P64[Hp] = _sueU::P64;
           R3 = Hp - 16;
           R2 = _sueT::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.679353688 UTC

[section ""data" . GHC.List.concat_closure" {
     GHC.List.concat_closure:
         const GHC.List.concat_info;
 },
 GHC.List.concat_entry() //  [R2]
         { info_tbl: [(cvCf,
                       label: GHC.List.concat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvCf: // global
           R2 = R2;
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.680661756 UTC

[section ""data" . GHC.List.concatMap_closure" {
     GHC.List.concatMap_closure:
         const GHC.List.concatMap_info;
 },
 sat_suf4_entry() //  [R1]
         { info_tbl: [(cvCB,
                       label: sat_suf4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvCB: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go2_sueY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_sueY_entry() //  [R1, R2]
         { info_tbl: [(cvCI,
                       label: go2_sueY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvCI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvCJ; else goto cvCK;
       cvCJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvCK: // global
           I64[Sp - 24] = block_cvCr_info;
           _sueY::P64 = R1;
           _sueW::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sueW::P64;
           P64[Sp - 8] = _sueY::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uvCV; else goto cvCs;
       uvCV: // global
           call _cvCr(R1) args: 0, res: 0, upd: 0;
       cvCs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvCr() //  [R1]
         { info_tbl: [(cvCr,
                       label: block_cvCr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvCr: // global
           if (R1 & 7 == 1) goto cvCF; else goto cvCG;
       cvCF: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvCG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvCQ; else goto cvCP;
       cvCQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvCP: // global
           _suf1::P64 = P64[R1 + 6];
           _suf2::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_suf4_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _suf2::P64;
           _sueW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cvCN_info;
           R2 = _suf1::P64;
           R1 = _sueW::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvCN() //  [R1]
         { info_tbl: [(cvCN,
                       label: block_cvCN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvCN: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.concatMap_entry() //  [R2, R3]
         { info_tbl: [(cvCW,
                       label: GHC.List.concatMap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvCW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvD0; else goto cvCZ;
       cvD0: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.concatMap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvCZ: // global
           I64[Hp - 8] = go2_sueY_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_sueY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.683088931 UTC

[section ""data" . GHC.List.lookup_closure" {
     GHC.List.lookup_closure:
         const GHC.List.lookup_info;
 },
 GHC.List.lookup_entry() //  [R2, R3, R4]
         { info_tbl: [(cvDc,
                       label: GHC.List.lookup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvDc: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cvDd; else goto uvDG;
       cvDd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lookup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uvDG: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cvD2() args: 0, res: 0, upd: 0;
     }
 },
 _cvD2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvD2: // global
           I64[Sp - 8] = block_cvD5_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvDI; else goto cvD6;
       uvDI: // global
           call _cvD5(R1) args: 0, res: 0, upd: 0;
       cvD6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvD5() //  [R1]
         { info_tbl: [(cvD5,
                       label: block_cvD5_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvD5: // global
           if (R1 & 7 == 1) goto cvD9; else goto cvDa;
       cvD9: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvDa: // global
           I64[Sp] = block_cvDk_info;
           _sufa::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sufa::P64;
           if (R1 & 7 != 0) goto uvDJ; else goto cvDm;
       uvDJ: // global
           call _cvDk(R1) args: 0, res: 0, upd: 0;
       cvDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvDk() //  [R1]
         { info_tbl: [(cvDk,
                       label: block_cvDk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvDk: // global
           I64[Sp - 8] = block_cvDq_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cvDq() //  [R1]
         { info_tbl: [(cvDq,
                       label: block_cvDq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvDq: // global
           if (R1 & 7 == 1) goto cvDx; else goto cvDB;
       cvDx: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 16;
           call _cvD2() args: 0, res: 0, upd: 0;
       cvDB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvDE; else goto cvDD;
       cvDE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvDD: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.685336717 UTC

[section ""data" . GHC.List.notElem_closure" {
     GHC.List.notElem_closure:
         const GHC.List.notElem_info;
 },
 GHC.List.notElem_entry() //  [R2, R3, R4]
         { info_tbl: [(cvDX,
                       label: GHC.List.notElem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvDX: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cvDY; else goto uvEi;
       cvDY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.notElem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uvEi: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cvDN() args: 0, res: 0, upd: 0;
     }
 },
 _cvDN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvDN: // global
           I64[Sp - 8] = block_cvDQ_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvEk; else goto cvDR;
       uvEk: // global
           call _cvDQ(R1) args: 0, res: 0, upd: 0;
       cvDR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvDQ() //  [R1]
         { info_tbl: [(cvDQ,
                       label: block_cvDQ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvDQ: // global
           if (R1 & 7 == 1) goto cvDU; else goto cvDV;
       cvDU: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvDV: // global
           I64[Sp] = block_cvE5_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes./=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cvE5() //  [R1]
         { info_tbl: [(cvE5,
                       label: block_cvE5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvE5: // global
           if (R1 & 7 == 1) goto cvEc; else goto cvEg;
       cvEc: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvEg: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cvDN() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.687267064 UTC

[section ""data" . GHC.List.elem_closure" {
     GHC.List.elem_closure:
         const GHC.List.elem_info;
 },
 GHC.List.elem_entry() //  [R2, R3, R4]
         { info_tbl: [(cvEy,
                       label: GHC.List.elem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvEy: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cvEz; else goto uvET;
       cvEz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.elem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uvET: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cvEo() args: 0, res: 0, upd: 0;
     }
 },
 _cvEo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvEo: // global
           I64[Sp - 8] = block_cvEr_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvEV; else goto cvEs;
       uvEV: // global
           call _cvEr(R1) args: 0, res: 0, upd: 0;
       cvEs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvEr() //  [R1]
         { info_tbl: [(cvEr,
                       label: block_cvEr_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvEr: // global
           if (R1 & 7 == 1) goto cvEv; else goto cvEw;
       cvEv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvEw: // global
           I64[Sp] = block_cvEG_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cvEG() //  [R1]
         { info_tbl: [(cvEG,
                       label: block_cvEG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvEG: // global
           if (R1 & 7 == 1) goto cvEN; else goto cvER;
       cvEN: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cvEo() args: 0, res: 0, upd: 0;
       cvER: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.690110034 UTC

[section ""data" . GHC.List.all_closure" {
     GHC.List.all_closure:
         const GHC.List.all_info;
 },
 GHC.List.all_entry() //  [R2, R3]
         { info_tbl: [(cvF9,
                       label: GHC.List.all_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvF9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvFa; else goto uvFu;
       cvFa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.all_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvFu: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvEZ() args: 0, res: 0, upd: 0;
     }
 },
 _cvEZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvEZ: // global
           I64[Sp - 8] = block_cvF2_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvFw; else goto cvF3;
       uvFw: // global
           call _cvF2(R1) args: 0, res: 0, upd: 0;
       cvF3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvF2() //  [R1]
         { info_tbl: [(cvF2,
                       label: block_cvF2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvF2: // global
           if (R1 & 7 == 1) goto cvF6; else goto cvF7;
       cvF6: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvF7: // global
           I64[Sp] = block_cvFh_info;
           R2 = P64[R1 + 6];
           _sufx::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sufx::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvFh() //  [R1]
         { info_tbl: [(cvFh,
                       label: block_cvFh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvFh: // global
           if (R1 & 7 == 1) goto cvFo; else goto cvFs;
       cvFo: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvFs: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cvEZ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.691916542 UTC

[section ""data" . GHC.List.any_closure" {
     GHC.List.any_closure:
         const GHC.List.any_info;
 },
 GHC.List.any_entry() //  [R2, R3]
         { info_tbl: [(cvFK,
                       label: GHC.List.any_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvFK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvFL; else goto uvG5;
       cvFL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.any_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvG5: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvFA() args: 0, res: 0, upd: 0;
     }
 },
 _cvFA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvFA: // global
           I64[Sp - 8] = block_cvFD_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvG7; else goto cvFE;
       uvG7: // global
           call _cvFD(R1) args: 0, res: 0, upd: 0;
       cvFE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvFD() //  [R1]
         { info_tbl: [(cvFD,
                       label: block_cvFD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvFD: // global
           if (R1 & 7 == 1) goto cvFH; else goto cvFI;
       cvFH: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvFI: // global
           I64[Sp] = block_cvFS_info;
           R2 = P64[R1 + 6];
           _sufD::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sufD::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvFS() //  [R1]
         { info_tbl: [(cvFS,
                       label: block_cvFS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvFS: // global
           if (R1 & 7 == 1) goto cvFZ; else goto cvG3;
       cvFZ: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cvFA() args: 0, res: 0, upd: 0;
       cvG3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.693722523 UTC

[section ""data" . GHC.List.or_closure" {
     GHC.List.or_closure:
         const GHC.List.or_info;
 },
 GHC.List.or_entry() //  [R2]
         { info_tbl: [(cvGl,
                       label: GHC.List.or_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvGl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvGm; else goto uvGH;
       cvGm: // global
           R2 = R2;
           R1 = GHC.List.or_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uvGH: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cvGb() args: 0, res: 0, upd: 0;
     }
 },
 _cvGb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvGb: // global
           _sufF::P64 = P64[Sp];
           I64[Sp] = block_cvGe_info;
           R1 = _sufF::P64;
           if (R1 & 7 != 0) goto uvGJ; else goto cvGf;
       uvGJ: // global
           call _cvGe(R1) args: 0, res: 0, upd: 0;
       cvGf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvGe() //  [R1]
         { info_tbl: [(cvGe,
                       label: block_cvGe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvGe: // global
           if (R1 & 7 == 1) goto cvGi; else goto cvGj;
       cvGi: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvGj: // global
           I64[Sp - 8] = block_cvGt_info;
           _sufI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sufI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvGK; else goto cvGv;
       uvGK: // global
           call _cvGt(R1) args: 0, res: 0, upd: 0;
       cvGv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvGt() //  [R1]
         { info_tbl: [(cvGt,
                       label: block_cvGt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvGt: // global
           if (R1 & 7 == 1) goto cvGB; else goto cvGF;
       cvGB: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cvGb() args: 0, res: 0, upd: 0;
       cvGF: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.695468894 UTC

[section ""data" . GHC.List.and_closure" {
     GHC.List.and_closure:
         const GHC.List.and_info;
 },
 GHC.List.and_entry() //  [R2]
         { info_tbl: [(cvGY,
                       label: GHC.List.and_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvGY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvGZ; else goto uvHk;
       cvGZ: // global
           R2 = R2;
           R1 = GHC.List.and_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uvHk: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cvGO() args: 0, res: 0, upd: 0;
     }
 },
 _cvGO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvGO: // global
           _sufK::P64 = P64[Sp];
           I64[Sp] = block_cvGR_info;
           R1 = _sufK::P64;
           if (R1 & 7 != 0) goto uvHm; else goto cvGS;
       uvHm: // global
           call _cvGR(R1) args: 0, res: 0, upd: 0;
       cvGS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvGR() //  [R1]
         { info_tbl: [(cvGR,
                       label: block_cvGR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvGR: // global
           if (R1 & 7 == 1) goto cvGV; else goto cvGW;
       cvGV: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvGW: // global
           I64[Sp - 8] = block_cvH6_info;
           _sufN::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sufN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvHn; else goto cvH8;
       uvHn: // global
           call _cvH6(R1) args: 0, res: 0, upd: 0;
       cvH8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvH6() //  [R1]
         { info_tbl: [(cvH6,
                       label: block_cvH6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvH6: // global
           if (R1 & 7 == 1) goto cvHe; else goto cvHi;
       cvHe: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvHi: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cvGO() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.698871948 UTC

[section ""data" . GHC.List.reverse1_closure" {
     GHC.List.reverse1_closure:
         const GHC.List.reverse1_info;
 },
 GHC.List.reverse1_entry() //  [R2, R3]
         { info_tbl: [(cvHF,
                       label: GHC.List.reverse1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvHF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvHG; else goto uvHN;
       cvHG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.reverse1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvHN: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvHr() args: 0, res: 0, upd: 0;
     }
 },
 _cvHr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvHr: // global
           _sufP::P64 = P64[Sp];
           I64[Sp] = block_cvHu_info;
           R1 = _sufP::P64;
           if (R1 & 7 != 0) goto uvHP; else goto cvHv;
       uvHP: // global
           call _cvHu(R1) args: 0, res: 0, upd: 0;
       cvHv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvHu() //  [R1]
         { info_tbl: [(cvHu,
                       label: block_cvHu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvHu: // global
           _sufQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cvHC; else goto cvHD;
       cvHC: // global
           R1 = _sufQ::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvHD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvHM; else goto cvHL;
       cvHM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvHL: // global
           _sufS::P64 = P64[R1 + 6];
           _sufT::P64 = P64[R1 + 14];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sufS::P64;
           P64[Hp] = _sufQ::P64;
           P64[Sp] = _sufT::P64;
           P64[Sp + 8] = Hp - 14;
           call _cvHr() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.701137575 UTC

[section ""data" . GHC.List.reverse_closure" {
     GHC.List.reverse_closure:
         const GHC.List.reverse_info;
 },
 GHC.List.reverse_entry() //  [R2]
         { info_tbl: [(cvHW,
                       label: GHC.List.reverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvHW: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.703180013 UTC

[section ""data" . GHC.List.$wbreak_closure" {
     GHC.List.$wbreak_closure:
         const GHC.List.$wbreak_info;
 },
 ds_sug2_entry() //  [R1]
         { info_tbl: [(cvIk,
                       label: ds_sug2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvIk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvIl; else goto cvIm;
       cvIl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvIm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cvIh_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvIh() //  [R1, R2]
         { info_tbl: [(cvIh,
                       label: block_cvIh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvIh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvIp; else goto cvIo;
       cvIp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cvIo: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wbreak_entry() //  [R2, R3]
         { info_tbl: [(cvIu,
                       label: GHC.List.$wbreak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvIu: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvIv; else goto cvIw;
       cvIv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wbreak_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvIw: // global
           I64[Sp - 16] = block_cvI3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvIN; else goto cvI4;
       uvIN: // global
           call _cvI3(R1) args: 0, res: 0, upd: 0;
       cvI4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvI3() //  [R1]
         { info_tbl: [(cvI3,
                       label: block_cvI3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvI3: // global
           if (R1 & 7 == 1) goto cvIr; else goto cvIs;
       cvIr: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cvIs: // global
           I64[Sp - 24] = block_cvI9_info;
           _sufZ::P64 = P64[R1 + 6];
           R2 = _sufZ::P64;
           _sufY::P64 = R1;
           _sug0::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sufZ::P64;
           P64[Sp - 8] = _sug0::P64;
           P64[Sp] = _sufY::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvI9() //  [R1]
         { info_tbl: [(cvI9,
                       label: block_cvI9_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvI9: // global
           if (R1 & 7 == 1) goto cvIE; else goto cvIL;
       cvIE: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cvIH; else goto cvIG;
       cvIH: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvIG: // global
           I64[Hp - 96] = ds_sug2_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cvId::P64 = Hp - 96;
           P64[Hp - 48] = _cvId::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cvId::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cvIL: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.706663513 UTC

[section ""data" . GHC.List.break_closure" {
     GHC.List.break_closure:
         const GHC.List.break_info;
 },
 GHC.List.break_entry() //  [R2, R3]
         { info_tbl: [(cvIV,
                       label: GHC.List.break_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvIV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvIW; else goto cvIX;
       cvIW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.break_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvIX: // global
           I64[Sp - 8] = block_cvIS_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvIS() //  [R1, R2]
         { info_tbl: [(cvIS,
                       label: block_cvIS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvIS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvJ0; else goto cvIZ;
       cvJ0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cvIZ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.709457064 UTC

[section ""data" . GHC.List.$wspan_closure" {
     GHC.List.$wspan_closure:
         const GHC.List.$wspan_info;
 },
 ds_sugq_entry() //  [R1]
         { info_tbl: [(cvJn,
                       label: ds_sugq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvJn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvJo; else goto cvJp;
       cvJo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvJp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cvJk_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvJk() //  [R1, R2]
         { info_tbl: [(cvJk,
                       label: block_cvJk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvJk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvJs; else goto cvJr;
       cvJs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cvJr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wspan_entry() //  [R2, R3]
         { info_tbl: [(cvJx,
                       label: GHC.List.$wspan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvJx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvJy; else goto cvJz;
       cvJy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wspan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvJz: // global
           I64[Sp - 16] = block_cvJ5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvJP; else goto cvJ6;
       uvJP: // global
           call _cvJ5(R1) args: 0, res: 0, upd: 0;
       cvJ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvJ5() //  [R1]
         { info_tbl: [(cvJ5,
                       label: block_cvJ5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvJ5: // global
           if (R1 & 7 == 1) goto cvJu; else goto cvJv;
       cvJu: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cvJv: // global
           I64[Sp - 24] = block_cvJb_info;
           _sugn::P64 = P64[R1 + 6];
           R2 = _sugn::P64;
           _sugm::P64 = R1;
           _sugo::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sugn::P64;
           P64[Sp - 8] = _sugo::P64;
           P64[Sp] = _sugm::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvJb() //  [R1]
         { info_tbl: [(cvJb,
                       label: block_cvJb_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvJb: // global
           if (R1 & 7 == 1) goto cvJG; else goto cvJK;
       cvJG: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cvJK: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cvJN; else goto cvJM;
       cvJN: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvJM: // global
           I64[Hp - 96] = ds_sugq_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cvJg::P64 = Hp - 96;
           P64[Hp - 48] = _cvJg::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cvJg::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.713909377 UTC

[section ""data" . GHC.List.span_closure" {
     GHC.List.span_closure:
         const GHC.List.span_info;
 },
 GHC.List.span_entry() //  [R2, R3]
         { info_tbl: [(cvJX,
                       label: GHC.List.span_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvJX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvJY; else goto cvJZ;
       cvJY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.span_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvJZ: // global
           I64[Sp - 8] = block_cvJU_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvJU() //  [R1, R2]
         { info_tbl: [(cvJU,
                       label: block_cvJU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvJU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvK2; else goto cvK1;
       cvK2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cvK1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.715992478 UTC

[section ""data" . GHC.List.takeFB_closure" {
     GHC.List.takeFB_closure:
         const GHC.List.takeFB_info;
 },
 sat_sugS_entry() //  [R1]
         { info_tbl: [(cvKk,
                       label: sat_sugS_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvKk: // global
           _sugS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cvKn; else goto cvKo;
       cvKo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cvKq; else goto cvKp;
       cvKq: // global
           HpAlloc = 16;
           goto cvKn;
       cvKn: // global
           R1 = _sugS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvKp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sugS::P64;
           _sugL::P64 = P64[_sugS::P64 + 16];
           _sugQ::I64 = I64[_sugS::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sugQ::I64;
           R2 = Hp - 7;
           R1 = _sugL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.takeFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cvKr,
                       label: GHC.List.takeFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvKr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvKs; else goto cvKt;
       cvKs: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvKt: // global
           I64[Sp - 40] = block_cvK7_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uvKA; else goto cvK8;
       uvKA: // global
           call _cvK7(R1) args: 0, res: 0, upd: 0;
       cvK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvK7() //  [R1]
         { info_tbl: [(cvK7,
                       label: block_cvK7_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvK7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvKw; else goto cvKv;
       cvKw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvKv: // global
           _sugI::P64 = P64[Sp + 8];
           _sugK::P64 = P64[Sp + 24];
           _sugP::I64 = I64[R1 + 7];
           if (_sugP::I64 != 1) goto cvKy; else goto cvKz;
       cvKy: // global
           I64[Hp - 24] = sat_sugS_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = _sugP::I64;
           R3 = Hp - 24;
           R2 = _sugK::P64;
           R1 = _sugI::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvKz: // global
           Hp = Hp - 32;
           R3 = P64[Sp + 16];
           R2 = _sugK::P64;
           R1 = _sugI::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.718718349 UTC

[section ""data" . GHC.List.flipSeqTake_closure" {
     GHC.List.flipSeqTake_closure:
         const GHC.List.flipSeqTake_info;
 },
 GHC.List.flipSeqTake_entry() //  [R2, R3]
         { info_tbl: [(cvKI,
                       label: GHC.List.flipSeqTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvKI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvKJ; else goto cvKK;
       cvKJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvKK: // global
           I64[Sp - 16] = block_cvKF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvKO; else goto cvKG;
       uvKO: // global
           call _cvKF() args: 0, res: 0, upd: 0;
       cvKG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvKF() //  []
         { info_tbl: [(cvKF,
                       label: block_cvKF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvKF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.720796035 UTC

[section ""data" . GHC.List.$wunsafeTake_closure" {
     GHC.List.$wunsafeTake_closure:
         const GHC.List.$wunsafeTake_info;
 },
 sat_suh4_entry() //  [R1]
         { info_tbl: [(cvL7,
                       label: sat_suh4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvL7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvL8; else goto cvL9;
       cvL8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvL9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24] - 1;
           Sp = Sp - 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wunsafeTake_entry() //  [R2, R3]
         { info_tbl: [(cvLe,
                       label: GHC.List.$wunsafeTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvLe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvLf; else goto cvLg;
       cvLf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wunsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvLg: // global
           I64[Sp - 16] = block_cvKT_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvLs; else goto cvKU;
       uvLs: // global
           call _cvKT(R1) args: 0, res: 0, upd: 0;
       cvKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvKT() //  [R1]
         { info_tbl: [(cvKT,
                       label: block_cvKT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvKT: // global
           if (R1 & 7 == 1) goto cvLb; else goto cvLc;
       cvLb: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvLc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cvLl; else goto cvLk;
       cvLl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvLk: // global
           _suh0::P64 = P64[R1 + 6];
           _suh2::I64 = I64[Sp + 8];
           if (_suh2::I64 != 1) goto cvLo; else goto cvLr;
       cvLo: // global
           _suh1::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_suh4_info;
           P64[Hp - 32] = _suh1::P64;
           I64[Hp - 24] = _suh2::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suh0::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvLr: // global
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = _suh0::P64;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cvLq::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cvLq::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.723159989 UTC

[section ""data" . GHC.List.unsafeTake_closure" {
     GHC.List.unsafeTake_closure:
         const GHC.List.unsafeTake_info;
 },
 GHC.List.unsafeTake_entry() //  [R2, R3]
         { info_tbl: [(cvLA,
                       label: GHC.List.unsafeTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvLA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvLB; else goto cvLC;
       cvLB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.unsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvLC: // global
           I64[Sp - 16] = block_cvLx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvLG; else goto cvLy;
       uvLG: // global
           call _cvLx(R1) args: 0, res: 0, upd: 0;
       cvLy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvLx() //  [R1]
         { info_tbl: [(cvLx,
                       label: block_cvLx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvLx: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.72445181 UTC

[section ""data" . GHC.List.take_closure" {
     GHC.List.take_closure:
         const GHC.List.take_info;
 },
 GHC.List.take_entry() //  [R2, R3]
         { info_tbl: [(cvLO,
                       label: GHC.List.take_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvLO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvLP; else goto cvLQ;
       cvLP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.take_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvLQ: // global
           I64[Sp - 16] = block_cvLL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvLZ; else goto cvLM;
       uvLZ: // global
           call _cvLL(R1) args: 0, res: 0, upd: 0;
       cvLM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvLL() //  [R1]
         { info_tbl: [(cvLL,
                       label: block_cvLL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvLL: // global
           _suhc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _suhc::I64)) goto cvLX; else goto cvLY;
       cvLX: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvLY: // global
           R3 = P64[Sp + 8];
           R2 = _suhc::I64;
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.726063201 UTC

[section ""data" . GHC.List.dropWhile_closure" {
     GHC.List.dropWhile_closure:
         const GHC.List.dropWhile_info;
 },
 GHC.List.dropWhile_entry() //  [R2, R3]
         { info_tbl: [(cvMb,
                       label: GHC.List.dropWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvMb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvMc; else goto uvMw;
       cvMc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.dropWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uvMw: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cvM1() args: 0, res: 0, upd: 0;
     }
 },
 _cvM1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvM1: // global
           I64[Sp - 8] = block_cvM4_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvMy; else goto cvM5;
       uvMy: // global
           call _cvM4(R1) args: 0, res: 0, upd: 0;
       cvM5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvM4() //  [R1]
         { info_tbl: [(cvM4,
                       label: block_cvM4_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvM4: // global
           if (R1 & 7 == 1) goto cvM8; else goto cvM9;
       cvM8: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvM9: // global
           I64[Sp - 8] = block_cvMj_info;
           R2 = P64[R1 + 6];
           _suhg::P64 = R1;
           _suhi::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _suhi::P64;
           P64[Sp + 16] = _suhg::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvMj() //  [R1]
         { info_tbl: [(cvMj,
                       label: block_cvMj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvMj: // global
           if (R1 & 7 == 1) goto cvMq; else goto cvMu;
       cvMq: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cvMu: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cvM1() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.727753807 UTC

[section ""data" . GHC.List.takeWhileFB_closure" {
     GHC.List.takeWhileFB_closure:
         const GHC.List.takeWhileFB_info;
 },
 GHC.List.takeWhileFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cvML,
                       label: GHC.List.takeWhileFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvML: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvMM; else goto cvMN;
       cvMM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhileFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvMN: // global
           I64[Sp - 40] = block_cvMF_info;
           _suhk::P64 = R2;
           R2 = R5;
           R1 = _suhk::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvMF() //  [R1]
         { info_tbl: [(cvMF,
                       label: block_cvMF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvMF: // global
           if (R1 & 7 == 1) goto cvMI; else goto cvMJ;
       cvMI: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvMJ: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.729599495 UTC

[section ""data" . GHC.List.takeWhile_closure" {
     GHC.List.takeWhile_closure:
         const GHC.List.takeWhile_info;
 },
 sat_suhw_entry() //  [R1]
         { info_tbl: [(cvNd,
                       label: sat_suhw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvNd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvNe; else goto cvNf;
       cvNe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvNf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.takeWhile_entry() //  [R2, R3]
         { info_tbl: [(cvNk,
                       label: GHC.List.takeWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvNk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvNl; else goto cvNm;
       cvNl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvNm: // global
           I64[Sp - 16] = block_cvMY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvNE; else goto cvMZ;
       uvNE: // global
           call _cvMY(R1) args: 0, res: 0, upd: 0;
       cvMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvMY() //  [R1]
         { info_tbl: [(cvMY,
                       label: block_cvMY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvMY: // global
           if (R1 & 7 == 1) goto uvNA; else goto cvNi;
       uvNA: // global
           Sp = Sp + 16;
           call _cvNt() args: 0, res: 0, upd: 0;
       cvNi: // global
           I64[Sp - 16] = block_cvN4_info;
           _suht::P64 = P64[R1 + 6];
           R2 = _suht::P64;
           _suhu::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _suhu::P64;
           P64[Sp] = _suht::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvN4() //  [R1]
         { info_tbl: [(cvN4,
                       label: block_cvN4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvN4: // global
           if (R1 & 7 == 1) goto uvNB; else goto cvNv;
       uvNB: // global
           Sp = Sp + 32;
           call _cvNt() args: 0, res: 0, upd: 0;
       cvNv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cvNy; else goto cvNx;
       cvNy: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvNx: // global
           I64[Hp - 48] = sat_suhw_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cvNt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvNt: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.732394062 UTC

[section ""data" . GHC.List.repeat_closure" {
     GHC.List.repeat_closure:
         const GHC.List.repeat_info;
 },
 GHC.List.repeat_entry() //  [R2]
         { info_tbl: [(cvNK,
                       label: GHC.List.repeat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvNK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvNO; else goto cvNN;
       cvNO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.List.repeat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvNN: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           _cvNJ::P64 = Hp - 14;
           P64[Hp] = _cvNJ::P64;
           R1 = _cvNJ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.repeatFB_closure" {
     GHC.List.repeatFB_closure:
         const GHC.List.repeatFB_info;
 },
 GHC.List.repeatFB_entry() //  [R2, R3]
         { info_tbl: [(cvNU,
                       label: GHC.List.repeatFB_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvNU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvNY; else goto cvNX;
       cvNY: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.repeatFB_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvNX: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           _cvNT::P64 = Hp - 32;
           P64[Hp] = _cvNT::P64;
           R1 = _cvNT::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.734412719 UTC

[section ""data" . GHC.List.replicate_closure" {
     GHC.List.replicate_closure:
         const GHC.List.replicate_info;
 },
 sat_suhM_entry() //  [R1]
         { info_tbl: [(cvOq,
                       label: sat_suhM_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvOq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvOr; else goto cvOs;
       cvOr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvOs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_suhI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_suhI_entry() //  [R1, R2]
         { info_tbl: [(cvOw,
                       label: $wxs_suhI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvOw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cvOA; else goto cvOz;
       cvOA: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvOz: // global
           if (R2 == 1) goto cvOv; else goto cvOu;
       cvOv: // global
           _suhH::P64 = P64[R1 + 15];
           Hp = Hp - 56;
           R1 = _suhH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvOu: // global
           _suhD::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_suhM_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suhD::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.replicate_entry() //  [R2, R3]
         { info_tbl: [(cvOC,
                       label: GHC.List.replicate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvOC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvOD; else goto cvOE;
       cvOD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.replicate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvOE: // global
           I64[Sp - 16] = block_cvO3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvOL; else goto cvO4;
       uvOL: // global
           call _cvO3(R1) args: 0, res: 0, upd: 0;
       cvO4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvO3() //  [R1]
         { info_tbl: [(cvO3,
                       label: block_cvO3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvO3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cvOH; else goto cvOG;
       cvOH: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvOG: // global
           _suhF::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _suhF::I64)) goto cvOJ; else goto cvOK;
       cvOJ: // global
           Hp = Hp - 48;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvOK: // global
           I64[Hp - 40] = :_con_info;
           _suhD::P64 = P64[Sp + 8];
           P64[Hp - 32] = _suhD::P64;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = $wxs_suhI_info;
           P64[Hp - 8] = _suhD::P64;
           P64[Hp] = Hp - 38;
           R2 = _suhF::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call $wxs_suhI_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.736734844 UTC

[section ""data" . GHC.List.$witerate'_closure" {
     GHC.List.$witerate'_closure:
         const GHC.List.$witerate'_info;
 },
 sat_suhT_entry() //  [R1]
         { info_tbl: [(cvOZ,
                       label: sat_suhT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvOZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvP0; else goto cvP1;
       cvP0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvP1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cvOW_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvOW() //  [R1, R2]
         { info_tbl: [(cvOW,
                       label: block_cvOW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvOW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvP4; else goto cvP3;
       cvP4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cvP3: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$witerate'_entry() //  [R2, R3]
         { info_tbl: [(cvP5,
                       label: GHC.List.$witerate'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvP5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvP6; else goto cvP7;
       cvP6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvP7: // global
           I64[Sp - 24] = block_cvOQ_info;
           _suhN::P64 = R2;
           R2 = R3;
           R1 = _suhN::P64;
           P64[Sp - 16] = _suhN::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvOQ() //  [R1]
         { info_tbl: [(cvOQ,
                       label: block_cvOQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvOQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvPa; else goto cvP9;
       cvPa: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvP9: // global
           I64[Hp - 24] = sat_suhT_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = Hp - 24;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.738975508 UTC

[section ""data" . GHC.List.iterate'FB_closure" {
     GHC.List.iterate'FB_closure:
         const GHC.List.iterate'FB_info;
 },
 go2_suhX_entry() //  [R1, R2]
         { info_tbl: [(cvPn,
                       label: go2_suhX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvPn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvPo; else goto cvPp;
       cvPo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvPp: // global
           I64[Sp - 32] = block_cvPk_info;
           _suhY::P64 = R2;
           R2 = R2;
           _suhX::P64 = R1;
           _suhU::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 24] = _suhU::P64;
           P64[Sp - 16] = _suhX::P64;
           P64[Sp - 8] = _suhY::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvPk() //  [R1]
         { info_tbl: [(cvPk,
                       label: block_cvPk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvPk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvPs; else goto cvPr;
       cvPs: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvPr: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.iterate'FB_entry() //  [R2, R3, R4]
         { info_tbl: [(cvPt,
                       label: GHC.List.iterate'FB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvPt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvPx; else goto cvPw;
       cvPx: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'FB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvPw: // global
           I64[Hp - 16] = go2_suhX_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_suhX_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.iterate'_closure" {
     GHC.List.iterate'_closure:
         const GHC.List.iterate'_info;
 },
 GHC.List.iterate'_entry() //  [R2, R3]
         { info_tbl: [(cvPF,
                       label: GHC.List.iterate'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvPF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvPG; else goto cvPH;
       cvPG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvPH: // global
           I64[Sp - 8] = block_cvPC_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvPC() //  [R1, R2]
         { info_tbl: [(cvPC,
                       label: block_cvPC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvPC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvPK; else goto cvPJ;
       cvPK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cvPJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.741355487 UTC

[section ""data" . GHC.List.$witerate_closure" {
     GHC.List.$witerate_closure:
         const GHC.List.$witerate_info;
 },
 sat_suic_entry() //  [R1]
         { info_tbl: [(cvPX,
                       label: sat_suic_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvPX: // global
           _suic::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cvPY; else goto cvPZ;
       cvPZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvQ1; else goto cvQ0;
       cvQ1: // global
           HpAlloc = 32;
           goto cvPY;
       cvPY: // global
           R1 = _suic::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvQ0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suic::P64;
           _sui6::P64 = P64[_suic::P64 + 16];
           _sui7::P64 = P64[_suic::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sui6::P64;
           P64[Hp] = _sui7::P64;
           I64[Sp - 24] = block_cvPU_info;
           R3 = Hp - 24;
           R2 = _sui6::P64;
           Sp = Sp - 24;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvPU() //  [R1, R2]
         { info_tbl: [(cvPU,
                       label: block_cvPU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvPU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvQ4; else goto cvQ3;
       cvQ4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cvQ3: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$witerate_entry() //  [R2, R3]
         { info_tbl: [(cvQ5,
                       label: GHC.List.$witerate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvQ5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvQ9; else goto cvQ8;
       cvQ9: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvQ8: // global
           I64[Hp - 24] = sat_suic_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.743518356 UTC

[section ""data" . GHC.List.iterateFB_closure" {
     GHC.List.iterateFB_closure:
         const GHC.List.iterateFB_info;
 },
 sat_suij_entry() //  [R1]
         { info_tbl: [(cvQo,
                       label: sat_suij_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvQo: // global
           _suij::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cvQp; else goto cvQq;
       cvQq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvQs; else goto cvQr;
       cvQs: // global
           HpAlloc = 32;
           goto cvQp;
       cvQp: // global
           R1 = _suij::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvQr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suij::P64;
           _suie::P64 = P64[_suij::P64 + 16];
           _suig::P64 = P64[_suij::P64 + 24];
           _suih::P64 = P64[_suij::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _suie::P64;
           P64[Hp] = _suih::P64;
           R2 = Hp - 24;
           R1 = _suig::P64;
           Sp = Sp - 16;
           call go2_suig_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go2_suig_entry() //  [R1, R2]
         { info_tbl: [(cvQt,
                       label: go2_suig_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvQt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvQx; else goto cvQw;
       cvQx: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvQw: // global
           _suid::P64 = P64[R1 + 7];
           _suie::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_suij_info;
           P64[Hp - 16] = _suie::P64;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = R2;
           R1 = _suid::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.iterateFB_entry() //  [R2, R3, R4]
         { info_tbl: [(cvQy,
                       label: GHC.List.iterateFB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvQy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvQC; else goto cvQB;
       cvQC: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterateFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvQB: // global
           I64[Hp - 16] = go2_suig_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_suig_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.iterate_closure" {
     GHC.List.iterate_closure:
         const GHC.List.iterate_info;
 },
 GHC.List.iterate_entry() //  [R2, R3]
         { info_tbl: [(cvQK,
                       label: GHC.List.iterate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvQK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvQL; else goto cvQM;
       cvQL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvQM: // global
           I64[Sp - 8] = block_cvQH_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvQH() //  [R1, R2]
         { info_tbl: [(cvQH,
                       label: block_cvQH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvQH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvQP; else goto cvQO;
       cvQP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cvQO: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.745542917 UTC

[section ""cstring" . lvl27_ru9o_bytes" {
     lvl27_ru9o_bytes:
         I8[] [71,72,67,47,76,105,115,116,46,104,115,58,52,49,49,58,51,52,45,53,53,124,113,115,64,40,113,32,58,32,95,41]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.746998621 UTC

[section ""data" . lvl28_ru9p_closure" {
     lvl28_ru9p_closure:
         const lvl28_ru9p_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_ru9p_entry() //  [R1]
         { info_tbl: [(cvQW,
                       label: lvl28_ru9p_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvQW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvQX; else goto cvQY;
       cvQX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvQY: // global
           (_cvQT::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvQT::I64 == 0) goto cvQV; else goto cvQU;
       cvQV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvQU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvQT::I64;
           R2 = lvl27_ru9o_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.748968211 UTC

[section ""data" . GHC.List.scanr1_closure" {
     GHC.List.scanr1_closure:
         const GHC.List.scanr1_info;
         const 0;
 },
 ds3_suix_entry() //  [R1]
         { info_tbl: [(cvRp,
                       label: ds3_suix_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvRp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvRq; else goto cvRr;
       cvRq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvRr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cvRj_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.scanr1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvRj() //  [R1]
         { info_tbl: [(cvRj,
                       label: block_cvRj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvRj: // global
           if (R1 & 7 == 1) goto cvRm; else goto cvRn;
       cvRm: // global
           R1 = lvl28_ru9p_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cvRn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvRA; else goto cvRz;
       cvRA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cvRz: // global
           _suiz::P64 = P64[R1 + 6];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _suiz::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_suiF_entry() //  [R1]
         { info_tbl: [(cvRH,
                       label: sat_suiF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvRH: // global
           _suiF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cvRI; else goto cvRJ;
       cvRJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvRL; else goto cvRK;
       cvRL: // global
           HpAlloc = 24;
           goto cvRI;
       cvRI: // global
           R1 = _suiF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvRK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suiF::P64;
           _suip::P64 = P64[_suiF::P64 + 16];
           _suis::P64 = P64[_suiF::P64 + 24];
           _suix::P64 = P64[_suiF::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _suix::P64;
           R3 = Hp - 16;
           R2 = _suis::P64;
           R1 = _suip::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.scanr1_entry() //  [R2, R3]
         { info_tbl: [(cvRQ,
                       label: GHC.List.scanr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvRQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvRR; else goto cvRS;
       cvRR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvRS: // global
           I64[Sp - 16] = block_cvR3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvSa; else goto cvR4;
       uvSa: // global
           call _cvR3(R1) args: 0, res: 0, upd: 0;
       cvR4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvR3() //  [R1]
         { info_tbl: [(cvR3,
                       label: block_cvR3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvR3: // global
           if (R1 & 7 == 1) goto cvRN; else goto cvRO;
       cvRN: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvRO: // global
           I64[Sp - 8] = block_cvR9_info;
           _suis::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _suis::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvS9; else goto cvRa;
       uvS9: // global
           call _cvR9(R1) args: 0, res: 0, upd: 0;
       cvRa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvR9() //  [R1]
         { info_tbl: [(cvR9,
                       label: block_cvR9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvR9: // global
           _suis::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cvRZ; else goto cvS4;
       cvRZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvS2; else goto cvS1;
       cvS2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvS1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suis::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvS4: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cvS7; else goto cvS6;
       cvS7: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvS6: // global
           I64[Hp - 112] = ds3_suix_info;
           _suip::P64 = P64[Sp + 16];
           P64[Hp - 96] = _suip::P64;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = stg_sel_0_upd_info;
           _cvRf::P64 = Hp - 112;
           P64[Hp - 64] = _cvRf::P64;
           I64[Hp - 56] = sat_suiF_info;
           P64[Hp - 40] = _suip::P64;
           P64[Hp - 32] = _suis::P64;
           P64[Hp - 24] = _cvRf::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.751952099 UTC

[section ""data" . GHC.List.scanrFB_closure" {
     GHC.List.scanrFB_closure:
         const GHC.List.scanrFB_info;
 },
 GHC.List.scanrFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cvSi,
                       label: GHC.List.scanrFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvSi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvSo; else goto cvSp;
       cvSo: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanrFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvSp: // global
           I64[Sp - 32] = block_cvSf_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uvSt; else goto cvSg;
       uvSt: // global
           call _cvSf(R1) args: 0, res: 0, upd: 0;
       cvSg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvSf() //  [R1]
         { info_tbl: [(cvSf,
                       label: block_cvSf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvSf: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cvSs; else goto cvSr;
       cvSs: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvSr: // global
           _suiP::P64 = P64[R1 + 7];
           _suiQ::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _suiP::P64;
           P64[Hp - 64] = _suiQ::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _suiP::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.754209648 UTC

[section ""data" . GHC.List.$wscanr_closure" {
     GHC.List.$wscanr_closure:
         const GHC.List.$wscanr_info;
 },
 ds_suiZ_entry() //  [R1]
         { info_tbl: [(cvSM,
                       label: ds_suiZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvSM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvSN; else goto cvSO;
       cvSN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvSO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cvSI_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvSI() //  [R1, R2]
         { info_tbl: [(cvSI,
                       label: block_cvSI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvSI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cvSR; else goto cvSQ;
       cvSR: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cvSQ: // global
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_suj8_entry() //  [R1]
         { info_tbl: [(cvSY,
                       label: sat_suj8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvSY: // global
           _suj8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cvSZ; else goto cvT0;
       cvT0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvT2; else goto cvT1;
       cvT2: // global
           HpAlloc = 24;
           goto cvSZ;
       cvSZ: // global
           R1 = _suj8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvT1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suj8::P64;
           _suiT::P64 = P64[_suj8::P64 + 16];
           _suiX::P64 = P64[_suj8::P64 + 24];
           _suiZ::P64 = P64[_suj8::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _suiZ::P64;
           R3 = Hp - 16;
           R2 = _suiX::P64;
           R1 = _suiT::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanr_entry() //  [R2, R3, R4]
         { info_tbl: [(cvT7,
                       label: GHC.List.$wscanr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvT7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvT8; else goto cvT9;
       cvT8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvT9: // global
           I64[Sp - 24] = block_cvSy_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uvTf; else goto cvSz;
       uvTf: // global
           call _cvSy(R1) args: 0, res: 0, upd: 0;
       cvSz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvSy() //  [R1]
         { info_tbl: [(cvSy,
                       label: block_cvSy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvSy: // global
           _suiU::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cvT4; else goto cvT5;
       cvT4: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _suiU::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cvT5: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cvTe; else goto cvTd;
       cvTe: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvTd: // global
           _suiX::P64 = P64[R1 + 6];
           _suiY::P64 = P64[R1 + 14];
           I64[Hp - 96] = ds_suiZ_info;
           _suiT::P64 = P64[Sp + 8];
           P64[Hp - 80] = _suiT::P64;
           P64[Hp - 72] = _suiU::P64;
           P64[Hp - 64] = _suiY::P64;
           I64[Hp - 56] = stg_sel_0_upd_info;
           _cvSE::P64 = Hp - 96;
           P64[Hp - 40] = _cvSE::P64;
           I64[Hp - 32] = sat_suj8_info;
           P64[Hp - 16] = _suiT::P64;
           P64[Hp - 8] = _suiX::P64;
           P64[Hp] = _cvSE::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.756909646 UTC

[section ""data" . GHC.List.strictUncurryScanr_closure" {
     GHC.List.strictUncurryScanr_closure:
         const GHC.List.strictUncurryScanr_info;
 },
 GHC.List.strictUncurryScanr_entry() //  [R2, R3]
         { info_tbl: [(cvTn,
                       label: GHC.List.strictUncurryScanr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvTn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvTo; else goto cvTp;
       cvTo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.strictUncurryScanr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvTp: // global
           I64[Sp - 16] = block_cvTk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvTt; else goto cvTl;
       uvTt: // global
           call _cvTk(R1) args: 0, res: 0, upd: 0;
       cvTl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvTk() //  [R1]
         { info_tbl: [(cvTk,
                       label: block_cvTk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvTk: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.scanr_closure" {
     GHC.List.scanr_closure:
         const GHC.List.scanr_info;
 },
 GHC.List.scanr_entry() //  [R2, R3, R4]
         { info_tbl: [(cvTB,
                       label: GHC.List.scanr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvTB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvTC; else goto cvTD;
       cvTC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvTD: // global
           I64[Sp - 8] = block_cvTy_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvTy() //  [R1, R2]
         { info_tbl: [(cvTy,
                       label: block_cvTy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvTy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvTG; else goto cvTF;
       cvTG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cvTF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.758651975 UTC

[section ""data" . GHC.List.flipSeqScanl'_closure" {
     GHC.List.flipSeqScanl'_closure:
         const GHC.List.flipSeqScanl'_info;
 },
 GHC.List.flipSeqScanl'_entry() //  [R2, R3]
         { info_tbl: [(cvTN,
                       label: GHC.List.flipSeqScanl'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvTN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvTO; else goto cvTP;
       cvTO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqScanl'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvTP: // global
           I64[Sp - 16] = block_cvTL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvTL() //  []
         { info_tbl: [(cvTL,
                       label: block_cvTL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvTL: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.759819508 UTC

[section ""data" . GHC.List.scanlFB'_closure" {
     GHC.List.scanlFB'_closure:
         const GHC.List.scanlFB'_info;
 },
 GHC.List.scanlFB'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cvTY,
                       label: GHC.List.scanlFB'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvTY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvTZ; else goto cvU0;
       cvTZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvU0: // global
           I64[Sp - 24] = block_cvTV_info;
           _sujs::P64 = R3;
           R3 = R4;
           _sujr::P64 = R2;
           R2 = R6;
           R1 = _sujr::P64;
           P64[Sp - 16] = _sujs::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvTV() //  [R1]
         { info_tbl: [(cvTV,
                       label: block_cvTV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvTV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cvU3; else goto cvU2;
       cvU3: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvU2: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.761886966 UTC

[section ""data" . GHC.List.$wscanlGo'_closure" {
     GHC.List.$wscanlGo'_closure:
         const GHC.List.$wscanlGo'_info;
 },
 sat_sujJ_entry() //  [R1]
         { info_tbl: [(cvUl,
                       label: sat_sujJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvUl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvUm; else goto cvUn;
       cvUm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvUn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cvUe_info;
           _sujy::P64 = P64[R1 + 16];
           _sujB::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sujy::P64;
           P64[Sp - 24] = _sujB::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uvUD; else goto cvUf;
       uvUD: // global
           call _cvUe(R1) args: 0, res: 0, upd: 0;
       cvUf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cvUe() //  [R1]
         { info_tbl: [(cvUe,
                       label: block_cvUe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvUe: // global
           if (R1 & 7 == 1) goto cvUi; else goto cvUj;
       cvUi: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cvUj: // global
           I64[Sp] = block_cvUt_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           _sujE::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sujE::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cvUt() //  [R1]
         { info_tbl: [(cvUt,
                       label: block_cvUt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvUt: // global
           _sujE::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cvUv_info;
           R4 = _sujE::P64;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanlGo'_entry(R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvUv() //  [R1, R2]
         { info_tbl: [(cvUv,
                       label: block_cvUv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvUv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvUC; else goto cvUB;
       cvUC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cvUB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanlGo'_entry() //  [R2, R3, R4]
         { info_tbl: [(cvUE,
                       label: GHC.List.$wscanlGo'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvUE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvUF; else goto cvUG;
       cvUF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvUG: // global
           I64[Sp - 24] = block_cvU8_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvU8() //  [R1]
         { info_tbl: [(cvU8,
                       label: block_cvU8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvU8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvUJ; else goto cvUI;
       cvUJ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvUI: // global
           I64[Hp - 32] = sat_sujJ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = Hp - 32;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.764912535 UTC

[section ""data" . GHC.List.scanl'_scanlGo'_closure" {
     GHC.List.scanl'_scanlGo'_closure:
         const GHC.List.scanl'_scanlGo'_info;
 },
 GHC.List.scanl'_scanlGo'_entry() //  [R2, R3, R4]
         { info_tbl: [(cvUR,
                       label: GHC.List.scanl'_scanlGo'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvUR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvUS; else goto cvUT;
       cvUS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl'_scanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvUT: // global
           I64[Sp - 8] = block_cvUO_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo'_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvUO() //  [R1, R2]
         { info_tbl: [(cvUO,
                       label: block_cvUO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvUO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvUW; else goto cvUV;
       cvUW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cvUV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.766079268 UTC

[section ""data" . GHC.List.scanl'_closure" {
     GHC.List.scanl'_closure:
         const GHC.List.scanl'_info;
 },
 GHC.List.scanl'_entry() //  [R2, R3, R4]
         { info_tbl: [(cvV1,
                       label: GHC.List.scanl'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvV1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl'_scanlGo'_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.766916319 UTC

[section ""data" . GHC.List.constScanl_closure" {
     GHC.List.constScanl_closure:
         const GHC.List.constScanl_info;
 },
 GHC.List.constScanl_entry() //  [R2, R3]
         { info_tbl: [(cvV8,
                       label: GHC.List.constScanl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvV8: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.767837585 UTC

[section ""data" . GHC.List.scanlFB_closure" {
     GHC.List.scanlFB_closure:
         const GHC.List.scanlFB_info;
 },
 GHC.List.scanlFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cvVh,
                       label: GHC.List.scanlFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvVh: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cvVl; else goto cvVk;
       cvVl: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvVk: // global
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R6;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R5;
           _cvVf::P64 = Hp - 64;
           P64[Hp] = _cvVf::P64;
           _sujR::P64 = R3;
           R3 = Hp - 24;
           R2 = _cvVf::P64;
           R1 = _sujR::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.769471264 UTC

[section ""data" . GHC.List.$wscanlGo_closure" {
     GHC.List.$wscanlGo_closure:
         const GHC.List.$wscanlGo_info;
 },
 sat_suk7_entry() //  [R1]
         { info_tbl: [(cvVB,
                       label: sat_suk7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvVB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cvVC; else goto cvVD;
       cvVC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvVD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cvVu_info;
           _sujX::P64 = P64[R1 + 16];
           _sujY::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sujX::P64;
           P64[Sp - 24] = _sujY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uvVT; else goto cvVv;
       uvVT: // global
           call _cvVu(R1) args: 0, res: 0, upd: 0;
       cvVv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cvVu() //  [R1]
         { info_tbl: [(cvVu,
                       label: block_cvVu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvVu: // global
           if (R1 & 7 == 1) goto cvVy; else goto cvVz;
       cvVy: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cvVz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvVP; else goto cvVO;
       cvVP: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cvVO: // global
           _suk1::P64 = P64[R1 + 6];
           _suk2::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           _sujX::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sujX::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _suk1::P64;
           I64[Sp + 16] = block_cvVK_info;
           R4 = _suk2::P64;
           R3 = Hp - 32;
           R2 = _sujX::P64;
           Sp = Sp + 16;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvVK() //  [R1, R2]
         { info_tbl: [(cvVK,
                       label: block_cvVK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvVK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvVS; else goto cvVR;
       cvVS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cvVR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanlGo_entry() //  [R2, R3, R4]
         { info_tbl: [(cvVU,
                       label: GHC.List.$wscanlGo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvVU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvVY; else goto cvVX;
       cvVY: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvVX: // global
           I64[Hp - 32] = sat_suk7_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.771474294 UTC

[section ""data" . GHC.List.scanl_scanlGo_closure" {
     GHC.List.scanl_scanlGo_closure:
         const GHC.List.scanl_scanlGo_info;
 },
 GHC.List.scanl_scanlGo_entry() //  [R2, R3, R4]
         { info_tbl: [(cvW6,
                       label: GHC.List.scanl_scanlGo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvW6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cvW7; else goto cvW8;
       cvW7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl_scanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvW8: // global
           I64[Sp - 8] = block_cvW3_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cvW3() //  [R1, R2]
         { info_tbl: [(cvW3,
                       label: block_cvW3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvW3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cvWb; else goto cvWa;
       cvWb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cvWa: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.772644835 UTC

[section ""data" . GHC.List.scanl_closure" {
     GHC.List.scanl_closure:
         const GHC.List.scanl_info;
 },
 GHC.List.scanl_entry() //  [R2, R3, R4]
         { info_tbl: [(cvWg,
                       label: GHC.List.scanl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvWg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl_scanlGo_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.77393464 UTC

[section ""data" . GHC.List.scanl1_closure" {
     GHC.List.scanl1_closure:
         const GHC.List.scanl1_info;
 },
 sat_sukm_entry() //  [R1]
         { info_tbl: [(cvWz,
                       label: sat_sukm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvWz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cvWA; else goto cvWB;
       cvWA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvWB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cvWx_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cvWx() //  [R2]
         { info_tbl: [(cvWx,
                       label: block_cvWx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvWx: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.scanl1_entry() //  [R2, R3]
         { info_tbl: [(cvWH,
                       label: GHC.List.scanl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvWH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvWI; else goto cvWJ;
       cvWI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvWJ: // global
           I64[Sp - 16] = block_cvWn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvWQ; else goto cvWo;
       uvWQ: // global
           call _cvWn(R1) args: 0, res: 0, upd: 0;
       cvWo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvWn() //  [R1]
         { info_tbl: [(cvWn,
                       label: block_cvWn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvWn: // global
           if (R1 & 7 == 1) goto cvWE; else goto cvWF;
       cvWE: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cvWF: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cvWP; else goto cvWO;
       cvWP: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvWO: // global
           _sukh::P64 = P64[R1 + 6];
           _suki::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sukm_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sukh::P64;
           P64[Hp - 24] = _suki::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sukh::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.775969228 UTC

[section ""data" . GHC.List.foldl'_closure" {
     GHC.List.foldl'_closure:
         const GHC.List.foldl'_info;
 },
 GHC.List.foldl'_entry() //  [R2, R3, R4]
         { info_tbl: [(cvWX,
                       label: GHC.List.foldl'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvWX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvWY; else goto cvWZ;
       cvWY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvWZ: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cvX1() args: 0, res: 0, upd: 0;
     }
 },
 _cvX1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvX1: // global
           I64[Sp - 8] = block_cvX3_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvXq; else goto cvX5;
       uvXq: // global
           call _cvX3(R1) args: 0, res: 0, upd: 0;
       cvX5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvX3() //  [R1]
         { info_tbl: [(cvX3,
                       label: block_cvX3_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvX3: // global
           _suks::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cvXb; else goto cvXi;
       cvXb: // global
           R1 = _suks::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvXi: // global
           I64[Sp] = block_cvXe_info;
           _suku::P64 = P64[R1 + 6];
           _sukv::P64 = P64[R1 + 14];
           R1 = _suks::P64;
           P64[Sp + 16] = _sukv::P64;
           P64[Sp + 24] = _suku::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvXe() //  [R1]
         { info_tbl: [(cvXe,
                       label: block_cvXe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvXe: // global
           I64[Sp] = block_cvXg_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           R1 = P64[Sp + 8];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvXg() //  [R1]
         { info_tbl: [(cvXg,
                       label: block_cvXg_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvXg: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cvX1() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.777905944 UTC

[section ""data" . GHC.List.foldl1'_closure" {
     GHC.List.foldl1'_closure:
         const GHC.List.foldl1'_info;
         const 0;
 },
 GHC.List.foldl1'_entry() //  [R2, R3]
         { info_tbl: [(cvXD,
                       label: GHC.List.foldl1'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvXD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvXE; else goto cvXF;
       cvXE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvXF: // global
           I64[Sp - 16] = block_cvXw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvXM; else goto cvXx;
       uvXM: // global
           call _cvXw(R1) args: 0, res: 0, upd: 0;
       cvXx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvXw() //  [R1]
         { info_tbl: [(cvXw,
                       label: block_cvXw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvXw: // global
           if (R1 & 7 == 1) goto cvXA; else goto cvXB;
       cvXA: // global
           R1 = GHC.List.foldl1'1_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvXB: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl'_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.779690211 UTC

[section ""data" . sat_sukD_closure" {
     sat_sukD_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.780221535 UTC

[section ""data" . sat_sukE_closure" {
     sat_sukE_closure:
         const :_con_info;
         const sat_sukD_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.780977411 UTC

[section ""data" . lvl29_ru9q_closure" {
     lvl29_ru9q_closure:
         const lvl29_ru9q_info;
         const 0;
         const 0;
         const 0;
 },
 lvl29_ru9q_entry() //  [R1]
         { info_tbl: [(cvXT,
                       label: lvl29_ru9q_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvXT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvXU; else goto cvXV;
       cvXU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvXV: // global
           (_cvXQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvXQ::I64 == 0) goto cvXS; else goto cvXR;
       cvXS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvXR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvXQ::I64;
           R3 = sat_sukE_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.782109102 UTC

[section ""data" . lvl30_ru9r_closure" {
     lvl30_ru9r_closure:
         const lvl30_ru9r_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_ru9r_entry() //  [R1]
         { info_tbl: [(cvY2,
                       label: lvl30_ru9r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvY2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvY3; else goto cvY4;
       cvY3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvY4: // global
           (_cvXZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cvXZ::I64 == 0) goto cvY1; else goto cvY0;
       cvY1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cvY0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cvXZ::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.783521561 UTC

[section ""data" . GHC.List.foldl_closure" {
     GHC.List.foldl_closure:
         const GHC.List.foldl_info;
 },
 GHC.List.foldl_entry() //  [R2, R3, R4]
         { info_tbl: [(cvYl,
                       label: GHC.List.foldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvYl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvYm; else goto cvYn;
       cvYm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvYn: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cvYc() args: 0, res: 0, upd: 0;
     }
 },
 _cvYc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvYc: // global
           I64[Sp - 8] = block_cvYe_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uvYA; else goto cvYf;
       uvYA: // global
           call _cvYe(R1) args: 0, res: 0, upd: 0;
       cvYf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvYe() //  [R1]
         { info_tbl: [(cvYe,
                       label: block_cvYe_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvYe: // global
           _sukK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cvYs; else goto cvYt;
       cvYs: // global
           R1 = _sukK::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvYt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cvYw; else goto cvYv;
       cvYw: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cvYv: // global
           _sukM::P64 = P64[R1 + 6];
           _sukN::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sukK::P64;
           P64[Hp] = _sukM::P64;
           P64[Sp + 16] = _sukN::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call _cvYc() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.78527615 UTC

[section ""data" . GHC.List.sum_closure" {
     GHC.List.sum_closure:
         const GHC.List.sum_info;
         const 0;
 },
 sat_sukR_entry() //  [R1]
         { info_tbl: [(cvYL,
                       label: sat_sukR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvYL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvYM; else goto cvYN;
       cvYM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvYN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl30_ru9r_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sukQ_entry() //  [R1]
         { info_tbl: [(cvYS,
                       label: sat_sukQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvYS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvYT; else goto cvYU;
       cvYT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvYU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.sum_entry() //  [R2]
         { info_tbl: [(cvYV,
                       label: GHC.List.sum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvYV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cvYZ; else goto cvYY;
       cvYZ: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.sum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvYY: // global
           I64[Hp - 40] = sat_sukR_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sukQ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.786944139 UTC

[section ""data" . GHC.List.product_closure" {
     GHC.List.product_closure:
         const GHC.List.product_info;
         const 0;
 },
 sat_sukU_entry() //  [R1]
         { info_tbl: [(cvZ8,
                       label: sat_sukU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvZ8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvZ9; else goto cvZa;
       cvZ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvZa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl29_ru9q_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sukT_entry() //  [R1]
         { info_tbl: [(cvZf,
                       label: sat_sukT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvZf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvZg; else goto cvZh;
       cvZg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cvZh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.product_entry() //  [R2]
         { info_tbl: [(cvZi,
                       label: GHC.List.product_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvZi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cvZm; else goto cvZl;
       cvZm: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.product_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cvZl: // global
           I64[Hp - 40] = sat_sukU_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sukT_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.788558079 UTC

[section ""data" . GHC.List.foldl1_closure" {
     GHC.List.foldl1_closure:
         const GHC.List.foldl1_info;
         const 0;
 },
 GHC.List.foldl1_entry() //  [R2, R3]
         { info_tbl: [(cvZy,
                       label: GHC.List.foldl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvZy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cvZz; else goto cvZA;
       cvZz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cvZA: // global
           I64[Sp - 16] = block_cvZr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uvZH; else goto cvZs;
       uvZH: // global
           call _cvZr(R1) args: 0, res: 0, upd: 0;
       cvZs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvZr() //  [R1]
         { info_tbl: [(cvZr,
                       label: block_cvZr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvZr: // global
           if (R1 & 7 == 1) goto cvZv; else goto cvZw;
       cvZv: // global
           R1 = GHC.List.foldl2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvZw: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.789996342 UTC

[section ""data" . GHC.List.filterFB_closure" {
     GHC.List.filterFB_closure:
         const GHC.List.filterFB_info;
 },
 GHC.List.filterFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cvZS,
                       label: GHC.List.filterFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvZS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cvZT; else goto cvZU;
       cvZT: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filterFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cvZU: // global
           I64[Sp - 32] = block_cvZM_info;
           _sul0::P64 = R2;
           R2 = R4;
           R1 = R3;
           P64[Sp - 24] = _sul0::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cvZM() //  [R1]
         { info_tbl: [(cvZM,
                       label: block_cvZM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cvZM: // global
           _sul3::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cvZP; else goto cvZQ;
       cvZP: // global
           R1 = _sul3::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cvZQ: // global
           R3 = _sul3::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.791767655 UTC

[section ""data" . GHC.List.filter_closure" {
     GHC.List.filter_closure:
         const GHC.List.filter_info;
 },
 sat_sulb_entry() //  [R1]
         { info_tbl: [(cw0k,
                       label: sat_sulb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw0k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw0l; else goto cw0m;
       cw0l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw0m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.filter_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.filter_entry() //  [R2, R3]
         { info_tbl: [(cw0r,
                       label: GHC.List.filter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw0r: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cw0s; else goto uw0H;
       cw0s: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filter_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uw0H: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cw02() args: 0, res: 0, upd: 0;
     }
 },
 _cw02() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw02: // global
           I64[Sp - 8] = block_cw05_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uw0J; else goto cw06;
       uw0J: // global
           call _cw05(R1) args: 0, res: 0, upd: 0;
       cw06: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw05() //  [R1]
         { info_tbl: [(cw05,
                       label: block_cw05_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw05: // global
           if (R1 & 7 == 1) goto cw0o; else goto cw0p;
       cw0o: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cw0p: // global
           I64[Sp - 8] = block_cw0b_info;
           _sul8::P64 = P64[R1 + 6];
           R2 = _sul8::P64;
           _sul9::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sul9::P64;
           P64[Sp + 16] = _sul8::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw0b() //  [R1]
         { info_tbl: [(cw0b,
                       label: block_cw0b_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw0b: // global
           _sul5::P64 = P64[Sp + 16];
           _sul9::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cw0A; else goto cw0C;
       cw0A: // global
           P64[Sp + 16] = _sul5::P64;
           P64[Sp + 24] = _sul9::P64;
           Sp = Sp + 16;
           call _cw02() args: 0, res: 0, upd: 0;
       cw0C: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cw0F; else goto cw0E;
       cw0F: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cw0E: // global
           I64[Hp - 48] = sat_sulb_info;
           P64[Hp - 32] = _sul5::P64;
           P64[Hp - 24] = _sul9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.794745744 UTC

[section ""data" . GHC.List.idLength_closure" {
     GHC.List.idLength_closure:
         const GHC.List.idLength_info;
 },
 GHC.List.idLength_entry() //  [R2]
         { info_tbl: [(cw0Q,
                       label: GHC.List.idLength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw0Q: // global
           R2 = R2;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.795808471 UTC

[section ""data" . GHC.List.lengthFB_closure" {
     GHC.List.lengthFB_closure:
         const GHC.List.lengthFB_info;
 },
 GHC.List.lengthFB_entry() //  [R2, R3, R4]
         { info_tbl: [(cw10,
                       label: GHC.List.lengthFB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw10: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw17; else goto cw18;
       cw17: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lengthFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cw18: // global
           I64[Sp - 16] = block_cw0X_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uw1c; else goto cw0Y;
       uw1c: // global
           call _cw0X(R1) args: 0, res: 0, upd: 0;
       cw0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw0X() //  [R1]
         { info_tbl: [(cw0X,
                       label: block_cw0X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw0X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cw1b; else goto cw1a;
       cw1b: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cw1a: // global
           _sulh::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sulh::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.797412958 UTC

[section ""data" . GHC.List.$wlenAcc_closure" {
     GHC.List.$wlenAcc_closure:
         const GHC.List.$wlenAcc_info;
 },
 GHC.List.$wlenAcc_entry() //  [R2, R3]
         { info_tbl: [(cw1o,
                       label: GHC.List.$wlenAcc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw1o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw1p; else goto uw1y;
       cw1p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wlenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uw1y: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cw1e() args: 0, res: 0, upd: 0;
     }
 },
 _cw1e() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw1e: // global
           _sulj::P64 = P64[Sp];
           I64[Sp] = block_cw1h_info;
           R1 = _sulj::P64;
           if (R1 & 7 != 0) goto uw1A; else goto cw1i;
       uw1A: // global
           call _cw1h(R1) args: 0, res: 0, upd: 0;
       cw1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw1h() //  [R1]
         { info_tbl: [(cw1h,
                       label: block_cw1h_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw1h: // global
           _sulk::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cw1l; else goto cw1m;
       cw1l: // global
           R1 = _sulk::I64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cw1m: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _sulk::I64 + 1;
           call _cw1e() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.798853494 UTC

[section ""data" . GHC.List.lenAcc_closure" {
     GHC.List.lenAcc_closure:
         const GHC.List.lenAcc_info;
 },
 GHC.List.lenAcc_entry() //  [R2, R3]
         { info_tbl: [(cw1K,
                       label: GHC.List.lenAcc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw1K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw1S; else goto cw1T;
       cw1S: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw1T: // global
           I64[Sp - 16] = block_cw1H_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uw1Y; else goto cw1I;
       uw1Y: // global
           call _cw1H(R1) args: 0, res: 0, upd: 0;
       cw1I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw1H() //  [R1]
         { info_tbl: [(cw1H,
                       label: block_cw1H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw1H: // global
           _sulp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cw1N_info;
           R3 = I64[R1 + 7];
           R2 = _sulp::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cw1N() //  [R1]
         { info_tbl: [(cw1N,
                       label: block_cw1N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw1N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cw1X; else goto cw1W;
       cw1X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cw1W: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.800254213 UTC

[section ""data" . GHC.List.length_closure" {
     GHC.List.length_closure:
         const GHC.List.length_info;
 },
 GHC.List.length_entry() //  [R2]
         { info_tbl: [(cw25,
                       label: GHC.List.length_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw25: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cw29; else goto cw2a;
       cw29: // global
           R2 = R2;
           R1 = GHC.List.length_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cw2a: // global
           I64[Sp - 8] = block_cw23_info;
           R3 = 0;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cw23() //  [R1]
         { info_tbl: [(cw23,
                       label: block_cw23_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw23: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cw2d; else goto cw2c;
       cw2d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cw2c: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.801546831 UTC

[section ""data" . GHC.List.null_closure" {
     GHC.List.null_closure:
         const GHC.List.null_info;
 },
 GHC.List.null_entry() //  [R2]
         { info_tbl: [(cw2p,
                       label: GHC.List.null_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw2p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cw2q; else goto cw2r;
       cw2q: // global
           R2 = R2;
           R1 = GHC.List.null_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cw2r: // global
           I64[Sp - 8] = block_cw2i_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uw2y; else goto cw2j;
       uw2y: // global
           call _cw2i(R1) args: 0, res: 0, upd: 0;
       cw2j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw2i() //  [R1]
         { info_tbl: [(cw2i,
                       label: block_cw2i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw2i: // global
           if (R1 & 7 == 1) goto cw2m; else goto cw2n;
       cw2m: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cw2n: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.802870128 UTC

[section ""data" . GHC.List.uncons_closure" {
     GHC.List.uncons_closure:
         const GHC.List.uncons_info;
 },
 GHC.List.uncons_entry() //  [R2]
         { info_tbl: [(cw2K,
                       label: GHC.List.uncons_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw2K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cw2L; else goto cw2M;
       cw2L: // global
           R2 = R2;
           R1 = GHC.List.uncons_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cw2M: // global
           I64[Sp - 8] = block_cw2D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uw2X; else goto cw2E;
       uw2X: // global
           call _cw2D(R1) args: 0, res: 0, upd: 0;
       cw2E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw2D() //  [R1]
         { info_tbl: [(cw2D,
                       label: block_cw2D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw2D: // global
           if (R1 & 7 == 1) goto cw2H; else goto cw2I;
       cw2H: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cw2I: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cw2W; else goto cw2V;
       cw2W: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cw2V: // global
           _sulC::P64 = P64[R1 + 6];
           _sulD::P64 = P64[R1 + 14];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = _sulC::P64;
           P64[Hp - 16] = _sulD::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.804068707 UTC

[section ""relreadonly" . Supf_srt" {
     Supf_srt:
         const lvl1_ru8R_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.List.errorEmptyList_closure;
         const GHC.List.prel_list_str_closure;
         const lvl3_ru8T_closure;
         const GHC.List.!!2_closure;
         const GHC.List.!!1_closure;
         const poly_exit_ru8U_closure;
         const poly_$wgo_ru8V_closure;
         const GHC.List.negIndex_closure;
         const GHC.List.!!_closure;
         const GHC.List.$w!!_closure;
         const lvl5_ru8X_closure;
         const GHC.List.cycle_closure;
         const GHC.List.cycle1_closure;
         const lvl7_ru8Z_closure;
         const lvl8_ru90_closure;
         const GHC.List.foldr1_closure;
         const lvl10_ru92_closure;
         const GHC.List.init_closure;
         const GHC.List.init2_closure;
         const lvl12_ru94_closure;
         const GHC.List.lastError_closure;
         const lvl14_ru97_closure;
         const GHC.List.tail_closure;
         const GHC.List.scanl2_closure;
         const lvl16_ru99_closure;
         const GHC.List.head_closure;
         const GHC.List.badHead_closure;
         const lvl18_ru9b_closure;
         const GHC.List.maximum_$smaximum_closure;
         const GHC.List.maximum1_closure;
         const lvl21_ru9e_closure;
         const GHC.List.minimum_$sminimum_closure;
         const GHC.List.minimum1_closure;
         const GHC.List.maximum_$smaximum1_closure;
         const GHC.List.maximum2_closure;
         const GHC.List.maximum_closure;
         const lvl19_ru9c_closure;
         const GHC.List.minimum_$sminimum1_closure;
         const GHC.List.minimum2_closure;
         const GHC.List.minimum_closure;
         const lvl22_ru9f_closure;
         const lvl24_ru9h_closure;
         const GHC.List.errorEmptyList_closure;
         const lvl26_ru9j_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.List.scanr1_closure;
         const lvl28_ru9p_closure;
         const GHC.List.foldl1'_closure;
         const GHC.List.foldl1'1_closure;
         const sat_sukE_closure;
         const lvl30_ru9r_closure;
         const GHC.List.sum_closure;
         const lvl29_ru9q_closure;
         const GHC.List.product_closure;
         const GHC.List.foldl1_closure;
         const GHC.List.foldl2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.805286909 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:06.806914652 UTC

[section ""data" . $wunsafeDrop_ru8P_closure" {
     $wunsafeDrop_ru8P_closure:
         const $wunsafeDrop_ru8P_info;
 },
 $wunsafeDrop_ru8P_entry() //  [R2, R3]
         { info_tbl: [(cw39,
                       label: $wunsafeDrop_ru8P_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw39: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cw3a; else goto uw3o;
       cw3a: // global
           R3 = R3;
           R2 = R2;
           R1 = $wunsafeDrop_ru8P_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uw3o: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cw2Z() args: 0, res: 0, upd: 0;
     }
 },
 _cw2Z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw2Z: // global
           I64[Sp - 8] = block_cw32_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uw3q; else goto cw33;
       uw3q: // global
           call _cw32(R1) args: 0, res: 0, upd: 0;
       cw33: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw32() //  [R1]
         { info_tbl: [(cw32,
                       label: block_cw32_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw32: // global
           if (R1 & 7 == 1) goto cw36; else goto cw37;
       cw36: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cw37: // global
           _su9x::P64 = P64[R1 + 14];
           _su9y::I64 = I64[Sp + 8];
           if (_su9y::I64 != 1) goto cw3k; else goto cw3l;
       cw3k: // global
           I64[Sp + 8] = _su9y::I64 - 1;
           P64[Sp + 16] = _su9x::P64;
           Sp = Sp + 8;
           call _cw2Z() args: 0, res: 0, upd: 0;
       cw3l: // global
           R1 = _su9x::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.814980815 UTC

[section ""data" . GHC.List.drop_closure" {
     GHC.List.drop_closure:
         const GHC.List.drop_info;
 },
 GHC.List.drop_entry() //  [R2, R3]
         { info_tbl: [(cw3R,
                       label: GHC.List.drop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw3R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw3S; else goto cw3T;
       cw3S: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.drop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw3T: // global
           I64[Sp - 16] = block_cw3O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uw42; else goto cw3P;
       uw42: // global
           call _cw3O(R1) args: 0, res: 0, upd: 0;
       cw3P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw3O() //  [R1]
         { info_tbl: [(cw3O,
                       label: block_cw3O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw3O: // global
           _su9B::P64 = P64[Sp + 8];
           _su9D::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_su9D::I64, 0)) goto cw40; else goto cw41;
       cw40: // global
           R3 = _su9B::P64;
           R2 = _su9D::I64;
           Sp = Sp + 16;
           call $wunsafeDrop_ru8P_entry(R3, R2) args: 8, res: 0, upd: 8;
       cw41: // global
           R1 = _su9B::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.821397992 UTC

[section ""data" . GHC.List.$wsplitAt'_closure" {
     GHC.List.$wsplitAt'_closure:
         const GHC.List.$wsplitAt'_info;
 },
 ds2_su9N_entry() //  [R1]
         { info_tbl: [(cw4B,
                       label: ds2_su9N_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw4B: // global
           _su9N::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cw4H; else goto cw4I;
       cw4I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cw4K; else goto cw4J;
       cw4K: // global
           HpAlloc = 16;
           goto cw4H;
       cw4H: // global
           R1 = _su9N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw4J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _su9N::P64;
           _su9J::P64 = P64[_su9N::P64 + 16];
           _su9O::I64 = I64[_su9N::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _su9O::I64;
           I64[Sp - 24] = block_cw4E_info;
           R3 = _su9J::P64;
           R2 = Hp - 7;
           Sp = Sp - 24;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cw4E() //  [R1, R2]
         { info_tbl: [(cw4E,
                       label: block_cw4E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw4E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cw4N; else goto cw4M;
       cw4N: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cw4M: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wsplitAt'_entry() //  [R2, R3]
         { info_tbl: [(cw4S,
                       label: GHC.List.$wsplitAt'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw4S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cw4T; else goto cw4U;
       cw4T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wsplitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw4U: // global
           I64[Sp - 16] = block_cw4i_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uw5a; else goto cw4j;
       uw5a: // global
           call _cw4i(R1) args: 0, res: 0, upd: 0;
       cw4j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw4i() //  [R1]
         { info_tbl: [(cw4i,
                       label: block_cw4i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw4i: // global
           if (R1 & 7 == 1) goto cw4P; else goto cw4Q;
       cw4P: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cw4Q: // global
           I64[Sp - 8] = block_cw4o_info;
           _su9I::P64 = P64[R1 + 6];
           _su9J::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _su9J::P64;
           P64[Sp + 8] = _su9I::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uw59; else goto cw4p;
       uw59: // global
           call _cw4o(R1) args: 0, res: 0, upd: 0;
       cw4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw4o() //  [R1]
         { info_tbl: [(cw4o,
                       label: block_cw4o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw4o: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cw50; else goto cw4Z;
       cw50: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cw4Z: // global
           _su9I::P64 = P64[Sp + 16];
           _su9J::P64 = P64[Sp + 8];
           _su9M::I64 = I64[R1 + 7];
           if (_su9M::I64 != 1) goto cw55; else goto cw58;
       cw55: // global
           I64[Hp - 96] = ds2_su9N_info;
           P64[Hp - 80] = _su9J::P64;
           I64[Hp - 72] = _su9M::I64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cw4v::P64 = Hp - 96;
           P64[Hp - 48] = _cw4v::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cw4v::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _su9I::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cw58: // global
           I64[Hp - 96] = :_con_info;
           P64[Hp - 88] = _su9I::P64;
           P64[Hp - 80] = GHC.Types.[]_closure+1;
           _cw57::P64 = Hp - 94;
           Hp = Hp - 80;
           R2 = _su9J::P64;
           R1 = _cw57::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.834863509 UTC

[section ""data" . GHC.List.splitAt_splitAt'_closure" {
     GHC.List.splitAt_splitAt'_closure:
         const GHC.List.splitAt_splitAt'_info;
 },
 GHC.List.splitAt_splitAt'_entry() //  [R2, R3]
         { info_tbl: [(cw5K,
                       label: GHC.List.splitAt_splitAt'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw5K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cw5L; else goto cw5M;
       cw5L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_splitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw5M: // global
           I64[Sp - 8] = block_cw5H_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cw5H() //  [R1, R2]
         { info_tbl: [(cw5H,
                       label: block_cw5H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw5H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cw5P; else goto cw5O;
       cw5P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cw5O: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.841441617 UTC

[section ""data" . GHC.List.splitAt_closure" {
     GHC.List.splitAt_closure:
         const GHC.List.splitAt_info;
 },
 GHC.List.splitAt_entry() //  [R2, R3]
         { info_tbl: [(cw66,
                       label: GHC.List.splitAt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw66: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw67; else goto cw68;
       cw67: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw68: // global
           I64[Sp - 16] = block_cw63_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uw6s; else goto cw64;
       uw6s: // global
           call _cw63(R1) args: 0, res: 0, upd: 0;
       cw64: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw63() //  [R1]
         { info_tbl: [(cw63,
                       label: block_cw63_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw63: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cw6d; else goto cw6c;
       cw6d: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cw6c: // global
           _sua9::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto cw6l; else goto cw6r;
       cw6l: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_cw6h_info;
           R3 = _sua9::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
       cw6r: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = _sua9::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cw6h() //  [R1, R2]
         { info_tbl: [(cw6h,
                       label: block_cw6h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw6h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cw6o; else goto cw6n;
       cw6o: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cw6n: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.84911332 UTC

[section ""cstring" . GHC.List.$trModule4_bytes" {
     GHC.List.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.850773718 UTC

[section ""data" . GHC.List.$trModule3_closure" {
     GHC.List.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.852859285 UTC

[section ""cstring" . GHC.List.$trModule2_bytes" {
     GHC.List.$trModule2_bytes:
         I8[] [71,72,67,46,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.854450688 UTC

[section ""data" . GHC.List.$trModule1_closure" {
     GHC.List.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.856022379 UTC

[section ""data" . GHC.List.$trModule_closure" {
     GHC.List.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.List.$trModule3_closure+1;
         const GHC.List.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.858736275 UTC

[section ""data" . GHC.List.init1_closure" {
     GHC.List.init1_closure:
         const GHC.List.init1_info;
 },
 sat_sual_entry() //  [R1]
         { info_tbl: [(cw70,
                       label: sat_sual_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw70: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw71; else goto cw72;
       cw71: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw72: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.init1_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.init1_entry() //  [R2, R3]
         { info_tbl: [(cw77,
                       label: GHC.List.init1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw78; else goto cw79;
       cw78: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.init1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw79: // global
           I64[Sp - 16] = block_cw6Q_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uw7g; else goto cw6R;
       uw7g: // global
           call _cw6Q(R1) args: 0, res: 0, upd: 0;
       cw6R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw6Q() //  [R1]
         { info_tbl: [(cw6Q,
                       label: block_cw6Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw6Q: // global
           if (R1 & 7 == 1) goto cw74; else goto cw75;
       cw74: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cw75: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cw7f; else goto cw7e;
       cw7f: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cw7e: // global
           _suaj::P64 = P64[R1 + 6];
           _suak::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sual_info;
           P64[Hp - 32] = _suaj::P64;
           P64[Hp - 24] = _suak::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.866816762 UTC

[section ""cstring" . lvl_ru8Q_bytes" {
     lvl_ru8Q_bytes:
         I8[] [58,32,101,109,112,116,121,32,108,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.868702102 UTC

[section ""data" . lvl1_ru8R_closure" {
     lvl1_ru8R_closure:
         const lvl1_ru8R_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ru8R_entry() //  [R1]
         { info_tbl: [(cw7H,
                       label: lvl1_ru8R_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw7H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw7I; else goto cw7J;
       cw7I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw7J: // global
           (_cw7E::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw7E::I64 == 0) goto cw7G; else goto cw7F;
       cw7G: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw7F: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw7E::I64;
           R2 = lvl_ru8Q_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.873435609 UTC

[section ""cstring" . GHC.List.!!4_bytes" {
     GHC.List.!!4_bytes:
         I8[] [80,114,101,108,117,100,101,46]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.87525358 UTC

[section ""data" . GHC.List.prel_list_str_closure" {
     GHC.List.prel_list_str_closure:
         const GHC.List.prel_list_str_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.prel_list_str_entry() //  [R1]
         { info_tbl: [(cw7Y,
                       label: GHC.List.prel_list_str_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw7Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw7Z; else goto cw80;
       cw7Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw80: // global
           (_cw7V::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw7V::I64 == 0) goto cw7X; else goto cw7W;
       cw7X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw7W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw7V::I64;
           R2 = GHC.List.!!4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.879590012 UTC

[section ""data" . GHC.List.errorEmptyList_closure" {
     GHC.List.errorEmptyList_closure:
         const GHC.List.errorEmptyList_info;
         const 0;
 },
 sat_suan_entry() //  [R1]
         { info_tbl: [(cw8g,
                       label: sat_suan_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw8g: // global
           R3 = lvl1_ru8R_closure;
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.errorEmptyList_entry() //  [R2]
         { info_tbl: [(cw8l,
                       label: GHC.List.errorEmptyList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw8l: // global
           _suam::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cw8m; else goto cw8n;
       cw8n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cw8p; else goto cw8o;
       cw8p: // global
           HpAlloc = 24;
           goto cw8m;
       cw8m: // global
           R2 = _suam::P64;
           R1 = GHC.List.errorEmptyList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cw8o: // global
           I64[Hp - 16] = sat_suan_info;
           P64[Hp] = _suam::P64;
           I64[Sp - 8] = block_cw8j_info;
           R3 = Hp - 16;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cw8j() //  [R1]
         { info_tbl: [(cw8j,
                       label: block_cw8j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw8j: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.886974563 UTC

[section ""cstring" . lvl2_ru8S_bytes" {
     lvl2_ru8S_bytes:
         I8[] [33,33,58,32,110,101,103,97,116,105,118,101,32,105,110,100,101,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.888939844 UTC

[section ""data" . lvl3_ru8T_closure" {
     lvl3_ru8T_closure:
         const lvl3_ru8T_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_ru8T_entry() //  [R1]
         { info_tbl: [(cw8L,
                       label: lvl3_ru8T_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw8L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw8M; else goto cw8N;
       cw8M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw8N: // global
           (_cw8I::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw8I::I64 == 0) goto cw8K; else goto cw8J;
       cw8K: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw8J: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw8I::I64;
           R2 = lvl2_ru8S_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.893172623 UTC

[section ""data" . GHC.List.negIndex_closure" {
     GHC.List.negIndex_closure:
         const GHC.List.negIndex_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.negIndex_entry() //  [R1]
         { info_tbl: [(cw93,
                       label: GHC.List.negIndex_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw93: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cw94; else goto cw95;
       cw94: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw95: // global
           (_cw8Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw8Y::I64 == 0) goto cw90; else goto cw8Z;
       cw90: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw8Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw8Y::I64;
           I64[Sp - 24] = block_cw91_info;
           R3 = lvl3_ru8T_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cw91() //  [R1]
         { info_tbl: [(cw91,
                       label: block_cw91_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw91: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.899019023 UTC

[section ""cstring" . GHC.List.!!3_bytes" {
     GHC.List.!!3_bytes:
         I8[] [33,33,58,32,105,110,100,101,120,32,116,111,111,32,108,97,114,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.900944757 UTC

[section ""data" . GHC.List.!!2_closure" {
     GHC.List.!!2_closure:
         const GHC.List.!!2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!2_entry() //  [R1]
         { info_tbl: [(cw9q,
                       label: GHC.List.!!2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw9q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw9r; else goto cw9s;
       cw9r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw9s: // global
           (_cw9n::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw9n::I64 == 0) goto cw9p; else goto cw9o;
       cw9p: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw9o: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw9n::I64;
           R2 = GHC.List.!!3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.904972477 UTC

[section ""data" . GHC.List.!!1_closure" {
     GHC.List.!!1_closure:
         const GHC.List.!!1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!1_entry() //  [R1]
         { info_tbl: [(cw9G,
                       label: GHC.List.!!1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw9G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw9H; else goto cw9I;
       cw9H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw9I: // global
           (_cw9D::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw9D::I64 == 0) goto cw9F; else goto cw9E;
       cw9F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw9E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw9D::I64;
           R3 = GHC.List.!!2_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.910041986 UTC

[section ""data" . GHC.List.tooLarge_closure" {
     GHC.List.tooLarge_closure:
         const GHC.List.tooLarge_info;
         const 0;
 },
 GHC.List.tooLarge_entry() //  []
         { info_tbl: [(cw9U,
                       label: GHC.List.tooLarge_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cw9U: // global
           R2 = GHC.List.!!1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.913392328 UTC

[section ""data" . poly_exit_ru8U_closure" {
     poly_exit_ru8U_closure:
         const poly_exit_ru8U_info;
         const 0;
         const 0;
         const 0;
 },
 poly_exit_ru8U_entry() //  [R1]
         { info_tbl: [(cwa7,
                       label: poly_exit_ru8U_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwa7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwa8; else goto cwa9;
       cwa8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwa9: // global
           (_cwa4::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwa4::I64 == 0) goto cwa6; else goto cwa5;
       cwa6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwa5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwa4::I64;
           R2 = GHC.List.!!1_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.917621115 UTC

[section ""data" . poly_$wgo_ru8V_closure" {
     poly_$wgo_ru8V_closure:
         const poly_$wgo_ru8V_info;
         const 0;
 },
 poly_$wgo_ru8V_entry() //  [R2, R3]
         { info_tbl: [(cwas,
                       label: poly_$wgo_ru8V_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwas: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwat; else goto uwaH;
       cwat: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_$wgo_ru8V_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwaH: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwai() args: 0, res: 0, upd: 0;
     }
 },
 _cwai() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwai: // global
           _suar::P64 = P64[Sp];
           I64[Sp] = block_cwal_info;
           R1 = _suar::P64;
           if (R1 & 7 != 0) goto uwaJ; else goto cwam;
       uwaJ: // global
           call _cwal(R1) args: 0, res: 0, upd: 0;
       cwam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwal() //  [R1]
         { info_tbl: [(cwal,
                       label: block_cwal_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwal: // global
           if (R1 & 7 == 1) goto cwap; else goto cwaq;
       cwap: // global
           R1 = poly_exit_ru8U_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwaq: // global
           _suaw::I64 = I64[Sp + 8];
           if (_suaw::I64 != 0) goto cwaD; else goto cwaE;
       cwaD: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _suaw::I64 - 1;
           call _cwai() args: 0, res: 0, upd: 0;
       cwaE: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.924466393 UTC

[section ""data" . GHC.List.$w!!_closure" {
     GHC.List.$w!!_closure:
         const GHC.List.$w!!_info;
         const 0;
 },
 GHC.List.$w!!_entry() //  [R2, R3]
         { info_tbl: [(cwba,
                       label: GHC.List.$w!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwba: // global
           if (%MO_S_Ge_W64(R3, 0)) goto cwb8; else goto cwb9;
       cwb8: // global
           R3 = R3;
           R2 = R2;
           call poly_$wgo_ru8V_entry(R3, R2) args: 8, res: 0, upd: 8;
       cwb9: // global
           R1 = GHC.List.negIndex_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.928480459 UTC

[section ""data" . GHC.List.!!_closure" {
     GHC.List.!!_closure:
         const GHC.List.!!_info;
         const 0;
 },
 GHC.List.!!_entry() //  [R2, R3]
         { info_tbl: [(cwbo,
                       label: GHC.List.!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwbo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwbp; else goto cwbq;
       cwbp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.!!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwbq: // global
           I64[Sp - 16] = block_cwbl_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwbu; else goto cwbm;
       uwbu: // global
           call _cwbl(R1) args: 0, res: 0, upd: 0;
       cwbm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwbl() //  [R1]
         { info_tbl: [(cwbl,
                       label: block_cwbl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwbl: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$w!!_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.933721574 UTC

[section ""cstring" . lvl4_ru8W_bytes" {
     lvl4_ru8W_bytes:
         I8[] [99,121,99,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.935635621 UTC

[section ""data" . lvl5_ru8X_closure" {
     lvl5_ru8X_closure:
         const lvl5_ru8X_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_ru8X_entry() //  [R1]
         { info_tbl: [(cwbL,
                       label: lvl5_ru8X_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwbL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwbM; else goto cwbN;
       cwbM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwbN: // global
           (_cwbI::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwbI::I64 == 0) goto cwbK; else goto cwbJ;
       cwbK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwbJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwbI::I64;
           R2 = lvl4_ru8W_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.939979019 UTC

[section ""data" . GHC.List.cycle1_closure" {
     GHC.List.cycle1_closure:
         const GHC.List.cycle1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.cycle1_entry() //  [R1]
         { info_tbl: [(cwc1,
                       label: GHC.List.cycle1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwc1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwc2; else goto cwc3;
       cwc2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwc3: // global
           (_cwbY::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwbY::I64 == 0) goto cwc0; else goto cwbZ;
       cwc0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwbZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwbY::I64;
           R2 = lvl5_ru8X_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.944229414 UTC

[section ""data" . GHC.List.cycle_closure" {
     GHC.List.cycle_closure:
         const GHC.List.cycle_info;
         const 0;
 },
 xs'_suaJ_entry() //  [R1]
         { info_tbl: [(cwcp,
                       label: xs'_suaJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwcp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwcq; else goto cwcr;
       cwcq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwcr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.cycle_entry() //  [R2]
         { info_tbl: [(cwcw,
                       label: GHC.List.cycle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwcw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwcx; else goto cwcy;
       cwcx: // global
           R2 = R2;
           R1 = GHC.List.cycle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwcy: // global
           I64[Sp - 8] = block_cwcf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwcE; else goto cwcg;
       uwcE: // global
           call _cwcf(R1) args: 0, res: 0, upd: 0;
       cwcg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwcf() //  [R1]
         { info_tbl: [(cwcf,
                       label: block_cwcf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwcf: // global
           if (R1 & 7 == 1) goto cwct; else goto cwcu;
       cwct: // global
           R1 = GHC.List.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwcu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwcD; else goto cwcC;
       cwcD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwcC: // global
           I64[Hp - 16] = xs'_suaJ_info;
           P64[Hp] = R1;
           R1 = (Hp + -16) & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.952843242 UTC

[section ""cstring" . lvl6_ru8Y_bytes" {
     lvl6_ru8Y_bytes:
         I8[] [102,111,108,100,114,49]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.954783774 UTC

[section ""data" . lvl7_ru8Z_closure" {
     lvl7_ru8Z_closure:
         const lvl7_ru8Z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_ru8Z_entry() //  [R1]
         { info_tbl: [(cwd4,
                       label: lvl7_ru8Z_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwd4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwd5; else goto cwd6;
       cwd5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwd6: // global
           (_cwd1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwd1::I64 == 0) goto cwd3; else goto cwd2;
       cwd3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwd2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwd1::I64;
           R2 = lvl6_ru8Y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.95874436 UTC

[section ""data" . lvl8_ru90_closure" {
     lvl8_ru90_closure:
         const lvl8_ru90_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_ru90_entry() //  [R1]
         { info_tbl: [(cwdk,
                       label: lvl8_ru90_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwdk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwdl; else goto cwdm;
       cwdl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwdm: // global
           (_cwdh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwdh::I64 == 0) goto cwdj; else goto cwdi;
       cwdj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwdi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwdh::I64;
           R2 = lvl7_ru8Z_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.963269959 UTC

[section ""data" . GHC.List.foldr1_closure" {
     GHC.List.foldr1_closure:
         const GHC.List.foldr1_info;
         const 0;
 },
 go2_suaM_entry() //  [R1, R2]
         { info_tbl: [(cwdK,
                       label: go2_suaM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwdK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwdL; else goto cwdM;
       cwdL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwdM: // global
           I64[Sp - 24] = block_cwdD_info;
           _suaM::P64 = R1;
           _suaK::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _suaK::P64;
           P64[Sp - 8] = _suaM::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uwea; else goto cwdE;
       uwea: // global
           call _cwdD(R1) args: 0, res: 0, upd: 0;
       cwdE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwdD() //  [R1]
         { info_tbl: [(cwdD,
                       label: block_cwdD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwdD: // global
           if (R1 & 7 == 1) goto cwdH; else goto cwdI;
       cwdH: // global
           R1 = lvl8_ru90_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwdI: // global
           I64[Sp - 8] = block_cwdS_info;
           _suaP::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _suaP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwe9; else goto cwdU;
       uwe9: // global
           call _cwdS(R1) args: 0, res: 0, upd: 0;
       cwdU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwdS() //  [R1]
         { info_tbl: [(cwdS,
                       label: block_cwdS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwdS: // global
           _suaP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwe0; else goto cwe4;
       cwe0: // global
           R1 = _suaP::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwe4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cwe7; else goto cwe6;
       cwe7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwe6: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = _suaP::P64;
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.foldr1_entry() //  [R2, R3]
         { info_tbl: [(cweb,
                       label: GHC.List.foldr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cweb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwef; else goto cwee;
       cwef: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwee: // global
           I64[Hp - 8] = go2_suaM_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_suaM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.973783323 UTC

[section ""cstring" . lvl9_ru91_bytes" {
     lvl9_ru91_bytes:
         I8[] [105,110,105,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.975739389 UTC

[section ""data" . lvl10_ru92_closure" {
     lvl10_ru92_closure:
         const lvl10_ru92_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ru92_entry() //  [R1]
         { info_tbl: [(cweI,
                       label: lvl10_ru92_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cweI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cweJ; else goto cweK;
       cweJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cweK: // global
           (_cweF::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cweF::I64 == 0) goto cweH; else goto cweG;
       cweH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cweG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cweF::I64;
           R2 = lvl9_ru91_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.980246952 UTC

[section ""data" . GHC.List.init2_closure" {
     GHC.List.init2_closure:
         const GHC.List.init2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.init2_entry() //  [R1]
         { info_tbl: [(cweY,
                       label: GHC.List.init2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cweY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cweZ; else goto cwf0;
       cweZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwf0: // global
           (_cweV::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cweV::I64 == 0) goto cweX; else goto cweW;
       cweX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cweW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cweV::I64;
           R2 = lvl10_ru92_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.984655974 UTC

[section ""data" . GHC.List.init_closure" {
     GHC.List.init_closure:
         const GHC.List.init_info;
         const 0;
 },
 GHC.List.init_entry() //  [R2]
         { info_tbl: [(cwfj,
                       label: GHC.List.init_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwfj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwfk; else goto cwfl;
       cwfk: // global
           R2 = R2;
           R1 = GHC.List.init_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwfl: // global
           I64[Sp - 8] = block_cwfc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwfs; else goto cwfd;
       uwfs: // global
           call _cwfc(R1) args: 0, res: 0, upd: 0;
       cwfd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwfc() //  [R1]
         { info_tbl: [(cwfc,
                       label: block_cwfc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwfc: // global
           if (R1 & 7 == 1) goto cwfg; else goto cwfh;
       cwfg: // global
           R1 = GHC.List.init2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwfh: // global
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.List.init1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.990201461 UTC

[section ""cstring" . lvl11_ru93_bytes" {
     lvl11_ru93_bytes:
         I8[] [108,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.992155508 UTC

[section ""data" . lvl12_ru94_closure" {
     lvl12_ru94_closure:
         const lvl12_ru94_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ru94_entry() //  [R1]
         { info_tbl: [(cwfM,
                       label: lvl12_ru94_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwfM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwfN; else goto cwfO;
       cwfN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwfO: // global
           (_cwfJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwfJ::I64 == 0) goto cwfL; else goto cwfK;
       cwfL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwfK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwfJ::I64;
           R2 = lvl11_ru93_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:06.997134469 UTC

[section ""data" . GHC.List.lastError_closure" {
     GHC.List.lastError_closure:
         const GHC.List.lastError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.lastError_entry() //  [R1]
         { info_tbl: [(cwg2,
                       label: GHC.List.lastError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwg2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwg3; else goto cwg4;
       cwg3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwg4: // global
           (_cwfZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwfZ::I64 == 0) goto cwg1; else goto cwg0;
       cwg1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwg0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwfZ::I64;
           R2 = lvl12_ru94_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.001349596 UTC

[section ""data" . poly_go_ru95_closure" {
     poly_go_ru95_closure:
         const poly_go_ru95_info;
 },
 poly_go_ru95_entry() //  [R2, R3]
         { info_tbl: [(cwgn,
                       label: poly_go_ru95_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwgn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwgo; else goto uwgw;
       cwgo: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_go_ru95_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwgw: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwgd() args: 0, res: 0, upd: 0;
     }
 },
 _cwgd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwgd: // global
           _suaZ::P64 = P64[Sp];
           I64[Sp] = block_cwgg_info;
           R1 = _suaZ::P64;
           if (R1 & 7 != 0) goto uwgy; else goto cwgh;
       uwgy: // global
           call _cwgg(R1) args: 0, res: 0, upd: 0;
       cwgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwgg() //  [R1]
         { info_tbl: [(cwgg,
                       label: block_cwgg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwgg: // global
           if (R1 & 7 == 1) goto cwgk; else goto cwgl;
       cwgk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwgl: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cwgd() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.008072619 UTC

[section ""data" . GHC.List.last_closure" {
     GHC.List.last_closure:
         const GHC.List.last_info;
         const 0;
 },
 GHC.List.last_entry() //  [R2]
         { info_tbl: [(cwgU,
                       label: GHC.List.last_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwgU: // global
           R3 = GHC.List.lastError_closure;
           R2 = R2;
           call poly_go_ru95_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.011374153 UTC

[section ""cstring" . lvl13_ru96_bytes" {
     lvl13_ru96_bytes:
         I8[] [116,97,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.01319033 UTC

[section ""data" . lvl14_ru97_closure" {
     lvl14_ru97_closure:
         const lvl14_ru97_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ru97_entry() //  [R1]
         { info_tbl: [(cwh8,
                       label: lvl14_ru97_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwh8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwh9; else goto cwha;
       cwh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwha: // global
           (_cwh5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwh5::I64 == 0) goto cwh7; else goto cwh6;
       cwh7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwh6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwh5::I64;
           R2 = lvl13_ru96_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.017112855 UTC

[section ""data" . GHC.List.scanl2_closure" {
     GHC.List.scanl2_closure:
         const GHC.List.scanl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.scanl2_entry() //  [R1]
         { info_tbl: [(cwho,
                       label: GHC.List.scanl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwho: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwhp; else goto cwhq;
       cwhp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwhq: // global
           (_cwhl::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwhl::I64 == 0) goto cwhn; else goto cwhm;
       cwhn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwhm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwhl::I64;
           R2 = lvl14_ru97_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.022026627 UTC

[section ""data" . GHC.List.tail_closure" {
     GHC.List.tail_closure:
         const GHC.List.tail_info;
         const 0;
 },
 GHC.List.tail_entry() //  [R2]
         { info_tbl: [(cwhJ,
                       label: GHC.List.tail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwhJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwhK; else goto cwhL;
       cwhK: // global
           R2 = R2;
           R1 = GHC.List.tail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwhL: // global
           I64[Sp - 8] = block_cwhC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwhS; else goto cwhD;
       uwhS: // global
           call _cwhC(R1) args: 0, res: 0, upd: 0;
       cwhD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwhC() //  [R1]
         { info_tbl: [(cwhC,
                       label: block_cwhC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwhC: // global
           if (R1 & 7 == 1) goto cwhG; else goto cwhH;
       cwhG: // global
           R1 = GHC.List.scanl2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwhH: // global
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.027343825 UTC

[section ""cstring" . lvl15_ru98_bytes" {
     lvl15_ru98_bytes:
         I8[] [104,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.029135078 UTC

[section ""data" . lvl16_ru99_closure" {
     lvl16_ru99_closure:
         const lvl16_ru99_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_ru99_entry() //  [R1]
         { info_tbl: [(cwie,
                       label: lvl16_ru99_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwie: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwif; else goto cwig;
       cwif: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwig: // global
           (_cwib::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwib::I64 == 0) goto cwid; else goto cwic;
       cwid: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwic: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwib::I64;
           R2 = lvl15_ru98_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.03320945 UTC

[section ""data" . GHC.List.badHead_closure" {
     GHC.List.badHead_closure:
         const GHC.List.badHead_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.badHead_entry() //  [R1]
         { info_tbl: [(cwiu,
                       label: GHC.List.badHead_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwiu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwiv; else goto cwiw;
       cwiv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwiw: // global
           (_cwir::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwir::I64 == 0) goto cwit; else goto cwis;
       cwit: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwis: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwir::I64;
           R2 = lvl16_ru99_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.038185529 UTC

[section ""data" . GHC.List.head_closure" {
     GHC.List.head_closure:
         const GHC.List.head_info;
         const 0;
 },
 GHC.List.head_entry() //  [R2]
         { info_tbl: [(cwiP,
                       label: GHC.List.head_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwiP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwiQ; else goto cwiR;
       cwiQ: // global
           R2 = R2;
           R1 = GHC.List.head_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwiR: // global
           I64[Sp - 8] = block_cwiI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwiY; else goto cwiJ;
       uwiY: // global
           call _cwiI(R1) args: 0, res: 0, upd: 0;
       cwiJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwiI() //  [R1]
         { info_tbl: [(cwiI,
                       label: block_cwiI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwiI: // global
           if (R1 & 7 == 1) goto cwiM; else goto cwiN;
       cwiM: // global
           R1 = GHC.List.badHead_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwiN: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.043451596 UTC

[section ""cstring" . lvl17_ru9a_bytes" {
     lvl17_ru9a_bytes:
         I8[] [109,97,120,105,109,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.045533058 UTC

[section ""data" . lvl18_ru9b_closure" {
     lvl18_ru9b_closure:
         const lvl18_ru9b_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_ru9b_entry() //  [R1]
         { info_tbl: [(cwjh,
                       label: lvl18_ru9b_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwjh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwji; else goto cwjj;
       cwji: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwjj: // global
           (_cwje::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwje::I64 == 0) goto cwjg; else goto cwjf;
       cwjg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwjf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwje::I64;
           R2 = lvl17_ru9a_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.049525269 UTC

[section ""data" . GHC.List.maximum1_closure" {
     GHC.List.maximum1_closure:
         const GHC.List.maximum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum1_entry() //  [R1]
         { info_tbl: [(cwjx,
                       label: GHC.List.maximum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwjx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwjy; else goto cwjz;
       cwjy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwjz: // global
           (_cwju::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwju::I64 == 0) goto cwjw; else goto cwjv;
       cwjw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwjv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwju::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.054389646 UTC

[section ""data" . GHC.List.maximum2_closure" {
     GHC.List.maximum2_closure:
         const GHC.List.maximum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum2_entry() //  [R1]
         { info_tbl: [(cwjN,
                       label: GHC.List.maximum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwjN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwjO; else goto cwjP;
       cwjO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwjP: // global
           (_cwjK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwjK::I64 == 0) goto cwjM; else goto cwjL;
       cwjM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwjL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwjK::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.05834726 UTC

[section ""data" . lvl19_ru9c_closure" {
     lvl19_ru9c_closure:
         const lvl19_ru9c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_ru9c_entry() //  [R1]
         { info_tbl: [(cwk3,
                       label: lvl19_ru9c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwk3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwk4; else goto cwk5;
       cwk4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwk5: // global
           (_cwk0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwk0::I64 == 0) goto cwk2; else goto cwk1;
       cwk2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwk1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwk0::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.062438917 UTC

[section ""data" . GHC.List.maximum_go_closure" {
     GHC.List.maximum_go_closure:
         const GHC.List.maximum_go_info;
 },
 GHC.List.maximum_go_entry() //  [R2, R3]
         { info_tbl: [(cwko,
                       label: GHC.List.maximum_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwko: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwkp; else goto uwkI;
       cwkp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwkI: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwke() args: 0, res: 0, upd: 0;
     }
 },
 _cwke() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwke: // global
           _subd::P64 = P64[Sp];
           I64[Sp] = block_cwkh_info;
           R1 = _subd::P64;
           if (R1 & 7 != 0) goto uwkL; else goto cwki;
       uwkL: // global
           call _cwkh(R1) args: 0, res: 0, upd: 0;
       cwki: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwkh() //  [R1]
         { info_tbl: [(cwkh,
                       label: block_cwkh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwkh: // global
           _sube::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwkl; else goto cwkm;
       cwkl: // global
           R1 = _sube::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwkm: // global
           I64[Sp - 16] = block_cwkw_info;
           _subg::P64 = P64[R1 + 6];
           R3 = _subg::P64;
           R2 = _sube::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _subg::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cwkw() //  [R1]
         { info_tbl: [(cwkw,
                       label: block_cwkw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwkw: // global
           _subh::P64 = P64[Sp + 8];
           if (R1 == 1) goto cwkH; else goto cwkD;
       cwkH: // global
           _sube::P64 = P64[Sp + 16];
           P64[Sp + 16] = _subh::P64;
           P64[Sp + 24] = _sube::P64;
           Sp = Sp + 16;
           goto uwkO;
       cwkD: // global
           P64[Sp + 16] = _subh::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uwkO;
       uwkO: // global
           call _cwke() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.071559184 UTC

[section ""data" . GHC.List.maximum_$smaximum_closure" {
     GHC.List.maximum_$smaximum_closure:
         const GHC.List.maximum_$smaximum_info;
         const 0;
 },
 GHC.List.maximum_$smaximum_entry() //  [R2]
         { info_tbl: [(cwlk,
                       label: GHC.List.maximum_$smaximum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwlk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwll; else goto cwlm;
       cwll: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwlm: // global
           I64[Sp - 8] = block_cwld_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwlt; else goto cwle;
       uwlt: // global
           call _cwld(R1) args: 0, res: 0, upd: 0;
       cwle: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwld() //  [R1]
         { info_tbl: [(cwld,
                       label: block_cwld_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwld: // global
           if (R1 & 7 == 1) goto cwlh; else goto cwli;
       cwlh: // global
           R1 = GHC.List.maximum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwli: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.maximum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.076903409 UTC

[section ""cstring" . lvl20_ru9d_bytes" {
     lvl20_ru9d_bytes:
         I8[] [109,105,110,105,109,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.079100977 UTC

[section ""data" . lvl21_ru9e_closure" {
     lvl21_ru9e_closure:
         const lvl21_ru9e_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_ru9e_entry() //  [R1]
         { info_tbl: [(cwlN,
                       label: lvl21_ru9e_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwlN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwlO; else goto cwlP;
       cwlO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwlP: // global
           (_cwlK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwlK::I64 == 0) goto cwlM; else goto cwlL;
       cwlM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwlL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwlK::I64;
           R2 = lvl20_ru9d_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.082932284 UTC

[section ""data" . GHC.List.minimum1_closure" {
     GHC.List.minimum1_closure:
         const GHC.List.minimum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum1_entry() //  [R1]
         { info_tbl: [(cwm3,
                       label: GHC.List.minimum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwm3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwm4; else goto cwm5;
       cwm4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwm5: // global
           (_cwm0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwm0::I64 == 0) goto cwm2; else goto cwm1;
       cwm2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwm1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwm0::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.087249618 UTC

[section ""data" . GHC.List.minimum2_closure" {
     GHC.List.minimum2_closure:
         const GHC.List.minimum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum2_entry() //  [R1]
         { info_tbl: [(cwmj,
                       label: GHC.List.minimum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwmj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwmk; else goto cwml;
       cwmk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwml: // global
           (_cwmg::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwmg::I64 == 0) goto cwmi; else goto cwmh;
       cwmi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwmh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwmg::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.091283468 UTC

[section ""data" . lvl22_ru9f_closure" {
     lvl22_ru9f_closure:
         const lvl22_ru9f_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ru9f_entry() //  [R1]
         { info_tbl: [(cwmz,
                       label: lvl22_ru9f_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwmz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwmA; else goto cwmB;
       cwmA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwmB: // global
           (_cwmw::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwmw::I64 == 0) goto cwmy; else goto cwmx;
       cwmy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwmx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwmw::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.096069317 UTC

[section ""data" . GHC.List.minimum_go_closure" {
     GHC.List.minimum_go_closure:
         const GHC.List.minimum_go_info;
 },
 GHC.List.minimum_go_entry() //  [R2, R3]
         { info_tbl: [(cwmU,
                       label: GHC.List.minimum_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwmU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwmV; else goto uwne;
       cwmV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwne: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwmK() args: 0, res: 0, upd: 0;
     }
 },
 _cwmK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwmK: // global
           _subn::P64 = P64[Sp];
           I64[Sp] = block_cwmN_info;
           R1 = _subn::P64;
           if (R1 & 7 != 0) goto uwnh; else goto cwmO;
       uwnh: // global
           call _cwmN(R1) args: 0, res: 0, upd: 0;
       cwmO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwmN() //  [R1]
         { info_tbl: [(cwmN,
                       label: block_cwmN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwmN: // global
           _subo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwmR; else goto cwmS;
       cwmR: // global
           R1 = _subo::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwmS: // global
           I64[Sp - 16] = block_cwn2_info;
           _subq::P64 = P64[R1 + 6];
           R3 = _subq::P64;
           R2 = _subo::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _subq::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cwn2() //  [R1]
         { info_tbl: [(cwn2,
                       label: block_cwn2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwn2: // global
           _subr::P64 = P64[Sp + 8];
           if (R1 == 1) goto cwnd; else goto cwn9;
       cwnd: // global
           P64[Sp + 16] = _subr::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uwnk;
       cwn9: // global
           _subo::P64 = P64[Sp + 16];
           P64[Sp + 16] = _subr::P64;
           P64[Sp + 24] = _subo::P64;
           Sp = Sp + 16;
           goto uwnk;
       uwnk: // global
           call _cwmK() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.105009291 UTC

[section ""data" . GHC.List.minimum_$sminimum_closure" {
     GHC.List.minimum_$sminimum_closure:
         const GHC.List.minimum_$sminimum_info;
         const 0;
 },
 GHC.List.minimum_$sminimum_entry() //  [R2]
         { info_tbl: [(cwnQ,
                       label: GHC.List.minimum_$sminimum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwnQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwnR; else goto cwnS;
       cwnR: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwnS: // global
           I64[Sp - 8] = block_cwnJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwnZ; else goto cwnK;
       uwnZ: // global
           call _cwnJ(R1) args: 0, res: 0, upd: 0;
       cwnK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwnJ() //  [R1]
         { info_tbl: [(cwnJ,
                       label: block_cwnJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwnJ: // global
           if (R1 & 7 == 1) goto cwnN; else goto cwnO;
       cwnN: // global
           R1 = GHC.List.minimum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwnO: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.minimum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.111401181 UTC

[section ""data" . GHC.List.$wgo_closure" {
     GHC.List.$wgo_closure:
         const GHC.List.$wgo_info;
 },
 GHC.List.$wgo_entry() //  [R2, R3]
         { info_tbl: [(cwon,
                       label: GHC.List.$wgo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwon: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwoo; else goto uwoH;
       cwoo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwoH: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwod() args: 0, res: 0, upd: 0;
     }
 },
 _cwod() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwod: // global
           _subx::P64 = P64[Sp];
           I64[Sp] = block_cwog_info;
           R1 = _subx::P64;
           if (R1 & 7 != 0) goto uwoK; else goto cwoh;
       uwoK: // global
           call _cwog(R1) args: 0, res: 0, upd: 0;
       cwoh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwog() //  [R1]
         { info_tbl: [(cwog,
                       label: block_cwog_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwog: // global
           if (R1 & 7 == 1) goto cwok; else goto cwol;
       cwok: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwol: // global
           I64[Sp - 8] = block_cwov_info;
           _subB::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _subB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwoL; else goto cwox;
       uwoL: // global
           call _cwov(R1) args: 0, res: 0, upd: 0;
       cwox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwov() //  [R1]
         { info_tbl: [(cwov,
                       label: block_cwov_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwov: // global
           _suby::I64 = I64[Sp + 16];
           _subB::P64 = P64[Sp + 8];
           _subD::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_suby::I64,
                            _subD::I64)) goto cwoF; else goto cwoG;
       cwoF: // global
           P64[Sp + 8] = _subB::P64;
           I64[Sp + 16] = _suby::I64;
           Sp = Sp + 8;
           goto uwoO;
       cwoG: // global
           P64[Sp + 8] = _subB::P64;
           I64[Sp + 16] = _subD::I64;
           Sp = Sp + 8;
           goto uwoO;
       uwoO: // global
           call _cwod() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.120687937 UTC

[section ""data" . GHC.List.maximum_$smaximum1_closure" {
     GHC.List.maximum_$smaximum1_closure:
         const GHC.List.maximum_$smaximum1_info;
         const 0;
 },
 GHC.List.maximum_$smaximum1_entry() //  [R2]
         { info_tbl: [(cwpi,
                       label: GHC.List.maximum_$smaximum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwpi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwpj; else goto cwpk;
       cwpj: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwpk: // global
           I64[Sp - 8] = block_cwpb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwpG; else goto cwpc;
       uwpG: // global
           call _cwpb(R1) args: 0, res: 0, upd: 0;
       cwpc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwpb() //  [R1]
         { info_tbl: [(cwpb,
                       label: block_cwpb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwpb: // global
           if (R1 & 7 == 1) goto cwpf; else goto cwpg;
       cwpf: // global
           R1 = GHC.List.maximum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwpg: // global
           I64[Sp - 8] = block_cwpq_info;
           _subI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _subI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwpF; else goto cwpr;
       uwpF: // global
           call _cwpq(R1) args: 0, res: 0, upd: 0;
       cwpr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwpq() //  [R1]
         { info_tbl: [(cwpq,
                       label: block_cwpq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwpq: // global
           _subI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cwpv_info;
           R3 = I64[R1 + 7];
           R2 = _subI::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cwpv() //  [R1]
         { info_tbl: [(cwpv,
                       label: block_cwpv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwpv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwpE; else goto cwpD;
       cwpE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cwpD: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.131175909 UTC

[section ""data" . GHC.List.maximum_closure" {
     GHC.List.maximum_closure:
         const GHC.List.maximum_info;
         const 0;
 },
 sat_subX_entry() //  [R1]
         { info_tbl: [(cwqq,
                       label: sat_subX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwqq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwqr; else goto cwqs;
       cwqr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwqs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.max_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.List.maximum_entry() //  [R2, R3]
         { info_tbl: [(cwqx,
                       label: GHC.List.maximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwqx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwqy; else goto cwqz;
       cwqy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwqz: // global
           I64[Sp - 16] = block_cwq5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwqS; else goto cwq6;
       uwqS: // global
           call _cwq5(R1) args: 0, res: 0, upd: 0;
       cwq6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwq5() //  [R1]
         { info_tbl: [(cwq5,
                       label: block_cwq5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwq5: // global
           if (R1 & 7 == 1) goto cwqu; else goto cwqv;
       cwqu: // global
           R1 = lvl19_ru9c_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwqv: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cwqe() args: 0, res: 0, upd: 0;
     }
 },
 _cwqe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwqe: // global
           I64[Sp - 8] = block_cwqg_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwqQ; else goto cwqh;
       uwqQ: // global
           call _cwqg(R1) args: 0, res: 0, upd: 0;
       cwqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwqg() //  [R1]
         { info_tbl: [(cwqg,
                       label: block_cwqg_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwqg: // global
           _subT::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwqH; else goto cwqI;
       cwqH: // global
           R1 = _subT::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwqI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cwqL; else goto cwqK;
       cwqL: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwqK: // global
           _subV::P64 = P64[R1 + 6];
           _subW::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_subX_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _subT::P64;
           P64[Hp] = _subV::P64;
           P64[Sp + 16] = _subW::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cwqe() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.143048554 UTC

[section ""data" . GHC.List.$wgo1_closure" {
     GHC.List.$wgo1_closure:
         const GHC.List.$wgo1_info;
 },
 GHC.List.$wgo1_entry() //  [R2, R3]
         { info_tbl: [(cwrx,
                       label: GHC.List.$wgo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwrx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwry; else goto uwrR;
       cwry: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwrR: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwrn() args: 0, res: 0, upd: 0;
     }
 },
 _cwrn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwrn: // global
           _subY::P64 = P64[Sp];
           I64[Sp] = block_cwrq_info;
           R1 = _subY::P64;
           if (R1 & 7 != 0) goto uwrU; else goto cwrr;
       uwrU: // global
           call _cwrq(R1) args: 0, res: 0, upd: 0;
       cwrr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwrq() //  [R1]
         { info_tbl: [(cwrq,
                       label: block_cwrq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwrq: // global
           if (R1 & 7 == 1) goto cwru; else goto cwrv;
       cwru: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwrv: // global
           I64[Sp - 8] = block_cwrF_info;
           _suc2::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _suc2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwrV; else goto cwrH;
       uwrV: // global
           call _cwrF(R1) args: 0, res: 0, upd: 0;
       cwrH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwrF() //  [R1]
         { info_tbl: [(cwrF,
                       label: block_cwrF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwrF: // global
           _subZ::I64 = I64[Sp + 16];
           _suc2::P64 = P64[Sp + 8];
           _suc4::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_subZ::I64,
                            _suc4::I64)) goto cwrP; else goto cwrQ;
       cwrP: // global
           P64[Sp + 8] = _suc2::P64;
           I64[Sp + 16] = _suc4::I64;
           Sp = Sp + 8;
           goto uwrY;
       cwrQ: // global
           P64[Sp + 8] = _suc2::P64;
           I64[Sp + 16] = _subZ::I64;
           Sp = Sp + 8;
           goto uwrY;
       uwrY: // global
           call _cwrn() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.15225938 UTC

[section ""data" . GHC.List.minimum_$sminimum1_closure" {
     GHC.List.minimum_$sminimum1_closure:
         const GHC.List.minimum_$sminimum1_info;
         const 0;
 },
 GHC.List.minimum_$sminimum1_entry() //  [R2]
         { info_tbl: [(cwss,
                       label: GHC.List.minimum_$sminimum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwss: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwst; else goto cwsu;
       cwst: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwsu: // global
           I64[Sp - 8] = block_cwsl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwsQ; else goto cwsm;
       uwsQ: // global
           call _cwsl(R1) args: 0, res: 0, upd: 0;
       cwsm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwsl() //  [R1]
         { info_tbl: [(cwsl,
                       label: block_cwsl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwsl: // global
           if (R1 & 7 == 1) goto cwsp; else goto cwsq;
       cwsp: // global
           R1 = GHC.List.minimum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwsq: // global
           I64[Sp - 8] = block_cwsA_info;
           _suc9::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _suc9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwsP; else goto cwsB;
       uwsP: // global
           call _cwsA(R1) args: 0, res: 0, upd: 0;
       cwsB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwsA() //  [R1]
         { info_tbl: [(cwsA,
                       label: block_cwsA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwsA: // global
           _suc9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cwsF_info;
           R3 = I64[R1 + 7];
           R2 = _suc9::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cwsF() //  [R1]
         { info_tbl: [(cwsF,
                       label: block_cwsF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwsF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwsO; else goto cwsN;
       cwsO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cwsN: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.162091904 UTC

[section ""data" . GHC.List.minimum_closure" {
     GHC.List.minimum_closure:
         const GHC.List.minimum_info;
         const 0;
 },
 sat_suco_entry() //  [R1]
         { info_tbl: [(cwtA,
                       label: sat_suco_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwtA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwtB; else goto cwtC;
       cwtB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwtC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.min_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.List.minimum_entry() //  [R2, R3]
         { info_tbl: [(cwtH,
                       label: GHC.List.minimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwtH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwtI; else goto cwtJ;
       cwtI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwtJ: // global
           I64[Sp - 16] = block_cwtf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwu2; else goto cwtg;
       uwu2: // global
           call _cwtf(R1) args: 0, res: 0, upd: 0;
       cwtg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwtf() //  [R1]
         { info_tbl: [(cwtf,
                       label: block_cwtf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwtf: // global
           if (R1 & 7 == 1) goto cwtE; else goto cwtF;
       cwtE: // global
           R1 = lvl22_ru9f_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwtF: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cwto() args: 0, res: 0, upd: 0;
     }
 },
 _cwto() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwto: // global
           I64[Sp - 8] = block_cwtq_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwu0; else goto cwtr;
       uwu0: // global
           call _cwtq(R1) args: 0, res: 0, upd: 0;
       cwtr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwtq() //  [R1]
         { info_tbl: [(cwtq,
                       label: block_cwtq_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwtq: // global
           _suck::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwtR; else goto cwtS;
       cwtR: // global
           R1 = _suck::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwtS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cwtV; else goto cwtU;
       cwtV: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwtU: // global
           _sucm::P64 = P64[R1 + 6];
           _sucn::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_suco_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _suck::P64;
           P64[Hp] = _sucm::P64;
           P64[Sp + 16] = _sucn::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cwto() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.174067891 UTC

[section ""cstring" . lvl23_ru9g_bytes" {
     lvl23_ru9g_bytes:
         I8[] [102,111,108,100,108,49,39]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.176013676 UTC

[section ""data" . lvl24_ru9h_closure" {
     lvl24_ru9h_closure:
         const lvl24_ru9h_info;
         const 0;
         const 0;
         const 0;
 },
 lvl24_ru9h_entry() //  [R1]
         { info_tbl: [(cwuD,
                       label: lvl24_ru9h_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwuD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwuE; else goto cwuF;
       cwuE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwuF: // global
           (_cwuA::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwuA::I64 == 0) goto cwuC; else goto cwuB;
       cwuC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwuB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwuA::I64;
           R2 = lvl23_ru9g_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.18052376 UTC

[section ""data" . GHC.List.foldl1'1_closure" {
     GHC.List.foldl1'1_closure:
         const GHC.List.foldl1'1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl1'1_entry() //  [R1]
         { info_tbl: [(cwuT,
                       label: GHC.List.foldl1'1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwuT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwuU; else goto cwuV;
       cwuU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwuV: // global
           (_cwuQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwuQ::I64 == 0) goto cwuS; else goto cwuR;
       cwuS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwuR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwuQ::I64;
           R2 = lvl24_ru9h_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.18427985 UTC

[section ""cstring" . lvl25_ru9i_bytes" {
     lvl25_ru9i_bytes:
         I8[] [102,111,108,100,108,49]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.186283086 UTC

[section ""data" . lvl26_ru9j_closure" {
     lvl26_ru9j_closure:
         const lvl26_ru9j_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_ru9j_entry() //  [R1]
         { info_tbl: [(cwva,
                       label: lvl26_ru9j_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwva: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwvb; else goto cwvc;
       cwvb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwvc: // global
           (_cwv7::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwv7::I64 == 0) goto cwv9; else goto cwv8;
       cwv9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwv8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwv7::I64;
           R2 = lvl25_ru9i_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.190288084 UTC

[section ""data" . GHC.List.foldl2_closure" {
     GHC.List.foldl2_closure:
         const GHC.List.foldl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl2_entry() //  [R1]
         { info_tbl: [(cwvq,
                       label: GHC.List.foldl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwvq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwvr; else goto cwvs;
       cwvr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwvs: // global
           (_cwvn::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwvn::I64 == 0) goto cwvp; else goto cwvo;
       cwvp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwvo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwvn::I64;
           R2 = lvl26_ru9j_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.195390226 UTC

[section ""data" . $wgo2_ru9k_closure" {
     $wgo2_ru9k_closure:
         const $wgo2_ru9k_info;
 },
 ds_sucx_entry() //  [R1]
         { info_tbl: [(cwvW,
                       label: ds_sucx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwvW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwvX; else goto cwvY;
       cwvX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwvY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cwvT_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cwvT() //  [R1, R2, R3]
         { info_tbl: [(cwvT,
                       label: block_cwvT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwvT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cww1; else goto cww0;
       cww1: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 24;
       cww0: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo2_ru9k_entry() //  [R2]
         { info_tbl: [(cww6,
                       label: $wgo2_ru9k_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cww6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cww7; else goto cww8;
       cww7: // global
           R2 = R2;
           R1 = $wgo2_ru9k_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cww8: // global
           I64[Sp - 8] = block_cwvE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwwm; else goto cwvF;
       uwwm: // global
           call _cwvE(R1) args: 0, res: 0, upd: 0;
       cwvF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwvE() //  [R1]
         { info_tbl: [(cwvE,
                       label: block_cwvE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwvE: // global
           if (R1 & 7 == 1) goto cww3; else goto cww4;
       cww3: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cww4: // global
           I64[Sp - 8] = block_cwvK_info;
           _sucs::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sucs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwwl; else goto cwvL;
       uwwl: // global
           call _cwvK(R1) args: 0, res: 0, upd: 0;
       cwvL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwvK() //  [R1]
         { info_tbl: [(cwvK,
                       label: block_cwvK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwvK: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cwwk; else goto cwwj;
       cwwk: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwwj: // global
           _sucu::P64 = P64[R1 + 7];
           _sucv::P64 = P64[R1 + 15];
           _sucw::P64 = P64[R1 + 23];
           I64[Hp - 160] = ds_sucx_info;
           P64[Hp - 144] = P64[Sp + 8];
           I64[Hp - 136] = stg_sel_2_upd_info;
           _cwvP::P64 = Hp - 160;
           P64[Hp - 120] = _cwvP::P64;
           I64[Hp - 112] = :_con_info;
           P64[Hp - 104] = _sucw::P64;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _cwvP::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sucv::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cwvP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sucu::P64;
           P64[Hp] = Hp - 40;
           R3 = Hp - 110;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.207919228 UTC

[section ""data" . go_ru9l_closure" {
     go_ru9l_closure:
         const go_ru9l_info;
 },
 go_ru9l_entry() //  [R2]
         { info_tbl: [(cwwX,
                       label: go_ru9l_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwwX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwwY; else goto cwwZ;
       cwwY: // global
           R2 = R2;
           R1 = go_ru9l_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwwZ: // global
           I64[Sp - 8] = block_cwwU_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cwwU() //  [R1, R2, R3]
         { info_tbl: [(cwwU,
                       label: block_cwwU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwwU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cwx2; else goto cwx1;
       cwx2: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cwx1: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.213340353 UTC

[section ""data" . GHC.List.unzip3_closure" {
     GHC.List.unzip3_closure:
         const GHC.List.unzip3_info;
 },
 GHC.List.unzip3_entry() //  [R2]
         { info_tbl: [(cwxg,
                       label: GHC.List.unzip3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwxg: // global
           R2 = R2;
           call go_ru9l_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.217198639 UTC

[section ""data" . $wgo3_ru9m_closure" {
     $wgo3_ru9m_closure:
         const $wgo3_ru9m_info;
 },
 ds_sud6_entry() //  [R1]
         { info_tbl: [(cwxJ,
                       label: ds_sud6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwxJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwxK; else goto cwxL;
       cwxK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwxL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cwxG_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cwxG() //  [R1, R2]
         { info_tbl: [(cwxG,
                       label: block_cwxG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwxG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwxO; else goto cwxN;
       cwxO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cwxN: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo3_ru9m_entry() //  [R2]
         { info_tbl: [(cwxT,
                       label: $wgo3_ru9m_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwxT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwxU; else goto cwxV;
       cwxU: // global
           R2 = R2;
           R1 = $wgo3_ru9m_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwxV: // global
           I64[Sp - 8] = block_cwxr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwy7; else goto cwxs;
       uwy7: // global
           call _cwxr(R1) args: 0, res: 0, upd: 0;
       cwxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwxr() //  [R1]
         { info_tbl: [(cwxr,
                       label: block_cwxr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwxr: // global
           if (R1 & 7 == 1) goto cwxQ; else goto cwxR;
       cwxQ: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cwxR: // global
           I64[Sp - 8] = block_cwxx_info;
           _sud2::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sud2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwy6; else goto cwxy;
       uwy6: // global
           call _cwxx(R1) args: 0, res: 0, upd: 0;
       cwxy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwxx() //  [R1]
         { info_tbl: [(cwxx,
                       label: block_cwxx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwxx: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cwy5; else goto cwy4;
       cwy5: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwy4: // global
           _sud4::P64 = P64[R1 + 7];
           _sud5::P64 = P64[R1 + 15];
           I64[Hp - 112] = ds_sud6_info;
           P64[Hp - 96] = P64[Sp + 8];
           I64[Hp - 88] = stg_sel_1_upd_info;
           _cwxC::P64 = Hp - 112;
           P64[Hp - 72] = _cwxC::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sud5::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cwxC::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sud4::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.230219178 UTC

[section ""data" . go1_ru9n_closure" {
     go1_ru9n_closure:
         const go1_ru9n_info;
 },
 go1_ru9n_entry() //  [R2]
         { info_tbl: [(cwyH,
                       label: go1_ru9n_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwyH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwyI; else goto cwyJ;
       cwyI: // global
           R2 = R2;
           R1 = go1_ru9n_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwyJ: // global
           I64[Sp - 8] = block_cwyE_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cwyE() //  [R1, R2]
         { info_tbl: [(cwyE,
                       label: block_cwyE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwyE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwyM; else goto cwyL;
       cwyM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cwyL: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.235789809 UTC

[section ""data" . GHC.List.unzip_closure" {
     GHC.List.unzip_closure:
         const GHC.List.unzip_info;
 },
 GHC.List.unzip_entry() //  [R2]
         { info_tbl: [(cwz0,
                       label: GHC.List.unzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwz0: // global
           R2 = R2;
           call go1_ru9n_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.24026922 UTC

[section ""data" . GHC.List.zipWith3_closure" {
     GHC.List.zipWith3_closure:
         const GHC.List.zipWith3_info;
 },
 go2_suds_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cwzn,
                       label: go2_suds_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwzn: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cwzo; else goto cwzp;
       cwzo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwzp: // global
           I64[Sp - 40] = block_cwzg_info;
           _suds::P64 = R1;
           _sudo::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 32] = _sudo::P64;
           P64[Sp - 24] = _suds::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uwA6; else goto cwzh;
       uwA6: // global
           call _cwzg(R1) args: 0, res: 0, upd: 0;
       cwzh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwzg() //  [R1]
         { info_tbl: [(cwzg,
                       label: block_cwzg_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwzg: // global
           if (R1 & 7 == 1) goto uwA1; else goto cwzl;
       uwA1: // global
           Sp = Sp + 40;
           call _cwzP() args: 0, res: 0, upd: 0;
       cwzl: // global
           I64[Sp - 8] = block_cwzv_info;
           _sudx::P64 = P64[R1 + 6];
           _sudy::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sudy::P64;
           P64[Sp + 24] = _sudx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwA4; else goto cwzx;
       uwA4: // global
           call _cwzv(R1) args: 0, res: 0, upd: 0;
       cwzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwzv() //  [R1]
         { info_tbl: [(cwzv,
                       label: block_cwzv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwzv: // global
           if (R1 & 7 == 1) goto uwA2; else goto cwzI;
       uwA2: // global
           Sp = Sp + 48;
           call _cwzP() args: 0, res: 0, upd: 0;
       cwzI: // global
           I64[Sp - 8] = block_cwzG_info;
           _sudA::P64 = P64[R1 + 6];
           _sudB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sudB::P64;
           P64[Sp + 40] = _sudA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwA7; else goto cwzJ;
       uwA7: // global
           call _cwzG(R1) args: 0, res: 0, upd: 0;
       cwzJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwzG() //  [R1]
         { info_tbl: [(cwzG,
                       label: block_cwzG_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwzG: // global
           if (R1 & 7 == 1) goto uwA3; else goto cwzV;
       uwA3: // global
           Sp = Sp + 56;
           call _cwzP() args: 0, res: 0, upd: 0;
       cwzV: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cwzY; else goto cwzX;
       cwzY: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwzX: // global
           _sudD::P64 = P64[R1 + 6];
           _sudE::P64 = P64[R1 + 14];
           I64[Hp - 112] = stg_ap_4_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 16];
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sudE::P64;
           I64[Hp - 64] = stg_ap_4_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = _sudD::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cwzP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwzP: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cwAa,
                       label: GHC.List.zipWith3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwAa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwAe; else goto cwAd;
       cwAe: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwAd: // global
           I64[Hp - 8] = go2_suds_info;
           P64[Hp] = R2;
           _sudq::P64 = R4;
           R4 = R5;
           _sudp::P64 = R3;
           R3 = _sudq::P64;
           R2 = _sudp::P64;
           R1 = Hp - 5;
           call go2_suds_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.254613508 UTC

[section ""data" . GHC.List.zipWithFB_closure" {
     GHC.List.zipWithFB_closure:
         const GHC.List.zipWithFB_info;
 },
 GHC.List.zipWithFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cwAW,
                       label: GHC.List.zipWithFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwAW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cwB0; else goto cwAZ;
       cwB0: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWithFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwAZ: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R3 = R6;
           _sudH::P64 = R2;
           R2 = Hp - 32;
           R1 = _sudH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.259336894 UTC

[section ""data" . GHC.List.zip3_closure" {
     GHC.List.zip3_closure:
         const GHC.List.zip3_info;
 },
 sat_sue0_entry() //  [R1]
         { info_tbl: [(cwBv,
                       label: sat_sue0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwBv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwBw; else goto cwBx;
       cwBw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwBx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.zip3_entry() //  [R2, R3, R4]
         { info_tbl: [(cwBC,
                       label: GHC.List.zip3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwBC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwBD; else goto cwBE;
       cwBD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwBE: // global
           I64[Sp - 24] = block_cwB9_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uwC8; else goto cwBa;
       uwC8: // global
           call _cwB9(R1) args: 0, res: 0, upd: 0;
       cwBa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwB9() //  [R1]
         { info_tbl: [(cwB9,
                       label: block_cwB9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwB9: // global
           if (R1 & 7 == 1) goto uwC0; else goto cwBA;
       uwC0: // global
           Sp = Sp + 24;
           call _cwBR() args: 0, res: 0, upd: 0;
       cwBA: // global
           I64[Sp - 8] = block_cwBf_info;
           _sudR::P64 = P64[R1 + 6];
           _sudS::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sudS::P64;
           P64[Sp + 8] = _sudR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwC3; else goto cwBg;
       uwC3: // global
           call _cwBf(R1) args: 0, res: 0, upd: 0;
       cwBg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwBf() //  [R1]
         { info_tbl: [(cwBf,
                       label: block_cwBf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwBf: // global
           if (R1 & 7 == 1) goto uwC1; else goto cwBN;
       uwC1: // global
           Sp = Sp + 32;
           call _cwBR() args: 0, res: 0, upd: 0;
       cwBN: // global
           I64[Sp - 8] = block_cwBl_info;
           _sudU::P64 = P64[R1 + 6];
           _sudV::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sudV::P64;
           P64[Sp + 24] = _sudU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwC5; else goto cwBm;
       uwC5: // global
           call _cwBl(R1) args: 0, res: 0, upd: 0;
       cwBm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwBl() //  [R1]
         { info_tbl: [(cwBl,
                       label: block_cwBl_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwBl: // global
           if (R1 & 7 == 1) goto uwC2; else goto cwBU;
       uwC2: // global
           Sp = Sp + 40;
           call _cwBR() args: 0, res: 0, upd: 0;
       cwBU: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cwBX; else goto cwBW;
       cwBX: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwBW: // global
           _sudX::P64 = P64[R1 + 6];
           _sudY::P64 = P64[R1 + 14];
           I64[Hp - 88] = sat_sue0_info;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sudY::P64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sudX::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 47;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cwBR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwBR: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.272587749 UTC

[section ""data" . GHC.List.zipFB_closure" {
     GHC.List.zipFB_closure:
         const GHC.List.zipFB_info;
 },
 GHC.List.zipFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cwCP,
                       label: GHC.List.zipFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwCP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwCT; else goto cwCS;
       cwCT: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwCS: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _sue1::P64 = R2;
           R2 = Hp - 15;
           R1 = _sue1::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.277407209 UTC

[section ""data" . GHC.List.foldr2_left_closure" {
     GHC.List.foldr2_left_closure:
         const GHC.List.foldr2_left_info;
 },
 GHC.List.foldr2_left_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cwD9,
                       label: GHC.List.foldr2_left_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwD9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwDa; else goto cwDb;
       cwDa: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_left_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwDb: // global
           I64[Sp - 40] = block_cwD2_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uwDl; else goto cwD3;
       uwDl: // global
           call _cwD2(R1) args: 0, res: 0, upd: 0;
       cwD3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwD2() //  [R1]
         { info_tbl: [(cwD2,
                       label: block_cwD2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwD2: // global
           if (R1 & 7 == 1) goto cwD6; else goto cwD7;
       cwD6: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwD7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cwDk; else goto cwDj;
       cwDk: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwDj: // global
           _suec::P64 = P64[R1 + 6];
           _sued::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sued::P64;
           R4 = Hp - 24;
           R3 = _suec::P64;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.28681214 UTC

[section ""data" . GHC.List.zip_closure" {
     GHC.List.zip_closure:
         const GHC.List.zip_info;
 },
 sat_sueo_entry() //  [R1]
         { info_tbl: [(cwDS,
                       label: sat_sueo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwDS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwDT; else goto cwDU;
       cwDT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwDU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.zip_entry() //  [R2, R3]
         { info_tbl: [(cwDZ,
                       label: GHC.List.zip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwDZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwE0; else goto cwE1;
       cwE0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwE1: // global
           I64[Sp - 16] = block_cwDC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwEl; else goto cwDD;
       uwEl: // global
           call _cwDC(R1) args: 0, res: 0, upd: 0;
       cwDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwDC() //  [R1]
         { info_tbl: [(cwDC,
                       label: block_cwDC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwDC: // global
           if (R1 & 7 == 1) goto uwEg; else goto cwDX;
       uwEg: // global
           Sp = Sp + 16;
           call _cwE8() args: 0, res: 0, upd: 0;
       cwDX: // global
           I64[Sp - 8] = block_cwDI_info;
           _suei::P64 = P64[R1 + 6];
           _suej::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _suej::P64;
           P64[Sp + 8] = _suei::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwEi; else goto cwDJ;
       uwEi: // global
           call _cwDI(R1) args: 0, res: 0, upd: 0;
       cwDJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwDI() //  [R1]
         { info_tbl: [(cwDI,
                       label: block_cwDI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwDI: // global
           if (R1 & 7 == 1) goto uwEh; else goto cwEb;
       uwEh: // global
           Sp = Sp + 24;
           call _cwE8() args: 0, res: 0, upd: 0;
       cwEb: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cwEe; else goto cwEd;
       cwEe: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwEd: // global
           _suel::P64 = P64[R1 + 6];
           _suem::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sueo_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _suem::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _suel::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cwE8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwE8: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.zipWith_closure" {
     GHC.List.zipWith_closure:
         const GHC.List.zipWith_info;
 },
 go2_sues_entry() //  [R1, R2, R3]
         { info_tbl: [(cwEC,
                       label: go2_sues_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwEC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwED; else goto cwEE;
       cwED: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwEE: // global
           I64[Sp - 32] = block_cwEv_info;
           _sues::P64 = R1;
           _suep::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 24] = _suep::P64;
           P64[Sp - 16] = _sues::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uwF7; else goto cwEw;
       uwF7: // global
           call _cwEv(R1) args: 0, res: 0, upd: 0;
       cwEw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwEv() //  [R1]
         { info_tbl: [(cwEv,
                       label: block_cwEv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwEv: // global
           if (R1 & 7 == 1) goto uwF3; else goto cwEA;
       uwF3: // global
           Sp = Sp + 32;
           call _cwES() args: 0, res: 0, upd: 0;
       cwEA: // global
           I64[Sp - 8] = block_cwEK_info;
           _suew::P64 = P64[R1 + 6];
           _suex::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _suex::P64;
           P64[Sp + 24] = _suew::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwF5; else goto cwEM;
       uwF5: // global
           call _cwEK(R1) args: 0, res: 0, upd: 0;
       cwEM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwEK() //  [R1]
         { info_tbl: [(cwEK,
                       label: block_cwEK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwEK: // global
           if (R1 & 7 == 1) goto uwF4; else goto cwEY;
       uwF4: // global
           Sp = Sp + 40;
           call _cwES() args: 0, res: 0, upd: 0;
       cwEY: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cwF1; else goto cwF0;
       cwF1: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwF0: // global
           _suez::P64 = P64[R1 + 6];
           _sueA::P64 = P64[R1 + 14];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sueA::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _suez::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cwES() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwES: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cwF9,
                       label: GHC.List.zipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwF9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwFd; else goto cwFc;
       cwFd: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwFc: // global
           I64[Hp - 8] = go2_sues_info;
           P64[Hp] = R2;
           _sueq::P64 = R3;
           R3 = R4;
           R2 = _sueq::P64;
           R1 = Hp - 6;
           call go2_sues_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.foldr2_closure" {
     GHC.List.foldr2_closure:
         const GHC.List.foldr2_info;
 },
 go2_sueH_entry() //  [R1, R2, R3]
         { info_tbl: [(cwFu,
                       label: go2_sueH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwFu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cwFv; else goto cwFw;
       cwFv: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwFw: // global
           I64[Sp - 40] = block_cwFn_info;
           _sueH::P64 = R1;
           _sueD::P64 = P64[R1 + 6];
           _sueE::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _sueD::P64;
           P64[Sp - 24] = _sueE::P64;
           P64[Sp - 16] = _sueH::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uwFX; else goto cwFo;
       uwFX: // global
           call _cwFn(R1) args: 0, res: 0, upd: 0;
       cwFo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwFn() //  [R1]
         { info_tbl: [(cwFn,
                       label: block_cwFn_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwFn: // global
           if (R1 & 7 == 1) goto uwFT; else goto cwFs;
       uwFT: // global
           Sp = Sp + 16;
           call _cwFK() args: 0, res: 0, upd: 0;
       cwFs: // global
           I64[Sp - 8] = block_cwFC_info;
           _sueL::P64 = P64[R1 + 6];
           _sueM::P64 = P64[R1 + 14];
           R1 = P64[Sp + 32];
           P64[Sp] = _sueM::P64;
           P64[Sp + 32] = _sueL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwFV; else goto cwFE;
       uwFV: // global
           call _cwFC(R1) args: 0, res: 0, upd: 0;
       cwFE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwFC() //  [R1]
         { info_tbl: [(cwFC,
                       label: block_cwFC_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwFC: // global
           if (R1 & 7 == 1) goto uwFU; else goto cwFO;
       uwFU: // global
           Sp = Sp + 24;
           call _cwFK() args: 0, res: 0, upd: 0;
       cwFO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cwFR; else goto cwFQ;
       cwFR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwFQ: // global
           _sueO::P64 = P64[R1 + 6];
           _sueP::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sueP::P64;
           R4 = Hp - 32;
           R3 = _sueO::P64;
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 16];
           Sp = Sp + 48;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cwFK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwFK: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.foldr2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cwFZ,
                       label: GHC.List.foldr2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwFZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwG3; else goto cwG2;
       cwG3: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwG2: // global
           I64[Hp - 16] = go2_sueH_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 14;
           call go2_sueH_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.318205469 UTC

[section ""data" . GHC.List.concat_go_closure" {
     GHC.List.concat_go_closure:
         const GHC.List.concat_go_info;
 },
 sat_sueV_entry() //  [R1]
         { info_tbl: [(cwHD,
                       label: sat_sueV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwHD: // global
           R2 = P64[R1 + 16];
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.concat_go_entry() //  [R2]
         { info_tbl: [(cwHK,
                       label: GHC.List.concat_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwHK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwHL; else goto cwHM;
       cwHL: // global
           R2 = R2;
           R1 = GHC.List.concat_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwHM: // global
           I64[Sp - 8] = block_cwHt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwHS; else goto cwHu;
       uwHS: // global
           call _cwHt(R1) args: 0, res: 0, upd: 0;
       cwHu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwHt() //  [R1]
         { info_tbl: [(cwHt,
                       label: block_cwHt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwHt: // global
           if (R1 & 7 == 1) goto cwHH; else goto cwHI;
       cwHH: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwHI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwHR; else goto cwHQ;
       cwHR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwHQ: // global
           _sueT::P64 = P64[R1 + 6];
           _sueU::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sueV_info;
           P64[Hp] = _sueU::P64;
           R3 = Hp - 16;
           R2 = _sueT::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.325946494 UTC

[section ""data" . GHC.List.concat_closure" {
     GHC.List.concat_closure:
         const GHC.List.concat_info;
 },
 GHC.List.concat_entry() //  [R2]
         { info_tbl: [(cwIc,
                       label: GHC.List.concat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwIc: // global
           R2 = R2;
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.330247268 UTC

[section ""data" . GHC.List.concatMap_closure" {
     GHC.List.concatMap_closure:
         const GHC.List.concatMap_info;
 },
 sat_suf4_entry() //  [R1]
         { info_tbl: [(cwIC,
                       label: sat_suf4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwIC: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go2_sueY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_sueY_entry() //  [R1, R2]
         { info_tbl: [(cwIJ,
                       label: go2_sueY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwIJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwIK; else goto cwIL;
       cwIK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwIL: // global
           I64[Sp - 24] = block_cwIs_info;
           _sueY::P64 = R1;
           _sueW::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sueW::P64;
           P64[Sp - 8] = _sueY::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uwIW; else goto cwIt;
       uwIW: // global
           call _cwIs(R1) args: 0, res: 0, upd: 0;
       cwIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwIs() //  [R1]
         { info_tbl: [(cwIs,
                       label: block_cwIs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwIs: // global
           if (R1 & 7 == 1) goto cwIG; else goto cwIH;
       cwIG: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwIH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cwIR; else goto cwIQ;
       cwIR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwIQ: // global
           _suf1::P64 = P64[R1 + 6];
           _suf2::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_suf4_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _suf2::P64;
           _sueW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cwIO_info;
           R2 = _suf1::P64;
           R1 = _sueW::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwIO() //  [R1]
         { info_tbl: [(cwIO,
                       label: block_cwIO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwIO: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.concatMap_entry() //  [R2, R3]
         { info_tbl: [(cwIX,
                       label: GHC.List.concatMap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwIX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwJ1; else goto cwJ0;
       cwJ1: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.concatMap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwJ0: // global
           I64[Hp - 8] = go2_sueY_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_sueY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.342314801 UTC

[section ""data" . GHC.List.lookup_closure" {
     GHC.List.lookup_closure:
         const GHC.List.lookup_info;
 },
 GHC.List.lookup_entry() //  [R2, R3, R4]
         { info_tbl: [(cwJA,
                       label: GHC.List.lookup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwJA: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cwJB; else goto uwK4;
       cwJB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lookup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uwK4: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cwJq() args: 0, res: 0, upd: 0;
     }
 },
 _cwJq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwJq: // global
           I64[Sp - 8] = block_cwJt_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwK6; else goto cwJu;
       uwK6: // global
           call _cwJt(R1) args: 0, res: 0, upd: 0;
       cwJu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwJt() //  [R1]
         { info_tbl: [(cwJt,
                       label: block_cwJt_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwJt: // global
           if (R1 & 7 == 1) goto cwJx; else goto cwJy;
       cwJx: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwJy: // global
           I64[Sp] = block_cwJI_info;
           _sufa::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sufa::P64;
           if (R1 & 7 != 0) goto uwK7; else goto cwJK;
       uwK7: // global
           call _cwJI(R1) args: 0, res: 0, upd: 0;
       cwJK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwJI() //  [R1]
         { info_tbl: [(cwJI,
                       label: block_cwJI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwJI: // global
           I64[Sp - 8] = block_cwJO_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cwJO() //  [R1]
         { info_tbl: [(cwJO,
                       label: block_cwJO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwJO: // global
           if (R1 & 7 == 1) goto cwJV; else goto cwJZ;
       cwJV: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 16;
           call _cwJq() args: 0, res: 0, upd: 0;
       cwJZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwK2; else goto cwK1;
       cwK2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwK1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.353487772 UTC

[section ""data" . GHC.List.notElem_closure" {
     GHC.List.notElem_closure:
         const GHC.List.notElem_info;
 },
 GHC.List.notElem_entry() //  [R2, R3, R4]
         { info_tbl: [(cwKQ,
                       label: GHC.List.notElem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwKQ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cwKR; else goto uwLb;
       cwKR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.notElem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uwLb: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cwKG() args: 0, res: 0, upd: 0;
     }
 },
 _cwKG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwKG: // global
           I64[Sp - 8] = block_cwKJ_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwLd; else goto cwKK;
       uwLd: // global
           call _cwKJ(R1) args: 0, res: 0, upd: 0;
       cwKK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwKJ() //  [R1]
         { info_tbl: [(cwKJ,
                       label: block_cwKJ_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwKJ: // global
           if (R1 & 7 == 1) goto cwKN; else goto cwKO;
       cwKN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwKO: // global
           I64[Sp] = block_cwKY_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes./=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cwKY() //  [R1]
         { info_tbl: [(cwKY,
                       label: block_cwKY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwKY: // global
           if (R1 & 7 == 1) goto cwL5; else goto cwL9;
       cwL5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwL9: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cwKG() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.363060738 UTC

[section ""data" . GHC.List.elem_closure" {
     GHC.List.elem_closure:
         const GHC.List.elem_info;
 },
 GHC.List.elem_entry() //  [R2, R3, R4]
         { info_tbl: [(cwLR,
                       label: GHC.List.elem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwLR: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cwLS; else goto uwMc;
       cwLS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.elem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uwMc: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cwLH() args: 0, res: 0, upd: 0;
     }
 },
 _cwLH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwLH: // global
           I64[Sp - 8] = block_cwLK_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwMe; else goto cwLL;
       uwMe: // global
           call _cwLK(R1) args: 0, res: 0, upd: 0;
       cwLL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwLK() //  [R1]
         { info_tbl: [(cwLK,
                       label: block_cwLK_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwLK: // global
           if (R1 & 7 == 1) goto cwLO; else goto cwLP;
       cwLO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwLP: // global
           I64[Sp] = block_cwLZ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cwLZ() //  [R1]
         { info_tbl: [(cwLZ,
                       label: block_cwLZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwLZ: // global
           if (R1 & 7 == 1) goto cwM6; else goto cwMa;
       cwM6: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cwLH() args: 0, res: 0, upd: 0;
       cwMa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.372226728 UTC

[section ""data" . GHC.List.all_closure" {
     GHC.List.all_closure:
         const GHC.List.all_info;
 },
 GHC.List.all_entry() //  [R2, R3]
         { info_tbl: [(cwMS,
                       label: GHC.List.all_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwMS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwMT; else goto uwNd;
       cwMT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.all_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwNd: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwMI() args: 0, res: 0, upd: 0;
     }
 },
 _cwMI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwMI: // global
           I64[Sp - 8] = block_cwML_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwNf; else goto cwMM;
       uwNf: // global
           call _cwML(R1) args: 0, res: 0, upd: 0;
       cwMM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwML() //  [R1]
         { info_tbl: [(cwML,
                       label: block_cwML_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwML: // global
           if (R1 & 7 == 1) goto cwMP; else goto cwMQ;
       cwMP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwMQ: // global
           I64[Sp] = block_cwN0_info;
           R2 = P64[R1 + 6];
           _sufx::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sufx::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwN0() //  [R1]
         { info_tbl: [(cwN0,
                       label: block_cwN0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwN0: // global
           if (R1 & 7 == 1) goto cwN7; else goto cwNb;
       cwN7: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwNb: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cwMI() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.381593092 UTC

[section ""data" . GHC.List.any_closure" {
     GHC.List.any_closure:
         const GHC.List.any_info;
 },
 GHC.List.any_entry() //  [R2, R3]
         { info_tbl: [(cwNP,
                       label: GHC.List.any_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwNP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwNQ; else goto uwOa;
       cwNQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.any_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwOa: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwNF() args: 0, res: 0, upd: 0;
     }
 },
 _cwNF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwNF: // global
           I64[Sp - 8] = block_cwNI_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwOc; else goto cwNJ;
       uwOc: // global
           call _cwNI(R1) args: 0, res: 0, upd: 0;
       cwNJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwNI() //  [R1]
         { info_tbl: [(cwNI,
                       label: block_cwNI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwNI: // global
           if (R1 & 7 == 1) goto cwNM; else goto cwNN;
       cwNM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwNN: // global
           I64[Sp] = block_cwNX_info;
           R2 = P64[R1 + 6];
           _sufD::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sufD::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwNX() //  [R1]
         { info_tbl: [(cwNX,
                       label: block_cwNX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwNX: // global
           if (R1 & 7 == 1) goto cwO4; else goto cwO8;
       cwO4: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cwNF() args: 0, res: 0, upd: 0;
       cwO8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.390491393 UTC

[section ""data" . GHC.List.or_closure" {
     GHC.List.or_closure:
         const GHC.List.or_info;
 },
 GHC.List.or_entry() //  [R2]
         { info_tbl: [(cwOM,
                       label: GHC.List.or_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwOM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwON; else goto uwP8;
       cwON: // global
           R2 = R2;
           R1 = GHC.List.or_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uwP8: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cwOC() args: 0, res: 0, upd: 0;
     }
 },
 _cwOC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwOC: // global
           _sufF::P64 = P64[Sp];
           I64[Sp] = block_cwOF_info;
           R1 = _sufF::P64;
           if (R1 & 7 != 0) goto uwPa; else goto cwOG;
       uwPa: // global
           call _cwOF(R1) args: 0, res: 0, upd: 0;
       cwOG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwOF() //  [R1]
         { info_tbl: [(cwOF,
                       label: block_cwOF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwOF: // global
           if (R1 & 7 == 1) goto cwOJ; else goto cwOK;
       cwOJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwOK: // global
           I64[Sp - 8] = block_cwOU_info;
           _sufI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sufI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwPb; else goto cwOW;
       uwPb: // global
           call _cwOU(R1) args: 0, res: 0, upd: 0;
       cwOW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwOU() //  [R1]
         { info_tbl: [(cwOU,
                       label: block_cwOU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwOU: // global
           if (R1 & 7 == 1) goto cwP2; else goto cwP6;
       cwP2: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cwOC() args: 0, res: 0, upd: 0;
       cwP6: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.399375952 UTC

[section ""data" . GHC.List.and_closure" {
     GHC.List.and_closure:
         const GHC.List.and_info;
 },
 GHC.List.and_entry() //  [R2]
         { info_tbl: [(cwPL,
                       label: GHC.List.and_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwPL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwPM; else goto uwQ7;
       cwPM: // global
           R2 = R2;
           R1 = GHC.List.and_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uwQ7: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cwPB() args: 0, res: 0, upd: 0;
     }
 },
 _cwPB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwPB: // global
           _sufK::P64 = P64[Sp];
           I64[Sp] = block_cwPE_info;
           R1 = _sufK::P64;
           if (R1 & 7 != 0) goto uwQ9; else goto cwPF;
       uwQ9: // global
           call _cwPE(R1) args: 0, res: 0, upd: 0;
       cwPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwPE() //  [R1]
         { info_tbl: [(cwPE,
                       label: block_cwPE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwPE: // global
           if (R1 & 7 == 1) goto cwPI; else goto cwPJ;
       cwPI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwPJ: // global
           I64[Sp - 8] = block_cwPT_info;
           _sufN::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sufN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwQa; else goto cwPV;
       uwQa: // global
           call _cwPT(R1) args: 0, res: 0, upd: 0;
       cwPV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwPT() //  [R1]
         { info_tbl: [(cwPT,
                       label: block_cwPT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwPT: // global
           if (R1 & 7 == 1) goto cwQ1; else goto cwQ5;
       cwQ1: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwQ5: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cwPB() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.408788357 UTC

[section ""data" . GHC.List.reverse1_closure" {
     GHC.List.reverse1_closure:
         const GHC.List.reverse1_info;
 },
 GHC.List.reverse1_entry() //  [R2, R3]
         { info_tbl: [(cwQO,
                       label: GHC.List.reverse1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwQO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwQP; else goto uwQW;
       cwQP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.reverse1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwQW: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwQA() args: 0, res: 0, upd: 0;
     }
 },
 _cwQA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwQA: // global
           _sufP::P64 = P64[Sp];
           I64[Sp] = block_cwQD_info;
           R1 = _sufP::P64;
           if (R1 & 7 != 0) goto uwQY; else goto cwQE;
       uwQY: // global
           call _cwQD(R1) args: 0, res: 0, upd: 0;
       cwQE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwQD() //  [R1]
         { info_tbl: [(cwQD,
                       label: block_cwQD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwQD: // global
           _sufQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwQL; else goto cwQM;
       cwQL: // global
           R1 = _sufQ::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwQM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwQV; else goto cwQU;
       cwQV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwQU: // global
           _sufS::P64 = P64[R1 + 6];
           _sufT::P64 = P64[R1 + 14];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sufS::P64;
           P64[Hp] = _sufQ::P64;
           P64[Sp] = _sufT::P64;
           P64[Sp + 8] = Hp - 14;
           call _cwQA() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.415644564 UTC

[section ""data" . GHC.List.reverse_closure" {
     GHC.List.reverse_closure:
         const GHC.List.reverse_info;
 },
 GHC.List.reverse_entry() //  [R2]
         { info_tbl: [(cwRl,
                       label: GHC.List.reverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwRl: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.419790816 UTC

[section ""data" . GHC.List.$wbreak_closure" {
     GHC.List.$wbreak_closure:
         const GHC.List.$wbreak_info;
 },
 ds_sug2_entry() //  [R1]
         { info_tbl: [(cwRN,
                       label: ds_sug2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwRN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwRO; else goto cwRP;
       cwRO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwRP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cwRK_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cwRK() //  [R1, R2]
         { info_tbl: [(cwRK,
                       label: block_cwRK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwRK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwRS; else goto cwRR;
       cwRS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cwRR: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wbreak_entry() //  [R2, R3]
         { info_tbl: [(cwRX,
                       label: GHC.List.$wbreak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwRX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwRY; else goto cwRZ;
       cwRY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wbreak_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwRZ: // global
           I64[Sp - 16] = block_cwRw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwSg; else goto cwRx;
       uwSg: // global
           call _cwRw(R1) args: 0, res: 0, upd: 0;
       cwRx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwRw() //  [R1]
         { info_tbl: [(cwRw,
                       label: block_cwRw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwRw: // global
           if (R1 & 7 == 1) goto cwRU; else goto cwRV;
       cwRU: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cwRV: // global
           I64[Sp - 24] = block_cwRC_info;
           _sufZ::P64 = P64[R1 + 6];
           R2 = _sufZ::P64;
           _sufY::P64 = R1;
           _sug0::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sufZ::P64;
           P64[Sp - 8] = _sug0::P64;
           P64[Sp] = _sufY::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwRC() //  [R1]
         { info_tbl: [(cwRC,
                       label: block_cwRC_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwRC: // global
           if (R1 & 7 == 1) goto cwS7; else goto cwSe;
       cwS7: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cwSa; else goto cwS9;
       cwSa: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwS9: // global
           I64[Hp - 96] = ds_sug2_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cwRG::P64 = Hp - 96;
           P64[Hp - 48] = _cwRG::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cwRG::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cwSe: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.432582657 UTC

[section ""data" . GHC.List.break_closure" {
     GHC.List.break_closure:
         const GHC.List.break_info;
 },
 GHC.List.break_entry() //  [R2, R3]
         { info_tbl: [(cwST,
                       label: GHC.List.break_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwST: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwSU; else goto cwSV;
       cwSU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.break_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwSV: // global
           I64[Sp - 8] = block_cwSQ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cwSQ() //  [R1, R2]
         { info_tbl: [(cwSQ,
                       label: block_cwSQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwSQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwSY; else goto cwSX;
       cwSY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cwSX: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.439590072 UTC

[section ""data" . GHC.List.$wspan_closure" {
     GHC.List.$wspan_closure:
         const GHC.List.$wspan_info;
 },
 ds_sugq_entry() //  [R1]
         { info_tbl: [(cwTu,
                       label: ds_sugq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwTu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwTv; else goto cwTw;
       cwTv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwTw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cwTr_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cwTr() //  [R1, R2]
         { info_tbl: [(cwTr,
                       label: block_cwTr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwTr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwTz; else goto cwTy;
       cwTz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cwTy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wspan_entry() //  [R2, R3]
         { info_tbl: [(cwTE,
                       label: GHC.List.$wspan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwTE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwTF; else goto cwTG;
       cwTF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wspan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwTG: // global
           I64[Sp - 16] = block_cwTc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwTW; else goto cwTd;
       uwTW: // global
           call _cwTc(R1) args: 0, res: 0, upd: 0;
       cwTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwTc() //  [R1]
         { info_tbl: [(cwTc,
                       label: block_cwTc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwTc: // global
           if (R1 & 7 == 1) goto cwTB; else goto cwTC;
       cwTB: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cwTC: // global
           I64[Sp - 24] = block_cwTi_info;
           _sugn::P64 = P64[R1 + 6];
           R2 = _sugn::P64;
           _sugm::P64 = R1;
           _sugo::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sugn::P64;
           P64[Sp - 8] = _sugo::P64;
           P64[Sp] = _sugm::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwTi() //  [R1]
         { info_tbl: [(cwTi,
                       label: block_cwTi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwTi: // global
           if (R1 & 7 == 1) goto cwTN; else goto cwTR;
       cwTN: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cwTR: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cwTU; else goto cwTT;
       cwTU: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwTT: // global
           I64[Hp - 96] = ds_sugq_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cwTn::P64 = Hp - 96;
           P64[Hp - 48] = _cwTn::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cwTn::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.452387396 UTC

[section ""data" . GHC.List.span_closure" {
     GHC.List.span_closure:
         const GHC.List.span_info;
 },
 GHC.List.span_entry() //  [R2, R3]
         { info_tbl: [(cwUz,
                       label: GHC.List.span_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwUz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwUA; else goto cwUB;
       cwUA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.span_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwUB: // global
           I64[Sp - 8] = block_cwUw_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cwUw() //  [R1, R2]
         { info_tbl: [(cwUw,
                       label: block_cwUw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwUw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwUE; else goto cwUD;
       cwUE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cwUD: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.458333627 UTC

[section ""data" . GHC.List.takeFB_closure" {
     GHC.List.takeFB_closure:
         const GHC.List.takeFB_info;
 },
 sat_sugS_entry() //  [R1]
         { info_tbl: [(cwV5,
                       label: sat_sugS_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwV5: // global
           _sugS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cwV8; else goto cwV9;
       cwV9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwVb; else goto cwVa;
       cwVb: // global
           HpAlloc = 16;
           goto cwV8;
       cwV8: // global
           R1 = _sugS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwVa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sugS::P64;
           _sugL::P64 = P64[_sugS::P64 + 16];
           _sugQ::I64 = I64[_sugS::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sugQ::I64;
           R2 = Hp - 7;
           R1 = _sugL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.takeFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cwVc,
                       label: GHC.List.takeFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwVc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwVd; else goto cwVe;
       cwVd: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwVe: // global
           I64[Sp - 40] = block_cwUS_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uwVl; else goto cwUT;
       uwVl: // global
           call _cwUS(R1) args: 0, res: 0, upd: 0;
       cwUT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwUS() //  [R1]
         { info_tbl: [(cwUS,
                       label: block_cwUS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwUS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cwVh; else goto cwVg;
       cwVh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwVg: // global
           _sugI::P64 = P64[Sp + 8];
           _sugK::P64 = P64[Sp + 24];
           _sugP::I64 = I64[R1 + 7];
           if (_sugP::I64 != 1) goto cwVj; else goto cwVk;
       cwVj: // global
           I64[Hp - 24] = sat_sugS_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = _sugP::I64;
           R3 = Hp - 24;
           R2 = _sugK::P64;
           R1 = _sugI::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwVk: // global
           Hp = Hp - 32;
           R3 = P64[Sp + 16];
           R2 = _sugK::P64;
           R1 = _sugI::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.467478643 UTC

[section ""data" . GHC.List.flipSeqTake_closure" {
     GHC.List.flipSeqTake_closure:
         const GHC.List.flipSeqTake_info;
 },
 GHC.List.flipSeqTake_entry() //  [R2, R3]
         { info_tbl: [(cwVI,
                       label: GHC.List.flipSeqTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwVI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwVJ; else goto cwVK;
       cwVJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwVK: // global
           I64[Sp - 16] = block_cwVF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwVO; else goto cwVG;
       uwVO: // global
           call _cwVF() args: 0, res: 0, upd: 0;
       cwVG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwVF() //  []
         { info_tbl: [(cwVF,
                       label: block_cwVF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwVF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.473599671 UTC

[section ""data" . GHC.List.$wunsafeTake_closure" {
     GHC.List.$wunsafeTake_closure:
         const GHC.List.$wunsafeTake_info;
 },
 sat_suh4_entry() //  [R1]
         { info_tbl: [(cwWg,
                       label: sat_suh4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwWg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwWh; else goto cwWi;
       cwWh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwWi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24] - 1;
           Sp = Sp - 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wunsafeTake_entry() //  [R2, R3]
         { info_tbl: [(cwWn,
                       label: GHC.List.$wunsafeTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwWn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwWo; else goto cwWp;
       cwWo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wunsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwWp: // global
           I64[Sp - 16] = block_cwW2_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwWB; else goto cwW3;
       uwWB: // global
           call _cwW2(R1) args: 0, res: 0, upd: 0;
       cwW3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwW2() //  [R1]
         { info_tbl: [(cwW2,
                       label: block_cwW2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwW2: // global
           if (R1 & 7 == 1) goto cwWk; else goto cwWl;
       cwWk: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwWl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cwWu; else goto cwWt;
       cwWu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwWt: // global
           _suh0::P64 = P64[R1 + 6];
           _suh2::I64 = I64[Sp + 8];
           if (_suh2::I64 != 1) goto cwWx; else goto cwWA;
       cwWx: // global
           _suh1::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_suh4_info;
           P64[Hp - 32] = _suh1::P64;
           I64[Hp - 24] = _suh2::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suh0::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwWA: // global
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = _suh0::P64;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cwWz::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cwWz::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.48243724 UTC

[section ""data" . GHC.List.unsafeTake_closure" {
     GHC.List.unsafeTake_closure:
         const GHC.List.unsafeTake_info;
 },
 GHC.List.unsafeTake_entry() //  [R2, R3]
         { info_tbl: [(cwX3,
                       label: GHC.List.unsafeTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwX3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwX4; else goto cwX5;
       cwX4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.unsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwX5: // global
           I64[Sp - 16] = block_cwX0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwX9; else goto cwX1;
       uwX9: // global
           call _cwX0(R1) args: 0, res: 0, upd: 0;
       cwX1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwX0() //  [R1]
         { info_tbl: [(cwX0,
                       label: block_cwX0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwX0: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.487781385 UTC

[section ""data" . GHC.List.take_closure" {
     GHC.List.take_closure:
         const GHC.List.take_info;
 },
 GHC.List.take_entry() //  [R2, R3]
         { info_tbl: [(cwXq,
                       label: GHC.List.take_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwXq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwXr; else goto cwXs;
       cwXr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.take_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwXs: // global
           I64[Sp - 16] = block_cwXn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwXB; else goto cwXo;
       uwXB: // global
           call _cwXn(R1) args: 0, res: 0, upd: 0;
       cwXo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwXn() //  [R1]
         { info_tbl: [(cwXn,
                       label: block_cwXn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwXn: // global
           _suhc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _suhc::I64)) goto cwXz; else goto cwXA;
       cwXz: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwXA: // global
           R3 = P64[Sp + 8];
           R2 = _suhc::I64;
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.494577198 UTC

[section ""data" . GHC.List.dropWhile_closure" {
     GHC.List.dropWhile_closure:
         const GHC.List.dropWhile_info;
 },
 GHC.List.dropWhile_entry() //  [R2, R3]
         { info_tbl: [(cwXX,
                       label: GHC.List.dropWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwXX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwXY; else goto uwYi;
       cwXY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.dropWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwYi: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwXN() args: 0, res: 0, upd: 0;
     }
 },
 _cwXN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwXN: // global
           I64[Sp - 8] = block_cwXQ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwYk; else goto cwXR;
       uwYk: // global
           call _cwXQ(R1) args: 0, res: 0, upd: 0;
       cwXR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwXQ() //  [R1]
         { info_tbl: [(cwXQ,
                       label: block_cwXQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwXQ: // global
           if (R1 & 7 == 1) goto cwXU; else goto cwXV;
       cwXU: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwXV: // global
           I64[Sp - 8] = block_cwY5_info;
           R2 = P64[R1 + 6];
           _suhg::P64 = R1;
           _suhi::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _suhi::P64;
           P64[Sp + 16] = _suhg::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwY5() //  [R1]
         { info_tbl: [(cwY5,
                       label: block_cwY5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwY5: // global
           if (R1 & 7 == 1) goto cwYc; else goto cwYg;
       cwYc: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwYg: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cwXN() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.503124652 UTC

[section ""data" . GHC.List.takeWhileFB_closure" {
     GHC.List.takeWhileFB_closure:
         const GHC.List.takeWhileFB_info;
 },
 GHC.List.takeWhileFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cwYU,
                       label: GHC.List.takeWhileFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwYU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwYV; else goto cwYW;
       cwYV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhileFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwYW: // global
           I64[Sp - 40] = block_cwYO_info;
           _suhk::P64 = R2;
           R2 = R5;
           R1 = _suhk::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwYO() //  [R1]
         { info_tbl: [(cwYO,
                       label: block_cwYO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwYO: // global
           if (R1 & 7 == 1) goto cwYR; else goto cwYS;
       cwYR: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwYS: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.509804166 UTC

[section ""data" . GHC.List.takeWhile_closure" {
     GHC.List.takeWhile_closure:
         const GHC.List.takeWhile_info;
 },
 sat_suhw_entry() //  [R1]
         { info_tbl: [(cwZw,
                       label: sat_suhw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwZw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwZx; else goto cwZy;
       cwZx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwZy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.takeWhile_entry() //  [R2, R3]
         { info_tbl: [(cwZD,
                       label: GHC.List.takeWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwZD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwZE; else goto cwZF;
       cwZE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwZF: // global
           I64[Sp - 16] = block_cwZh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwZX; else goto cwZi;
       uwZX: // global
           call _cwZh(R1) args: 0, res: 0, upd: 0;
       cwZi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwZh() //  [R1]
         { info_tbl: [(cwZh,
                       label: block_cwZh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwZh: // global
           if (R1 & 7 == 1) goto uwZT; else goto cwZB;
       uwZT: // global
           Sp = Sp + 16;
           call _cwZM() args: 0, res: 0, upd: 0;
       cwZB: // global
           I64[Sp - 16] = block_cwZn_info;
           _suht::P64 = P64[R1 + 6];
           R2 = _suht::P64;
           _suhu::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _suhu::P64;
           P64[Sp] = _suht::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwZn() //  [R1]
         { info_tbl: [(cwZn,
                       label: block_cwZn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwZn: // global
           if (R1 & 7 == 1) goto uwZU; else goto cwZO;
       uwZU: // global
           Sp = Sp + 32;
           call _cwZM() args: 0, res: 0, upd: 0;
       cwZO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cwZR; else goto cwZQ;
       cwZR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwZQ: // global
           I64[Hp - 48] = sat_suhw_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cwZM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cwZM: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.520167757 UTC

[section ""data" . GHC.List.repeat_closure" {
     GHC.List.repeat_closure:
         const GHC.List.repeat_info;
 },
 GHC.List.repeat_entry() //  [R2]
         { info_tbl: [(cx0v,
                       label: GHC.List.repeat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx0v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx0z; else goto cx0y;
       cx0z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.List.repeat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cx0y: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           _cx0u::P64 = Hp - 14;
           P64[Hp] = _cx0u::P64;
           R1 = _cx0u::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.repeatFB_closure" {
     GHC.List.repeatFB_closure:
         const GHC.List.repeatFB_info;
 },
 GHC.List.repeatFB_entry() //  [R2, R3]
         { info_tbl: [(cx0F,
                       label: GHC.List.repeatFB_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx0F: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cx0J; else goto cx0I;
       cx0J: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.repeatFB_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx0I: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           _cx0E::P64 = Hp - 32;
           P64[Hp] = _cx0E::P64;
           R1 = _cx0E::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.527617275 UTC

[section ""data" . GHC.List.replicate_closure" {
     GHC.List.replicate_closure:
         const GHC.List.replicate_info;
 },
 sat_suhM_entry() //  [R1]
         { info_tbl: [(cx1k,
                       label: sat_suhM_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx1k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cx1l; else goto cx1m;
       cx1l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx1m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_suhI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_suhI_entry() //  [R1, R2]
         { info_tbl: [(cx1q,
                       label: $wxs_suhI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx1q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cx1u; else goto cx1t;
       cx1u: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cx1t: // global
           if (R2 == 1) goto cx1p; else goto cx1o;
       cx1p: // global
           _suhH::P64 = P64[R1 + 15];
           Hp = Hp - 56;
           R1 = _suhH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cx1o: // global
           _suhD::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_suhM_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suhD::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.replicate_entry() //  [R2, R3]
         { info_tbl: [(cx1w,
                       label: GHC.List.replicate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx1w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cx1x; else goto cx1y;
       cx1x: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.replicate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx1y: // global
           I64[Sp - 16] = block_cx0X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ux1F; else goto cx0Y;
       ux1F: // global
           call _cx0X(R1) args: 0, res: 0, upd: 0;
       cx0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cx0X() //  [R1]
         { info_tbl: [(cx0X,
                       label: block_cx0X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx0X: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cx1B; else goto cx1A;
       cx1B: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx1A: // global
           _suhF::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _suhF::I64)) goto cx1D; else goto cx1E;
       cx1D: // global
           Hp = Hp - 48;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cx1E: // global
           I64[Hp - 40] = :_con_info;
           _suhD::P64 = P64[Sp + 8];
           P64[Hp - 32] = _suhD::P64;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = $wxs_suhI_info;
           P64[Hp - 8] = _suhD::P64;
           P64[Hp] = Hp - 38;
           R2 = _suhF::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call $wxs_suhI_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.539040852 UTC

[section ""data" . GHC.List.$witerate'_closure" {
     GHC.List.$witerate'_closure:
         const GHC.List.$witerate'_info;
 },
 sat_suhT_entry() //  [R1]
         { info_tbl: [(cx2f,
                       label: sat_suhT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx2f: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx2g; else goto cx2h;
       cx2g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx2h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cx2c_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cx2c() //  [R1, R2]
         { info_tbl: [(cx2c,
                       label: block_cx2c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx2c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx2k; else goto cx2j;
       cx2k: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cx2j: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$witerate'_entry() //  [R2, R3]
         { info_tbl: [(cx2l,
                       label: GHC.List.$witerate'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx2l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx2m; else goto cx2n;
       cx2m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx2n: // global
           I64[Sp - 24] = block_cx26_info;
           _suhN::P64 = R2;
           R2 = R3;
           R1 = _suhN::P64;
           P64[Sp - 16] = _suhN::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cx26() //  [R1]
         { info_tbl: [(cx26,
                       label: block_cx26_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx26: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cx2q; else goto cx2p;
       cx2q: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx2p: // global
           I64[Hp - 24] = sat_suhT_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = Hp - 24;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.54968175 UTC

[section ""data" . GHC.List.iterate'FB_closure" {
     GHC.List.iterate'FB_closure:
         const GHC.List.iterate'FB_info;
 },
 go2_suhX_entry() //  [R1, R2]
         { info_tbl: [(cx2V,
                       label: go2_suhX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx2V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cx2W; else goto cx2X;
       cx2W: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cx2X: // global
           I64[Sp - 32] = block_cx2S_info;
           _suhY::P64 = R2;
           R2 = R2;
           _suhX::P64 = R1;
           _suhU::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 24] = _suhU::P64;
           P64[Sp - 16] = _suhX::P64;
           P64[Sp - 8] = _suhY::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cx2S() //  [R1]
         { info_tbl: [(cx2S,
                       label: block_cx2S_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx2S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cx30; else goto cx2Z;
       cx30: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx2Z: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.iterate'FB_entry() //  [R2, R3, R4]
         { info_tbl: [(cx31,
                       label: GHC.List.iterate'FB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx31: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx35; else goto cx34;
       cx35: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'FB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cx34: // global
           I64[Hp - 16] = go2_suhX_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_suhX_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.iterate'_closure" {
     GHC.List.iterate'_closure:
         const GHC.List.iterate'_info;
 },
 GHC.List.iterate'_entry() //  [R2, R3]
         { info_tbl: [(cx3d,
                       label: GHC.List.iterate'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx3d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cx3e; else goto cx3f;
       cx3e: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx3f: // global
           I64[Sp - 8] = block_cx3a_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cx3a() //  [R1, R2]
         { info_tbl: [(cx3a,
                       label: block_cx3a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx3a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx3i; else goto cx3h;
       cx3i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cx3h: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.562560706 UTC

[section ""data" . GHC.List.$witerate_closure" {
     GHC.List.$witerate_closure:
         const GHC.List.$witerate_info;
 },
 sat_suic_entry() //  [R1]
         { info_tbl: [(cx3Q,
                       label: sat_suic_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx3Q: // global
           _suic::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cx3R; else goto cx3S;
       cx3S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cx3U; else goto cx3T;
       cx3U: // global
           HpAlloc = 32;
           goto cx3R;
       cx3R: // global
           R1 = _suic::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx3T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suic::P64;
           _sui6::P64 = P64[_suic::P64 + 16];
           _sui7::P64 = P64[_suic::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sui6::P64;
           P64[Hp] = _sui7::P64;
           I64[Sp - 24] = block_cx3N_info;
           R3 = Hp - 24;
           R2 = _sui6::P64;
           Sp = Sp - 24;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cx3N() //  [R1, R2]
         { info_tbl: [(cx3N,
                       label: block_cx3N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx3N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx3X; else goto cx3W;
       cx3X: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cx3W: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$witerate_entry() //  [R2, R3]
         { info_tbl: [(cx3Y,
                       label: GHC.List.$witerate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx3Y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cx42; else goto cx41;
       cx42: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx41: // global
           I64[Hp - 24] = sat_suic_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.571575316 UTC

[section ""data" . GHC.List.iterateFB_closure" {
     GHC.List.iterateFB_closure:
         const GHC.List.iterateFB_info;
 },
 sat_suij_entry() //  [R1]
         { info_tbl: [(cx4u,
                       label: sat_suij_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx4u: // global
           _suij::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cx4v; else goto cx4w;
       cx4w: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cx4y; else goto cx4x;
       cx4y: // global
           HpAlloc = 32;
           goto cx4v;
       cx4v: // global
           R1 = _suij::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx4x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suij::P64;
           _suie::P64 = P64[_suij::P64 + 16];
           _suig::P64 = P64[_suij::P64 + 24];
           _suih::P64 = P64[_suij::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _suie::P64;
           P64[Hp] = _suih::P64;
           R2 = Hp - 24;
           R1 = _suig::P64;
           Sp = Sp - 16;
           call go2_suig_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go2_suig_entry() //  [R1, R2]
         { info_tbl: [(cx4z,
                       label: go2_suig_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx4z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cx4D; else goto cx4C;
       cx4D: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cx4C: // global
           _suid::P64 = P64[R1 + 7];
           _suie::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_suij_info;
           P64[Hp - 16] = _suie::P64;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = R2;
           R1 = _suid::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.iterateFB_entry() //  [R2, R3, R4]
         { info_tbl: [(cx4E,
                       label: GHC.List.iterateFB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx4E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx4I; else goto cx4H;
       cx4I: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterateFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cx4H: // global
           I64[Hp - 16] = go2_suig_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_suig_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.iterate_closure" {
     GHC.List.iterate_closure:
         const GHC.List.iterate_info;
 },
 GHC.List.iterate_entry() //  [R2, R3]
         { info_tbl: [(cx4Q,
                       label: GHC.List.iterate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx4Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cx4R; else goto cx4S;
       cx4R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx4S: // global
           I64[Sp - 8] = block_cx4N_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cx4N() //  [R1, R2]
         { info_tbl: [(cx4N,
                       label: block_cx4N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx4N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx4V; else goto cx4U;
       cx4V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cx4U: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.584599465 UTC

[section ""cstring" . lvl27_ru9o_bytes" {
     lvl27_ru9o_bytes:
         I8[] [71,72,67,47,76,105,115,116,46,104,115,58,52,49,49,58,51,52,45,53,53,124,113,115,64,40,113,32,58,32,95,41]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.586600678 UTC

[section ""data" . lvl28_ru9p_closure" {
     lvl28_ru9p_closure:
         const lvl28_ru9p_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_ru9p_entry() //  [R1]
         { info_tbl: [(cx5n,
                       label: lvl28_ru9p_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx5n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cx5o; else goto cx5p;
       cx5o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx5p: // global
           (_cx5k::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cx5k::I64 == 0) goto cx5m; else goto cx5l;
       cx5m: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cx5l: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cx5k::I64;
           R2 = lvl27_ru9o_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.592196065 UTC

[section ""data" . GHC.List.scanr1_closure" {
     GHC.List.scanr1_closure:
         const GHC.List.scanr1_info;
         const 0;
 },
 ds3_suix_entry() //  [R1]
         { info_tbl: [(cx5X,
                       label: ds3_suix_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx5X: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx5Y; else goto cx5Z;
       cx5Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx5Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cx5R_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.scanr1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cx5R() //  [R1]
         { info_tbl: [(cx5R,
                       label: block_cx5R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx5R: // global
           if (R1 & 7 == 1) goto cx5U; else goto cx5V;
       cx5U: // global
           R1 = lvl28_ru9p_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cx5V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx68; else goto cx67;
       cx68: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cx67: // global
           _suiz::P64 = P64[R1 + 6];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _suiz::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_suiF_entry() //  [R1]
         { info_tbl: [(cx6f,
                       label: sat_suiF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx6f: // global
           _suiF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cx6g; else goto cx6h;
       cx6h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx6j; else goto cx6i;
       cx6j: // global
           HpAlloc = 24;
           goto cx6g;
       cx6g: // global
           R1 = _suiF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx6i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suiF::P64;
           _suip::P64 = P64[_suiF::P64 + 16];
           _suis::P64 = P64[_suiF::P64 + 24];
           _suix::P64 = P64[_suiF::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _suix::P64;
           R3 = Hp - 16;
           R2 = _suis::P64;
           R1 = _suip::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.scanr1_entry() //  [R2, R3]
         { info_tbl: [(cx6o,
                       label: GHC.List.scanr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx6o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx6p; else goto cx6q;
       cx6p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx6q: // global
           I64[Sp - 16] = block_cx5B_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ux6I; else goto cx5C;
       ux6I: // global
           call _cx5B(R1) args: 0, res: 0, upd: 0;
       cx5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cx5B() //  [R1]
         { info_tbl: [(cx5B,
                       label: block_cx5B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx5B: // global
           if (R1 & 7 == 1) goto cx6l; else goto cx6m;
       cx6l: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cx6m: // global
           I64[Sp - 8] = block_cx5H_info;
           _suis::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _suis::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ux6H; else goto cx5I;
       ux6H: // global
           call _cx5H(R1) args: 0, res: 0, upd: 0;
       cx5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cx5H() //  [R1]
         { info_tbl: [(cx5H,
                       label: block_cx5H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx5H: // global
           _suis::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cx6x; else goto cx6C;
       cx6x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx6A; else goto cx6z;
       cx6A: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx6z: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suis::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cx6C: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cx6F; else goto cx6E;
       cx6F: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx6E: // global
           I64[Hp - 112] = ds3_suix_info;
           _suip::P64 = P64[Sp + 16];
           P64[Hp - 96] = _suip::P64;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = stg_sel_0_upd_info;
           _cx5N::P64 = Hp - 112;
           P64[Hp - 64] = _cx5N::P64;
           I64[Hp - 56] = sat_suiF_info;
           P64[Hp - 40] = _suip::P64;
           P64[Hp - 32] = _suis::P64;
           P64[Hp - 24] = _cx5N::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.608226991 UTC

[section ""data" . GHC.List.scanrFB_closure" {
     GHC.List.scanrFB_closure:
         const GHC.List.scanrFB_info;
 },
 GHC.List.scanrFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cx7r,
                       label: GHC.List.scanrFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx7r: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cx7x; else goto cx7y;
       cx7x: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanrFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cx7y: // global
           I64[Sp - 32] = block_cx7o_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ux7C; else goto cx7p;
       ux7C: // global
           call _cx7o(R1) args: 0, res: 0, upd: 0;
       cx7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cx7o() //  [R1]
         { info_tbl: [(cx7o,
                       label: block_cx7o_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx7o: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cx7B; else goto cx7A;
       cx7B: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx7A: // global
           _suiP::P64 = P64[R1 + 7];
           _suiQ::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _suiP::P64;
           P64[Hp - 64] = _suiQ::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _suiP::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.615711346 UTC

[section ""data" . GHC.List.$wscanr_closure" {
     GHC.List.$wscanr_closure:
         const GHC.List.$wscanr_info;
 },
 ds_suiZ_entry() //  [R1]
         { info_tbl: [(cx8a,
                       label: ds_suiZ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx8a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx8b; else goto cx8c;
       cx8b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx8c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cx86_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cx86() //  [R1, R2]
         { info_tbl: [(cx86,
                       label: block_cx86_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx86: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cx8f; else goto cx8e;
       cx8f: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cx8e: // global
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_suj8_entry() //  [R1]
         { info_tbl: [(cx8m,
                       label: sat_suj8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx8m: // global
           _suj8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cx8n; else goto cx8o;
       cx8o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx8q; else goto cx8p;
       cx8q: // global
           HpAlloc = 24;
           goto cx8n;
       cx8n: // global
           R1 = _suj8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx8p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suj8::P64;
           _suiT::P64 = P64[_suj8::P64 + 16];
           _suiX::P64 = P64[_suj8::P64 + 24];
           _suiZ::P64 = P64[_suj8::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _suiZ::P64;
           R3 = Hp - 16;
           R2 = _suiX::P64;
           R1 = _suiT::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanr_entry() //  [R2, R3, R4]
         { info_tbl: [(cx8v,
                       label: GHC.List.$wscanr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx8v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx8w; else goto cx8x;
       cx8w: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cx8x: // global
           I64[Sp - 24] = block_cx7W_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ux8D; else goto cx7X;
       ux8D: // global
           call _cx7W(R1) args: 0, res: 0, upd: 0;
       cx7X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cx7W() //  [R1]
         { info_tbl: [(cx7W,
                       label: block_cx7W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx7W: // global
           _suiU::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cx8s; else goto cx8t;
       cx8s: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _suiU::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cx8t: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cx8C; else goto cx8B;
       cx8C: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx8B: // global
           _suiX::P64 = P64[R1 + 6];
           _suiY::P64 = P64[R1 + 14];
           I64[Hp - 96] = ds_suiZ_info;
           _suiT::P64 = P64[Sp + 8];
           P64[Hp - 80] = _suiT::P64;
           P64[Hp - 72] = _suiU::P64;
           P64[Hp - 64] = _suiY::P64;
           I64[Hp - 56] = stg_sel_0_upd_info;
           _cx82::P64 = Hp - 96;
           P64[Hp - 40] = _cx82::P64;
           I64[Hp - 32] = sat_suj8_info;
           P64[Hp - 16] = _suiT::P64;
           P64[Hp - 8] = _suiX::P64;
           P64[Hp] = _cx82::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.628883018 UTC

[section ""data" . GHC.List.strictUncurryScanr_closure" {
     GHC.List.strictUncurryScanr_closure:
         const GHC.List.strictUncurryScanr_info;
 },
 GHC.List.strictUncurryScanr_entry() //  [R2, R3]
         { info_tbl: [(cx9b,
                       label: GHC.List.strictUncurryScanr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx9b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cx9c; else goto cx9d;
       cx9c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.strictUncurryScanr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx9d: // global
           I64[Sp - 16] = block_cx98_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ux9h; else goto cx99;
       ux9h: // global
           call _cx98(R1) args: 0, res: 0, upd: 0;
       cx99: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cx98() //  [R1]
         { info_tbl: [(cx98,
                       label: block_cx98_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx98: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.scanr_closure" {
     GHC.List.scanr_closure:
         const GHC.List.scanr_info;
 },
 GHC.List.scanr_entry() //  [R2, R3, R4]
         { info_tbl: [(cx9p,
                       label: GHC.List.scanr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx9p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cx9q; else goto cx9r;
       cx9q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cx9r: // global
           I64[Sp - 8] = block_cx9m_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cx9m() //  [R1, R2]
         { info_tbl: [(cx9m,
                       label: block_cx9m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx9m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx9u; else goto cx9t;
       cx9u: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cx9t: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.639720256 UTC

[section ""data" . GHC.List.flipSeqScanl'_closure" {
     GHC.List.flipSeqScanl'_closure:
         const GHC.List.flipSeqScanl'_info;
 },
 GHC.List.flipSeqScanl'_entry() //  [R2, R3]
         { info_tbl: [(cx9T,
                       label: GHC.List.flipSeqScanl'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx9T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cx9U; else goto cx9V;
       cx9U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqScanl'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx9V: // global
           I64[Sp - 16] = block_cx9R_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cx9R() //  []
         { info_tbl: [(cx9R,
                       label: block_cx9R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cx9R: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.645200613 UTC

[section ""data" . GHC.List.scanlFB'_closure" {
     GHC.List.scanlFB'_closure:
         const GHC.List.scanlFB'_info;
 },
 GHC.List.scanlFB'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cxac,
                       label: GHC.List.scanlFB'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxac: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxad; else goto cxae;
       cxad: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxae: // global
           I64[Sp - 24] = block_cxa9_info;
           _sujs::P64 = R3;
           R3 = R4;
           _sujr::P64 = R2;
           R2 = R6;
           R1 = _sujr::P64;
           P64[Sp - 16] = _sujs::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxa9() //  [R1]
         { info_tbl: [(cxa9,
                       label: block_cxa9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxa9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cxah; else goto cxag;
       cxah: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxag: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.652218836 UTC

[section ""data" . GHC.List.$wscanlGo'_closure" {
     GHC.List.$wscanlGo'_closure:
         const GHC.List.$wscanlGo'_info;
 },
 sat_sujJ_entry() //  [R1]
         { info_tbl: [(cxaI,
                       label: sat_sujJ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxaI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cxaJ; else goto cxaK;
       cxaJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxaK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cxaB_info;
           _sujy::P64 = P64[R1 + 16];
           _sujB::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sujy::P64;
           P64[Sp - 24] = _sujB::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uxb0; else goto cxaC;
       uxb0: // global
           call _cxaB(R1) args: 0, res: 0, upd: 0;
       cxaC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cxaB() //  [R1]
         { info_tbl: [(cxaB,
                       label: block_cxaB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxaB: // global
           if (R1 & 7 == 1) goto cxaF; else goto cxaG;
       cxaF: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cxaG: // global
           I64[Sp] = block_cxaQ_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           _sujE::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sujE::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cxaQ() //  [R1]
         { info_tbl: [(cxaQ,
                       label: block_cxaQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxaQ: // global
           _sujE::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cxaS_info;
           R4 = _sujE::P64;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanlGo'_entry(R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _cxaS() //  [R1, R2]
         { info_tbl: [(cxaS,
                       label: block_cxaS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxaS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxaZ; else goto cxaY;
       cxaZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cxaY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanlGo'_entry() //  [R2, R3, R4]
         { info_tbl: [(cxb1,
                       label: GHC.List.$wscanlGo'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxb1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxb2; else goto cxb3;
       cxb2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxb3: // global
           I64[Sp - 24] = block_cxav_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxav() //  [R1]
         { info_tbl: [(cxav,
                       label: block_cxav_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxav: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxb6; else goto cxb5;
       cxb6: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxb5: // global
           I64[Hp - 32] = sat_sujJ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = Hp - 32;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.666609515 UTC

[section ""data" . GHC.List.scanl'_scanlGo'_closure" {
     GHC.List.scanl'_scanlGo'_closure:
         const GHC.List.scanl'_scanlGo'_info;
 },
 GHC.List.scanl'_scanlGo'_entry() //  [R2, R3, R4]
         { info_tbl: [(cxbH,
                       label: GHC.List.scanl'_scanlGo'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxbH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxbI; else goto cxbJ;
       cxbI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl'_scanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxbJ: // global
           I64[Sp - 8] = block_cxbE_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo'_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cxbE() //  [R1, R2]
         { info_tbl: [(cxbE,
                       label: block_cxbE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxbE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxbM; else goto cxbL;
       cxbM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cxbL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.672363857 UTC

[section ""data" . GHC.List.scanl'_closure" {
     GHC.List.scanl'_closure:
         const GHC.List.scanl'_info;
 },
 GHC.List.scanl'_entry() //  [R2, R3, R4]
         { info_tbl: [(cxc0,
                       label: GHC.List.scanl'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxc0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl'_scanlGo'_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.67569536 UTC

[section ""data" . GHC.List.constScanl_closure" {
     GHC.List.constScanl_closure:
         const GHC.List.constScanl_info;
 },
 GHC.List.constScanl_entry() //  [R2, R3]
         { info_tbl: [(cxcb,
                       label: GHC.List.constScanl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxcb: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.679607587 UTC

[section ""data" . GHC.List.scanlFB_closure" {
     GHC.List.scanlFB_closure:
         const GHC.List.scanlFB_info;
 },
 GHC.List.scanlFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cxco,
                       label: GHC.List.scanlFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxco: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cxcs; else goto cxcr;
       cxcs: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxcr: // global
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R6;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R5;
           _cxcm::P64 = Hp - 64;
           P64[Hp] = _cxcm::P64;
           _sujR::P64 = R3;
           R3 = Hp - 24;
           R2 = _cxcm::P64;
           R1 = _sujR::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.684398633 UTC

[section ""data" . GHC.List.$wscanlGo_closure" {
     GHC.List.$wscanlGo_closure:
         const GHC.List.$wscanlGo_info;
 },
 sat_suk7_entry() //  [R1]
         { info_tbl: [(cxcM,
                       label: sat_suk7_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxcM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cxcN; else goto cxcO;
       cxcN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxcO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cxcF_info;
           _sujX::P64 = P64[R1 + 16];
           _sujY::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sujX::P64;
           P64[Sp - 24] = _sujY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uxd4; else goto cxcG;
       uxd4: // global
           call _cxcF(R1) args: 0, res: 0, upd: 0;
       cxcG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cxcF() //  [R1]
         { info_tbl: [(cxcF,
                       label: block_cxcF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxcF: // global
           if (R1 & 7 == 1) goto cxcJ; else goto cxcK;
       cxcJ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cxcK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxd0; else goto cxcZ;
       cxd0: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cxcZ: // global
           _suk1::P64 = P64[R1 + 6];
           _suk2::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           _sujX::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sujX::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _suk1::P64;
           I64[Sp + 16] = block_cxcV_info;
           R4 = _suk2::P64;
           R3 = Hp - 32;
           R2 = _sujX::P64;
           Sp = Sp + 16;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cxcV() //  [R1, R2]
         { info_tbl: [(cxcV,
                       label: block_cxcV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxcV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxd3; else goto cxd2;
       cxd3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cxd2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanlGo_entry() //  [R2, R3, R4]
         { info_tbl: [(cxd5,
                       label: GHC.List.$wscanlGo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxd5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxd9; else goto cxd8;
       cxd9: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxd8: // global
           I64[Hp - 32] = sat_suk7_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.695481073 UTC

[section ""data" . GHC.List.scanl_scanlGo_closure" {
     GHC.List.scanl_scanlGo_closure:
         const GHC.List.scanl_scanlGo_info;
 },
 GHC.List.scanl_scanlGo_entry() //  [R2, R3, R4]
         { info_tbl: [(cxdC,
                       label: GHC.List.scanl_scanlGo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxdC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxdD; else goto cxdE;
       cxdD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl_scanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxdE: // global
           I64[Sp - 8] = block_cxdz_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cxdz() //  [R1, R2]
         { info_tbl: [(cxdz,
                       label: block_cxdz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxdz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxdH; else goto cxdG;
       cxdH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cxdG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.701009486 UTC

[section ""data" . GHC.List.scanl_closure" {
     GHC.List.scanl_closure:
         const GHC.List.scanl_info;
 },
 GHC.List.scanl_entry() //  [R2, R3, R4]
         { info_tbl: [(cxdV,
                       label: GHC.List.scanl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxdV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl_scanlGo_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.705095649 UTC

[section ""data" . GHC.List.scanl1_closure" {
     GHC.List.scanl1_closure:
         const GHC.List.scanl1_info;
 },
 sat_sukm_entry() //  [R1]
         { info_tbl: [(cxei,
                       label: sat_sukm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxei: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxej; else goto cxek;
       cxej: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxek: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cxeg_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cxeg() //  [R2]
         { info_tbl: [(cxeg,
                       label: block_cxeg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxeg: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.scanl1_entry() //  [R2, R3]
         { info_tbl: [(cxeq,
                       label: GHC.List.scanl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxeq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxer; else goto cxes;
       cxer: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxes: // global
           I64[Sp - 16] = block_cxe6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxez; else goto cxe7;
       uxez: // global
           call _cxe6(R1) args: 0, res: 0, upd: 0;
       cxe7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxe6() //  [R1]
         { info_tbl: [(cxe6,
                       label: block_cxe6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxe6: // global
           if (R1 & 7 == 1) goto cxen; else goto cxeo;
       cxen: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxeo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cxey; else goto cxex;
       cxey: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxex: // global
           _sukh::P64 = P64[R1 + 6];
           _suki::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sukm_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sukh::P64;
           P64[Hp - 24] = _suki::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sukh::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.716138376 UTC

[section ""data" . GHC.List.foldl'_closure" {
     GHC.List.foldl'_closure:
         const GHC.List.foldl'_info;
 },
 GHC.List.foldl'_entry() //  [R2, R3, R4]
         { info_tbl: [(cxf4,
                       label: GHC.List.foldl'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxf4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxf5; else goto cxf6;
       cxf5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxf6: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cxf8() args: 0, res: 0, upd: 0;
     }
 },
 _cxf8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxf8: // global
           I64[Sp - 8] = block_cxfa_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxfx; else goto cxfc;
       uxfx: // global
           call _cxfa(R1) args: 0, res: 0, upd: 0;
       cxfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxfa() //  [R1]
         { info_tbl: [(cxfa,
                       label: block_cxfa_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxfa: // global
           _suks::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cxfi; else goto cxfp;
       cxfi: // global
           R1 = _suks::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxfp: // global
           I64[Sp] = block_cxfl_info;
           _suku::P64 = P64[R1 + 6];
           _sukv::P64 = P64[R1 + 14];
           R1 = _suks::P64;
           P64[Sp + 16] = _sukv::P64;
           P64[Sp + 24] = _suku::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxfl() //  [R1]
         { info_tbl: [(cxfl,
                       label: block_cxfl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxfl: // global
           I64[Sp] = block_cxfn_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           R1 = P64[Sp + 8];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxfn() //  [R1]
         { info_tbl: [(cxfn,
                       label: block_cxfn_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxfn: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cxf8() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.726480423 UTC

[section ""data" . GHC.List.foldl1'_closure" {
     GHC.List.foldl1'_closure:
         const GHC.List.foldl1'_info;
         const 0;
 },
 GHC.List.foldl1'_entry() //  [R2, R3]
         { info_tbl: [(cxg4,
                       label: GHC.List.foldl1'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxg4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxg5; else goto cxg6;
       cxg5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxg6: // global
           I64[Sp - 16] = block_cxfX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxgd; else goto cxfY;
       uxgd: // global
           call _cxfX(R1) args: 0, res: 0, upd: 0;
       cxfY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxfX() //  [R1]
         { info_tbl: [(cxfX,
                       label: block_cxfX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxfX: // global
           if (R1 & 7 == 1) goto cxg1; else goto cxg2;
       cxg1: // global
           R1 = GHC.List.foldl1'1_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxg2: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl'_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.732777755 UTC

[section ""data" . sat_sukD_closure" {
     sat_sukD_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.734929908 UTC

[section ""data" . sat_sukE_closure" {
     sat_sukE_closure:
         const :_con_info;
         const sat_sukD_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.736945001 UTC

[section ""data" . lvl29_ru9q_closure" {
     lvl29_ru9q_closure:
         const lvl29_ru9q_info;
         const 0;
         const 0;
         const 0;
 },
 lvl29_ru9q_entry() //  [R1]
         { info_tbl: [(cxgx,
                       label: lvl29_ru9q_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxgx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxgy; else goto cxgz;
       cxgy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxgz: // global
           (_cxgu::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxgu::I64 == 0) goto cxgw; else goto cxgv;
       cxgw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxgv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxgu::I64;
           R3 = sat_sukE_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.74182346 UTC

[section ""data" . lvl30_ru9r_closure" {
     lvl30_ru9r_closure:
         const lvl30_ru9r_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_ru9r_entry() //  [R1]
         { info_tbl: [(cxgN,
                       label: lvl30_ru9r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxgN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxgO; else goto cxgP;
       cxgO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxgP: // global
           (_cxgK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxgK::I64 == 0) goto cxgM; else goto cxgL;
       cxgM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxgL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxgK::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.747033386 UTC

[section ""data" . GHC.List.foldl_closure" {
     GHC.List.foldl_closure:
         const GHC.List.foldl_info;
 },
 GHC.List.foldl_entry() //  [R2, R3, R4]
         { info_tbl: [(cxhd,
                       label: GHC.List.foldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxhd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxhe; else goto cxhf;
       cxhe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxhf: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cxh4() args: 0, res: 0, upd: 0;
     }
 },
 _cxh4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxh4: // global
           I64[Sp - 8] = block_cxh6_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxhs; else goto cxh7;
       uxhs: // global
           call _cxh6(R1) args: 0, res: 0, upd: 0;
       cxh7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxh6() //  [R1]
         { info_tbl: [(cxh6,
                       label: block_cxh6_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxh6: // global
           _sukK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cxhk; else goto cxhl;
       cxhk: // global
           R1 = _sukK::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxhl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxho; else goto cxhn;
       cxho: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxhn: // global
           _sukM::P64 = P64[R1 + 6];
           _sukN::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sukK::P64;
           P64[Hp] = _sukM::P64;
           P64[Sp + 16] = _sukN::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call _cxh4() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.756068121 UTC

[section ""data" . GHC.List.sum_closure" {
     GHC.List.sum_closure:
         const GHC.List.sum_info;
         const 0;
 },
 sat_sukR_entry() //  [R1]
         { info_tbl: [(cxhS,
                       label: sat_sukR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxhS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxhT; else goto cxhU;
       cxhT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxhU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl30_ru9r_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sukQ_entry() //  [R1]
         { info_tbl: [(cxhZ,
                       label: sat_sukQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxhZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxi0; else goto cxi1;
       cxi0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxi1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.sum_entry() //  [R2]
         { info_tbl: [(cxi2,
                       label: GHC.List.sum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxi2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cxi6; else goto cxi5;
       cxi6: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.sum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxi5: // global
           I64[Hp - 40] = sat_sukR_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sukQ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.764244918 UTC

[section ""data" . GHC.List.product_closure" {
     GHC.List.product_closure:
         const GHC.List.product_info;
         const 0;
 },
 sat_sukU_entry() //  [R1]
         { info_tbl: [(cxir,
                       label: sat_sukU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxir: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxis; else goto cxit;
       cxis: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxit: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl29_ru9q_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sukT_entry() //  [R1]
         { info_tbl: [(cxiy,
                       label: sat_sukT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxiy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxiz; else goto cxiA;
       cxiz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxiA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.product_entry() //  [R2]
         { info_tbl: [(cxiB,
                       label: GHC.List.product_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxiB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cxiF; else goto cxiE;
       cxiF: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.product_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxiE: // global
           I64[Hp - 40] = sat_sukU_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sukT_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.775370348 UTC

[section ""data" . GHC.List.foldl1_closure" {
     GHC.List.foldl1_closure:
         const GHC.List.foldl1_info;
         const 0;
 },
 GHC.List.foldl1_entry() //  [R2, R3]
         { info_tbl: [(cxj3,
                       label: GHC.List.foldl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxj3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxj4; else goto cxj5;
       cxj4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxj5: // global
           I64[Sp - 16] = block_cxiW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxjc; else goto cxiX;
       uxjc: // global
           call _cxiW(R1) args: 0, res: 0, upd: 0;
       cxiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxiW() //  [R1]
         { info_tbl: [(cxiW,
                       label: block_cxiW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxiW: // global
           if (R1 & 7 == 1) goto cxj0; else goto cxj1;
       cxj0: // global
           R1 = GHC.List.foldl2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxj1: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.782857647 UTC

[section ""data" . GHC.List.filterFB_closure" {
     GHC.List.filterFB_closure:
         const GHC.List.filterFB_info;
 },
 GHC.List.filterFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cxjy,
                       label: GHC.List.filterFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxjy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxjz; else goto cxjA;
       cxjz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filterFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxjA: // global
           I64[Sp - 32] = block_cxjs_info;
           _sul0::P64 = R2;
           R2 = R4;
           R1 = R3;
           P64[Sp - 24] = _sul0::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxjs() //  [R1]
         { info_tbl: [(cxjs,
                       label: block_cxjs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxjs: // global
           _sul3::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cxjv; else goto cxjw;
       cxjv: // global
           R1 = _sul3::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxjw: // global
           R3 = _sul3::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.791264284 UTC

[section ""data" . GHC.List.filter_closure" {
     GHC.List.filter_closure:
         const GHC.List.filter_info;
 },
 sat_sulb_entry() //  [R1]
         { info_tbl: [(cxka,
                       label: sat_sulb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxka: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxkb; else goto cxkc;
       cxkb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxkc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.filter_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.filter_entry() //  [R2, R3]
         { info_tbl: [(cxkh,
                       label: GHC.List.filter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxkh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxki; else goto uxkx;
       cxki: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filter_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxkx: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxjS() args: 0, res: 0, upd: 0;
     }
 },
 _cxjS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxjS: // global
           I64[Sp - 8] = block_cxjV_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxkz; else goto cxjW;
       uxkz: // global
           call _cxjV(R1) args: 0, res: 0, upd: 0;
       cxjW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxjV() //  [R1]
         { info_tbl: [(cxjV,
                       label: block_cxjV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxjV: // global
           if (R1 & 7 == 1) goto cxke; else goto cxkf;
       cxke: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxkf: // global
           I64[Sp - 8] = block_cxk1_info;
           _sul8::P64 = P64[R1 + 6];
           R2 = _sul8::P64;
           _sul9::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sul9::P64;
           P64[Sp + 16] = _sul8::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxk1() //  [R1]
         { info_tbl: [(cxk1,
                       label: block_cxk1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxk1: // global
           _sul5::P64 = P64[Sp + 16];
           _sul9::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cxkq; else goto cxks;
       cxkq: // global
           P64[Sp + 16] = _sul5::P64;
           P64[Sp + 24] = _sul9::P64;
           Sp = Sp + 16;
           call _cxjS() args: 0, res: 0, upd: 0;
       cxks: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cxkv; else goto cxku;
       cxkv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxku: // global
           I64[Hp - 48] = sat_sulb_info;
           P64[Hp - 32] = _sul5::P64;
           P64[Hp - 24] = _sul9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.8026141 UTC

[section ""data" . GHC.List.idLength_closure" {
     GHC.List.idLength_closure:
         const GHC.List.idLength_info;
 },
 GHC.List.idLength_entry() //  [R2]
         { info_tbl: [(cxl6,
                       label: GHC.List.idLength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxl6: // global
           R2 = R2;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.806189144 UTC

[section ""data" . GHC.List.lengthFB_closure" {
     GHC.List.lengthFB_closure:
         const GHC.List.lengthFB_info;
 },
 GHC.List.lengthFB_entry() //  [R2, R3, R4]
         { info_tbl: [(cxlk,
                       label: GHC.List.lengthFB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxlk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxlr; else goto cxls;
       cxlr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lengthFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxls: // global
           I64[Sp - 16] = block_cxlh_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxlw; else goto cxli;
       uxlw: // global
           call _cxlh(R1) args: 0, res: 0, upd: 0;
       cxli: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxlh() //  [R1]
         { info_tbl: [(cxlh,
                       label: block_cxlh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxlh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxlv; else goto cxlu;
       cxlv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxlu: // global
           _sulh::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sulh::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.812605461 UTC

[section ""data" . GHC.List.$wlenAcc_closure" {
     GHC.List.$wlenAcc_closure:
         const GHC.List.$wlenAcc_info;
 },
 GHC.List.$wlenAcc_entry() //  [R2, R3]
         { info_tbl: [(cxlS,
                       label: GHC.List.$wlenAcc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxlS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxlT; else goto uxm2;
       cxlT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wlenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxm2: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxlI() args: 0, res: 0, upd: 0;
     }
 },
 _cxlI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxlI: // global
           _sulj::P64 = P64[Sp];
           I64[Sp] = block_cxlL_info;
           R1 = _sulj::P64;
           if (R1 & 7 != 0) goto uxm4; else goto cxlM;
       uxm4: // global
           call _cxlL(R1) args: 0, res: 0, upd: 0;
       cxlM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxlL() //  [R1]
         { info_tbl: [(cxlL,
                       label: block_cxlL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxlL: // global
           _sulk::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cxlP; else goto cxlQ;
       cxlP: // global
           R1 = _sulk::I64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxlQ: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _sulk::I64 + 1;
           call _cxlI() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.81949346 UTC

[section ""data" . GHC.List.lenAcc_closure" {
     GHC.List.lenAcc_closure:
         const GHC.List.lenAcc_info;
 },
 GHC.List.lenAcc_entry() //  [R2, R3]
         { info_tbl: [(cxmu,
                       label: GHC.List.lenAcc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxmu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxmC; else goto cxmD;
       cxmC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxmD: // global
           I64[Sp - 16] = block_cxmr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxmI; else goto cxms;
       uxmI: // global
           call _cxmr(R1) args: 0, res: 0, upd: 0;
       cxms: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxmr() //  [R1]
         { info_tbl: [(cxmr,
                       label: block_cxmr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxmr: // global
           _sulp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cxmx_info;
           R3 = I64[R1 + 7];
           R2 = _sulp::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cxmx() //  [R1]
         { info_tbl: [(cxmx,
                       label: block_cxmx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxmx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxmH; else goto cxmG;
       cxmH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cxmG: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.827374517 UTC

[section ""data" . GHC.List.length_closure" {
     GHC.List.length_closure:
         const GHC.List.length_info;
 },
 GHC.List.length_entry() //  [R2]
         { info_tbl: [(cxn2,
                       label: GHC.List.length_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxn2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxn6; else goto cxn7;
       cxn6: // global
           R2 = R2;
           R1 = GHC.List.length_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxn7: // global
           I64[Sp - 8] = block_cxn0_info;
           R3 = 0;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cxn0() //  [R1]
         { info_tbl: [(cxn0,
                       label: block_cxn0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxn0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxna; else goto cxn9;
       cxna: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cxn9: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.83298991 UTC

[section ""data" . GHC.List.null_closure" {
     GHC.List.null_closure:
         const GHC.List.null_info;
 },
 GHC.List.null_entry() //  [R2]
         { info_tbl: [(cxnv,
                       label: GHC.List.null_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxnv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxnw; else goto cxnx;
       cxnw: // global
           R2 = R2;
           R1 = GHC.List.null_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxnx: // global
           I64[Sp - 8] = block_cxno_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxnE; else goto cxnp;
       uxnE: // global
           call _cxno(R1) args: 0, res: 0, upd: 0;
       cxnp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxno() //  [R1]
         { info_tbl: [(cxno,
                       label: block_cxno_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxno: // global
           if (R1 & 7 == 1) goto cxns; else goto cxnt;
       cxns: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxnt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.838780318 UTC

[section ""data" . GHC.List.uncons_closure" {
     GHC.List.uncons_closure:
         const GHC.List.uncons_info;
 },
 GHC.List.uncons_entry() //  [R2]
         { info_tbl: [(cxo3,
                       label: GHC.List.uncons_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxo3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxo4; else goto cxo5;
       cxo4: // global
           R2 = R2;
           R1 = GHC.List.uncons_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxo5: // global
           I64[Sp - 8] = block_cxnW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxog; else goto cxnX;
       uxog: // global
           call _cxnW(R1) args: 0, res: 0, upd: 0;
       cxnX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxnW() //  [R1]
         { info_tbl: [(cxnW,
                       label: block_cxnW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxnW: // global
           if (R1 & 7 == 1) goto cxo0; else goto cxo1;
       cxo0: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxo1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxof; else goto cxoe;
       cxof: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxoe: // global
           _sulC::P64 = P64[R1 + 6];
           _sulD::P64 = P64[R1 + 14];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = _sulC::P64;
           P64[Hp - 16] = _sulD::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:07.845931935 UTC

[section ""relreadonly" . Supf_srt" {
     Supf_srt:
         const lvl1_ru8R_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.List.errorEmptyList_closure;
         const GHC.List.prel_list_str_closure;
         const lvl3_ru8T_closure;
         const GHC.List.!!2_closure;
         const GHC.List.!!1_closure;
         const poly_exit_ru8U_closure;
         const poly_$wgo_ru8V_closure;
         const GHC.List.negIndex_closure;
         const GHC.List.!!_closure;
         const GHC.List.$w!!_closure;
         const lvl5_ru8X_closure;
         const GHC.List.cycle_closure;
         const GHC.List.cycle1_closure;
         const lvl7_ru8Z_closure;
         const lvl8_ru90_closure;
         const GHC.List.foldr1_closure;
         const lvl10_ru92_closure;
         const GHC.List.init_closure;
         const GHC.List.init2_closure;
         const lvl12_ru94_closure;
         const GHC.List.lastError_closure;
         const lvl14_ru97_closure;
         const GHC.List.tail_closure;
         const GHC.List.scanl2_closure;
         const lvl16_ru99_closure;
         const GHC.List.head_closure;
         const GHC.List.badHead_closure;
         const lvl18_ru9b_closure;
         const GHC.List.maximum_$smaximum_closure;
         const GHC.List.maximum1_closure;
         const lvl21_ru9e_closure;
         const GHC.List.minimum_$sminimum_closure;
         const GHC.List.minimum1_closure;
         const GHC.List.maximum_$smaximum1_closure;
         const GHC.List.maximum2_closure;
         const GHC.List.maximum_closure;
         const lvl19_ru9c_closure;
         const GHC.List.minimum_$sminimum1_closure;
         const GHC.List.minimum2_closure;
         const GHC.List.minimum_closure;
         const lvl22_ru9f_closure;
         const lvl24_ru9h_closure;
         const GHC.List.errorEmptyList_closure;
         const lvl26_ru9j_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.List.scanr1_closure;
         const lvl28_ru9p_closure;
         const GHC.List.foldl1'_closure;
         const GHC.List.foldl1'1_closure;
         const sat_sukE_closure;
         const lvl30_ru9r_closure;
         const GHC.List.sum_closure;
         const lvl29_ru9q_closure;
         const GHC.List.product_closure;
         const GHC.List.foldl1_closure;
         const GHC.List.foldl2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.852282307 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:10.854026102 UTC

[section ""data" . $wunsafeDrop_ru8P_closure" {
     $wunsafeDrop_ru8P_closure:
         const $wunsafeDrop_ru8P_info;
 },
 $wunsafeDrop_ru8P_entry() //  [R2, R3]
         { info_tbl: [(cxAT,
                       label: $wunsafeDrop_ru8P_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxAT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxAU; else goto uxB8;
       cxAU: // global
           R3 = R3;
           R2 = R2;
           R1 = $wunsafeDrop_ru8P_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxB8: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxAJ() args: 0, res: 0, upd: 0;
     }
 },
 _cxAJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxAJ: // global
           I64[Sp - 8] = block_cxAM_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxBa; else goto cxAN;
       uxBa: // global
           call _cxAM(R1) args: 0, res: 0, upd: 0;
       cxAN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxAM() //  [R1]
         { info_tbl: [(cxAM,
                       label: block_cxAM_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxAM: // global
           if (R1 & 7 == 1) goto cxAQ; else goto cxAR;
       cxAQ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxAR: // global
           _sxoA::P64 = P64[R1 + 14];
           _sxoB::I64 = I64[Sp + 8];
           if (_sxoB::I64 != 1) goto cxB4; else goto cxB5;
       cxB4: // global
           I64[Sp + 8] = _sxoB::I64 - 1;
           P64[Sp + 16] = _sxoA::P64;
           Sp = Sp + 8;
           call _cxAJ() args: 0, res: 0, upd: 0;
       cxB5: // global
           R1 = _sxoA::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.861176665 UTC

[section ""data" . GHC.List.drop_closure" {
     GHC.List.drop_closure:
         const GHC.List.drop_info;
 },
 GHC.List.drop_entry() //  [R2, R3]
         { info_tbl: [(cxBD,
                       label: GHC.List.drop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxBD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxBE; else goto cxBF;
       cxBE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.drop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxBF: // global
           I64[Sp - 16] = block_cxBA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxBO; else goto cxBB;
       uxBO: // global
           call _cxBA(R1) args: 0, res: 0, upd: 0;
       cxBB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxBA() //  [R1]
         { info_tbl: [(cxBA,
                       label: block_cxBA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxBA: // global
           _sxoE::P64 = P64[Sp + 8];
           _sxoG::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_sxoG::I64, 0)) goto cxBM; else goto cxBN;
       cxBM: // global
           R3 = _sxoE::P64;
           R2 = _sxoG::I64;
           Sp = Sp + 16;
           call $wunsafeDrop_ru8P_entry(R3, R2) args: 8, res: 0, upd: 8;
       cxBN: // global
           R1 = _sxoE::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.867736919 UTC

[section ""data" . GHC.List.$wsplitAt'_closure" {
     GHC.List.$wsplitAt'_closure:
         const GHC.List.$wsplitAt'_info;
 },
 ds2_sxoQ_entry() //  [R1]
         { info_tbl: [(cxCo,
                       label: ds2_sxoQ_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxCo: // global
           _sxoQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cxCu; else goto cxCv;
       cxCv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxCx; else goto cxCw;
       cxCx: // global
           HpAlloc = 16;
           goto cxCu;
       cxCu: // global
           R1 = _sxoQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxCw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxoQ::P64;
           _sxoM::P64 = P64[_sxoQ::P64 + 16];
           _sxoR::I64 = I64[_sxoQ::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sxoR::I64;
           I64[Sp - 24] = block_cxCr_info;
           R3 = _sxoM::P64;
           R2 = Hp - 7;
           Sp = Sp - 24;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cxCr() //  [R1, R2]
         { info_tbl: [(cxCr,
                       label: block_cxCr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxCr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxCA; else goto cxCz;
       cxCA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cxCz: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wsplitAt'_entry() //  [R2, R3]
         { info_tbl: [(cxCF,
                       label: GHC.List.$wsplitAt'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxCF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxCG; else goto cxCH;
       cxCG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wsplitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxCH: // global
           I64[Sp - 16] = block_cxC5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxCX; else goto cxC6;
       uxCX: // global
           call _cxC5(R1) args: 0, res: 0, upd: 0;
       cxC6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxC5() //  [R1]
         { info_tbl: [(cxC5,
                       label: block_cxC5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxC5: // global
           if (R1 & 7 == 1) goto cxCC; else goto cxCD;
       cxCC: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cxCD: // global
           I64[Sp - 8] = block_cxCb_info;
           _sxoL::P64 = P64[R1 + 6];
           _sxoM::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sxoM::P64;
           P64[Sp + 8] = _sxoL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxCW; else goto cxCc;
       uxCW: // global
           call _cxCb(R1) args: 0, res: 0, upd: 0;
       cxCc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxCb() //  [R1]
         { info_tbl: [(cxCb,
                       label: block_cxCb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxCb: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cxCN; else goto cxCM;
       cxCN: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxCM: // global
           _sxoL::P64 = P64[Sp + 16];
           _sxoM::P64 = P64[Sp + 8];
           _sxoP::I64 = I64[R1 + 7];
           if (_sxoP::I64 != 1) goto cxCS; else goto cxCV;
       cxCS: // global
           I64[Hp - 96] = ds2_sxoQ_info;
           P64[Hp - 80] = _sxoM::P64;
           I64[Hp - 72] = _sxoP::I64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cxCi::P64 = Hp - 96;
           P64[Hp - 48] = _cxCi::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cxCi::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxoL::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cxCV: // global
           I64[Hp - 96] = :_con_info;
           P64[Hp - 88] = _sxoL::P64;
           P64[Hp - 80] = GHC.Types.[]_closure+1;
           _cxCU::P64 = Hp - 94;
           Hp = Hp - 80;
           R2 = _sxoM::P64;
           R1 = _cxCU::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.88161452 UTC

[section ""data" . GHC.List.splitAt_splitAt'_closure" {
     GHC.List.splitAt_splitAt'_closure:
         const GHC.List.splitAt_splitAt'_info;
 },
 GHC.List.splitAt_splitAt'_entry() //  [R2, R3]
         { info_tbl: [(cxDM,
                       label: GHC.List.splitAt_splitAt'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxDM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxDN; else goto cxDO;
       cxDN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_splitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxDO: // global
           I64[Sp - 8] = block_cxDJ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cxDJ() //  [R1, R2]
         { info_tbl: [(cxDJ,
                       label: block_cxDJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxDJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxDR; else goto cxDQ;
       cxDR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cxDQ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.887753567 UTC

[section ""data" . GHC.List.splitAt_closure" {
     GHC.List.splitAt_closure:
         const GHC.List.splitAt_info;
 },
 GHC.List.splitAt_entry() //  [R2, R3]
         { info_tbl: [(cxEa,
                       label: GHC.List.splitAt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxEa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxEb; else goto cxEc;
       cxEb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxEc: // global
           I64[Sp - 16] = block_cxE7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxEw; else goto cxE8;
       uxEw: // global
           call _cxE7(R1) args: 0, res: 0, upd: 0;
       cxE8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxE7() //  [R1]
         { info_tbl: [(cxE7,
                       label: block_cxE7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxE7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxEh; else goto cxEg;
       cxEh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxEg: // global
           _sxpc::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto cxEp; else goto cxEv;
       cxEp: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_cxEl_info;
           R3 = _sxpc::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
       cxEv: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = _sxpc::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cxEl() //  [R1, R2]
         { info_tbl: [(cxEl,
                       label: block_cxEl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxEl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxEs; else goto cxEr;
       cxEs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cxEr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.896003888 UTC

[section ""cstring" . GHC.List.$trModule4_bytes" {
     GHC.List.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.897723299 UTC

[section ""data" . GHC.List.$trModule3_closure" {
     GHC.List.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.899352066 UTC

[section ""cstring" . GHC.List.$trModule2_bytes" {
     GHC.List.$trModule2_bytes:
         I8[] [71,72,67,46,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.900942848 UTC

[section ""data" . GHC.List.$trModule1_closure" {
     GHC.List.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.902571112 UTC

[section ""data" . GHC.List.$trModule_closure" {
     GHC.List.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.List.$trModule3_closure+1;
         const GHC.List.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.90492217 UTC

[section ""data" . GHC.List.init1_closure" {
     GHC.List.init1_closure:
         const GHC.List.init1_info;
 },
 sat_sxpo_entry() //  [R1]
         { info_tbl: [(cxFa,
                       label: sat_sxpo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxFa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxFb; else goto cxFc;
       cxFb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxFc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.init1_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.init1_entry() //  [R2, R3]
         { info_tbl: [(cxFh,
                       label: GHC.List.init1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxFh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxFi; else goto cxFj;
       cxFi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.init1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxFj: // global
           I64[Sp - 16] = block_cxF0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxFq; else goto cxF1;
       uxFq: // global
           call _cxF0(R1) args: 0, res: 0, upd: 0;
       cxF1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxF0() //  [R1]
         { info_tbl: [(cxF0,
                       label: block_cxF0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxF0: // global
           if (R1 & 7 == 1) goto cxFe; else goto cxFf;
       cxFe: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxFf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cxFp; else goto cxFo;
       cxFp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxFo: // global
           _sxpm::P64 = P64[R1 + 6];
           _sxpn::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sxpo_info;
           P64[Hp - 32] = _sxpm::P64;
           P64[Hp - 24] = _sxpn::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.913568653 UTC

[section ""cstring" . lvl_ru8Q_bytes" {
     lvl_ru8Q_bytes:
         I8[] [58,32,101,109,112,116,121,32,108,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.915405039 UTC

[section ""data" . lvl1_ru8R_closure" {
     lvl1_ru8R_closure:
         const lvl1_ru8R_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ru8R_entry() //  [R1]
         { info_tbl: [(cxFW,
                       label: lvl1_ru8R_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxFW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxFX; else goto cxFY;
       cxFX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxFY: // global
           (_cxFT::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxFT::I64 == 0) goto cxFV; else goto cxFU;
       cxFV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxFU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxFT::I64;
           R2 = lvl_ru8Q_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.919343621 UTC

[section ""cstring" . GHC.List.!!4_bytes" {
     GHC.List.!!4_bytes:
         I8[] [80,114,101,108,117,100,101,46]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.921182566 UTC

[section ""data" . GHC.List.prel_list_str_closure" {
     GHC.List.prel_list_str_closure:
         const GHC.List.prel_list_str_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.prel_list_str_entry() //  [R1]
         { info_tbl: [(cxGe,
                       label: GHC.List.prel_list_str_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxGe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxGf; else goto cxGg;
       cxGf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxGg: // global
           (_cxGb::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxGb::I64 == 0) goto cxGd; else goto cxGc;
       cxGd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxGc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxGb::I64;
           R2 = GHC.List.!!4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.925488411 UTC

[section ""data" . GHC.List.errorEmptyList_closure" {
     GHC.List.errorEmptyList_closure:
         const GHC.List.errorEmptyList_info;
         const 0;
 },
 sat_sxpq_entry() //  [R1]
         { info_tbl: [(cxGx,
                       label: sat_sxpq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxGx: // global
           R3 = lvl1_ru8R_closure;
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.errorEmptyList_entry() //  [R2]
         { info_tbl: [(cxGC,
                       label: GHC.List.errorEmptyList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxGC: // global
           _sxpp::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cxGD; else goto cxGE;
       cxGE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxGG; else goto cxGF;
       cxGG: // global
           HpAlloc = 24;
           goto cxGD;
       cxGD: // global
           R2 = _sxpp::P64;
           R1 = GHC.List.errorEmptyList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxGF: // global
           I64[Hp - 16] = sat_sxpq_info;
           P64[Hp] = _sxpp::P64;
           I64[Sp - 8] = block_cxGA_info;
           R3 = Hp - 16;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cxGA() //  [R1]
         { info_tbl: [(cxGA,
                       label: block_cxGA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxGA: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.932689855 UTC

[section ""cstring" . lvl2_ru8S_bytes" {
     lvl2_ru8S_bytes:
         I8[] [33,33,58,32,110,101,103,97,116,105,118,101,32,105,110,100,101,120]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.934611986 UTC

[section ""data" . lvl3_ru8T_closure" {
     lvl3_ru8T_closure:
         const lvl3_ru8T_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_ru8T_entry() //  [R1]
         { info_tbl: [(cxH5,
                       label: lvl3_ru8T_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxH5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxH6; else goto cxH7;
       cxH6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxH7: // global
           (_cxH2::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxH2::I64 == 0) goto cxH4; else goto cxH3;
       cxH4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxH3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxH2::I64;
           R2 = lvl2_ru8S_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.938580714 UTC

[section ""data" . GHC.List.negIndex_closure" {
     GHC.List.negIndex_closure:
         const GHC.List.negIndex_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.negIndex_entry() //  [R1]
         { info_tbl: [(cxHo,
                       label: GHC.List.negIndex_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxHo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxHp; else goto cxHq;
       cxHp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxHq: // global
           (_cxHj::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxHj::I64 == 0) goto cxHl; else goto cxHk;
       cxHl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxHk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxHj::I64;
           I64[Sp - 24] = block_cxHm_info;
           R3 = lvl3_ru8T_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cxHm() //  [R1]
         { info_tbl: [(cxHm,
                       label: block_cxHm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxHm: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.944782768 UTC

[section ""cstring" . GHC.List.!!3_bytes" {
     GHC.List.!!3_bytes:
         I8[] [33,33,58,32,105,110,100,101,120,32,116,111,111,32,108,97,114,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.946781605 UTC

[section ""data" . GHC.List.!!2_closure" {
     GHC.List.!!2_closure:
         const GHC.List.!!2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!2_entry() //  [R1]
         { info_tbl: [(cxHN,
                       label: GHC.List.!!2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxHN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxHO; else goto cxHP;
       cxHO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxHP: // global
           (_cxHK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxHK::I64 == 0) goto cxHM; else goto cxHL;
       cxHM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxHL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxHK::I64;
           R2 = GHC.List.!!3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.95069999 UTC

[section ""data" . GHC.List.!!1_closure" {
     GHC.List.!!1_closure:
         const GHC.List.!!1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!1_entry() //  [R1]
         { info_tbl: [(cxI4,
                       label: GHC.List.!!1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxI5; else goto cxI6;
       cxI5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxI6: // global
           (_cxI1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxI1::I64 == 0) goto cxI3; else goto cxI2;
       cxI3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxI2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxI1::I64;
           R3 = GHC.List.!!2_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.954893893 UTC

[section ""data" . GHC.List.tooLarge_closure" {
     GHC.List.tooLarge_closure:
         const GHC.List.tooLarge_info;
         const 0;
 },
 GHC.List.tooLarge_entry() //  []
         { info_tbl: [(cxIj,
                       label: GHC.List.tooLarge_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxIj: // global
           R2 = GHC.List.!!1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.958204243 UTC

[section ""data" . poly_exit_ru8U_closure" {
     poly_exit_ru8U_closure:
         const poly_exit_ru8U_info;
         const 0;
         const 0;
         const 0;
 },
 poly_exit_ru8U_entry() //  [R1]
         { info_tbl: [(cxIw,
                       label: poly_exit_ru8U_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxIw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxIx; else goto cxIy;
       cxIx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxIy: // global
           (_cxIt::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxIt::I64 == 0) goto cxIv; else goto cxIu;
       cxIv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxIu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxIt::I64;
           R2 = GHC.List.!!1_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.962507406 UTC

[section ""data" . poly_$wgo_ru8V_closure" {
     poly_$wgo_ru8V_closure:
         const poly_$wgo_ru8V_info;
         const 0;
 },
 poly_$wgo_ru8V_entry() //  [R2, R3]
         { info_tbl: [(cxIS,
                       label: poly_$wgo_ru8V_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxIS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxIT; else goto uxJ7;
       cxIT: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_$wgo_ru8V_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxJ7: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxII() args: 0, res: 0, upd: 0;
     }
 },
 _cxII() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxII: // global
           _sxpu::P64 = P64[Sp];
           I64[Sp] = block_cxIL_info;
           R1 = _sxpu::P64;
           if (R1 & 7 != 0) goto uxJ9; else goto cxIM;
       uxJ9: // global
           call _cxIL(R1) args: 0, res: 0, upd: 0;
       cxIM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxIL() //  [R1]
         { info_tbl: [(cxIL,
                       label: block_cxIL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxIL: // global
           if (R1 & 7 == 1) goto cxIP; else goto cxIQ;
       cxIP: // global
           R1 = poly_exit_ru8U_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxIQ: // global
           _sxpz::I64 = I64[Sp + 8];
           if (_sxpz::I64 != 0) goto cxJ3; else goto cxJ4;
       cxJ3: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _sxpz::I64 - 1;
           call _cxII() args: 0, res: 0, upd: 0;
       cxJ4: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.969493775 UTC

[section ""data" . GHC.List.$w!!_closure" {
     GHC.List.$w!!_closure:
         const GHC.List.$w!!_info;
         const 0;
 },
 GHC.List.$w!!_entry() //  [R2, R3]
         { info_tbl: [(cxJB,
                       label: GHC.List.$w!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxJB: // global
           if (%MO_S_Ge_W64(R3, 0)) goto cxJz; else goto cxJA;
       cxJz: // global
           R3 = R3;
           R2 = R2;
           call poly_$wgo_ru8V_entry(R3, R2) args: 8, res: 0, upd: 8;
       cxJA: // global
           R1 = GHC.List.negIndex_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.973811343 UTC

[section ""data" . GHC.List.!!_closure" {
     GHC.List.!!_closure:
         const GHC.List.!!_info;
         const 0;
 },
 GHC.List.!!_entry() //  [R2, R3]
         { info_tbl: [(cxJP,
                       label: GHC.List.!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxJP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxJQ; else goto cxJR;
       cxJQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.!!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxJR: // global
           I64[Sp - 16] = block_cxJM_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxJV; else goto cxJN;
       uxJV: // global
           call _cxJM(R1) args: 0, res: 0, upd: 0;
       cxJN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxJM() //  [R1]
         { info_tbl: [(cxJM,
                       label: block_cxJM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxJM: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$w!!_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.979298862 UTC

[section ""cstring" . lvl4_ru8W_bytes" {
     lvl4_ru8W_bytes:
         I8[] [99,121,99,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.98115161 UTC

[section ""data" . lvl5_ru8X_closure" {
     lvl5_ru8X_closure:
         const lvl5_ru8X_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_ru8X_entry() //  [R1]
         { info_tbl: [(cxKd,
                       label: lvl5_ru8X_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxKd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxKe; else goto cxKf;
       cxKe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxKf: // global
           (_cxKa::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxKa::I64 == 0) goto cxKc; else goto cxKb;
       cxKc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxKb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxKa::I64;
           R2 = lvl4_ru8W_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.985061605 UTC

[section ""data" . GHC.List.cycle1_closure" {
     GHC.List.cycle1_closure:
         const GHC.List.cycle1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.cycle1_entry() //  [R1]
         { info_tbl: [(cxKu,
                       label: GHC.List.cycle1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxKu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxKv; else goto cxKw;
       cxKv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxKw: // global
           (_cxKr::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxKr::I64 == 0) goto cxKt; else goto cxKs;
       cxKt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxKs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxKr::I64;
           R2 = lvl5_ru8X_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.989655929 UTC

[section ""data" . GHC.List.cycle_closure" {
     GHC.List.cycle_closure:
         const GHC.List.cycle_info;
         const 0;
 },
 xs'_sxpM_entry() //  [R1]
         { info_tbl: [(cxKT,
                       label: xs'_sxpM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxKT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxKU; else goto cxKV;
       cxKU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxKV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.cycle_entry() //  [R2]
         { info_tbl: [(cxL0,
                       label: GHC.List.cycle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxL0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxL1; else goto cxL2;
       cxL1: // global
           R2 = R2;
           R1 = GHC.List.cycle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxL2: // global
           I64[Sp - 8] = block_cxKJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxL8; else goto cxKK;
       uxL8: // global
           call _cxKJ(R1) args: 0, res: 0, upd: 0;
       cxKK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxKJ() //  [R1]
         { info_tbl: [(cxKJ,
                       label: block_cxKJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxKJ: // global
           if (R1 & 7 == 1) goto cxKX; else goto cxKY;
       cxKX: // global
           R1 = GHC.List.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxKY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxL7; else goto cxL6;
       cxL7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxL6: // global
           I64[Hp - 16] = xs'_sxpM_info;
           P64[Hp] = R1;
           R1 = (Hp + -16) & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.997044969 UTC

[section ""cstring" . lvl6_ru8Y_bytes" {
     lvl6_ru8Y_bytes:
         I8[] [102,111,108,100,114,49]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:10.999256759 UTC

[section ""data" . lvl7_ru8Z_closure" {
     lvl7_ru8Z_closure:
         const lvl7_ru8Z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_ru8Z_entry() //  [R1]
         { info_tbl: [(cxLB,
                       label: lvl7_ru8Z_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxLB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxLC; else goto cxLD;
       cxLC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxLD: // global
           (_cxLy::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxLy::I64 == 0) goto cxLA; else goto cxLz;
       cxLA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxLz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxLy::I64;
           R2 = lvl6_ru8Y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.003623246 UTC

[section ""data" . lvl8_ru90_closure" {
     lvl8_ru90_closure:
         const lvl8_ru90_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_ru90_entry() //  [R1]
         { info_tbl: [(cxLS,
                       label: lvl8_ru90_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxLS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxLT; else goto cxLU;
       cxLT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxLU: // global
           (_cxLP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxLP::I64 == 0) goto cxLR; else goto cxLQ;
       cxLR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxLQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxLP::I64;
           R2 = lvl7_ru8Z_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.008053902 UTC

[section ""data" . GHC.List.foldr1_closure" {
     GHC.List.foldr1_closure:
         const GHC.List.foldr1_info;
         const 0;
 },
 go2_sxpP_entry() //  [R1, R2]
         { info_tbl: [(cxMj,
                       label: go2_sxpP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxMj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxMk; else goto cxMl;
       cxMk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxMl: // global
           I64[Sp - 24] = block_cxMc_info;
           _sxpP::P64 = R1;
           _sxpN::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sxpN::P64;
           P64[Sp - 8] = _sxpP::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uxMJ; else goto cxMd;
       uxMJ: // global
           call _cxMc(R1) args: 0, res: 0, upd: 0;
       cxMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxMc() //  [R1]
         { info_tbl: [(cxMc,
                       label: block_cxMc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxMc: // global
           if (R1 & 7 == 1) goto cxMg; else goto cxMh;
       cxMg: // global
           R1 = lvl8_ru90_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxMh: // global
           I64[Sp - 8] = block_cxMr_info;
           _sxpS::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sxpS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxMI; else goto cxMt;
       uxMI: // global
           call _cxMr(R1) args: 0, res: 0, upd: 0;
       cxMt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxMr() //  [R1]
         { info_tbl: [(cxMr,
                       label: block_cxMr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxMr: // global
           _sxpS::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cxMz; else goto cxMD;
       cxMz: // global
           R1 = _sxpS::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxMD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cxMG; else goto cxMF;
       cxMG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxMF: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = _sxpS::P64;
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.foldr1_entry() //  [R2, R3]
         { info_tbl: [(cxMK,
                       label: GHC.List.foldr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxMK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxMO; else goto cxMN;
       cxMO: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxMN: // global
           I64[Hp - 8] = go2_sxpP_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_sxpP_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.017945667 UTC

[section ""cstring" . lvl9_ru91_bytes" {
     lvl9_ru91_bytes:
         I8[] [105,110,105,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.019810573 UTC

[section ""data" . lvl10_ru92_closure" {
     lvl10_ru92_closure:
         const lvl10_ru92_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ru92_entry() //  [R1]
         { info_tbl: [(cxNl,
                       label: lvl10_ru92_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxNm; else goto cxNn;
       cxNm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxNn: // global
           (_cxNi::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxNi::I64 == 0) goto cxNk; else goto cxNj;
       cxNk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxNj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxNi::I64;
           R2 = lvl9_ru91_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.024315949 UTC

[section ""data" . GHC.List.init2_closure" {
     GHC.List.init2_closure:
         const GHC.List.init2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.init2_entry() //  [R1]
         { info_tbl: [(cxNC,
                       label: GHC.List.init2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxNC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxND; else goto cxNE;
       cxND: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxNE: // global
           (_cxNz::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxNz::I64 == 0) goto cxNB; else goto cxNA;
       cxNB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxNA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxNz::I64;
           R2 = lvl10_ru92_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.028627796 UTC

[section ""data" . GHC.List.init_closure" {
     GHC.List.init_closure:
         const GHC.List.init_info;
         const 0;
 },
 GHC.List.init_entry() //  [R2]
         { info_tbl: [(cxNY,
                       label: GHC.List.init_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxNY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxNZ; else goto cxO0;
       cxNZ: // global
           R2 = R2;
           R1 = GHC.List.init_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxO0: // global
           I64[Sp - 8] = block_cxNR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxO7; else goto cxNS;
       uxO7: // global
           call _cxNR(R1) args: 0, res: 0, upd: 0;
       cxNS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxNR() //  [R1]
         { info_tbl: [(cxNR,
                       label: block_cxNR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxNR: // global
           if (R1 & 7 == 1) goto cxNV; else goto cxNW;
       cxNV: // global
           R1 = GHC.List.init2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxNW: // global
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.List.init1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.035008763 UTC

[section ""cstring" . lvl11_ru93_bytes" {
     lvl11_ru93_bytes:
         I8[] [108,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.036954821 UTC

[section ""data" . lvl12_ru94_closure" {
     lvl12_ru94_closure:
         const lvl12_ru94_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ru94_entry() //  [R1]
         { info_tbl: [(cxOs,
                       label: lvl12_ru94_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxOs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxOt; else goto cxOu;
       cxOt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxOu: // global
           (_cxOp::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxOp::I64 == 0) goto cxOr; else goto cxOq;
       cxOr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxOq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxOp::I64;
           R2 = lvl11_ru93_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.041072785 UTC

[section ""data" . GHC.List.lastError_closure" {
     GHC.List.lastError_closure:
         const GHC.List.lastError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.lastError_entry() //  [R1]
         { info_tbl: [(cxOJ,
                       label: GHC.List.lastError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxOJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxOK; else goto cxOL;
       cxOK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxOL: // global
           (_cxOG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxOG::I64 == 0) goto cxOI; else goto cxOH;
       cxOI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxOH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxOG::I64;
           R2 = lvl12_ru94_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.046498177 UTC

[section ""data" . poly_go_ru95_closure" {
     poly_go_ru95_closure:
         const poly_go_ru95_info;
 },
 poly_go_ru95_entry() //  [R2, R3]
         { info_tbl: [(cxP5,
                       label: poly_go_ru95_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxP5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxP6; else goto uxPe;
       cxP6: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_go_ru95_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxPe: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxOV() args: 0, res: 0, upd: 0;
     }
 },
 _cxOV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxOV: // global
           _sxq2::P64 = P64[Sp];
           I64[Sp] = block_cxOY_info;
           R1 = _sxq2::P64;
           if (R1 & 7 != 0) goto uxPg; else goto cxOZ;
       uxPg: // global
           call _cxOY(R1) args: 0, res: 0, upd: 0;
       cxOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxOY() //  [R1]
         { info_tbl: [(cxOY,
                       label: block_cxOY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxOY: // global
           if (R1 & 7 == 1) goto cxP2; else goto cxP3;
       cxP2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxP3: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cxOV() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.052933457 UTC

[section ""data" . GHC.List.last_closure" {
     GHC.List.last_closure:
         const GHC.List.last_info;
         const 0;
 },
 GHC.List.last_entry() //  [R2]
         { info_tbl: [(cxPD,
                       label: GHC.List.last_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxPD: // global
           R3 = GHC.List.lastError_closure;
           R2 = R2;
           call poly_go_ru95_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.056178276 UTC

[section ""cstring" . lvl13_ru96_bytes" {
     lvl13_ru96_bytes:
         I8[] [116,97,105,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.058072055 UTC

[section ""data" . lvl14_ru97_closure" {
     lvl14_ru97_closure:
         const lvl14_ru97_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ru97_entry() //  [R1]
         { info_tbl: [(cxPR,
                       label: lvl14_ru97_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxPR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxPS; else goto cxPT;
       cxPS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxPT: // global
           (_cxPO::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxPO::I64 == 0) goto cxPQ; else goto cxPP;
       cxPQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxPP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxPO::I64;
           R2 = lvl13_ru96_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.062438723 UTC

[section ""data" . GHC.List.scanl2_closure" {
     GHC.List.scanl2_closure:
         const GHC.List.scanl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.scanl2_entry() //  [R1]
         { info_tbl: [(cxQ8,
                       label: GHC.List.scanl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxQ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxQ9; else goto cxQa;
       cxQ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxQa: // global
           (_cxQ5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxQ5::I64 == 0) goto cxQ7; else goto cxQ6;
       cxQ7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxQ6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxQ5::I64;
           R2 = lvl14_ru97_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.066675083 UTC

[section ""data" . GHC.List.tail_closure" {
     GHC.List.tail_closure:
         const GHC.List.tail_info;
         const 0;
 },
 GHC.List.tail_entry() //  [R2]
         { info_tbl: [(cxQu,
                       label: GHC.List.tail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxQu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxQv; else goto cxQw;
       cxQv: // global
           R2 = R2;
           R1 = GHC.List.tail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxQw: // global
           I64[Sp - 8] = block_cxQn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxQD; else goto cxQo;
       uxQD: // global
           call _cxQn(R1) args: 0, res: 0, upd: 0;
       cxQo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxQn() //  [R1]
         { info_tbl: [(cxQn,
                       label: block_cxQn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxQn: // global
           if (R1 & 7 == 1) goto cxQr; else goto cxQs;
       cxQr: // global
           R1 = GHC.List.scanl2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxQs: // global
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.072546427 UTC

[section ""cstring" . lvl15_ru98_bytes" {
     lvl15_ru98_bytes:
         I8[] [104,101,97,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.07471099 UTC

[section ""data" . lvl16_ru99_closure" {
     lvl16_ru99_closure:
         const lvl16_ru99_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_ru99_entry() //  [R1]
         { info_tbl: [(cxR0,
                       label: lvl16_ru99_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxR0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxR1; else goto cxR2;
       cxR1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxR2: // global
           (_cxQX::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxQX::I64 == 0) goto cxQZ; else goto cxQY;
       cxQZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxQY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxQX::I64;
           R2 = lvl15_ru98_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.078958336 UTC

[section ""data" . GHC.List.badHead_closure" {
     GHC.List.badHead_closure:
         const GHC.List.badHead_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.badHead_entry() //  [R1]
         { info_tbl: [(cxRh,
                       label: GHC.List.badHead_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxRh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxRi; else goto cxRj;
       cxRi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxRj: // global
           (_cxRe::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxRe::I64 == 0) goto cxRg; else goto cxRf;
       cxRg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxRf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxRe::I64;
           R2 = lvl16_ru99_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.083114934 UTC

[section ""data" . GHC.List.head_closure" {
     GHC.List.head_closure:
         const GHC.List.head_info;
         const 0;
 },
 GHC.List.head_entry() //  [R2]
         { info_tbl: [(cxRD,
                       label: GHC.List.head_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxRD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxRE; else goto cxRF;
       cxRE: // global
           R2 = R2;
           R1 = GHC.List.head_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxRF: // global
           I64[Sp - 8] = block_cxRw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxRM; else goto cxRx;
       uxRM: // global
           call _cxRw(R1) args: 0, res: 0, upd: 0;
       cxRx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxRw() //  [R1]
         { info_tbl: [(cxRw,
                       label: block_cxRw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxRw: // global
           if (R1 & 7 == 1) goto cxRA; else goto cxRB;
       cxRA: // global
           R1 = GHC.List.badHead_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxRB: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.088532051 UTC

[section ""cstring" . lvl17_ru9a_bytes" {
     lvl17_ru9a_bytes:
         I8[] [109,97,120,105,109,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.090515973 UTC

[section ""data" . lvl18_ru9b_closure" {
     lvl18_ru9b_closure:
         const lvl18_ru9b_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_ru9b_entry() //  [R1]
         { info_tbl: [(cxS6,
                       label: lvl18_ru9b_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxS6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxS7; else goto cxS8;
       cxS7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxS8: // global
           (_cxS3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxS3::I64 == 0) goto cxS5; else goto cxS4;
       cxS5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxS4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxS3::I64;
           R2 = lvl17_ru9a_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.09484737 UTC

[section ""data" . GHC.List.maximum1_closure" {
     GHC.List.maximum1_closure:
         const GHC.List.maximum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum1_entry() //  [R1]
         { info_tbl: [(cxSn,
                       label: GHC.List.maximum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxSn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxSo; else goto cxSp;
       cxSo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxSp: // global
           (_cxSk::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxSk::I64 == 0) goto cxSm; else goto cxSl;
       cxSm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxSl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxSk::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.099654115 UTC

[section ""data" . GHC.List.maximum2_closure" {
     GHC.List.maximum2_closure:
         const GHC.List.maximum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum2_entry() //  [R1]
         { info_tbl: [(cxSE,
                       label: GHC.List.maximum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxSE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxSF; else goto cxSG;
       cxSF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxSG: // global
           (_cxSB::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxSB::I64 == 0) goto cxSD; else goto cxSC;
       cxSD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxSC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxSB::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.103692486 UTC

[section ""data" . lvl19_ru9c_closure" {
     lvl19_ru9c_closure:
         const lvl19_ru9c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_ru9c_entry() //  [R1]
         { info_tbl: [(cxSV,
                       label: lvl19_ru9c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxSV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxSW; else goto cxSX;
       cxSW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxSX: // global
           (_cxSS::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxSS::I64 == 0) goto cxSU; else goto cxST;
       cxSU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxST: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxSS::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.108051523 UTC

[section ""data" . GHC.List.maximum_go_closure" {
     GHC.List.maximum_go_closure:
         const GHC.List.maximum_go_info;
 },
 GHC.List.maximum_go_entry() //  [R2, R3]
         { info_tbl: [(cxTh,
                       label: GHC.List.maximum_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxTh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxTi; else goto uxTB;
       cxTi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxTB: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxT7() args: 0, res: 0, upd: 0;
     }
 },
 _cxT7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxT7: // global
           _sxqg::P64 = P64[Sp];
           I64[Sp] = block_cxTa_info;
           R1 = _sxqg::P64;
           if (R1 & 7 != 0) goto uxTE; else goto cxTb;
       uxTE: // global
           call _cxTa(R1) args: 0, res: 0, upd: 0;
       cxTb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxTa() //  [R1]
         { info_tbl: [(cxTa,
                       label: block_cxTa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxTa: // global
           _sxqh::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cxTe; else goto cxTf;
       cxTe: // global
           R1 = _sxqh::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxTf: // global
           I64[Sp - 16] = block_cxTp_info;
           _sxqj::P64 = P64[R1 + 6];
           R3 = _sxqj::P64;
           R2 = _sxqh::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _sxqj::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cxTp() //  [R1]
         { info_tbl: [(cxTp,
                       label: block_cxTp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxTp: // global
           _sxqk::P64 = P64[Sp + 8];
           if (R1 == 1) goto cxTA; else goto cxTw;
       cxTA: // global
           _sxqh::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sxqk::P64;
           P64[Sp + 24] = _sxqh::P64;
           Sp = Sp + 16;
           goto uxTH;
       cxTw: // global
           P64[Sp + 16] = _sxqk::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uxTH;
       uxTH: // global
           call _cxT7() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.116570941 UTC

[section ""data" . GHC.List.maximum_$smaximum_closure" {
     GHC.List.maximum_$smaximum_closure:
         const GHC.List.maximum_$smaximum_info;
         const 0;
 },
 GHC.List.maximum_$smaximum_entry() //  [R2]
         { info_tbl: [(cxUf,
                       label: GHC.List.maximum_$smaximum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxUf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxUg; else goto cxUh;
       cxUg: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxUh: // global
           I64[Sp - 8] = block_cxU8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxUo; else goto cxU9;
       uxUo: // global
           call _cxU8(R1) args: 0, res: 0, upd: 0;
       cxU9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxU8() //  [R1]
         { info_tbl: [(cxU8,
                       label: block_cxU8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxU8: // global
           if (R1 & 7 == 1) goto cxUc; else goto cxUd;
       cxUc: // global
           R1 = GHC.List.maximum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxUd: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.maximum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.121958416 UTC

[section ""cstring" . lvl20_ru9d_bytes" {
     lvl20_ru9d_bytes:
         I8[] [109,105,110,105,109,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.123800933 UTC

[section ""data" . lvl21_ru9e_closure" {
     lvl21_ru9e_closure:
         const lvl21_ru9e_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_ru9e_entry() //  [R1]
         { info_tbl: [(cxUJ,
                       label: lvl21_ru9e_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxUJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxUK; else goto cxUL;
       cxUK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxUL: // global
           (_cxUG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxUG::I64 == 0) goto cxUI; else goto cxUH;
       cxUI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxUH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxUG::I64;
           R2 = lvl20_ru9d_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.128143759 UTC

[section ""data" . GHC.List.minimum1_closure" {
     GHC.List.minimum1_closure:
         const GHC.List.minimum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum1_entry() //  [R1]
         { info_tbl: [(cxV0,
                       label: GHC.List.minimum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxV0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxV1; else goto cxV2;
       cxV1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxV2: // global
           (_cxUX::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxUX::I64 == 0) goto cxUZ; else goto cxUY;
       cxUZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxUY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxUX::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.132753531 UTC

[section ""data" . GHC.List.minimum2_closure" {
     GHC.List.minimum2_closure:
         const GHC.List.minimum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum2_entry() //  [R1]
         { info_tbl: [(cxVh,
                       label: GHC.List.minimum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxVh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxVi; else goto cxVj;
       cxVi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxVj: // global
           (_cxVe::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxVe::I64 == 0) goto cxVg; else goto cxVf;
       cxVg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxVf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxVe::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.13695316 UTC

[section ""data" . lvl22_ru9f_closure" {
     lvl22_ru9f_closure:
         const lvl22_ru9f_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ru9f_entry() //  [R1]
         { info_tbl: [(cxVy,
                       label: lvl22_ru9f_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxVy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxVz; else goto cxVA;
       cxVz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxVA: // global
           (_cxVv::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxVv::I64 == 0) goto cxVx; else goto cxVw;
       cxVx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxVw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxVv::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.141730091 UTC

[section ""data" . GHC.List.minimum_go_closure" {
     GHC.List.minimum_go_closure:
         const GHC.List.minimum_go_info;
 },
 GHC.List.minimum_go_entry() //  [R2, R3]
         { info_tbl: [(cxVU,
                       label: GHC.List.minimum_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxVU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxVV; else goto uxWe;
       cxVV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxWe: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxVK() args: 0, res: 0, upd: 0;
     }
 },
 _cxVK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxVK: // global
           _sxqq::P64 = P64[Sp];
           I64[Sp] = block_cxVN_info;
           R1 = _sxqq::P64;
           if (R1 & 7 != 0) goto uxWh; else goto cxVO;
       uxWh: // global
           call _cxVN(R1) args: 0, res: 0, upd: 0;
       cxVO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxVN() //  [R1]
         { info_tbl: [(cxVN,
                       label: block_cxVN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxVN: // global
           _sxqr::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cxVR; else goto cxVS;
       cxVR: // global
           R1 = _sxqr::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxVS: // global
           I64[Sp - 16] = block_cxW2_info;
           _sxqt::P64 = P64[R1 + 6];
           R3 = _sxqt::P64;
           R2 = _sxqr::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _sxqt::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cxW2() //  [R1]
         { info_tbl: [(cxW2,
                       label: block_cxW2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxW2: // global
           _sxqu::P64 = P64[Sp + 8];
           if (R1 == 1) goto cxWd; else goto cxW9;
       cxWd: // global
           P64[Sp + 16] = _sxqu::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uxWk;
       cxW9: // global
           _sxqr::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sxqu::P64;
           P64[Sp + 24] = _sxqr::P64;
           Sp = Sp + 16;
           goto uxWk;
       uxWk: // global
           call _cxVK() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.150780357 UTC

[section ""data" . GHC.List.minimum_$sminimum_closure" {
     GHC.List.minimum_$sminimum_closure:
         const GHC.List.minimum_$sminimum_info;
         const 0;
 },
 GHC.List.minimum_$sminimum_entry() //  [R2]
         { info_tbl: [(cxWS,
                       label: GHC.List.minimum_$sminimum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxWS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxWT; else goto cxWU;
       cxWT: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxWU: // global
           I64[Sp - 8] = block_cxWL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxX1; else goto cxWM;
       uxX1: // global
           call _cxWL(R1) args: 0, res: 0, upd: 0;
       cxWM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxWL() //  [R1]
         { info_tbl: [(cxWL,
                       label: block_cxWL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxWL: // global
           if (R1 & 7 == 1) goto cxWP; else goto cxWQ;
       cxWP: // global
           R1 = GHC.List.minimum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxWQ: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.minimum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.158110727 UTC

[section ""data" . GHC.List.$wgo_closure" {
     GHC.List.$wgo_closure:
         const GHC.List.$wgo_info;
 },
 GHC.List.$wgo_entry() //  [R2, R3]
         { info_tbl: [(cxXq,
                       label: GHC.List.$wgo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxXq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxXr; else goto uxXK;
       cxXr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxXK: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxXg() args: 0, res: 0, upd: 0;
     }
 },
 _cxXg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxXg: // global
           _sxqA::P64 = P64[Sp];
           I64[Sp] = block_cxXj_info;
           R1 = _sxqA::P64;
           if (R1 & 7 != 0) goto uxXN; else goto cxXk;
       uxXN: // global
           call _cxXj(R1) args: 0, res: 0, upd: 0;
       cxXk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxXj() //  [R1]
         { info_tbl: [(cxXj,
                       label: block_cxXj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxXj: // global
           if (R1 & 7 == 1) goto cxXn; else goto cxXo;
       cxXn: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxXo: // global
           I64[Sp - 8] = block_cxXy_info;
           _sxqE::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxqE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxXO; else goto cxXA;
       uxXO: // global
           call _cxXy(R1) args: 0, res: 0, upd: 0;
       cxXA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxXy() //  [R1]
         { info_tbl: [(cxXy,
                       label: block_cxXy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxXy: // global
           _sxqB::I64 = I64[Sp + 16];
           _sxqE::P64 = P64[Sp + 8];
           _sxqG::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_sxqB::I64,
                            _sxqG::I64)) goto cxXI; else goto cxXJ;
       cxXI: // global
           P64[Sp + 8] = _sxqE::P64;
           I64[Sp + 16] = _sxqB::I64;
           Sp = Sp + 8;
           goto uxXR;
       cxXJ: // global
           P64[Sp + 8] = _sxqE::P64;
           I64[Sp + 16] = _sxqG::I64;
           Sp = Sp + 8;
           goto uxXR;
       uxXR: // global
           call _cxXg() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.167616807 UTC

[section ""data" . GHC.List.maximum_$smaximum1_closure" {
     GHC.List.maximum_$smaximum1_closure:
         const GHC.List.maximum_$smaximum1_info;
         const 0;
 },
 GHC.List.maximum_$smaximum1_entry() //  [R2]
         { info_tbl: [(cxYn,
                       label: GHC.List.maximum_$smaximum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxYn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxYo; else goto cxYp;
       cxYo: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxYp: // global
           I64[Sp - 8] = block_cxYg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxYL; else goto cxYh;
       uxYL: // global
           call _cxYg(R1) args: 0, res: 0, upd: 0;
       cxYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxYg() //  [R1]
         { info_tbl: [(cxYg,
                       label: block_cxYg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxYg: // global
           if (R1 & 7 == 1) goto cxYk; else goto cxYl;
       cxYk: // global
           R1 = GHC.List.maximum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxYl: // global
           I64[Sp - 8] = block_cxYv_info;
           _sxqL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxqL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxYK; else goto cxYw;
       uxYK: // global
           call _cxYv(R1) args: 0, res: 0, upd: 0;
       cxYw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxYv() //  [R1]
         { info_tbl: [(cxYv,
                       label: block_cxYv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxYv: // global
           _sxqL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cxYA_info;
           R3 = I64[R1 + 7];
           R2 = _sxqL::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cxYA() //  [R1]
         { info_tbl: [(cxYA,
                       label: block_cxYA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxYA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxYJ; else goto cxYI;
       cxYJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cxYI: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.177846578 UTC

[section ""data" . GHC.List.maximum_closure" {
     GHC.List.maximum_closure:
         const GHC.List.maximum_info;
         const 0;
 },
 sat_sxr0_entry() //  [R1]
         { info_tbl: [(cxZz,
                       label: sat_sxr0_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxZz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cxZA; else goto cxZB;
       cxZA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxZB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.max_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.List.maximum_entry() //  [R2, R3]
         { info_tbl: [(cxZG,
                       label: GHC.List.maximum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxZG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxZH; else goto cxZI;
       cxZH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxZI: // global
           I64[Sp - 16] = block_cxZe_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uy01; else goto cxZf;
       uy01: // global
           call _cxZe(R1) args: 0, res: 0, upd: 0;
       cxZf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxZe() //  [R1]
         { info_tbl: [(cxZe,
                       label: block_cxZe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxZe: // global
           if (R1 & 7 == 1) goto cxZD; else goto cxZE;
       cxZD: // global
           R1 = lvl19_ru9c_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxZE: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cxZn() args: 0, res: 0, upd: 0;
     }
 },
 _cxZn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxZn: // global
           I64[Sp - 8] = block_cxZp_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxZZ; else goto cxZq;
       uxZZ: // global
           call _cxZp(R1) args: 0, res: 0, upd: 0;
       cxZq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxZp() //  [R1]
         { info_tbl: [(cxZp,
                       label: block_cxZp_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cxZp: // global
           _sxqW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cxZQ; else goto cxZR;
       cxZQ: // global
           R1 = _sxqW::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxZR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxZU; else goto cxZT;
       cxZU: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxZT: // global
           _sxqY::P64 = P64[R1 + 6];
           _sxqZ::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_sxr0_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sxqW::P64;
           P64[Hp] = _sxqY::P64;
           P64[Sp + 16] = _sxqZ::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cxZn() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.189789313 UTC

[section ""data" . GHC.List.$wgo1_closure" {
     GHC.List.$wgo1_closure:
         const GHC.List.$wgo1_info;
 },
 GHC.List.$wgo1_entry() //  [R2, R3]
         { info_tbl: [(cy0L,
                       label: GHC.List.$wgo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy0L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cy0M; else goto uy15;
       cy0M: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uy15: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cy0B() args: 0, res: 0, upd: 0;
     }
 },
 _cy0B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy0B: // global
           _sxr1::P64 = P64[Sp];
           I64[Sp] = block_cy0E_info;
           R1 = _sxr1::P64;
           if (R1 & 7 != 0) goto uy18; else goto cy0F;
       uy18: // global
           call _cy0E(R1) args: 0, res: 0, upd: 0;
       cy0F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy0E() //  [R1]
         { info_tbl: [(cy0E,
                       label: block_cy0E_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy0E: // global
           if (R1 & 7 == 1) goto cy0I; else goto cy0J;
       cy0I: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cy0J: // global
           I64[Sp - 8] = block_cy0T_info;
           _sxr5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxr5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy19; else goto cy0V;
       uy19: // global
           call _cy0T(R1) args: 0, res: 0, upd: 0;
       cy0V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy0T() //  [R1]
         { info_tbl: [(cy0T,
                       label: block_cy0T_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy0T: // global
           _sxr2::I64 = I64[Sp + 16];
           _sxr5::P64 = P64[Sp + 8];
           _sxr7::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_sxr2::I64,
                            _sxr7::I64)) goto cy13; else goto cy14;
       cy13: // global
           P64[Sp + 8] = _sxr5::P64;
           I64[Sp + 16] = _sxr7::I64;
           Sp = Sp + 8;
           goto uy1c;
       cy14: // global
           P64[Sp + 8] = _sxr5::P64;
           I64[Sp + 16] = _sxr2::I64;
           Sp = Sp + 8;
           goto uy1c;
       uy1c: // global
           call _cy0B() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.19963053 UTC

[section ""data" . GHC.List.minimum_$sminimum1_closure" {
     GHC.List.minimum_$sminimum1_closure:
         const GHC.List.minimum_$sminimum1_info;
         const 0;
 },
 GHC.List.minimum_$sminimum1_entry() //  [R2]
         { info_tbl: [(cy1I,
                       label: GHC.List.minimum_$sminimum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy1I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy1J; else goto cy1K;
       cy1J: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cy1K: // global
           I64[Sp - 8] = block_cy1B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy26; else goto cy1C;
       uy26: // global
           call _cy1B(R1) args: 0, res: 0, upd: 0;
       cy1C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy1B() //  [R1]
         { info_tbl: [(cy1B,
                       label: block_cy1B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy1B: // global
           if (R1 & 7 == 1) goto cy1F; else goto cy1G;
       cy1F: // global
           R1 = GHC.List.minimum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cy1G: // global
           I64[Sp - 8] = block_cy1Q_info;
           _sxrc::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxrc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy25; else goto cy1R;
       uy25: // global
           call _cy1Q(R1) args: 0, res: 0, upd: 0;
       cy1R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy1Q() //  [R1]
         { info_tbl: [(cy1Q,
                       label: block_cy1Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy1Q: // global
           _sxrc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cy1V_info;
           R3 = I64[R1 + 7];
           R2 = _sxrc::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cy1V() //  [R1]
         { info_tbl: [(cy1V,
                       label: block_cy1V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy1V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cy24; else goto cy23;
       cy24: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cy23: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.210278118 UTC

[section ""data" . GHC.List.minimum_closure" {
     GHC.List.minimum_closure:
         const GHC.List.minimum_info;
         const 0;
 },
 sat_sxrr_entry() //  [R1]
         { info_tbl: [(cy2U,
                       label: sat_sxrr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy2U: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cy2V; else goto cy2W;
       cy2V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy2W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.min_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 GHC.List.minimum_entry() //  [R2, R3]
         { info_tbl: [(cy31,
                       label: GHC.List.minimum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy31: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cy32; else goto cy33;
       cy32: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cy33: // global
           I64[Sp - 16] = block_cy2z_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uy3m; else goto cy2A;
       uy3m: // global
           call _cy2z(R1) args: 0, res: 0, upd: 0;
       cy2A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy2z() //  [R1]
         { info_tbl: [(cy2z,
                       label: block_cy2z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy2z: // global
           if (R1 & 7 == 1) goto cy2Y; else goto cy2Z;
       cy2Y: // global
           R1 = lvl22_ru9f_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cy2Z: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cy2I() args: 0, res: 0, upd: 0;
     }
 },
 _cy2I() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy2I: // global
           I64[Sp - 8] = block_cy2K_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy3k; else goto cy2L;
       uy3k: // global
           call _cy2K(R1) args: 0, res: 0, upd: 0;
       cy2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy2K() //  [R1]
         { info_tbl: [(cy2K,
                       label: block_cy2K_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy2K: // global
           _sxrn::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cy3b; else goto cy3c;
       cy3b: // global
           R1 = _sxrn::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cy3c: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cy3f; else goto cy3e;
       cy3f: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cy3e: // global
           _sxrp::P64 = P64[R1 + 6];
           _sxrq::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_sxrr_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sxrn::P64;
           P64[Hp] = _sxrp::P64;
           P64[Sp + 16] = _sxrq::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cy2I() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.221178539 UTC

[section ""cstring" . lvl23_ru9g_bytes" {
     lvl23_ru9g_bytes:
         I8[] [102,111,108,100,108,49,39]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.223251342 UTC

[section ""data" . lvl24_ru9h_closure" {
     lvl24_ru9h_closure:
         const lvl24_ru9h_info;
         const 0;
         const 0;
         const 0;
 },
 lvl24_ru9h_entry() //  [R1]
         { info_tbl: [(cy42,
                       label: lvl24_ru9h_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy42: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy43; else goto cy44;
       cy43: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy44: // global
           (_cy3Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cy3Z::I64 == 0) goto cy41; else goto cy40;
       cy41: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cy40: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cy3Z::I64;
           R2 = lvl23_ru9g_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.227957269 UTC

[section ""data" . GHC.List.foldl1'1_closure" {
     GHC.List.foldl1'1_closure:
         const GHC.List.foldl1'1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl1'1_entry() //  [R1]
         { info_tbl: [(cy4j,
                       label: GHC.List.foldl1'1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy4j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy4k; else goto cy4l;
       cy4k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy4l: // global
           (_cy4g::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cy4g::I64 == 0) goto cy4i; else goto cy4h;
       cy4i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cy4h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cy4g::I64;
           R2 = lvl24_ru9h_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.231872771 UTC

[section ""cstring" . lvl25_ru9i_bytes" {
     lvl25_ru9i_bytes:
         I8[] [102,111,108,100,108,49]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.233775901 UTC

[section ""data" . lvl26_ru9j_closure" {
     lvl26_ru9j_closure:
         const lvl26_ru9j_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_ru9j_entry() //  [R1]
         { info_tbl: [(cy4B,
                       label: lvl26_ru9j_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy4B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy4C; else goto cy4D;
       cy4C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy4D: // global
           (_cy4y::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cy4y::I64 == 0) goto cy4A; else goto cy4z;
       cy4A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cy4z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cy4y::I64;
           R2 = lvl25_ru9i_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.23782254 UTC

[section ""data" . GHC.List.foldl2_closure" {
     GHC.List.foldl2_closure:
         const GHC.List.foldl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl2_entry() //  [R1]
         { info_tbl: [(cy4S,
                       label: GHC.List.foldl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy4S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy4T; else goto cy4U;
       cy4T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy4U: // global
           (_cy4P::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cy4P::I64 == 0) goto cy4R; else goto cy4Q;
       cy4R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cy4Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cy4P::I64;
           R2 = lvl26_ru9j_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.242635686 UTC

[section ""data" . $wgo2_ru9k_closure" {
     $wgo2_ru9k_closure:
         const $wgo2_ru9k_info;
 },
 ds_sxrA_entry() //  [R1]
         { info_tbl: [(cy5p,
                       label: ds_sxrA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy5p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cy5q; else goto cy5r;
       cy5q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy5r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cy5m_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cy5m() //  [R1, R2, R3]
         { info_tbl: [(cy5m,
                       label: block_cy5m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy5m: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cy5u; else goto cy5t;
       cy5u: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 24;
       cy5t: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo2_ru9k_entry() //  [R2]
         { info_tbl: [(cy5z,
                       label: $wgo2_ru9k_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy5z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy5A; else goto cy5B;
       cy5A: // global
           R2 = R2;
           R1 = $wgo2_ru9k_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cy5B: // global
           I64[Sp - 8] = block_cy57_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy5P; else goto cy58;
       uy5P: // global
           call _cy57(R1) args: 0, res: 0, upd: 0;
       cy58: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy57() //  [R1]
         { info_tbl: [(cy57,
                       label: block_cy57_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy57: // global
           if (R1 & 7 == 1) goto cy5w; else goto cy5x;
       cy5w: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cy5x: // global
           I64[Sp - 8] = block_cy5d_info;
           _sxrv::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxrv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy5O; else goto cy5e;
       uy5O: // global
           call _cy5d(R1) args: 0, res: 0, upd: 0;
       cy5e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy5d() //  [R1]
         { info_tbl: [(cy5d,
                       label: block_cy5d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy5d: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cy5N; else goto cy5M;
       cy5N: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cy5M: // global
           _sxrx::P64 = P64[R1 + 7];
           _sxry::P64 = P64[R1 + 15];
           _sxrz::P64 = P64[R1 + 23];
           I64[Hp - 160] = ds_sxrA_info;
           P64[Hp - 144] = P64[Sp + 8];
           I64[Hp - 136] = stg_sel_2_upd_info;
           _cy5i::P64 = Hp - 160;
           P64[Hp - 120] = _cy5i::P64;
           I64[Hp - 112] = :_con_info;
           P64[Hp - 104] = _sxrz::P64;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _cy5i::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sxry::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cy5i::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxrx::P64;
           P64[Hp] = Hp - 40;
           R3 = Hp - 110;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.255814274 UTC

[section ""data" . go_ru9l_closure" {
     go_ru9l_closure:
         const go_ru9l_info;
 },
 go_ru9l_entry() //  [R2]
         { info_tbl: [(cy6F,
                       label: go_ru9l_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy6F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cy6G; else goto cy6H;
       cy6G: // global
           R2 = R2;
           R1 = go_ru9l_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cy6H: // global
           I64[Sp - 8] = block_cy6C_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cy6C() //  [R1, R2, R3]
         { info_tbl: [(cy6C,
                       label: block_cy6C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy6C: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cy6K; else goto cy6J;
       cy6K: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cy6J: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.261655123 UTC

[section ""data" . GHC.List.unzip3_closure" {
     GHC.List.unzip3_closure:
         const GHC.List.unzip3_info;
 },
 GHC.List.unzip3_entry() //  [R2]
         { info_tbl: [(cy70,
                       label: GHC.List.unzip3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy70: // global
           R2 = R2;
           call go_ru9l_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.265705823 UTC

[section ""data" . $wgo3_ru9m_closure" {
     $wgo3_ru9m_closure:
         const $wgo3_ru9m_info;
 },
 ds_sxs9_entry() //  [R1]
         { info_tbl: [(cy7t,
                       label: ds_sxs9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy7t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cy7u; else goto cy7v;
       cy7u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy7v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cy7q_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cy7q() //  [R1, R2]
         { info_tbl: [(cy7q,
                       label: block_cy7q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy7q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cy7y; else goto cy7x;
       cy7y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cy7x: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo3_ru9m_entry() //  [R2]
         { info_tbl: [(cy7D,
                       label: $wgo3_ru9m_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy7E; else goto cy7F;
       cy7E: // global
           R2 = R2;
           R1 = $wgo3_ru9m_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cy7F: // global
           I64[Sp - 8] = block_cy7b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy7R; else goto cy7c;
       uy7R: // global
           call _cy7b(R1) args: 0, res: 0, upd: 0;
       cy7c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy7b() //  [R1]
         { info_tbl: [(cy7b,
                       label: block_cy7b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy7b: // global
           if (R1 & 7 == 1) goto cy7A; else goto cy7B;
       cy7A: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cy7B: // global
           I64[Sp - 8] = block_cy7h_info;
           _sxs5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxs5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy7Q; else goto cy7i;
       uy7Q: // global
           call _cy7h(R1) args: 0, res: 0, upd: 0;
       cy7i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy7h() //  [R1]
         { info_tbl: [(cy7h,
                       label: block_cy7h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy7h: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cy7P; else goto cy7O;
       cy7P: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cy7O: // global
           _sxs7::P64 = P64[R1 + 7];
           _sxs8::P64 = P64[R1 + 15];
           I64[Hp - 112] = ds_sxs9_info;
           P64[Hp - 96] = P64[Sp + 8];
           I64[Hp - 88] = stg_sel_1_upd_info;
           _cy7m::P64 = Hp - 112;
           P64[Hp - 72] = _cy7m::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sxs8::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cy7m::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxs7::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.277951943 UTC

[section ""data" . go1_ru9n_closure" {
     go1_ru9n_closure:
         const go1_ru9n_info;
 },
 go1_ru9n_entry() //  [R2]
         { info_tbl: [(cy8D,
                       label: go1_ru9n_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy8D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cy8E; else goto cy8F;
       cy8E: // global
           R2 = R2;
           R1 = go1_ru9n_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cy8F: // global
           I64[Sp - 8] = block_cy8A_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cy8A() //  [R1, R2]
         { info_tbl: [(cy8A,
                       label: block_cy8A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy8A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cy8I; else goto cy8H;
       cy8I: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cy8H: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.283576218 UTC

[section ""data" . GHC.List.unzip_closure" {
     GHC.List.unzip_closure:
         const GHC.List.unzip_info;
 },
 GHC.List.unzip_entry() //  [R2]
         { info_tbl: [(cy8Y,
                       label: GHC.List.unzip_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy8Y: // global
           R2 = R2;
           call go1_ru9n_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.28853851 UTC

[section ""data" . GHC.List.zipWith3_closure" {
     GHC.List.zipWith3_closure:
         const GHC.List.zipWith3_info;
 },
 go2_sxsv_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cy9l,
                       label: go2_sxsv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy9l: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cy9m; else goto cy9n;
       cy9m: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cy9n: // global
           I64[Sp - 40] = block_cy9e_info;
           _sxsv::P64 = R1;
           _sxsr::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 32] = _sxsr::P64;
           P64[Sp - 24] = _sxsv::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uya4; else goto cy9f;
       uya4: // global
           call _cy9e(R1) args: 0, res: 0, upd: 0;
       cy9f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy9e() //  [R1]
         { info_tbl: [(cy9e,
                       label: block_cy9e_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy9e: // global
           if (R1 & 7 == 1) goto uy9Z; else goto cy9j;
       uy9Z: // global
           Sp = Sp + 40;
           call _cy9N() args: 0, res: 0, upd: 0;
       cy9j: // global
           I64[Sp - 8] = block_cy9t_info;
           _sxsA::P64 = P64[R1 + 6];
           _sxsB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sxsB::P64;
           P64[Sp + 24] = _sxsA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uya2; else goto cy9v;
       uya2: // global
           call _cy9t(R1) args: 0, res: 0, upd: 0;
       cy9v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy9t() //  [R1]
         { info_tbl: [(cy9t,
                       label: block_cy9t_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy9t: // global
           if (R1 & 7 == 1) goto uya0; else goto cy9G;
       uya0: // global
           Sp = Sp + 48;
           call _cy9N() args: 0, res: 0, upd: 0;
       cy9G: // global
           I64[Sp - 8] = block_cy9E_info;
           _sxsD::P64 = P64[R1 + 6];
           _sxsE::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sxsE::P64;
           P64[Sp + 40] = _sxsD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uya5; else goto cy9H;
       uya5: // global
           call _cy9E(R1) args: 0, res: 0, upd: 0;
       cy9H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy9E() //  [R1]
         { info_tbl: [(cy9E,
                       label: block_cy9E_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy9E: // global
           if (R1 & 7 == 1) goto uya1; else goto cy9T;
       uya1: // global
           Sp = Sp + 56;
           call _cy9N() args: 0, res: 0, upd: 0;
       cy9T: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cy9W; else goto cy9V;
       cy9W: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cy9V: // global
           _sxsG::P64 = P64[R1 + 6];
           _sxsH::P64 = P64[R1 + 14];
           I64[Hp - 112] = stg_ap_4_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 16];
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sxsH::P64;
           I64[Hp - 64] = stg_ap_4_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = _sxsG::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cy9N() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cy9N: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith3_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cya8,
                       label: GHC.List.zipWith3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cya8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cyac; else goto cyab;
       cyac: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyab: // global
           I64[Hp - 8] = go2_sxsv_info;
           P64[Hp] = R2;
           _sxst::P64 = R4;
           R4 = R5;
           _sxss::P64 = R3;
           R3 = _sxst::P64;
           R2 = _sxss::P64;
           R1 = Hp - 5;
           call go2_sxsv_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.302705377 UTC

[section ""data" . GHC.List.zipWithFB_closure" {
     GHC.List.zipWithFB_closure:
         const GHC.List.zipWithFB_info;
 },
 GHC.List.zipWithFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cyb2,
                       label: GHC.List.zipWithFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyb2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyb6; else goto cyb5;
       cyb6: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWithFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyb5: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R3 = R6;
           _sxsK::P64 = R2;
           R2 = Hp - 32;
           R1 = _sxsK::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.307681855 UTC

[section ""data" . GHC.List.zip3_closure" {
     GHC.List.zip3_closure:
         const GHC.List.zip3_info;
 },
 sat_sxt3_entry() //  [R1]
         { info_tbl: [(cybC,
                       label: sat_sxt3_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cybC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cybD; else goto cybE;
       cybD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cybE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.zip3_entry() //  [R2, R3, R4]
         { info_tbl: [(cybJ,
                       label: GHC.List.zip3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cybJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cybK; else goto cybL;
       cybK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cybL: // global
           I64[Sp - 24] = block_cybg_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uycf; else goto cybh;
       uycf: // global
           call _cybg(R1) args: 0, res: 0, upd: 0;
       cybh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cybg() //  [R1]
         { info_tbl: [(cybg,
                       label: block_cybg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cybg: // global
           if (R1 & 7 == 1) goto uyc7; else goto cybH;
       uyc7: // global
           Sp = Sp + 24;
           call _cybY() args: 0, res: 0, upd: 0;
       cybH: // global
           I64[Sp - 8] = block_cybm_info;
           _sxsU::P64 = P64[R1 + 6];
           _sxsV::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sxsV::P64;
           P64[Sp + 8] = _sxsU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyca; else goto cybn;
       uyca: // global
           call _cybm(R1) args: 0, res: 0, upd: 0;
       cybn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cybm() //  [R1]
         { info_tbl: [(cybm,
                       label: block_cybm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cybm: // global
           if (R1 & 7 == 1) goto uyc8; else goto cybU;
       uyc8: // global
           Sp = Sp + 32;
           call _cybY() args: 0, res: 0, upd: 0;
       cybU: // global
           I64[Sp - 8] = block_cybs_info;
           _sxsX::P64 = P64[R1 + 6];
           _sxsY::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sxsY::P64;
           P64[Sp + 24] = _sxsX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uycc; else goto cybt;
       uycc: // global
           call _cybs(R1) args: 0, res: 0, upd: 0;
       cybt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cybs() //  [R1]
         { info_tbl: [(cybs,
                       label: block_cybs_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cybs: // global
           if (R1 & 7 == 1) goto uyc9; else goto cyc1;
       uyc9: // global
           Sp = Sp + 40;
           call _cybY() args: 0, res: 0, upd: 0;
       cyc1: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cyc4; else goto cyc3;
       cyc4: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyc3: // global
           _sxt0::P64 = P64[R1 + 6];
           _sxt1::P64 = P64[R1 + 14];
           I64[Hp - 88] = sat_sxt3_info;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sxt1::P64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sxt0::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 47;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cybY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cybY: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.32177762 UTC

[section ""data" . GHC.List.zipFB_closure" {
     GHC.List.zipFB_closure:
         const GHC.List.zipFB_info;
 },
 GHC.List.zipFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cyd4,
                       label: GHC.List.zipFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyd4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyd8; else goto cyd7;
       cyd8: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyd7: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _sxt4::P64 = R2;
           R2 = Hp - 15;
           R1 = _sxt4::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.326252593 UTC

[section ""data" . GHC.List.foldr2_left_closure" {
     GHC.List.foldr2_left_closure:
         const GHC.List.foldr2_left_info;
 },
 GHC.List.foldr2_left_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cydp,
                       label: GHC.List.foldr2_left_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cydp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cydq; else goto cydr;
       cydq: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_left_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cydr: // global
           I64[Sp - 40] = block_cydi_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uydB; else goto cydj;
       uydB: // global
           call _cydi(R1) args: 0, res: 0, upd: 0;
       cydj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cydi() //  [R1]
         { info_tbl: [(cydi,
                       label: block_cydi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cydi: // global
           if (R1 & 7 == 1) goto cydm; else goto cydn;
       cydm: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cydn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cydA; else goto cydz;
       cydA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cydz: // global
           _sxtf::P64 = P64[R1 + 6];
           _sxtg::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sxtg::P64;
           R4 = Hp - 24;
           R3 = _sxtf::P64;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.334992883 UTC

[section ""data" . GHC.List.zip_closure" {
     GHC.List.zip_closure:
         const GHC.List.zip_info;
 },
 sat_sxtr_entry() //  [R1]
         { info_tbl: [(cyea,
                       label: sat_sxtr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyea: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyeb; else goto cyec;
       cyeb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyec: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.zip_entry() //  [R2, R3]
         { info_tbl: [(cyeh,
                       label: GHC.List.zip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyeh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyei; else goto cyej;
       cyei: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyej: // global
           I64[Sp - 16] = block_cydU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyeD; else goto cydV;
       uyeD: // global
           call _cydU(R1) args: 0, res: 0, upd: 0;
       cydV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cydU() //  [R1]
         { info_tbl: [(cydU,
                       label: block_cydU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cydU: // global
           if (R1 & 7 == 1) goto uyey; else goto cyef;
       uyey: // global
           Sp = Sp + 16;
           call _cyeq() args: 0, res: 0, upd: 0;
       cyef: // global
           I64[Sp - 8] = block_cye0_info;
           _sxtl::P64 = P64[R1 + 6];
           _sxtm::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sxtm::P64;
           P64[Sp + 8] = _sxtl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyeA; else goto cye1;
       uyeA: // global
           call _cye0(R1) args: 0, res: 0, upd: 0;
       cye1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cye0() //  [R1]
         { info_tbl: [(cye0,
                       label: block_cye0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cye0: // global
           if (R1 & 7 == 1) goto uyez; else goto cyet;
       uyez: // global
           Sp = Sp + 24;
           call _cyeq() args: 0, res: 0, upd: 0;
       cyet: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cyew; else goto cyev;
       cyew: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyev: // global
           _sxto::P64 = P64[R1 + 6];
           _sxtp::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sxtr_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sxtp::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sxto::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cyeq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyeq: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.zipWith_closure" {
     GHC.List.zipWith_closure:
         const GHC.List.zipWith_info;
 },
 go2_sxtv_entry() //  [R1, R2, R3]
         { info_tbl: [(cyeU,
                       label: go2_sxtv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyeU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cyeV; else goto cyeW;
       cyeV: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyeW: // global
           I64[Sp - 32] = block_cyeN_info;
           _sxtv::P64 = R1;
           _sxts::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 24] = _sxts::P64;
           P64[Sp - 16] = _sxtv::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uyfp; else goto cyeO;
       uyfp: // global
           call _cyeN(R1) args: 0, res: 0, upd: 0;
       cyeO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyeN() //  [R1]
         { info_tbl: [(cyeN,
                       label: block_cyeN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyeN: // global
           if (R1 & 7 == 1) goto uyfl; else goto cyeS;
       uyfl: // global
           Sp = Sp + 32;
           call _cyfa() args: 0, res: 0, upd: 0;
       cyeS: // global
           I64[Sp - 8] = block_cyf2_info;
           _sxtz::P64 = P64[R1 + 6];
           _sxtA::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sxtA::P64;
           P64[Sp + 24] = _sxtz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyfn; else goto cyf4;
       uyfn: // global
           call _cyf2(R1) args: 0, res: 0, upd: 0;
       cyf4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyf2() //  [R1]
         { info_tbl: [(cyf2,
                       label: block_cyf2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyf2: // global
           if (R1 & 7 == 1) goto uyfm; else goto cyfg;
       uyfm: // global
           Sp = Sp + 40;
           call _cyfa() args: 0, res: 0, upd: 0;
       cyfg: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cyfj; else goto cyfi;
       cyfj: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyfi: // global
           _sxtC::P64 = P64[R1 + 6];
           _sxtD::P64 = P64[R1 + 14];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sxtD::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sxtC::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cyfa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyfa: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cyfr,
                       label: GHC.List.zipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyfr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cyfv; else goto cyfu;
       cyfv: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyfu: // global
           I64[Hp - 8] = go2_sxtv_info;
           P64[Hp] = R2;
           _sxtt::P64 = R3;
           R3 = R4;
           R2 = _sxtt::P64;
           R1 = Hp - 6;
           call go2_sxtv_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.foldr2_closure" {
     GHC.List.foldr2_closure:
         const GHC.List.foldr2_info;
 },
 go2_sxtK_entry() //  [R1, R2, R3]
         { info_tbl: [(cyfM,
                       label: go2_sxtK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyfM: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cyfN; else goto cyfO;
       cyfN: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyfO: // global
           I64[Sp - 40] = block_cyfF_info;
           _sxtK::P64 = R1;
           _sxtG::P64 = P64[R1 + 6];
           _sxtH::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _sxtG::P64;
           P64[Sp - 24] = _sxtH::P64;
           P64[Sp - 16] = _sxtK::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uygf; else goto cyfG;
       uygf: // global
           call _cyfF(R1) args: 0, res: 0, upd: 0;
       cyfG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyfF() //  [R1]
         { info_tbl: [(cyfF,
                       label: block_cyfF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyfF: // global
           if (R1 & 7 == 1) goto uygb; else goto cyfK;
       uygb: // global
           Sp = Sp + 16;
           call _cyg2() args: 0, res: 0, upd: 0;
       cyfK: // global
           I64[Sp - 8] = block_cyfU_info;
           _sxtO::P64 = P64[R1 + 6];
           _sxtP::P64 = P64[R1 + 14];
           R1 = P64[Sp + 32];
           P64[Sp] = _sxtP::P64;
           P64[Sp + 32] = _sxtO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uygd; else goto cyfW;
       uygd: // global
           call _cyfU(R1) args: 0, res: 0, upd: 0;
       cyfW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyfU() //  [R1]
         { info_tbl: [(cyfU,
                       label: block_cyfU_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyfU: // global
           if (R1 & 7 == 1) goto uygc; else goto cyg6;
       uygc: // global
           Sp = Sp + 24;
           call _cyg2() args: 0, res: 0, upd: 0;
       cyg6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyg9; else goto cyg8;
       cyg9: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyg8: // global
           _sxtR::P64 = P64[R1 + 6];
           _sxtS::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sxtS::P64;
           R4 = Hp - 32;
           R3 = _sxtR::P64;
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 16];
           Sp = Sp + 48;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cyg2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyg2: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.foldr2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cygh,
                       label: GHC.List.foldr2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cygh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cygl; else goto cygk;
       cygl: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cygk: // global
           I64[Hp - 16] = go2_sxtK_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 14;
           call go2_sxtK_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.368357493 UTC

[section ""data" . GHC.List.concat_go_closure" {
     GHC.List.concat_go_closure:
         const GHC.List.concat_go_info;
 },
 sat_sxtY_entry() //  [R1]
         { info_tbl: [(cyid,
                       label: sat_sxtY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyid: // global
           R2 = P64[R1 + 16];
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.concat_go_entry() //  [R2]
         { info_tbl: [(cyik,
                       label: GHC.List.concat_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyik: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyil; else goto cyim;
       cyil: // global
           R2 = R2;
           R1 = GHC.List.concat_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyim: // global
           I64[Sp - 8] = block_cyi3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyis; else goto cyi4;
       uyis: // global
           call _cyi3(R1) args: 0, res: 0, upd: 0;
       cyi4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyi3() //  [R1]
         { info_tbl: [(cyi3,
                       label: block_cyi3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyi3: // global
           if (R1 & 7 == 1) goto cyih; else goto cyii;
       cyih: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyii: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyir; else goto cyiq;
       cyir: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyiq: // global
           _sxtW::P64 = P64[R1 + 6];
           _sxtX::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sxtY_info;
           P64[Hp] = _sxtX::P64;
           R3 = Hp - 16;
           R2 = _sxtW::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.37607891 UTC

[section ""data" . GHC.List.concat_closure" {
     GHC.List.concat_closure:
         const GHC.List.concat_info;
 },
 GHC.List.concat_entry() //  [R2]
         { info_tbl: [(cyiP,
                       label: GHC.List.concat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyiP: // global
           R2 = R2;
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.380186842 UTC

[section ""data" . GHC.List.concatMap_closure" {
     GHC.List.concatMap_closure:
         const GHC.List.concatMap_info;
 },
 sat_sxu7_entry() //  [R1]
         { info_tbl: [(cyjf,
                       label: sat_sxu7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyjf: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go2_sxu1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go2_sxu1_entry() //  [R1, R2]
         { info_tbl: [(cyjm,
                       label: go2_sxu1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyjm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyjn; else goto cyjo;
       cyjn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyjo: // global
           I64[Sp - 24] = block_cyj5_info;
           _sxu1::P64 = R1;
           _sxtZ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sxtZ::P64;
           P64[Sp - 8] = _sxu1::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uyjz; else goto cyj6;
       uyjz: // global
           call _cyj5(R1) args: 0, res: 0, upd: 0;
       cyj6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyj5() //  [R1]
         { info_tbl: [(cyj5,
                       label: block_cyj5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyj5: // global
           if (R1 & 7 == 1) goto cyjj; else goto cyjk;
       cyjj: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyjk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyju; else goto cyjt;
       cyju: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyjt: // global
           _sxu4::P64 = P64[R1 + 6];
           _sxu5::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sxu7_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sxu5::P64;
           _sxtZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cyjr_info;
           R2 = _sxu4::P64;
           R1 = _sxtZ::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyjr() //  [R1]
         { info_tbl: [(cyjr,
                       label: block_cyjr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyjr: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.concatMap_entry() //  [R2, R3]
         { info_tbl: [(cyjA,
                       label: GHC.List.concatMap_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyjA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cyjE; else goto cyjD;
       cyjE: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.concatMap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyjD: // global
           I64[Hp - 8] = go2_sxu1_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_sxu1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.393039612 UTC

[section ""data" . GHC.List.lookup_closure" {
     GHC.List.lookup_closure:
         const GHC.List.lookup_info;
 },
 GHC.List.lookup_entry() //  [R2, R3, R4]
         { info_tbl: [(cyki,
                       label: GHC.List.lookup_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyki: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cykj; else goto uykM;
       cykj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lookup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uykM: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cyk8() args: 0, res: 0, upd: 0;
     }
 },
 _cyk8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyk8: // global
           I64[Sp - 8] = block_cykb_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uykO; else goto cykc;
       uykO: // global
           call _cykb(R1) args: 0, res: 0, upd: 0;
       cykc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cykb() //  [R1]
         { info_tbl: [(cykb,
                       label: block_cykb_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cykb: // global
           if (R1 & 7 == 1) goto cykf; else goto cykg;
       cykf: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cykg: // global
           I64[Sp] = block_cykq_info;
           _sxud::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sxud::P64;
           if (R1 & 7 != 0) goto uykP; else goto cyks;
       uykP: // global
           call _cykq(R1) args: 0, res: 0, upd: 0;
       cyks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cykq() //  [R1]
         { info_tbl: [(cykq,
                       label: block_cykq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cykq: // global
           I64[Sp - 8] = block_cykw_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cykw() //  [R1]
         { info_tbl: [(cykw,
                       label: block_cykw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cykw: // global
           if (R1 & 7 == 1) goto cykD; else goto cykH;
       cykD: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 16;
           call _cyk8() args: 0, res: 0, upd: 0;
       cykH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cykK; else goto cykJ;
       cykK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cykJ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.404511153 UTC

[section ""data" . GHC.List.notElem_closure" {
     GHC.List.notElem_closure:
         const GHC.List.notElem_info;
 },
 GHC.List.notElem_entry() //  [R2, R3, R4]
         { info_tbl: [(cylE,
                       label: GHC.List.notElem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cylE: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cylF; else goto uylZ;
       cylF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.notElem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uylZ: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cylu() args: 0, res: 0, upd: 0;
     }
 },
 _cylu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cylu: // global
           I64[Sp - 8] = block_cylx_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uym1; else goto cyly;
       uym1: // global
           call _cylx(R1) args: 0, res: 0, upd: 0;
       cyly: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cylx() //  [R1]
         { info_tbl: [(cylx,
                       label: block_cylx_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cylx: // global
           if (R1 & 7 == 1) goto cylB; else goto cylC;
       cylB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cylC: // global
           I64[Sp] = block_cylM_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes./=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cylM() //  [R1]
         { info_tbl: [(cylM,
                       label: block_cylM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cylM: // global
           if (R1 & 7 == 1) goto cylT; else goto cylX;
       cylT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cylX: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cylu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.415474207 UTC

[section ""data" . GHC.List.elem_closure" {
     GHC.List.elem_closure:
         const GHC.List.elem_info;
 },
 GHC.List.elem_entry() //  [R2, R3, R4]
         { info_tbl: [(cymK,
                       label: GHC.List.elem_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cymK: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cymL; else goto uyn5;
       cymL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.elem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uyn5: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cymA() args: 0, res: 0, upd: 0;
     }
 },
 _cymA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cymA: // global
           I64[Sp - 8] = block_cymD_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyn7; else goto cymE;
       uyn7: // global
           call _cymD(R1) args: 0, res: 0, upd: 0;
       cymE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cymD() //  [R1]
         { info_tbl: [(cymD,
                       label: block_cymD_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cymD: // global
           if (R1 & 7 == 1) goto cymH; else goto cymI;
       cymH: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cymI: // global
           I64[Sp] = block_cymS_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cymS() //  [R1]
         { info_tbl: [(cymS,
                       label: block_cymS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cymS: // global
           if (R1 & 7 == 1) goto cymZ; else goto cyn3;
       cymZ: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cymA() args: 0, res: 0, upd: 0;
       cyn3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.424791411 UTC

[section ""data" . GHC.List.all_closure" {
     GHC.List.all_closure:
         const GHC.List.all_info;
 },
 GHC.List.all_entry() //  [R2, R3]
         { info_tbl: [(cynQ,
                       label: GHC.List.all_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cynQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cynR; else goto uyob;
       cynR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.all_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uyob: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cynG() args: 0, res: 0, upd: 0;
     }
 },
 _cynG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cynG: // global
           I64[Sp - 8] = block_cynJ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyod; else goto cynK;
       uyod: // global
           call _cynJ(R1) args: 0, res: 0, upd: 0;
       cynK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cynJ() //  [R1]
         { info_tbl: [(cynJ,
                       label: block_cynJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cynJ: // global
           if (R1 & 7 == 1) goto cynN; else goto cynO;
       cynN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cynO: // global
           I64[Sp] = block_cynY_info;
           R2 = P64[R1 + 6];
           _sxuA::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sxuA::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cynY() //  [R1]
         { info_tbl: [(cynY,
                       label: block_cynY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cynY: // global
           if (R1 & 7 == 1) goto cyo5; else goto cyo9;
       cyo5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyo9: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cynG() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.433768336 UTC

[section ""data" . GHC.List.any_closure" {
     GHC.List.any_closure:
         const GHC.List.any_info;
 },
 GHC.List.any_entry() //  [R2, R3]
         { info_tbl: [(cyoR,
                       label: GHC.List.any_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyoR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyoS; else goto uypc;
       cyoS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.any_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uypc: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cyoH() args: 0, res: 0, upd: 0;
     }
 },
 _cyoH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyoH: // global
           I64[Sp - 8] = block_cyoK_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uype; else goto cyoL;
       uype: // global
           call _cyoK(R1) args: 0, res: 0, upd: 0;
       cyoL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyoK() //  [R1]
         { info_tbl: [(cyoK,
                       label: block_cyoK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyoK: // global
           if (R1 & 7 == 1) goto cyoO; else goto cyoP;
       cyoO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyoP: // global
           I64[Sp] = block_cyoZ_info;
           R2 = P64[R1 + 6];
           _sxuG::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sxuG::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyoZ() //  [R1]
         { info_tbl: [(cyoZ,
                       label: block_cyoZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyoZ: // global
           if (R1 & 7 == 1) goto cyp6; else goto cypa;
       cyp6: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cyoH() args: 0, res: 0, upd: 0;
       cypa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.442690526 UTC

[section ""data" . GHC.List.or_closure" {
     GHC.List.or_closure:
         const GHC.List.or_info;
 },
 GHC.List.or_entry() //  [R2]
         { info_tbl: [(cypS,
                       label: GHC.List.or_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cypS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cypT; else goto uyqe;
       cypT: // global
           R2 = R2;
           R1 = GHC.List.or_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uyqe: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cypI() args: 0, res: 0, upd: 0;
     }
 },
 _cypI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cypI: // global
           _sxuI::P64 = P64[Sp];
           I64[Sp] = block_cypL_info;
           R1 = _sxuI::P64;
           if (R1 & 7 != 0) goto uyqg; else goto cypM;
       uyqg: // global
           call _cypL(R1) args: 0, res: 0, upd: 0;
       cypM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cypL() //  [R1]
         { info_tbl: [(cypL,
                       label: block_cypL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cypL: // global
           if (R1 & 7 == 1) goto cypP; else goto cypQ;
       cypP: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cypQ: // global
           I64[Sp - 8] = block_cyq0_info;
           _sxuL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxuL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyqh; else goto cyq2;
       uyqh: // global
           call _cyq0(R1) args: 0, res: 0, upd: 0;
       cyq2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyq0() //  [R1]
         { info_tbl: [(cyq0,
                       label: block_cyq0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyq0: // global
           if (R1 & 7 == 1) goto cyq8; else goto cyqc;
       cyq8: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cypI() args: 0, res: 0, upd: 0;
       cyqc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.452195275 UTC

[section ""data" . GHC.List.and_closure" {
     GHC.List.and_closure:
         const GHC.List.and_info;
 },
 GHC.List.and_entry() //  [R2]
         { info_tbl: [(cyqV,
                       label: GHC.List.and_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyqV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyqW; else goto uyrh;
       cyqW: // global
           R2 = R2;
           R1 = GHC.List.and_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uyrh: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cyqL() args: 0, res: 0, upd: 0;
     }
 },
 _cyqL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyqL: // global
           _sxuN::P64 = P64[Sp];
           I64[Sp] = block_cyqO_info;
           R1 = _sxuN::P64;
           if (R1 & 7 != 0) goto uyrj; else goto cyqP;
       uyrj: // global
           call _cyqO(R1) args: 0, res: 0, upd: 0;
       cyqP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyqO() //  [R1]
         { info_tbl: [(cyqO,
                       label: block_cyqO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyqO: // global
           if (R1 & 7 == 1) goto cyqS; else goto cyqT;
       cyqS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyqT: // global
           I64[Sp - 8] = block_cyr3_info;
           _sxuQ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxuQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyrk; else goto cyr5;
       uyrk: // global
           call _cyr3(R1) args: 0, res: 0, upd: 0;
       cyr5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyr3() //  [R1]
         { info_tbl: [(cyr3,
                       label: block_cyr3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyr3: // global
           if (R1 & 7 == 1) goto cyrb; else goto cyrf;
       cyrb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyrf: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cyqL() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.461074252 UTC

[section ""data" . GHC.List.reverse1_closure" {
     GHC.List.reverse1_closure:
         const GHC.List.reverse1_info;
 },
 GHC.List.reverse1_entry() //  [R2, R3]
         { info_tbl: [(cys2,
                       label: GHC.List.reverse1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cys2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cys3; else goto uysa;
       cys3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.reverse1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uysa: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cyrO() args: 0, res: 0, upd: 0;
     }
 },
 _cyrO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyrO: // global
           _sxuS::P64 = P64[Sp];
           I64[Sp] = block_cyrR_info;
           R1 = _sxuS::P64;
           if (R1 & 7 != 0) goto uysc; else goto cyrS;
       uysc: // global
           call _cyrR(R1) args: 0, res: 0, upd: 0;
       cyrS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyrR() //  [R1]
         { info_tbl: [(cyrR,
                       label: block_cyrR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyrR: // global
           _sxuT::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cyrZ; else goto cys0;
       cyrZ: // global
           R1 = _sxuT::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cys0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cys9; else goto cys8;
       cys9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cys8: // global
           _sxuV::P64 = P64[R1 + 6];
           _sxuW::P64 = P64[R1 + 14];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxuV::P64;
           P64[Hp] = _sxuT::P64;
           P64[Sp] = _sxuW::P64;
           P64[Sp + 8] = Hp - 14;
           call _cyrO() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.469301489 UTC

[section ""data" . GHC.List.reverse_closure" {
     GHC.List.reverse_closure:
         const GHC.List.reverse_info;
 },
 GHC.List.reverse_entry() //  [R2]
         { info_tbl: [(cysB,
                       label: GHC.List.reverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cysB: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.473507692 UTC

[section ""data" . GHC.List.$wbreak_closure" {
     GHC.List.$wbreak_closure:
         const GHC.List.$wbreak_info;
 },
 ds_sxv5_entry() //  [R1]
         { info_tbl: [(cyt4,
                       label: ds_sxv5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyt4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyt5; else goto cyt6;
       cyt5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyt6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyt1_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cyt1() //  [R1, R2]
         { info_tbl: [(cyt1,
                       label: block_cyt1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyt1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyt9; else goto cyt8;
       cyt9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyt8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wbreak_entry() //  [R2, R3]
         { info_tbl: [(cyte,
                       label: GHC.List.$wbreak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyte: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cytf; else goto cytg;
       cytf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wbreak_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cytg: // global
           I64[Sp - 16] = block_cysN_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uytx; else goto cysO;
       uytx: // global
           call _cysN(R1) args: 0, res: 0, upd: 0;
       cysO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cysN() //  [R1]
         { info_tbl: [(cysN,
                       label: block_cysN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cysN: // global
           if (R1 & 7 == 1) goto cytb; else goto cytc;
       cytb: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cytc: // global
           I64[Sp - 24] = block_cysT_info;
           _sxv2::P64 = P64[R1 + 6];
           R2 = _sxv2::P64;
           _sxv1::P64 = R1;
           _sxv3::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sxv2::P64;
           P64[Sp - 8] = _sxv3::P64;
           P64[Sp] = _sxv1::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cysT() //  [R1]
         { info_tbl: [(cysT,
                       label: block_cysT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cysT: // global
           if (R1 & 7 == 1) goto cyto; else goto cytv;
       cyto: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cytr; else goto cytq;
       cytr: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cytq: // global
           I64[Hp - 96] = ds_sxv5_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cysX::P64 = Hp - 96;
           P64[Hp - 48] = _cysX::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cysX::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cytv: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.486639025 UTC

[section ""data" . GHC.List.break_closure" {
     GHC.List.break_closure:
         const GHC.List.break_info;
 },
 GHC.List.break_entry() //  [R2, R3]
         { info_tbl: [(cyum,
                       label: GHC.List.break_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyum: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyun; else goto cyuo;
       cyun: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.break_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyuo: // global
           I64[Sp - 8] = block_cyuj_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cyuj() //  [R1, R2]
         { info_tbl: [(cyuj,
                       label: block_cyuj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyuj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyur; else goto cyuq;
       cyur: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyuq: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.494013302 UTC

[section ""data" . GHC.List.$wspan_closure" {
     GHC.List.$wspan_closure:
         const GHC.List.$wspan_info;
 },
 ds_sxvt_entry() //  [R1]
         { info_tbl: [(cyuZ,
                       label: ds_sxvt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyuZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyv0; else goto cyv1;
       cyv0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyv1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyuW_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cyuW() //  [R1, R2]
         { info_tbl: [(cyuW,
                       label: block_cyuW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyuW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyv4; else goto cyv3;
       cyv4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyv3: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wspan_entry() //  [R2, R3]
         { info_tbl: [(cyv9,
                       label: GHC.List.$wspan_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyv9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cyva; else goto cyvb;
       cyva: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wspan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyvb: // global
           I64[Sp - 16] = block_cyuH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyvr; else goto cyuI;
       uyvr: // global
           call _cyuH(R1) args: 0, res: 0, upd: 0;
       cyuI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyuH() //  [R1]
         { info_tbl: [(cyuH,
                       label: block_cyuH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyuH: // global
           if (R1 & 7 == 1) goto cyv6; else goto cyv7;
       cyv6: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cyv7: // global
           I64[Sp - 24] = block_cyuN_info;
           _sxvq::P64 = P64[R1 + 6];
           R2 = _sxvq::P64;
           _sxvp::P64 = R1;
           _sxvr::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sxvq::P64;
           P64[Sp - 8] = _sxvr::P64;
           P64[Sp] = _sxvp::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyuN() //  [R1]
         { info_tbl: [(cyuN,
                       label: block_cyuN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyuN: // global
           if (R1 & 7 == 1) goto cyvi; else goto cyvm;
       cyvi: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cyvm: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cyvp; else goto cyvo;
       cyvp: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyvo: // global
           I64[Hp - 96] = ds_sxvt_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cyuS::P64 = Hp - 96;
           P64[Hp - 48] = _cyuS::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cyuS::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.506530952 UTC

[section ""data" . GHC.List.span_closure" {
     GHC.List.span_closure:
         const GHC.List.span_info;
 },
 GHC.List.span_entry() //  [R2, R3]
         { info_tbl: [(cywg,
                       label: GHC.List.span_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cywg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cywh; else goto cywi;
       cywh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.span_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cywi: // global
           I64[Sp - 8] = block_cywd_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cywd() //  [R1, R2]
         { info_tbl: [(cywd,
                       label: block_cywd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cywd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cywl; else goto cywk;
       cywl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cywk: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.513614462 UTC

[section ""data" . GHC.List.takeFB_closure" {
     GHC.List.takeFB_closure:
         const GHC.List.takeFB_info;
 },
 sat_sxvV_entry() //  [R1]
         { info_tbl: [(cywO,
                       label: sat_sxvV_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cywO: // global
           _sxvV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cywR; else goto cywS;
       cywS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cywU; else goto cywT;
       cywU: // global
           HpAlloc = 16;
           goto cywR;
       cywR: // global
           R1 = _sxvV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cywT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxvV::P64;
           _sxvO::P64 = P64[_sxvV::P64 + 16];
           _sxvT::I64 = I64[_sxvV::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sxvT::I64;
           R2 = Hp - 7;
           R1 = _sxvO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.takeFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cywV,
                       label: GHC.List.takeFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cywV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cywW; else goto cywX;
       cywW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cywX: // global
           I64[Sp - 40] = block_cywB_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uyx4; else goto cywC;
       uyx4: // global
           call _cywB(R1) args: 0, res: 0, upd: 0;
       cywC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cywB() //  [R1]
         { info_tbl: [(cywB,
                       label: block_cywB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cywB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyx0; else goto cywZ;
       cyx0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cywZ: // global
           _sxvL::P64 = P64[Sp + 8];
           _sxvN::P64 = P64[Sp + 24];
           _sxvS::I64 = I64[R1 + 7];
           if (_sxvS::I64 != 1) goto cyx2; else goto cyx3;
       cyx2: // global
           I64[Hp - 24] = sat_sxvV_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = _sxvS::I64;
           R3 = Hp - 24;
           R2 = _sxvN::P64;
           R1 = _sxvL::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyx3: // global
           Hp = Hp - 32;
           R3 = P64[Sp + 16];
           R2 = _sxvN::P64;
           R1 = _sxvL::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.522313278 UTC

[section ""data" . GHC.List.flipSeqTake_closure" {
     GHC.List.flipSeqTake_closure:
         const GHC.List.flipSeqTake_info;
 },
 GHC.List.flipSeqTake_entry() //  [R2, R3]
         { info_tbl: [(cyxv,
                       label: GHC.List.flipSeqTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyxv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyxw; else goto cyxx;
       cyxw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyxx: // global
           I64[Sp - 16] = block_cyxs_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyxB; else goto cyxt;
       uyxB: // global
           call _cyxs() args: 0, res: 0, upd: 0;
       cyxt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyxs() //  []
         { info_tbl: [(cyxs,
                       label: block_cyxs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyxs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.528385336 UTC

[section ""data" . GHC.List.$wunsafeTake_closure" {
     GHC.List.$wunsafeTake_closure:
         const GHC.List.$wunsafeTake_info;
 },
 sat_sxw7_entry() //  [R1]
         { info_tbl: [(cyy4,
                       label: sat_sxw7_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyy4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyy5; else goto cyy6;
       cyy5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyy6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24] - 1;
           Sp = Sp - 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wunsafeTake_entry() //  [R2, R3]
         { info_tbl: [(cyyb,
                       label: GHC.List.$wunsafeTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyyb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyyc; else goto cyyd;
       cyyc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wunsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyyd: // global
           I64[Sp - 16] = block_cyxQ_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyyp; else goto cyxR;
       uyyp: // global
           call _cyxQ(R1) args: 0, res: 0, upd: 0;
       cyxR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyxQ() //  [R1]
         { info_tbl: [(cyxQ,
                       label: block_cyxQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyxQ: // global
           if (R1 & 7 == 1) goto cyy8; else goto cyy9;
       cyy8: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyy9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cyyi; else goto cyyh;
       cyyi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyyh: // global
           _sxw3::P64 = P64[R1 + 6];
           _sxw5::I64 = I64[Sp + 8];
           if (_sxw5::I64 != 1) goto cyyl; else goto cyyo;
       cyyl: // global
           _sxw4::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sxw7_info;
           P64[Hp - 32] = _sxw4::P64;
           I64[Hp - 24] = _sxw5::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxw3::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyyo: // global
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = _sxw3::P64;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cyyn::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cyyn::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.538260296 UTC

[section ""data" . GHC.List.unsafeTake_closure" {
     GHC.List.unsafeTake_closure:
         const GHC.List.unsafeTake_info;
 },
 GHC.List.unsafeTake_entry() //  [R2, R3]
         { info_tbl: [(cyyZ,
                       label: GHC.List.unsafeTake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyyZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyz0; else goto cyz1;
       cyz0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.unsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyz1: // global
           I64[Sp - 16] = block_cyyW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyz5; else goto cyyX;
       uyz5: // global
           call _cyyW(R1) args: 0, res: 0, upd: 0;
       cyyX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyyW() //  [R1]
         { info_tbl: [(cyyW,
                       label: block_cyyW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyyW: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.543988358 UTC

[section ""data" . GHC.List.take_closure" {
     GHC.List.take_closure:
         const GHC.List.take_info;
 },
 GHC.List.take_entry() //  [R2, R3]
         { info_tbl: [(cyzn,
                       label: GHC.List.take_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyzn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyzo; else goto cyzp;
       cyzo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.take_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyzp: // global
           I64[Sp - 16] = block_cyzk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyzy; else goto cyzl;
       uyzy: // global
           call _cyzk(R1) args: 0, res: 0, upd: 0;
       cyzl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyzk() //  [R1]
         { info_tbl: [(cyzk,
                       label: block_cyzk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyzk: // global
           _sxwf::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _sxwf::I64)) goto cyzw; else goto cyzx;
       cyzw: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyzx: // global
           R3 = P64[Sp + 8];
           R2 = _sxwf::I64;
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.550873253 UTC

[section ""data" . GHC.List.dropWhile_closure" {
     GHC.List.dropWhile_closure:
         const GHC.List.dropWhile_info;
 },
 GHC.List.dropWhile_entry() //  [R2, R3]
         { info_tbl: [(cyzW,
                       label: GHC.List.dropWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyzW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyzX; else goto uyAh;
       cyzX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.dropWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uyAh: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cyzM() args: 0, res: 0, upd: 0;
     }
 },
 _cyzM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyzM: // global
           I64[Sp - 8] = block_cyzP_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyAj; else goto cyzQ;
       uyAj: // global
           call _cyzP(R1) args: 0, res: 0, upd: 0;
       cyzQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyzP() //  [R1]
         { info_tbl: [(cyzP,
                       label: block_cyzP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyzP: // global
           if (R1 & 7 == 1) goto cyzT; else goto cyzU;
       cyzT: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyzU: // global
           I64[Sp - 8] = block_cyA4_info;
           R2 = P64[R1 + 6];
           _sxwj::P64 = R1;
           _sxwl::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sxwl::P64;
           P64[Sp + 16] = _sxwj::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyA4() //  [R1]
         { info_tbl: [(cyA4,
                       label: block_cyA4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyA4: // global
           if (R1 & 7 == 1) goto cyAb; else goto cyAf;
       cyAb: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cyAf: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cyzM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.559674444 UTC

[section ""data" . GHC.List.takeWhileFB_closure" {
     GHC.List.takeWhileFB_closure:
         const GHC.List.takeWhileFB_info;
 },
 GHC.List.takeWhileFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cyAW,
                       label: GHC.List.takeWhileFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyAW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cyAX; else goto cyAY;
       cyAX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhileFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyAY: // global
           I64[Sp - 40] = block_cyAQ_info;
           _sxwn::P64 = R2;
           R2 = R5;
           R1 = _sxwn::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyAQ() //  [R1]
         { info_tbl: [(cyAQ,
                       label: block_cyAQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyAQ: // global
           if (R1 & 7 == 1) goto cyAT; else goto cyAU;
       cyAT: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyAU: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.56618496 UTC

[section ""data" . GHC.List.takeWhile_closure" {
     GHC.List.takeWhile_closure:
         const GHC.List.takeWhile_info;
 },
 sat_sxwz_entry() //  [R1]
         { info_tbl: [(cyBz,
                       label: sat_sxwz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyBz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyBA; else goto cyBB;
       cyBA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyBB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.takeWhile_entry() //  [R2, R3]
         { info_tbl: [(cyBG,
                       label: GHC.List.takeWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyBG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyBH; else goto cyBI;
       cyBH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyBI: // global
           I64[Sp - 16] = block_cyBk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyC0; else goto cyBl;
       uyC0: // global
           call _cyBk(R1) args: 0, res: 0, upd: 0;
       cyBl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyBk() //  [R1]
         { info_tbl: [(cyBk,
                       label: block_cyBk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyBk: // global
           if (R1 & 7 == 1) goto uyBW; else goto cyBE;
       uyBW: // global
           Sp = Sp + 16;
           call _cyBP() args: 0, res: 0, upd: 0;
       cyBE: // global
           I64[Sp - 16] = block_cyBq_info;
           _sxww::P64 = P64[R1 + 6];
           R2 = _sxww::P64;
           _sxwx::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _sxwx::P64;
           P64[Sp] = _sxww::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyBq() //  [R1]
         { info_tbl: [(cyBq,
                       label: block_cyBq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyBq: // global
           if (R1 & 7 == 1) goto uyBX; else goto cyBR;
       uyBX: // global
           Sp = Sp + 32;
           call _cyBP() args: 0, res: 0, upd: 0;
       cyBR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cyBU; else goto cyBT;
       cyBU: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyBT: // global
           I64[Hp - 48] = sat_sxwz_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cyBP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyBP: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.577832845 UTC

[section ""data" . GHC.List.repeat_closure" {
     GHC.List.repeat_closure:
         const GHC.List.repeat_info;
 },
 GHC.List.repeat_entry() //  [R2]
         { info_tbl: [(cyCE,
                       label: GHC.List.repeat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyCE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyCI; else goto cyCH;
       cyCI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.List.repeat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyCH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           _cyCD::P64 = Hp - 14;
           P64[Hp] = _cyCD::P64;
           R1 = _cyCD::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.repeatFB_closure" {
     GHC.List.repeatFB_closure:
         const GHC.List.repeatFB_info;
 },
 GHC.List.repeatFB_entry() //  [R2, R3]
         { info_tbl: [(cyCO,
                       label: GHC.List.repeatFB_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyCO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyCS; else goto cyCR;
       cyCS: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.repeatFB_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyCR: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           _cyCN::P64 = Hp - 32;
           P64[Hp] = _cyCN::P64;
           R1 = _cyCN::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.585478336 UTC

[section ""data" . GHC.List.replicate_closure" {
     GHC.List.replicate_closure:
         const GHC.List.replicate_info;
 },
 sat_sxwP_entry() //  [R1]
         { info_tbl: [(cyDv,
                       label: sat_sxwP_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyDv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyDw; else goto cyDx;
       cyDw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyDx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sxwL_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_sxwL_entry() //  [R1, R2]
         { info_tbl: [(cyDB,
                       label: $wxs_sxwL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyDB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cyDF; else goto cyDE;
       cyDF: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyDE: // global
           if (R2 == 1) goto cyDA; else goto cyDz;
       cyDA: // global
           _sxwK::P64 = P64[R1 + 15];
           Hp = Hp - 56;
           R1 = _sxwK::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyDz: // global
           _sxwG::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sxwP_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxwG::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.replicate_entry() //  [R2, R3]
         { info_tbl: [(cyDH,
                       label: GHC.List.replicate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyDH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyDI; else goto cyDJ;
       cyDI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.replicate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyDJ: // global
           I64[Sp - 16] = block_cyD8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyDQ; else goto cyD9;
       uyDQ: // global
           call _cyD8(R1) args: 0, res: 0, upd: 0;
       cyD9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyD8() //  [R1]
         { info_tbl: [(cyD8,
                       label: block_cyD8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyD8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cyDM; else goto cyDL;
       cyDM: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyDL: // global
           _sxwI::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _sxwI::I64)) goto cyDO; else goto cyDP;
       cyDO: // global
           Hp = Hp - 48;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyDP: // global
           I64[Hp - 40] = :_con_info;
           _sxwG::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sxwG::P64;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = $wxs_sxwL_info;
           P64[Hp - 8] = _sxwG::P64;
           P64[Hp] = Hp - 38;
           R2 = _sxwI::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call $wxs_sxwL_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.596218134 UTC

[section ""data" . GHC.List.$witerate'_closure" {
     GHC.List.$witerate'_closure:
         const GHC.List.$witerate'_info;
 },
 sat_sxwW_entry() //  [R1]
         { info_tbl: [(cyEz,
                       label: sat_sxwW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyEz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyEA; else goto cyEB;
       cyEA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyEB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyEw_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cyEw() //  [R1, R2]
         { info_tbl: [(cyEw,
                       label: block_cyEw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyEw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyEE; else goto cyED;
       cyEE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyED: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$witerate'_entry() //  [R2, R3]
         { info_tbl: [(cyEF,
                       label: GHC.List.$witerate'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyEF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyEG; else goto cyEH;
       cyEG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyEH: // global
           I64[Sp - 24] = block_cyEq_info;
           _sxwQ::P64 = R2;
           R2 = R3;
           R1 = _sxwQ::P64;
           P64[Sp - 16] = _sxwQ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyEq() //  [R1]
         { info_tbl: [(cyEq,
                       label: block_cyEq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyEq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyEK; else goto cyEJ;
       cyEK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyEJ: // global
           I64[Hp - 24] = sat_sxwW_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = Hp - 24;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.607321689 UTC

[section ""data" . GHC.List.iterate'FB_closure" {
     GHC.List.iterate'FB_closure:
         const GHC.List.iterate'FB_info;
 },
 go2_sxx0_entry() //  [R1, R2]
         { info_tbl: [(cyFk,
                       label: go2_sxx0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyFk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyFl; else goto cyFm;
       cyFl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyFm: // global
           I64[Sp - 32] = block_cyFh_info;
           _sxx1::P64 = R2;
           R2 = R2;
           _sxx0::P64 = R1;
           _sxwX::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 24] = _sxwX::P64;
           P64[Sp - 16] = _sxx0::P64;
           P64[Sp - 8] = _sxx1::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyFh() //  [R1]
         { info_tbl: [(cyFh,
                       label: block_cyFh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyFh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyFp; else goto cyFo;
       cyFp: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyFo: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.iterate'FB_entry() //  [R2, R3, R4]
         { info_tbl: [(cyFq,
                       label: GHC.List.iterate'FB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyFq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyFu; else goto cyFt;
       cyFu: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'FB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyFt: // global
           I64[Hp - 16] = go2_sxx0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_sxx0_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.iterate'_closure" {
     GHC.List.iterate'_closure:
         const GHC.List.iterate'_info;
 },
 GHC.List.iterate'_entry() //  [R2, R3]
         { info_tbl: [(cyFC,
                       label: GHC.List.iterate'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyFC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyFD; else goto cyFE;
       cyFD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyFE: // global
           I64[Sp - 8] = block_cyFz_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cyFz() //  [R1, R2]
         { info_tbl: [(cyFz,
                       label: block_cyFz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyFz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyFH; else goto cyFG;
       cyFH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyFG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.620372278 UTC

[section ""data" . GHC.List.$witerate_closure" {
     GHC.List.$witerate_closure:
         const GHC.List.$witerate_info;
 },
 sat_sxxf_entry() //  [R1]
         { info_tbl: [(cyGk,
                       label: sat_sxxf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyGk: // global
           _sxxf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cyGl; else goto cyGm;
       cyGm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyGo; else goto cyGn;
       cyGo: // global
           HpAlloc = 32;
           goto cyGl;
       cyGl: // global
           R1 = _sxxf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyGn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxxf::P64;
           _sxx9::P64 = P64[_sxxf::P64 + 16];
           _sxxa::P64 = P64[_sxxf::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sxx9::P64;
           P64[Hp] = _sxxa::P64;
           I64[Sp - 24] = block_cyGh_info;
           R3 = Hp - 24;
           R2 = _sxx9::P64;
           Sp = Sp - 24;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cyGh() //  [R1, R2]
         { info_tbl: [(cyGh,
                       label: block_cyGh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyGh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyGr; else goto cyGq;
       cyGr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyGq: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$witerate_entry() //  [R2, R3]
         { info_tbl: [(cyGs,
                       label: GHC.List.$witerate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyGs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyGw; else goto cyGv;
       cyGw: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyGv: // global
           I64[Hp - 24] = sat_sxxf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.629012664 UTC

[section ""data" . GHC.List.iterateFB_closure" {
     GHC.List.iterateFB_closure:
         const GHC.List.iterateFB_info;
 },
 sat_sxxm_entry() //  [R1]
         { info_tbl: [(cyH3,
                       label: sat_sxxm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyH3: // global
           _sxxm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cyH4; else goto cyH5;
       cyH5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyH7; else goto cyH6;
       cyH7: // global
           HpAlloc = 32;
           goto cyH4;
       cyH4: // global
           R1 = _sxxm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyH6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxxm::P64;
           _sxxh::P64 = P64[_sxxm::P64 + 16];
           _sxxj::P64 = P64[_sxxm::P64 + 24];
           _sxxk::P64 = P64[_sxxm::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sxxh::P64;
           P64[Hp] = _sxxk::P64;
           R2 = Hp - 24;
           R1 = _sxxj::P64;
           Sp = Sp - 16;
           call go2_sxxj_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go2_sxxj_entry() //  [R1, R2]
         { info_tbl: [(cyH8,
                       label: go2_sxxj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyH8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyHc; else goto cyHb;
       cyHc: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyHb: // global
           _sxxg::P64 = P64[R1 + 7];
           _sxxh::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sxxm_info;
           P64[Hp - 16] = _sxxh::P64;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = R2;
           R1 = _sxxg::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.iterateFB_entry() //  [R2, R3, R4]
         { info_tbl: [(cyHd,
                       label: GHC.List.iterateFB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyHd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyHh; else goto cyHg;
       cyHh: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterateFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyHg: // global
           I64[Hp - 16] = go2_sxxj_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_sxxj_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.iterate_closure" {
     GHC.List.iterate_closure:
         const GHC.List.iterate_info;
 },
 GHC.List.iterate_entry() //  [R2, R3]
         { info_tbl: [(cyHp,
                       label: GHC.List.iterate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyHp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyHq; else goto cyHr;
       cyHq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyHr: // global
           I64[Sp - 8] = block_cyHm_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cyHm() //  [R1, R2]
         { info_tbl: [(cyHm,
                       label: block_cyHm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyHm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyHu; else goto cyHt;
       cyHu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyHt: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.642143524 UTC

[section ""cstring" . lvl27_ru9o_bytes" {
     lvl27_ru9o_bytes:
         I8[] [71,72,67,47,76,105,115,116,46,104,115,58,52,49,49,58,51,52,45,53,53,124,113,115,64,40,113,32,58,32,95,41]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.644056152 UTC

[section ""data" . lvl28_ru9p_closure" {
     lvl28_ru9p_closure:
         const lvl28_ru9p_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_ru9p_entry() //  [R1]
         { info_tbl: [(cyI2,
                       label: lvl28_ru9p_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyI2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyI3; else goto cyI4;
       cyI3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyI4: // global
           (_cyHZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cyHZ::I64 == 0) goto cyI1; else goto cyI0;
       cyI1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cyI0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cyHZ::I64;
           R2 = lvl27_ru9o_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.649214687 UTC

[section ""data" . GHC.List.scanr1_closure" {
     GHC.List.scanr1_closure:
         const GHC.List.scanr1_info;
         const 0;
 },
 ds3_sxxA_entry() //  [R1]
         { info_tbl: [(cyID,
                       label: ds3_sxxA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyID: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyIE; else goto cyIF;
       cyIE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyIF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyIx_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.scanr1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cyIx() //  [R1]
         { info_tbl: [(cyIx,
                       label: block_cyIx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyIx: // global
           if (R1 & 7 == 1) goto cyIA; else goto cyIB;
       cyIA: // global
           R1 = lvl28_ru9p_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cyIB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyIO; else goto cyIN;
       cyIO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cyIN: // global
           _sxxC::P64 = P64[R1 + 6];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sxxC::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sxxI_entry() //  [R1]
         { info_tbl: [(cyIV,
                       label: sat_sxxI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyIV: // global
           _sxxI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cyIW; else goto cyIX;
       cyIX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyIZ; else goto cyIY;
       cyIZ: // global
           HpAlloc = 24;
           goto cyIW;
       cyIW: // global
           R1 = _sxxI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyIY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxxI::P64;
           _sxxs::P64 = P64[_sxxI::P64 + 16];
           _sxxv::P64 = P64[_sxxI::P64 + 24];
           _sxxA::P64 = P64[_sxxI::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sxxA::P64;
           R3 = Hp - 16;
           R2 = _sxxv::P64;
           R1 = _sxxs::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.scanr1_entry() //  [R2, R3]
         { info_tbl: [(cyJ4,
                       label: GHC.List.scanr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyJ4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyJ5; else goto cyJ6;
       cyJ5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyJ6: // global
           I64[Sp - 16] = block_cyIh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyJo; else goto cyIi;
       uyJo: // global
           call _cyIh(R1) args: 0, res: 0, upd: 0;
       cyIi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyIh() //  [R1]
         { info_tbl: [(cyIh,
                       label: block_cyIh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyIh: // global
           if (R1 & 7 == 1) goto cyJ1; else goto cyJ2;
       cyJ1: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyJ2: // global
           I64[Sp - 8] = block_cyIn_info;
           _sxxv::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sxxv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyJn; else goto cyIo;
       uyJn: // global
           call _cyIn(R1) args: 0, res: 0, upd: 0;
       cyIo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyIn() //  [R1]
         { info_tbl: [(cyIn,
                       label: block_cyIn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyIn: // global
           _sxxv::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cyJd; else goto cyJi;
       cyJd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyJg; else goto cyJf;
       cyJg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyJf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxxv::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyJi: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cyJl; else goto cyJk;
       cyJl: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyJk: // global
           I64[Hp - 112] = ds3_sxxA_info;
           _sxxs::P64 = P64[Sp + 16];
           P64[Hp - 96] = _sxxs::P64;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = stg_sel_0_upd_info;
           _cyIt::P64 = Hp - 112;
           P64[Hp - 64] = _cyIt::P64;
           I64[Hp - 56] = sat_sxxI_info;
           P64[Hp - 40] = _sxxs::P64;
           P64[Hp - 32] = _sxxv::P64;
           P64[Hp - 24] = _cyIt::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.665899981 UTC

[section ""data" . GHC.List.scanrFB_closure" {
     GHC.List.scanrFB_closure:
         const GHC.List.scanrFB_info;
 },
 GHC.List.scanrFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cyKm,
                       label: GHC.List.scanrFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyKm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyKs; else goto cyKt;
       cyKs: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanrFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyKt: // global
           I64[Sp - 32] = block_cyKj_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uyKx; else goto cyKk;
       uyKx: // global
           call _cyKj(R1) args: 0, res: 0, upd: 0;
       cyKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyKj() //  [R1]
         { info_tbl: [(cyKj,
                       label: block_cyKj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyKj: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cyKw; else goto cyKv;
       cyKw: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyKv: // global
           _sxxS::P64 = P64[R1 + 7];
           _sxxT::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sxxS::P64;
           P64[Hp - 64] = _sxxT::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sxxS::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.673524367 UTC

[section ""data" . GHC.List.$wscanr_closure" {
     GHC.List.$wscanr_closure:
         const GHC.List.$wscanr_info;
 },
 ds_sxy2_entry() //  [R1]
         { info_tbl: [(cyL9,
                       label: ds_sxy2_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyL9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyLa; else goto cyLb;
       cyLa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyLb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyL5_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cyL5() //  [R1, R2]
         { info_tbl: [(cyL5,
                       label: block_cyL5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyL5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cyLe; else goto cyLd;
       cyLe: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyLd: // global
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sxyb_entry() //  [R1]
         { info_tbl: [(cyLl,
                       label: sat_sxyb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyLl: // global
           _sxyb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cyLm; else goto cyLn;
       cyLn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyLp; else goto cyLo;
       cyLp: // global
           HpAlloc = 24;
           goto cyLm;
       cyLm: // global
           R1 = _sxyb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyLo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxyb::P64;
           _sxxW::P64 = P64[_sxyb::P64 + 16];
           _sxy0::P64 = P64[_sxyb::P64 + 24];
           _sxy2::P64 = P64[_sxyb::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sxy2::P64;
           R3 = Hp - 16;
           R2 = _sxy0::P64;
           R1 = _sxxW::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanr_entry() //  [R2, R3, R4]
         { info_tbl: [(cyLu,
                       label: GHC.List.$wscanr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyLu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyLv; else goto cyLw;
       cyLv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyLw: // global
           I64[Sp - 24] = block_cyKV_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uyLC; else goto cyKW;
       uyLC: // global
           call _cyKV(R1) args: 0, res: 0, upd: 0;
       cyKW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyKV() //  [R1]
         { info_tbl: [(cyKV,
                       label: block_cyKV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyKV: // global
           _sxxX::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cyLr; else goto cyLs;
       cyLr: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _sxxX::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cyLs: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cyLB; else goto cyLA;
       cyLB: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyLA: // global
           _sxy0::P64 = P64[R1 + 6];
           _sxy1::P64 = P64[R1 + 14];
           I64[Hp - 96] = ds_sxy2_info;
           _sxxW::P64 = P64[Sp + 8];
           P64[Hp - 80] = _sxxW::P64;
           P64[Hp - 72] = _sxxX::P64;
           P64[Hp - 64] = _sxy1::P64;
           I64[Hp - 56] = stg_sel_0_upd_info;
           _cyL1::P64 = Hp - 96;
           P64[Hp - 40] = _cyL1::P64;
           I64[Hp - 32] = sat_sxyb_info;
           P64[Hp - 16] = _sxxW::P64;
           P64[Hp - 8] = _sxy0::P64;
           P64[Hp] = _cyL1::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.686558424 UTC

[section ""data" . GHC.List.strictUncurryScanr_closure" {
     GHC.List.strictUncurryScanr_closure:
         const GHC.List.strictUncurryScanr_info;
 },
 GHC.List.strictUncurryScanr_entry() //  [R2, R3]
         { info_tbl: [(cyMl,
                       label: GHC.List.strictUncurryScanr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyMl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyMm; else goto cyMn;
       cyMm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.strictUncurryScanr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyMn: // global
           I64[Sp - 16] = block_cyMi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyMr; else goto cyMj;
       uyMr: // global
           call _cyMi(R1) args: 0, res: 0, upd: 0;
       cyMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyMi() //  [R1]
         { info_tbl: [(cyMi,
                       label: block_cyMi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyMi: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.scanr_closure" {
     GHC.List.scanr_closure:
         const GHC.List.scanr_info;
 },
 GHC.List.scanr_entry() //  [R2, R3, R4]
         { info_tbl: [(cyMz,
                       label: GHC.List.scanr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyMz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyMA; else goto cyMB;
       cyMA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyMB: // global
           I64[Sp - 8] = block_cyMw_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cyMw() //  [R1, R2]
         { info_tbl: [(cyMw,
                       label: block_cyMw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyMw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyME; else goto cyMD;
       cyME: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyMD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.696587763 UTC

[section ""data" . GHC.List.flipSeqScanl'_closure" {
     GHC.List.flipSeqScanl'_closure:
         const GHC.List.flipSeqScanl'_info;
 },
 GHC.List.flipSeqScanl'_entry() //  [R2, R3]
         { info_tbl: [(cyN6,
                       label: GHC.List.flipSeqScanl'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyN6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyN7; else goto cyN8;
       cyN7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqScanl'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyN8: // global
           I64[Sp - 16] = block_cyN4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyN4() //  []
         { info_tbl: [(cyN4,
                       label: block_cyN4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyN4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.702752294 UTC

[section ""data" . GHC.List.scanlFB'_closure" {
     GHC.List.scanlFB'_closure:
         const GHC.List.scanlFB'_info;
 },
 GHC.List.scanlFB'_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cyNq,
                       label: GHC.List.scanlFB'_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyNq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyNr; else goto cyNs;
       cyNr: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyNs: // global
           I64[Sp - 24] = block_cyNn_info;
           _sxyv::P64 = R3;
           R3 = R4;
           _sxyu::P64 = R2;
           R2 = R6;
           R1 = _sxyu::P64;
           P64[Sp - 16] = _sxyv::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyNn() //  [R1]
         { info_tbl: [(cyNn,
                       label: block_cyNn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyNn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyNv; else goto cyNu;
       cyNv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyNu: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.709407857 UTC

[section ""data" . GHC.List.$wscanlGo'_closure" {
     GHC.List.$wscanlGo'_closure:
         const GHC.List.$wscanlGo'_info;
 },
 sat_sxyM_entry() //  [R1]
         { info_tbl: [(cyNY,
                       label: sat_sxyM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyNY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cyNZ; else goto cyO0;
       cyNZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyO0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cyNR_info;
           _sxyB::P64 = P64[R1 + 16];
           _sxyE::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sxyB::P64;
           P64[Sp - 24] = _sxyE::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uyOg; else goto cyNS;
       uyOg: // global
           call _cyNR(R1) args: 0, res: 0, upd: 0;
       cyNS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cyNR() //  [R1]
         { info_tbl: [(cyNR,
                       label: block_cyNR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyNR: // global
           if (R1 & 7 == 1) goto cyNV; else goto cyNW;
       cyNV: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cyNW: // global
           I64[Sp] = block_cyO6_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           _sxyH::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sxyH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cyO6() //  [R1]
         { info_tbl: [(cyO6,
                       label: block_cyO6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyO6: // global
           _sxyH::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cyO8_info;
           R4 = _sxyH::P64;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanlGo'_entry(R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 _cyO8() //  [R1, R2]
         { info_tbl: [(cyO8,
                       label: block_cyO8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyO8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyOf; else goto cyOe;
       cyOf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyOe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanlGo'_entry() //  [R2, R3, R4]
         { info_tbl: [(cyOh,
                       label: GHC.List.$wscanlGo'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyOh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyOi; else goto cyOj;
       cyOi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyOj: // global
           I64[Sp - 24] = block_cyNL_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyNL() //  [R1]
         { info_tbl: [(cyNL,
                       label: block_cyNL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyNL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyOm; else goto cyOl;
       cyOm: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyOl: // global
           I64[Hp - 32] = sat_sxyM_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = Hp - 32;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.722903087 UTC

[section ""data" . GHC.List.scanl'_scanlGo'_closure" {
     GHC.List.scanl'_scanlGo'_closure:
         const GHC.List.scanl'_scanlGo'_info;
 },
 GHC.List.scanl'_scanlGo'_entry() //  [R2, R3, R4]
         { info_tbl: [(cyP5,
                       label: GHC.List.scanl'_scanlGo'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyP5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyP6; else goto cyP7;
       cyP6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl'_scanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyP7: // global
           I64[Sp - 8] = block_cyP2_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo'_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cyP2() //  [R1, R2]
         { info_tbl: [(cyP2,
                       label: block_cyP2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyP2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyPa; else goto cyP9;
       cyPa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyP9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.728638322 UTC

[section ""data" . GHC.List.scanl'_closure" {
     GHC.List.scanl'_closure:
         const GHC.List.scanl'_info;
 },
 GHC.List.scanl'_entry() //  [R2, R3, R4]
         { info_tbl: [(cyPq,
                       label: GHC.List.scanl'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyPq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl'_scanlGo'_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.732643292 UTC

[section ""data" . GHC.List.constScanl_closure" {
     GHC.List.constScanl_closure:
         const GHC.List.constScanl_info;
 },
 GHC.List.constScanl_entry() //  [R2, R3]
         { info_tbl: [(cyPB,
                       label: GHC.List.constScanl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyPB: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.736253238 UTC

[section ""data" . GHC.List.scanlFB_closure" {
     GHC.List.scanlFB_closure:
         const GHC.List.scanlFB_info;
 },
 GHC.List.scanlFB_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cyPO,
                       label: GHC.List.scanlFB_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyPO: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cyPS; else goto cyPR;
       cyPS: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyPR: // global
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R6;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R5;
           _cyPM::P64 = Hp - 64;
           P64[Hp] = _cyPM::P64;
           _sxyU::P64 = R3;
           R3 = Hp - 24;
           R2 = _cyPM::P64;
           R1 = _sxyU::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.741018824 UTC

[section ""data" . GHC.List.$wscanlGo_closure" {
     GHC.List.$wscanlGo_closure:
         const GHC.List.$wscanlGo_info;
 },
 sat_sxza_entry() //  [R1]
         { info_tbl: [(cyQe,
                       label: sat_sxza_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyQe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cyQf; else goto cyQg;
       cyQf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyQg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cyQ7_info;
           _sxz0::P64 = P64[R1 + 16];
           _sxz1::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sxz0::P64;
           P64[Sp - 24] = _sxz1::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uyQw; else goto cyQ8;
       uyQw: // global
           call _cyQ7(R1) args: 0, res: 0, upd: 0;
       cyQ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cyQ7() //  [R1]
         { info_tbl: [(cyQ7,
                       label: block_cyQ7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyQ7: // global
           if (R1 & 7 == 1) goto cyQb; else goto cyQc;
       cyQb: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cyQc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyQs; else goto cyQr;
       cyQs: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cyQr: // global
           _sxz4::P64 = P64[R1 + 6];
           _sxz5::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           _sxz0::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sxz0::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sxz4::P64;
           I64[Sp + 16] = block_cyQn_info;
           R4 = _sxz5::P64;
           R3 = Hp - 32;
           R2 = _sxz0::P64;
           Sp = Sp + 16;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cyQn() //  [R1, R2]
         { info_tbl: [(cyQn,
                       label: block_cyQn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyQn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyQv; else goto cyQu;
       cyQv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyQu: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.$wscanlGo_entry() //  [R2, R3, R4]
         { info_tbl: [(cyQx,
                       label: GHC.List.$wscanlGo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyQx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyQB; else goto cyQA;
       cyQB: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyQA: // global
           I64[Hp - 32] = sat_sxza_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.751372175 UTC

[section ""data" . GHC.List.scanl_scanlGo_closure" {
     GHC.List.scanl_scanlGo_closure:
         const GHC.List.scanl_scanlGo_info;
 },
 GHC.List.scanl_scanlGo_entry() //  [R2, R3, R4]
         { info_tbl: [(cyRb,
                       label: GHC.List.scanl_scanlGo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyRb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyRc; else goto cyRd;
       cyRc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl_scanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyRd: // global
           I64[Sp - 8] = block_cyR8_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cyR8() //  [R1, R2]
         { info_tbl: [(cyR8,
                       label: block_cyR8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyR8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyRg; else goto cyRf;
       cyRg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyRf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.757121474 UTC

[section ""data" . GHC.List.scanl_closure" {
     GHC.List.scanl_closure:
         const GHC.List.scanl_info;
 },
 GHC.List.scanl_entry() //  [R2, R3, R4]
         { info_tbl: [(cyRw,
                       label: GHC.List.scanl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyRw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl_scanlGo_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.762156406 UTC

[section ""data" . GHC.List.scanl1_closure" {
     GHC.List.scanl1_closure:
         const GHC.List.scanl1_info;
 },
 sat_sxzp_entry() //  [R1]
         { info_tbl: [(cyRT,
                       label: sat_sxzp_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyRT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyRU; else goto cyRV;
       cyRU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyRV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyRR_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cyRR() //  [R2]
         { info_tbl: [(cyRR,
                       label: block_cyRR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyRR: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.scanl1_entry() //  [R2, R3]
         { info_tbl: [(cyS1,
                       label: GHC.List.scanl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyS1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyS2; else goto cyS3;
       cyS2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyS3: // global
           I64[Sp - 16] = block_cyRH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uySa; else goto cyRI;
       uySa: // global
           call _cyRH(R1) args: 0, res: 0, upd: 0;
       cyRI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyRH() //  [R1]
         { info_tbl: [(cyRH,
                       label: block_cyRH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyRH: // global
           if (R1 & 7 == 1) goto cyRY; else goto cyRZ;
       cyRY: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyRZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cyS9; else goto cyS8;
       cyS9: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyS8: // global
           _sxzk::P64 = P64[R1 + 6];
           _sxzl::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sxzp_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sxzk::P64;
           P64[Hp - 24] = _sxzl::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxzk::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.77275225 UTC

[section ""data" . GHC.List.foldl'_closure" {
     GHC.List.foldl'_closure:
         const GHC.List.foldl'_info;
 },
 GHC.List.foldl'_entry() //  [R2, R3, R4]
         { info_tbl: [(cySL,
                       label: GHC.List.foldl'_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cySL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cySM; else goto cySN;
       cySM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cySN: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cySP() args: 0, res: 0, upd: 0;
     }
 },
 _cySP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cySP: // global
           I64[Sp - 8] = block_cySR_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyTe; else goto cyST;
       uyTe: // global
           call _cySR(R1) args: 0, res: 0, upd: 0;
       cyST: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cySR() //  [R1]
         { info_tbl: [(cySR,
                       label: block_cySR_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cySR: // global
           _sxzv::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cySZ; else goto cyT6;
       cySZ: // global
           R1 = _sxzv::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyT6: // global
           I64[Sp] = block_cyT2_info;
           _sxzx::P64 = P64[R1 + 6];
           _sxzy::P64 = P64[R1 + 14];
           R1 = _sxzv::P64;
           P64[Sp + 16] = _sxzy::P64;
           P64[Sp + 24] = _sxzx::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyT2() //  [R1]
         { info_tbl: [(cyT2,
                       label: block_cyT2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyT2: // global
           I64[Sp] = block_cyT4_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           R1 = P64[Sp + 8];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyT4() //  [R1]
         { info_tbl: [(cyT4,
                       label: block_cyT4_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyT4: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cySP() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.783695512 UTC

[section ""data" . GHC.List.foldl1'_closure" {
     GHC.List.foldl1'_closure:
         const GHC.List.foldl1'_info;
         const 0;
 },
 GHC.List.foldl1'_entry() //  [R2, R3]
         { info_tbl: [(cyTO,
                       label: GHC.List.foldl1'_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyTO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyTP; else goto cyTQ;
       cyTP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyTQ: // global
           I64[Sp - 16] = block_cyTH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyTX; else goto cyTI;
       uyTX: // global
           call _cyTH(R1) args: 0, res: 0, upd: 0;
       cyTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyTH() //  [R1]
         { info_tbl: [(cyTH,
                       label: block_cyTH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyTH: // global
           if (R1 & 7 == 1) goto cyTL; else goto cyTM;
       cyTL: // global
           R1 = GHC.List.foldl1'1_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyTM: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl'_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.789588193 UTC

[section ""data" . sat_sxzG_closure" {
     sat_sxzG_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.791278542 UTC

[section ""data" . sat_sxzH_closure" {
     sat_sxzH_closure:
         const :_con_info;
         const sat_sxzG_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.793288804 UTC

[section ""data" . lvl29_ru9q_closure" {
     lvl29_ru9q_closure:
         const lvl29_ru9q_info;
         const 0;
         const 0;
         const 0;
 },
 lvl29_ru9q_entry() //  [R1]
         { info_tbl: [(cyUi,
                       label: lvl29_ru9q_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyUi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyUj; else goto cyUk;
       cyUj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyUk: // global
           (_cyUf::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cyUf::I64 == 0) goto cyUh; else goto cyUg;
       cyUh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cyUg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cyUf::I64;
           R3 = sat_sxzH_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.798463602 UTC

[section ""data" . lvl30_ru9r_closure" {
     lvl30_ru9r_closure:
         const lvl30_ru9r_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_ru9r_entry() //  [R1]
         { info_tbl: [(cyUA,
                       label: lvl30_ru9r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyUA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyUB; else goto cyUC;
       cyUB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyUC: // global
           (_cyUx::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cyUx::I64 == 0) goto cyUz; else goto cyUy;
       cyUz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cyUy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cyUx::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.803021847 UTC

[section ""data" . GHC.List.foldl_closure" {
     GHC.List.foldl_closure:
         const GHC.List.foldl_info;
 },
 GHC.List.foldl_entry() //  [R2, R3, R4]
         { info_tbl: [(cyV3,
                       label: GHC.List.foldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyV3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyV4; else goto cyV5;
       cyV4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyV5: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cyUU() args: 0, res: 0, upd: 0;
     }
 },
 _cyUU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyUU: // global
           I64[Sp - 8] = block_cyUW_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyVi; else goto cyUX;
       uyVi: // global
           call _cyUW(R1) args: 0, res: 0, upd: 0;
       cyUX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyUW() //  [R1]
         { info_tbl: [(cyUW,
                       label: block_cyUW_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyUW: // global
           _sxzN::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cyVa; else goto cyVb;
       cyVa: // global
           R1 = _sxzN::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyVb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyVe; else goto cyVd;
       cyVe: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyVd: // global
           _sxzP::P64 = P64[R1 + 6];
           _sxzQ::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sxzN::P64;
           P64[Hp] = _sxzP::P64;
           P64[Sp + 16] = _sxzQ::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call _cyUU() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.810465401 UTC

[section ""data" . GHC.List.sum_closure" {
     GHC.List.sum_closure:
         const GHC.List.sum_info;
         const 0;
 },
 sat_sxzU_entry() //  [R1]
         { info_tbl: [(cyVK,
                       label: sat_sxzU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyVK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyVL; else goto cyVM;
       cyVL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyVM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl30_ru9r_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sxzT_entry() //  [R1]
         { info_tbl: [(cyVR,
                       label: sat_sxzT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyVR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyVS; else goto cyVT;
       cyVS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyVT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.sum_entry() //  [R2]
         { info_tbl: [(cyVU,
                       label: GHC.List.sum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyVU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cyVY; else goto cyVX;
       cyVY: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.sum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyVX: // global
           I64[Hp - 40] = sat_sxzU_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sxzT_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.819266025 UTC

[section ""data" . GHC.List.product_closure" {
     GHC.List.product_closure:
         const GHC.List.product_info;
         const 0;
 },
 sat_sxzX_entry() //  [R1]
         { info_tbl: [(cyWp,
                       label: sat_sxzX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyWp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyWq; else goto cyWr;
       cyWq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyWr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl29_ru9q_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sxzW_entry() //  [R1]
         { info_tbl: [(cyWw,
                       label: sat_sxzW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyWw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyWx; else goto cyWy;
       cyWx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyWy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.product_entry() //  [R2]
         { info_tbl: [(cyWz,
                       label: GHC.List.product_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyWz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cyWD; else goto cyWC;
       cyWD: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.product_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyWC: // global
           I64[Hp - 40] = sat_sxzX_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sxzW_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.827341759 UTC

[section ""data" . GHC.List.foldl1_closure" {
     GHC.List.foldl1_closure:
         const GHC.List.foldl1_info;
         const 0;
 },
 GHC.List.foldl1_entry() //  [R2, R3]
         { info_tbl: [(cyX7,
                       label: GHC.List.foldl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyX7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyX8; else goto cyX9;
       cyX8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyX9: // global
           I64[Sp - 16] = block_cyX0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyXg; else goto cyX1;
       uyXg: // global
           call _cyX0(R1) args: 0, res: 0, upd: 0;
       cyX1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyX0() //  [R1]
         { info_tbl: [(cyX0,
                       label: block_cyX0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyX0: // global
           if (R1 & 7 == 1) goto cyX4; else goto cyX5;
       cyX4: // global
           R1 = GHC.List.foldl2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyX5: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.83391787 UTC

[section ""data" . GHC.List.filterFB_closure" {
     GHC.List.filterFB_closure:
         const GHC.List.filterFB_info;
 },
 GHC.List.filterFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cyXD,
                       label: GHC.List.filterFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyXD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyXE; else goto cyXF;
       cyXE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filterFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyXF: // global
           I64[Sp - 32] = block_cyXx_info;
           _sxA3::P64 = R2;
           R2 = R4;
           R1 = R3;
           P64[Sp - 24] = _sxA3::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyXx() //  [R1]
         { info_tbl: [(cyXx,
                       label: block_cyXx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyXx: // global
           _sxA6::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cyXA; else goto cyXB;
       cyXA: // global
           R1 = _sxA6::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyXB: // global
           R3 = _sxA6::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.840280139 UTC

[section ""data" . GHC.List.filter_closure" {
     GHC.List.filter_closure:
         const GHC.List.filter_info;
 },
 sat_sxAe_entry() //  [R1]
         { info_tbl: [(cyYg,
                       label: sat_sxAe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyYg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyYh; else goto cyYi;
       cyYh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyYi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.filter_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.List.filter_entry() //  [R2, R3]
         { info_tbl: [(cyYn,
                       label: GHC.List.filter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyYn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyYo; else goto uyYD;
       cyYo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filter_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uyYD: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cyXY() args: 0, res: 0, upd: 0;
     }
 },
 _cyXY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyXY: // global
           I64[Sp - 8] = block_cyY1_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyYF; else goto cyY2;
       uyYF: // global
           call _cyY1(R1) args: 0, res: 0, upd: 0;
       cyY2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyY1() //  [R1]
         { info_tbl: [(cyY1,
                       label: block_cyY1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyY1: // global
           if (R1 & 7 == 1) goto cyYk; else goto cyYl;
       cyYk: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyYl: // global
           I64[Sp - 8] = block_cyY7_info;
           _sxAb::P64 = P64[R1 + 6];
           R2 = _sxAb::P64;
           _sxAc::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sxAc::P64;
           P64[Sp + 16] = _sxAb::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyY7() //  [R1]
         { info_tbl: [(cyY7,
                       label: block_cyY7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyY7: // global
           _sxA8::P64 = P64[Sp + 16];
           _sxAc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cyYw; else goto cyYy;
       cyYw: // global
           P64[Sp + 16] = _sxA8::P64;
           P64[Sp + 24] = _sxAc::P64;
           Sp = Sp + 16;
           call _cyXY() args: 0, res: 0, upd: 0;
       cyYy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cyYB; else goto cyYA;
       cyYB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyYA: // global
           I64[Hp - 48] = sat_sxAe_info;
           P64[Hp - 32] = _sxA8::P64;
           P64[Hp - 24] = _sxAc::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.851024248 UTC

[section ""data" . GHC.List.idLength_closure" {
     GHC.List.idLength_closure:
         const GHC.List.idLength_info;
 },
 GHC.List.idLength_entry() //  [R2]
         { info_tbl: [(cyZi,
                       label: GHC.List.idLength_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyZi: // global
           R2 = R2;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.854554483 UTC

[section ""data" . GHC.List.lengthFB_closure" {
     GHC.List.lengthFB_closure:
         const GHC.List.lengthFB_info;
 },
 GHC.List.lengthFB_entry() //  [R2, R3, R4]
         { info_tbl: [(cyZw,
                       label: GHC.List.lengthFB_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyZw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyZD; else goto cyZE;
       cyZD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lengthFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyZE: // global
           I64[Sp - 16] = block_cyZt_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyZI; else goto cyZu;
       uyZI: // global
           call _cyZt(R1) args: 0, res: 0, upd: 0;
       cyZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyZt() //  [R1]
         { info_tbl: [(cyZt,
                       label: block_cyZt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyZt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cyZH; else goto cyZG;
       cyZH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyZG: // global
           _sxAk::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sxAk::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.861186245 UTC

[section ""data" . GHC.List.$wlenAcc_closure" {
     GHC.List.$wlenAcc_closure:
         const GHC.List.$wlenAcc_info;
 },
 GHC.List.$wlenAcc_entry() //  [R2, R3]
         { info_tbl: [(cz06,
                       label: GHC.List.$wlenAcc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cz06: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cz07; else goto uz0g;
       cz07: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wlenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uz0g: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cyZW() args: 0, res: 0, upd: 0;
     }
 },
 _cyZW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyZW: // global
           _sxAm::P64 = P64[Sp];
           I64[Sp] = block_cyZZ_info;
           R1 = _sxAm::P64;
           if (R1 & 7 != 0) goto uz0i; else goto cz00;
       uz0i: // global
           call _cyZZ(R1) args: 0, res: 0, upd: 0;
       cz00: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyZZ() //  [R1]
         { info_tbl: [(cyZZ,
                       label: block_cyZZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cyZZ: // global
           _sxAn::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cz03; else goto cz04;
       cz03: // global
           R1 = _sxAn::I64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cz04: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _sxAn::I64 + 1;
           call _cyZW() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.868996124 UTC

[section ""data" . GHC.List.lenAcc_closure" {
     GHC.List.lenAcc_closure:
         const GHC.List.lenAcc_info;
 },
 GHC.List.lenAcc_entry() //  [R2, R3]
         { info_tbl: [(cz0J,
                       label: GHC.List.lenAcc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cz0J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cz0R; else goto cz0S;
       cz0R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cz0S: // global
           I64[Sp - 16] = block_cz0G_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uz0X; else goto cz0H;
       uz0X: // global
           call _cz0G(R1) args: 0, res: 0, upd: 0;
       cz0H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cz0G() //  [R1]
         { info_tbl: [(cz0G,
                       label: block_cz0G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cz0G: // global
           _sxAs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cz0M_info;
           R3 = I64[R1 + 7];
           R2 = _sxAs::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cz0M() //  [R1]
         { info_tbl: [(cz0M,
                       label: block_cz0M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cz0M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cz0W; else goto cz0V;
       cz0W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cz0V: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.876203609 UTC

[section ""data" . GHC.List.length_closure" {
     GHC.List.length_closure:
         const GHC.List.length_info;
 },
 GHC.List.length_entry() //  [R2]
         { info_tbl: [(cz1k,
                       label: GHC.List.length_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cz1k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cz1o; else goto cz1p;
       cz1o: // global
           R2 = R2;
           R1 = GHC.List.length_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cz1p: // global
           I64[Sp - 8] = block_cz1i_info;
           R3 = 0;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cz1i() //  [R1]
         { info_tbl: [(cz1i,
                       label: block_cz1i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cz1i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cz1s; else goto cz1r;
       cz1s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cz1r: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.881882477 UTC

[section ""data" . GHC.List.null_closure" {
     GHC.List.null_closure:
         const GHC.List.null_info;
 },
 GHC.List.null_entry() //  [R2]
         { info_tbl: [(cz1P,
                       label: GHC.List.null_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cz1P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cz1Q; else goto cz1R;
       cz1Q: // global
           R2 = R2;
           R1 = GHC.List.null_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cz1R: // global
           I64[Sp - 8] = block_cz1I_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uz1Y; else goto cz1J;
       uz1Y: // global
           call _cz1I(R1) args: 0, res: 0, upd: 0;
       cz1J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cz1I() //  [R1]
         { info_tbl: [(cz1I,
                       label: block_cz1I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cz1I: // global
           if (R1 & 7 == 1) goto cz1M; else goto cz1N;
       cz1M: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cz1N: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.887716245 UTC

[section ""data" . GHC.List.uncons_closure" {
     GHC.List.uncons_closure:
         const GHC.List.uncons_info;
 },
 GHC.List.uncons_entry() //  [R2]
         { info_tbl: [(cz2q,
                       label: GHC.List.uncons_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cz2q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cz2r; else goto cz2s;
       cz2r: // global
           R2 = R2;
           R1 = GHC.List.uncons_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cz2s: // global
           I64[Sp - 8] = block_cz2j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uz2D; else goto cz2k;
       uz2D: // global
           call _cz2j(R1) args: 0, res: 0, upd: 0;
       cz2k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cz2j() //  [R1]
         { info_tbl: [(cz2j,
                       label: block_cz2j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cz2j: // global
           if (R1 & 7 == 1) goto cz2n; else goto cz2o;
       cz2n: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cz2o: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cz2C; else goto cz2B;
       cz2C: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cz2B: // global
           _sxAF::P64 = P64[R1 + 6];
           _sxAG::P64 = P64[R1 + 14];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = _sxAF::P64;
           P64[Hp - 16] = _sxAG::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:11.894276344 UTC

[section ""relreadonly" . SxGK_srt" {
     SxGK_srt:
         const lvl1_ru8R_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.List.errorEmptyList_closure;
         const GHC.List.prel_list_str_closure;
         const lvl3_ru8T_closure;
         const GHC.List.!!2_closure;
         const GHC.List.!!1_closure;
         const poly_exit_ru8U_closure;
         const poly_$wgo_ru8V_closure;
         const GHC.List.negIndex_closure;
         const GHC.List.!!_closure;
         const GHC.List.$w!!_closure;
         const lvl5_ru8X_closure;
         const GHC.List.cycle_closure;
         const GHC.List.cycle1_closure;
         const lvl7_ru8Z_closure;
         const lvl8_ru90_closure;
         const GHC.List.foldr1_closure;
         const lvl10_ru92_closure;
         const GHC.List.init_closure;
         const GHC.List.init2_closure;
         const lvl12_ru94_closure;
         const GHC.List.lastError_closure;
         const lvl14_ru97_closure;
         const GHC.List.tail_closure;
         const GHC.List.scanl2_closure;
         const lvl16_ru99_closure;
         const GHC.List.head_closure;
         const GHC.List.badHead_closure;
         const lvl18_ru9b_closure;
         const GHC.List.maximum_$smaximum_closure;
         const GHC.List.maximum1_closure;
         const lvl21_ru9e_closure;
         const GHC.List.minimum_$sminimum_closure;
         const GHC.List.minimum1_closure;
         const GHC.List.maximum_$smaximum1_closure;
         const GHC.List.maximum2_closure;
         const GHC.List.maximum_closure;
         const lvl19_ru9c_closure;
         const GHC.List.minimum_$sminimum1_closure;
         const GHC.List.minimum2_closure;
         const GHC.List.minimum_closure;
         const lvl22_ru9f_closure;
         const lvl24_ru9h_closure;
         const GHC.List.errorEmptyList_closure;
         const lvl26_ru9j_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.List.scanr1_closure;
         const lvl28_ru9p_closure;
         const GHC.List.foldl1'_closure;
         const GHC.List.foldl1'1_closure;
         const sat_sxzH_closure;
         const lvl30_ru9r_closure;
         const GHC.List.sum_closure;
         const lvl29_ru9q_closure;
         const GHC.List.product_closure;
         const GHC.List.foldl1_closure;
         const GHC.List.foldl2_closure;
 }]

