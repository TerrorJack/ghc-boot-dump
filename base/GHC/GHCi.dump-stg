
==================== Pre unarise: ====================
2018-03-16 15:55:01.755783673 UTC

GHC.GHCi.$p1GHCiSandboxIO
  :: forall (m :: * -> *).
     GHC.GHCi.GHCiSandboxIO m =>
     GHC.Base.Monad m
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_snRn]
        case v_snRn of {
          GHC.GHCi.C:GHCiSandboxIO v_snRp [Occ=Once] _ [Occ=Dead] -> v_snRp;
        };

GHC.GHCi.ghciStepIO
  :: forall (m :: * -> *).
     GHC.GHCi.GHCiSandboxIO m =>
     forall a. m a -> GHC.Types.IO a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_snRr]
        case v_snRr of {
          GHC.GHCi.C:GHCiSandboxIO _ [Occ=Dead] v_snRu [Occ=Once] -> v_snRu;
        };

GHC.GHCi.$fGHCiSandboxIOIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.GHCi.GHCiSandboxIO GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.GHCi.C:GHCiSandboxIO! [GHC.Base.$fMonadIO
                                             GHC.Base.id];

GHC.GHCi.$fFunctorNoIO1
  :: forall a b.
     a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S(SL)),1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_snRv x1_snRw s_snRx]
        case x1_snRw s_snRx of {
          (#,#) ipv_snRz [Occ=Once] _ [Occ=Dead] -> (#,#) [ipv_snRz x_snRv];
        };

GHC.GHCi.$fFunctorNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.GHCi.NoIO
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorIO2
                                       GHC.GHCi.$fFunctorNoIO1];

GHC.GHCi.$fApplicativeNoIO5
  :: forall a.
     a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a1_snRB s_snRC] (#,#) [s_snRC a1_snRB];

GHC.GHCi.$fGHCiSandboxIONoIO1
  :: forall a. GHC.GHCi.NoIO a -> GHC.GHCi.NoIO a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_snRD] ds_snRD;

GHC.GHCi.noio :: forall a. GHC.GHCi.NoIO a -> GHC.Types.IO a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.GHCi.$fGHCiSandboxIONoIO1 eta_B1;

GHC.GHCi.$fMonadNoIO1
  :: forall a b.
     GHC.GHCi.NoIO a
     -> (a -> GHC.GHCi.NoIO b)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [k_snRE f_snRF s_snRG]
        case k_snRE s_snRG of {
          (#,#) ipv_snRI [Occ=Once] ipv1_snRJ [Occ=Once] ->
              f_snRF ipv1_snRJ ipv_snRI;
        };

GHC.GHCi.$fApplicativeNoIO4
  :: forall b a.
     GHC.GHCi.NoIO (a -> b)
     -> GHC.GHCi.NoIO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_snRK m2_snRL s_snRM]
        case m1_snRK s_snRM of {
          (#,#) ipv_snRO [Occ=Once] ipv1_snRP [Occ=Once!] ->
              case m2_snRL ipv_snRO of {
                (#,#) ipv2_snRR [Occ=Once] ipv3_snRS [Occ=Once] ->
                    let {
                      sat_snRT [Occ=Once] :: b_anJB
                      [LclId] =
                          [ipv1_snRP ipv3_snRS] \u [] ipv1_snRP ipv3_snRS;
                    } in  (#,#) [ipv2_snRR sat_snRT];
              };
        };

GHC.GHCi.$fApplicativeNoIO2
  :: forall a b.
     GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [a1_snRU a2_snRV eta_snRW]
        case a1_snRU eta_snRW of {
          (#,#) ipv_snRY [Occ=Once] _ [Occ=Dead] -> a2_snRV ipv_snRY;
        };

GHC.GHCi.$fApplicativeNoIO3
  :: forall a b c.
     (a -> b -> c)
     -> GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f1_snS0 x_snS1 eta_snS2 eta1_snS3]
        case x_snS1 eta1_snS3 of {
          (#,#) ipv_snS5 [Occ=Once] ipv1_snS6 [Occ=Once] ->
              case eta_snS2 ipv_snS5 of {
                (#,#) ipv2_snS8 [Occ=Once] ipv3_snS9 [Occ=Once] ->
                    let {
                      sat_snSa [Occ=Once] :: c_anJZ
                      [LclId] =
                          [f1_snS0 ipv1_snS6 ipv3_snS9] \u [] f1_snS0 ipv1_snS6 ipv3_snS9;
                    } in  (#,#) [ipv2_snS8 sat_snSa];
              };
        };

GHC.GHCi.$fApplicativeNoIO1
  :: forall a b.
     GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_snSb eta_snSc eta1_snSd]
        case x_snSb eta1_snSd of {
          (#,#) ipv_snSf [Occ=Once] ipv1_snSg [Occ=Once] ->
              case eta_snSc ipv_snSf of {
                (#,#) ipv2_snSi [Occ=Once] _ [Occ=Dead] ->
                    (#,#) [ipv2_snSi ipv1_snSg];
              };
        };

GHC.GHCi.$fMonadNoIO_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.GHCi.NoIO a -> GHC.GHCi.NoIO b -> GHC.GHCi.NoIO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.GHCi.$fApplicativeNoIO2 eta_B3 eta_B2 eta_B1;

GHC.GHCi.$fApplicativeNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.GHCi.$fFunctorNoIO
                                           GHC.GHCi.$fApplicativeNoIO5
                                           GHC.GHCi.$fApplicativeNoIO4
                                           GHC.GHCi.$fApplicativeNoIO3
                                           GHC.GHCi.$fApplicativeNoIO2
                                           GHC.GHCi.$fApplicativeNoIO1];

lvl_rnRg :: forall a. [GHC.Types.Char] -> GHC.GHCi.NoIO a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_snSk] GHC.Err.errorWithoutStackTrace eta_snSk;

GHC.GHCi.$fMonadNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.GHCi.$fApplicativeNoIO
                                     GHC.GHCi.$fMonadNoIO1
                                     GHC.GHCi.$fMonadNoIO_$c>>
                                     GHC.GHCi.$fApplicativeNoIO5
                                     lvl_rnRg];

GHC.GHCi.$fGHCiSandboxIONoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.GHCi.GHCiSandboxIO GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.GHCi.C:GHCiSandboxIO! [GHC.GHCi.$fMonadNoIO
                                             GHC.GHCi.$fGHCiSandboxIONoIO1];

GHC.GHCi.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.GHCi.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$trModule4];

GHC.GHCi.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.GHCi"#;

GHC.GHCi.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$trModule2];

GHC.GHCi.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.GHCi.$trModule3
                                     GHC.GHCi.$trModule1];

$krep_rnRh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.GHCi.$tcGHCiSandboxIO1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rnRh];

$krep1_rnRi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_rnRj :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rnRi GHC.Types.[]];

$krep3_rnRk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcIO
                                              $krep2_rnRj];

GHC.GHCi.$tcGHCiSandboxIO3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHCiSandboxIO"#;

GHC.GHCi.$tcGHCiSandboxIO2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tcGHCiSandboxIO3];

GHC.GHCi.$tcGHCiSandboxIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6221156064250054927##
                                    4417322204787188560##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tcGHCiSandboxIO2
                                    0#
                                    GHC.GHCi.$tcGHCiSandboxIO1];

GHC.GHCi.$tcNoIO2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NoIO"#;

GHC.GHCi.$tcNoIO1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tcNoIO2];

GHC.GHCi.$tcNoIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10516839389931644691##
                                    13251969196347980517##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tcNoIO1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_rnRl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.GHCi.$tcNoIO
                                              $krep2_rnRj];

GHC.GHCi.$tc'NoIO1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rnRk $krep4_rnRl];

GHC.GHCi.$tc'NoIO3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'NoIO"#;

GHC.GHCi.$tc'NoIO2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tc'NoIO3];

GHC.GHCi.$tc'NoIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11198799526314248800##
                                    4496738896484332546##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tc'NoIO2
                                    1#
                                    GHC.GHCi.$tc'NoIO1];

GHC.GHCi.C:GHCiSandboxIO
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall a. m a -> GHC.Types.IO a) -> GHC.GHCi.GHCiSandboxIO m
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.GHCi.C:GHCiSandboxIO [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 15:55:01.7610672 UTC

GHC.GHCi.$p1GHCiSandboxIO
  :: forall (m :: * -> *).
     GHC.GHCi.GHCiSandboxIO m =>
     GHC.Base.Monad m
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_snRn]
        case v_snRn of {
          GHC.GHCi.C:GHCiSandboxIO v_snRp [Occ=Once] _ [Occ=Dead] -> v_snRp;
        };

GHC.GHCi.ghciStepIO
  :: forall (m :: * -> *).
     GHC.GHCi.GHCiSandboxIO m =>
     forall a. m a -> GHC.Types.IO a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_snRr]
        case v_snRr of {
          GHC.GHCi.C:GHCiSandboxIO _ [Occ=Dead] v_snRu [Occ=Once] -> v_snRu;
        };

GHC.GHCi.$fGHCiSandboxIOIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.GHCi.GHCiSandboxIO GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.GHCi.C:GHCiSandboxIO! [GHC.Base.$fMonadIO
                                             GHC.Base.id];

GHC.GHCi.$fFunctorNoIO1
  :: forall a b.
     a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S(SL)),1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_snRv x1_snRw void_0E]
        case x1_snRw GHC.Prim.void# of {
          Unit# _ [Occ=Dead] -> Unit# [x_snRv];
        };

GHC.GHCi.$fFunctorNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.GHCi.NoIO
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorIO2
                                       GHC.GHCi.$fFunctorNoIO1];

GHC.GHCi.$fApplicativeNoIO5
  :: forall a.
     a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a1_snRB void_0E] Unit# [a1_snRB];

GHC.GHCi.$fGHCiSandboxIONoIO1
  :: forall a. GHC.GHCi.NoIO a -> GHC.GHCi.NoIO a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_snRD] ds_snRD;

GHC.GHCi.noio :: forall a. GHC.GHCi.NoIO a -> GHC.Types.IO a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.GHCi.$fGHCiSandboxIONoIO1 eta_B1;

GHC.GHCi.$fMonadNoIO1
  :: forall a b.
     GHC.GHCi.NoIO a
     -> (a -> GHC.GHCi.NoIO b)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [k_snRE f_snRF void_0E]
        case k_snRE GHC.Prim.void# of {
          Unit# ipv1_snRJ [Occ=Once] -> f_snRF ipv1_snRJ GHC.Prim.void#;
        };

GHC.GHCi.$fApplicativeNoIO4
  :: forall b a.
     GHC.GHCi.NoIO (a -> b)
     -> GHC.GHCi.NoIO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_snRK m2_snRL void_0E]
        case m1_snRK GHC.Prim.void# of {
          Unit# ipv1_snRP [Occ=Once!] ->
              case m2_snRL GHC.Prim.void# of {
                Unit# ipv3_snRS [Occ=Once] ->
                    let {
                      sat_snRT [Occ=Once] :: b_anJB
                      [LclId] =
                          [ipv1_snRP ipv3_snRS] \u [] ipv1_snRP ipv3_snRS;
                    } in  Unit# [sat_snRT];
              };
        };

GHC.GHCi.$fApplicativeNoIO2
  :: forall a b.
     GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [a1_snRU a2_snRV void_0E]
        case a1_snRU GHC.Prim.void# of {
          Unit# _ [Occ=Dead] -> a2_snRV GHC.Prim.void#;
        };

GHC.GHCi.$fApplicativeNoIO3
  :: forall a b c.
     (a -> b -> c)
     -> GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f1_snS0 x_snS1 eta_snS2 void_0E]
        case x_snS1 GHC.Prim.void# of {
          Unit# ipv1_snS6 [Occ=Once] ->
              case eta_snS2 GHC.Prim.void# of {
                Unit# ipv3_snS9 [Occ=Once] ->
                    let {
                      sat_snSa [Occ=Once] :: c_anJZ
                      [LclId] =
                          [f1_snS0 ipv1_snS6 ipv3_snS9] \u [] f1_snS0 ipv1_snS6 ipv3_snS9;
                    } in  Unit# [sat_snSa];
              };
        };

GHC.GHCi.$fApplicativeNoIO1
  :: forall a b.
     GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_snSb eta_snSc void_0E]
        case x_snSb GHC.Prim.void# of {
          Unit# ipv1_snSg [Occ=Once] ->
              case eta_snSc GHC.Prim.void# of {
                Unit# _ [Occ=Dead] -> Unit# [ipv1_snSg];
              };
        };

GHC.GHCi.$fMonadNoIO_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.GHCi.NoIO a -> GHC.GHCi.NoIO b -> GHC.GHCi.NoIO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.GHCi.$fApplicativeNoIO2 eta_B3 eta_B2 GHC.Prim.void#;

GHC.GHCi.$fApplicativeNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.GHCi.$fFunctorNoIO
                                           GHC.GHCi.$fApplicativeNoIO5
                                           GHC.GHCi.$fApplicativeNoIO4
                                           GHC.GHCi.$fApplicativeNoIO3
                                           GHC.GHCi.$fApplicativeNoIO2
                                           GHC.GHCi.$fApplicativeNoIO1];

lvl_rnRg :: forall a. [GHC.Types.Char] -> GHC.GHCi.NoIO a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_snSk] GHC.Err.errorWithoutStackTrace eta_snSk;

GHC.GHCi.$fMonadNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.GHCi.$fApplicativeNoIO
                                     GHC.GHCi.$fMonadNoIO1
                                     GHC.GHCi.$fMonadNoIO_$c>>
                                     GHC.GHCi.$fApplicativeNoIO5
                                     lvl_rnRg];

GHC.GHCi.$fGHCiSandboxIONoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.GHCi.GHCiSandboxIO GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.GHCi.C:GHCiSandboxIO! [GHC.GHCi.$fMonadNoIO
                                             GHC.GHCi.$fGHCiSandboxIONoIO1];

GHC.GHCi.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.GHCi.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$trModule4];

GHC.GHCi.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.GHCi"#;

GHC.GHCi.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$trModule2];

GHC.GHCi.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.GHCi.$trModule3
                                     GHC.GHCi.$trModule1];

$krep_rnRh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.GHCi.$tcGHCiSandboxIO1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rnRh];

$krep1_rnRi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_rnRj :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rnRi GHC.Types.[]];

$krep3_rnRk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcIO
                                              $krep2_rnRj];

GHC.GHCi.$tcGHCiSandboxIO3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHCiSandboxIO"#;

GHC.GHCi.$tcGHCiSandboxIO2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tcGHCiSandboxIO3];

GHC.GHCi.$tcGHCiSandboxIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6221156064250054927##
                                    4417322204787188560##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tcGHCiSandboxIO2
                                    0#
                                    GHC.GHCi.$tcGHCiSandboxIO1];

GHC.GHCi.$tcNoIO2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NoIO"#;

GHC.GHCi.$tcNoIO1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tcNoIO2];

GHC.GHCi.$tcNoIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10516839389931644691##
                                    13251969196347980517##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tcNoIO1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_rnRl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.GHCi.$tcNoIO
                                              $krep2_rnRj];

GHC.GHCi.$tc'NoIO1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rnRk $krep4_rnRl];

GHC.GHCi.$tc'NoIO3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'NoIO"#;

GHC.GHCi.$tc'NoIO2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tc'NoIO3];

GHC.GHCi.$tc'NoIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11198799526314248800##
                                    4496738896484332546##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tc'NoIO2
                                    1#
                                    GHC.GHCi.$tc'NoIO1];

GHC.GHCi.C:GHCiSandboxIO
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall a. m a -> GHC.Types.IO a) -> GHC.GHCi.GHCiSandboxIO m
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.GHCi.C:GHCiSandboxIO [eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 15:55:02.138234291 UTC

GHC.GHCi.$p1GHCiSandboxIO
  :: forall (m :: * -> *).
     GHC.GHCi.GHCiSandboxIO m =>
     GHC.Base.Monad m
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_so1S]
        case v_so1S of {
          GHC.GHCi.C:GHCiSandboxIO v_so1U [Occ=Once] _ [Occ=Dead] -> v_so1U;
        };

GHC.GHCi.ghciStepIO
  :: forall (m :: * -> *).
     GHC.GHCi.GHCiSandboxIO m =>
     forall a. m a -> GHC.Types.IO a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_so1W]
        case v_so1W of {
          GHC.GHCi.C:GHCiSandboxIO _ [Occ=Dead] v_so1Z [Occ=Once] -> v_so1Z;
        };

GHC.GHCi.$fGHCiSandboxIOIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.GHCi.GHCiSandboxIO GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.GHCi.C:GHCiSandboxIO! [GHC.Base.$fMonadIO
                                             GHC.Base.id];

GHC.GHCi.$fFunctorNoIO1
  :: forall a b.
     a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S(SL)),1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_so20 x1_so21 s_so22]
        case x1_so21 s_so22 of {
          (#,#) ipv_so24 [Occ=Once] _ [Occ=Dead] -> (#,#) [ipv_so24 x_so20];
        };

GHC.GHCi.$fFunctorNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.GHCi.NoIO
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorIO2
                                       GHC.GHCi.$fFunctorNoIO1];

GHC.GHCi.$fApplicativeNoIO5
  :: forall a.
     a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a1_so26 s_so27] (#,#) [s_so27 a1_so26];

GHC.GHCi.$fGHCiSandboxIONoIO1
  :: forall a. GHC.GHCi.NoIO a -> GHC.GHCi.NoIO a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_so28] ds_so28;

GHC.GHCi.noio :: forall a. GHC.GHCi.NoIO a -> GHC.Types.IO a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.GHCi.$fGHCiSandboxIONoIO1 eta_B1;

GHC.GHCi.$fMonadNoIO1
  :: forall a b.
     GHC.GHCi.NoIO a
     -> (a -> GHC.GHCi.NoIO b)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [k_so29 f_so2a s_so2b]
        case k_so29 s_so2b of {
          (#,#) ipv_so2d [Occ=Once] ipv1_so2e [Occ=Once] ->
              f_so2a ipv1_so2e ipv_so2d;
        };

GHC.GHCi.$fApplicativeNoIO4
  :: forall b a.
     GHC.GHCi.NoIO (a -> b)
     -> GHC.GHCi.NoIO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_so2f m2_so2g s_so2h]
        case m1_so2f s_so2h of {
          (#,#) ipv_so2j [Occ=Once] ipv1_so2k [Occ=Once!] ->
              case m2_so2g ipv_so2j of {
                (#,#) ipv2_so2m [Occ=Once] ipv3_so2n [Occ=Once] ->
                    let {
                      sat_so2o [Occ=Once] :: b_anJB
                      [LclId] =
                          [ipv1_so2k ipv3_so2n] \u [] ipv1_so2k ipv3_so2n;
                    } in  (#,#) [ipv2_so2m sat_so2o];
              };
        };

GHC.GHCi.$fApplicativeNoIO2
  :: forall a b.
     GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [a1_so2p a2_so2q eta_so2r]
        case a1_so2p eta_so2r of {
          (#,#) ipv_so2t [Occ=Once] _ [Occ=Dead] -> a2_so2q ipv_so2t;
        };

GHC.GHCi.$fApplicativeNoIO3
  :: forall a b c.
     (a -> b -> c)
     -> GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f1_so2v x_so2w eta_so2x eta1_so2y]
        case x_so2w eta1_so2y of {
          (#,#) ipv_so2A [Occ=Once] ipv1_so2B [Occ=Once] ->
              case eta_so2x ipv_so2A of {
                (#,#) ipv2_so2D [Occ=Once] ipv3_so2E [Occ=Once] ->
                    let {
                      sat_so2F [Occ=Once] :: c_anJZ
                      [LclId] =
                          [f1_so2v ipv1_so2B ipv3_so2E] \u [] f1_so2v ipv1_so2B ipv3_so2E;
                    } in  (#,#) [ipv2_so2D sat_so2F];
              };
        };

GHC.GHCi.$fApplicativeNoIO1
  :: forall a b.
     GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_so2G eta_so2H eta1_so2I]
        case x_so2G eta1_so2I of {
          (#,#) ipv_so2K [Occ=Once] ipv1_so2L [Occ=Once] ->
              case eta_so2H ipv_so2K of {
                (#,#) ipv2_so2N [Occ=Once] _ [Occ=Dead] ->
                    (#,#) [ipv2_so2N ipv1_so2L];
              };
        };

GHC.GHCi.$fMonadNoIO_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.GHCi.NoIO a -> GHC.GHCi.NoIO b -> GHC.GHCi.NoIO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.GHCi.$fApplicativeNoIO2 eta_B3 eta_B2 eta_B1;

GHC.GHCi.$fApplicativeNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.GHCi.$fFunctorNoIO
                                           GHC.GHCi.$fApplicativeNoIO5
                                           GHC.GHCi.$fApplicativeNoIO4
                                           GHC.GHCi.$fApplicativeNoIO3
                                           GHC.GHCi.$fApplicativeNoIO2
                                           GHC.GHCi.$fApplicativeNoIO1];

lvl_rnRg :: forall a. [GHC.Types.Char] -> GHC.GHCi.NoIO a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_so2P] GHC.Err.errorWithoutStackTrace eta_so2P;

GHC.GHCi.$fMonadNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.GHCi.$fApplicativeNoIO
                                     GHC.GHCi.$fMonadNoIO1
                                     GHC.GHCi.$fMonadNoIO_$c>>
                                     GHC.GHCi.$fApplicativeNoIO5
                                     lvl_rnRg];

GHC.GHCi.$fGHCiSandboxIONoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.GHCi.GHCiSandboxIO GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.GHCi.C:GHCiSandboxIO! [GHC.GHCi.$fMonadNoIO
                                             GHC.GHCi.$fGHCiSandboxIONoIO1];

GHC.GHCi.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.GHCi.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$trModule4];

GHC.GHCi.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.GHCi"#;

GHC.GHCi.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$trModule2];

GHC.GHCi.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.GHCi.$trModule3
                                     GHC.GHCi.$trModule1];

$krep_rnRh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.GHCi.$tcGHCiSandboxIO1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rnRh];

$krep1_rnRi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_rnRj :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rnRi GHC.Types.[]];

$krep3_rnRk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcIO
                                              $krep2_rnRj];

GHC.GHCi.$tcGHCiSandboxIO3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHCiSandboxIO"#;

GHC.GHCi.$tcGHCiSandboxIO2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tcGHCiSandboxIO3];

GHC.GHCi.$tcGHCiSandboxIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6221156064250054927##
                                    4417322204787188560##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tcGHCiSandboxIO2
                                    0#
                                    GHC.GHCi.$tcGHCiSandboxIO1];

GHC.GHCi.$tcNoIO2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NoIO"#;

GHC.GHCi.$tcNoIO1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tcNoIO2];

GHC.GHCi.$tcNoIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10516839389931644691##
                                    13251969196347980517##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tcNoIO1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_rnRl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.GHCi.$tcNoIO
                                              $krep2_rnRj];

GHC.GHCi.$tc'NoIO1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rnRk $krep4_rnRl];

GHC.GHCi.$tc'NoIO3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'NoIO"#;

GHC.GHCi.$tc'NoIO2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tc'NoIO3];

GHC.GHCi.$tc'NoIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11198799526314248800##
                                    4496738896484332546##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tc'NoIO2
                                    1#
                                    GHC.GHCi.$tc'NoIO1];

GHC.GHCi.C:GHCiSandboxIO
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall a. m a -> GHC.Types.IO a) -> GHC.GHCi.GHCiSandboxIO m
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.GHCi.C:GHCiSandboxIO [eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 15:55:02.144342062 UTC

GHC.GHCi.$p1GHCiSandboxIO
  :: forall (m :: * -> *).
     GHC.GHCi.GHCiSandboxIO m =>
     GHC.Base.Monad m
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_so1S]
        case v_so1S of {
          GHC.GHCi.C:GHCiSandboxIO v_so1U [Occ=Once] _ [Occ=Dead] -> v_so1U;
        };

GHC.GHCi.ghciStepIO
  :: forall (m :: * -> *).
     GHC.GHCi.GHCiSandboxIO m =>
     forall a. m a -> GHC.Types.IO a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_so1W]
        case v_so1W of {
          GHC.GHCi.C:GHCiSandboxIO _ [Occ=Dead] v_so1Z [Occ=Once] -> v_so1Z;
        };

GHC.GHCi.$fGHCiSandboxIOIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.GHCi.GHCiSandboxIO GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.GHCi.C:GHCiSandboxIO! [GHC.Base.$fMonadIO
                                             GHC.Base.id];

GHC.GHCi.$fFunctorNoIO1
  :: forall a b.
     a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S(SL)),1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_so20 x1_so21 void_0E]
        case x1_so21 GHC.Prim.void# of {
          Unit# _ [Occ=Dead] -> Unit# [x_so20];
        };

GHC.GHCi.$fFunctorNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.GHCi.NoIO
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorIO2
                                       GHC.GHCi.$fFunctorNoIO1];

GHC.GHCi.$fApplicativeNoIO5
  :: forall a.
     a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a1_so26 void_0E] Unit# [a1_so26];

GHC.GHCi.$fGHCiSandboxIONoIO1
  :: forall a. GHC.GHCi.NoIO a -> GHC.GHCi.NoIO a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_so28] ds_so28;

GHC.GHCi.noio :: forall a. GHC.GHCi.NoIO a -> GHC.Types.IO a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.GHCi.$fGHCiSandboxIONoIO1 eta_B1;

GHC.GHCi.$fMonadNoIO1
  :: forall a b.
     GHC.GHCi.NoIO a
     -> (a -> GHC.GHCi.NoIO b)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [k_so29 f_so2a void_0E]
        case k_so29 GHC.Prim.void# of {
          Unit# ipv1_so2e [Occ=Once] -> f_so2a ipv1_so2e GHC.Prim.void#;
        };

GHC.GHCi.$fApplicativeNoIO4
  :: forall b a.
     GHC.GHCi.NoIO (a -> b)
     -> GHC.GHCi.NoIO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_so2f m2_so2g void_0E]
        case m1_so2f GHC.Prim.void# of {
          Unit# ipv1_so2k [Occ=Once!] ->
              case m2_so2g GHC.Prim.void# of {
                Unit# ipv3_so2n [Occ=Once] ->
                    let {
                      sat_so2o [Occ=Once] :: b_anJB
                      [LclId] =
                          [ipv1_so2k ipv3_so2n] \u [] ipv1_so2k ipv3_so2n;
                    } in  Unit# [sat_so2o];
              };
        };

GHC.GHCi.$fApplicativeNoIO2
  :: forall a b.
     GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [a1_so2p a2_so2q void_0E]
        case a1_so2p GHC.Prim.void# of {
          Unit# _ [Occ=Dead] -> a2_so2q GHC.Prim.void#;
        };

GHC.GHCi.$fApplicativeNoIO3
  :: forall a b c.
     (a -> b -> c)
     -> GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f1_so2v x_so2w eta_so2x void_0E]
        case x_so2w GHC.Prim.void# of {
          Unit# ipv1_so2B [Occ=Once] ->
              case eta_so2x GHC.Prim.void# of {
                Unit# ipv3_so2E [Occ=Once] ->
                    let {
                      sat_so2F [Occ=Once] :: c_anJZ
                      [LclId] =
                          [f1_so2v ipv1_so2B ipv3_so2E] \u [] f1_so2v ipv1_so2B ipv3_so2E;
                    } in  Unit# [sat_so2F];
              };
        };

GHC.GHCi.$fApplicativeNoIO1
  :: forall a b.
     GHC.GHCi.NoIO a
     -> GHC.GHCi.NoIO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_so2G eta_so2H void_0E]
        case x_so2G GHC.Prim.void# of {
          Unit# ipv1_so2L [Occ=Once] ->
              case eta_so2H GHC.Prim.void# of {
                Unit# _ [Occ=Dead] -> Unit# [ipv1_so2L];
              };
        };

GHC.GHCi.$fMonadNoIO_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.GHCi.NoIO a -> GHC.GHCi.NoIO b -> GHC.GHCi.NoIO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.GHCi.$fApplicativeNoIO2 eta_B3 eta_B2 GHC.Prim.void#;

GHC.GHCi.$fApplicativeNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.GHCi.$fFunctorNoIO
                                           GHC.GHCi.$fApplicativeNoIO5
                                           GHC.GHCi.$fApplicativeNoIO4
                                           GHC.GHCi.$fApplicativeNoIO3
                                           GHC.GHCi.$fApplicativeNoIO2
                                           GHC.GHCi.$fApplicativeNoIO1];

lvl_rnRg :: forall a. [GHC.Types.Char] -> GHC.GHCi.NoIO a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_so2P] GHC.Err.errorWithoutStackTrace eta_so2P;

GHC.GHCi.$fMonadNoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.GHCi.$fApplicativeNoIO
                                     GHC.GHCi.$fMonadNoIO1
                                     GHC.GHCi.$fMonadNoIO_$c>>
                                     GHC.GHCi.$fApplicativeNoIO5
                                     lvl_rnRg];

GHC.GHCi.$fGHCiSandboxIONoIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.GHCi.GHCiSandboxIO GHC.GHCi.NoIO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.GHCi.C:GHCiSandboxIO! [GHC.GHCi.$fMonadNoIO
                                             GHC.GHCi.$fGHCiSandboxIONoIO1];

GHC.GHCi.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.GHCi.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$trModule4];

GHC.GHCi.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.GHCi"#;

GHC.GHCi.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$trModule2];

GHC.GHCi.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.GHCi.$trModule3
                                     GHC.GHCi.$trModule1];

$krep_rnRh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.GHCi.$tcGHCiSandboxIO1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rnRh];

$krep1_rnRi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_rnRj :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_rnRi GHC.Types.[]];

$krep3_rnRk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcIO
                                              $krep2_rnRj];

GHC.GHCi.$tcGHCiSandboxIO3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHCiSandboxIO"#;

GHC.GHCi.$tcGHCiSandboxIO2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tcGHCiSandboxIO3];

GHC.GHCi.$tcGHCiSandboxIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6221156064250054927##
                                    4417322204787188560##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tcGHCiSandboxIO2
                                    0#
                                    GHC.GHCi.$tcGHCiSandboxIO1];

GHC.GHCi.$tcNoIO2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NoIO"#;

GHC.GHCi.$tcNoIO1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tcNoIO2];

GHC.GHCi.$tcNoIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10516839389931644691##
                                    13251969196347980517##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tcNoIO1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_rnRl :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.GHCi.$tcNoIO
                                              $krep2_rnRj];

GHC.GHCi.$tc'NoIO1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_rnRk $krep4_rnRl];

GHC.GHCi.$tc'NoIO3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'NoIO"#;

GHC.GHCi.$tc'NoIO2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.GHCi.$tc'NoIO3];

GHC.GHCi.$tc'NoIO :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11198799526314248800##
                                    4496738896484332546##
                                    GHC.GHCi.$trModule
                                    GHC.GHCi.$tc'NoIO2
                                    1#
                                    GHC.GHCi.$tc'NoIO1];

GHC.GHCi.C:GHCiSandboxIO
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall a. m a -> GHC.Types.IO a) -> GHC.GHCi.GHCiSandboxIO m
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.GHCi.C:GHCiSandboxIO [eta_B2 eta_B1];

