
==================== Output Cmm ====================
2018-03-16 15:59:46.790562394 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:46.791480803 UTC

[section ""cstring" . GHC.Clock.$trModule4_bytes" {
     GHC.Clock.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.792368003 UTC

[section ""data" . GHC.Clock.$trModule3_closure" {
     GHC.Clock.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Clock.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.793307399 UTC

[section ""cstring" . GHC.Clock.$trModule2_bytes" {
     GHC.Clock.$trModule2_bytes:
         I8[] [71,72,67,46,67,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.794230953 UTC

[section ""data" . GHC.Clock.$trModule1_closure" {
     GHC.Clock.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Clock.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.795052523 UTC

[section ""data" . GHC.Clock.$trModule_closure" {
     GHC.Clock.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Clock.$trModule3_closure+1;
         const GHC.Clock.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.796341893 UTC

[section ""data" . getMonotonicTimeNSec1_r4RZ9_closure" {
     getMonotonicTimeNSec1_r4RZ9_closure:
         const getMonotonicTimeNSec1_r4RZ9_info;
 },
 getMonotonicTimeNSec1_r4RZ9_entry() //  []
         { info_tbl: [(c4RZv,
                       label: getMonotonicTimeNSec1_r4RZ9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4RZv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4RZz; else goto c4RZy;
       c4RZz: // global
           HpAlloc = 16;
           R1 = getMonotonicTimeNSec1_r4RZ9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4RZy: // global
           (_s4RZf::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4RZf::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.797933508 UTC

[section ""data" . GHC.Clock.getMonotonicTimeNSec_closure" {
     GHC.Clock.getMonotonicTimeNSec_closure:
         const GHC.Clock.getMonotonicTimeNSec_info;
 },
 GHC.Clock.getMonotonicTimeNSec_entry() //  []
         { info_tbl: [(c4RZE,
                       label: GHC.Clock.getMonotonicTimeNSec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4RZE: // global
           call getMonotonicTimeNSec1_r4RZ9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.799301129 UTC

[section ""data" . GHC.Clock.getMonotonicTime1_closure" {
     GHC.Clock.getMonotonicTime1_closure:
         const GHC.Clock.getMonotonicTime1_info;
 },
 GHC.Clock.getMonotonicTime1_entry() //  []
         { info_tbl: [(c4RZP,
                       label: GHC.Clock.getMonotonicTime1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4RZP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4RZY; else goto c4RZX;
       c4RZY: // global
           HpAlloc = 16;
           R1 = GHC.Clock.getMonotonicTime1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4RZX: // global
           (_s4RZl::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           (_c4RZM::F64) = call MO_UF_Conv W64(_s4RZl::I64);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = %MO_F_Quot_W64(_c4RZM::F64, 1.0e9 :: W64);
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.800883496 UTC

[section ""data" . GHC.Clock.getMonotonicTime_closure" {
     GHC.Clock.getMonotonicTime_closure:
         const GHC.Clock.getMonotonicTime_info;
 },
 GHC.Clock.getMonotonicTime_entry() //  []
         { info_tbl: [(c4S03,
                       label: GHC.Clock.getMonotonicTime_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S03: // global
           call GHC.Clock.getMonotonicTime1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.801963658 UTC

[section ""relreadonly" . S4S06_srt" { S4S06_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.802698755 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:46.803392359 UTC

[section ""cstring" . GHC.Clock.$trModule4_bytes" {
     GHC.Clock.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.804233465 UTC

[section ""data" . GHC.Clock.$trModule3_closure" {
     GHC.Clock.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Clock.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.805036107 UTC

[section ""cstring" . GHC.Clock.$trModule2_bytes" {
     GHC.Clock.$trModule2_bytes:
         I8[] [71,72,67,46,67,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.805899851 UTC

[section ""data" . GHC.Clock.$trModule1_closure" {
     GHC.Clock.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Clock.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.806742854 UTC

[section ""data" . GHC.Clock.$trModule_closure" {
     GHC.Clock.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Clock.$trModule3_closure+1;
         const GHC.Clock.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.80812258 UTC

[section ""data" . getMonotonicTimeNSec1_r4RZ9_closure" {
     getMonotonicTimeNSec1_r4RZ9_closure:
         const getMonotonicTimeNSec1_r4RZ9_info;
 },
 getMonotonicTimeNSec1_r4RZ9_entry() //  []
         { info_tbl: [(c4S0d,
                       label: getMonotonicTimeNSec1_r4RZ9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S0d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4S0h; else goto c4S0g;
       c4S0h: // global
           HpAlloc = 16;
           R1 = getMonotonicTimeNSec1_r4RZ9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4S0g: // global
           (_s4RZf::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4RZf::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.809836814 UTC

[section ""data" . GHC.Clock.getMonotonicTimeNSec_closure" {
     GHC.Clock.getMonotonicTimeNSec_closure:
         const GHC.Clock.getMonotonicTimeNSec_info;
 },
 GHC.Clock.getMonotonicTimeNSec_entry() //  []
         { info_tbl: [(c4S0m,
                       label: GHC.Clock.getMonotonicTimeNSec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S0m: // global
           call getMonotonicTimeNSec1_r4RZ9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.811316599 UTC

[section ""data" . GHC.Clock.getMonotonicTime1_closure" {
     GHC.Clock.getMonotonicTime1_closure:
         const GHC.Clock.getMonotonicTime1_info;
 },
 GHC.Clock.getMonotonicTime1_entry() //  []
         { info_tbl: [(c4S0x,
                       label: GHC.Clock.getMonotonicTime1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S0x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4S0G; else goto c4S0F;
       c4S0G: // global
           HpAlloc = 16;
           R1 = GHC.Clock.getMonotonicTime1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4S0F: // global
           (_s4RZl::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           (_c4S0u::F64) = call MO_UF_Conv W64(_s4RZl::I64);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = %MO_F_Quot_W64(_c4S0u::F64, 1.0e9 :: W64);
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.812832886 UTC

[section ""data" . GHC.Clock.getMonotonicTime_closure" {
     GHC.Clock.getMonotonicTime_closure:
         const GHC.Clock.getMonotonicTime_info;
 },
 GHC.Clock.getMonotonicTime_entry() //  []
         { info_tbl: [(c4S0L,
                       label: GHC.Clock.getMonotonicTime_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S0L: // global
           call GHC.Clock.getMonotonicTime1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.813962588 UTC

[section ""relreadonly" . S4S06_srt" { S4S06_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.815075431 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:46.816868776 UTC

[section ""cstring" . GHC.Clock.$trModule4_bytes" {
     GHC.Clock.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.819610261 UTC

[section ""data" . GHC.Clock.$trModule3_closure" {
     GHC.Clock.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Clock.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.822247009 UTC

[section ""cstring" . GHC.Clock.$trModule2_bytes" {
     GHC.Clock.$trModule2_bytes:
         I8[] [71,72,67,46,67,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.824785577 UTC

[section ""data" . GHC.Clock.$trModule1_closure" {
     GHC.Clock.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Clock.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.827423262 UTC

[section ""data" . GHC.Clock.$trModule_closure" {
     GHC.Clock.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Clock.$trModule3_closure+1;
         const GHC.Clock.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.831579122 UTC

[section ""data" . getMonotonicTimeNSec1_r4RZ9_closure" {
     getMonotonicTimeNSec1_r4RZ9_closure:
         const getMonotonicTimeNSec1_r4RZ9_info;
 },
 getMonotonicTimeNSec1_r4RZ9_entry() //  []
         { info_tbl: [(c4S0Z,
                       label: getMonotonicTimeNSec1_r4RZ9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S0Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4S13; else goto c4S12;
       c4S13: // global
           HpAlloc = 16;
           R1 = getMonotonicTimeNSec1_r4RZ9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4S12: // global
           (_s4RZf::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4RZf::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.837890633 UTC

[section ""data" . GHC.Clock.getMonotonicTimeNSec_closure" {
     GHC.Clock.getMonotonicTimeNSec_closure:
         const GHC.Clock.getMonotonicTimeNSec_info;
 },
 GHC.Clock.getMonotonicTimeNSec_entry() //  []
         { info_tbl: [(c4S1d,
                       label: GHC.Clock.getMonotonicTimeNSec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S1d: // global
           call getMonotonicTimeNSec1_r4RZ9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.843456634 UTC

[section ""data" . GHC.Clock.getMonotonicTime1_closure" {
     GHC.Clock.getMonotonicTime1_closure:
         const GHC.Clock.getMonotonicTime1_info;
 },
 GHC.Clock.getMonotonicTime1_entry() //  []
         { info_tbl: [(c4S1s,
                       label: GHC.Clock.getMonotonicTime1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S1s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4S1B; else goto c4S1A;
       c4S1B: // global
           HpAlloc = 16;
           R1 = GHC.Clock.getMonotonicTime1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4S1A: // global
           (_s4RZl::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           (_c4S1p::F64) = call MO_UF_Conv W64(_s4RZl::I64);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = %MO_F_Quot_W64(_c4S1p::F64, 1.0e9 :: W64);
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.85024412 UTC

[section ""data" . GHC.Clock.getMonotonicTime_closure" {
     GHC.Clock.getMonotonicTime_closure:
         const GHC.Clock.getMonotonicTime_info;
 },
 GHC.Clock.getMonotonicTime_entry() //  []
         { info_tbl: [(c4S1O,
                       label: GHC.Clock.getMonotonicTime_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S1O: // global
           call GHC.Clock.getMonotonicTime1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.856448651 UTC

[section ""relreadonly" . S4S06_srt" { S4S06_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.903243692 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:46.904799141 UTC

[section ""cstring" . GHC.Clock.$trModule4_bytes" {
     GHC.Clock.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.907313908 UTC

[section ""data" . GHC.Clock.$trModule3_closure" {
     GHC.Clock.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Clock.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.910953528 UTC

[section ""cstring" . GHC.Clock.$trModule2_bytes" {
     GHC.Clock.$trModule2_bytes:
         I8[] [71,72,67,46,67,108,111,99,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.913638431 UTC

[section ""data" . GHC.Clock.$trModule1_closure" {
     GHC.Clock.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Clock.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.916218953 UTC

[section ""data" . GHC.Clock.$trModule_closure" {
     GHC.Clock.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Clock.$trModule3_closure+1;
         const GHC.Clock.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.919445269 UTC

[section ""data" . getMonotonicTimeNSec1_r4RZ9_closure" {
     getMonotonicTimeNSec1_r4RZ9_closure:
         const getMonotonicTimeNSec1_r4RZ9_info;
 },
 getMonotonicTimeNSec1_r4RZ9_entry() //  []
         { info_tbl: [(c4S2l,
                       label: getMonotonicTimeNSec1_r4RZ9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S2l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4S2p; else goto c4S2o;
       c4S2p: // global
           HpAlloc = 16;
           R1 = getMonotonicTimeNSec1_r4RZ9_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4S2o: // global
           (_s4S20::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4S20::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.925458301 UTC

[section ""data" . GHC.Clock.getMonotonicTimeNSec_closure" {
     GHC.Clock.getMonotonicTimeNSec_closure:
         const GHC.Clock.getMonotonicTimeNSec_info;
 },
 GHC.Clock.getMonotonicTimeNSec_entry() //  []
         { info_tbl: [(c4S2A,
                       label: GHC.Clock.getMonotonicTimeNSec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S2A: // global
           call getMonotonicTimeNSec1_r4RZ9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.930907052 UTC

[section ""data" . GHC.Clock.getMonotonicTime1_closure" {
     GHC.Clock.getMonotonicTime1_closure:
         const GHC.Clock.getMonotonicTime1_info;
 },
 GHC.Clock.getMonotonicTime1_entry() //  []
         { info_tbl: [(c4S2P,
                       label: GHC.Clock.getMonotonicTime1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S2P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4S2Y; else goto c4S2X;
       c4S2Y: // global
           HpAlloc = 16;
           R1 = GHC.Clock.getMonotonicTime1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c4S2X: // global
           (_s4S26::I64) = call "ccall" arg hints:  []  result hints:  [] getMonotonicNSec();
           (_c4S2M::F64) = call MO_UF_Conv W64(_s4S26::I64);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = %MO_F_Quot_W64(_c4S2M::F64, 1.0e9 :: W64);
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.937586536 UTC

[section ""data" . GHC.Clock.getMonotonicTime_closure" {
     GHC.Clock.getMonotonicTime_closure:
         const GHC.Clock.getMonotonicTime_info;
 },
 GHC.Clock.getMonotonicTime_entry() //  []
         { info_tbl: [(c4S3c,
                       label: GHC.Clock.getMonotonicTime_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4S3c: // global
           call GHC.Clock.getMonotonicTime1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:46.942397739 UTC

[section ""relreadonly" . S4S3j_srt" { S4S3j_srt:
 }]

