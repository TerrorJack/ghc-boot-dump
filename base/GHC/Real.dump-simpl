
==================== Tidy Core ====================
2018-03-16 15:56:01.706143298 UTC

Result size of Tidy Core
  = {terms: 5,908, types: 6,285, coercions: 0, joins: 12/161}

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
GHC.Real.$p1Fractional :: forall a. Fractional a => Num a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>,
 RULES: Built in rule for GHC.Real.$p1Fractional: "Class op $p1Fractional"]
GHC.Real.$p1Fractional
  = \ (@ a_a1dNK) (v_B1 :: Fractional a_a1dNK) ->
      case v_B1 of v_B1 { GHC.Real.C:Fractional v_B2 v_B3 v_B4 v_B5 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
/ :: forall a. Fractional a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>,
 RULES: Built in rule for /: "Class op /"]
/ = \ (@ a_a1dNK) (v_B1 :: Fractional a_a1dNK) ->
      case v_B1 of v_B1 { GHC.Real.C:Fractional v_B2 v_B3 v_B4 v_B5 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
recip :: forall a. Fractional a => a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>,
 RULES: Built in rule for recip: "Class op recip"]
recip
  = \ (@ a_a1dNK) (v_B1 :: Fractional a_a1dNK) ->
      case v_B1 of v_B1 { GHC.Real.C:Fractional v_B2 v_B3 v_B4 v_B5 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
fromRational :: forall a. Fractional a => Rational -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>,
 RULES: Built in rule for fromRational: "Class op fromRational"]
fromRational
  = \ (@ a_a1dNK) (v_B1 :: Fractional a_a1dNK) ->
      case v_B1 of v_B1 { GHC.Real.C:Fractional v_B2 v_B3 v_B4 v_B5 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 34, coercions: 0, joins: 0/0}
GHC.Real.$p1Integral :: forall a. Integral a => Real a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLL),U(U,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for GHC.Real.$p1Integral: "Class op $p1Integral"]
GHC.Real.$p1Integral
  = \ (@ a_a1dNO) (v_B1 :: Integral a_a1dNO) ->
      case v_B1 of v_B1
      { GHC.Real.C:Integral v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                            v_Ba ->
      v_B2
      }

-- RHS size: {terms: 6, types: 34, coercions: 0, joins: 0/0}
GHC.Real.$p2Integral :: forall a. Integral a => Enum a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLL),U(A,U,A,A,A,A,A,A,A)>,
 RULES: Built in rule for GHC.Real.$p2Integral: "Class op $p2Integral"]
GHC.Real.$p2Integral
  = \ (@ a_a1dNO) (v_B1 :: Integral a_a1dNO) ->
      case v_B1 of v_B1
      { GHC.Real.C:Integral v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                            v_Ba ->
      v_B3
      }

-- RHS size: {terms: 6, types: 34, coercions: 0, joins: 0/0}
quot :: forall a. Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLL),U(A,A,U,A,A,A,A,A,A)>,
 RULES: Built in rule for quot: "Class op quot"]
quot
  = \ (@ a_a1dNO) (v_B1 :: Integral a_a1dNO) ->
      case v_B1 of v_B1
      { GHC.Real.C:Integral v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                            v_Ba ->
      v_B4
      }

-- RHS size: {terms: 6, types: 34, coercions: 0, joins: 0/0}
rem :: forall a. Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLL),U(A,A,A,U,A,A,A,A,A)>,
 RULES: Built in rule for rem: "Class op rem"]
rem
  = \ (@ a_a1dNO) (v_B1 :: Integral a_a1dNO) ->
      case v_B1 of v_B1
      { GHC.Real.C:Integral v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                            v_Ba ->
      v_B5
      }

-- RHS size: {terms: 6, types: 34, coercions: 0, joins: 0/0}
div :: forall a. Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLL),U(A,A,A,A,U,A,A,A,A)>,
 RULES: Built in rule for div: "Class op div"]
div
  = \ (@ a_a1dNO) (v_B1 :: Integral a_a1dNO) ->
      case v_B1 of v_B1
      { GHC.Real.C:Integral v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                            v_Ba ->
      v_B6
      }

-- RHS size: {terms: 6, types: 34, coercions: 0, joins: 0/0}
mod :: forall a. Integral a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLL),U(A,A,A,A,A,U,A,A,A)>,
 RULES: Built in rule for mod: "Class op mod"]
mod
  = \ (@ a_a1dNO) (v_B1 :: Integral a_a1dNO) ->
      case v_B1 of v_B1
      { GHC.Real.C:Integral v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                            v_Ba ->
      v_B7
      }

-- RHS size: {terms: 6, types: 34, coercions: 0, joins: 0/0}
quotRem :: forall a. Integral a => a -> a -> (a, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLL),U(A,A,A,A,A,A,U,A,A)>,
 RULES: Built in rule for quotRem: "Class op quotRem"]
quotRem
  = \ (@ a_a1dNO) (v_B1 :: Integral a_a1dNO) ->
      case v_B1 of v_B1
      { GHC.Real.C:Integral v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                            v_Ba ->
      v_B8
      }

-- RHS size: {terms: 6, types: 34, coercions: 0, joins: 0/0}
divMod :: forall a. Integral a => a -> a -> (a, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSL),U(A,A,A,A,A,A,A,U,A)>,
 RULES: Built in rule for divMod: "Class op divMod"]
divMod
  = \ (@ a_a1dNO) (v_B1 :: Integral a_a1dNO) ->
      case v_B1 of v_B1
      { GHC.Real.C:Integral v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                            v_Ba ->
      v_B9
      }

-- RHS size: {terms: 6, types: 34, coercions: 0, joins: 0/0}
toInteger :: forall a. Integral a => a -> Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLS),U(A,A,A,A,A,A,A,A,U)>,
 RULES: Built in rule for toInteger: "Class op toInteger"]
toInteger
  = \ (@ a_a1dNO) (v_B1 :: Integral a_a1dNO) ->
      case v_B1 of v_B1
      { GHC.Real.C:Integral v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                            v_Ba ->
      v_Ba
      }

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
GHC.Real.$p1Real :: forall a. Real a => Num a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLL),U(U,A,A)>,
 RULES: Built in rule for GHC.Real.$p1Real: "Class op $p1Real"]
GHC.Real.$p1Real
  = \ (@ a_a1dO6) (v_B1 :: Real a_a1dO6) ->
      case v_B1 of v_B1 { GHC.Real.C:Real v_B2 v_B3 v_B4 -> v_B2 }

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
GHC.Real.$p2Real :: forall a. Real a => Ord a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSL),U(A,U,A)>,
 RULES: Built in rule for GHC.Real.$p2Real: "Class op $p2Real"]
GHC.Real.$p2Real
  = \ (@ a_a1dO6) (v_B1 :: Real a_a1dO6) ->
      case v_B1 of v_B1 { GHC.Real.C:Real v_B2 v_B3 v_B4 -> v_B3 }

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
toRational :: forall a. Real a => a -> Rational
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLS),U(A,A,U)>,
 RULES: Built in rule for toRational: "Class op toRational"]
toRational
  = \ (@ a_a1dO6) (v_B1 :: Real a_a1dO6) ->
      case v_B1 of v_B1 { GHC.Real.C:Real v_B2 v_B3 v_B4 -> v_B4 }

-- RHS size: {terms: 6, types: 42, coercions: 0, joins: 0/0}
GHC.Real.$p1RealFrac :: forall a. RealFrac a => Real a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLL),U(U,A,A,A,A,A,A)>,
 RULES: Built in rule for GHC.Real.$p1RealFrac: "Class op $p1RealFrac"]
GHC.Real.$p1RealFrac
  = \ (@ a_a1dNs) (v_B1 :: RealFrac a_a1dNs) ->
      case v_B1 of v_B1
      { GHC.Real.C:RealFrac v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 42, coercions: 0, joins: 0/0}
GHC.Real.$p2RealFrac :: forall a. RealFrac a => Fractional a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLL),U(A,U,A,A,A,A,A)>,
 RULES: Built in rule for GHC.Real.$p2RealFrac: "Class op $p2RealFrac"]
GHC.Real.$p2RealFrac
  = \ (@ a_a1dNs) (v_B1 :: RealFrac a_a1dNs) ->
      case v_B1 of v_B1
      { GHC.Real.C:RealFrac v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 42, coercions: 0, joins: 0/0}
properFraction
  :: forall a. RealFrac a => forall b. Integral b => a -> (b, a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLL),U(A,A,U,A,A,A,A)>,
 RULES: Built in rule for properFraction: "Class op properFraction"]
properFraction
  = \ (@ a_a1dNs) (v_B1 :: RealFrac a_a1dNs) ->
      case v_B1 of v_B1
      { GHC.Real.C:RealFrac v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 42, coercions: 0, joins: 0/0}
truncate :: forall a. RealFrac a => forall b. Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLL),U(A,A,A,U,A,A,A)>,
 RULES: Built in rule for truncate: "Class op truncate"]
truncate
  = \ (@ a_a1dNs) (v_B1 :: RealFrac a_a1dNs) ->
      case v_B1 of v_B1
      { GHC.Real.C:RealFrac v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 42, coercions: 0, joins: 0/0}
round :: forall a. RealFrac a => forall b. Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLL),U(A,A,A,A,U,A,A)>,
 RULES: Built in rule for round: "Class op round"]
round
  = \ (@ a_a1dNs) (v_B1 :: RealFrac a_a1dNs) ->
      case v_B1 of v_B1
      { GHC.Real.C:RealFrac v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B6
      }

-- RHS size: {terms: 6, types: 42, coercions: 0, joins: 0/0}
ceiling :: forall a. RealFrac a => forall b. Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSL),U(A,A,A,A,A,U,A)>,
 RULES: Built in rule for ceiling: "Class op ceiling"]
ceiling
  = \ (@ a_a1dNs) (v_B1 :: RealFrac a_a1dNs) ->
      case v_B1 of v_B1
      { GHC.Real.C:RealFrac v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B7
      }

-- RHS size: {terms: 6, types: 42, coercions: 0, joins: 0/0}
floor :: forall a. RealFrac a => forall b. Integral b => a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLS),U(A,A,A,A,A,A,U)>,
 RULES: Built in rule for floor: "Class op floor"]
floor
  = \ (@ a_a1dNs) (v_B1 :: RealFrac a_a1dNs) ->
      case v_B1 of v_B1
      { GHC.Real.C:RealFrac v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 ->
      v_B8
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
GHC.Real.$W:% [InlPrag=INLINE[2]] :: forall a. a -> a -> Ratio a
[GblId[DataConWrapper],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dO7)
                 (dt_a1dRU [Occ=Once] :: a_a1dO7[sk:1])
                 (dt_a1dRV [Occ=Once] :: a_a1dO7[sk:1]) ->
                 case dt_a1dRU of dt_X1dRY { __DEFAULT ->
                 case dt_a1dRV of dt_X1dS0 { __DEFAULT ->
                 GHC.Real.:% @ a_a1dO7 dt_X1dRY dt_X1dS0
                 }
                 }}]
GHC.Real.$W:%
  = \ (@ a_a1dO7)
      (dt_a1dRU [Occ=Once] :: a_a1dO7[sk:1])
      (dt_a1dRV [Occ=Once] :: a_a1dO7[sk:1]) ->
      case dt_a1dRU of dt_X1dRY { __DEFAULT ->
      case dt_a1dRV of dt_X1dS0 { __DEFAULT ->
      GHC.Real.:% @ a_a1dO7 dt_X1dRY dt_X1dS0
      }
      }

-- RHS size: {terms: 19, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$s$c< [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer -> Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hvC [Occ=Once!] :: Ratio Integer)
                 (w1_s1hvD [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hvC of { :% ww1_s1hvG [Occ=Once] ww2_s1hvH [Occ=Once] ->
                 case w1_s1hvD of { :% ww4_s1hvL [Occ=Once] ww5_s1hvM [Occ=Once] ->
                 case ltInteger#
                        (timesInteger ww1_s1hvG ww5_s1hvM)
                        (timesInteger ww4_s1hvL ww2_s1hvH)
                 of wild_aojh
                 { __DEFAULT ->
                 tagToEnum# @ Bool wild_aojh
                 }
                 }
                 }}]
GHC.Real.$fOrdRatio_$s$c<
  = \ (w_s1hvC :: Ratio Integer) (w1_s1hvD :: Ratio Integer) ->
      case w_s1hvC of { :% ww1_s1hvG ww2_s1hvH ->
      case w1_s1hvD of { :% ww4_s1hvL ww5_s1hvM ->
      case ltInteger#
             (timesInteger ww1_s1hvG ww5_s1hvM)
             (timesInteger ww4_s1hvL ww2_s1hvH)
      of wild_aojh
      { __DEFAULT ->
      tagToEnum# @ Bool wild_aojh
      }
      }
      }

-- RHS size: {terms: 19, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$s$c<= [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer -> Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hvP [Occ=Once!] :: Ratio Integer)
                 (w1_s1hvQ [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hvP of { :% ww1_s1hvT [Occ=Once] ww2_s1hvU [Occ=Once] ->
                 case w1_s1hvQ of { :% ww4_s1hvY [Occ=Once] ww5_s1hvZ [Occ=Once] ->
                 case leInteger#
                        (timesInteger ww1_s1hvT ww5_s1hvZ)
                        (timesInteger ww4_s1hvY ww2_s1hvU)
                 of wild_a1fv2
                 { __DEFAULT ->
                 tagToEnum# @ Bool wild_a1fv2
                 }
                 }
                 }}]
GHC.Real.$fEnumRatio_$s$c<=
  = \ (w_s1hvP :: Ratio Integer) (w1_s1hvQ :: Ratio Integer) ->
      case w_s1hvP of { :% ww1_s1hvT ww2_s1hvU ->
      case w1_s1hvQ of { :% ww4_s1hvY ww5_s1hvZ ->
      case leInteger#
             (timesInteger ww1_s1hvT ww5_s1hvZ)
             (timesInteger ww4_s1hvY ww2_s1hvU)
      of wild_a1fv2
      { __DEFAULT ->
      tagToEnum# @ Bool wild_a1fv2
      }
      }
      }

-- RHS size: {terms: 35, types: 9, coercions: 0, joins: 1/1}
GHC.Real.$w$s$ccompare [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Integer -> Integer -> Integer -> Ordering
[GblId,
 Arity=4,
 Str=<S,U><S,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 224 10}]
GHC.Real.$w$s$ccompare
  = \ (ww_s1hw6
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hw7
         :: Integer
         Unf=OtherCon [])
      (ww2_s1hwb
         :: Integer
         Unf=OtherCon [])
      (ww3_s1hwc
         :: Integer
         Unf=OtherCon []) ->
      case eqInteger# ww_s1hw6 ww2_s1hwb of wild_a1foK { __DEFAULT ->
      join {
        $j_s1g3n [Dmd=<L,1*U>] :: Ordering
        [LclId[JoinId(0)]]
        $j_s1g3n
          = case leInteger#
                   (timesInteger ww_s1hw6 ww3_s1hwc)
                   (timesInteger ww2_s1hwb ww1_s1hw7)
            of {
              __DEFAULT -> GHC.Types.GT;
              1# -> GHC.Types.LT
            } } in
      case wild_a1foK of {
        __DEFAULT -> jump $j_s1g3n;
        1# ->
          case eqInteger# ww1_s1hw7 ww3_s1hwc of {
            __DEFAULT -> jump $j_s1g3n;
            1# -> GHC.Types.EQ
          }
      }
      }

-- RHS size: {terms: 13, types: 12, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$s$ccompare [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer -> Ordering
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hw2 [Occ=Once!] :: Ratio Integer)
                 (w1_s1hw3 [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hw2 of { :% ww1_s1hw6 [Occ=Once] ww2_s1hw7 [Occ=Once] ->
                 case w1_s1hw3 of { :% ww4_s1hwb [Occ=Once] ww5_s1hwc [Occ=Once] ->
                 GHC.Real.$w$s$ccompare ww1_s1hw6 ww2_s1hw7 ww4_s1hwb ww5_s1hwc
                 }
                 }}]
GHC.Real.$fEnumRatio_$s$ccompare
  = \ (w_s1hw2 :: Ratio Integer) (w1_s1hw3 :: Ratio Integer) ->
      case w_s1hw2 of { :% ww1_s1hw6 ww2_s1hw7 ->
      case w1_s1hw3 of { :% ww4_s1hwb ww5_s1hwc ->
      GHC.Real.$w$s$ccompare ww1_s1hw6 ww2_s1hw7 ww4_s1hwb ww5_s1hwc
      }
      }

-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$s$c>=
  :: Ratio Integer -> Ratio Integer -> Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fiT [Occ=Once] :: Ratio Integer)
                 (y_a1fiU [Occ=Once] :: Ratio Integer) ->
                 case GHC.Real.$fEnumRatio_$s$ccompare x_a1fiT y_a1fiU of {
                   __DEFAULT -> GHC.Types.True;
                   LT -> GHC.Types.False
                 }}]
GHC.Real.$fEnumRatio_$s$c>=
  = \ (x_a1fiT :: Ratio Integer) (y_a1fiU :: Ratio Integer) ->
      case x_a1fiT of { :% ww1_s1hw6 ww2_s1hw7 ->
      case y_a1fiU of { :% ww4_s1hwb ww5_s1hwc ->
      case GHC.Real.$w$s$ccompare ww1_s1hw6 ww2_s1hw7 ww4_s1hwb ww5_s1hwc
      of {
        __DEFAULT -> GHC.Types.True;
        LT -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$s$c> :: Ratio Integer -> Ratio Integer -> Bool
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1fiM [Occ=Once] :: Ratio Integer)
                 (y_a1fiN [Occ=Once] :: Ratio Integer) ->
                 case GHC.Real.$fEnumRatio_$s$ccompare x_a1fiM y_a1fiN of {
                   __DEFAULT -> GHC.Types.False;
                   GT -> GHC.Types.True
                 }}]
GHC.Real.$fOrdRatio_$s$c>
  = \ (x_a1fiM :: Ratio Integer) (y_a1fiN :: Ratio Integer) ->
      case x_a1fiM of { :% ww1_s1hw6 ww2_s1hw7 ->
      case y_a1fiN of { :% ww4_s1hwb ww5_s1hwc ->
      case GHC.Real.$w$s$ccompare ww1_s1hw6 ww2_s1hw7 ww4_s1hwb ww5_s1hwc
      of {
        __DEFAULT -> GHC.Types.False;
        GT -> GHC.Types.True
      }
      }
      }

-- RHS size: {terms: 20, types: 13, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$s$cmin
  :: Ratio Integer -> Ratio Integer -> Ratio Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55m :: Ratio Integer) (y_a55n :: Ratio Integer) ->
                 case GHC.Real.$fEnumRatio_$s$c<= x_a55m y_a55n of {
                   False -> y_a55n;
                   True -> x_a55m
                 }}]
GHC.Real.$fOrdRatio_$s$cmin
  = \ (x_a55m :: Ratio Integer) (y_a55n :: Ratio Integer) ->
      case x_a55m of ww_s1hvS { :% ww1_s1hvT ww2_s1hvU ->
      case y_a55n of ww3_s1hvX { :% ww4_s1hvY ww5_s1hvZ ->
      case leInteger#
             (timesInteger ww1_s1hvT ww5_s1hvZ)
             (timesInteger ww4_s1hvY ww2_s1hvU)
      of {
        __DEFAULT -> ww3_s1hvX;
        1# -> ww_s1hvS
      }
      }
      }

-- RHS size: {terms: 20, types: 13, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$s$cmax
  :: Ratio Integer -> Ratio Integer -> Ratio Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a55d :: Ratio Integer) (y_a55e :: Ratio Integer) ->
                 case GHC.Real.$fEnumRatio_$s$c<= x_a55d y_a55e of {
                   False -> x_a55d;
                   True -> y_a55e
                 }}]
GHC.Real.$fOrdRatio_$s$cmax
  = \ (x_a55d :: Ratio Integer) (y_a55e :: Ratio Integer) ->
      case x_a55d of ww_s1hvS { :% ww1_s1hvT ww2_s1hvU ->
      case y_a55e of ww3_s1hvX { :% ww4_s1hvY ww5_s1hvZ ->
      case leInteger#
             (timesInteger ww1_s1hvT ww5_s1hvZ)
             (timesInteger ww4_s1hvY ww2_s1hvU)
      of {
        __DEFAULT -> ww_s1hvS;
        1# -> ww3_s1hvX
      }
      }
      }

-- RHS size: {terms: 11, types: 8, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$s$cnegate
  :: Ratio Integer -> Ratio Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1fhf [Occ=Once!] :: Ratio Integer) ->
                 case ds_d1fhf of { :% x_a1dOK [Occ=Once] y_a1dOL [Occ=Once] ->
                 case negateInteger x_a1dOK of dt_X1dZJ { __DEFAULT ->
                 GHC.Real.:% @ Integer dt_X1dZJ y_a1dOL
                 }
                 }}]
GHC.Real.$fFractionalRatio_$s$cnegate
  = \ (ds_d1fhf :: Ratio Integer) ->
      case ds_d1fhf of { :% x_a1dOK y_a1dOL ->
      case negateInteger x_a1dOK of dt_X1dZJ { __DEFAULT ->
      GHC.Real.:% @ Integer dt_X1dZJ y_a1dOL
      }
      }

-- RHS size: {terms: 11, types: 8, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$s$cabs
  :: Ratio Integer -> Ratio Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1fhr [Occ=Once!] :: Ratio Integer) ->
                 case ds_d1fhr of { :% x_a1dOM [Occ=Once] y_a1dON [Occ=Once] ->
                 case absInteger x_a1dOM of dt_X1dZK { __DEFAULT ->
                 GHC.Real.:% @ Integer dt_X1dZK y_a1dON
                 }
                 }}]
GHC.Real.$fFractionalRatio_$s$cabs
  = \ (ds_d1fhr :: Ratio Integer) ->
      case ds_d1fhr of { :% x_a1dOM y_a1dON ->
      case absInteger x_a1dOM of dt_X1dZK { __DEFAULT ->
      GHC.Real.:% @ Integer dt_X1dZK y_a1dON
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Real.$fEnumRatio1 = 1

-- RHS size: {terms: 11, types: 8, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$s$csignum
  :: Ratio Integer -> Ratio Integer
[GblId,
 Arity=1,
 Str=<S(SL),1*U(U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1fhD [Occ=Once!] :: Ratio Integer) ->
                 case ds_d1fhD of { :% x_a1dOO [Occ=Once] _ [Occ=Dead] ->
                 case signumInteger x_a1dOO of dt_X1dZM { __DEFAULT ->
                 GHC.Real.:% @ Integer dt_X1dZM GHC.Real.$fEnumRatio1
                 }
                 }}]
GHC.Real.$fFractionalRatio_$s$csignum
  = \ (ds_d1fhD :: Ratio Integer) ->
      case ds_d1fhD of { :% x_a1dOO ds1_d1fhO ->
      case signumInteger x_a1dOO of dt_X1dZM { __DEFAULT ->
      GHC.Real.:% @ Integer dt_X1dZM GHC.Real.$fEnumRatio1
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$s$cfromInteger
  :: Integer -> Ratio Integer
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1dOP [Occ=Once] :: Integer) ->
                 case x_a1dOP of dt_X1dZI { __DEFAULT ->
                 GHC.Real.:% @ Integer dt_X1dZI GHC.Real.$fEnumRatio1
                 }}]
GHC.Real.$fFractionalRatio_$s$cfromInteger
  = \ (x_a1dOP :: Integer) ->
      case x_a1dOP of dt_X1dZI { __DEFAULT ->
      GHC.Real.:% @ Integer dt_X1dZI GHC.Real.$fEnumRatio1
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Real.$fRealInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: Real Integer
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Integer
                       GHC.Num.$fNumInteger
                       integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger
                       GHC.Real.$fFractionalRatio_$s$cfromInteger]
GHC.Real.$fRealInteger
  = GHC.Real.C:Real
      @ Integer
      GHC.Num.$fNumInteger
      integer-simple-0.1.1.1:GHC.Integer.Type.$fOrdInteger
      GHC.Real.$fFractionalRatio_$s$cfromInteger

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInt_$ctoInteger :: Int -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1fn3 [Occ=Once!] :: Int) ->
                 case ds_d1fn3 of { I# i_a1dPD [Occ=Once] ->
                 smallInteger i_a1dPD
                 }}]
GHC.Real.$fIntegralInt_$ctoInteger
  = \ (ds_d1fn3 :: Int) ->
      case ds_d1fn3 of { I# i_a1dPD -> smallInteger i_a1dPD }

-- RHS size: {terms: 11, types: 5, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$ctoRational :: Int -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1dPQ [Occ=Once!] :: Int) ->
                 case x_a1dPQ of { I# i_a1dPD [Occ=Once] ->
                 case smallInteger i_a1dPD of dt_X1dZT { __DEFAULT ->
                 GHC.Real.:% @ Integer dt_X1dZT GHC.Real.$fEnumRatio1
                 }
                 }}]
GHC.Real.$fEnumRatio_$ctoRational
  = \ (x_a1dPQ :: Int) ->
      case x_a1dPQ of { I# i_a1dPD ->
      case smallInteger i_a1dPD of dt_X1dZT { __DEFAULT ->
      GHC.Real.:% @ Integer dt_X1dZT GHC.Real.$fEnumRatio1
      }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Real.$fRealInt [InlPrag=NOUSERINLINE CONLIKE] :: Real Int
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Int
                       GHC.Num.$fNumInt
                       GHC.Classes.$fOrdInt
                       GHC.Real.$fEnumRatio_$ctoRational]
GHC.Real.$fRealInt
  = GHC.Real.C:Real
      @ Int
      GHC.Num.$fNumInt
      GHC.Classes.$fOrdInt
      GHC.Real.$fEnumRatio_$ctoRational

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralWord_$ctoInteger :: Word -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1fkI [Occ=Once!] :: Word) ->
                 case ds_d1fkI of { W# x#_a1dPB [Occ=Once] ->
                 wordToInteger x#_a1dPB
                 }}]
GHC.Real.$fIntegralWord_$ctoInteger
  = \ (ds_d1fkI :: Word) ->
      case ds_d1fkI of { W# x#_a1dPB -> wordToInteger x#_a1dPB }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInteger_$ctoInteger :: Integer -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (n_a1dOZ [Occ=Once] :: Integer) -> n_a1dOZ}]
GHC.Real.$fIntegralInteger_$ctoInteger
  = \ (n_a1dOZ :: Integer) -> n_a1dOZ

-- RHS size: {terms: 22, types: 15, coercions: 0, joins: 0/0}
GHC.Real.$fEqRatio_$s$c== [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hwf [Occ=Once!] :: Ratio Integer)
                 (w1_s1hwg [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hwf of { :% ww1_s1hwj [Occ=Once] ww2_s1hwk [Occ=Once] ->
                 case w1_s1hwg of { :% ww4_s1hwo [Occ=Once] ww5_s1hwp [Occ=Once] ->
                 case eqInteger# ww1_s1hwj ww4_s1hwo of {
                   __DEFAULT -> GHC.Types.False;
                   1# ->
                     case eqInteger# ww2_s1hwk ww5_s1hwp of wild1_X1fy0 { __DEFAULT ->
                     tagToEnum# @ Bool wild1_X1fy0
                     }
                 }
                 }
                 }}]
GHC.Real.$fEqRatio_$s$c==
  = \ (w_s1hwf :: Ratio Integer) (w1_s1hwg :: Ratio Integer) ->
      case w_s1hwf of { :% ww1_s1hwj ww2_s1hwk ->
      case w1_s1hwg of { :% ww4_s1hwo ww5_s1hwp ->
      case eqInteger# ww1_s1hwj ww4_s1hwo of {
        __DEFAULT -> GHC.Types.False;
        1# ->
          case eqInteger# ww2_s1hwk ww5_s1hwp of wild1_X1fy0 { __DEFAULT ->
          tagToEnum# @ Bool wild1_X1fy0
          }
      }
      }
      }

-- RHS size: {terms: 22, types: 19, coercions: 0, joins: 0/0}
GHC.Real.$fEqRatio_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a. Eq a => Ratio a -> Ratio a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hws)
                 (w_s1hwt :: Eq a_s1hws)
                 (w1_s1hwu [Occ=Once!] :: Ratio a_s1hws)
                 (w2_s1hwv [Occ=Once!] :: Ratio a_s1hws) ->
                 case w1_s1hwu of { :% ww1_s1hwy [Occ=Once] ww2_s1hwz [Occ=Once] ->
                 case w2_s1hwv of { :% ww4_s1hwD [Occ=Once] ww5_s1hwE [Occ=Once] ->
                 case == @ a_s1hws w_s1hwt ww1_s1hwy ww4_s1hwD of {
                   False -> GHC.Types.False;
                   True -> == @ a_s1hws w_s1hwt ww2_s1hwz ww5_s1hwE
                 }
                 }
                 }}]
GHC.Real.$fEqRatio_$c==
  = \ (@ a_s1hws)
      (w_s1hwt :: Eq a_s1hws)
      (w1_s1hwu :: Ratio a_s1hws)
      (w2_s1hwv :: Ratio a_s1hws) ->
      case w1_s1hwu of { :% ww1_s1hwy ww2_s1hwz ->
      case w2_s1hwv of { :% ww4_s1hwD ww5_s1hwE ->
      case == @ a_s1hws w_s1hwt ww1_s1hwy ww4_s1hwD of {
        False -> GHC.Types.False;
        True -> == @ a_s1hws w_s1hwt ww2_s1hwz ww5_s1hwE
      }
      }
      }

-- RHS size: {terms: 23, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$s$c/= [InlPrag=INLINE (sat-args=2)]
  :: Ratio Integer -> Ratio Integer -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once!] :: Ratio Integer)
                 (y_a22c [Occ=Once!] :: Ratio Integer) ->
                 case x_a22b of { :% a1_a1e7U [Occ=Once] a2_a1e7V [Occ=Once] ->
                 case y_a22c of { :% b1_a1e7W [Occ=Once] b2_a1e7X [Occ=Once] ->
                 case eqInteger# a1_a1e7U b1_a1e7W of {
                   __DEFAULT -> GHC.Types.True;
                   1# ->
                     case eqInteger# a2_a1e7V b2_a1e7X of {
                       __DEFAULT -> GHC.Types.True;
                       1# -> GHC.Types.False
                     }
                 }
                 }
                 }}]
GHC.Real.$fOrdRatio_$s$c/=
  = \ (eta_B2 :: Ratio Integer) (eta1_B1 :: Ratio Integer) ->
      case eta_B2 of { :% a1_a1e7U a2_a1e7V ->
      case eta1_B1 of { :% b1_a1e7W b2_a1e7X ->
      case eqInteger# a1_a1e7U b1_a1e7W of {
        __DEFAULT -> GHC.Types.True;
        1# ->
          case eqInteger# a2_a1e7V b2_a1e7X of {
            __DEFAULT -> GHC.Types.True;
            1# -> GHC.Types.False
          }
      }
      }
      }

-- RHS size: {terms: 27, types: 20, coercions: 0, joins: 0/0}
GHC.Real.$fEqRatio_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a. Eq a => Ratio a -> Ratio a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a1eDJ)
                 ($dEq_a1eDK [Occ=Once] :: Eq a_a1eDJ)
                 (x_a22b [Occ=Once] :: Ratio a_a1eDJ)
                 (y_a22c [Occ=Once] :: Ratio a_a1eDJ) ->
                 case GHC.Real.$fEqRatio_$c== @ a_a1eDJ $dEq_a1eDK x_a22b y_a22c
                 of {
                   False -> GHC.Types.True;
                   True -> GHC.Types.False
                 }}]
GHC.Real.$fEqRatio_$c/=
  = \ (@ a_a1eDJ)
      ($dEq_a1eDK :: Eq a_a1eDJ)
      (eta_B2 :: Ratio a_a1eDJ)
      (eta1_B1 :: Ratio a_a1eDJ) ->
      case eta_B2 of { :% ww1_s1hwy ww2_s1hwz ->
      case eta1_B1 of { :% ww4_s1hwD ww5_s1hwE ->
      case == @ a_a1eDJ $dEq_a1eDK ww1_s1hwy ww4_s1hwD of {
        False -> GHC.Types.True;
        True ->
          case == @ a_a1eDJ $dEq_a1eDK ww2_s1hwz ww5_s1hwE of {
            False -> GHC.Types.True;
            True -> GHC.Types.False
          }
      }
      }
      }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$s$fEqRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq (Ratio Integer)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: Ratio Integer
                        \ (ds_d1fdr [Occ=Once!] :: Ratio Integer)
                          (ds1_d1fds [Occ=Once!] :: Ratio Integer) ->
                          case ds_d1fdr of { :% a1_a1e7U [Occ=Once] a2_a1e7V [Occ=Once] ->
                          case ds1_d1fds of { :% b1_a1e7W [Occ=Once] b2_a1e7X [Occ=Once] ->
                          case eqInteger# a1_a1e7U b1_a1e7W of {
                            __DEFAULT -> GHC.Types.False;
                            1# ->
                              case eqInteger# a2_a1e7V b2_a1e7X of wild3_X1fy9 { __DEFAULT ->
                              tagToEnum# @ Bool wild3_X1fy9
                              }
                          }
                          }
                          }
                        GHC.Real.$fOrdRatio_$s$c/=]
GHC.Real.$fOrdRatio_$s$fEqRatio
  = GHC.Classes.C:Eq
      @ (Ratio Integer)
      GHC.Real.$fEqRatio_$s$c==
      GHC.Real.$fOrdRatio_$s$c/=

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Real.$fEqRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_a1dO7) (v_B1 :: Eq a_a1dO7) ->
       GHC.Classes.C:Eq TYPE: Ratio a_a1dO7
                        GHC.Real.$fEqRatio_$c== @ a_a1dO7 v_B1
                        GHC.Real.$fEqRatio_$c/= @ a_a1dO7 v_B1]
GHC.Real.$fEqRatio
  = \ (@ a_a1eDJ) ($dEq_a1eDK :: Eq a_a1eDJ) ->
      GHC.Classes.C:Eq
        @ (Ratio a_a1eDJ)
        (GHC.Real.$fEqRatio_$c== @ a_a1eDJ $dEq_a1eDK)
        (GHC.Real.$fEqRatio_$c/= @ a_a1eDJ $dEq_a1eDK)

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$s$fOrdRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord (Ratio Integer)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Ratio Integer
                         GHC.Real.$fOrdRatio_$s$fEqRatio
                         GHC.Real.$fEnumRatio_$s$ccompare
                         GHC.Real.$fOrdRatio_$s$c<
                         GHC.Real.$fEnumRatio_$s$c<=
                         GHC.Real.$fOrdRatio_$s$c>
                         GHC.Real.$fEnumRatio_$s$c>=
                         GHC.Real.$fOrdRatio_$s$cmax
                         GHC.Real.$fOrdRatio_$s$cmin]
GHC.Real.$fOrdRatio_$s$fOrdRatio
  = GHC.Classes.C:Ord
      @ (Ratio Integer)
      GHC.Real.$fOrdRatio_$s$fEqRatio
      GHC.Real.$fEnumRatio_$s$ccompare
      GHC.Real.$fOrdRatio_$s$c<
      GHC.Real.$fEnumRatio_$s$c<=
      GHC.Real.$fOrdRatio_$s$c>
      GHC.Real.$fEnumRatio_$s$c>=
      GHC.Real.$fOrdRatio_$s$cmax
      GHC.Real.$fOrdRatio_$s$cmin

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$cp1Ord :: forall a. Integral a => Eq (Ratio a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eJ2)
                 ($dIntegral_a1eJ3 [Occ=Once] :: Integral a_a1eJ2) ->
                 GHC.Real.$fEqRatio
                   @ a_a1eJ2
                   (GHC.Classes.$p1Ord
                      @ a_a1eJ2
                      (GHC.Real.$p2Real
                         @ a_a1eJ2 (GHC.Real.$p1Integral @ a_a1eJ2 $dIntegral_a1eJ3)))}]
GHC.Real.$fOrdRatio_$cp1Ord
  = \ (@ a_a1eJ2) ($dIntegral_a1eJ3 :: Integral a_a1eJ2) ->
      GHC.Real.$fEqRatio
        @ a_a1eJ2
        (GHC.Classes.$p1Ord
           @ a_a1eJ2
           (GHC.Real.$p2Real
              @ a_a1eJ2 (GHC.Real.$p1Integral @ a_a1eJ2 $dIntegral_a1eJ3)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.even1 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Real.even1 = 0

-- RHS size: {terms: 46, types: 45, coercions: 0, joins: 0/4}
GHC.Real.$dmfloor
  :: forall a. RealFrac a => forall b. Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U,U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNs) ($dRealFrac_a1eB7 :: RealFrac a_a1dNs) ->
                 let {
                   $dReal_a1eYG :: Real a_a1dNs
                   [LclId]
                   $dReal_a1eYG = GHC.Real.$p1RealFrac @ a_a1dNs $dRealFrac_a1eB7 } in
                 let {
                   $dNum_a1eYI [Occ=OnceL] :: Num a_a1dNs
                   [LclId]
                   $dNum_a1eYI = GHC.Real.$p1Real @ a_a1dNs $dReal_a1eYG } in
                 let {
                   $dOrd_a1eYJ [Occ=OnceL] :: Ord a_a1dNs
                   [LclId]
                   $dOrd_a1eYJ = GHC.Real.$p2Real @ a_a1dNs $dReal_a1eYG } in
                 \ (@ b_a1eDd) ($dIntegral_a1eDf :: Integral b_a1eDd) ->
                   let {
                     $dReal1_a1eYM [Occ=OnceL] :: Real b_a1eDd
                     [LclId]
                     $dReal1_a1eYM
                       = GHC.Real.$p1Integral @ b_a1eDd $dIntegral_a1eDf } in
                   let {
                     $dNum1_a1eYO :: Num b_a1eDd
                     [LclId]
                     $dNum1_a1eYO = GHC.Real.$p1Real @ b_a1eDd $dReal1_a1eYM } in
                   \ (x_a1dNH [Occ=Once] :: a_a1dNs) ->
                     let {
                       ds_d1fcW :: (b_a1eDd, a_a1dNs)
                       [LclId]
                       ds_d1fcW
                         = properFraction
                             @ a_a1dNs $dRealFrac_a1eB7 @ b_a1eDd $dIntegral_a1eDf x_a1dNH } in
                     case < @ a_a1dNs
                            $dOrd_a1eYJ
                            (case ds_d1fcW of { (_ [Occ=Dead], r_a1eDo [Occ=Once]) ->
                             r_a1eDo
                             })
                            (fromInteger @ a_a1dNs $dNum_a1eYI 0)
                     of {
                       False ->
                         case ds_d1fcW of { (n_a1eDm [Occ=Once], _ [Occ=Dead]) -> n_a1eDm };
                       True ->
                         - @ b_a1eDd
                           $dNum1_a1eYO
                           (case ds_d1fcW of { (n_a1eDm [Occ=Once], _ [Occ=Dead]) ->
                            n_a1eDm
                            })
                           (fromInteger @ b_a1eDd $dNum1_a1eYO 1)
                     }}]
GHC.Real.$dmfloor
  = \ (@ a_a1dNs)
      ($dRealFrac_a1eB7 :: RealFrac a_a1dNs)
      (@ b_a1eDd)
      (eta_B2 :: Integral b_a1eDd)
      (eta1_B1 :: a_a1dNs) ->
      let {
        ds_s1fXT [Dmd=<L,U(1*U,1*U)>] :: (b_a1eDd, a_a1dNs)
        [LclId]
        ds_s1fXT
          = properFraction
              @ a_a1dNs $dRealFrac_a1eB7 @ b_a1eDd eta_B2 eta1_B1 } in
      let {
        $dReal_s1fXW [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
          :: Real a_a1dNs
        [LclId]
        $dReal_s1fXW = GHC.Real.$p1RealFrac @ a_a1dNs $dRealFrac_a1eB7 } in
      case < @ a_a1dNs
             (GHC.Real.$p2Real @ a_a1dNs $dReal_s1fXW)
             (case ds_s1fXT of { (n_a1eDm, r_a1eDo) -> r_a1eDo })
             (fromInteger
                @ a_a1dNs (GHC.Real.$p1Real @ a_a1dNs $dReal_s1fXW) GHC.Real.even1)
      of {
        False -> case ds_s1fXT of { (n_a1eDm, r_a1eDo) -> n_a1eDm };
        True ->
          let {
            $dReal1_s1fXV [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
              :: Real b_a1eDd
            [LclId]
            $dReal1_s1fXV = GHC.Real.$p1Integral @ b_a1eDd eta_B2 } in
          let {
            $dNum_s1fXU [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
              :: Num b_a1eDd
            [LclId]
            $dNum_s1fXU = GHC.Real.$p1Real @ b_a1eDd $dReal1_s1fXV } in
          - @ b_a1eDd
            $dNum_s1fXU
            (case ds_s1fXT of { (n_a1eDm, r_a1eDo) -> n_a1eDm })
            (fromInteger @ b_a1eDd $dNum_s1fXU GHC.Real.$fEnumRatio1)
      }

-- RHS size: {terms: 46, types: 45, coercions: 0, joins: 0/4}
GHC.Real.$dmceiling
  :: forall a. RealFrac a => forall b. Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLL),U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,A,1*C1(C1(U)),A,A,A),A),A,1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U,U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNs) ($dRealFrac_a1eB7 :: RealFrac a_a1dNs) ->
                 let {
                   $dReal_a1eYv :: Real a_a1dNs
                   [LclId]
                   $dReal_a1eYv = GHC.Real.$p1RealFrac @ a_a1dNs $dRealFrac_a1eB7 } in
                 let {
                   $dNum_a1eYx [Occ=OnceL] :: Num a_a1dNs
                   [LclId]
                   $dNum_a1eYx = GHC.Real.$p1Real @ a_a1dNs $dReal_a1eYv } in
                 let {
                   $dOrd_a1eYy [Occ=OnceL] :: Ord a_a1dNs
                   [LclId]
                   $dOrd_a1eYy = GHC.Real.$p2Real @ a_a1dNs $dReal_a1eYv } in
                 \ (@ b_a1eCG) ($dIntegral_a1eCI :: Integral b_a1eCG) ->
                   let {
                     $dReal1_a1eYB [Occ=OnceL] :: Real b_a1eCG
                     [LclId]
                     $dReal1_a1eYB
                       = GHC.Real.$p1Integral @ b_a1eCG $dIntegral_a1eCI } in
                   let {
                     $dNum1_a1eYD :: Num b_a1eCG
                     [LclId]
                     $dNum1_a1eYD = GHC.Real.$p1Real @ b_a1eCG $dReal1_a1eYB } in
                   \ (x_a1dNE [Occ=Once] :: a_a1dNs) ->
                     let {
                       ds_d1fc3 :: (b_a1eCG, a_a1dNs)
                       [LclId]
                       ds_d1fc3
                         = properFraction
                             @ a_a1dNs $dRealFrac_a1eB7 @ b_a1eCG $dIntegral_a1eCI x_a1dNE } in
                     case > @ a_a1dNs
                            $dOrd_a1eYy
                            (case ds_d1fc3 of { (_ [Occ=Dead], r_a1eCR [Occ=Once]) ->
                             r_a1eCR
                             })
                            (fromInteger @ a_a1dNs $dNum_a1eYx 0)
                     of {
                       False ->
                         case ds_d1fc3 of { (n_a1eCP [Occ=Once], _ [Occ=Dead]) -> n_a1eCP };
                       True ->
                         + @ b_a1eCG
                           $dNum1_a1eYD
                           (case ds_d1fc3 of { (n_a1eCP [Occ=Once], _ [Occ=Dead]) ->
                            n_a1eCP
                            })
                           (fromInteger @ b_a1eCG $dNum1_a1eYD 1)
                     }}]
GHC.Real.$dmceiling
  = \ (@ a_a1dNs)
      ($dRealFrac_a1eB7 :: RealFrac a_a1dNs)
      (@ b_a1eCG)
      (eta_B2 :: Integral b_a1eCG)
      (eta1_B1 :: a_a1dNs) ->
      let {
        ds_s1fXL [Dmd=<L,U(1*U,1*U)>] :: (b_a1eCG, a_a1dNs)
        [LclId]
        ds_s1fXL
          = properFraction
              @ a_a1dNs $dRealFrac_a1eB7 @ b_a1eCG eta_B2 eta1_B1 } in
      let {
        $dReal_s1fXO [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,A,1*C1(C1(U)),A,A,A),A)>]
          :: Real a_a1dNs
        [LclId]
        $dReal_s1fXO = GHC.Real.$p1RealFrac @ a_a1dNs $dRealFrac_a1eB7 } in
      case > @ a_a1dNs
             (GHC.Real.$p2Real @ a_a1dNs $dReal_s1fXO)
             (case ds_s1fXL of { (n_a1eCP, r_a1eCR) -> r_a1eCR })
             (fromInteger
                @ a_a1dNs (GHC.Real.$p1Real @ a_a1dNs $dReal_s1fXO) GHC.Real.even1)
      of {
        False -> case ds_s1fXL of { (n_a1eCP, r_a1eCR) -> n_a1eCP };
        True ->
          let {
            $dReal1_s1fXN [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
              :: Real b_a1eCG
            [LclId]
            $dReal1_s1fXN = GHC.Real.$p1Integral @ b_a1eCG eta_B2 } in
          let {
            $dNum_s1fXM [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
              :: Num b_a1eCG
            [LclId]
            $dNum_s1fXM = GHC.Real.$p1Real @ b_a1eCG $dReal1_s1fXN } in
          + @ b_a1eCG
            $dNum_s1fXM
            (case ds_s1fXL of { (n_a1eCP, r_a1eCR) -> n_a1eCP })
            (fromInteger @ b_a1eCG $dNum_s1fXM GHC.Real.$fEnumRatio1)
      }

-- RHS size: {terms: 12, types: 16, coercions: 0, joins: 0/0}
GHC.Real.$dmtruncate [InlPrag=INLINE (sat-args=1)]
  :: forall a. RealFrac a => forall b. Integral b => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S(SL)))LLLL),1*U(A,A,1*C1(C1(U(1*U,A))),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNs)
                 ($dRealFrac_a1eB7 [Occ=Once] :: RealFrac a_a1dNs)
                 (@ b_a1eB9)
                 ($dIntegral_a1eBb [Occ=Once] :: Integral b_a1eB9)
                 (x_a1dNy [Occ=Once] :: a_a1dNs) ->
                 case properFraction
                        @ a_a1dNs $dRealFrac_a1eB7 @ b_a1eB9 $dIntegral_a1eBb x_a1dNy
                 of
                 { (m_a1eBi [Occ=Once], _ [Occ=Dead]) ->
                 m_a1eBi
                 }}]
GHC.Real.$dmtruncate
  = \ (@ a_a1dNs)
      ($dRealFrac_a1eB7 :: RealFrac a_a1dNs)
      (@ b_a1eB9)
      ($dIntegral_a1eBb :: Integral b_a1eB9)
      (x_a1dNy :: a_a1dNs) ->
      case properFraction
             @ a_a1dNs $dRealFrac_a1eB7 @ b_a1eB9 $dIntegral_a1eBb x_a1dNy
      of
      { (m_a1eBi, ds_d1fae) ->
      m_a1eBi
      }

-- RHS size: {terms: 10, types: 8, coercions: 0, joins: 0/0}
GHC.Real.$dmrecip [InlPrag=INLINE (sat-args=1)]
  :: forall a. Fractional a => a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LL),U(1*U(A,A,A,A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNK) ($dFractional_a1eAS :: Fractional a_a1dNK) ->
                 let {
                   $dNum_a1eB5 [Occ=OnceL] :: Num a_a1dNK
                   [LclId]
                   $dNum_a1eB5
                     = GHC.Real.$p1Fractional @ a_a1dNK $dFractional_a1eAS } in
                 \ (x_a1dNL [Occ=Once] :: a_a1dNK) ->
                   / @ a_a1dNK
                     $dFractional_a1eAS
                     (fromInteger @ a_a1dNK $dNum_a1eB5 1)
                     x_a1dNL}]
GHC.Real.$dmrecip
  = \ (@ a_a1dNK)
      ($dFractional_a1eAS :: Fractional a_a1dNK)
      (eta_B1 :: a_a1dNK) ->
      / @ a_a1dNK
        $dFractional_a1eAS
        (fromInteger
           @ a_a1dNK
           (GHC.Real.$p1Fractional @ a_a1dNK $dFractional_a1eAS)
           GHC.Real.$fEnumRatio1)
        eta_B1

-- RHS size: {terms: 11, types: 9, coercions: 0, joins: 0/0}
GHC.Real.$dm/ [InlPrag=INLINE (sat-args=2)]
  :: forall a. Fractional a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLC(C(S))LLLL)LLL),U(1*U(A,A,1*C1(C1(U)),A,A,A,A),A,1*C1(U),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNK) ($dFractional_a1eAS :: Fractional a_a1dNK) ->
                 let {
                   $dNum_a1eAW [Occ=OnceL] :: Num a_a1dNK
                   [LclId]
                   $dNum_a1eAW
                     = GHC.Real.$p1Fractional @ a_a1dNK $dFractional_a1eAS } in
                 \ (x_a1dNM [Occ=Once] :: a_a1dNK)
                   (y_a1dNN [Occ=Once] :: a_a1dNK) ->
                   * @ a_a1dNK
                     $dNum_a1eAW
                     x_a1dNM
                     (recip @ a_a1dNK $dFractional_a1eAS y_a1dNN)}]
GHC.Real.$dm/
  = \ (@ a_a1dNK)
      ($dFractional_a1eAS :: Fractional a_a1dNK)
      (eta_B2 :: a_a1dNK)
      (eta1_B1 :: a_a1dNK) ->
      * @ a_a1dNK
        (GHC.Real.$p1Fractional @ a_a1dNK $dFractional_a1eAS)
        eta_B2
        (recip @ a_a1dNK $dFractional_a1eAS eta1_B1)

-- RHS size: {terms: 59, types: 75, coercions: 0, joins: 0/4}
GHC.Real.$dmdivMod :: forall a. Integral a => a -> a -> (a, a)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,1*C1(C1(U(U,U))),A,A)><L,U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNO) ($dIntegral_a1ezj :: Integral a_a1dNO) ->
                 let {
                   $dReal_a1eY2 :: Real a_a1dNO
                   [LclId]
                   $dReal_a1eY2 = GHC.Real.$p1Integral @ a_a1dNO $dIntegral_a1ezj } in
                 let {
                   $dNum_a1eY4 :: Num a_a1dNO
                   [LclId]
                   $dNum_a1eY4 = GHC.Real.$p1Real @ a_a1dNO $dReal_a1eY2 } in
                 let {
                   $dEq_s1fos [Occ=OnceL] :: Ord a_a1dNO
                   [LclId]
                   $dEq_s1fos = GHC.Real.$p2Real @ a_a1dNO $dReal_a1eY2 } in
                 let {
                   $dEq1_a1eAE [Occ=OnceL] :: Eq a_a1dNO
                   [LclId]
                   $dEq1_a1eAE = GHC.Classes.$p1Ord @ a_a1dNO $dEq_s1fos } in
                 \ (n_a1dO1 [Occ=Once] :: a_a1dNO) (d_a1dO2 :: a_a1dNO) ->
                   let {
                     ds_d1f9k :: ((a_a1dNO, a_a1dNO), a_a1dNO, a_a1dNO)
                     [LclId]
                     ds_d1f9k
                       = case quotRem @ a_a1dNO $dIntegral_a1ezj n_a1dO1 d_a1dO2
                         of wild_X3R
                         { (q_a1eAr [Occ=Once], r_a1eAt [Occ=Once]) ->
                         (wild_X3R, q_a1eAr, r_a1eAt)
                         } } in
                   let {
                     r_a1dO5 :: a_a1dNO
                     [LclId]
                     r_a1dO5
                       = case ds_d1f9k of
                         { (_ [Occ=Dead], _ [Occ=Dead], r1_a1eAt [Occ=Once]) ->
                         r1_a1eAt
                         } } in
                   case ==
                          @ a_a1dNO
                          $dEq1_a1eAE
                          (signum @ a_a1dNO $dNum_a1eY4 r_a1dO5)
                          (negate
                             @ a_a1dNO $dNum_a1eY4 (signum @ a_a1dNO $dNum_a1eY4 d_a1dO2))
                   of {
                     False ->
                       case ds_d1f9k of
                       { (qr_a1eAn [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
                       qr_a1eAn
                       };
                     True ->
                       (- @ a_a1dNO
                          $dNum_a1eY4
                          (case ds_d1f9k of
                           { (_ [Occ=Dead], q_a1eAr [Occ=Once], _ [Occ=Dead]) ->
                           q_a1eAr
                           })
                          (fromInteger @ a_a1dNO $dNum_a1eY4 1),
                        + @ a_a1dNO $dNum_a1eY4 r_a1dO5 d_a1dO2)
                   }}]
GHC.Real.$dmdivMod
  = \ (@ a_a1dNO)
      ($dIntegral_a1ezj :: Integral a_a1dNO)
      (eta_B2 :: a_a1dNO)
      (eta1_B1 :: a_a1dNO) ->
      let {
        $dReal_s1fXG [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real a_a1dNO
        [LclId]
        $dReal_s1fXG = GHC.Real.$p1Integral @ a_a1dNO $dIntegral_a1ezj } in
      let {
        $dNum_s1fXF [Dmd=<L,U(1*C1(C1(U)),1*C1(C1(U)),A,1*C1(U),A,C(U),1*C1(U))>]
          :: Num a_a1dNO
        [LclId]
        $dNum_s1fXF = GHC.Real.$p1Real @ a_a1dNO $dReal_s1fXG } in
      let {
        ds_s1fXE [Dmd=<L,U(1*U(U,U),1*U,1*U)>]
          :: ((a_a1dNO, a_a1dNO), a_a1dNO, a_a1dNO)
        [LclId]
        ds_s1fXE
          = case quotRem @ a_a1dNO $dIntegral_a1ezj eta_B2 eta1_B1
            of wild_X3R
            { (q_a1eAr, r_a1eAt) ->
            (wild_X3R, q_a1eAr, r_a1eAt)
            } } in
      let {
        r_s1fXD :: a_a1dNO
        [LclId]
        r_s1fXD
          = case ds_s1fXE of { (qr_a1eAn, q_a1eAr, r1_a1eAt) ->
            r1_a1eAt
            } } in
      case ==
             @ a_a1dNO
             (GHC.Classes.$p1Ord
                @ a_a1dNO (GHC.Real.$p2Real @ a_a1dNO $dReal_s1fXG))
             (signum @ a_a1dNO $dNum_s1fXF r_s1fXD)
             (negate
                @ a_a1dNO $dNum_s1fXF (signum @ a_a1dNO $dNum_s1fXF eta1_B1))
      of {
        False ->
          case ds_s1fXE of { (qr_a1eAn, q_a1eAr, r1_a1eAt) -> qr_a1eAn };
        True ->
          (- @ a_a1dNO
             $dNum_s1fXF
             (case ds_s1fXE of { (qr_a1eAn, q_a1eAr, r1_a1eAt) -> q_a1eAr })
             (fromInteger @ a_a1dNO $dNum_s1fXF GHC.Real.$fEnumRatio1),
           + @ a_a1dNO $dNum_s1fXF r_s1fXD eta1_B1)
      }

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
GHC.Real.$dmmod [InlPrag=INLINE (sat-args=2)]
  :: forall a. Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(S(LS)))L),1*U(A,A,A,A,A,A,A,1*C1(C1(U(A,1*U))),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNO)
                 ($dIntegral_a1ezj [Occ=Once] :: Integral a_a1dNO)
                 (n_a1dNY [Occ=Once] :: a_a1dNO)
                 (d_a1dNZ [Occ=Once] :: a_a1dNO) ->
                 case divMod @ a_a1dNO $dIntegral_a1ezj n_a1dNY d_a1dNZ of
                 { (_ [Occ=Dead], r_a1eAb [Occ=Once]) ->
                 r_a1eAb
                 }}]
GHC.Real.$dmmod
  = \ (@ a_a1dNO)
      ($dIntegral_a1ezj :: Integral a_a1dNO)
      (n_a1dNY :: a_a1dNO)
      (d_a1dNZ :: a_a1dNO) ->
      case divMod @ a_a1dNO $dIntegral_a1ezj n_a1dNY d_a1dNZ of
      { (ds_d1f97, r_a1eAb) ->
      r_a1eAb
      }

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
GHC.Real.$dmdiv [InlPrag=INLINE (sat-args=2)]
  :: forall a. Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(S(SL)))L),1*U(A,A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNO)
                 ($dIntegral_a1ezj [Occ=Once] :: Integral a_a1dNO)
                 (n_a1dNV [Occ=Once] :: a_a1dNO)
                 (d_a1dNW [Occ=Once] :: a_a1dNO) ->
                 case divMod @ a_a1dNO $dIntegral_a1ezj n_a1dNV d_a1dNW of
                 { (q_a1ezW [Occ=Once], _ [Occ=Dead]) ->
                 q_a1ezW
                 }}]
GHC.Real.$dmdiv
  = \ (@ a_a1dNO)
      ($dIntegral_a1ezj :: Integral a_a1dNO)
      (n_a1dNV :: a_a1dNO)
      (d_a1dNW :: a_a1dNO) ->
      case divMod @ a_a1dNO $dIntegral_a1ezj n_a1dNV d_a1dNW of
      { (q_a1ezW, ds_d1f8J) ->
      q_a1ezW
      }

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
GHC.Real.$dmrem [InlPrag=INLINE (sat-args=2)]
  :: forall a. Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(LS)))LL),1*U(A,A,A,A,A,A,1*C1(C1(U(A,1*U))),A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNO)
                 ($dIntegral_a1ezj [Occ=Once] :: Integral a_a1dNO)
                 (n_a1dNS [Occ=Once] :: a_a1dNO)
                 (d_a1dNT [Occ=Once] :: a_a1dNO) ->
                 case quotRem @ a_a1dNO $dIntegral_a1ezj n_a1dNS d_a1dNT of
                 { (_ [Occ=Dead], r_a1ezH [Occ=Once]) ->
                 r_a1ezH
                 }}]
GHC.Real.$dmrem
  = \ (@ a_a1dNO)
      ($dIntegral_a1ezj :: Integral a_a1dNO)
      (n_a1dNS :: a_a1dNO)
      (d_a1dNT :: a_a1dNO) ->
      case quotRem @ a_a1dNO $dIntegral_a1ezj n_a1dNS d_a1dNT of
      { (ds_d1f8l, r_a1ezH) ->
      r_a1ezH
      }

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
GHC.Real.$dmquot [InlPrag=INLINE (sat-args=2)]
  :: forall a. Integral a => a -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(C(S(SL)))LL),1*U(A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNO)
                 ($dIntegral_a1ezj [Occ=Once] :: Integral a_a1dNO)
                 (n_a1dNP [Occ=Once] :: a_a1dNO)
                 (d_a1dNQ [Occ=Once] :: a_a1dNO) ->
                 case quotRem @ a_a1dNO $dIntegral_a1ezj n_a1dNP d_a1dNQ of
                 { (q_a1ezs [Occ=Once], _ [Occ=Dead]) ->
                 q_a1ezs
                 }}]
GHC.Real.$dmquot
  = \ (@ a_a1dNO)
      ($dIntegral_a1ezj :: Integral a_a1dNO)
      (n_a1dNP :: a_a1dNO)
      (d_a1dNQ :: a_a1dNO) ->
      case quotRem @ a_a1dNO $dIntegral_a1ezj n_a1dNP d_a1dNQ of
      { (q_a1ezs, ds_d1f7X) ->
      q_a1ezs
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
divZeroError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x]
divZeroError
  = \ (@ a_a1ezd) ->
      raise#
        @ GHC.Exception.SomeException
        @ 'LiftedRep
        @ a_a1ezd
        divZeroException

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInt1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$fIntegralInt1 = GHC.Types.I# 0#

-- RHS size: {terms: 23, types: 11, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInt_$cmod [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Str=<L,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hwU [Occ=Once!] :: Int)
                 (w1_s1hwV [Occ=Once!] :: Int) ->
                 case w1_s1hwV of { I# ww1_s1hwY [Occ=Once!] ->
                 case ww1_s1hwY of wild_X8v {
                   __DEFAULT ->
                     case w_s1hwU of { I# x_i1flD [Occ=Once] ->
                     case modInt# x_i1flD wild_X8v of ww2_s1hx2 { __DEFAULT ->
                     GHC.Types.I# ww2_s1hx2
                     }
                     };
                   -1# -> GHC.Types.I# 0#;
                   0# -> case divZeroError of { }
                 }
                 }}]
GHC.Real.$fIntegralInt_$cmod
  = \ (w_s1hwU :: Int) (w1_s1hwV :: Int) ->
      case w1_s1hwV of { I# ww1_s1hwY ->
      case ww1_s1hwY of wild_X8v {
        __DEFAULT ->
          case w_s1hwU of { I# x_i1flD ->
          case modInt# x_i1flD wild_X8v of ww2_s1hx2 { __DEFAULT ->
          GHC.Types.I# ww2_s1hx2
          }
          };
        -1# -> GHC.Real.$fIntegralInt1;
        0# -> case divZeroError of wild1_00 { }
      }
      }

-- RHS size: {terms: 22, types: 9, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInt_$crem :: Int -> Int -> Int
[GblId,
 Arity=2,
 Str=<L,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a1dPG [Occ=Once!] :: Int)
                 (b_a1dPH [Occ=Once!] :: Int) ->
                 case b_a1dPH of { I# x_a22G [Occ=Once!] ->
                 case x_a22G of wild1_X8z {
                   __DEFAULT ->
                     case a_a1dPG of { I# x1_i1fl7 [Occ=Once] ->
                     case remInt# x1_i1fl7 wild1_X8z of wild3_i1fld { __DEFAULT ->
                     GHC.Types.I# wild3_i1fld
                     }
                     };
                   -1# -> GHC.Real.$fIntegralInt1;
                   0# -> divZeroError @ Int
                 }
                 }}]
GHC.Real.$fIntegralInt_$crem
  = \ (a_a1dPG :: Int) (b_a1dPH :: Int) ->
      case b_a1dPH of { I# x_a22G ->
      case x_a22G of wild1_X8z {
        __DEFAULT ->
          case a_a1dPG of { I# x1_i1fl7 ->
          case remInt# x1_i1fl7 wild1_X8z of wild3_i1fld { __DEFAULT ->
          GHC.Types.I# wild3_i1fld
          }
          };
        -1# -> GHC.Real.$fIntegralInt1;
        0# -> divZeroError @ Int
      }
      }

-- RHS size: {terms: 12, types: 4, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInteger_$cquot [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Integer -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d1fj0 [Occ=Once] :: Integer) (ds1_d1fj1 :: Integer) ->
                 case eqInteger# ds1_d1fj1 0 of {
                   __DEFAULT -> quotInteger ds_d1fj0 ds1_d1fj1;
                   1# -> divZeroError @ Integer
                 }}]
GHC.Real.$fIntegralInteger_$cquot
  = \ (eta_B2 :: Integer) (eta1_B1 :: Integer) ->
      case eqInteger# eta1_B1 GHC.Real.even1 of {
        __DEFAULT -> quotInteger eta_B2 eta1_B1;
        1# -> divZeroError @ Integer
      }

-- RHS size: {terms: 12, types: 4, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInteger_$crem [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Integer -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d1fj6 [Occ=Once] :: Integer) (ds1_d1fj7 :: Integer) ->
                 case eqInteger# ds1_d1fj7 0 of {
                   __DEFAULT -> remInteger ds_d1fj6 ds1_d1fj7;
                   1# -> divZeroError @ Integer
                 }}]
GHC.Real.$fIntegralInteger_$crem
  = \ (eta_B2 :: Integer) (eta1_B1 :: Integer) ->
      case eqInteger# eta1_B1 GHC.Real.even1 of {
        __DEFAULT -> remInteger eta_B2 eta1_B1;
        1# -> divZeroError @ Integer
      }

-- RHS size: {terms: 12, types: 4, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInteger_$cdiv [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Integer -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d1fjc [Occ=Once] :: Integer) (ds1_d1fjd :: Integer) ->
                 case eqInteger# ds1_d1fjd 0 of {
                   __DEFAULT -> divInteger ds_d1fjc ds1_d1fjd;
                   1# -> divZeroError @ Integer
                 }}]
GHC.Real.$fIntegralInteger_$cdiv
  = \ (eta_B2 :: Integer) (eta1_B1 :: Integer) ->
      case eqInteger# eta1_B1 GHC.Real.even1 of {
        __DEFAULT -> divInteger eta_B2 eta1_B1;
        1# -> divZeroError @ Integer
      }

-- RHS size: {terms: 12, types: 4, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInteger_$cmod [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Integer -> Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d1fji [Occ=Once] :: Integer) (ds1_d1fjj :: Integer) ->
                 case eqInteger# ds1_d1fjj 0 of {
                   __DEFAULT -> modInteger ds_d1fji ds1_d1fjj;
                   1# -> divZeroError @ Integer
                 }}]
GHC.Real.$fIntegralInteger_$cmod
  = \ (eta_B2 :: Integer) (eta1_B1 :: Integer) ->
      case eqInteger# eta1_B1 GHC.Real.even1 of {
        __DEFAULT -> modInteger eta_B2 eta1_B1;
        1# -> divZeroError @ Integer
      }

-- RHS size: {terms: 17, types: 15, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInteger_$cquotRem [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Integer -> (Integer, Integer)
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d1fjo [Occ=Once] :: Integer) (ds1_d1fjp :: Integer) ->
                 case eqInteger# ds1_d1fjp 0 of {
                   __DEFAULT ->
                     case quotRemInteger ds_d1fjo ds1_d1fjp of
                     { (# ipv_s1fpa [Occ=Once], ipv1_s1fpb [Occ=Once] #) ->
                     (ipv_s1fpa, ipv1_s1fpb)
                     };
                   1# -> divZeroError @ (Integer, Integer)
                 }}]
GHC.Real.$fIntegralInteger_$cquotRem
  = \ (eta_B2 :: Integer) (eta1_B1 :: Integer) ->
      case eqInteger# eta1_B1 GHC.Real.even1 of {
        __DEFAULT ->
          case quotRemInteger eta_B2 eta1_B1 of
          { (# ipv_s1fp4, ipv1_s1fp5 #) ->
          (ipv_s1fp4, ipv1_s1fp5)
          };
        1# -> divZeroError @ (Integer, Integer)
      }

-- RHS size: {terms: 17, types: 15, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInteger_$cdivMod [InlPrag=INLINE (sat-args=2)]
  :: Integer -> Integer -> (Integer, Integer)
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d1fjz [Occ=Once] :: Integer) (ds1_d1fjA :: Integer) ->
                 case eqInteger# ds1_d1fjA 0 of {
                   __DEFAULT ->
                     case divModInteger ds_d1fjz ds1_d1fjA of
                     { (# ipv_s1fpm [Occ=Once], ipv1_s1fpn [Occ=Once] #) ->
                     (ipv_s1fpm, ipv1_s1fpn)
                     };
                   1# -> divZeroError @ (Integer, Integer)
                 }}]
GHC.Real.$fIntegralInteger_$cdivMod
  = \ (eta_B2 :: Integer) (eta1_B1 :: Integer) ->
      case eqInteger# eta1_B1 GHC.Real.even1 of {
        __DEFAULT ->
          case divModInteger eta_B2 eta1_B1 of
          { (# ipv_s1fpg, ipv1_s1fph #) ->
          (ipv_s1fpg, ipv1_s1fph)
          };
        1# -> divZeroError @ (Integer, Integer)
      }

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Integer
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Integer
                           GHC.Real.$fRealInteger
                           GHC.Enum.$fEnumInteger
                           GHC.Real.$fIntegralInteger_$cquot
                           GHC.Real.$fIntegralInteger_$crem
                           GHC.Real.$fIntegralInteger_$cdiv
                           GHC.Real.$fIntegralInteger_$cmod
                           GHC.Real.$fIntegralInteger_$cquotRem
                           GHC.Real.$fIntegralInteger_$cdivMod
                           GHC.Real.$fIntegralInteger_$ctoInteger]
GHC.Real.$fIntegralInteger
  = GHC.Real.C:Integral
      @ Integer
      GHC.Real.$fRealInteger
      GHC.Enum.$fEnumInteger
      GHC.Real.$fIntegralInteger_$cquot
      GHC.Real.$fIntegralInteger_$crem
      GHC.Real.$fIntegralInteger_$cdiv
      GHC.Real.$fIntegralInteger_$cmod
      GHC.Real.$fIntegralInteger_$cquotRem
      GHC.Real.$fIntegralInteger_$cdivMod
      GHC.Real.$fIntegralInteger_$ctoInteger

-- RHS size: {terms: 20, types: 9, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralWord_$cquot :: Word -> Word -> Word
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1fjL [Occ=Once!] :: Word)
                 (y_a1dPi [Occ=Once!] :: Word) ->
                 case ds_d1fjL of { W# x#_a1dPh [Occ=Once] ->
                 case y_a1dPi of { W# y#_a1dPj [Occ=Once!] ->
                 case y#_a1dPj of wild2_X8U {
                   __DEFAULT ->
                     case quotWord# x#_a1dPh wild2_X8U of wild3_Xx { __DEFAULT ->
                     GHC.Types.W# wild3_Xx
                     };
                   0## -> divZeroError @ Word
                 }
                 }
                 }}]
GHC.Real.$fIntegralWord_$cquot
  = \ (ds_d1fjL :: Word) (y_a1dPi :: Word) ->
      case ds_d1fjL of { W# x#_a1dPh ->
      case y_a1dPi of { W# y#_a1dPj ->
      case y#_a1dPj of wild2_X8U {
        __DEFAULT ->
          case quotWord# x#_a1dPh wild2_X8U of wild3_Xx { __DEFAULT ->
          GHC.Types.W# wild3_Xx
          };
        0## -> divZeroError @ Word
      }
      }
      }

-- RHS size: {terms: 20, types: 9, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralWord_$crem :: Word -> Word -> Word
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1fjU [Occ=Once!] :: Word)
                 (y_a1dPl [Occ=Once!] :: Word) ->
                 case ds_d1fjU of { W# x#_a1dPk [Occ=Once] ->
                 case y_a1dPl of { W# y#_a1dPm [Occ=Once!] ->
                 case y#_a1dPm of wild2_X8W {
                   __DEFAULT ->
                     case remWord# x#_a1dPk wild2_X8W of wild3_Xy { __DEFAULT ->
                     GHC.Types.W# wild3_Xy
                     };
                   0## -> divZeroError @ Word
                 }
                 }
                 }}]
GHC.Real.$fIntegralWord_$crem
  = \ (ds_d1fjU :: Word) (y_a1dPl :: Word) ->
      case ds_d1fjU of { W# x#_a1dPk ->
      case y_a1dPl of { W# y#_a1dPm ->
      case y#_a1dPm of wild2_X8W {
        __DEFAULT ->
          case remWord# x#_a1dPk wild2_X8W of wild3_Xy { __DEFAULT ->
          GHC.Types.W# wild3_Xy
          };
        0## -> divZeroError @ Word
      }
      }
      }

-- RHS size: {terms: 23, types: 19, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralWord_$cquotRem :: Word -> Word -> (Word, Word)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1fkl [Occ=Once!] :: Word)
                 (y_a1dPu [Occ=Once!] :: Word) ->
                 case ds_d1fkl of { W# x#_a1dPt [Occ=Once] ->
                 case y_a1dPu of { W# y#_a1dPv [Occ=Once!] ->
                 case y#_a1dPv of wild2_X92 {
                   __DEFAULT ->
                     case quotRemWord# x#_a1dPt wild2_X92 of
                     { (# ipv_s1fpJ [Occ=Once], ipv1_s1fpK [Occ=Once] #) ->
                     (GHC.Types.W# ipv_s1fpJ, GHC.Types.W# ipv1_s1fpK)
                     };
                   0## -> divZeroError @ (Word, Word)
                 }
                 }
                 }}]
GHC.Real.$fIntegralWord_$cquotRem
  = \ (ds_d1fkl :: Word) (y_a1dPu :: Word) ->
      case ds_d1fkl of { W# x#_a1dPt ->
      case y_a1dPu of { W# y#_a1dPv ->
      case y#_a1dPv of wild2_X92 {
        __DEFAULT ->
          case quotRemWord# x#_a1dPt wild2_X92 of
          { (# ipv_s1fpJ, ipv1_s1fpK #) ->
          (GHC.Types.W# ipv_s1fpJ, GHC.Types.W# ipv1_s1fpK)
          };
        0## -> divZeroError @ (Word, Word)
      }
      }
      }

-- RHS size: {terms: 28, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralWord_$cdivMod :: Word -> Word -> (Word, Word)
[GblId,
 Arity=2,
 Str=<S,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d1fkz [Occ=Once!] :: Word)
                 (y_a1dPz [Occ=Once!] :: Word) ->
                 case ds_d1fkz of { W# x#_a1dPy ->
                 case y_a1dPz of { W# y#_a1dPA [Occ=Once!] ->
                 case y#_a1dPA of wild2_X94 {
                   __DEFAULT ->
                     (case quotWord# x#_a1dPy wild2_X94 of wild3_XC { __DEFAULT ->
                      GHC.Types.W# wild3_XC
                      },
                      case remWord# x#_a1dPy wild2_X94 of wild3_XC { __DEFAULT ->
                      GHC.Types.W# wild3_XC
                      });
                   0## -> divZeroError @ (Word, Word)
                 }
                 }
                 }}]
GHC.Real.$fIntegralWord_$cdivMod
  = \ (ds_d1fkz :: Word) (y_a1dPz :: Word) ->
      case ds_d1fkz of { W# x#_a1dPy ->
      case y_a1dPz of { W# y#_a1dPA ->
      case y#_a1dPA of wild2_X94 {
        __DEFAULT ->
          (case quotWord# x#_a1dPy wild2_X94 of wild3_XC { __DEFAULT ->
           GHC.Types.W# wild3_XC
           },
           case remWord# x#_a1dPy wild2_X94 of wild3_XC { __DEFAULT ->
           GHC.Types.W# wild3_XC
           });
        0## -> divZeroError @ (Word, Word)
      }
      }
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
ratioZeroDenominatorError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x]
ratioZeroDenominatorError
  = \ (@ a_a1ewQ) ->
      raise#
        @ GHC.Exception.SomeException
        @ 'LiftedRep
        @ a_a1ewQ
        ratioZeroDenomException

-- RHS size: {terms: 32, types: 15, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$s$crecip [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hx4 [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hx4 of { :% ww1_s1hx7 ww2_s1hx8 [Occ=Once*] ->
                 case eqInteger# ww1_s1hx7 GHC.Real.even1 of {
                   __DEFAULT ->
                     case ltInteger# ww1_s1hx7 GHC.Real.even1 of {
                       __DEFAULT -> GHC.Real.:% @ Integer ww2_s1hx8 ww1_s1hx7;
                       1# ->
                         case negateInteger ww2_s1hx8 of dt_X1e17 { __DEFAULT ->
                         case negateInteger ww1_s1hx7 of dt1_X1e1c { __DEFAULT ->
                         GHC.Real.:% @ Integer dt_X1e17 dt1_X1e1c
                         }
                         }
                     };
                   1# -> case ratioZeroDenominatorError of { }
                 }
                 }}]
GHC.Real.$fFractionalRatio_$s$crecip
  = \ (w_s1hx4 :: Ratio Integer) ->
      case w_s1hx4 of { :% ww1_s1hx7 ww2_s1hx8 ->
      case eqInteger# ww1_s1hx7 GHC.Real.even1 of {
        __DEFAULT ->
          case ltInteger# ww1_s1hx7 GHC.Real.even1 of {
            __DEFAULT -> GHC.Real.:% @ Integer ww2_s1hx8 ww1_s1hx7;
            1# ->
              case negateInteger ww2_s1hx8 of dt_X1e17 { __DEFAULT ->
              case negateInteger ww1_s1hx7 of dt1_X1e1c { __DEFAULT ->
              GHC.Real.:% @ Integer dt_X1e17 dt1_X1e1c
              }
              }
          };
        1# -> case ratioZeroDenominatorError of wild1_00 { }
      }
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
overflowError [InlPrag=NOINLINE] :: forall a. a
[GblId, Str=x]
overflowError
  = \ (@ a_a1ewL) ->
      raise#
        @ GHC.Exception.SomeException
        @ 'LiftedRep
        @ a_a1ewL
        overflowException

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
lvl_r1j38 :: (Int, Int)
[GblId, Str=m, Unf=OtherCon []]
lvl_r1j38 = (overflowError @ Int, GHC.Real.$fIntegralInt1)

-- RHS size: {terms: 184, types: 99, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInt_$cdivMod [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int -> (Int, Int)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hxe [Occ=Once!] :: Int)
                 (w1_s1hxf [Occ=Once!] :: Int) ->
                 case w_s1hxe of { I# ww1_s1hxi ->
                 case w1_s1hxf of { I# ww3_s1hxm [Occ=Once!] ->
                 case ww3_s1hxm of wild_X98 {
                   __DEFAULT ->
                     case ># ww1_s1hxi 0# of {
                       __DEFAULT ->
                         case <# ww1_s1hxi 0# of {
                           __DEFAULT ->
                             case quotRemInt# ww1_s1hxi wild_X98 of
                             { (# ipv_i1fmn [Occ=Once], ipv1_i1fmo [Occ=Once] #) ->
                             (GHC.Types.I# ipv_i1fmn, GHC.Types.I# ipv1_i1fmo)
                             };
                           1# ->
                             case ># wild_X98 0# of {
                               __DEFAULT ->
                                 case quotRemInt# ww1_s1hxi wild_X98 of
                                 { (# ipv_i1fmt [Occ=Once], ipv1_i1fmu [Occ=Once] #) ->
                                 (GHC.Types.I# ipv_i1fmt, GHC.Types.I# ipv1_i1fmu)
                                 };
                               1# ->
                                 case quotRemInt# (+# ww1_s1hxi 1#) wild_X98 of
                                 { (# ipv_i1fmy [Occ=Once], ipv1_i1fmz [Occ=Once] #) ->
                                 (GHC.Types.I# (-# ipv_i1fmy 1#),
                                  GHC.Types.I# (-# (+# ipv1_i1fmz wild_X98) 1#))
                                 }
                             }
                         };
                       1# ->
                         case <# wild_X98 0# of {
                           __DEFAULT ->
                             case <# ww1_s1hxi 0# of {
                               __DEFAULT ->
                                 case quotRemInt# ww1_s1hxi wild_X98 of
                                 { (# ipv_i1fmF [Occ=Once], ipv1_i1fmG [Occ=Once] #) ->
                                 (GHC.Types.I# ipv_i1fmF, GHC.Types.I# ipv1_i1fmG)
                                 };
                               1# ->
                                 case ># wild_X98 0# of {
                                   __DEFAULT ->
                                     case quotRemInt# ww1_s1hxi wild_X98 of
                                     { (# ipv_i1fmL [Occ=Once], ipv1_i1fmM [Occ=Once] #) ->
                                     (GHC.Types.I# ipv_i1fmL, GHC.Types.I# ipv1_i1fmM)
                                     };
                                   1# ->
                                     case quotRemInt# (+# ww1_s1hxi 1#) wild_X98 of
                                     { (# ipv_i1fmQ [Occ=Once], ipv1_i1fmR [Occ=Once] #) ->
                                     (GHC.Types.I# (-# ipv_i1fmQ 1#),
                                      GHC.Types.I# (-# (+# ipv1_i1fmR wild_X98) 1#))
                                     }
                                 }
                             };
                           1# ->
                             case quotRemInt# (-# ww1_s1hxi 1#) wild_X98 of
                             { (# ipv_i1fmV [Occ=Once], ipv1_i1fmW [Occ=Once] #) ->
                             (GHC.Types.I# (-# ipv_i1fmV 1#),
                              GHC.Types.I# (+# (+# ipv1_i1fmW wild_X98) 1#))
                             }
                         }
                     };
                   -1# ->
                     case ww1_s1hxi of wild1_X9j {
                       __DEFAULT ->
                         case ># wild1_X9j 0# of {
                           __DEFAULT ->
                             case <# wild1_X9j 0# of {
                               __DEFAULT ->
                                 case quotRemInt# wild1_X9j -1# of
                                 { (# ipv_i1fmn [Occ=Once], ipv1_i1fmo [Occ=Once] #) ->
                                 (GHC.Types.I# ipv_i1fmn, GHC.Types.I# ipv1_i1fmo)
                                 };
                               1# ->
                                 case quotRemInt# wild1_X9j -1# of
                                 { (# ipv_i1fmt [Occ=Once], ipv1_i1fmu [Occ=Once] #) ->
                                 (GHC.Types.I# ipv_i1fmt, GHC.Types.I# ipv1_i1fmu)
                                 }
                             };
                           1# ->
                             case quotRemInt# (-# wild1_X9j 1#) -1# of
                             { (# ipv_i1fmV [Occ=Once], ipv1_i1fmW [Occ=Once] #) ->
                             (GHC.Types.I# (-# ipv_i1fmV 1#),
                              GHC.Types.I# (+# (+# ipv1_i1fmW -1#) 1#))
                             }
                         };
                       -9223372036854775808# ->
                         (overflowError @ Int, GHC.Real.$fIntegralInt1)
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Real.$fIntegralInt_$cdivMod
  = \ (w_s1hxe :: Int) (w1_s1hxf :: Int) ->
      case w_s1hxe of { I# ww1_s1hxi ->
      case w1_s1hxf of { I# ww3_s1hxm ->
      case ww3_s1hxm of wild_X98 {
        __DEFAULT ->
          case ># ww1_s1hxi 0# of {
            __DEFAULT ->
              case <# ww1_s1hxi 0# of {
                __DEFAULT ->
                  case quotRemInt# ww1_s1hxi wild_X98 of
                  { (# ipv_i1fmn, ipv1_i1fmo #) ->
                  (GHC.Types.I# ipv_i1fmn, GHC.Types.I# ipv1_i1fmo)
                  };
                1# ->
                  case ># wild_X98 0# of {
                    __DEFAULT ->
                      case quotRemInt# ww1_s1hxi wild_X98 of
                      { (# ipv_i1fmt, ipv1_i1fmu #) ->
                      (GHC.Types.I# ipv_i1fmt, GHC.Types.I# ipv1_i1fmu)
                      };
                    1# ->
                      case quotRemInt# (+# ww1_s1hxi 1#) wild_X98 of
                      { (# ipv_i1fmy, ipv1_i1fmz #) ->
                      (GHC.Types.I# (-# ipv_i1fmy 1#),
                       GHC.Types.I# (-# (+# ipv1_i1fmz wild_X98) 1#))
                      }
                  }
              };
            1# ->
              case <# wild_X98 0# of {
                __DEFAULT ->
                  case <# ww1_s1hxi 0# of {
                    __DEFAULT ->
                      case quotRemInt# ww1_s1hxi wild_X98 of
                      { (# ipv_i1fmF, ipv1_i1fmG #) ->
                      (GHC.Types.I# ipv_i1fmF, GHC.Types.I# ipv1_i1fmG)
                      };
                    1# ->
                      case ># wild_X98 0# of {
                        __DEFAULT ->
                          case quotRemInt# ww1_s1hxi wild_X98 of
                          { (# ipv_i1fmL, ipv1_i1fmM #) ->
                          (GHC.Types.I# ipv_i1fmL, GHC.Types.I# ipv1_i1fmM)
                          };
                        1# ->
                          case quotRemInt# (+# ww1_s1hxi 1#) wild_X98 of
                          { (# ipv_i1fmQ, ipv1_i1fmR #) ->
                          (GHC.Types.I# (-# ipv_i1fmQ 1#),
                           GHC.Types.I# (-# (+# ipv1_i1fmR wild_X98) 1#))
                          }
                      }
                  };
                1# ->
                  case quotRemInt# (-# ww1_s1hxi 1#) wild_X98 of
                  { (# ipv_i1fmV, ipv1_i1fmW #) ->
                  (GHC.Types.I# (-# ipv_i1fmV 1#),
                   GHC.Types.I# (+# (+# ipv1_i1fmW wild_X98) 1#))
                  }
              }
          };
        -1# ->
          case ww1_s1hxi of wild1_X9j {
            __DEFAULT ->
              case ># wild1_X9j 0# of {
                __DEFAULT ->
                  case quotRemInt# wild1_X9j -1# of { (# ipv_i1fmn, ipv1_i1fmo #) ->
                  (GHC.Types.I# ipv_i1fmn, GHC.Types.I# ipv1_i1fmo)
                  };
                1# ->
                  case quotRemInt# (-# wild1_X9j 1#) -1# of
                  { (# ipv_i1fmV, ipv1_i1fmW #) ->
                  (GHC.Types.I# (-# ipv_i1fmV 1#),
                   GHC.Types.I# (+# (+# ipv1_i1fmW -1#) 1#))
                  }
              };
            -9223372036854775808# -> lvl_r1j38
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 40, types: 29, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInt_$cquotRem [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int -> (Int, Int)
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hxs [Occ=Once!] :: Int)
                 (w1_s1hxt [Occ=Once!] :: Int) ->
                 case w_s1hxs of { I# ww1_s1hxw [Occ=Once*] ->
                 case w1_s1hxt of { I# ww3_s1hxA [Occ=Once!] ->
                 case ww3_s1hxA of wild_X9d {
                   __DEFAULT ->
                     case quotRemInt# ww1_s1hxw wild_X9d of
                     { (# ipv_i1fm1 [Occ=Once], ipv1_i1fm2 [Occ=Once] #) ->
                     (GHC.Types.I# ipv_i1fm1, GHC.Types.I# ipv1_i1fm2)
                     };
                   -1# ->
                     case ww1_s1hxw of wild1_X9p {
                       __DEFAULT ->
                         case quotRemInt# wild1_X9p -1# of
                         { (# ipv_i1fm1 [Occ=Once], ipv1_i1fm2 [Occ=Once] #) ->
                         (GHC.Types.I# ipv_i1fm1, GHC.Types.I# ipv1_i1fm2)
                         };
                       -9223372036854775808# ->
                         (overflowError @ Int, GHC.Real.$fIntegralInt1)
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Real.$fIntegralInt_$cquotRem
  = \ (w_s1hxs :: Int) (w1_s1hxt :: Int) ->
      case w_s1hxs of { I# ww1_s1hxw ->
      case w1_s1hxt of { I# ww3_s1hxA ->
      case ww3_s1hxA of wild_X9d {
        __DEFAULT ->
          case quotRemInt# ww1_s1hxw wild_X9d of
          { (# ipv_i1fm1, ipv1_i1fm2 #) ->
          (GHC.Types.I# ipv_i1fm1, GHC.Types.I# ipv1_i1fm2)
          };
        -1# ->
          case ww1_s1hxw of wild1_X9p {
            __DEFAULT ->
              case quotRemInt# wild1_X9p -1# of { (# ipv_i1fm1, ipv1_i1fm2 #) ->
              (GHC.Types.I# ipv_i1fm1, GHC.Types.I# ipv1_i1fm2)
              };
            -9223372036854775808# -> lvl_r1j38
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 21, types: 10, coercions: 0, joins: 0/0}
GHC.Real.$w$cdiv [InlPrag=NOUSERINLINE[0]] :: Int# -> Int# -> Int#
[GblId,
 Arity=2,
 Str=<S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 70] 110 0}]
GHC.Real.$w$cdiv
  = \ (ww_s1hxK :: Int#) (ww1_s1hxO :: Int#) ->
      case ww1_s1hxO of wild_X9g {
        __DEFAULT -> divInt# ww_s1hxK wild_X9g;
        -1# ->
          case ww_s1hxK of wild1_X9s {
            __DEFAULT -> divInt# wild1_X9s -1#;
            -9223372036854775808# -> case overflowError of wild2_00 { }
          };
        0# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInt_$cdiv [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hxG [Occ=Once!] :: Int)
                 (w1_s1hxH [Occ=Once!] :: Int) ->
                 case w_s1hxG of { I# ww1_s1hxK [Occ=Once] ->
                 case w1_s1hxH of { I# ww3_s1hxO [Occ=Once] ->
                 case GHC.Real.$w$cdiv ww1_s1hxK ww3_s1hxO of ww4_s1hxS
                 { __DEFAULT ->
                 GHC.Types.I# ww4_s1hxS
                 }
                 }
                 }}]
GHC.Real.$fIntegralInt_$cdiv
  = \ (w_s1hxG :: Int) (w1_s1hxH :: Int) ->
      case w_s1hxG of { I# ww1_s1hxK ->
      case w1_s1hxH of { I# ww3_s1hxO ->
      case GHC.Real.$w$cdiv ww1_s1hxK ww3_s1hxO of ww4_s1hxS
      { __DEFAULT ->
      GHC.Types.I# ww4_s1hxS
      }
      }
      }

-- RHS size: {terms: 32, types: 15, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInt_$cquot [InlPrag=NOUSERINLINE[0]]
  :: Int -> Int -> Int
[GblId,
 Arity=2,
 Str=<S(S),1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hxU [Occ=Once!] :: Int)
                 (w1_s1hxV [Occ=Once!] :: Int) ->
                 case w_s1hxU of { I# ww1_s1hxY [Occ=Once*] ->
                 case w1_s1hxV of { I# ww3_s1hy2 [Occ=Once!] ->
                 case ww3_s1hy2 of wild_X9j {
                   __DEFAULT ->
                     case quotInt# ww1_s1hxY wild_X9j of ww4_s1hy6 { __DEFAULT ->
                     GHC.Types.I# ww4_s1hy6
                     };
                   -1# ->
                     case ww1_s1hxY of wild1_X9v {
                       __DEFAULT -> GHC.Types.I# (quotInt# wild1_X9v -1#);
                       -9223372036854775808# -> case overflowError of { }
                     };
                   0# -> case divZeroError of { }
                 }
                 }
                 }}]
GHC.Real.$fIntegralInt_$cquot
  = \ (w_s1hxU :: Int) (w1_s1hxV :: Int) ->
      case w_s1hxU of { I# ww1_s1hxY ->
      case w1_s1hxV of { I# ww3_s1hy2 ->
      case ww3_s1hy2 of wild_X9j {
        __DEFAULT ->
          case quotInt# ww1_s1hxY wild_X9j of ww4_s1hy6 { __DEFAULT ->
          GHC.Types.I# ww4_s1hy6
          };
        -1# ->
          case ww1_s1hxY of wild1_X9v {
            __DEFAULT -> GHC.Types.I# (quotInt# wild1_X9v -1#);
            -9223372036854775808# -> case overflowError of wild2_00 { }
          };
        0# -> case divZeroError of wild1_00 { }
      }
      }
      }

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Int
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Int
                           GHC.Real.$fRealInt
                           GHC.Enum.$fEnumInt
                           GHC.Real.$fIntegralInt_$cquot
                           GHC.Real.$fIntegralInt_$crem
                           GHC.Real.$fIntegralInt_$cdiv
                           GHC.Real.$fIntegralInt_$cmod
                           GHC.Real.$fIntegralInt_$cquotRem
                           GHC.Real.$fIntegralInt_$cdivMod
                           GHC.Real.$fIntegralInt_$ctoInteger]
GHC.Real.$fIntegralInt
  = GHC.Real.C:Integral
      @ Int
      GHC.Real.$fRealInt
      GHC.Enum.$fEnumInt
      GHC.Real.$fIntegralInt_$cquot
      GHC.Real.$fIntegralInt_$crem
      GHC.Real.$fIntegralInt_$cdiv
      GHC.Real.$fIntegralInt_$cmod
      GHC.Real.$fIntegralInt_$cquotRem
      GHC.Real.$fIntegralInt_$cdivMod
      GHC.Real.$fIntegralInt_$ctoInteger

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl1_r1j39 :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl1_r1j39 = GHC.Types.I# -1#

Rec {
-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
lvl2_r1j3a :: Int
[GblId]
lvl2_r1j3a = GHC.Real.$wgcd' lvl1_r1j39 0#

-- RHS size: {terms: 21, types: 6, coercions: 0, joins: 0/0}
GHC.Real.$wgcd' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Int -> Int# -> Int
[GblId, Arity=2, Str=<L,1*U(U)><S,1*U>, Unf=OtherCon []]
GHC.Real.$wgcd'
  = \ (w_s1hy8 :: Int) (ww_s1hyc :: Int#) ->
      case ww_s1hyc of wild_X9n {
        __DEFAULT ->
          case w_s1hy8 of { I# x_i1fl7 ->
          case remInt# x_i1fl7 wild_X9n of wild2_i1fld { __DEFAULT ->
          GHC.Real.$wgcd' (GHC.Types.I# wild_X9n) wild2_i1fld
          }
          };
        -1# -> lvl2_r1j3a;
        0# -> w_s1hy8
      }
end Rec }

Rec {
-- RHS size: {terms: 14, types: 3, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_gcd' [Occ=LoopBreaker]
  :: Integer -> Integer -> Integer
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []]
GHC.Real.$fEnumRatio_gcd'
  = \ (a_a1dR1 :: Integer) (ds_d1f3F :: Integer) ->
      case eqInteger# ds_d1f3F GHC.Real.even1 of {
        __DEFAULT ->
          GHC.Real.$fEnumRatio_gcd' ds_d1f3F (remInteger a_a1dR1 ds_d1f3F);
        1# -> a_a1dR1
      }
end Rec }

-- RHS size: {terms: 45, types: 31, coercions: 0, joins: 1/6}
gcd [InlPrag=NOINLINE[1]] :: forall a. Integral a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(U(A,A,A,A,C(U),A,1*C1(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 352 0}]
gcd
  = \ (@ a_a1eor)
      ($dIntegral_a1eot :: Integral a_a1eor)
      (eta_B2 :: a_a1eor)
      (eta1_B1 :: a_a1eor) ->
      let {
        $dReal_s1fVl [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(U(A,A,A,A,C(U),A,1*C1(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real a_a1eor
        [LclId]
        $dReal_s1fVl = GHC.Real.$p1Integral @ a_a1eor $dIntegral_a1eot } in
      let {
        lvl8_s1fZn :: a_a1eor
        [LclId]
        lvl8_s1fZn
          = fromInteger
              @ a_a1eor
              (GHC.Real.$p1Real @ a_a1eor $dReal_s1fVl)
              GHC.Real.even1 } in
      let {
        $dEq_s1fVj [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
          :: Ord a_a1eor
        [LclId]
        $dEq_s1fVj = GHC.Real.$p2Real @ a_a1eor $dReal_s1fVl } in
      let {
        $dEq1_s1fVi [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_a1eor
        [LclId]
        $dEq1_s1fVi = GHC.Classes.$p1Ord @ a_a1eor $dEq_s1fVj } in
      let {
        $dNum_s1fVm [Dmd=<L,U(A,A,A,A,C(U),A,A)>] :: Num a_a1eor
        [LclId]
        $dNum_s1fVm = GHC.Real.$p1Real @ a_a1eor $dReal_s1fVl } in
      joinrec {
        gcd'_s1fVh [Occ=LoopBreaker] :: a_a1eor -> a_a1eor -> a_a1eor
        [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []]
        gcd'_s1fVh (a1_a1dR1 :: a_a1eor) (ds_d1f3F :: a_a1eor)
          = case == @ a_a1eor $dEq1_s1fVi ds_d1f3F lvl8_s1fZn of {
              False ->
                jump gcd'_s1fVh
                  ds_d1f3F (rem @ a_a1eor $dIntegral_a1eot a1_a1dR1 ds_d1f3F);
              True -> a1_a1dR1
            }; } in
      jump gcd'_s1fVh
        (abs @ a_a1eor $dNum_s1fVm eta_B2)
        (abs @ a_a1eor $dNum_s1fVm eta1_B1)

-- RHS size: {terms: 37, types: 17, coercions: 0, joins: 0/1}
GHC.Real.$w$sreduce [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Integer -> (# Integer, Integer #)
[GblId,
 Arity=2,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 260 30}]
GHC.Real.$w$sreduce
  = \ (w_s1hyw :: Integer) (w1_s1hyx :: Integer) ->
      case eqInteger# w1_s1hyx GHC.Real.even1 of {
        __DEFAULT ->
          let {
            d_s1fUC [Dmd=<S,U>] :: Integer
            [LclId]
            d_s1fUC
              = GHC.Real.$fEnumRatio_gcd'
                  (absInteger w_s1hyw) (absInteger w1_s1hyx) } in
          case eqInteger# d_s1fUC GHC.Real.even1 of wild1_X1fzB {
            __DEFAULT ->
              case quotInteger w_s1hyw d_s1fUC of dt_X1e1z { __DEFAULT ->
              case quotInteger w1_s1hyx d_s1fUC of dt1_X1e1H { __DEFAULT ->
              (# dt_X1e1z, dt1_X1e1H #)
              }
              };
            1# -> case divZeroError of wild2_00 { }
          };
        1# -> case ratioZeroDenominatorError of wild1_00 { }
      }

-- RHS size: {terms: 10, types: 10, coercions: 0, joins: 0/0}
GHC.Real.reduce_$sreduce [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Integer -> Ratio Integer
[GblId,
 Arity=2,
 Str=<S,U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hyw [Occ=Once] :: Integer)
                 (w1_s1hyx [Occ=Once] :: Integer) ->
                 case GHC.Real.$w$sreduce w_s1hyw w1_s1hyx of
                 { (# ww1_s1hKK [Occ=Once], ww2_s1hKL [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww1_s1hKK ww2_s1hKL
                 }}]
GHC.Real.reduce_$sreduce
  = \ (w_s1hyw :: Integer) (w1_s1hyx :: Integer) ->
      case GHC.Real.$w$sreduce w_s1hyw w1_s1hyx of
      { (# ww1_s1hKK, ww2_s1hKL #) ->
      GHC.Real.:% @ Integer ww1_s1hKK ww2_s1hKL
      }

-- RHS size: {terms: 15, types: 11, coercions: 0, joins: 0/0}
GHC.Real.$fRealWord_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: Word -> Rational
[GblId,
 Arity=1,
 Str=<S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hyC [Occ=Once!] :: Word) ->
                 case w_s1hyC of { W# ww1_s1hyF [Occ=Once] ->
                 case GHC.Real.$w$sreduce
                        (timesInteger (wordToInteger ww1_s1hyF) GHC.Real.$fEnumRatio1)
                        GHC.Real.$fEnumRatio1
                 of
                 { (# ww3_s1hKN [Occ=Once], ww4_s1hKO [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww3_s1hKN ww4_s1hKO
                 }
                 }}]
GHC.Real.$fRealWord_$ctoRational
  = \ (w_s1hyC :: Word) ->
      case w_s1hyC of { W# ww1_s1hyF ->
      case GHC.Real.$w$sreduce
             (timesInteger (wordToInteger ww1_s1hyF) GHC.Real.$fEnumRatio1)
             GHC.Real.$fEnumRatio1
      of
      { (# ww3_s1hKN, ww4_s1hKO #) ->
      GHC.Real.:% @ Integer ww3_s1hKN ww4_s1hKO
      }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Real.$fRealWord [InlPrag=NOUSERINLINE CONLIKE] :: Real Word
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Word
                       GHC.Num.$fNumWord
                       GHC.Classes.$fOrdWord
                       GHC.Real.$fRealWord_$ctoRational]
GHC.Real.$fRealWord
  = GHC.Real.C:Real
      @ Word
      GHC.Num.$fNumWord
      GHC.Classes.$fOrdWord
      GHC.Real.$fRealWord_$ctoRational

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
GHC.Real.$fIntegralWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral Word
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: Word
                           GHC.Real.$fRealWord
                           GHC.Enum.$fEnumWord
                           GHC.Real.$fIntegralWord_$cquot
                           GHC.Real.$fIntegralWord_$crem
                           GHC.Real.$fIntegralWord_$cquot
                           GHC.Real.$fIntegralWord_$crem
                           GHC.Real.$fIntegralWord_$cquotRem
                           GHC.Real.$fIntegralWord_$cdivMod
                           GHC.Real.$fIntegralWord_$ctoInteger]
GHC.Real.$fIntegralWord
  = GHC.Real.C:Integral
      @ Word
      GHC.Real.$fRealWord
      GHC.Enum.$fEnumWord
      GHC.Real.$fIntegralWord_$cquot
      GHC.Real.$fIntegralWord_$crem
      GHC.Real.$fIntegralWord_$cquot
      GHC.Real.$fIntegralWord_$crem
      GHC.Real.$fIntegralWord_$cquotRem
      GHC.Real.$fIntegralWord_$cdivMod
      GHC.Real.$fIntegralWord_$ctoInteger

-- RHS size: {terms: 20, types: 20, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$s$c* [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer -> Ratio Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hyL [Occ=Once!] :: Ratio Integer)
                 (w1_s1hyM [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hyL of { :% ww1_s1hyP [Occ=Once] ww2_s1hyQ [Occ=Once] ->
                 case w1_s1hyM of { :% ww4_s1hyU [Occ=Once] ww5_s1hyV [Occ=Once] ->
                 case GHC.Real.$w$sreduce
                        (timesInteger ww1_s1hyP ww4_s1hyU)
                        (timesInteger ww2_s1hyQ ww5_s1hyV)
                 of
                 { (# ww7_s1hKQ [Occ=Once], ww8_s1hKR [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww7_s1hKQ ww8_s1hKR
                 }
                 }
                 }}]
GHC.Real.$fFractionalRatio_$s$c*
  = \ (w_s1hyL :: Ratio Integer) (w1_s1hyM :: Ratio Integer) ->
      case w_s1hyL of { :% ww1_s1hyP ww2_s1hyQ ->
      case w1_s1hyM of { :% ww4_s1hyU ww5_s1hyV ->
      case GHC.Real.$w$sreduce
             (timesInteger ww1_s1hyP ww4_s1hyU)
             (timesInteger ww2_s1hyQ ww5_s1hyV)
      of
      { (# ww7_s1hKQ, ww8_s1hKR #) ->
      GHC.Real.:% @ Integer ww7_s1hKQ ww8_s1hKR
      }
      }
      }

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Real.$w$s$c- [InlPrag=NOUSERINLINE[0]]
  :: Integer
     -> Integer -> Integer -> Integer -> (# Integer, Integer #)
[GblId,
 Arity=4,
 Str=<S,1*U><S,U><S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 150 0}]
GHC.Real.$w$s$c-
  = \ (ww_s1hz5
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hz6
         :: Integer
         Unf=OtherCon [])
      (ww2_s1hza
         :: Integer
         Unf=OtherCon [])
      (ww3_s1hzb
         :: Integer
         Unf=OtherCon []) ->
      GHC.Real.$w$sreduce
        (minusInteger
           (timesInteger ww_s1hz5 ww3_s1hzb)
           (timesInteger ww2_s1hza ww1_s1hz6))
        (timesInteger ww1_s1hz6 ww3_s1hzb)

-- RHS size: {terms: 18, types: 20, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$s$c- [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer -> Ratio Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hz1 [Occ=Once!] :: Ratio Integer)
                 (w1_s1hz2 [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hz1 of { :% ww1_s1hz5 [Occ=Once] ww2_s1hz6 [Occ=Once] ->
                 case w1_s1hz2 of { :% ww4_s1hza [Occ=Once] ww5_s1hzb [Occ=Once] ->
                 case GHC.Real.$w$s$c- ww1_s1hz5 ww2_s1hz6 ww4_s1hza ww5_s1hzb of
                 { (# ww7_s1hKT [Occ=Once], ww8_s1hKU [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww7_s1hKT ww8_s1hKU
                 }
                 }
                 }}]
GHC.Real.$fEnumRatio_$s$c-
  = \ (w_s1hz1 :: Ratio Integer) (w1_s1hz2 :: Ratio Integer) ->
      case w_s1hz1 of { :% ww1_s1hz5 ww2_s1hz6 ->
      case w1_s1hz2 of { :% ww4_s1hza ww5_s1hzb ->
      case GHC.Real.$w$s$c- ww1_s1hz5 ww2_s1hz6 ww4_s1hza ww5_s1hzb of
      { (# ww7_s1hKT, ww8_s1hKU #) ->
      GHC.Real.:% @ Integer ww7_s1hKT ww8_s1hKU
      }
      }
      }

-- RHS size: {terms: 15, types: 4, coercions: 0, joins: 0/0}
GHC.Real.$w$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: Integer
     -> Integer -> Integer -> Integer -> (# Integer, Integer #)
[GblId,
 Arity=4,
 Str=<S,1*U><S,U><S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 150 0}]
GHC.Real.$w$s$c+
  = \ (ww_s1hzl
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hzm
         :: Integer
         Unf=OtherCon [])
      (ww2_s1hzq
         :: Integer
         Unf=OtherCon [])
      (ww3_s1hzr
         :: Integer
         Unf=OtherCon []) ->
      GHC.Real.$w$sreduce
        (plusInteger
           (timesInteger ww_s1hzl ww3_s1hzr)
           (timesInteger ww2_s1hzq ww1_s1hzm))
        (timesInteger ww1_s1hzm ww3_s1hzr)

-- RHS size: {terms: 18, types: 20, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$s$c+ [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer -> Ratio Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hzh [Occ=Once!] :: Ratio Integer)
                 (w1_s1hzi [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hzh of { :% ww1_s1hzl [Occ=Once] ww2_s1hzm [Occ=Once] ->
                 case w1_s1hzi of { :% ww4_s1hzq [Occ=Once] ww5_s1hzr [Occ=Once] ->
                 case GHC.Real.$w$s$c+ ww1_s1hzl ww2_s1hzm ww4_s1hzq ww5_s1hzr of
                 { (# ww7_s1hKW [Occ=Once], ww8_s1hKX [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww7_s1hKW ww8_s1hKX
                 }
                 }
                 }}]
GHC.Real.$fEnumRatio_$s$c+
  = \ (w_s1hzh :: Ratio Integer) (w1_s1hzi :: Ratio Integer) ->
      case w_s1hzh of { :% ww1_s1hzl ww2_s1hzm ->
      case w1_s1hzi of { :% ww4_s1hzq ww5_s1hzr ->
      case GHC.Real.$w$s$c+ ww1_s1hzl ww2_s1hzm ww4_s1hzq ww5_s1hzr of
      { (# ww7_s1hKW, ww8_s1hKX #) ->
      GHC.Real.:% @ Integer ww7_s1hKW ww8_s1hKX
      }
      }
      }

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$s$fNumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: Num (Ratio Integer)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: Ratio Integer
                     GHC.Real.$fEnumRatio_$s$c+
                     GHC.Real.$fEnumRatio_$s$c-
                     GHC.Real.$fFractionalRatio_$s$c*
                     GHC.Real.$fFractionalRatio_$s$cnegate
                     GHC.Real.$fFractionalRatio_$s$cabs
                     GHC.Real.$fFractionalRatio_$s$csignum
                     GHC.Real.$fFractionalRatio_$s$cfromInteger]
GHC.Real.$fFractionalRatio_$s$fNumRatio
  = GHC.Num.C:Num
      @ (Ratio Integer)
      GHC.Real.$fEnumRatio_$s$c+
      GHC.Real.$fEnumRatio_$s$c-
      GHC.Real.$fFractionalRatio_$s$c*
      GHC.Real.$fFractionalRatio_$s$cnegate
      GHC.Real.$fFractionalRatio_$s$cabs
      GHC.Real.$fFractionalRatio_$s$csignum
      GHC.Real.$fFractionalRatio_$s$cfromInteger

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
GHC.Real.$w$s$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Integer -> (# Integer, Integer #)
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 0}]
GHC.Real.$w$s$cfromRational
  = \ (ww_s1hzA
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hzB
         :: Integer
         Unf=OtherCon []) ->
      GHC.Real.$w$sreduce
        (timesInteger ww_s1hzA (signumInteger ww1_s1hzB))
        (absInteger ww1_s1hzB)

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$s$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: Rational -> Ratio Integer
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hzx [Occ=Once!] :: Rational) ->
                 case w_s1hzx of { :% ww1_s1hzA [Occ=Once] ww2_s1hzB [Occ=Once] ->
                 case GHC.Real.$w$s$cfromRational ww1_s1hzA ww2_s1hzB of
                 { (# ww4_s1hKZ [Occ=Once], ww5_s1hL0 [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww4_s1hKZ ww5_s1hL0
                 }
                 }}]
GHC.Real.$fFractionalRatio_$s$cfromRational
  = \ (w_s1hzx :: Rational) ->
      case w_s1hzx of { :% ww1_s1hzA ww2_s1hzB ->
      case GHC.Real.$w$s$cfromRational ww1_s1hzA ww2_s1hzB of
      { (# ww4_s1hKZ, ww5_s1hL0 #) ->
      GHC.Real.:% @ Integer ww4_s1hKZ ww5_s1hL0
      }
      }

-- RHS size: {terms: 17, types: 5, coercions: 0, joins: 0/1}
GHC.Real.$w$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: Integer
     -> Integer -> Integer -> Integer -> (# Integer, Integer #)
[GblId,
 Arity=4,
 Str=<S,1*U><S,1*U><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 170 0}]
GHC.Real.$w$s$c/
  = \ (ww_X1hIT
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hzM
         :: Integer
         Unf=OtherCon [])
      (ww2_X1hJ0
         :: Integer
         Unf=OtherCon [])
      (ww3_s1hzR
         :: Integer
         Unf=OtherCon []) ->
      let {
        y_s1fUs [Dmd=<S,U>] :: Integer
        [LclId]
        y_s1fUs = timesInteger ww1_s1hzM ww2_X1hJ0 } in
      GHC.Real.$w$sreduce
        (timesInteger
           (timesInteger ww_X1hIT ww3_s1hzR) (signumInteger y_s1fUs))
        (absInteger y_s1fUs)

-- RHS size: {terms: 18, types: 20, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$s$c/ [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer -> Ratio Integer
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hzH [Occ=Once!] :: Ratio Integer)
                 (w1_s1hzI [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hzH of { :% ww1_X1hIY [Occ=Once] ww2_s1hzM [Occ=Once] ->
                 case w1_s1hzI of { :% ww4_X1hJ9 [Occ=Once] ww5_s1hzR [Occ=Once] ->
                 case GHC.Real.$w$s$c/ ww1_X1hIY ww2_s1hzM ww4_X1hJ9 ww5_s1hzR of
                 { (# ww7_s1hL2 [Occ=Once], ww8_s1hL3 [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww7_s1hL2 ww8_s1hL3
                 }
                 }
                 }}]
GHC.Real.$fFractionalRatio_$s$c/
  = \ (w_s1hzH :: Ratio Integer) (w1_s1hzI :: Ratio Integer) ->
      case w_s1hzH of { :% ww1_X1hIY ww2_s1hzM ->
      case w1_s1hzI of { :% ww4_X1hJ9 ww5_s1hzR ->
      case GHC.Real.$w$s$c/ ww1_X1hIY ww2_s1hzM ww4_X1hJ9 ww5_s1hzR of
      { (# ww7_s1hL2, ww8_s1hL3 #) ->
      GHC.Real.:% @ Integer ww7_s1hL2 ww8_s1hL3
      }
      }
      }

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$s$fFractionalRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: Fractional (Ratio Integer)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Fractional TYPE: Ratio Integer
                             GHC.Real.$fFractionalRatio_$s$fNumRatio
                             GHC.Real.$fFractionalRatio_$s$c/
                             GHC.Real.$fFractionalRatio_$s$crecip
                             GHC.Real.$fFractionalRatio_$s$cfromRational]
GHC.Real.$fFractionalRatio_$s$fFractionalRatio
  = GHC.Real.C:Fractional
      @ (Ratio Integer)
      GHC.Real.$fFractionalRatio_$s$fNumRatio
      GHC.Real.$fFractionalRatio_$s$c/
      GHC.Real.$fFractionalRatio_$s$crecip
      GHC.Real.$fFractionalRatio_$s$cfromRational

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
ratioPrec :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
ratioPrec = GHC.Types.I# 7#

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
infinity :: Rational
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
infinity
  = GHC.Real.:% @ Integer GHC.Real.$fEnumRatio1 GHC.Real.even1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
notANumber :: Rational
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
notANumber = GHC.Real.:% @ Integer GHC.Real.even1 GHC.Real.even1

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
numerator :: forall a. Ratio a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1ewr) (ds_d1f6r [Occ=Once!] :: Ratio a_a1ewr) ->
                 case ds_d1f6r of { :% x_a1dQp [Occ=Once] _ [Occ=Dead] ->
                 x_a1dQp
                 }}]
numerator
  = \ (@ a_a1ewr) (ds_d1f6r :: Ratio a_a1ewr) ->
      case ds_d1f6r of { :% x_a1dQp ds1_d1f6x -> x_a1dQp }

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
denominator :: forall a. Ratio a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1ewp) (ds_d1f6j [Occ=Once!] :: Ratio a_a1ewp) ->
                 case ds_d1f6j of { :% _ [Occ=Dead] y_a1dQq [Occ=Once] ->
                 y_a1dQq
                 }}]
denominator
  = \ (@ a_a1ewp) (ds_d1f6j :: Ratio a_a1ewp) ->
      case ds_d1f6j of { :% ds1_d1f6p y_a1dQq -> y_a1dQq }

Rec {
-- RHS size: {terms: 21, types: 32, coercions: 0, joins: 0/0}
GHC.Real.$w$snumericEnumFrom [InlPrag=NOUSERINLINE[0],
                              Occ=LoopBreaker]
  :: Integer -> Integer -> (# Ratio Integer, [Ratio Integer] #)
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []]
GHC.Real.$w$snumericEnumFrom
  = \ (ww_s1hA0
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hA1
         :: Integer
         Unf=OtherCon []) ->
      (# GHC.Real.:% @ Integer ww_s1hA0 ww1_s1hA1,
         case GHC.Real.$w$s$c+
                ww_s1hA0 ww1_s1hA1 GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
         of
         { (# ww3_s1hKW, ww4_s1hKX #) ->
         case GHC.Real.$w$snumericEnumFrom ww3_s1hKW ww4_s1hKX of
         { (# ww6_s1hL5, ww7_s1hL6 #) ->
         GHC.Types.: @ (Ratio Integer) ww6_s1hL5 ww7_s1hL6
         }
         } #)
end Rec }

-- RHS size: {terms: 12, types: 21, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$snumericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> [Ratio Integer]
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hzX [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hzX of { :% ww1_s1hA0 [Occ=Once] ww2_s1hA1 [Occ=Once] ->
                 case GHC.Real.$w$snumericEnumFrom ww1_s1hA0 ww2_s1hA1 of
                 { (# ww4_s1hL5 [Occ=Once], ww5_s1hL6 [Occ=Once] #) ->
                 GHC.Types.: @ (Ratio Integer) ww4_s1hL5 ww5_s1hL6
                 }
                 }}]
GHC.Real.$fEnumRatio_$snumericEnumFrom
  = \ (w_s1hzX :: Ratio Integer) ->
      case w_s1hzX of { :% ww1_s1hA0 ww2_s1hA1 ->
      case GHC.Real.$w$snumericEnumFrom ww1_s1hA0 ww2_s1hA1 of
      { (# ww4_s1hL5, ww5_s1hL6 #) ->
      GHC.Types.: @ (Ratio Integer) ww4_s1hL5 ww5_s1hL6
      }
      }

Rec {
-- RHS size: {terms: 24, types: 27, coercions: 0, joins: 0/1}
GHC.Real.$wnumericEnumFrom [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: forall a. Fractional a => a -> (# a, [a] #)
[GblId,
 Arity=2,
 Str=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)><S,1*U>,
 Unf=OtherCon []]
GHC.Real.$wnumericEnumFrom
  = \ (@ a_s1hA7)
      (w_s1hA8 :: Fractional a_s1hA7)
      (w1_s1hA9 :: a_s1hA7) ->
      case w1_s1hA9 of n_X1dR9 { __DEFAULT ->
      (# n_X1dR9,
         let {
           $dNum_s1fXr [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
             :: Num a_s1hA7
           [LclId]
           $dNum_s1fXr = GHC.Real.$p1Fractional @ a_s1hA7 w_s1hA8 } in
         case GHC.Real.$wnumericEnumFrom
                @ a_s1hA7
                w_s1hA8
                (+ @ a_s1hA7
                   $dNum_s1fXr
                   n_X1dR9
                   (fromInteger @ a_s1hA7 $dNum_s1fXr GHC.Real.$fEnumRatio1))
         of
         { (# ww1_s1hL8, ww2_s1hL9 #) ->
         GHC.Types.: @ a_s1hA7 ww1_s1hL8 ww2_s1hL9
         } #)
      }
end Rec }

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
numericEnumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall a. Fractional a => a -> [a]
[GblId,
 Arity=2,
 Str=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)><S,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hA7)
                 (w_s1hA8 [Occ=Once] :: Fractional a_s1hA7)
                 (w1_s1hA9 [Occ=Once] :: a_s1hA7) ->
                 case GHC.Real.$wnumericEnumFrom @ a_s1hA7 w_s1hA8 w1_s1hA9 of
                 { (# ww1_s1hL8 [Occ=Once], ww2_s1hL9 [Occ=Once] #) ->
                 GHC.Types.: @ a_s1hA7 ww1_s1hL8 ww2_s1hL9
                 }}]
numericEnumFrom
  = \ (@ a_s1hA7)
      (w_s1hA8 :: Fractional a_s1hA7)
      (w1_s1hA9 :: a_s1hA7) ->
      case GHC.Real.$wnumericEnumFrom @ a_s1hA7 w_s1hA8 w1_s1hA9 of
      { (# ww1_s1hL8, ww2_s1hL9 #) ->
      GHC.Types.: @ a_s1hA7 ww1_s1hL8 ww2_s1hL9
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.even2 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Real.even2 = 2

-- RHS size: {terms: 10, types: 8, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio2 :: Ratio Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 70 30}]
GHC.Real.$fEnumRatio2
  = case GHC.Real.$w$s$c/
           GHC.Real.$fEnumRatio1
           GHC.Real.$fEnumRatio1
           GHC.Real.even2
           GHC.Real.$fEnumRatio1
    of
    { (# ww1_s1hL2, ww2_s1hL3 #) ->
    GHC.Real.:% @ Integer ww1_s1hL2 ww2_s1hL3
    }

-- RHS size: {terms: 33, types: 41, coercions: 0, joins: 0/1}
GHC.Real.$w$snumericEnumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Integer -> Ratio Integer -> [Ratio Integer]
[GblId,
 Arity=3,
 Str=<L,U><L,U><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 20] 220 0}]
GHC.Real.$w$snumericEnumFromTo
  = \ (ww_s1hAi
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hAj
         :: Integer
         Unf=OtherCon [])
      (w_s1hAf :: Ratio Integer) ->
      case GHC.Real.$w$snumericEnumFrom ww_s1hAi ww1_s1hAj of
      { (# ww3_s1hL5, ww4_s1hL6 #) ->
      takeWhile
        @ (Ratio Integer)
        (let {
           ds_s1fXn [Dmd=<L,U(U,U)>] :: Ratio Integer
           [LclId]
           ds_s1fXn
             = case w_s1hAf of { :% ww6_s1hzl ww7_s1hzm ->
               case GHC.Real.$fEnumRatio2 of { :% ww9_s1hzq ww10_s1hzr ->
               case GHC.Real.$w$s$c+ ww6_s1hzl ww7_s1hzm ww9_s1hzq ww10_s1hzr of
               { (# ww12_s1hKW, ww13_s1hKX #) ->
               GHC.Real.:% @ Integer ww12_s1hKW ww13_s1hKX
               }
               }
               } } in
         \ (ds1_d1f6e :: Ratio Integer) ->
           GHC.Real.$fEnumRatio_$s$c<= ds1_d1f6e ds_s1fXn)
        (GHC.Types.: @ (Ratio Integer) ww3_s1hL5 ww4_s1hL6)
      }

-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$snumericEnumFromTo [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer -> [Ratio Integer]
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><L,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hAe [Occ=Once!] :: Ratio Integer)
                 (w1_s1hAf [Occ=Once] :: Ratio Integer) ->
                 case w_s1hAe of { :% ww1_s1hAi [Occ=Once] ww2_s1hAj [Occ=Once] ->
                 GHC.Real.$w$snumericEnumFromTo ww1_s1hAi ww2_s1hAj w1_s1hAf
                 }}]
GHC.Real.$fEnumRatio_$snumericEnumFromTo
  = \ (w_s1hAe :: Ratio Integer) (w1_s1hAf :: Ratio Integer) ->
      case w_s1hAe of { :% ww1_s1hAi ww2_s1hAj ->
      GHC.Real.$w$snumericEnumFromTo ww1_s1hAi ww2_s1hAj w1_s1hAf
      }

-- RHS size: {terms: 34, types: 30, coercions: 0, joins: 0/2}
numericEnumFromTo
  :: forall a. (Ord a, Fractional a) => a -> a -> [a]
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(U(C(C1(U)),A,A,A,A,A,C(U)),1*C1(C1(U)),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 0 0] 310 0}]
numericEnumFromTo
  = \ (@ a_a1ew7)
      ($dOrd_a1ew9 :: Ord a_a1ew7)
      ($dFractional_a1ewa :: Fractional a_a1ew7)
      (eta_B2 :: a_a1ew7)
      (eta1_B1 :: a_a1ew7) ->
      case GHC.Real.$wnumericEnumFrom @ a_a1ew7 $dFractional_a1ewa eta_B2
      of
      { (# ww1_s1hL8, ww2_s1hL9 #) ->
      let {
        $dNum_s1fXe [Dmd=<L,U(1*C1(C1(U)),A,A,A,A,A,C(U))>] :: Num a_a1ew7
        [LclId]
        $dNum_s1fXe
          = GHC.Real.$p1Fractional @ a_a1ew7 $dFractional_a1ewa } in
      takeWhile
        @ a_a1ew7
        (let {
           ds_s1fXg :: a_a1ew7
           [LclId]
           ds_s1fXg
             = + @ a_a1ew7
                 $dNum_s1fXe
                 eta1_B1
                 (/ @ a_a1ew7
                    $dFractional_a1ewa
                    (fromInteger @ a_a1ew7 $dNum_s1fXe GHC.Real.$fEnumRatio1)
                    (fromInteger @ a_a1ew7 $dNum_s1fXe GHC.Real.even2)) } in
         \ (ds1_d1f6e :: a_a1ew7) ->
           <= @ a_a1ew7 $dOrd_a1ew9 ds1_d1f6e ds_s1fXg)
        (GHC.Types.: @ a_a1ew7 ww1_s1hL8 ww2_s1hL9)
      }

Rec {
-- RHS size: {terms: 32, types: 41, coercions: 0, joins: 0/0}
GHC.Real.$w$snumericEnumFromThen [InlPrag=NOUSERINLINE[0],
                                  Occ=LoopBreaker]
  :: Integer
     -> Integer
     -> Integer
     -> Integer
     -> (# Ratio Integer, [Ratio Integer] #)
[GblId, Arity=4, Str=<L,U><L,U><L,U><L,U>, Unf=OtherCon []]
GHC.Real.$w$snumericEnumFromThen
  = \ (ww_s1hAv
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hAw
         :: Integer
         Unf=OtherCon [])
      (ww2_s1hAA
         :: Integer
         Unf=OtherCon [])
      (ww3_s1hAB
         :: Integer
         Unf=OtherCon []) ->
      (# GHC.Real.:% @ Integer ww_s1hAv ww1_s1hAw,
         case GHC.Real.$w$s$c+ ww2_s1hAA ww3_s1hAB ww2_s1hAA ww3_s1hAB of
         { (# ww5_s1hKW, ww6_s1hKX #) ->
         case GHC.Real.$w$s$c- ww5_s1hKW ww6_s1hKX ww_s1hAv ww1_s1hAw of
         { (# ww8_s1hKT, ww9_s1hKU #) ->
         case GHC.Real.$w$snumericEnumFromThen
                ww2_s1hAA ww3_s1hAB ww8_s1hKT ww9_s1hKU
         of
         { (# ww11_s1hLb, ww12_s1hLc #) ->
         GHC.Types.: @ (Ratio Integer) ww11_s1hLb ww12_s1hLc
         }
         }
         } #)
end Rec }

-- RHS size: {terms: 18, types: 27, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$snumericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Ratio Integer -> [Ratio Integer]
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hAr [Occ=Once!] :: Ratio Integer)
                 (w1_s1hAs [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hAr of { :% ww1_s1hAv [Occ=Once] ww2_s1hAw [Occ=Once] ->
                 case w1_s1hAs of { :% ww4_s1hAA [Occ=Once] ww5_s1hAB [Occ=Once] ->
                 case GHC.Real.$w$snumericEnumFromThen
                        ww1_s1hAv ww2_s1hAw ww4_s1hAA ww5_s1hAB
                 of
                 { (# ww7_s1hLb [Occ=Once], ww8_s1hLc [Occ=Once] #) ->
                 GHC.Types.: @ (Ratio Integer) ww7_s1hLb ww8_s1hLc
                 }
                 }
                 }}]
GHC.Real.$fEnumRatio_$snumericEnumFromThen
  = \ (w_s1hAr :: Ratio Integer) (w1_s1hAs :: Ratio Integer) ->
      case w_s1hAr of { :% ww1_s1hAv ww2_s1hAw ->
      case w1_s1hAs of { :% ww4_s1hAA ww5_s1hAB ->
      case GHC.Real.$w$snumericEnumFromThen
             ww1_s1hAv ww2_s1hAw ww4_s1hAA ww5_s1hAB
      of
      { (# ww7_s1hLb, ww8_s1hLc #) ->
      GHC.Types.: @ (Ratio Integer) ww7_s1hLb ww8_s1hLc
      }
      }
      }

Rec {
-- RHS size: {terms: 30, types: 29, coercions: 0, joins: 0/1}
GHC.Real.$wnumericEnumFromThen [InlPrag=NOUSERINLINE[0],
                                Occ=LoopBreaker]
  :: forall a. Fractional a => a -> a -> (# a, [a] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []]
GHC.Real.$wnumericEnumFromThen
  = \ (@ a_s1hAH)
      (w_s1hAI :: Fractional a_s1hAH)
      (w1_s1hAJ :: a_s1hAH)
      (w2_s1hAK :: a_s1hAH) ->
      case w1_s1hAJ of n_X1dRd { __DEFAULT ->
      case w2_s1hAK of m_X1dRf { __DEFAULT ->
      (# n_X1dRd,
         let {
           $dNum_s1fX5 [Dmd=<S(LC(C(S))LLLLL),U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,A)>]
             :: Num a_s1hAH
           [LclId]
           $dNum_s1fX5 = GHC.Real.$p1Fractional @ a_s1hAH w_s1hAI } in
         case GHC.Real.$wnumericEnumFromThen
                @ a_s1hAH
                w_s1hAI
                m_X1dRf
                (- @ a_s1hAH
                   $dNum_s1fX5
                   (+ @ a_s1hAH $dNum_s1fX5 m_X1dRf m_X1dRf)
                   n_X1dRd)
         of
         { (# ww1_s1hLe, ww2_s1hLf #) ->
         GHC.Types.: @ a_s1hAH ww1_s1hLe ww2_s1hLf
         } #)
      }
      }
end Rec }

-- RHS size: {terms: 13, types: 17, coercions: 0, joins: 0/0}
numericEnumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall a. Fractional a => a -> a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)><S,1*U><S,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hAH)
                 (w_s1hAI [Occ=Once] :: Fractional a_s1hAH)
                 (w1_s1hAJ [Occ=Once] :: a_s1hAH)
                 (w2_s1hAK [Occ=Once] :: a_s1hAH) ->
                 case GHC.Real.$wnumericEnumFromThen
                        @ a_s1hAH w_s1hAI w1_s1hAJ w2_s1hAK
                 of
                 { (# ww1_s1hLe [Occ=Once], ww2_s1hLf [Occ=Once] #) ->
                 GHC.Types.: @ a_s1hAH ww1_s1hLe ww2_s1hLf
                 }}]
numericEnumFromThen
  = \ (@ a_s1hAH)
      (w_s1hAI :: Fractional a_s1hAH)
      (w1_s1hAJ :: a_s1hAH)
      (w2_s1hAK :: a_s1hAH) ->
      case GHC.Real.$wnumericEnumFromThen
             @ a_s1hAH w_s1hAI w1_s1hAJ w2_s1hAK
      of
      { (# ww1_s1hLe, ww2_s1hLf #) ->
      GHC.Types.: @ a_s1hAH ww1_s1hLe ww2_s1hLf
      }

-- RHS size: {terms: 88, types: 84, coercions: 0, joins: 0/2}
GHC.Real.$w$snumericEnumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Integer
     -> Integer
     -> Integer
     -> Integer
     -> Ratio Integer
     -> [Ratio Integer]
[GblId,
 Arity=5,
 Str=<L,U><L,U><L,U><L,U><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 40] 670 0}]
GHC.Real.$w$snumericEnumFromThenTo
  = \ (ww_s1hAU
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hAV
         :: Integer
         Unf=OtherCon [])
      (ww2_s1hAZ
         :: Integer
         Unf=OtherCon [])
      (ww3_s1hB0
         :: Integer
         Unf=OtherCon [])
      (w_s1hAR :: Ratio Integer) ->
      case GHC.Real.$w$snumericEnumFromThen
             ww_s1hAU ww1_s1hAV ww2_s1hAZ ww3_s1hB0
      of
      { (# ww5_s1hLb, ww6_s1hLc #) ->
      takeWhile
        @ (Ratio Integer)
        (case GHC.Real.$w$s$ccompare ww2_s1hAZ ww3_s1hB0 ww_s1hAU ww1_s1hAV
         of {
           __DEFAULT ->
             let {
               ds_s1fX1 [Dmd=<L,U(U,U)>] :: Ratio Integer
               [LclId]
               ds_s1fX1
                 = case w_s1hAR of { :% ww8_s1hzl ww9_s1hzm ->
                   case GHC.Real.$w$s$c- ww2_s1hAZ ww3_s1hB0 ww_s1hAU ww1_s1hAV of
                   { (# ww11_s1hKT, ww12_s1hKU #) ->
                   case GHC.Real.$w$s$c/
                          ww11_s1hKT ww12_s1hKU GHC.Real.even2 GHC.Real.$fEnumRatio1
                   of
                   { (# ww14_s1hL2, ww15_s1hL3 #) ->
                   case GHC.Real.$w$s$c+ ww8_s1hzl ww9_s1hzm ww14_s1hL2 ww15_s1hL3 of
                   { (# ww17_s1hKW, ww18_s1hKX #) ->
                   GHC.Real.:% @ Integer ww17_s1hKW ww18_s1hKX
                   }
                   }
                   }
                   } } in
             \ (ds1_d1f60 :: Ratio Integer) ->
               GHC.Real.$fEnumRatio_$s$c<= ds1_d1f60 ds_s1fX1;
           LT ->
             let {
               ds_s1fWZ [Dmd=<L,U(U,U)>] :: Ratio Integer
               [LclId]
               ds_s1fWZ
                 = case w_s1hAR of { :% ww8_s1hzl ww9_s1hzm ->
                   case GHC.Real.$w$s$c- ww2_s1hAZ ww3_s1hB0 ww_s1hAU ww1_s1hAV of
                   { (# ww11_s1hKT, ww12_s1hKU #) ->
                   case GHC.Real.$w$s$c/
                          ww11_s1hKT ww12_s1hKU GHC.Real.even2 GHC.Real.$fEnumRatio1
                   of
                   { (# ww14_s1hL2, ww15_s1hL3 #) ->
                   case GHC.Real.$w$s$c+ ww8_s1hzl ww9_s1hzm ww14_s1hL2 ww15_s1hL3 of
                   { (# ww17_s1hKW, ww18_s1hKX #) ->
                   GHC.Real.:% @ Integer ww17_s1hKW ww18_s1hKX
                   }
                   }
                   }
                   } } in
             \ (ds1_d1f62 :: Ratio Integer) ->
               GHC.Real.$fEnumRatio_$s$c>= ds1_d1f62 ds_s1fWZ
         })
        (GHC.Types.: @ (Ratio Integer) ww5_s1hLb ww6_s1hLc)
      }

-- RHS size: {terms: 15, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$snumericEnumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer
     -> Ratio Integer -> Ratio Integer -> [Ratio Integer]
[GblId,
 Arity=3,
 Str=<S(SS),1*U(U,U)><S(SS),1*U(U,U)><L,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hAP [Occ=Once!] :: Ratio Integer)
                 (w1_s1hAQ [Occ=Once!] :: Ratio Integer)
                 (w2_s1hAR [Occ=Once] :: Ratio Integer) ->
                 case w_s1hAP of { :% ww1_s1hAU [Occ=Once] ww2_s1hAV [Occ=Once] ->
                 case w1_s1hAQ of { :% ww4_s1hAZ [Occ=Once] ww5_s1hB0 [Occ=Once] ->
                 GHC.Real.$w$snumericEnumFromThenTo
                   ww1_s1hAU ww2_s1hAV ww4_s1hAZ ww5_s1hB0 w2_s1hAR
                 }
                 }}]
GHC.Real.$fEnumRatio_$snumericEnumFromThenTo
  = \ (w_s1hAP :: Ratio Integer)
      (w1_s1hAQ :: Ratio Integer)
      (w2_s1hAR :: Ratio Integer) ->
      case w_s1hAP of { :% ww1_s1hAU ww2_s1hAV ->
      case w1_s1hAQ of { :% ww4_s1hAZ ww5_s1hB0 ->
      GHC.Real.$w$snumericEnumFromThenTo
        ww1_s1hAU ww2_s1hAV ww4_s1hAZ ww5_s1hB0 w2_s1hAR
      }
      }

-- RHS size: {terms: 56, types: 38, coercions: 0, joins: 0/4}
numericEnumFromThenTo
  :: forall a. (Ord a, Fractional a) => a -> a -> a -> [a]
[GblId,
 Arity=5,
 Str=<L,U(A,A,A,C(C1(U)),A,C(C1(U)),A,A)><L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,1*C1(U)),1*C1(C1(U)),A,A)><S,U><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [90 60 0 0 0] 500 0}]
numericEnumFromThenTo
  = \ (@ a_a1evf)
      ($dOrd_a1evh :: Ord a_a1evf)
      ($dFractional_a1evi :: Fractional a_a1evf)
      (eta_B3 :: a_a1evf)
      (eta1_B2 :: a_a1evf)
      (eta2_B1 :: a_a1evf) ->
      case GHC.Real.$wnumericEnumFromThen
             @ a_a1evf $dFractional_a1evi eta_B3 eta1_B2
      of
      { (# ww1_s1hLe, ww2_s1hLf #) ->
      takeWhile
        @ a_a1evf
        (let {
           $dNum_s1fWM [Dmd=<L,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
             :: Num a_a1evf
           [LclId]
           $dNum_s1fWM
             = GHC.Real.$p1Fractional @ a_a1evf $dFractional_a1evi } in
         let {
           mid_s1fWL :: a_a1evf
           [LclId]
           mid_s1fWL
             = / @ a_a1evf
                 $dFractional_a1evi
                 (- @ a_a1evf $dNum_s1fWM eta1_B2 eta_B3)
                 (fromInteger @ a_a1evf $dNum_s1fWM GHC.Real.even2) } in
         case >= @ a_a1evf $dOrd_a1evh eta1_B2 eta_B3 of {
           False ->
             let {
               ds_s1fWO :: a_a1evf
               [LclId]
               ds_s1fWO = + @ a_a1evf $dNum_s1fWM eta2_B1 mid_s1fWL } in
             \ (ds1_d1f62 :: a_a1evf) ->
               >= @ a_a1evf $dOrd_a1evh ds1_d1f62 ds_s1fWO;
           True ->
             let {
               ds_s1fWQ :: a_a1evf
               [LclId]
               ds_s1fWQ = + @ a_a1evf $dNum_s1fWM eta2_B1 mid_s1fWL } in
             \ (ds1_d1f60 :: a_a1evf) ->
               <= @ a_a1evf $dOrd_a1evh ds1_d1f60 ds_s1fWQ
         })
        (GHC.Types.: @ a_a1evf ww1_s1hLe ww2_s1hLf)
      }

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
fromIntegral [InlPrag=NOINLINE[1]]
  :: forall a b. (Integral a, Num b) => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U))><S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 60 0}]
fromIntegral
  = \ (@ a_a1euP)
      (@ b_a1euQ)
      ($dIntegral_a1euS :: Integral a_a1euP)
      ($dNum_a1euT :: Num b_a1euQ)
      (eta_B1 :: a_a1euP) ->
      fromInteger
        @ b_a1euQ $dNum_a1euT (toInteger @ a_a1euP $dIntegral_a1euS eta_B1)

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
realToFrac [InlPrag=NOINLINE[1]]
  :: forall a b. (Real a, Fractional b) => a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(U))><S(LLLC(S)),1*U(A,A,A,1*C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 60 0}]
realToFrac
  = \ (@ a_a1euC)
      (@ b_a1euD)
      ($dReal_a1euF :: Real a_a1euC)
      ($dFractional_a1euG :: Fractional b_a1euD)
      (eta_B1 :: a_a1euC) ->
      fromRational
        @ b_a1euD
        $dFractional_a1euG
        (toRational @ a_a1euC $dReal_a1euF eta_B1)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.showSigned1 :: Char
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.showSigned1 = GHC.Types.C# '-'#

-- RHS size: {terms: 48, types: 27, coercions: 0, joins: 0/2}
showSigned :: forall a. Real a => (a -> ShowS) -> Int -> a -> ShowS
[GblId,
 Arity=4,
 Str=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)><L,1*C1(U)><L,1*U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 20 0] 351 120}]
showSigned
  = \ (@ a_a1euj)
      ($dReal_a1eul :: Real a_a1euj)
      (eta_B3 :: a_a1euj -> ShowS)
      (eta1_B2 :: Int)
      (eta2_B1 :: a_a1euj) ->
      let {
        $dNum_s1fWB [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>] :: Num a_a1euj
        [LclId]
        $dNum_s1fWB = GHC.Real.$p1Real @ a_a1euj $dReal_a1eul } in
      case < @ a_a1euj
             (GHC.Real.$p2Real @ a_a1euj $dReal_a1eul)
             eta2_B1
             (fromInteger @ a_a1euj $dNum_s1fWB GHC.Real.even1)
      of {
        False -> eta_B3 eta2_B1;
        True ->
          case eta1_B2 of { I# x_aA1E ->
          let {
            g1_s1fWE [Dmd=<L,C(U)>] :: String -> String
            [LclId]
            g1_s1fWE = eta_B3 (negate @ a_a1euj $dNum_s1fWB eta2_B1) } in
          case ># x_aA1E 6# of {
            __DEFAULT ->
              \ (x1_i1f4k :: String) ->
                GHC.Types.: @ Char GHC.Real.showSigned1 (g1_s1fWE x1_i1f4k);
            1# ->
              \ (x1_i1f5A :: String) ->
                GHC.Types.:
                  @ Char
                  GHC.Show.$fShow(,)4
                  (GHC.Types.:
                     @ Char
                     GHC.Real.showSigned1
                     (g1_s1fWE (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x1_i1f5A)))
          }
          }
      }

-- RHS size: {terms: 22, types: 17, coercions: 0, joins: 0/2}
even [InlPrag=INLINABLE] :: forall a. Integral a => a -> Bool
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,1*C1(C1(U)),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60] 470 60
         Tmpl= \ (@ a_a1eq0) ($dIntegral_a1eq2 :: Integral a_a1eq0) ->
                 let {
                   $dReal_a1eWB :: Real a_a1eq0
                   [LclId]
                   $dReal_a1eWB = GHC.Real.$p1Integral @ a_a1eq0 $dIntegral_a1eq2 } in
                 let {
                   $dNum_a1eWD :: Num a_a1eq0
                   [LclId]
                   $dNum_a1eWD = GHC.Real.$p1Real @ a_a1eq0 $dReal_a1eWB } in
                 let {
                   $dEq_s1fsA [Occ=OnceL] :: Ord a_a1eq0
                   [LclId]
                   $dEq_s1fsA = GHC.Real.$p2Real @ a_a1eq0 $dReal_a1eWB } in
                 let {
                   $dEq1_a1eq4 [Occ=OnceL] :: Eq a_a1eq0
                   [LclId]
                   $dEq1_a1eq4 = GHC.Classes.$p1Ord @ a_a1eq0 $dEq_s1fsA } in
                 \ (n_a1dQE [Occ=Once] :: a_a1eq0) ->
                   ==
                     @ a_a1eq0
                     $dEq1_a1eq4
                     (rem
                        @ a_a1eq0
                        $dIntegral_a1eq2
                        n_a1dQE
                        (fromInteger @ a_a1eq0 $dNum_a1eWD 2))
                     (fromInteger @ a_a1eq0 $dNum_a1eWD 0)}]
even
  = \ (@ a_a1eq0)
      ($dIntegral_a1eq2 :: Integral a_a1eq0)
      (eta_B1 :: a_a1eq0) ->
      let {
        $dReal_s1fWj [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real a_a1eq0
        [LclId]
        $dReal_s1fWj = GHC.Real.$p1Integral @ a_a1eq0 $dIntegral_a1eq2 } in
      let {
        $dNum_s1fWi [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_a1eq0
        [LclId]
        $dNum_s1fWi = GHC.Real.$p1Real @ a_a1eq0 $dReal_s1fWj } in
      ==
        @ a_a1eq0
        (GHC.Classes.$p1Ord
           @ a_a1eq0 (GHC.Real.$p2Real @ a_a1eq0 $dReal_s1fWj))
        (rem
           @ a_a1eq0
           $dIntegral_a1eq2
           eta_B1
           (fromInteger @ a_a1eq0 $dNum_s1fWi GHC.Real.even2))
        (fromInteger @ a_a1eq0 $dNum_s1fWi GHC.Real.even1)

-- RHS size: {terms: 11, types: 7, coercions: 0, joins: 0/0}
odd [InlPrag=INLINABLE] :: forall a. Integral a => a -> Bool
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eqc)
                 ($dIntegral_a1eqe [Occ=Once] :: Integral a_a1eqc)
                 (x_i1f4k [Occ=Once] :: a_a1eqc) ->
                 case even @ a_a1eqc $dIntegral_a1eqe x_i1f4k of {
                   False -> GHC.Types.True;
                   True -> GHC.Types.False
                 }}]
odd
  = \ (@ a_a1eqc)
      ($dIntegral_a1eqe :: Integral a_a1eqc)
      (x_i1f4k :: a_a1eqc) ->
      case even @ a_a1eqc $dIntegral_a1eqe x_i1f4k of {
        False -> GHC.Types.True;
        True -> GHC.Types.False
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl3_r1j3b :: Ratio Integer
[GblId, Str=m, Unf=OtherCon []]
lvl3_r1j3b
  = GHC.Real.:% @ Integer GHC.Real.$fEnumRatio1 GHC.Real.even2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl4_r1j3c :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl4_r1j3c = "round default defn: Bad value"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio1 :: forall b. b
[GblId, Str=x]
GHC.Real.$fRealFracRatio1
  = \ (@ b_a1eBu) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ b_a1eBu (unpackCString# lvl4_r1j3c)

-- RHS size: {terms: 112, types: 71, coercions: 0, joins: 1/11}
GHC.Real.$dmround
  :: forall a. RealFrac a => forall b. Integral b => a -> b
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),U(1*U(1*U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),1*U(A,A,A,1*C1(U)),1*C1(C1(U(1*U,1*U))),A,A,A,A)><L,U(U(U(U,U,U,U,U,U,U),U(U(U,U),U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1dNs) ($dRealFrac_a1eB7 :: RealFrac a_a1dNs) ->
                 let {
                   $dFractional_a1eYl [Occ=OnceL] :: Fractional a_a1dNs
                   [LclId]
                   $dFractional_a1eYl
                     = GHC.Real.$p2RealFrac @ a_a1dNs $dRealFrac_a1eB7 } in
                 let {
                   $dReal_a1eYk :: Real a_a1dNs
                   [LclId]
                   $dReal_a1eYk = GHC.Real.$p1RealFrac @ a_a1dNs $dRealFrac_a1eB7 } in
                 let {
                   $dNum_a1eYm :: Num a_a1dNs
                   [LclId]
                   $dNum_a1eYm = GHC.Real.$p1Real @ a_a1dNs $dReal_a1eYk } in
                 let {
                   $dOrd_a1eYn :: Ord a_a1dNs
                   [LclId]
                   $dOrd_a1eYn = GHC.Real.$p2Real @ a_a1dNs $dReal_a1eYk } in
                 let {
                   $dEq_a1eYo :: Eq a_a1dNs
                   [LclId]
                   $dEq_a1eYo = GHC.Classes.$p1Ord @ a_a1dNs $dOrd_a1eYn } in
                 \ (@ b_a1eBu) ($dIntegral_a1eBw :: Integral b_a1eBu) ->
                   let {
                     $dReal1_a1eYq [Occ=OnceL] :: Real b_a1eBu
                     [LclId]
                     $dReal1_a1eYq
                       = GHC.Real.$p1Integral @ b_a1eBu $dIntegral_a1eBw } in
                   let {
                     $dNum1_a1eYs :: Num b_a1eBu
                     [LclId]
                     $dNum1_a1eYs = GHC.Real.$p1Real @ b_a1eBu $dReal1_a1eYq } in
                   \ (x_a1dNA [Occ=Once] :: a_a1dNs) ->
                     let {
                       ds_d1faY :: (b_a1eBu, a_a1dNs)
                       [LclId]
                       ds_d1faY
                         = properFraction
                             @ a_a1dNs $dRealFrac_a1eB7 @ b_a1eBu $dIntegral_a1eBw x_a1dNA } in
                     let {
                       n_a1dNB :: b_a1eBu
                       [LclId]
                       n_a1dNB
                         = case ds_d1faY of { (n1_a1eBD [Occ=Once], _ [Occ=Dead]) ->
                           n1_a1eBD
                           } } in
                     let {
                       r_a1dNC :: a_a1dNs
                       [LclId]
                       r_a1dNC
                         = case ds_d1faY of { (_ [Occ=Dead], r1_a1eBF [Occ=Once]) ->
                           r1_a1eBF
                           } } in
                     let {
                       ds1_d1faf :: a_a1dNs
                       [LclId]
                       ds1_d1faf
                         = signum
                             @ a_a1dNs
                             $dNum_a1eYm
                             (- @ a_a1dNs
                                $dNum_a1eYm
                                (abs @ a_a1dNs $dNum_a1eYm r_a1dNC)
                                (fromRational
                                   @ a_a1dNs $dFractional_a1eYl (GHC.Real.:% @ Integer 1 2))) } in
                     join {
                       m_a1dND [Occ=Once*T[0]] :: b_a1eBu
                       [LclId[JoinId(0)]]
                       m_a1dND
                         = case < @ a_a1dNs
                                  $dOrd_a1eYn
                                  r_a1dNC
                                  (fromInteger @ a_a1dNs $dNum_a1eYm 0)
                           of {
                             False ->
                               + @ b_a1eBu
                                 $dNum1_a1eYs
                                 n_a1dNB
                                 (fromInteger @ b_a1eBu $dNum1_a1eYs 1);
                             True ->
                               - @ b_a1eBu
                                 $dNum1_a1eYs
                                 n_a1dNB
                                 (fromInteger @ b_a1eBu $dNum1_a1eYs 1)
                           } } in
                     case ==
                            @ a_a1dNs
                            $dEq_a1eYo
                            ds1_d1faf
                            (negate
                               @ a_a1dNs $dNum_a1eYm (fromInteger @ a_a1dNs $dNum_a1eYm 1))
                     of {
                       False ->
                         case ==
                                @ a_a1dNs
                                $dEq_a1eYo
                                ds1_d1faf
                                (fromInteger @ a_a1dNs $dNum_a1eYm 0)
                         of {
                           False ->
                             case ==
                                    @ a_a1dNs
                                    $dEq_a1eYo
                                    ds1_d1faf
                                    (fromInteger @ a_a1dNs $dNum_a1eYm 1)
                             of {
                               False ->
                                 errorWithoutStackTrace
                                   @ 'LiftedRep
                                   @ b_a1eBu
                                   (build
                                      @ Char
                                      (\ (@ b1_i1fsK) ->
                                         unpackFoldrCString#
                                           @ b1_i1fsK "round default defn: Bad value"#));
                               True -> jump m_a1dND
                             };
                           True ->
                             case even @ b_a1eBu $dIntegral_a1eBw n_a1dNB of {
                               False -> jump m_a1dND;
                               True -> n_a1dNB
                             }
                         };
                       True -> n_a1dNB
                     }}]
GHC.Real.$dmround
  = \ (@ a_a1dNs)
      ($dRealFrac_a1eB7 :: RealFrac a_a1dNs)
      (@ b_a1eBu)
      (eta_B2 :: Integral b_a1eBu)
      (eta1_B1 :: a_a1dNs) ->
      let {
        ds_s1fW9 [Dmd=<L,U(1*U,1*U)>] :: (b_a1eBu, a_a1dNs)
        [LclId]
        ds_s1fW9
          = properFraction
              @ a_a1dNs $dRealFrac_a1eB7 @ b_a1eBu eta_B2 eta1_B1 } in
      let {
        $dReal_s1fWf [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
          :: Real a_a1dNs
        [LclId]
        $dReal_s1fWf = GHC.Real.$p1RealFrac @ a_a1dNs $dRealFrac_a1eB7 } in
      let {
        $dOrd_s1fWd [Dmd=<S(S(C(C(S))L)LLLLLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
          :: Ord a_a1dNs
        [LclId]
        $dOrd_s1fWd = GHC.Real.$p2Real @ a_a1dNs $dReal_s1fWf } in
      let {
        $dEq_s1fWc [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_a1dNs
        [LclId]
        $dEq_s1fWc = GHC.Classes.$p1Ord @ a_a1dNs $dOrd_s1fWd } in
      let {
        $dNum_s1fWe [Dmd=<L,U(A,1*C1(C1(U)),A,1*C1(U),1*C1(U),1*C1(U),C(U))>]
          :: Num a_a1dNs
        [LclId]
        $dNum_s1fWe = GHC.Real.$p1Real @ a_a1dNs $dReal_s1fWf } in
      let {
        r_s1fW7 :: a_a1dNs
        [LclId]
        r_s1fW7 = case ds_s1fW9 of { (n_a1eBD, r1_a1eBF) -> r1_a1eBF } } in
      let {
        ds1_s1fW6 :: a_a1dNs
        [LclId]
        ds1_s1fW6
          = signum
              @ a_a1dNs
              $dNum_s1fWe
              (- @ a_a1dNs
                 $dNum_s1fWe
                 (abs @ a_a1dNs $dNum_s1fWe r_s1fW7)
                 (fromRational
                    @ a_a1dNs
                    (GHC.Real.$p2RealFrac @ a_a1dNs $dRealFrac_a1eB7)
                    lvl3_r1j3b)) } in
      let {
        n_s1fW8 :: b_a1eBu
        [LclId]
        n_s1fW8
          = case ds_s1fW9 of { (n1_a1eBD, r1_a1eBF) -> n1_a1eBD } } in
      case ==
             @ a_a1dNs
             $dEq_s1fWc
             ds1_s1fW6
             (negate
                @ a_a1dNs
                $dNum_s1fWe
                (fromInteger @ a_a1dNs $dNum_s1fWe GHC.Real.$fEnumRatio1))
      of {
        False ->
          join {
            m_s1fW5 [Dmd=<L,1*U>] :: b_a1eBu
            [LclId[JoinId(0)]]
            m_s1fW5
              = let {
                  $dReal1_s1fWb [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                    :: Real b_a1eBu
                  [LclId]
                  $dReal1_s1fWb = GHC.Real.$p1Integral @ b_a1eBu eta_B2 } in
                let {
                  $dNum1_s1fWa [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                    :: Num b_a1eBu
                  [LclId]
                  $dNum1_s1fWa = GHC.Real.$p1Real @ b_a1eBu $dReal1_s1fWb } in
                case < @ a_a1dNs
                       $dOrd_s1fWd
                       r_s1fW7
                       (fromInteger @ a_a1dNs $dNum_s1fWe GHC.Real.even1)
                of {
                  False ->
                    + @ b_a1eBu
                      $dNum1_s1fWa
                      n_s1fW8
                      (fromInteger @ b_a1eBu $dNum1_s1fWa GHC.Real.$fEnumRatio1);
                  True ->
                    - @ b_a1eBu
                      $dNum1_s1fWa
                      n_s1fW8
                      (fromInteger @ b_a1eBu $dNum1_s1fWa GHC.Real.$fEnumRatio1)
                } } in
          case ==
                 @ a_a1dNs
                 $dEq_s1fWc
                 ds1_s1fW6
                 (fromInteger @ a_a1dNs $dNum_s1fWe GHC.Real.even1)
          of {
            False ->
              case ==
                     @ a_a1dNs
                     $dEq_s1fWc
                     ds1_s1fW6
                     (fromInteger @ a_a1dNs $dNum_s1fWe GHC.Real.$fEnumRatio1)
              of {
                False -> GHC.Real.$fRealFracRatio1 @ b_a1eBu;
                True -> jump m_s1fW5
              };
            True ->
              case even @ b_a1eBu eta_B2 n_s1fW8 of {
                False -> jump m_s1fW5;
                True -> n_s1fW8
              }
          };
        True -> n_s1fW8
      }

-- RHS size: {terms: 36, types: 25, coercions: 0, joins: 0/4}
integralEnumFrom :: forall a. (Integral a, Bounded a) => a -> [a]
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,1*U(A,1*U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 30 0] 330 0}]
integralEnumFrom
  = \ (@ a_a1eoa)
      ($dIntegral_a1eoc :: Integral a_a1eoa)
      ($dBounded_a1eod :: Bounded a_a1eoa)
      (eta_B1 :: a_a1eoa) ->
      let {
        f_s1gYP [Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>] :: Real a_a1eoa
        [LclId]
        f_s1gYP = GHC.Real.$p1Integral @ a_a1eoa $dIntegral_a1eoc } in
      let {
        f1_s1gYQ [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_a1eoa
        [LclId]
        f1_s1gYQ = GHC.Real.$p1Real @ a_a1eoa f_s1gYP } in
      let {
        lim_i1ftu [Dmd=<S,U>] :: Integer
        [LclId]
        lim_i1ftu
          = toInteger
              @ a_a1eoa
              $dIntegral_a1eoc
              (maxBound @ a_a1eoa $dBounded_a1eod) } in
      letrec {
        go_i1ftv [Occ=LoopBreaker] :: Integer -> [a_a1eoa]
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_i1ftv
          = \ (x_i1ftw :: Integer) ->
              case gtInteger# x_i1ftw lim_i1ftu of {
                __DEFAULT ->
                  GHC.Types.:
                    @ a_a1eoa
                    (fromInteger @ a_a1eoa f1_s1gYQ x_i1ftw)
                    (go_i1ftv (plusInteger x_i1ftw GHC.Real.$fEnumRatio1));
                1# -> GHC.Types.[] @ a_a1eoa
              }; } in
      go_i1ftv (toInteger @ a_a1eoa $dIntegral_a1eoc eta_B1)

-- RHS size: {terms: 147, types: 73, coercions: 0, joins: 0/16}
integralEnumFromThen
  :: forall a. (Integral a, Bounded a) => a -> a -> [a]
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,1*U(1*U,1*U)><L,U><L,U>,
 Unf=OtherCon []]
integralEnumFromThen
  = \ (@ a_a1enm)
      ($dIntegral_a1eno :: Integral a_a1enm)
      ($dBounded_a1enp :: Bounded a_a1enm)
      (eta_B2 :: a_a1enm)
      (eta1_B1 :: a_a1enm) ->
      let {
        i_n2_s1fV9 [Dmd=<S,U>] :: Integer
        [LclId]
        i_n2_s1fV9 = toInteger @ a_a1enm $dIntegral_a1eno eta1_B1 } in
      let {
        i_n1_s1fV8 [Dmd=<S,U>] :: Integer
        [LclId]
        i_n1_s1fV8 = toInteger @ a_a1enm $dIntegral_a1eno eta_B2 } in
      case geInteger# i_n2_s1fV9 i_n1_s1fV8 of {
        __DEFAULT ->
          let {
            delta_i1fu8 [Dmd=<S,U>] :: Integer
            [LclId]
            delta_i1fu8 = minusInteger i_n2_s1fV9 i_n1_s1fV8 } in
          let {
            f_s1gYT [Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>] :: Real a_a1enm
            [LclId]
            f_s1gYT = GHC.Real.$p1Integral @ a_a1enm $dIntegral_a1eno } in
          let {
            f1_s1gYU [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_a1enm
            [LclId]
            f1_s1gYU = GHC.Real.$p1Real @ a_a1enm f_s1gYT } in
          case geInteger# delta_i1fu8 GHC.Real.even1 of {
            __DEFAULT ->
              let {
                lim_i1gZ1 [Dmd=<S,U>] :: Integer
                [LclId]
                lim_i1gZ1
                  = toInteger
                      @ a_a1enm
                      $dIntegral_a1eno
                      (minBound @ a_a1enm $dBounded_a1enp) } in
              letrec {
                go_i1gZ2 [Occ=LoopBreaker] :: Integer -> [a_a1enm]
                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                go_i1gZ2
                  = \ (x_i1gZ3 :: Integer) ->
                      case ltInteger# x_i1gZ3 lim_i1gZ1 of {
                        __DEFAULT ->
                          GHC.Types.:
                            @ a_a1enm
                            (fromInteger @ a_a1enm f1_s1gYU x_i1gZ3)
                            (go_i1gZ2 (plusInteger x_i1gZ3 delta_i1fu8));
                        1# -> GHC.Types.[] @ a_a1enm
                      }; } in
              go_i1gZ2 i_n1_s1fV8;
            1# ->
              let {
                lim_i1gZb [Dmd=<S,U>] :: Integer
                [LclId]
                lim_i1gZb
                  = toInteger
                      @ a_a1enm
                      $dIntegral_a1eno
                      (minBound @ a_a1enm $dBounded_a1enp) } in
              letrec {
                go_i1gZc [Occ=LoopBreaker] :: Integer -> [a_a1enm]
                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                go_i1gZc
                  = \ (x_i1gZd :: Integer) ->
                      case gtInteger# x_i1gZd lim_i1gZb of {
                        __DEFAULT ->
                          GHC.Types.:
                            @ a_a1enm
                            (fromInteger @ a_a1enm f1_s1gYU x_i1gZd)
                            (go_i1gZc (plusInteger x_i1gZd delta_i1fu8));
                        1# -> GHC.Types.[] @ a_a1enm
                      }; } in
              go_i1gZc i_n1_s1fV8
          };
        1# ->
          let {
            delta_i1fu8 [Dmd=<S,U>] :: Integer
            [LclId]
            delta_i1fu8 = minusInteger i_n2_s1fV9 i_n1_s1fV8 } in
          let {
            f_s1gZg [Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>] :: Real a_a1enm
            [LclId]
            f_s1gZg = GHC.Real.$p1Integral @ a_a1enm $dIntegral_a1eno } in
          let {
            f1_s1gZh [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_a1enm
            [LclId]
            f1_s1gZh = GHC.Real.$p1Real @ a_a1enm f_s1gZg } in
          case geInteger# delta_i1fu8 GHC.Real.even1 of {
            __DEFAULT ->
              let {
                lim_i1gZ1 [Dmd=<S,U>] :: Integer
                [LclId]
                lim_i1gZ1
                  = toInteger
                      @ a_a1enm
                      $dIntegral_a1eno
                      (maxBound @ a_a1enm $dBounded_a1enp) } in
              letrec {
                go_i1gZ2 [Occ=LoopBreaker] :: Integer -> [a_a1enm]
                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                go_i1gZ2
                  = \ (x_i1gZ3 :: Integer) ->
                      case ltInteger# x_i1gZ3 lim_i1gZ1 of {
                        __DEFAULT ->
                          GHC.Types.:
                            @ a_a1enm
                            (fromInteger @ a_a1enm f1_s1gZh x_i1gZ3)
                            (go_i1gZ2 (plusInteger x_i1gZ3 delta_i1fu8));
                        1# -> GHC.Types.[] @ a_a1enm
                      }; } in
              go_i1gZ2 i_n1_s1fV8;
            1# ->
              let {
                lim_i1gZb [Dmd=<S,U>] :: Integer
                [LclId]
                lim_i1gZb
                  = toInteger
                      @ a_a1enm
                      $dIntegral_a1eno
                      (maxBound @ a_a1enm $dBounded_a1enp) } in
              letrec {
                go_i1gZc [Occ=LoopBreaker] :: Integer -> [a_a1enm]
                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
                go_i1gZc
                  = \ (x_i1gZd :: Integer) ->
                      case gtInteger# x_i1gZd lim_i1gZb of {
                        __DEFAULT ->
                          GHC.Types.:
                            @ a_a1enm
                            (fromInteger @ a_a1enm f1_s1gZh x_i1gZd)
                            (go_i1gZc (plusInteger x_i1gZd delta_i1fu8));
                        1# -> GHC.Types.[] @ a_a1enm
                      }; } in
              go_i1gZc i_n1_s1fV8
          }
      }

-- RHS size: {terms: 35, types: 23, coercions: 0, joins: 0/4}
integralEnumFromTo :: forall a. Integral a => a -> a -> [a]
[GblId,
 Arity=3,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 0 0] 310 0}]
integralEnumFromTo
  = \ (@ a_a1en9)
      ($dIntegral_a1enb :: Integral a_a1en9)
      (eta_B2 :: a_a1en9)
      (eta1_B1 :: a_a1en9) ->
      let {
        f_s1gZl [Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>] :: Real a_a1en9
        [LclId]
        f_s1gZl = GHC.Real.$p1Integral @ a_a1en9 $dIntegral_a1enb } in
      let {
        f1_s1gZm [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_a1en9
        [LclId]
        f1_s1gZm = GHC.Real.$p1Real @ a_a1en9 f_s1gZl } in
      let {
        lim_i1ftu [Dmd=<S,U>] :: Integer
        [LclId]
        lim_i1ftu = toInteger @ a_a1en9 $dIntegral_a1enb eta1_B1 } in
      letrec {
        go_i1ftv [Occ=LoopBreaker] :: Integer -> [a_a1en9]
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        go_i1ftv
          = \ (x_i1ftw :: Integer) ->
              case gtInteger# x_i1ftw lim_i1ftu of {
                __DEFAULT ->
                  GHC.Types.:
                    @ a_a1en9
                    (fromInteger @ a_a1en9 f1_s1gZm x_i1ftw)
                    (go_i1ftv (plusInteger x_i1ftw GHC.Real.$fEnumRatio1));
                1# -> GHC.Types.[] @ a_a1en9
              }; } in
      go_i1ftv (toInteger @ a_a1en9 $dIntegral_a1enb eta_B2)

-- RHS size: {terms: 73, types: 38, coercions: 0, joins: 0/8}
integralEnumFromThenTo
  :: forall a. Integral a => a -> a -> a -> [a]
[GblId,
 Arity=4,
 Str=<S(LLLLLLLLC(S)),U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [150 0 0 0] 660 0}]
integralEnumFromThenTo
  = \ (@ a_a1emS)
      ($dIntegral_a1emU :: Integral a_a1emS)
      (eta_B3 :: a_a1emS)
      (eta1_B2 :: a_a1emS)
      (eta2_B1 :: a_a1emS) ->
      let {
        x_s1fV5 [Dmd=<S,U>] :: Integer
        [LclId]
        x_s1fV5 = toInteger @ a_a1emS $dIntegral_a1emU eta_B3 } in
      let {
        delta_i1fu8 [Dmd=<S,U>] :: Integer
        [LclId]
        delta_i1fu8
          = minusInteger
              (toInteger @ a_a1emS $dIntegral_a1emU eta1_B2) x_s1fV5 } in
      let {
        f_s1gZo [Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>] :: Real a_a1emS
        [LclId]
        f_s1gZo = GHC.Real.$p1Integral @ a_a1emS $dIntegral_a1emU } in
      let {
        f1_s1gZp [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_a1emS
        [LclId]
        f1_s1gZp = GHC.Real.$p1Real @ a_a1emS f_s1gZo } in
      case geInteger# delta_i1fu8 GHC.Real.even1 of {
        __DEFAULT ->
          let {
            lim_i1gZ1 [Dmd=<S,U>] :: Integer
            [LclId]
            lim_i1gZ1 = toInteger @ a_a1emS $dIntegral_a1emU eta2_B1 } in
          letrec {
            go_i1gZ2 [Occ=LoopBreaker] :: Integer -> [a_a1emS]
            [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
            go_i1gZ2
              = \ (x1_i1gZ3 :: Integer) ->
                  case ltInteger# x1_i1gZ3 lim_i1gZ1 of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ a_a1emS
                        (fromInteger @ a_a1emS f1_s1gZp x1_i1gZ3)
                        (go_i1gZ2 (plusInteger x1_i1gZ3 delta_i1fu8));
                    1# -> GHC.Types.[] @ a_a1emS
                  }; } in
          go_i1gZ2 x_s1fV5;
        1# ->
          let {
            lim_i1gZb [Dmd=<S,U>] :: Integer
            [LclId]
            lim_i1gZb = toInteger @ a_a1emS $dIntegral_a1emU eta2_B1 } in
          letrec {
            go_i1gZc [Occ=LoopBreaker] :: Integer -> [a_a1emS]
            [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
            go_i1gZc
              = \ (x1_i1gZd :: Integer) ->
                  case gtInteger# x1_i1gZd lim_i1gZb of {
                    __DEFAULT ->
                      GHC.Types.:
                        @ a_a1emS
                        (fromInteger @ a_a1emS f1_s1gZp x1_i1gZd)
                        (go_i1gZc (plusInteger x1_i1gZd delta_i1fu8));
                    1# -> GHC.Types.[] @ a_a1emS
                  }; } in
          go_i1gZc x_s1fV5
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Real.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$trModule3 = GHC.Types.TrNameS GHC.Real.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Real.$trModule2 = "GHC.Real"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$trModule1 = GHC.Types.TrNameS GHC.Real.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Real.$trModule
  = GHC.Types.Module GHC.Real.$trModule3 GHC.Real.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r1j3d :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r1j3d
  = GHC.Types.KindRepTyConApp
      integer-simple-0.1.1.1:GHC.Integer.Type.$tcInteger
      (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_r1j3e :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_r1j3e
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcFractional1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Real.$tcFractional1
  = GHC.Types.KindRepFun GHC.Types.krep$* $krep1_r1j3e

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep2_r1j3f :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_r1j3f = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3_r1j3g :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep3_r1j3g = GHC.Types.KindRepFun $krep2_r1j3f $krep2_r1j3f

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_r1j3h :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep4_r1j3h = GHC.Types.KindRepFun $krep2_r1j3f $krep3_r1j3g

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_r1j3i :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep5_r1j3i = GHC.Types.KindRepFun $krep2_r1j3f $krep_r1j3d

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep6_r1j3j :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep6_r1j3j
  = GHC.Types.: @ KindRep $krep2_r1j3f (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep7_r1j3k :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep7_r1j3k = GHC.Types.: @ KindRep $krep2_r1j3f $krep6_r1j3j

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_r1j3l :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep8_r1j3l
  = GHC.Types.KindRepTyConApp GHC.Tuple.$tc(,) $krep7_r1j3k

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_r1j3m :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep9_r1j3m = GHC.Types.KindRepFun $krep2_r1j3f $krep8_r1j3l

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_r1j3n :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep10_r1j3n = GHC.Types.KindRepFun $krep2_r1j3f $krep9_r1j3m

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_r1j3o :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep11_r1j3o
  = GHC.Types.KindRepTyConApp GHC.Num.$tcNum $krep6_r1j3j

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_r1j3p :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep12_r1j3p
  = GHC.Types.KindRepTyConApp GHC.Enum.$tcEnum $krep6_r1j3j

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13_r1j3q :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep13_r1j3q
  = GHC.Types.KindRepTyConApp GHC.Classes.$tcOrd $krep6_r1j3j

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcRatio2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Real.$tcRatio2 = "Ratio"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcRatio1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$tcRatio1 = GHC.Types.TrNameS GHC.Real.$tcRatio2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcRatio :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Real.$tcRatio
  = GHC.Types.TyCon
      17658523810845794968##
      1271393732863050253##
      GHC.Real.$trModule
      GHC.Real.$tcRatio1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep14_r1j3r :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep14_r1j3r
  = GHC.Types.KindRepTyConApp GHC.Real.$tcRatio $krep6_r1j3j

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep15_r1j3s :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep15_r1j3s = GHC.Types.KindRepFun $krep2_r1j3f $krep14_r1j3r

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc':%1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Real.$tc':%1 = GHC.Types.KindRepFun $krep2_r1j3f $krep15_r1j3s

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc':%3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Real.$tc':%3 = "':%"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc':%2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$tc':%2 = GHC.Types.TrNameS GHC.Real.$tc':%3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc':% :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Real.$tc':%
  = GHC.Types.TyCon
      11952989868638128372##
      6861245286732044789##
      GHC.Real.$trModule
      GHC.Real.$tc':%2
      1#
      GHC.Real.$tc':%1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep16_r1j3t :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep16_r1j3t
  = GHC.Types.: @ KindRep $krep_r1j3d (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep17_r1j3u :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep17_r1j3u
  = GHC.Types.KindRepTyConApp GHC.Real.$tcRatio $krep16_r1j3t

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep18_r1j3v :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep18_r1j3v = GHC.Types.KindRepFun $krep2_r1j3f $krep17_r1j3u

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep19_r1j3w :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep19_r1j3w = GHC.Types.KindRepFun $krep17_r1j3u $krep2_r1j3f

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcReal2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Real.$tcReal2 = "Real"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcReal1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$tcReal1 = GHC.Types.TrNameS GHC.Real.$tcReal2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcReal :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Real.$tcReal
  = GHC.Types.TyCon
      1826502536394630182##
      14487785779892251413##
      GHC.Real.$trModule
      GHC.Real.$tcReal1
      0#
      GHC.Real.$tcFractional1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep20_r1j3x :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep20_r1j3x
  = GHC.Types.KindRepTyConApp GHC.Real.$tcReal $krep6_r1j3j

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep21_r1j3y :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep21_r1j3y = GHC.Types.KindRepFun $krep18_r1j3v $krep20_r1j3x

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep22_r1j3z :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep22_r1j3z = GHC.Types.KindRepFun $krep13_r1j3q $krep21_r1j3y

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Real1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Real.$tc'C:Real1
  = GHC.Types.KindRepFun $krep11_r1j3o $krep22_r1j3z

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Real3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Real.$tc'C:Real3 = "'C:Real"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Real2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$tc'C:Real2 = GHC.Types.TrNameS GHC.Real.$tc'C:Real3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Real :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Real.$tc'C:Real
  = GHC.Types.TyCon
      5938283050841830427##
      8926187074226767634##
      GHC.Real.$trModule
      GHC.Real.$tc'C:Real2
      1#
      GHC.Real.$tc'C:Real1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcIntegral2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Real.$tcIntegral2 = "Integral"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcIntegral1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$tcIntegral1 = GHC.Types.TrNameS GHC.Real.$tcIntegral2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcIntegral :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Real.$tcIntegral
  = GHC.Types.TyCon
      16601157811546713973##
      3304955164956033666##
      GHC.Real.$trModule
      GHC.Real.$tcIntegral1
      0#
      GHC.Real.$tcFractional1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep23_r1j3A :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep23_r1j3A
  = GHC.Types.KindRepTyConApp GHC.Real.$tcIntegral $krep6_r1j3j

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep24_r1j3B :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep24_r1j3B = GHC.Types.KindRepFun $krep5_r1j3i $krep23_r1j3A

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep25_r1j3C :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep25_r1j3C = GHC.Types.KindRepFun $krep10_r1j3n $krep24_r1j3B

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep26_r1j3D :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep26_r1j3D = GHC.Types.KindRepFun $krep10_r1j3n $krep25_r1j3C

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep27_r1j3E :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep27_r1j3E = GHC.Types.KindRepFun $krep4_r1j3h $krep26_r1j3D

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep28_r1j3F :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep28_r1j3F = GHC.Types.KindRepFun $krep4_r1j3h $krep27_r1j3E

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep29_r1j3G :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep29_r1j3G = GHC.Types.KindRepFun $krep4_r1j3h $krep28_r1j3F

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep30_r1j3H :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep30_r1j3H = GHC.Types.KindRepFun $krep4_r1j3h $krep29_r1j3G

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep31_r1j3I :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep31_r1j3I = GHC.Types.KindRepFun $krep12_r1j3p $krep30_r1j3H

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Integral1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Real.$tc'C:Integral1
  = GHC.Types.KindRepFun $krep20_r1j3x $krep31_r1j3I

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Integral3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Real.$tc'C:Integral3 = "'C:Integral"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Integral2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$tc'C:Integral2
  = GHC.Types.TrNameS GHC.Real.$tc'C:Integral3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Integral :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Real.$tc'C:Integral
  = GHC.Types.TyCon
      12141017740256829283##
      17564033539811245778##
      GHC.Real.$trModule
      GHC.Real.$tc'C:Integral2
      1#
      GHC.Real.$tc'C:Integral1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcFractional3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Real.$tcFractional3 = "Fractional"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcFractional2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$tcFractional2 = GHC.Types.TrNameS GHC.Real.$tcFractional3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcFractional :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Real.$tcFractional
  = GHC.Types.TyCon
      14968870971062750857##
      13774835939651899219##
      GHC.Real.$trModule
      GHC.Real.$tcFractional2
      0#
      GHC.Real.$tcFractional1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep32_r1j3J :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep32_r1j3J
  = GHC.Types.KindRepTyConApp GHC.Real.$tcFractional $krep6_r1j3j

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep33_r1j3K :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep33_r1j3K = GHC.Types.KindRepFun $krep19_r1j3w $krep32_r1j3J

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep34_r1j3L :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep34_r1j3L = GHC.Types.KindRepFun $krep3_r1j3g $krep33_r1j3K

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep35_r1j3M :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep35_r1j3M = GHC.Types.KindRepFun $krep4_r1j3h $krep34_r1j3L

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Fractional1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Real.$tc'C:Fractional1
  = GHC.Types.KindRepFun $krep11_r1j3o $krep35_r1j3M

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Fractional3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
GHC.Real.$tc'C:Fractional3 = "'C:Fractional"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Fractional2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$tc'C:Fractional2
  = GHC.Types.TrNameS GHC.Real.$tc'C:Fractional3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tc'C:Fractional :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Real.$tc'C:Fractional
  = GHC.Types.TyCon
      15706435530565718930##
      11021884564355505453##
      GHC.Real.$trModule
      GHC.Real.$tc'C:Fractional2
      1#
      GHC.Real.$tc'C:Fractional1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcRealFrac2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Real.$tcRealFrac2 = "RealFrac"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcRealFrac1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.$tcRealFrac1 = GHC.Types.TrNameS GHC.Real.$tcRealFrac2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$tcRealFrac :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Real.$tcRealFrac
  = GHC.Types.TyCon
      2318913099678420819##
      6373121509494083706##
      GHC.Real.$trModule
      GHC.Real.$tcRealFrac1
      0#
      GHC.Real.$tcFractional1

-- RHS size: {terms: 23, types: 18, coercions: 0, joins: 0/2}
GHC.Real.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> a -> a -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 200 0}]
GHC.Real.$w$c<
  = \ (@ a_s1hBR)
      (w_s1hBS :: Integral a_s1hBR)
      (ww_s1hBX
         :: a_s1hBR
         Unf=OtherCon [])
      (ww1_s1hBY
         :: a_s1hBR
         Unf=OtherCon [])
      (ww2_s1hC2
         :: a_s1hBR
         Unf=OtherCon [])
      (ww3_s1hC3
         :: a_s1hBR
         Unf=OtherCon []) ->
      let {
        $dReal_s1fV3 [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
          :: Real a_s1hBR
        [LclId]
        $dReal_s1fV3 = GHC.Real.$p1Integral @ a_s1hBR w_s1hBS } in
      let {
        $dNum_s1fV2 [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>] :: Num a_s1hBR
        [LclId]
        $dNum_s1fV2 = GHC.Real.$p1Real @ a_s1hBR $dReal_s1fV3 } in
      < @ a_s1hBR
        (GHC.Real.$p2Real @ a_s1hBR $dReal_s1fV3)
        (* @ a_s1hBR $dNum_s1fV2 ww_s1hBX ww3_s1hC3)
        (* @ a_s1hBR $dNum_s1fV2 ww2_s1hC2 ww1_s1hBY)

-- RHS size: {terms: 16, types: 17, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hBR)
                 (w_s1hBS [Occ=Once] :: Integral a_s1hBR)
                 (w1_s1hBT [Occ=Once!] :: Ratio a_s1hBR)
                 (w2_s1hBU [Occ=Once!] :: Ratio a_s1hBR) ->
                 case w1_s1hBT of { :% ww1_s1hBX [Occ=Once] ww2_s1hBY [Occ=Once] ->
                 case w2_s1hBU of { :% ww4_s1hC2 [Occ=Once] ww5_s1hC3 [Occ=Once] ->
                 GHC.Real.$w$c<
                   @ a_s1hBR w_s1hBS ww1_s1hBX ww2_s1hBY ww4_s1hC2 ww5_s1hC3
                 }
                 }}]
GHC.Real.$fOrdRatio_$c<
  = \ (@ a_s1hBR)
      (w_s1hBS :: Integral a_s1hBR)
      (w1_s1hBT :: Ratio a_s1hBR)
      (w2_s1hBU :: Ratio a_s1hBR) ->
      case w1_s1hBT of { :% ww1_s1hBX ww2_s1hBY ->
      case w2_s1hBU of { :% ww4_s1hC2 ww5_s1hC3 ->
      GHC.Real.$w$c<
        @ a_s1hBR w_s1hBS ww1_s1hBX ww2_s1hBY ww4_s1hC2 ww5_s1hC3
      }
      }

-- RHS size: {terms: 23, types: 18, coercions: 0, joins: 0/2}
GHC.Real.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> a -> a -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 200 0}]
GHC.Real.$w$c<=
  = \ (@ a_s1hC6)
      (w_s1hC7 :: Integral a_s1hC6)
      (ww_s1hCc
         :: a_s1hC6
         Unf=OtherCon [])
      (ww1_s1hCd
         :: a_s1hC6
         Unf=OtherCon [])
      (ww2_s1hCh
         :: a_s1hC6
         Unf=OtherCon [])
      (ww3_s1hCi
         :: a_s1hC6
         Unf=OtherCon []) ->
      let {
        $dReal_s1fUZ [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
          :: Real a_s1hC6
        [LclId]
        $dReal_s1fUZ = GHC.Real.$p1Integral @ a_s1hC6 w_s1hC7 } in
      let {
        $dNum_s1fUY [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>] :: Num a_s1hC6
        [LclId]
        $dNum_s1fUY = GHC.Real.$p1Real @ a_s1hC6 $dReal_s1fUZ } in
      <=
        @ a_s1hC6
        (GHC.Real.$p2Real @ a_s1hC6 $dReal_s1fUZ)
        (* @ a_s1hC6 $dNum_s1fUY ww_s1hCc ww3_s1hCi)
        (* @ a_s1hC6 $dNum_s1fUY ww2_s1hCh ww1_s1hCd)

-- RHS size: {terms: 16, types: 17, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hC6)
                 (w_s1hC7 [Occ=Once] :: Integral a_s1hC6)
                 (w1_s1hC8 [Occ=Once!] :: Ratio a_s1hC6)
                 (w2_s1hC9 [Occ=Once!] :: Ratio a_s1hC6) ->
                 case w1_s1hC8 of { :% ww1_s1hCc [Occ=Once] ww2_s1hCd [Occ=Once] ->
                 case w2_s1hC9 of { :% ww4_s1hCh [Occ=Once] ww5_s1hCi [Occ=Once] ->
                 GHC.Real.$w$c<=
                   @ a_s1hC6 w_s1hC7 ww1_s1hCc ww2_s1hCd ww4_s1hCh ww5_s1hCi
                 }
                 }}]
GHC.Real.$fOrdRatio_$c<=
  = \ (@ a_s1hC6)
      (w_s1hC7 :: Integral a_s1hC6)
      (w1_s1hC8 :: Ratio a_s1hC6)
      (w2_s1hC9 :: Ratio a_s1hC6) ->
      case w1_s1hC8 of { :% ww1_s1hCc ww2_s1hCd ->
      case w2_s1hC9 of { :% ww4_s1hCh ww5_s1hCi ->
      GHC.Real.$w$c<=
        @ a_s1hC6 w_s1hC7 ww1_s1hCc ww2_s1hCd ww4_s1hCh ww5_s1hCi
      }
      }

-- RHS size: {terms: 21, types: 18, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$cmax
  :: forall a. Integral a => Ratio a -> Ratio a -> Ratio a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eJ2)
                 ($dIntegral_a1eJ3 [Occ=Once] :: Integral a_a1eJ2)
                 (x_a55d :: Ratio a_a1eJ2)
                 (y_a55e :: Ratio a_a1eJ2) ->
                 case GHC.Real.$fOrdRatio_$c<=
                        @ a_a1eJ2 $dIntegral_a1eJ3 x_a55d y_a55e
                 of {
                   False -> x_a55d;
                   True -> y_a55e
                 }}]
GHC.Real.$fOrdRatio_$cmax
  = \ (@ a_a1eJ2)
      ($dIntegral_a1eJ3 :: Integral a_a1eJ2)
      (x_a55d :: Ratio a_a1eJ2)
      (y_a55e :: Ratio a_a1eJ2) ->
      case x_a55d of ww_s1hCb { :% ww1_s1hCc ww2_s1hCd ->
      case y_a55e of ww3_s1hCg { :% ww4_s1hCh ww5_s1hCi ->
      case GHC.Real.$w$c<=
             @ a_a1eJ2 $dIntegral_a1eJ3 ww1_s1hCc ww2_s1hCd ww4_s1hCh ww5_s1hCi
      of {
        False -> ww_s1hCb;
        True -> ww3_s1hCg
      }
      }
      }

-- RHS size: {terms: 21, types: 18, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$cmin
  :: forall a. Integral a => Ratio a -> Ratio a -> Ratio a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,C(C1(U)),A,A,A,A),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eJ2)
                 ($dIntegral_a1eJ3 [Occ=Once] :: Integral a_a1eJ2)
                 (x_a55m :: Ratio a_a1eJ2)
                 (y_a55n :: Ratio a_a1eJ2) ->
                 case GHC.Real.$fOrdRatio_$c<=
                        @ a_a1eJ2 $dIntegral_a1eJ3 x_a55m y_a55n
                 of {
                   False -> y_a55n;
                   True -> x_a55m
                 }}]
GHC.Real.$fOrdRatio_$cmin
  = \ (@ a_a1eJ2)
      ($dIntegral_a1eJ3 :: Integral a_a1eJ2)
      (x_a55m :: Ratio a_a1eJ2)
      (y_a55n :: Ratio a_a1eJ2) ->
      case x_a55m of ww_s1hCb { :% ww1_s1hCc ww2_s1hCd ->
      case y_a55n of ww3_s1hCg { :% ww4_s1hCh ww5_s1hCi ->
      case GHC.Real.$w$c<=
             @ a_a1eJ2 $dIntegral_a1eJ3 ww1_s1hCc ww2_s1hCd ww4_s1hCh ww5_s1hCi
      of {
        False -> ww3_s1hCg;
        True -> ww_s1hCb
      }
      }
      }

-- RHS size: {terms: 52, types: 25, coercions: 0, joins: 0/3}
GHC.Real.$w$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> a -> a -> Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(1*U(A,A,C(C1(U)),A,A,A,A),U(1*U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 370 50}]
GHC.Real.$w$ccompare
  = \ (@ a_s1hCl)
      (w_s1hCm :: Integral a_s1hCl)
      (ww_s1hCr
         :: a_s1hCl
         Unf=OtherCon [])
      (ww1_s1hCs
         :: a_s1hCl
         Unf=OtherCon [])
      (ww2_s1hCw
         :: a_s1hCl
         Unf=OtherCon [])
      (ww3_s1hCx
         :: a_s1hCl
         Unf=OtherCon []) ->
      let {
        $dEq_s1g7w [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real a_s1hCl
        [LclId]
        $dEq_s1g7w = GHC.Real.$p1Integral @ a_s1hCl w_s1hCm } in
      let {
        $dEq1_s1g7x [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
          :: Ord a_s1hCl
        [LclId]
        $dEq1_s1g7x = GHC.Real.$p2Real @ a_s1hCl $dEq_s1g7w } in
      let {
        $dEq2_a1eDK [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_s1hCl
        [LclId]
        $dEq2_a1eDK = GHC.Classes.$p1Ord @ a_s1hCl $dEq1_s1g7x } in
      case == @ a_s1hCl $dEq2_a1eDK ww_s1hCr ww2_s1hCw of {
        False ->
          case GHC.Real.$w$c<=
                 @ a_s1hCl w_s1hCm ww_s1hCr ww1_s1hCs ww2_s1hCw ww3_s1hCx
          of {
            False -> GHC.Types.GT;
            True -> GHC.Types.LT
          };
        True ->
          case == @ a_s1hCl $dEq2_a1eDK ww1_s1hCs ww3_s1hCx of {
            False ->
              case GHC.Real.$w$c<=
                     @ a_s1hCl w_s1hCm ww_s1hCr ww1_s1hCs ww2_s1hCw ww3_s1hCx
              of {
                False -> GHC.Types.GT;
                True -> GHC.Types.LT
              };
            True -> GHC.Types.EQ
          }
      }

-- RHS size: {terms: 16, types: 17, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hCl)
                 (w_s1hCm [Occ=Once] :: Integral a_s1hCl)
                 (w1_s1hCn [Occ=Once!] :: Ratio a_s1hCl)
                 (w2_s1hCo [Occ=Once!] :: Ratio a_s1hCl) ->
                 case w1_s1hCn of { :% ww1_s1hCr [Occ=Once] ww2_s1hCs [Occ=Once] ->
                 case w2_s1hCo of { :% ww4_s1hCw [Occ=Once] ww5_s1hCx [Occ=Once] ->
                 GHC.Real.$w$ccompare
                   @ a_s1hCl w_s1hCm ww1_s1hCr ww2_s1hCs ww4_s1hCw ww5_s1hCx
                 }
                 }}]
GHC.Real.$fOrdRatio_$ccompare
  = \ (@ a_s1hCl)
      (w_s1hCm :: Integral a_s1hCl)
      (w1_s1hCn :: Ratio a_s1hCl)
      (w2_s1hCo :: Ratio a_s1hCl) ->
      case w1_s1hCn of { :% ww1_s1hCr ww2_s1hCs ->
      case w2_s1hCo of { :% ww4_s1hCw ww5_s1hCx ->
      GHC.Real.$w$ccompare
        @ a_s1hCl w_s1hCm ww1_s1hCr ww2_s1hCs ww4_s1hCw ww5_s1hCx
      }
      }

-- RHS size: {terms: 21, types: 18, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$c>
  :: forall a. Integral a => Ratio a -> Ratio a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eJ2)
                 ($dIntegral_a1eJ3 [Occ=Once] :: Integral a_a1eJ2)
                 (x_a1fiM [Occ=Once] :: Ratio a_a1eJ2)
                 (y_a1fiN [Occ=Once] :: Ratio a_a1eJ2) ->
                 case GHC.Real.$fOrdRatio_$ccompare
                        @ a_a1eJ2 $dIntegral_a1eJ3 x_a1fiM y_a1fiN
                 of {
                   __DEFAULT -> GHC.Types.False;
                   GT -> GHC.Types.True
                 }}]
GHC.Real.$fOrdRatio_$c>
  = \ (@ a_a1eJ2)
      ($dIntegral_a1eJ3 :: Integral a_a1eJ2)
      (x_a1fiM :: Ratio a_a1eJ2)
      (y_a1fiN :: Ratio a_a1eJ2) ->
      case x_a1fiM of { :% ww1_s1hCr ww2_s1hCs ->
      case y_a1fiN of { :% ww4_s1hCw ww5_s1hCx ->
      case GHC.Real.$w$ccompare
             @ a_a1eJ2 $dIntegral_a1eJ3 ww1_s1hCr ww2_s1hCs ww4_s1hCw ww5_s1hCx
      of {
        __DEFAULT -> GHC.Types.False;
        GT -> GHC.Types.True
      }
      }
      }

-- RHS size: {terms: 21, types: 18, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio_$c>=
  :: forall a. Integral a => Ratio a -> Ratio a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eJ2)
                 ($dIntegral_a1eJ3 [Occ=Once] :: Integral a_a1eJ2)
                 (x_a1fiT [Occ=Once] :: Ratio a_a1eJ2)
                 (y_a1fiU [Occ=Once] :: Ratio a_a1eJ2) ->
                 case GHC.Real.$fOrdRatio_$ccompare
                        @ a_a1eJ2 $dIntegral_a1eJ3 x_a1fiT y_a1fiU
                 of {
                   __DEFAULT -> GHC.Types.True;
                   LT -> GHC.Types.False
                 }}]
GHC.Real.$fOrdRatio_$c>=
  = \ (@ a_a1eJ2)
      ($dIntegral_a1eJ3 :: Integral a_a1eJ2)
      (x_a1fiT :: Ratio a_a1eJ2)
      (y_a1fiU :: Ratio a_a1eJ2) ->
      case x_a1fiT of { :% ww1_s1hCr ww2_s1hCs ->
      case y_a1fiU of { :% ww4_s1hCw ww5_s1hCx ->
      case GHC.Real.$w$ccompare
             @ a_a1eJ2 $dIntegral_a1eJ3 ww1_s1hCr ww2_s1hCs ww4_s1hCw ww5_s1hCx
      of {
        __DEFAULT -> GHC.Types.True;
        LT -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 19, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fOrdRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Integral a => Ord (Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(U(A,A,C(C1(U)),A,A,A,A),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_a1dOQ) (v_B1 :: Integral a_a1dOQ) ->
       GHC.Classes.C:Ord TYPE: Ratio a_a1dOQ
                         GHC.Real.$fOrdRatio_$cp1Ord @ a_a1dOQ v_B1
                         GHC.Real.$fOrdRatio_$ccompare @ a_a1dOQ v_B1
                         GHC.Real.$fOrdRatio_$c< @ a_a1dOQ v_B1
                         GHC.Real.$fOrdRatio_$c<= @ a_a1dOQ v_B1
                         GHC.Real.$fOrdRatio_$c> @ a_a1dOQ v_B1
                         GHC.Real.$fOrdRatio_$c>= @ a_a1dOQ v_B1
                         GHC.Real.$fOrdRatio_$cmax @ a_a1dOQ v_B1
                         GHC.Real.$fOrdRatio_$cmin @ a_a1dOQ v_B1]
GHC.Real.$fOrdRatio
  = \ (@ a_a1eJ2) ($dIntegral_a1eJ3 :: Integral a_a1eJ2) ->
      GHC.Classes.C:Ord
        @ (Ratio a_a1eJ2)
        (GHC.Real.$fOrdRatio_$cp1Ord @ a_a1eJ2 $dIntegral_a1eJ3)
        (GHC.Real.$fOrdRatio_$ccompare @ a_a1eJ2 $dIntegral_a1eJ3)
        (GHC.Real.$fOrdRatio_$c< @ a_a1eJ2 $dIntegral_a1eJ3)
        (GHC.Real.$fOrdRatio_$c<= @ a_a1eJ2 $dIntegral_a1eJ3)
        (GHC.Real.$fOrdRatio_$c> @ a_a1eJ2 $dIntegral_a1eJ3)
        (GHC.Real.$fOrdRatio_$c>= @ a_a1eJ2 $dIntegral_a1eJ3)
        (GHC.Real.$fOrdRatio_$cmax @ a_a1eJ2 $dIntegral_a1eJ3)
        (GHC.Real.$fOrdRatio_$cmin @ a_a1eJ2 $dIntegral_a1eJ3)

-- RHS size: {terms: 16, types: 15, coercions: 0, joins: 0/0}
GHC.Real.$fNumRatio_$cnegate [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LLLC(S)LLL)LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,A),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hCA)
                 (w_s1hCB [Occ=Once] :: Integral a_s1hCA)
                 (w1_s1hCC [Occ=Once!] :: Ratio a_s1hCA) ->
                 case w1_s1hCC of { :% ww1_s1hCF [Occ=Once] ww2_s1hCG [Occ=Once] ->
                 case negate
                        @ a_s1hCA
                        (GHC.Real.$p1Real
                           @ a_s1hCA (GHC.Real.$p1Integral @ a_s1hCA w_s1hCB))
                        ww1_s1hCF
                 of dt_X1e5P
                 { __DEFAULT ->
                 GHC.Real.:% @ a_s1hCA dt_X1e5P ww2_s1hCG
                 }
                 }}]
GHC.Real.$fNumRatio_$cnegate
  = \ (@ a_s1hCA)
      (w_s1hCB :: Integral a_s1hCA)
      (w1_s1hCC :: Ratio a_s1hCA) ->
      case w1_s1hCC of { :% ww1_s1hCF ww2_s1hCG ->
      case negate
             @ a_s1hCA
             (GHC.Real.$p1Real
                @ a_s1hCA (GHC.Real.$p1Integral @ a_s1hCA w_s1hCB))
             ww1_s1hCF
      of dt_X1e5P
      { __DEFAULT ->
      GHC.Real.:% @ a_s1hCA dt_X1e5P ww2_s1hCG
      }
      }

-- RHS size: {terms: 16, types: 15, coercions: 0, joins: 0/0}
GHC.Real.$fNumRatio_$cabs [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(LLLLC(S)LL)LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,1*C1(U),A,A),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hCM)
                 (w_s1hCN [Occ=Once] :: Integral a_s1hCM)
                 (w1_s1hCO [Occ=Once!] :: Ratio a_s1hCM) ->
                 case w1_s1hCO of { :% ww1_s1hCR [Occ=Once] ww2_s1hCS [Occ=Once] ->
                 case abs
                        @ a_s1hCM
                        (GHC.Real.$p1Real
                           @ a_s1hCM (GHC.Real.$p1Integral @ a_s1hCM w_s1hCN))
                        ww1_s1hCR
                 of dt_X1e5R
                 { __DEFAULT ->
                 GHC.Real.:% @ a_s1hCM dt_X1e5R ww2_s1hCS
                 }
                 }}]
GHC.Real.$fNumRatio_$cabs
  = \ (@ a_s1hCM)
      (w_s1hCN :: Integral a_s1hCM)
      (w1_s1hCO :: Ratio a_s1hCM) ->
      case w1_s1hCO of { :% ww1_s1hCR ww2_s1hCS ->
      case abs
             @ a_s1hCM
             (GHC.Real.$p1Real
                @ a_s1hCM (GHC.Real.$p1Integral @ a_s1hCM w_s1hCN))
             ww1_s1hCR
      of dt_X1e5R
      { __DEFAULT ->
      GHC.Real.:% @ a_s1hCM dt_X1e5R ww2_s1hCS
      }
      }

-- RHS size: {terms: 22, types: 19, coercions: 0, joins: 0/2}
GHC.Real.$w$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLC(S)C(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 140 30}]
GHC.Real.$w$csignum
  = \ (@ a_s1hCY)
      (w_s1hCZ :: Integral a_s1hCY)
      (ww_s1hD3
         :: a_s1hCY
         Unf=OtherCon []) ->
      let {
        $dReal_s1fUV [Dmd=<S(S(LLLLLC(S)C(S))LL),1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A)>]
          :: Real a_s1hCY
        [LclId]
        $dReal_s1fUV = GHC.Real.$p1Integral @ a_s1hCY w_s1hCZ } in
      let {
        $dNum_s1fUU [Dmd=<S(LLLLLC(S)C(S)),U(A,A,A,A,A,1*C1(U),1*C1(U))>]
          :: Num a_s1hCY
        [LclId]
        $dNum_s1fUU = GHC.Real.$p1Real @ a_s1hCY $dReal_s1fUV } in
      case signum @ a_s1hCY $dNum_s1fUU ww_s1hD3 of dt_X1e5Y
      { __DEFAULT ->
      case fromInteger @ a_s1hCY $dNum_s1fUU GHC.Real.$fEnumRatio1
      of dt1_X1e63
      { __DEFAULT ->
      (# dt_X1e5Y, dt1_X1e63 #)
      }
      }

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
GHC.Real.$fNumRatio_$csignum [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLC(S)C(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,1*C1(U),1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SL),1*U(U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hCY)
                 (w_s1hCZ [Occ=Once] :: Integral a_s1hCY)
                 (w1_s1hD0 [Occ=Once!] :: Ratio a_s1hCY) ->
                 case w1_s1hD0 of { :% ww1_s1hD3 [Occ=Once] _ [Occ=Dead] ->
                 case GHC.Real.$w$csignum @ a_s1hCY w_s1hCZ ww1_s1hD3 of
                 { (# ww4_s1hLn [Occ=Once], ww5_s1hLo [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hCY ww4_s1hLn ww5_s1hLo
                 }
                 }}]
GHC.Real.$fNumRatio_$csignum
  = \ (@ a_s1hCY)
      (w_s1hCZ :: Integral a_s1hCY)
      (w1_s1hD0 :: Ratio a_s1hCY) ->
      case w1_s1hD0 of { :% ww1_s1hD3 ww2_s1hD4 ->
      case GHC.Real.$w$csignum @ a_s1hCY w_s1hCZ ww1_s1hD3 of
      { (# ww4_s1hLn, ww5_s1hLo #) ->
      GHC.Real.:% @ a_s1hCY ww4_s1hLn ww5_s1hLo
      }
      }

-- RHS size: {terms: 22, types: 19, coercions: 0, joins: 0/2}
GHC.Real.$w$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Integer -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 140 30}]
GHC.Real.$w$cfromInteger
  = \ (@ a_s1hDa)
      (w_s1hDb :: Integral a_s1hDa)
      (w1_s1hDc :: Integer) ->
      let {
        $dReal_s1fUR [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
          :: Real a_s1hDa
        [LclId]
        $dReal_s1fUR = GHC.Real.$p1Integral @ a_s1hDa w_s1hDb } in
      let {
        $dNum_s1fUQ [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
          :: Num a_s1hDa
        [LclId]
        $dNum_s1fUQ = GHC.Real.$p1Real @ a_s1hDa $dReal_s1fUR } in
      case fromInteger @ a_s1hDa $dNum_s1fUQ w1_s1hDc of dt_X1e5V
      { __DEFAULT ->
      case fromInteger @ a_s1hDa $dNum_s1fUQ GHC.Real.$fEnumRatio1
      of dt1_X1e60
      { __DEFAULT ->
      (# dt_X1e5V, dt1_X1e60 #)
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fNumRatio_$cfromInteger [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Integer -> Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hDa)
                 (w_s1hDb [Occ=Once] :: Integral a_s1hDa)
                 (w1_s1hDc [Occ=Once] :: Integer) ->
                 case GHC.Real.$w$cfromInteger @ a_s1hDa w_s1hDb w1_s1hDc of
                 { (# ww1_s1hLq [Occ=Once], ww2_s1hLr [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hDa ww1_s1hLq ww2_s1hLr
                 }}]
GHC.Real.$fNumRatio_$cfromInteger
  = \ (@ a_s1hDa)
      (w_s1hDb :: Integral a_s1hDa)
      (w1_s1hDc :: Integer) ->
      case GHC.Real.$w$cfromInteger @ a_s1hDa w_s1hDb w1_s1hDc of
      { (# ww1_s1hLq, ww2_s1hLr #) ->
      GHC.Real.:% @ a_s1hDa ww1_s1hLq ww2_s1hLr
      }

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.Real.$fRealRatio_$s$ctoRational :: Ratio Integer -> Rational
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_d1fgd [Occ=Once] :: Ratio Integer) -> ds_d1fgd}]
GHC.Real.$fRealRatio_$s$ctoRational
  = \ (ds_d1fgd :: Ratio Integer) -> ds_d1fgd

-- RHS size: {terms: 19, types: 15, coercions: 0, joins: 0/0}
GHC.Real.$fRealRatio_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Rational
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)),U(A,A,A,A,A,A,A,A,C(U))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hDh)
                 (w_s1hDi :: Integral a_s1hDh)
                 (w1_s1hDj [Occ=Once!] :: Ratio a_s1hDh) ->
                 case w1_s1hDj of { :% ww1_s1hDm [Occ=Once] ww2_s1hDn [Occ=Once] ->
                 case toInteger @ a_s1hDh w_s1hDi ww1_s1hDm of dt_X1e60
                 { __DEFAULT ->
                 case toInteger @ a_s1hDh w_s1hDi ww2_s1hDn of dt1_X1e65
                 { __DEFAULT ->
                 GHC.Real.:% @ Integer dt_X1e60 dt1_X1e65
                 }
                 }
                 }}]
GHC.Real.$fRealRatio_$ctoRational
  = \ (@ a_s1hDh)
      (w_s1hDi :: Integral a_s1hDh)
      (w1_s1hDj :: Ratio a_s1hDh) ->
      case w1_s1hDj of { :% ww1_s1hDm ww2_s1hDn ->
      case toInteger @ a_s1hDh w_s1hDi ww1_s1hDm of dt_X1e60
      { __DEFAULT ->
      case toInteger @ a_s1hDh w_s1hDi ww2_s1hDn of dt1_X1e65
      { __DEFAULT ->
      GHC.Real.:% @ Integer dt_X1e60 dt1_X1e65
      }
      }
      }

-- RHS size: {terms: 50, types: 37, coercions: 0, joins: 0/3}
GHC.Real.$w$crecip [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 370 60}]
GHC.Real.$w$crecip
  = \ (@ a_s1hDt)
      (w_s1hDu :: Integral a_s1hDt)
      (ww_s1hDy
         :: a_s1hDt
         Unf=OtherCon [])
      (ww1_s1hDz
         :: a_s1hDt
         Unf=OtherCon []) ->
      let {
        $dReal_s1fUN [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
          :: Real a_s1hDt
        [LclId]
        $dReal_s1fUN = GHC.Real.$p1Integral @ a_s1hDt w_s1hDu } in
      let {
        $dNum_s1fUM [Dmd=<L,U(A,A,A,C(U),A,A,C(U))>] :: Num a_s1hDt
        [LclId]
        $dNum_s1fUM = GHC.Real.$p1Real @ a_s1hDt $dReal_s1fUN } in
      let {
        $dOrd_s1fUL [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
          :: Ord a_s1hDt
        [LclId]
        $dOrd_s1fUL = GHC.Real.$p2Real @ a_s1hDt $dReal_s1fUN } in
      case ==
             @ a_s1hDt
             (GHC.Classes.$p1Ord @ a_s1hDt $dOrd_s1fUL)
             ww_s1hDy
             (fromInteger @ a_s1hDt $dNum_s1fUM GHC.Real.even1)
      of {
        False ->
          case < @ a_s1hDt
                 $dOrd_s1fUL
                 ww_s1hDy
                 (fromInteger @ a_s1hDt $dNum_s1fUM GHC.Real.even1)
          of {
            False -> (# ww1_s1hDz, ww_s1hDy #);
            True ->
              case negate @ a_s1hDt $dNum_s1fUM ww1_s1hDz of dt_X1e6g
              { __DEFAULT ->
              case negate @ a_s1hDt $dNum_s1fUM ww_s1hDy of dt1_X1e6l
              { __DEFAULT ->
              (# dt_X1e6g, dt1_X1e6l #)
              }
              }
          };
        True -> case ratioZeroDenominatorError of wild1_00 { }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$crecip [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hDt)
                 (w_s1hDu [Occ=Once] :: Integral a_s1hDt)
                 (w1_s1hDv [Occ=Once!] :: Ratio a_s1hDt) ->
                 case w1_s1hDv of { :% ww1_s1hDy [Occ=Once] ww2_s1hDz [Occ=Once] ->
                 case GHC.Real.$w$crecip @ a_s1hDt w_s1hDu ww1_s1hDy ww2_s1hDz of
                 { (# ww4_s1hLw [Occ=Once], ww5_s1hLx [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hDt ww4_s1hLw ww5_s1hLx
                 }
                 }}]
GHC.Real.$fFractionalRatio_$crecip
  = \ (@ a_s1hDt)
      (w_s1hDu :: Integral a_s1hDt)
      (w1_s1hDv :: Ratio a_s1hDt) ->
      case w1_s1hDv of { :% ww1_s1hDy ww2_s1hDz ->
      case GHC.Real.$w$crecip @ a_s1hDt w_s1hDu ww1_s1hDy ww2_s1hDz of
      { (# ww4_s1hLw, ww5_s1hLx #) ->
      GHC.Real.:% @ a_s1hDt ww4_s1hLw ww5_s1hLx
      }
      }

-- RHS size: {terms: 38, types: 42, coercions: 0, joins: 0/1}
GHC.Real.$w$s$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b.
     Integral b =>
     Integer -> Integer -> (# b, Ratio Integer #)
[GblId,
 Arity=3,
 Str=<L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 220 30}]
GHC.Real.$w$s$cproperFraction
  = \ (@ b_s1hDF)
      (w_s1hDG :: Integral b_s1hDF)
      (ww_s1hDK
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hDL
         :: Integer
         Unf=OtherCon []) ->
      let {
        ds_s1fUH [Dmd=<L,U(1*U,1*U)>] :: (Integer, Integer)
        [LclId]
        ds_s1fUH
          = case eqInteger# ww1_s1hDL GHC.Real.even1 of {
              __DEFAULT ->
                case quotRemInteger ww_s1hDK ww1_s1hDL of
                { (# ipv_s1fpa, ipv1_s1fpb #) ->
                (ipv_s1fpa, ipv1_s1fpb)
                };
              1# -> divZeroError @ (Integer, Integer)
            } } in
      (# fromInteger
           @ b_s1hDF
           (GHC.Real.$p1Real
              @ b_s1hDF (GHC.Real.$p1Integral @ b_s1hDF w_s1hDG))
           (case ds_s1fUH of { (q_a1eFC, r_a1eFE) -> q_a1eFC }),
         case ds_s1fUH of { (q_a1eFC, r_a1eFE) ->
         case r_a1eFE of dt_X1e6e { __DEFAULT ->
         GHC.Real.:% @ Integer dt_X1e6e ww1_s1hDL
         }
         } #)

-- RHS size: {terms: 15, types: 23, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$s$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Ratio Integer -> (b, Ratio Integer)
[GblId,
 Arity=2,
 Str=<L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s1hDF)
                 (w_s1hDG [Occ=Once] :: Integral b_s1hDF)
                 (w1_s1hDH [Occ=Once!] :: Ratio Integer) ->
                 case w1_s1hDH of { :% ww1_s1hDK [Occ=Once] ww2_s1hDL [Occ=Once] ->
                 case GHC.Real.$w$s$cproperFraction
                        @ b_s1hDF w_s1hDG ww1_s1hDK ww2_s1hDL
                 of
                 { (# ww4_s1hLz [Occ=Once], ww5_s1hLA [Occ=Once] #) ->
                 (ww4_s1hLz, ww5_s1hLA)
                 }
                 }}]
GHC.Real.$fEnumRatio_$s$cproperFraction
  = \ (@ b_s1hDF)
      (w_s1hDG :: Integral b_s1hDF)
      (w1_s1hDH :: Ratio Integer) ->
      case w1_s1hDH of { :% ww1_s1hDK ww2_s1hDL ->
      case GHC.Real.$w$s$cproperFraction
             @ b_s1hDF w_s1hDG ww1_s1hDK ww2_s1hDL
      of
      { (# ww4_s1hLz, ww5_s1hLA #) ->
      (ww4_s1hLz, ww5_s1hLA)
      }
      }

-- RHS size: {terms: 31, types: 35, coercions: 0, joins: 0/1}
GHC.Real.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Integral a =>
     forall b. Integral b => a -> a -> (# b, Ratio a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,1*C1(C1(U(1*U,1*U))),A,1*C1(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 30 0 0] 190 30}]
GHC.Real.$w$cproperFraction
  = \ (@ a_s1hDR)
      (w_s1hDS :: Integral a_s1hDR)
      (@ b_s1hDT)
      (w1_s1hDU :: Integral b_s1hDT)
      (ww_s1hDY
         :: a_s1hDR
         Unf=OtherCon [])
      (ww1_s1hDZ
         :: a_s1hDR
         Unf=OtherCon []) ->
      let {
        ds_s1fUE [Dmd=<L,U(1*U,1*U)>] :: (a_s1hDR, a_s1hDR)
        [LclId]
        ds_s1fUE = quotRem @ a_s1hDR w_s1hDS ww_s1hDY ww1_s1hDZ } in
      (# fromInteger
           @ b_s1hDT
           (GHC.Real.$p1Real
              @ b_s1hDT (GHC.Real.$p1Integral @ b_s1hDT w1_s1hDU))
           (toInteger
              @ a_s1hDR
              w_s1hDS
              (case ds_s1fUE of { (q_a1eFC, r_a1eFE) -> q_a1eFC })),
         case ds_s1fUE of { (q_a1eFC, r_a1eFE) ->
         case r_a1eFE of dt_X1ej7 { __DEFAULT ->
         GHC.Real.:% @ a_s1hDR dt_X1ej7 ww1_s1hDZ
         }
         } #)

-- RHS size: {terms: 18, types: 28, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Integral a =>
     forall b. Integral b => Ratio a -> (b, Ratio a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hDR)
                 (w_s1hDS [Occ=Once] :: Integral a_s1hDR)
                 (@ b_s1hDT)
                 (w1_s1hDU [Occ=Once] :: Integral b_s1hDT)
                 (w2_s1hDV [Occ=Once!] :: Ratio a_s1hDR) ->
                 case w2_s1hDV of { :% ww1_s1hDY [Occ=Once] ww2_s1hDZ [Occ=Once] ->
                 case GHC.Real.$w$cproperFraction
                        @ a_s1hDR w_s1hDS @ b_s1hDT w1_s1hDU ww1_s1hDY ww2_s1hDZ
                 of
                 { (# ww4_s1hLC [Occ=Once], ww5_s1hLD [Occ=Once] #) ->
                 (ww4_s1hLC, ww5_s1hLD)
                 }
                 }}]
GHC.Real.$fEnumRatio_$cproperFraction
  = \ (@ a_s1hDR)
      (w_s1hDS :: Integral a_s1hDR)
      (@ b_s1hDT)
      (w1_s1hDU :: Integral b_s1hDT)
      (w2_s1hDV :: Ratio a_s1hDR) ->
      case w2_s1hDV of { :% ww1_s1hDY ww2_s1hDZ ->
      case GHC.Real.$w$cproperFraction
             @ a_s1hDR w_s1hDS @ b_s1hDT w1_s1hDU ww1_s1hDY ww2_s1hDZ
      of
      { (# ww4_s1hLC, ww5_s1hLD #) ->
      (ww4_s1hLC, ww5_s1hLD)
      }
      }

-- RHS size: {terms: 41, types: 28, coercions: 0, joins: 0/2}
GHC.Real.$wreduce [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,A,A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 0 0] 330 30}]
GHC.Real.$wreduce
  = \ (@ a_s1hE5)
      (w_s1hE6 :: Integral a_s1hE5)
      (w1_s1hE7 :: a_s1hE5)
      (w2_s1hE8 :: a_s1hE5) ->
      let {
        $dReal_s1fUy [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real a_s1hE5
        [LclId]
        $dReal_s1fUy = GHC.Real.$p1Integral @ a_s1hE5 w_s1hE6 } in
      case ==
             @ a_s1hE5
             (GHC.Classes.$p1Ord
                @ a_s1hE5 (GHC.Real.$p2Real @ a_s1hE5 $dReal_s1fUy))
             w2_s1hE8
             (fromInteger
                @ a_s1hE5 (GHC.Real.$p1Real @ a_s1hE5 $dReal_s1fUy) GHC.Real.even1)
      of {
        False ->
          let {
            d_s1fUA :: a_s1hE5
            [LclId]
            d_s1fUA = gcd @ a_s1hE5 w_s1hE6 w1_s1hE7 w2_s1hE8 } in
          case quot @ a_s1hE5 w_s1hE6 w1_s1hE7 d_s1fUA of dt_X1e6d
          { __DEFAULT ->
          case quot @ a_s1hE5 w_s1hE6 w2_s1hE8 d_s1fUA of dt1_X1ej5
          { __DEFAULT ->
          (# dt_X1e6d, dt1_X1ej5 #)
          }
          };
        True -> case ratioZeroDenominatorError of wild1_00 { }
      }

-- RHS size: {terms: 13, types: 15, coercions: 0, joins: 0/0}
reduce [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,A,A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hE5)
                 (w_s1hE6 [Occ=Once] :: Integral a_s1hE5)
                 (w1_s1hE7 [Occ=Once] :: a_s1hE5)
                 (w2_s1hE8 [Occ=Once] :: a_s1hE5) ->
                 case GHC.Real.$wreduce @ a_s1hE5 w_s1hE6 w1_s1hE7 w2_s1hE8 of
                 { (# ww1_s1hLF [Occ=Once], ww2_s1hLG [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hE5 ww1_s1hLF ww2_s1hLG
                 }}]
reduce
  = \ (@ a_s1hE5)
      (w_s1hE6 :: Integral a_s1hE5)
      (w1_s1hE7 :: a_s1hE5)
      (w2_s1hE8 :: a_s1hE5) ->
      case GHC.Real.$wreduce @ a_s1hE5 w_s1hE6 w1_s1hE7 w2_s1hE8 of
      { (# ww1_s1hLF, ww2_s1hLG #) ->
      GHC.Real.:% @ a_s1hE5 ww1_s1hLF ww2_s1hLG
      }

-- RHS size: {terms: 10, types: 10, coercions: 0, joins: 0/0}
GHC.Real.%_$s% [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Integer -> Ratio Integer
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hEd [Occ=Once] :: Integer)
                 (w1_s1hEe [Occ=Once] :: Integer) ->
                 case GHC.Real.$w$s$cfromRational w_s1hEd w1_s1hEe of
                 { (# ww1_s1hLI [Occ=Once], ww2_s1hLJ [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww1_s1hLI ww2_s1hLJ
                 }}]
GHC.Real.%_$s%
  = \ (w_s1hEd :: Integer) (w1_s1hEe :: Integer) ->
      case GHC.Real.$w$s$cfromRational w_s1hEd w1_s1hEe of
      { (# ww1_s1hLI, ww2_s1hLJ #) ->
      GHC.Real.:% @ Integer ww1_s1hLI ww2_s1hLJ
      }

-- RHS size: {terms: 21, types: 16, coercions: 0, joins: 0/2}
GHC.Real.$w% [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,1*C1(C1(U)),A,C(U),1*C1(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 200 0}]
GHC.Real.$w%
  = \ (@ a_s1hEj)
      (w_s1hEk :: Integral a_s1hEj)
      (w1_s1hEl :: a_s1hEj)
      (w2_s1hEm :: a_s1hEj) ->
      let {
        $dReal_s1fUw [Dmd=<L,1*U(1*U(A,A,1*C1(C1(U)),A,1*C1(U),1*C1(U),A),A,A)>]
          :: Real a_s1hEj
        [LclId]
        $dReal_s1fUw = GHC.Real.$p1Integral @ a_s1hEj w_s1hEk } in
      let {
        $dNum_s1fUv [Dmd=<L,U(A,A,1*C1(C1(U)),A,1*C1(U),1*C1(U),A)>]
          :: Num a_s1hEj
        [LclId]
        $dNum_s1fUv = GHC.Real.$p1Real @ a_s1hEj $dReal_s1fUw } in
      GHC.Real.$wreduce
        @ a_s1hEj
        w_s1hEk
        (* @ a_s1hEj
           $dNum_s1fUv
           w1_s1hEl
           (signum @ a_s1hEj $dNum_s1fUv w2_s1hEm))
        (abs @ a_s1hEj $dNum_s1fUv w2_s1hEm)

-- RHS size: {terms: 13, types: 15, coercions: 0, joins: 0/0}
% [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hEj)
                 (w_s1hEk [Occ=Once] :: Integral a_s1hEj)
                 (w1_s1hEl [Occ=Once] :: a_s1hEj)
                 (w2_s1hEm [Occ=Once] :: a_s1hEj) ->
                 case GHC.Real.$w% @ a_s1hEj w_s1hEk w1_s1hEl w2_s1hEm of
                 { (# ww1_s1hLL [Occ=Once], ww2_s1hLM [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hEj ww1_s1hLL ww2_s1hLM
                 }}]
% = \ (@ a_s1hEj)
      (w_s1hEk :: Integral a_s1hEj)
      (w1_s1hEl :: a_s1hEj)
      (w2_s1hEm :: a_s1hEj) ->
      case GHC.Real.$w% @ a_s1hEj w_s1hEk w1_s1hEl w2_s1hEm of
      { (# ww1_s1hLL, ww2_s1hLM #) ->
      GHC.Real.:% @ a_s1hEj ww1_s1hLL ww2_s1hLM
      }

-- RHS size: {terms: 22, types: 17, coercions: 0, joins: 0/2}
GHC.Real.$w$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 180 0}]
GHC.Real.$w$c/
  = \ (@ a_s1hEr)
      (w_s1hEs :: Integral a_s1hEr)
      (ww_s1hEx
         :: a_s1hEr
         Unf=OtherCon [])
      (ww1_s1hEy
         :: a_s1hEr
         Unf=OtherCon [])
      (ww2_s1hEC
         :: a_s1hEr
         Unf=OtherCon [])
      (ww3_s1hED
         :: a_s1hEr
         Unf=OtherCon []) ->
      let {
        $dReal_s1fUq [Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_s1hEr
        [LclId]
        $dReal_s1fUq = GHC.Real.$p1Integral @ a_s1hEr w_s1hEs } in
      let {
        $dNum_s1fUp [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>] :: Num a_s1hEr
        [LclId]
        $dNum_s1fUp = GHC.Real.$p1Real @ a_s1hEr $dReal_s1fUq } in
      GHC.Real.$w%
        @ a_s1hEr
        w_s1hEs
        (* @ a_s1hEr $dNum_s1fUp ww_s1hEx ww3_s1hED)
        (* @ a_s1hEr $dNum_s1fUp ww1_s1hEy ww2_s1hEC)

-- RHS size: {terms: 21, types: 25, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$c/ [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a -> Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hEr)
                 (w_s1hEs [Occ=Once] :: Integral a_s1hEr)
                 (w1_s1hEt [Occ=Once!] :: Ratio a_s1hEr)
                 (w2_s1hEu [Occ=Once!] :: Ratio a_s1hEr) ->
                 case w1_s1hEt of { :% ww1_s1hEx [Occ=Once] ww2_s1hEy [Occ=Once] ->
                 case w2_s1hEu of { :% ww4_s1hEC [Occ=Once] ww5_s1hED [Occ=Once] ->
                 case GHC.Real.$w$c/
                        @ a_s1hEr w_s1hEs ww1_s1hEx ww2_s1hEy ww4_s1hEC ww5_s1hED
                 of
                 { (# ww7_s1hLO [Occ=Once], ww8_s1hLP [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hEr ww7_s1hLO ww8_s1hLP
                 }
                 }
                 }}]
GHC.Real.$fFractionalRatio_$c/
  = \ (@ a_s1hEr)
      (w_s1hEs :: Integral a_s1hEr)
      (w1_s1hEt :: Ratio a_s1hEr)
      (w2_s1hEu :: Ratio a_s1hEr) ->
      case w1_s1hEt of { :% ww1_s1hEx ww2_s1hEy ->
      case w2_s1hEu of { :% ww4_s1hEC ww5_s1hED ->
      case GHC.Real.$w$c/
             @ a_s1hEr w_s1hEs ww1_s1hEx ww2_s1hEy ww4_s1hEC ww5_s1hED
      of
      { (# ww7_s1hLO, ww8_s1hLP #) ->
      GHC.Real.:% @ a_s1hEr ww7_s1hLO ww8_s1hLP
      }
      }
      }

-- RHS size: {terms: 18, types: 15, coercions: 0, joins: 0/2}
GHC.Real.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Integer -> Integer -> (# a, a #)
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 160 0}]
GHC.Real.$w$cfromRational
  = \ (@ a_s1hEJ)
      (w_s1hEK :: Integral a_s1hEJ)
      (ww_s1hEO
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hEP
         :: Integer
         Unf=OtherCon []) ->
      let {
        $dReal_s1fUm [Dmd=<L,1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
          :: Real a_s1hEJ
        [LclId]
        $dReal_s1fUm = GHC.Real.$p1Integral @ a_s1hEJ w_s1hEK } in
      let {
        $dNum_s1fUl [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_s1hEJ
        [LclId]
        $dNum_s1fUl = GHC.Real.$p1Real @ a_s1hEJ $dReal_s1fUm } in
      GHC.Real.$w%
        @ a_s1hEJ
        w_s1hEK
        (fromInteger @ a_s1hEJ $dNum_s1fUl ww_s1hEO)
        (fromInteger @ a_s1hEJ $dNum_s1fUl ww1_s1hEP)

-- RHS size: {terms: 15, types: 17, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio_$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Rational -> Ratio a
[GblId,
 Arity=2,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hEJ)
                 (w_s1hEK [Occ=Once] :: Integral a_s1hEJ)
                 (w1_s1hEL [Occ=Once!] :: Rational) ->
                 case w1_s1hEL of { :% ww1_s1hEO [Occ=Once] ww2_s1hEP [Occ=Once] ->
                 case GHC.Real.$w$cfromRational
                        @ a_s1hEJ w_s1hEK ww1_s1hEO ww2_s1hEP
                 of
                 { (# ww4_s1hLR [Occ=Once], ww5_s1hLS [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hEJ ww4_s1hLR ww5_s1hLS
                 }
                 }}]
GHC.Real.$fFractionalRatio_$cfromRational
  = \ (@ a_s1hEJ)
      (w_s1hEK :: Integral a_s1hEJ)
      (w1_s1hEL :: Rational) ->
      case w1_s1hEL of { :% ww1_s1hEO ww2_s1hEP ->
      case GHC.Real.$w$cfromRational
             @ a_s1hEJ w_s1hEK ww1_s1hEO ww2_s1hEP
      of
      { (# ww4_s1hLR, ww5_s1hLS #) ->
      GHC.Real.:% @ a_s1hEJ ww4_s1hLR ww5_s1hLS
      }
      }

-- RHS size: {terms: 28, types: 19, coercions: 0, joins: 0/2}
GHC.Real.$w$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(1*C1(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 260 0}]
GHC.Real.$w$c+
  = \ (@ a_s1hEV)
      (w_s1hEW :: Integral a_s1hEV)
      (ww_s1hF1
         :: a_s1hEV
         Unf=OtherCon [])
      (ww1_s1hF2
         :: a_s1hEV
         Unf=OtherCon [])
      (ww2_s1hF6
         :: a_s1hEV
         Unf=OtherCon [])
      (ww3_s1hF7
         :: a_s1hEV
         Unf=OtherCon []) ->
      let {
        $dReal_s1fUi [Dmd=<L,1*U(1*U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_s1hEV
        [LclId]
        $dReal_s1fUi = GHC.Real.$p1Integral @ a_s1hEV w_s1hEW } in
      let {
        $dNum_s1fUh [Dmd=<L,U(1*C1(C1(U)),A,C(C1(U)),A,A,A,A)>]
          :: Num a_s1hEV
        [LclId]
        $dNum_s1fUh = GHC.Real.$p1Real @ a_s1hEV $dReal_s1fUi } in
      GHC.Real.$wreduce
        @ a_s1hEV
        w_s1hEW
        (+ @ a_s1hEV
           $dNum_s1fUh
           (* @ a_s1hEV $dNum_s1fUh ww_s1hF1 ww3_s1hF7)
           (* @ a_s1hEV $dNum_s1fUh ww2_s1hF6 ww1_s1hF2))
        (* @ a_s1hEV $dNum_s1fUh ww1_s1hF2 ww3_s1hF7)

-- RHS size: {terms: 21, types: 25, coercions: 0, joins: 0/0}
GHC.Real.$fNumRatio_$c+ [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a -> Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hEV)
                 (w_s1hEW [Occ=Once] :: Integral a_s1hEV)
                 (w1_s1hEX [Occ=Once!] :: Ratio a_s1hEV)
                 (w2_s1hEY [Occ=Once!] :: Ratio a_s1hEV) ->
                 case w1_s1hEX of { :% ww1_s1hF1 [Occ=Once] ww2_s1hF2 [Occ=Once] ->
                 case w2_s1hEY of { :% ww4_s1hF6 [Occ=Once] ww5_s1hF7 [Occ=Once] ->
                 case GHC.Real.$w$c+
                        @ a_s1hEV w_s1hEW ww1_s1hF1 ww2_s1hF2 ww4_s1hF6 ww5_s1hF7
                 of
                 { (# ww7_s1hLU [Occ=Once], ww8_s1hLV [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hEV ww7_s1hLU ww8_s1hLV
                 }
                 }
                 }}]
GHC.Real.$fNumRatio_$c+
  = \ (@ a_s1hEV)
      (w_s1hEW :: Integral a_s1hEV)
      (w1_s1hEX :: Ratio a_s1hEV)
      (w2_s1hEY :: Ratio a_s1hEV) ->
      case w1_s1hEX of { :% ww1_s1hF1 ww2_s1hF2 ->
      case w2_s1hEY of { :% ww4_s1hF6 ww5_s1hF7 ->
      case GHC.Real.$w$c+
             @ a_s1hEV w_s1hEW ww1_s1hF1 ww2_s1hF2 ww4_s1hF6 ww5_s1hF7
      of
      { (# ww7_s1hLU, ww8_s1hLV #) ->
      GHC.Real.:% @ a_s1hEV ww7_s1hLU ww8_s1hLV
      }
      }
      }

-- RHS size: {terms: 28, types: 19, coercions: 0, joins: 0/2}
GHC.Real.$w$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,1*C1(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 260 0}]
GHC.Real.$w$c-
  = \ (@ a_s1hFd)
      (w_s1hFe :: Integral a_s1hFd)
      (ww_s1hFj
         :: a_s1hFd
         Unf=OtherCon [])
      (ww1_s1hFk
         :: a_s1hFd
         Unf=OtherCon [])
      (ww2_s1hFo
         :: a_s1hFd
         Unf=OtherCon [])
      (ww3_s1hFp
         :: a_s1hFd
         Unf=OtherCon []) ->
      let {
        $dReal_s1fUe [Dmd=<L,1*U(1*U(A,1*C1(C1(U)),C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_s1hFd
        [LclId]
        $dReal_s1fUe = GHC.Real.$p1Integral @ a_s1hFd w_s1hFe } in
      let {
        $dNum_s1fUd [Dmd=<L,U(A,1*C1(C1(U)),C(C1(U)),A,A,A,A)>]
          :: Num a_s1hFd
        [LclId]
        $dNum_s1fUd = GHC.Real.$p1Real @ a_s1hFd $dReal_s1fUe } in
      GHC.Real.$wreduce
        @ a_s1hFd
        w_s1hFe
        (- @ a_s1hFd
           $dNum_s1fUd
           (* @ a_s1hFd $dNum_s1fUd ww_s1hFj ww3_s1hFp)
           (* @ a_s1hFd $dNum_s1fUd ww2_s1hFo ww1_s1hFk))
        (* @ a_s1hFd $dNum_s1fUd ww1_s1hFk ww3_s1hFp)

-- RHS size: {terms: 21, types: 25, coercions: 0, joins: 0/0}
GHC.Real.$fNumRatio_$c- [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a -> Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hFd)
                 (w_s1hFe [Occ=Once] :: Integral a_s1hFd)
                 (w1_s1hFf [Occ=Once!] :: Ratio a_s1hFd)
                 (w2_s1hFg [Occ=Once!] :: Ratio a_s1hFd) ->
                 case w1_s1hFf of { :% ww1_s1hFj [Occ=Once] ww2_s1hFk [Occ=Once] ->
                 case w2_s1hFg of { :% ww4_s1hFo [Occ=Once] ww5_s1hFp [Occ=Once] ->
                 case GHC.Real.$w$c-
                        @ a_s1hFd w_s1hFe ww1_s1hFj ww2_s1hFk ww4_s1hFo ww5_s1hFp
                 of
                 { (# ww7_s1hLX [Occ=Once], ww8_s1hLY [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hFd ww7_s1hLX ww8_s1hLY
                 }
                 }
                 }}]
GHC.Real.$fNumRatio_$c-
  = \ (@ a_s1hFd)
      (w_s1hFe :: Integral a_s1hFd)
      (w1_s1hFf :: Ratio a_s1hFd)
      (w2_s1hFg :: Ratio a_s1hFd) ->
      case w1_s1hFf of { :% ww1_s1hFj ww2_s1hFk ->
      case w2_s1hFg of { :% ww4_s1hFo ww5_s1hFp ->
      case GHC.Real.$w$c-
             @ a_s1hFd w_s1hFe ww1_s1hFj ww2_s1hFk ww4_s1hFo ww5_s1hFp
      of
      { (# ww7_s1hLX, ww8_s1hLY #) ->
      GHC.Real.:% @ a_s1hFd ww7_s1hLX ww8_s1hLY
      }
      }
      }

-- RHS size: {terms: 22, types: 17, coercions: 0, joins: 0/2}
GHC.Real.$w$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => a -> a -> a -> a -> (# a, a #)
[GblId,
 Arity=5,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 180 0}]
GHC.Real.$w$c*
  = \ (@ a_s1hFv)
      (w_s1hFw :: Integral a_s1hFv)
      (ww_s1hFB
         :: a_s1hFv
         Unf=OtherCon [])
      (ww1_s1hFC
         :: a_s1hFv
         Unf=OtherCon [])
      (ww2_s1hFG
         :: a_s1hFv
         Unf=OtherCon [])
      (ww3_s1hFH
         :: a_s1hFv
         Unf=OtherCon []) ->
      let {
        $dReal_s1fUa [Dmd=<L,1*U(1*U(A,A,C(C1(U)),A,A,A,A),A,A)>]
          :: Real a_s1hFv
        [LclId]
        $dReal_s1fUa = GHC.Real.$p1Integral @ a_s1hFv w_s1hFw } in
      let {
        $dNum_s1fU9 [Dmd=<L,U(A,A,C(C1(U)),A,A,A,A)>] :: Num a_s1hFv
        [LclId]
        $dNum_s1fU9 = GHC.Real.$p1Real @ a_s1hFv $dReal_s1fUa } in
      GHC.Real.$wreduce
        @ a_s1hFv
        w_s1hFw
        (* @ a_s1hFv $dNum_s1fU9 ww_s1hFB ww2_s1hFG)
        (* @ a_s1hFv $dNum_s1fU9 ww1_s1hFC ww3_s1hFH)

-- RHS size: {terms: 21, types: 25, coercions: 0, joins: 0/0}
GHC.Real.$fNumRatio_$c* [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Ratio a -> Ratio a -> Ratio a
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hFv)
                 (w_s1hFw [Occ=Once] :: Integral a_s1hFv)
                 (w1_s1hFx [Occ=Once!] :: Ratio a_s1hFv)
                 (w2_s1hFy [Occ=Once!] :: Ratio a_s1hFv) ->
                 case w1_s1hFx of { :% ww1_s1hFB [Occ=Once] ww2_s1hFC [Occ=Once] ->
                 case w2_s1hFy of { :% ww4_s1hFG [Occ=Once] ww5_s1hFH [Occ=Once] ->
                 case GHC.Real.$w$c*
                        @ a_s1hFv w_s1hFw ww1_s1hFB ww2_s1hFC ww4_s1hFG ww5_s1hFH
                 of
                 { (# ww7_s1hM0 [Occ=Once], ww8_s1hM1 [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hFv ww7_s1hM0 ww8_s1hM1
                 }
                 }
                 }}]
GHC.Real.$fNumRatio_$c*
  = \ (@ a_s1hFv)
      (w_s1hFw :: Integral a_s1hFv)
      (w1_s1hFx :: Ratio a_s1hFv)
      (w2_s1hFy :: Ratio a_s1hFv) ->
      case w1_s1hFx of { :% ww1_s1hFB ww2_s1hFC ->
      case w2_s1hFy of { :% ww4_s1hFG ww5_s1hFH ->
      case GHC.Real.$w$c*
             @ a_s1hFv w_s1hFw ww1_s1hFB ww2_s1hFC ww4_s1hFG ww5_s1hFH
      of
      { (# ww7_s1hM0, ww8_s1hM1 #) ->
      GHC.Real.:% @ a_s1hFv ww7_s1hM0 ww8_s1hM1
      }
      }
      }

-- RHS size: {terms: 17, types: 13, coercions: 0, joins: 0/0}
GHC.Real.$fNumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Integral a => Num (Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_a1dOx) (v_B1 :: Integral a_a1dOx) ->
       GHC.Num.C:Num TYPE: Ratio a_a1dOx
                     GHC.Real.$fNumRatio_$c+ @ a_a1dOx v_B1
                     GHC.Real.$fNumRatio_$c- @ a_a1dOx v_B1
                     GHC.Real.$fNumRatio_$c* @ a_a1dOx v_B1
                     GHC.Real.$fNumRatio_$cnegate @ a_a1dOx v_B1
                     GHC.Real.$fNumRatio_$cabs @ a_a1dOx v_B1
                     GHC.Real.$fNumRatio_$csignum @ a_a1dOx v_B1
                     GHC.Real.$fNumRatio_$cfromInteger @ a_a1dOx v_B1]
GHC.Real.$fNumRatio
  = \ (@ a_a1eHM) ($dIntegral_a1eHN :: Integral a_a1eHM) ->
      GHC.Num.C:Num
        @ (Ratio a_a1eHM)
        (GHC.Real.$fNumRatio_$c+ @ a_a1eHM $dIntegral_a1eHN)
        (GHC.Real.$fNumRatio_$c- @ a_a1eHM $dIntegral_a1eHN)
        (GHC.Real.$fNumRatio_$c* @ a_a1eHM $dIntegral_a1eHN)
        (GHC.Real.$fNumRatio_$cnegate @ a_a1eHM $dIntegral_a1eHN)
        (GHC.Real.$fNumRatio_$cabs @ a_a1eHM $dIntegral_a1eHN)
        (GHC.Real.$fNumRatio_$csignum @ a_a1eHM $dIntegral_a1eHN)
        (GHC.Real.$fNumRatio_$cfromInteger @ a_a1eHM $dIntegral_a1eHN)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio3 :: Ratio Integer
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Real.$fEnumRatio3
  = GHC.Real.:% @ Integer GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$s$csucc :: Ratio Integer -> Ratio Integer
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1dO9 [Occ=Once] :: Ratio Integer) ->
                 GHC.Real.$fEnumRatio_$s$c+ x_a1dO9 GHC.Real.$fEnumRatio3}]
GHC.Real.$fEnumRatio_$s$csucc
  = \ (x_a1dO9 :: Ratio Integer) ->
      case x_a1dO9 of { :% ww1_s1hzl ww2_s1hzm ->
      case GHC.Real.$w$s$c+
             ww1_s1hzl ww2_s1hzm GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
      of
      { (# ww4_s1hKW, ww5_s1hKX #) ->
      GHC.Real.:% @ Integer ww4_s1hKW ww5_s1hKX
      }
      }

-- RHS size: {terms: 22, types: 27, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$csucc
  :: forall a. Integral a => Ratio a -> Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(C(C1(U)),A,C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eE0)
                 ($dIntegral_a1eE1 :: Integral a_a1eE0)
                 (x_a1dO9 [Occ=Once] :: Ratio a_a1eE0) ->
                 GHC.Real.$fNumRatio_$c+
                   @ a_a1eE0
                   $dIntegral_a1eE1
                   x_a1dO9
                   (GHC.Real.$fNumRatio_$cfromInteger
                      @ a_a1eE0 $dIntegral_a1eE1 GHC.Real.$fEnumRatio1)}]
GHC.Real.$fEnumRatio_$csucc
  = \ (@ a_a1eE0)
      ($dIntegral_a1eE1 :: Integral a_a1eE0)
      (x_a1dO9 :: Ratio a_a1eE0) ->
      case x_a1dO9 of { :% ww1_s1hF1 ww2_s1hF2 ->
      case GHC.Real.$w$cfromInteger
             @ a_a1eE0 $dIntegral_a1eE1 GHC.Real.$fEnumRatio1
      of
      { (# ww4_s1hLq, ww5_s1hLr #) ->
      case GHC.Real.$w$c+
             @ a_a1eE0 $dIntegral_a1eE1 ww1_s1hF1 ww2_s1hF2 ww4_s1hLq ww5_s1hLr
      of
      { (# ww7_s1hLU, ww8_s1hLV #) ->
      GHC.Real.:% @ a_a1eE0 ww7_s1hLU ww8_s1hLV
      }
      }
      }

-- RHS size: {terms: 14, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$s$cpred :: Ratio Integer -> Ratio Integer
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_a1dOa [Occ=Once] :: Ratio Integer) ->
                 GHC.Real.$fEnumRatio_$s$c- x_a1dOa GHC.Real.$fEnumRatio3}]
GHC.Real.$fEnumRatio_$s$cpred
  = \ (x_a1dOa :: Ratio Integer) ->
      case x_a1dOa of { :% ww1_s1hz5 ww2_s1hz6 ->
      case GHC.Real.$w$s$c-
             ww1_s1hz5 ww2_s1hz6 GHC.Real.$fEnumRatio1 GHC.Real.$fEnumRatio1
      of
      { (# ww4_s1hKT, ww5_s1hKU #) ->
      GHC.Real.:% @ Integer ww4_s1hKT ww5_s1hKU
      }
      }

-- RHS size: {terms: 22, types: 27, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$cpred
  :: forall a. Integral a => Ratio a -> Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eE0)
                 ($dIntegral_a1eE1 :: Integral a_a1eE0)
                 (x_a1dOa [Occ=Once] :: Ratio a_a1eE0) ->
                 GHC.Real.$fNumRatio_$c-
                   @ a_a1eE0
                   $dIntegral_a1eE1
                   x_a1dOa
                   (GHC.Real.$fNumRatio_$cfromInteger
                      @ a_a1eE0 $dIntegral_a1eE1 GHC.Real.$fEnumRatio1)}]
GHC.Real.$fEnumRatio_$cpred
  = \ (@ a_a1eE0)
      ($dIntegral_a1eE1 :: Integral a_a1eE0)
      (x_a1dOa :: Ratio a_a1eE0) ->
      case x_a1dOa of { :% ww1_s1hFj ww2_s1hFk ->
      case GHC.Real.$w$cfromInteger
             @ a_a1eE0 $dIntegral_a1eE1 GHC.Real.$fEnumRatio1
      of
      { (# ww4_s1hLq, ww5_s1hLr #) ->
      case GHC.Real.$w$c-
             @ a_a1eE0 $dIntegral_a1eE1 ww1_s1hFj ww2_s1hFk ww4_s1hLq ww5_s1hLr
      of
      { (# ww7_s1hLX, ww8_s1hLY #) ->
      GHC.Real.:% @ a_a1eE0 ww7_s1hLX ww8_s1hLY
      }
      }
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
GHC.Real.$fFractionalRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Integral a => Fractional (Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_a1dOo) (v_B1 :: Integral a_a1dOo) ->
       GHC.Real.C:Fractional TYPE: Ratio a_a1dOo
                             GHC.Real.$fNumRatio @ a_a1dOo v_B1
                             GHC.Real.$fFractionalRatio_$c/ @ a_a1dOo v_B1
                             GHC.Real.$fFractionalRatio_$crecip @ a_a1dOo v_B1
                             GHC.Real.$fFractionalRatio_$cfromRational @ a_a1dOo v_B1]
GHC.Real.$fFractionalRatio
  = \ (@ a_a1eGy) ($dIntegral_a1eGz :: Integral a_a1eGy) ->
      GHC.Real.C:Fractional
        @ (Ratio a_a1eGy)
        (GHC.Real.$fNumRatio @ a_a1eGy $dIntegral_a1eGz)
        (GHC.Real.$fFractionalRatio_$c/ @ a_a1eGy $dIntegral_a1eGz)
        (GHC.Real.$fFractionalRatio_$crecip @ a_a1eGy $dIntegral_a1eGz)
        (GHC.Real.$fFractionalRatio_$cfromRational
           @ a_a1eGy $dIntegral_a1eGz)

-- RHS size: {terms: 14, types: 27, coercions: 0, joins: 0/1}
GHC.Real.$fEnumRatio_$cenumFrom
  :: forall a. Integral a => Ratio a -> [Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eE0)
                 ($dIntegral_a1eE1 [Occ=Once] :: Integral a_a1eE0) ->
                 numericEnumFrom
                   @ (Ratio a_a1eE0)
                   (GHC.Real.$fFractionalRatio @ a_a1eE0 $dIntegral_a1eE1)}]
GHC.Real.$fEnumRatio_$cenumFrom
  = \ (@ a_a1eE0) ($dIntegral_a1eE1 :: Integral a_a1eE0) ->
      let {
        w_s1hA8 [Dmd=<L,U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A,A)>]
          :: Fractional (Ratio a_a1eE0)
        [LclId]
        w_s1hA8
          = GHC.Real.$fFractionalRatio @ a_a1eE0 $dIntegral_a1eE1 } in
      \ (w1_s1hA9 :: Ratio a_a1eE0) ->
        case GHC.Real.$wnumericEnumFrom @ (Ratio a_a1eE0) w_s1hA8 w1_s1hA9
        of
        { (# ww1_s1hL8, ww2_s1hL9 #) ->
        GHC.Types.: @ (Ratio a_a1eE0) ww1_s1hL8 ww2_s1hL9
        }

-- RHS size: {terms: 16, types: 29, coercions: 0, joins: 0/1}
GHC.Real.$fEnumRatio_$cenumFromThen
  :: forall a. Integral a => Ratio a -> Ratio a -> [Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eE0)
                 ($dIntegral_a1eE1 [Occ=Once] :: Integral a_a1eE0) ->
                 numericEnumFromThen
                   @ (Ratio a_a1eE0)
                   (GHC.Real.$fFractionalRatio @ a_a1eE0 $dIntegral_a1eE1)}]
GHC.Real.$fEnumRatio_$cenumFromThen
  = \ (@ a_a1eE0) ($dIntegral_a1eE1 :: Integral a_a1eE0) ->
      let {
        w_s1hAI [Dmd=<L,U(U(C(C1(U)),C(C1(U)),A,A,A,A,A),A,A,A)>]
          :: Fractional (Ratio a_a1eE0)
        [LclId]
        w_s1hAI
          = GHC.Real.$fFractionalRatio @ a_a1eE0 $dIntegral_a1eE1 } in
      \ (w1_s1hAJ :: Ratio a_a1eE0) (w2_s1hAK :: Ratio a_a1eE0) ->
        case GHC.Real.$wnumericEnumFromThen
               @ (Ratio a_a1eE0) w_s1hAI w1_s1hAJ w2_s1hAK
        of
        { (# ww1_s1hLe, ww2_s1hLf #) ->
        GHC.Types.: @ (Ratio a_a1eE0) ww1_s1hLe ww2_s1hLf
        }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$cenumFromTo
  :: forall a. Integral a => Ratio a -> Ratio a -> [Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eE0) ($dIntegral_a1eE1 :: Integral a_a1eE0) ->
                 numericEnumFromTo
                   @ (Ratio a_a1eE0)
                   (GHC.Real.$fOrdRatio @ a_a1eE0 $dIntegral_a1eE1)
                   (GHC.Real.$fFractionalRatio @ a_a1eE0 $dIntegral_a1eE1)}]
GHC.Real.$fEnumRatio_$cenumFromTo
  = \ (@ a_a1eE0) ($dIntegral_a1eE1 :: Integral a_a1eE0) ->
      numericEnumFromTo
        @ (Ratio a_a1eE0)
        (GHC.Real.$fOrdRatio @ a_a1eE0 $dIntegral_a1eE1)
        (GHC.Real.$fFractionalRatio @ a_a1eE0 $dIntegral_a1eE1)

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$cenumFromThenTo
  :: forall a.
     Integral a =>
     Ratio a -> Ratio a -> Ratio a -> [Ratio a]
[GblId,
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eE0) ($dIntegral_a1eE1 :: Integral a_a1eE0) ->
                 numericEnumFromThenTo
                   @ (Ratio a_a1eE0)
                   (GHC.Real.$fOrdRatio @ a_a1eE0 $dIntegral_a1eE1)
                   (GHC.Real.$fFractionalRatio @ a_a1eE0 $dIntegral_a1eE1)}]
GHC.Real.$fEnumRatio_$cenumFromThenTo
  = \ (@ a_a1eE0) ($dIntegral_a1eE1 :: Integral a_a1eE0) ->
      numericEnumFromThenTo
        @ (Ratio a_a1eE0)
        (GHC.Real.$fOrdRatio @ a_a1eE0 $dIntegral_a1eE1)
        (GHC.Real.$fFractionalRatio @ a_a1eE0 $dIntegral_a1eE1)

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio_$s$fRealRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: Real (Ratio Integer)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: Ratio Integer
                       GHC.Real.$fFractionalRatio_$s$fNumRatio
                       GHC.Real.$fOrdRatio_$s$fOrdRatio
                       \ (ds_d1fgd [Occ=Once!] :: Ratio Integer) ->
                         case ds_d1fgd of { :% x_a1dOm [Occ=Once] y_a1dOn [Occ=Once] ->
                         GHC.Real.$W:% @ Integer x_a1dOm y_a1dOn
                         }]
GHC.Real.$fRealFracRatio_$s$fRealRatio
  = GHC.Real.C:Real
      @ (Ratio Integer)
      GHC.Real.$fFractionalRatio_$s$fNumRatio
      GHC.Real.$fOrdRatio_$s$fOrdRatio
      GHC.Real.$fRealRatio_$s$ctoRational

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
GHC.Real.$fRealRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Integral a => Real (Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,C(U))>m,
 Unf=DFun: \ (@ a_a1dOl) (v_B1 :: Integral a_a1dOl) ->
       GHC.Real.C:Real TYPE: Ratio a_a1dOl
                       GHC.Real.$fNumRatio @ a_a1dOl v_B1
                       GHC.Real.$fOrdRatio @ a_a1dOl v_B1
                       GHC.Real.$fRealRatio_$ctoRational @ a_a1dOl v_B1]
GHC.Real.$fRealRatio
  = \ (@ a_a1eHn) ($dIntegral_a1eHo :: Integral a_a1eHn) ->
      GHC.Real.C:Real
        @ (Ratio a_a1eHn)
        (GHC.Real.$fNumRatio @ a_a1eHn $dIntegral_a1eHo)
        (GHC.Real.$fOrdRatio @ a_a1eHn $dIntegral_a1eHo)
        (GHC.Real.$fRealRatio_$ctoRational @ a_a1eHn $dIntegral_a1eHo)

-- RHS size: {terms: 34, types: 29, coercions: 0, joins: 0/2}
GHC.Real.$w$s$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Integer -> Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(1*C1(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 260 0}]
GHC.Real.$w$s$cceiling
  = \ (@ b_s1hFX)
      (w_s1hFY :: Integral b_s1hFX)
      (ww_s1hG2
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hG3
         :: Integer
         Unf=OtherCon []) ->
      case GHC.Real.$w$s$cproperFraction
             @ b_s1hFX w_s1hFY ww_s1hG2 ww1_s1hG3
      of
      { (# ww3_s1hLz, ww4_s1hLA #) ->
      case ww4_s1hLA of { :% ww6_s1hFT ww7_s1hFU ->
      case GHC.Real.$w$s$ccompare
             ww6_s1hFT ww7_s1hFU GHC.Real.even1 GHC.Real.$fEnumRatio1
      of {
        __DEFAULT -> ww3_s1hLz;
        GT ->
          let {
            $dReal_s1fU6 [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
              :: Real b_s1hFX
            [LclId]
            $dReal_s1fU6 = GHC.Real.$p1Integral @ b_s1hFX w_s1hFY } in
          let {
            $dNum_s1fU5 [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
              :: Num b_s1hFX
            [LclId]
            $dNum_s1fU5 = GHC.Real.$p1Real @ b_s1hFX $dReal_s1fU6 } in
          + @ b_s1hFX
            $dNum_s1fU5
            ww3_s1hLz
            (fromInteger @ b_s1hFX $dNum_s1fU5 GHC.Real.$fEnumRatio1)
      }
      }
      }

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio_$s$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Ratio Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s1hFX)
                 (w_s1hFY [Occ=Once] :: Integral b_s1hFX)
                 (w1_s1hFZ [Occ=Once!] :: Ratio Integer) ->
                 case w1_s1hFZ of { :% ww1_s1hG2 [Occ=Once] ww2_s1hG3 [Occ=Once] ->
                 GHC.Real.$w$s$cceiling @ b_s1hFX w_s1hFY ww1_s1hG2 ww2_s1hG3
                 }}]
GHC.Real.$fRealFracRatio_$s$cceiling
  = \ (@ b_s1hFX)
      (w_s1hFY :: Integral b_s1hFX)
      (w1_s1hFZ :: Ratio Integer) ->
      case w1_s1hFZ of { :% ww1_s1hG2 ww2_s1hG3 ->
      GHC.Real.$w$s$cceiling @ b_s1hFX w_s1hFY ww1_s1hG2 ww2_s1hG3
      }

-- RHS size: {terms: 43, types: 43, coercions: 0, joins: 0/2}
GHC.Real.$w$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => forall b. Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(1*C1(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 30 0 0] 320 0}]
GHC.Real.$w$cceiling
  = \ (@ a_s1hGg)
      (w_s1hGh :: Integral a_s1hGg)
      (@ b_s1hGi)
      (w1_s1hGj :: Integral b_s1hGi)
      (ww_s1hGn
         :: a_s1hGg
         Unf=OtherCon [])
      (ww1_s1hGo
         :: a_s1hGg
         Unf=OtherCon []) ->
      case GHC.Real.$w$cproperFraction
             @ a_s1hGg w_s1hGh @ b_s1hGi w1_s1hGj ww_s1hGn ww1_s1hGo
      of
      { (# ww3_s1hLC, ww4_s1hLD #) ->
      case ww4_s1hLD of { :% ww6_s1hGc ww7_s1hGd ->
      case GHC.Real.$w$cfromInteger @ a_s1hGg w_s1hGh GHC.Real.even1 of
      { (# ww9_s1hLq, ww10_s1hLr #) ->
      case GHC.Real.$w$ccompare
             @ a_s1hGg w_s1hGh ww6_s1hGc ww7_s1hGd ww9_s1hLq ww10_s1hLr
      of {
        __DEFAULT -> ww3_s1hLC;
        GT ->
          let {
            $dReal_s1fU0 [Dmd=<S(S(C(C(S))LLLLLL)LL),1*U(1*U(1*C1(C1(U)),A,A,A,A,A,1*C1(U)),A,A)>]
              :: Real b_s1hGi
            [LclId]
            $dReal_s1fU0 = GHC.Real.$p1Integral @ b_s1hGi w1_s1hGj } in
          let {
            $dNum_s1fTZ [Dmd=<S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))>]
              :: Num b_s1hGi
            [LclId]
            $dNum_s1fTZ = GHC.Real.$p1Real @ b_s1hGi $dReal_s1fU0 } in
          + @ b_s1hGi
            $dNum_s1fTZ
            ww3_s1hLC
            (fromInteger @ b_s1hGi $dNum_s1fTZ GHC.Real.$fEnumRatio1)
      }
      }
      }
      }

-- RHS size: {terms: 13, types: 16, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio_$cceiling [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => forall b. Integral b => Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLLLLC(S))S(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(U(C(C1(U)),A),A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hGg)
                 (w_s1hGh [Occ=Once] :: Integral a_s1hGg)
                 (@ b_s1hGi)
                 (w1_s1hGj [Occ=Once] :: Integral b_s1hGi)
                 (w2_s1hGk [Occ=Once!] :: Ratio a_s1hGg) ->
                 case w2_s1hGk of { :% ww1_s1hGn [Occ=Once] ww2_s1hGo [Occ=Once] ->
                 GHC.Real.$w$cceiling
                   @ a_s1hGg w_s1hGh @ b_s1hGi w1_s1hGj ww1_s1hGn ww2_s1hGo
                 }}]
GHC.Real.$fRealFracRatio_$cceiling
  = \ (@ a_s1hGg)
      (w_s1hGh :: Integral a_s1hGg)
      (@ b_s1hGi)
      (w1_s1hGj :: Integral b_s1hGi)
      (w2_s1hGk :: Ratio a_s1hGg) ->
      case w2_s1hGk of { :% ww1_s1hGn ww2_s1hGo ->
      GHC.Real.$w$cceiling
        @ a_s1hGg w_s1hGh @ b_s1hGi w1_s1hGj ww1_s1hGn ww2_s1hGo
      }

-- RHS size: {terms: 36, types: 29, coercions: 0, joins: 0/2}
GHC.Real.$w$s$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Integer -> Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 300 0}]
GHC.Real.$w$s$cfloor
  = \ (@ b_s1hGr)
      (w_s1hGs :: Integral b_s1hGr)
      (ww_s1hGw
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hGx
         :: Integer
         Unf=OtherCon []) ->
      case GHC.Real.$w$s$cproperFraction
             @ b_s1hGr w_s1hGs ww_s1hGw ww1_s1hGx
      of
      { (# ww3_s1hLz, ww4_s1hLA #) ->
      case ww4_s1hLA of { :% x_a1dOV y_a1dOW ->
      case ltInteger#
             (timesInteger x_a1dOV GHC.Real.$fEnumRatio1)
             (timesInteger GHC.Real.even1 y_a1dOW)
      of {
        __DEFAULT -> ww3_s1hLz;
        1# ->
          let {
            $dReal_s1fTU [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
              :: Real b_s1hGr
            [LclId]
            $dReal_s1fTU = GHC.Real.$p1Integral @ b_s1hGr w_s1hGs } in
          let {
            $dNum_s1fTT [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
              :: Num b_s1hGr
            [LclId]
            $dNum_s1fTT = GHC.Real.$p1Real @ b_s1hGr $dReal_s1fTU } in
          - @ b_s1hGr
            $dNum_s1fTT
            ww3_s1hLz
            (fromInteger @ b_s1hGr $dNum_s1fTT GHC.Real.$fEnumRatio1)
      }
      }
      }

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio_$s$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Ratio Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s1hGr)
                 (w_s1hGs [Occ=Once] :: Integral b_s1hGr)
                 (w1_s1hGt [Occ=Once!] :: Ratio Integer) ->
                 case w1_s1hGt of { :% ww1_s1hGw [Occ=Once] ww2_s1hGx [Occ=Once] ->
                 GHC.Real.$w$s$cfloor @ b_s1hGr w_s1hGs ww1_s1hGw ww2_s1hGx
                 }}]
GHC.Real.$fRealFracRatio_$s$cfloor
  = \ (@ b_s1hGr)
      (w_s1hGs :: Integral b_s1hGr)
      (w1_s1hGt :: Ratio Integer) ->
      case w1_s1hGt of { :% ww1_s1hGw ww2_s1hGx ->
      GHC.Real.$w$s$cfloor @ b_s1hGr w_s1hGs ww1_s1hGw ww2_s1hGx
      }

-- RHS size: {terms: 43, types: 43, coercions: 0, joins: 0/2}
GHC.Real.$w$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => forall b. Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLLLLC(S))S(LLC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 30 0 0] 320 0}]
GHC.Real.$w$cfloor
  = \ (@ a_s1hGK)
      (w_s1hGL :: Integral a_s1hGK)
      (@ b_s1hGM)
      (w1_s1hGN :: Integral b_s1hGM)
      (ww_s1hGR
         :: a_s1hGK
         Unf=OtherCon [])
      (ww1_s1hGS
         :: a_s1hGK
         Unf=OtherCon []) ->
      case GHC.Real.$w$cproperFraction
             @ a_s1hGK w_s1hGL @ b_s1hGM w1_s1hGN ww_s1hGR ww1_s1hGS
      of
      { (# ww3_s1hLC, ww4_s1hLD #) ->
      case ww4_s1hLD of { :% ww6_s1hGG ww7_s1hGH ->
      case GHC.Real.$w$cfromInteger @ a_s1hGK w_s1hGL GHC.Real.even1 of
      { (# ww9_s1hLq, ww10_s1hLr #) ->
      case GHC.Real.$w$c<
             @ a_s1hGK w_s1hGL ww6_s1hGG ww7_s1hGH ww9_s1hLq ww10_s1hLr
      of {
        False -> ww3_s1hLC;
        True ->
          let {
            $dReal_s1fTO [Dmd=<S(S(LC(C(S))LLLLL)LL),1*U(1*U(A,1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
              :: Real b_s1hGM
            [LclId]
            $dReal_s1fTO = GHC.Real.$p1Integral @ b_s1hGM w1_s1hGN } in
          let {
            $dNum_s1fTN [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))>]
              :: Num b_s1hGM
            [LclId]
            $dNum_s1fTN = GHC.Real.$p1Real @ b_s1hGM $dReal_s1fTO } in
          - @ b_s1hGM
            $dNum_s1fTN
            ww3_s1hLC
            (fromInteger @ b_s1hGM $dNum_s1fTN GHC.Real.$fEnumRatio1)
      }
      }
      }
      }

-- RHS size: {terms: 13, types: 16, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio_$cfloor [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => forall b. Integral b => Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLLLLC(S))S(LLC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,C(C1(U)),A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hGK)
                 (w_s1hGL [Occ=Once] :: Integral a_s1hGK)
                 (@ b_s1hGM)
                 (w1_s1hGN [Occ=Once] :: Integral b_s1hGM)
                 (w2_s1hGO [Occ=Once!] :: Ratio a_s1hGK) ->
                 case w2_s1hGO of { :% ww1_s1hGR [Occ=Once] ww2_s1hGS [Occ=Once] ->
                 GHC.Real.$w$cfloor
                   @ a_s1hGK w_s1hGL @ b_s1hGM w1_s1hGN ww1_s1hGR ww2_s1hGS
                 }}]
GHC.Real.$fRealFracRatio_$cfloor
  = \ (@ a_s1hGK)
      (w_s1hGL :: Integral a_s1hGK)
      (@ b_s1hGM)
      (w1_s1hGN :: Integral b_s1hGM)
      (w2_s1hGO :: Ratio a_s1hGK) ->
      case w2_s1hGO of { :% ww1_s1hGR ww2_s1hGS ->
      GHC.Real.$w$cfloor
        @ a_s1hGK w_s1hGL @ b_s1hGM w1_s1hGN ww1_s1hGR ww2_s1hGS
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio2 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
GHC.Real.$fRealFracRatio2 = -1

-- RHS size: {terms: 86, types: 47, coercions: 0, joins: 1/3}
GHC.Real.$w$s$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Integer -> Integer -> b
[GblId,
 Arity=3,
 Str=<L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 694 0}]
GHC.Real.$w$s$cround
  = \ (@ b_s1hH5)
      (w_s1hH6 :: Integral b_s1hH5)
      (ww_s1hHa
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hHb
         :: Integer
         Unf=OtherCon []) ->
      case GHC.Real.$w$s$cproperFraction
             @ b_s1hH5 w_s1hH6 ww_s1hHa ww1_s1hHb
      of
      { (# ww3_s1hLz, ww4_s1hLA #) ->
      case ww4_s1hLA of { :% ww6_s1hH1 ww7_s1hH2 ->
      case absInteger ww6_s1hH1 of dt_X1e7O { __DEFAULT ->
      case GHC.Real.$w$s$c-
             dt_X1e7O ww7_s1hH2 GHC.Real.$fEnumRatio1 GHC.Real.even2
      of
      { (# ww9_s1hKT, ww10_s1hKU #) ->
      case signumInteger ww9_s1hKT of dt1_X1e7H { __DEFAULT ->
      case eqInteger# dt1_X1e7H GHC.Real.$fRealFracRatio2 of {
        __DEFAULT ->
          join {
            m_s1fTC [Dmd=<L,1*U>] :: b_s1hH5
            [LclId[JoinId(0)]]
            m_s1fTC
              = let {
                  $dReal_s1fTI [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                    :: Real b_s1hH5
                  [LclId]
                  $dReal_s1fTI = GHC.Real.$p1Integral @ b_s1hH5 w_s1hH6 } in
                let {
                  $dNum_s1fTH [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                    :: Num b_s1hH5
                  [LclId]
                  $dNum_s1fTH = GHC.Real.$p1Real @ b_s1hH5 $dReal_s1fTI } in
                case ltInteger#
                       (timesInteger ww6_s1hH1 GHC.Real.$fEnumRatio1)
                       (timesInteger GHC.Real.even1 ww7_s1hH2)
                of {
                  __DEFAULT ->
                    + @ b_s1hH5
                      $dNum_s1fTH
                      ww3_s1hLz
                      (fromInteger @ b_s1hH5 $dNum_s1fTH GHC.Real.$fEnumRatio1);
                  1# ->
                    - @ b_s1hH5
                      $dNum_s1fTH
                      ww3_s1hLz
                      (fromInteger @ b_s1hH5 $dNum_s1fTH GHC.Real.$fEnumRatio1)
                } } in
          case eqInteger# dt1_X1e7H GHC.Real.even1 of {
            __DEFAULT ->
              case eqInteger# dt1_X1e7H GHC.Real.$fEnumRatio1 of {
                __DEFAULT -> GHC.Real.$fRealFracRatio1 @ b_s1hH5;
                1# -> jump m_s1fTC
              };
            1# ->
              case even @ b_s1hH5 w_s1hH6 ww3_s1hLz of {
                False -> jump m_s1fTC;
                True -> ww3_s1hLz
              }
          };
        1# -> ww3_s1hLz
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio_$s$cround [InlPrag=NOUSERINLINE[0]]
  :: forall b. Integral b => Ratio Integer -> b
[GblId,
 Arity=2,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s1hH5)
                 (w_s1hH6 [Occ=Once] :: Integral b_s1hH5)
                 (w1_s1hH7 [Occ=Once!] :: Ratio Integer) ->
                 case w1_s1hH7 of { :% ww1_s1hHa [Occ=Once] ww2_s1hHb [Occ=Once] ->
                 GHC.Real.$w$s$cround @ b_s1hH5 w_s1hH6 ww1_s1hHa ww2_s1hHb
                 }}]
GHC.Real.$fRealFracRatio_$s$cround
  = \ (@ b_s1hH5)
      (w_s1hH6 :: Integral b_s1hH5)
      (w1_s1hH7 :: Ratio Integer) ->
      case w1_s1hH7 of { :% ww1_s1hHa ww2_s1hHb ->
      GHC.Real.$w$s$cround @ b_s1hH5 w_s1hH6 ww1_s1hHa ww2_s1hHb
      }

-- RHS size: {terms: 156, types: 113, coercions: 0, joins: 3/8}
GHC.Real.$w$cround [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => forall b. Integral b => a -> a -> b
[GblId,
 Arity=4,
 Str=<S(S(S(LLLC(S)C(S)C(S)C(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),1*C1(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []]
GHC.Real.$w$cround
  = \ (@ a_s1hHo)
      (w_s1hHp :: Integral a_s1hHo)
      (@ b_s1hHq)
      (w1_s1hHr :: Integral b_s1hHq)
      (ww_s1hHv
         :: a_s1hHo
         Unf=OtherCon [])
      (ww1_s1hHw
         :: a_s1hHo
         Unf=OtherCon []) ->
      case GHC.Real.$w$cproperFraction
             @ a_s1hHo w_s1hHp @ b_s1hHq w1_s1hHr ww_s1hHv ww1_s1hHw
      of
      { (# ww3_s1hLC, ww4_s1hLD #) ->
      case ww4_s1hLD of { :% ww6_s1hHk ww7_s1hHl ->
      case abs
             @ a_s1hHo
             (GHC.Real.$p1Real
                @ a_s1hHo (GHC.Real.$p1Integral @ a_s1hHo w_s1hHp))
             ww6_s1hHk
      of dt_X1e5R
      { __DEFAULT ->
      case GHC.Real.$w$cfromRational
             @ a_s1hHo w_s1hHp GHC.Real.$fEnumRatio1 GHC.Real.even2
      of
      { (# ww9_s1hLR, ww10_s1hLS #) ->
      case GHC.Real.$w$c-
             @ a_s1hHo w_s1hHp dt_X1e5R ww7_s1hHl ww9_s1hLR ww10_s1hLS
      of
      { (# ww12_s1hLX, ww13_s1hLY #) ->
      case GHC.Real.$w$csignum @ a_s1hHo w_s1hHp ww12_s1hLX of
      { (# ww15_s1hLn, ww16_s1hLo #) ->
      case GHC.Real.$w$cfromInteger
             @ a_s1hHo w_s1hHp GHC.Real.$fEnumRatio1
      of
      { (# ww18_s1hLq, ww19_s1hLr #) ->
      case negate
             @ a_s1hHo
             (GHC.Real.$p1Real
                @ a_s1hHo (GHC.Real.$p1Integral @ a_s1hHo w_s1hHp))
             ww18_s1hLq
      of dt1_X1e5P
      { __DEFAULT ->
      let {
        $dEq_s1fTu [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),1*U(A,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real a_s1hHo
        [LclId]
        $dEq_s1fTu = GHC.Real.$p1Integral @ a_s1hHo w_s1hHp } in
      let {
        $dEq1_s1fTt [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
          :: Ord a_s1hHo
        [LclId]
        $dEq1_s1fTt = GHC.Real.$p2Real @ a_s1hHo $dEq_s1fTu } in
      let {
        $dEq2_s1fTs [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_s1hHo
        [LclId]
        $dEq2_s1fTs = GHC.Classes.$p1Ord @ a_s1hHo $dEq1_s1fTt } in
      join {
        $j_s1g9j [Dmd=<L,1*U>] :: b_s1hHq
        [LclId[JoinId(0)]]
        $j_s1g9j
          = case GHC.Real.$w$cfromInteger @ a_s1hHo w_s1hHp GHC.Real.even1 of
            { (# ww21_X1i1l, ww22_X1i1n #) ->
            join {
              m_s1fTl [Dmd=<L,1*U>] :: b_s1hHq
              [LclId[JoinId(0)]]
              m_s1fTl
                = let {
                    $dReal_s1fTr [Dmd=<S(SLL),1*U(1*U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U)),A,A)>]
                      :: Real b_s1hHq
                    [LclId]
                    $dReal_s1fTr = GHC.Real.$p1Integral @ b_s1hHq w1_s1hHr } in
                  let {
                    $dNum_s1fTq [Dmd=<S,U(1*C1(C1(U)),1*C1(C1(U)),A,A,A,A,1*C1(U))>]
                      :: Num b_s1hHq
                    [LclId]
                    $dNum_s1fTq = GHC.Real.$p1Real @ b_s1hHq $dReal_s1fTr } in
                  case GHC.Real.$w$c<
                         @ a_s1hHo w_s1hHp ww6_s1hHk ww7_s1hHl ww21_X1i1l ww22_X1i1n
                  of {
                    False ->
                      + @ b_s1hHq
                        $dNum_s1fTq
                        ww3_s1hLC
                        (fromInteger @ b_s1hHq $dNum_s1fTq GHC.Real.$fEnumRatio1);
                    True ->
                      - @ b_s1hHq
                        $dNum_s1fTq
                        ww3_s1hLC
                        (fromInteger @ b_s1hHq $dNum_s1fTq GHC.Real.$fEnumRatio1)
                  } } in
            join {
              $j1_s1g9f [Dmd=<L,1*U>] :: b_s1hHq
              [LclId[JoinId(0)]]
              $j1_s1g9f
                = case == @ a_s1hHo $dEq2_s1fTs ww15_s1hLn ww18_s1hLq of {
                    False -> GHC.Real.$fRealFracRatio1 @ b_s1hHq;
                    True ->
                      case == @ a_s1hHo $dEq2_s1fTs ww16_s1hLo ww19_s1hLr of {
                        False -> GHC.Real.$fRealFracRatio1 @ b_s1hHq;
                        True -> jump m_s1fTl
                      }
                  } } in
            case == @ a_s1hHo $dEq2_s1fTs ww15_s1hLn ww21_X1i1l of {
              False -> jump $j1_s1g9f;
              True ->
                case == @ a_s1hHo $dEq2_s1fTs ww16_s1hLo ww22_X1i1n of {
                  False -> jump $j1_s1g9f;
                  True ->
                    case even @ b_s1hHq w1_s1hHr ww3_s1hLC of {
                      False -> jump m_s1fTl;
                      True -> ww3_s1hLC
                    }
                }
            }
            } } in
      case == @ a_s1hHo $dEq2_s1fTs ww15_s1hLn dt1_X1e5P of {
        False -> jump $j_s1g9j;
        True ->
          case == @ a_s1hHo $dEq2_s1fTs ww16_s1hLo ww19_s1hLr of {
            False -> jump $j_s1g9j;
            True -> ww3_s1hLC
          }
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 13, types: 16, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio_$cround [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => forall b. Integral b => Ratio a -> b
[GblId,
 Arity=3,
 Str=<S(S(S(LLLC(S)C(S)C(S)C(S))S(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hHo)
                 (w_s1hHp [Occ=Once] :: Integral a_s1hHo)
                 (@ b_s1hHq)
                 (w1_s1hHr [Occ=Once] :: Integral b_s1hHq)
                 (w2_s1hHs [Occ=Once!] :: Ratio a_s1hHo) ->
                 case w2_s1hHs of { :% ww1_s1hHv [Occ=Once] ww2_s1hHw [Occ=Once] ->
                 GHC.Real.$w$cround
                   @ a_s1hHo w_s1hHp @ b_s1hHq w1_s1hHr ww1_s1hHv ww2_s1hHw
                 }}]
GHC.Real.$fRealFracRatio_$cround
  = \ (@ a_s1hHo)
      (w_s1hHp :: Integral a_s1hHo)
      (@ b_s1hHq)
      (w1_s1hHr :: Integral b_s1hHq)
      (w2_s1hHs :: Ratio a_s1hHo) ->
      case w2_s1hHs of { :% ww1_s1hHv ww2_s1hHw ->
      GHC.Real.$w$cround
        @ a_s1hHo w_s1hHp @ b_s1hHq w1_s1hHr ww1_s1hHv ww2_s1hHw
      }

-- RHS size: {terms: 24, types: 24, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio_$s$ctruncate [InlPrag=INLINE (sat-args=1)]
  :: forall b. Integral b => Ratio Integer -> b
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_a1eFV)
                 ($dIntegral_a1eFX [Occ=Once] :: Integral b_a1eFV)
                 (x_a1dNy [Occ=Once!] :: Ratio Integer) ->
                 case x_a1dNy of { :% x1_a1dOh [Occ=Once] y_a1dOi ->
                 fromInteger
                   @ b_a1eFV
                   (GHC.Real.$p1Real
                      @ b_a1eFV (GHC.Real.$p1Integral @ b_a1eFV $dIntegral_a1eFX))
                   (case eqInteger# y_a1dOi 0 of {
                      __DEFAULT ->
                        case quotRemInteger x1_a1dOh y_a1dOi of
                        { (# ipv_s1fpa [Occ=Once], _ [Occ=Dead] #) ->
                        ipv_s1fpa
                        };
                      1# -> case divZeroError of { }
                    })
                 }}]
GHC.Real.$fRealFracRatio_$s$ctruncate
  = \ (@ b_a1eFV)
      ($dIntegral_a1eFX :: Integral b_a1eFV)
      (x_a1dNy :: Ratio Integer) ->
      case x_a1dNy of { :% x1_a1dOh y_a1dOi ->
      fromInteger
        @ b_a1eFV
        (GHC.Real.$p1Real
           @ b_a1eFV (GHC.Real.$p1Integral @ b_a1eFV $dIntegral_a1eFX))
        (case eqInteger# y_a1dOi GHC.Real.even1 of {
           __DEFAULT ->
             case quotRemInteger x1_a1dOh y_a1dOi of
             { (# ipv_s1fpa, ipv1_s1fpb #) ->
             ipv_s1fpa
             };
           1# -> case divZeroError of wild2_00 { }
         })
      }

-- RHS size: {terms: 16, types: 25, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio_$ctruncate [InlPrag=INLINE (sat-args=1)]
  :: forall a. Integral a => forall b. Integral b => Ratio a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a1eFc)
                 ($dIntegral_a1eFd [Occ=Once] :: Integral a_a1eFc)
                 (@ b_a1eFV)
                 ($dIntegral1_a1eFX [Occ=Once] :: Integral b_a1eFV)
                 (x_a1dNy [Occ=Once] :: Ratio a_a1eFc) ->
                 case GHC.Real.$fEnumRatio_$cproperFraction
                        @ a_a1eFc $dIntegral_a1eFd @ b_a1eFV $dIntegral1_a1eFX x_a1dNy
                 of
                 { (m_a1eBi [Occ=Once], _ [Occ=Dead]) ->
                 m_a1eBi
                 }}]
GHC.Real.$fRealFracRatio_$ctruncate
  = \ (@ a_a1eFc)
      ($dIntegral_a1eFd :: Integral a_a1eFc)
      (@ b_a1eFV)
      ($dIntegral1_a1eFX :: Integral b_a1eFV)
      (x_a1dNy :: Ratio a_a1eFc) ->
      case x_a1dNy of { :% ww1_s1hDY ww2_s1hDZ ->
      case GHC.Real.$w$cproperFraction
             @ a_a1eFc
             $dIntegral_a1eFd
             @ b_a1eFV
             $dIntegral1_a1eFX
             ww1_s1hDY
             ww2_s1hDZ
      of
      { (# ww4_s1hLC, ww5_s1hLD #) ->
      ww4_s1hLC
      }
      }

-- RHS size: {terms: 8, types: 2, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio_$s$fRealFracRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: RealFrac (Ratio Integer)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:RealFrac TYPE: Ratio Integer
                           GHC.Real.$fRealFracRatio_$s$fRealRatio
                           GHC.Real.$fFractionalRatio_$s$fFractionalRatio
                           GHC.Real.$fEnumRatio_$s$cproperFraction
                           GHC.Real.$fRealFracRatio_$s$ctruncate
                           GHC.Real.$fRealFracRatio_$s$cround
                           GHC.Real.$fRealFracRatio_$s$cceiling
                           GHC.Real.$fRealFracRatio_$s$cfloor]
GHC.Real.$fRealFracRatio_$s$fRealFracRatio
  = GHC.Real.C:RealFrac
      @ (Ratio Integer)
      GHC.Real.$fRealFracRatio_$s$fRealRatio
      GHC.Real.$fFractionalRatio_$s$fFractionalRatio
      GHC.Real.$fEnumRatio_$s$cproperFraction
      GHC.Real.$fRealFracRatio_$s$ctruncate
      GHC.Real.$fRealFracRatio_$s$cround
      GHC.Real.$fRealFracRatio_$s$cceiling
      GHC.Real.$fRealFracRatio_$s$cfloor

-- RHS size: {terms: 17, types: 13, coercions: 0, joins: 0/0}
GHC.Real.$fRealFracRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Integral a => RealFrac (Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,1*U))),A,C(U))>m,
 Unf=DFun: \ (@ a_a1dOg) (v_B1 :: Integral a_a1dOg) ->
       GHC.Real.C:RealFrac TYPE: Ratio a_a1dOg
                           GHC.Real.$fRealRatio @ a_a1dOg v_B1
                           GHC.Real.$fFractionalRatio @ a_a1dOg v_B1
                           GHC.Real.$fEnumRatio_$cproperFraction @ a_a1dOg v_B1
                           GHC.Real.$fRealFracRatio_$ctruncate @ a_a1dOg v_B1
                           GHC.Real.$fRealFracRatio_$cround @ a_a1dOg v_B1
                           GHC.Real.$fRealFracRatio_$cceiling @ a_a1dOg v_B1
                           GHC.Real.$fRealFracRatio_$cfloor @ a_a1dOg v_B1]
GHC.Real.$fRealFracRatio
  = \ (@ a_a1eFc) ($dIntegral_a1eFd :: Integral a_a1eFc) ->
      GHC.Real.C:RealFrac
        @ (Ratio a_a1eFc)
        (GHC.Real.$fRealRatio @ a_a1eFc $dIntegral_a1eFd)
        (GHC.Real.$fFractionalRatio @ a_a1eFc $dIntegral_a1eFd)
        (GHC.Real.$fEnumRatio_$cproperFraction @ a_a1eFc $dIntegral_a1eFd)
        (GHC.Real.$fRealFracRatio_$ctruncate @ a_a1eFc $dIntegral_a1eFd)
        (GHC.Real.$fRealFracRatio_$cround @ a_a1eFc $dIntegral_a1eFd)
        (GHC.Real.$fRealFracRatio_$cceiling @ a_a1eFc $dIntegral_a1eFd)
        (GHC.Real.$fRealFracRatio_$cfloor @ a_a1eFc $dIntegral_a1eFd)

Rec {
-- RHS size: {terms: 38, types: 5, coercions: 0, joins: 0/0}
g_r1j3N :: Integer -> Integer -> Integer -> Integer
[GblId, Arity=3, Str=<S,U><S,U><S,1*U>, Unf=OtherCon []]
g_r1j3N
  = \ (x_a1dQL :: Integer)
      (y_a1dQM :: Integer)
      (z_a1dQN :: Integer) ->
      case eqInteger# (remInteger y_a1dQM GHC.Real.even2) GHC.Real.even1
      of {
        __DEFAULT ->
          case eqInteger# y_a1dQM GHC.Real.$fEnumRatio1 of {
            __DEFAULT ->
              g_r1j3N
                (timesInteger x_a1dQL x_a1dQL)
                (quotInteger y_a1dQM GHC.Real.even2)
                (timesInteger x_a1dQL z_a1dQN);
            1# -> timesInteger x_a1dQL z_a1dQN
          };
        1# ->
          g_r1j3N
            (timesInteger x_a1dQL x_a1dQL)
            (quotInteger y_a1dQM GHC.Real.even2)
            z_a1dQN
      }
end Rec }

Rec {
-- RHS size: {terms: 32, types: 4, coercions: 0, joins: 0/0}
GHC.Real.^_f [Occ=LoopBreaker] :: Integer -> Integer -> Integer
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []]
GHC.Real.^_f
  = \ (x_a1dQJ :: Integer) (y_a1dQK :: Integer) ->
      case eqInteger# (remInteger y_a1dQK GHC.Real.even2) GHC.Real.even1
      of {
        __DEFAULT ->
          case eqInteger# y_a1dQK GHC.Real.$fEnumRatio1 of {
            __DEFAULT ->
              g_r1j3N
                (timesInteger x_a1dQJ x_a1dQJ)
                (quotInteger y_a1dQK GHC.Real.even2)
                x_a1dQJ;
            1# -> x_a1dQJ
          };
        1# ->
          GHC.Real.^_f
            (timesInteger x_a1dQJ x_a1dQJ) (quotInteger y_a1dQK GHC.Real.even2)
      }
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl5_r1j3O :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl5_r1j3O = "Negative exponent"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Real.^1 :: Integer
[GblId, Str=x]
GHC.Real.^1
  = errorWithoutStackTrace
      @ 'LiftedRep @ Integer (unpackCString# lvl5_r1j3O)

-- RHS size: {terms: 19, types: 4, coercions: 0, joins: 0/0}
GHC.Real.^_$s^ [InlPrag=NOUSERINLINE[1]]
  :: Integer -> Integer -> Integer
[GblId,
 Arity=2,
 Str=<L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 130 0}]
GHC.Real.^_$s^
  = \ (x0_a1dQF :: Integer) (y0_a1dQG :: Integer) ->
      case ltInteger# y0_a1dQG GHC.Real.even1 of {
        __DEFAULT ->
          case eqInteger# y0_a1dQG GHC.Real.even1 of {
            __DEFAULT -> GHC.Real.^_f x0_a1dQF y0_a1dQG;
            1# -> GHC.Real.$fEnumRatio1
          };
        1# -> GHC.Real.^1
      }

-- RHS size: {terms: 17, types: 13, coercions: 0, joins: 0/0}
GHC.Real.$w$s$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Integer -> Int#
[GblId,
 Arity=2,
 Str=<S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 110 0}]
GHC.Real.$w$s$cfromEnum
  = \ (ww_s1hHJ
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hHK
         :: Integer
         Unf=OtherCon []) ->
      case eqInteger# ww1_s1hHK GHC.Real.even1 of {
        __DEFAULT ->
          case quotRemInteger ww_s1hHJ ww1_s1hHK of
          { (# ipv_s1fpa, ipv1_s1fpb #) ->
          integerToInt ipv_s1fpa
          };
        1# -> case divZeroError of wild1_00 { }
      }

-- RHS size: {terms: 11, types: 7, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$s$cfromEnum [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> Int
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hHG [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hHG of { :% ww1_s1hHJ [Occ=Once] ww2_s1hHK [Occ=Once] ->
                 case GHC.Real.$w$s$cfromEnum ww1_s1hHJ ww2_s1hHK of ww3_s1hHO
                 { __DEFAULT ->
                 GHC.Types.I# ww3_s1hHO
                 }
                 }}]
GHC.Real.$fEnumRatio_$s$cfromEnum
  = \ (w_s1hHG :: Ratio Integer) ->
      case w_s1hHG of { :% ww1_s1hHJ ww2_s1hHK ->
      case GHC.Real.$w$s$cfromEnum ww1_s1hHJ ww2_s1hHK of ww3_s1hHO
      { __DEFAULT ->
      GHC.Types.I# ww3_s1hHO
      }
      }

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$cfromEnum
  :: forall a. Integral a => Ratio a -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)),U(A,A,A,A,A,A,1*C1(C1(U(1*U,A))),A,1*C1(U))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1eE0)
                 ($dIntegral_a1eE1 [Occ=Once] :: Integral a_a1eE0)
                 (x_X1fc0 [Occ=Once] :: Ratio a_a1eE0) ->
                 case GHC.Real.$fEnumRatio_$cproperFraction
                        @ a_a1eE0
                        $dIntegral_a1eE1
                        @ Integer
                        GHC.Real.$fIntegralInteger
                        x_X1fc0
                 of
                 { (m_a1eBi [Occ=Once], _ [Occ=Dead]) ->
                 case integerToInt m_a1eBi of wild1_i1fxy { __DEFAULT ->
                 GHC.Types.I# wild1_i1fxy
                 }
                 }}]
GHC.Real.$fEnumRatio_$cfromEnum
  = \ (@ a_a1eE0)
      ($dIntegral_a1eE1 :: Integral a_a1eE0)
      (x_X1fc0 :: Ratio a_a1eE0) ->
      case x_X1fc0 of { :% ww1_s1hDY ww2_s1hDZ ->
      case integerToInt
             (toInteger
                @ a_a1eE0
                $dIntegral_a1eE1
                (case quotRem @ a_a1eE0 $dIntegral_a1eE1 ww1_s1hDY ww2_s1hDZ of
                 { (q_a1eFC, r_a1eFE) ->
                 q_a1eFC
                 }))
      of wild_i1fxy
      { __DEFAULT ->
      GHC.Types.I# wild_i1fxy
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
ratioPrec1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
ratioPrec1 = GHC.Types.I# 8#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Real.$fShowRatio2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Real.$fShowRatio2 = " % "#

-- RHS size: {terms: 47, types: 41, coercions: 0, joins: 0/0}
GHC.Real.$w$s$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int# -> Integer -> Integer -> String -> (# Char, [Char] #)
[GblId,
 Arity=4,
 Str=<S,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 311 30}]
GHC.Real.$w$s$cshowsPrec
  = \ (ww_s1hHV :: Int#)
      (ww1_s1hHZ
         :: Integer
         Unf=OtherCon [])
      (ww2_s1hI0
         :: Integer
         Unf=OtherCon [])
      (w_s1hHS :: String) ->
      case ># ww_s1hHV 7# of {
        __DEFAULT ->
          GHC.Show.$w$cshowsPrec4
            8#
            ww1_s1hHZ
            (unpackAppendCString#
               GHC.Real.$fShowRatio2
               (case GHC.Show.$w$cshowsPrec4 8# ww2_s1hI0 w_s1hHS of
                { (# ww4_i1fym, ww5_i1fyn #) ->
                GHC.Types.: @ Char ww4_i1fym ww5_i1fyn
                }));
        1# ->
          (# GHC.Show.$fShow(,)4,
             case GHC.Show.$w$cshowsPrec4
                    8#
                    ww1_s1hHZ
                    (unpackAppendCString#
                       GHC.Real.$fShowRatio2
                       (case GHC.Show.$w$cshowsPrec4
                               8# ww2_s1hI0 (GHC.Types.: @ Char GHC.Show.$fShow(,)2 w_s1hHS)
                        of
                        { (# ww4_i1fym, ww5_i1fyn #) ->
                        GHC.Types.: @ Char ww4_i1fym ww5_i1fyn
                        }))
             of
             { (# ww4_i1fym, ww5_i1fyn #) ->
             GHC.Types.: @ Char ww4_i1fym ww5_i1fyn
             } #)
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
GHC.Real.$fShowRatio_$s$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int -> Ratio Integer -> ShowS
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S(SS),1*U(U,U)><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hHQ [Occ=Once!] :: Int)
                 (w1_s1hHR [Occ=Once!] :: Ratio Integer)
                 (w2_s1hHS [Occ=Once] :: String) ->
                 case w_s1hHQ of { I# ww1_s1hHV [Occ=Once] ->
                 case w1_s1hHR of { :% ww3_s1hHZ [Occ=Once] ww4_s1hI0 [Occ=Once] ->
                 case GHC.Real.$w$s$cshowsPrec
                        ww1_s1hHV ww3_s1hHZ ww4_s1hI0 w2_s1hHS
                 of
                 { (# ww6_s1hM3 [Occ=Once], ww7_s1hM4 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww6_s1hM3 ww7_s1hM4
                 }
                 }
                 }}]
GHC.Real.$fShowRatio_$s$cshowsPrec
  = \ (w_s1hHQ :: Int)
      (w1_s1hHR :: Ratio Integer)
      (w2_s1hHS :: String) ->
      case w_s1hHQ of { I# ww1_s1hHV ->
      case w1_s1hHR of { :% ww3_s1hHZ ww4_s1hI0 ->
      case GHC.Real.$w$s$cshowsPrec
             ww1_s1hHV ww3_s1hHZ ww4_s1hI0 w2_s1hHS
      of
      { (# ww6_s1hM3, ww7_s1hM4 #) ->
      GHC.Types.: @ Char ww6_s1hM3 ww7_s1hM4
      }
      }
      }

-- RHS size: {terms: 37, types: 18, coercions: 0, joins: 0/2}
GHC.Real.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int# -> a -> a -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 0] 301 120}]
GHC.Real.$w$cshowsPrec
  = \ (@ a_s1hI6)
      (w_s1hI7 :: Show a_s1hI6)
      (ww_s1hIc :: Int#)
      (ww1_s1hIg
         :: a_s1hI6
         Unf=OtherCon [])
      (ww2_s1hIh
         :: a_s1hI6
         Unf=OtherCon []) ->
      let {
        f_s1fSY [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_s1fSY = showsPrec @ a_s1hI6 w_s1hI7 ratioPrec1 ww1_s1hIg } in
      let {
        g1_s1fSW [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        g1_s1fSW = showsPrec @ a_s1hI6 w_s1hI7 ratioPrec1 ww2_s1hIh } in
      case ># ww_s1hIc 7# of {
        __DEFAULT ->
          \ (x_X1fcp :: String) ->
            f_s1fSY
              (unpackAppendCString# GHC.Real.$fShowRatio2 (g1_s1fSW x_X1fcp));
        1# ->
          \ (x_i1f5A :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (f_s1fSY
                 (unpackAppendCString#
                    GHC.Real.$fShowRatio2
                    (g1_s1fSW (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i1f5A))))
      }

-- RHS size: {terms: 15, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fShowRatio_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int -> Ratio a -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hI6)
                 (w_s1hI7 [Occ=Once] :: Show a_s1hI6)
                 (w1_s1hI8 [Occ=Once!] :: Int)
                 (w2_s1hI9 [Occ=Once!] :: Ratio a_s1hI6) ->
                 case w1_s1hI8 of { I# ww1_s1hIc [Occ=Once] ->
                 case w2_s1hI9 of { :% ww3_s1hIg [Occ=Once] ww4_s1hIh [Occ=Once] ->
                 GHC.Real.$w$cshowsPrec
                   @ a_s1hI6 w_s1hI7 ww1_s1hIc ww3_s1hIg ww4_s1hIh
                 }
                 }}]
GHC.Real.$fShowRatio_$cshowsPrec
  = \ (@ a_s1hI6)
      (w_s1hI7 :: Show a_s1hI6)
      (w1_s1hI8 :: Int)
      (w2_s1hI9 :: Ratio a_s1hI6) ->
      case w1_s1hI8 of { I# ww1_s1hIc ->
      case w2_s1hI9 of { :% ww3_s1hIg ww4_s1hIh ->
      GHC.Real.$w$cshowsPrec
        @ a_s1hI6 w_s1hI7 ww1_s1hIc ww3_s1hIg ww4_s1hIh
      }
      }

-- RHS size: {terms: 15, types: 17, coercions: 0, joins: 0/0}
GHC.Real.$fShowRatio1 :: Ratio Integer -> ShowS
[GblId,
 Arity=2,
 Str=<S(SS),1*U(U,U)><L,U>m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 0] 80 30}]
GHC.Real.$fShowRatio1
  = \ (w_s1hHR :: Ratio Integer) (w1_s1hHS :: String) ->
      case w_s1hHR of { :% ww1_s1hHZ ww2_s1hI0 ->
      case GHC.Real.$w$s$cshowsPrec 0# ww1_s1hHZ ww2_s1hI0 w1_s1hHS of
      { (# ww4_s1hM3, ww5_s1hM4 #) ->
      GHC.Types.: @ Char ww4_s1hM3 ww5_s1hM4
      }
      }

-- RHS size: {terms: 6, types: 6, coercions: 0, joins: 0/0}
GHC.Real.$fShowRatio_$s$cshowList :: [Ratio Integer] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i1fnt [Occ=Once] :: [Ratio Integer])
                 (s_i1fnu [Occ=Once] :: String) ->
                 showList__
                   @ (Ratio Integer) GHC.Real.$fShowRatio1 ls_i1fnt s_i1fnu}]
GHC.Real.$fShowRatio_$s$cshowList
  = \ (ls_i1fnt :: [Ratio Integer]) (s_i1fnu :: String) ->
      showList__ @ (Ratio Integer) GHC.Real.$fShowRatio1 ls_i1fnt s_i1fnu

-- RHS size: {terms: 16, types: 17, coercions: 0, joins: 0/0}
GHC.Real.$fShowRatio_$cshowList
  :: forall a. Show a => [Ratio a] -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a1ePl)
                 ($dShow_a1ePm [Occ=Once] :: Show a_a1ePl)
                 (ls_i1fnt [Occ=Once] :: [Ratio a_a1ePl])
                 (s_i1fnu [Occ=Once] :: String) ->
                 showList__
                   @ (Ratio a_a1ePl)
                   (GHC.Real.$fShowRatio_$cshowsPrec
                      @ a_a1ePl $dShow_a1ePm GHC.Real.$fIntegralInt1)
                   ls_i1fnt
                   s_i1fnu}]
GHC.Real.$fShowRatio_$cshowList
  = \ (@ a_a1ePl)
      ($dShow_a1ePm :: Show a_a1ePl)
      (ls_i1fnt :: [Ratio a_a1ePl])
      (s_i1fnu :: String) ->
      showList__
        @ (Ratio a_a1ePl)
        (\ (w_s1hI9 :: Ratio a_a1ePl) ->
           case w_s1hI9 of { :% ww1_s1hIg ww2_s1hIh ->
           GHC.Real.$w$cshowsPrec
             @ a_a1ePl $dShow_a1ePm 0# ww1_s1hIg ww2_s1hIh
           })
        ls_i1fnt
        s_i1fnu

-- RHS size: {terms: 16, types: 13, coercions: 0, joins: 0/0}
GHC.Real.$w$s$cshow [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Integer -> (# Char, [Char] #)
[GblId,
 Arity=2,
 Str=<S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 130 0}]
GHC.Real.$w$s$cshow
  = \ (ww_s1hIn
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hIo
         :: Integer
         Unf=OtherCon []) ->
      GHC.Show.$w$cshowsPrec4
        8#
        ww_s1hIn
        (unpackAppendCString#
           GHC.Real.$fShowRatio2
           (case GHC.Show.$w$cshowsPrec4 8# ww1_s1hIo (GHC.Types.[] @ Char) of
            { (# ww3_i1fym, ww4_i1fyn #) ->
            GHC.Types.: @ Char ww3_i1fym ww4_i1fyn
            }))

-- RHS size: {terms: 12, types: 16, coercions: 0, joins: 0/0}
GHC.Real.$fShowRatio_$s$cshow [InlPrag=NOUSERINLINE[0]]
  :: Ratio Integer -> String
[GblId,
 Arity=1,
 Str=<S(SS),1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hIk [Occ=Once!] :: Ratio Integer) ->
                 case w_s1hIk of { :% ww1_s1hIn [Occ=Once] ww2_s1hIo [Occ=Once] ->
                 case GHC.Real.$w$s$cshow ww1_s1hIn ww2_s1hIo of
                 { (# ww4_s1hM6 [Occ=Once], ww5_s1hM7 [Occ=Once] #) ->
                 GHC.Types.: @ Char ww4_s1hM6 ww5_s1hM7
                 }
                 }}]
GHC.Real.$fShowRatio_$s$cshow
  = \ (w_s1hIk :: Ratio Integer) ->
      case w_s1hIk of { :% ww1_s1hIn ww2_s1hIo ->
      case GHC.Real.$w$s$cshow ww1_s1hIn ww2_s1hIo of
      { (# ww4_s1hM6, ww5_s1hM7 #) ->
      GHC.Types.: @ Char ww4_s1hM6 ww5_s1hM7
      }
      }

-- RHS size: {terms: 15, types: 9, coercions: 0, joins: 0/0}
GHC.Real.$w$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => a -> a -> String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 130 0}]
GHC.Real.$w$cshow
  = \ (@ a_s1hIu)
      (w_s1hIv :: Show a_s1hIu)
      (ww_s1hIz
         :: a_s1hIu
         Unf=OtherCon [])
      (ww1_s1hIA
         :: a_s1hIu
         Unf=OtherCon []) ->
      showsPrec
        @ a_s1hIu
        w_s1hIv
        ratioPrec1
        ww_s1hIz
        (unpackAppendCString#
           GHC.Real.$fShowRatio2
           (showsPrec
              @ a_s1hIu w_s1hIv ratioPrec1 ww1_s1hIA (GHC.Types.[] @ Char)))

-- RHS size: {terms: 10, types: 11, coercions: 0, joins: 0/0}
GHC.Real.$fShowRatio_$cshow [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Ratio a -> String
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(C(S)))LL),U(C(C1(C1(U))),A,A)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hIu)
                 (w_s1hIv [Occ=Once] :: Show a_s1hIu)
                 (w1_s1hIw [Occ=Once!] :: Ratio a_s1hIu) ->
                 case w1_s1hIw of { :% ww1_s1hIz [Occ=Once] ww2_s1hIA [Occ=Once] ->
                 GHC.Real.$w$cshow @ a_s1hIu w_s1hIv ww1_s1hIz ww2_s1hIA
                 }}]
GHC.Real.$fShowRatio_$cshow
  = \ (@ a_s1hIu)
      (w_s1hIv :: Show a_s1hIu)
      (w1_s1hIw :: Ratio a_s1hIu) ->
      case w1_s1hIw of { :% ww1_s1hIz ww2_s1hIA ->
      GHC.Real.$w$cshow @ a_s1hIu w_s1hIv ww1_s1hIz ww2_s1hIA
      }

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
GHC.Real.$fShowRatio_$s$fShowRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: Show (Ratio Integer)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Ratio Integer
                       GHC.Real.$fShowRatio_$s$cshowsPrec
                       GHC.Real.$fShowRatio_$s$cshow
                       GHC.Real.$fShowRatio_$s$cshowList]
GHC.Real.$fShowRatio_$s$fShowRatio
  = GHC.Show.C:Show
      @ (Ratio Integer)
      GHC.Real.$fShowRatio_$s$cshowsPrec
      GHC.Real.$fShowRatio_$s$cshow
      GHC.Real.$fShowRatio_$s$cshowList

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
GHC.Real.$fShowRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (Ratio a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_a1dOc) (v_B1 :: Show a_a1dOc) ->
       GHC.Show.C:Show TYPE: Ratio a_a1dOc
                       GHC.Real.$fShowRatio_$cshowsPrec @ a_a1dOc v_B1
                       GHC.Real.$fShowRatio_$cshow @ a_a1dOc v_B1
                       GHC.Real.$fShowRatio_$cshowList @ a_a1dOc v_B1]
GHC.Real.$fShowRatio
  = \ (@ a_a1ePl) ($dShow_a1ePm :: Show a_a1ePl) ->
      GHC.Show.C:Show
        @ (Ratio a_a1ePl)
        (GHC.Real.$fShowRatio_$cshowsPrec @ a_a1ePl $dShow_a1ePm)
        (GHC.Real.$fShowRatio_$cshow @ a_a1ePl $dShow_a1ePm)
        (GHC.Real.$fShowRatio_$cshowList @ a_a1ePl $dShow_a1ePm)

-- RHS size: {terms: 36, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$w$slcm [InlPrag=NOINLINE[1]] :: Word -> Word# -> Word#
[GblId,
 Arity=2,
 Str=<L,1*U(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 30] 132 0}]
GHC.Real.$w$slcm
  = \ (w_s1hID :: Word) (ww_s1hIH :: Word#) ->
      case ww_s1hIH of wild_XeM {
        __DEFAULT ->
          case w_s1hID of wild1_X1fOj { W# x_X1fOn ->
          case x_X1fOn of wild2_XeU {
            __DEFAULT ->
              case gcd
                     @ Word GHC.Real.$fIntegralWord wild1_X1fOj (GHC.Types.W# wild_XeM)
              of
              { W# y#_a1dPj ->
              case y#_a1dPj of wild4_Xf4 {
                __DEFAULT ->
                  case quotWord# wild2_XeU wild4_Xf4 of wild5_Xx { __DEFAULT ->
                  timesWord# wild5_Xx wild_XeM
                  };
                0## -> case divZeroError of wild5_00 { }
              }
              };
            0## -> 0##
          }
          };
        0## -> 0##
      }

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
GHC.Real.lcm_$slcm [InlPrag=NOUSERINLINE[0]]
  :: Word -> Word -> Word
[GblId,
 Arity=2,
 Str=<L,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hID [Occ=Once] :: Word)
                 (w1_s1hIE [Occ=Once!] :: Word) ->
                 case w1_s1hIE of { W# ww1_s1hIH [Occ=Once] ->
                 case GHC.Real.$w$slcm w_s1hID ww1_s1hIH of ww2_s1hIL { __DEFAULT ->
                 GHC.Types.W# ww2_s1hIL
                 }
                 }}]
GHC.Real.lcm_$slcm
  = \ (w_s1hID :: Word) (w1_s1hIE :: Word) ->
      case w1_s1hIE of { W# ww1_s1hIH ->
      case GHC.Real.$w$slcm w_s1hID ww1_s1hIH of ww2_s1hIL { __DEFAULT ->
      GHC.Types.W# ww2_s1hIL
      }
      }

-- RHS size: {terms: 88, types: 26, coercions: 0, joins: 1/3}
GHC.Real.$w$slcm1 [InlPrag=NOINLINE[1]] :: Int -> Int# -> Int#
[GblId,
 Arity=2,
 Str=<L,1*U(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 30] 250 0}]
GHC.Real.$w$slcm1
  = \ (w_s1hIN :: Int) (ww_s1hIR :: Int#) ->
      case ww_s1hIR of wild_XeR {
        __DEFAULT ->
          case w_s1hIN of wild1_X2hw { I# x_X2hA ->
          case x_X2hA of wild2_XeZ {
            __DEFAULT ->
              join {
                $j_s1hY4 [Dmd=<C(S),1*C1(U)>] :: Int# -> Int#
                [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                $j_s1hY4 (ww1_s1hyc [OS=OneShot] :: Int#)
                  = case GHC.Real.$wgcd'
                           (case >=# wild2_XeZ 0# of {
                              __DEFAULT -> GHC.Types.I# (negateInt# wild2_XeZ);
                              1# -> wild1_X2hw
                            })
                           ww1_s1hyc
                    of
                    { I# x1_X2hJ ->
                    case x1_X2hJ of wild4_X9j {
                      __DEFAULT ->
                        case quotInt# wild2_XeZ wild4_X9j of wild5_i1fkX { __DEFAULT ->
                        let {
                          x2_i1fAb [Dmd=<S,U>] :: Int#
                          [LclId]
                          x2_i1fAb = *# wild5_i1fkX wild_XeR } in
                        case >=# x2_i1fAb 0# of {
                          __DEFAULT -> negateInt# x2_i1fAb;
                          1# -> x2_i1fAb
                        }
                        };
                      -1# ->
                        case wild2_XeZ of wild5_X9v {
                          __DEFAULT ->
                            let {
                              x2_i1fAb [Dmd=<S,U>] :: Int#
                              [LclId]
                              x2_i1fAb = *# (quotInt# wild5_X9v -1#) wild_XeR } in
                            case >=# x2_i1fAb 0# of {
                              __DEFAULT -> negateInt# x2_i1fAb;
                              1# -> x2_i1fAb
                            };
                          -9223372036854775808# -> case overflowError of wild6_00 { }
                        };
                      0# -> case divZeroError of wild5_00 { }
                    }
                    } } in
              case >=# wild_XeR 0# of {
                __DEFAULT -> jump $j_s1hY4 (negateInt# wild_XeR);
                1# -> jump $j_s1hY4 wild_XeR
              };
            0# -> 0#
          }
          };
        0# -> 0#
      }

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
GHC.Real.lcm_$slcm1 [InlPrag=NOUSERINLINE[0]] :: Int -> Int -> Int
[GblId,
 Arity=2,
 Str=<L,1*U(U)><S(S),1*U(1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hIN [Occ=Once] :: Int)
                 (w1_s1hIO [Occ=Once!] :: Int) ->
                 case w1_s1hIO of { I# ww1_s1hIR [Occ=Once] ->
                 case GHC.Real.$w$slcm1 w_s1hIN ww1_s1hIR of ww2_s1hIV
                 { __DEFAULT ->
                 GHC.Types.I# ww2_s1hIV
                 }
                 }}]
GHC.Real.lcm_$slcm1
  = \ (w_s1hIN :: Int) (w1_s1hIO :: Int) ->
      case w1_s1hIO of { I# ww1_s1hIR ->
      case GHC.Real.$w$slcm1 w_s1hIN ww1_s1hIR of ww2_s1hIV
      { __DEFAULT ->
      GHC.Types.I# ww2_s1hIV
      }
      }

-- RHS size: {terms: 52, types: 30, coercions: 0, joins: 0/4}
lcm [InlPrag=NOINLINE[1]] :: forall a. Integral a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(SS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(A,A,1*C1(C1(U)),A,C(U),A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,1*C1(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 510 0}]
lcm
  = \ (@ a_a1epg)
      ($dIntegral_a1epi :: Integral a_a1epg)
      (eta_B2 :: a_a1epg)
      (eta1_B1 :: a_a1epg) ->
      let {
        $dReal_s1fSQ [Dmd=<S(SS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,1*C1(C1(U)),A,1*C1(U),A,C(U)),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real a_a1epg
        [LclId]
        $dReal_s1fSQ = GHC.Real.$p1Integral @ a_a1epg $dIntegral_a1epi } in
      let {
        $dNum_s1fSP [Dmd=<S,U(A,A,1*C1(C1(U)),A,1*C1(U),A,C(U))>]
          :: Num a_a1epg
        [LclId]
        $dNum_s1fSP = GHC.Real.$p1Real @ a_a1epg $dReal_s1fSQ } in
      let {
        $dOrd_s1fSO [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
          :: Ord a_a1epg
        [LclId]
        $dOrd_s1fSO = GHC.Real.$p2Real @ a_a1epg $dReal_s1fSQ } in
      let {
        $dEq_s1fSN [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_a1epg
        [LclId]
        $dEq_s1fSN = GHC.Classes.$p1Ord @ a_a1epg $dOrd_s1fSO } in
      case ==
             @ a_a1epg
             $dEq_s1fSN
             eta1_B1
             (fromInteger @ a_a1epg $dNum_s1fSP GHC.Real.even1)
      of {
        False ->
          case ==
                 @ a_a1epg
                 $dEq_s1fSN
                 eta_B2
                 (fromInteger @ a_a1epg $dNum_s1fSP GHC.Real.even1)
          of {
            False ->
              abs
                @ a_a1epg
                $dNum_s1fSP
                (* @ a_a1epg
                   $dNum_s1fSP
                   (quot
                      @ a_a1epg
                      $dIntegral_a1epi
                      eta_B2
                      (gcd @ a_a1epg $dIntegral_a1epi eta_B2 eta1_B1))
                   eta1_B1);
            True -> fromInteger @ a_a1epg $dNum_s1fSP GHC.Real.even1
          };
        True -> fromInteger @ a_a1epg $dNum_s1fSP GHC.Real.even1
      }

-- RHS size: {terms: 26, types: 21, coercions: 0, joins: 0/2}
GHC.Real.$w$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Int -> (# a, a #)
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 20] 170 30}]
GHC.Real.$w$ctoEnum
  = \ (@ a_s1hJ1) (w_s1hJ2 :: Integral a_s1hJ1) (w1_s1hJ3 :: Int) ->
      let {
        $dReal_s1fSI [Dmd=<S(S(LLLLLLC(S))LL),1*U(1*U(A,A,A,A,A,A,C(U)),A,A)>]
          :: Real a_s1hJ1
        [LclId]
        $dReal_s1fSI = GHC.Real.$p1Integral @ a_s1hJ1 w_s1hJ2 } in
      let {
        $dNum_s1fSH [Dmd=<S(LLLLLLC(S)),U(A,A,A,A,A,A,C(U))>]
          :: Num a_s1hJ1
        [LclId]
        $dNum_s1fSH = GHC.Real.$p1Real @ a_s1hJ1 $dReal_s1fSI } in
      case fromInteger
             @ a_s1hJ1
             $dNum_s1fSH
             (case w1_s1hJ3 of { I# i_a1dPD -> smallInteger i_a1dPD })
      of dt_X1e8L
      { __DEFAULT ->
      case fromInteger @ a_s1hJ1 $dNum_s1fSH GHC.Real.$fEnumRatio1
      of dt1_X1e8Q
      { __DEFAULT ->
      (# dt_X1e8L, dt1_X1e8Q #)
      }
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$ctoEnum [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Int -> Ratio a
[GblId,
 Arity=2,
 Str=<S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hJ1)
                 (w_s1hJ2 [Occ=Once] :: Integral a_s1hJ1)
                 (w1_s1hJ3 [Occ=Once] :: Int) ->
                 case GHC.Real.$w$ctoEnum @ a_s1hJ1 w_s1hJ2 w1_s1hJ3 of
                 { (# ww1_s1hM9 [Occ=Once], ww2_s1hMa [Occ=Once] #) ->
                 GHC.Real.:% @ a_s1hJ1 ww1_s1hM9 ww2_s1hMa
                 }}]
GHC.Real.$fEnumRatio_$ctoEnum
  = \ (@ a_s1hJ1) (w_s1hJ2 :: Integral a_s1hJ1) (w1_s1hJ3 :: Int) ->
      case GHC.Real.$w$ctoEnum @ a_s1hJ1 w_s1hJ2 w1_s1hJ3 of
      { (# ww1_s1hM9, ww2_s1hMa #) ->
      GHC.Real.:% @ a_s1hJ1 ww1_s1hM9 ww2_s1hMa
      }

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio_$s$fEnumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum (Ratio Integer)
[GblId,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: Ratio Integer
                       GHC.Real.$fEnumRatio_$s$csucc
                       GHC.Real.$fEnumRatio_$s$cpred
                       GHC.Real.$fEnumRatio_$ctoRational
                       GHC.Real.$fEnumRatio_$s$cfromEnum
                       GHC.Real.$fEnumRatio_$snumericEnumFrom
                       GHC.Real.$fEnumRatio_$snumericEnumFromThen
                       GHC.Real.$fEnumRatio_$snumericEnumFromTo
                       GHC.Real.$fEnumRatio_$snumericEnumFromThenTo]
GHC.Real.$fEnumRatio_$s$fEnumRatio
  = GHC.Enum.C:Enum
      @ (Ratio Integer)
      GHC.Real.$fEnumRatio_$s$csucc
      GHC.Real.$fEnumRatio_$s$cpred
      GHC.Real.$fEnumRatio_$ctoRational
      GHC.Real.$fEnumRatio_$s$cfromEnum
      GHC.Real.$fEnumRatio_$snumericEnumFrom
      GHC.Real.$fEnumRatio_$snumericEnumFromThen
      GHC.Real.$fEnumRatio_$snumericEnumFromTo
      GHC.Real.$fEnumRatio_$snumericEnumFromThenTo

-- RHS size: {terms: 19, types: 14, coercions: 0, joins: 0/0}
GHC.Real.$fEnumRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Integral a => Enum (Ratio a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,C(C1(U(1*U,A))),A,C(U))>m,
 Unf=DFun: \ (@ a_a1dO8) (v_B1 :: Integral a_a1dO8) ->
       GHC.Enum.C:Enum TYPE: Ratio a_a1dO8
                       GHC.Real.$fEnumRatio_$csucc @ a_a1dO8 v_B1
                       GHC.Real.$fEnumRatio_$cpred @ a_a1dO8 v_B1
                       GHC.Real.$fEnumRatio_$ctoEnum @ a_a1dO8 v_B1
                       GHC.Real.$fEnumRatio_$cfromEnum @ a_a1dO8 v_B1
                       GHC.Real.$fEnumRatio_$cenumFrom @ a_a1dO8 v_B1
                       GHC.Real.$fEnumRatio_$cenumFromThen @ a_a1dO8 v_B1
                       GHC.Real.$fEnumRatio_$cenumFromTo @ a_a1dO8 v_B1
                       GHC.Real.$fEnumRatio_$cenumFromThenTo @ a_a1dO8 v_B1]
GHC.Real.$fEnumRatio
  = \ (@ a_a1eE0) ($dIntegral_a1eE1 :: Integral a_a1eE0) ->
      GHC.Enum.C:Enum
        @ (Ratio a_a1eE0)
        (GHC.Real.$fEnumRatio_$csucc @ a_a1eE0 $dIntegral_a1eE1)
        (GHC.Real.$fEnumRatio_$cpred @ a_a1eE0 $dIntegral_a1eE1)
        (GHC.Real.$fEnumRatio_$ctoEnum @ a_a1eE0 $dIntegral_a1eE1)
        (GHC.Real.$fEnumRatio_$cfromEnum @ a_a1eE0 $dIntegral_a1eE1)
        (GHC.Real.$fEnumRatio_$cenumFrom @ a_a1eE0 $dIntegral_a1eE1)
        (GHC.Real.$fEnumRatio_$cenumFromThen @ a_a1eE0 $dIntegral_a1eE1)
        (GHC.Real.$fEnumRatio_$cenumFromTo @ a_a1eE0 $dIntegral_a1eE1)
        (GHC.Real.$fEnumRatio_$cenumFromThenTo @ a_a1eE0 $dIntegral_a1eE1)

Rec {
-- RHS size: {terms: 34, types: 5, coercions: 0, joins: 0/0}
$wg_r1j3P :: Int# -> Int# -> Int# -> Int#
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,U><S,U><S,U>,
 Unf=OtherCon []]
$wg_r1j3P
  = \ (ww_s1hJd :: Int#) (ww1_s1hJh :: Int#) (ww2_s1hJl :: Int#) ->
      case remInt# ww1_s1hJh 2# of {
        __DEFAULT ->
          case ww1_s1hJh of wild1_Xfl {
            __DEFAULT ->
              $wg_r1j3P
                (*# ww_s1hJd ww_s1hJd)
                (quotInt# wild1_Xfl 2#)
                (*# ww_s1hJd ww2_s1hJl);
            1# -> *# ww_s1hJd ww2_s1hJl
          };
        0# ->
          $wg_r1j3P (*# ww_s1hJd ww_s1hJd) (quotInt# ww1_s1hJh 2#) ww2_s1hJl
      }
end Rec }

Rec {
-- RHS size: {terms: 28, types: 4, coercions: 0, joins: 0/0}
GHC.Real.$wf1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Int# -> Int# -> Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []]
GHC.Real.$wf1
  = \ (ww_s1hJv :: Int#) (ww1_s1hJz :: Int#) ->
      case remInt# ww1_s1hJz 2# of {
        __DEFAULT ->
          case ww1_s1hJz of wild1_Xfl {
            __DEFAULT ->
              $wg_r1j3P (*# ww_s1hJv ww_s1hJv) (quotInt# wild1_Xfl 2#) ww_s1hJv;
            1# -> ww_s1hJv
          };
        0# -> GHC.Real.$wf1 (*# ww_s1hJv ww_s1hJv) (quotInt# ww1_s1hJz 2#)
      }
end Rec }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
GHC.Real.^_f2 [InlPrag=NOUSERINLINE[0]] :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hJr [Occ=Once!] :: Int)
                 (w1_s1hJs [Occ=Once!] :: Int) ->
                 case w_s1hJr of { I# ww1_s1hJv [Occ=Once] ->
                 case w1_s1hJs of { I# ww3_s1hJz [Occ=Once] ->
                 case GHC.Real.$wf1 ww1_s1hJv ww3_s1hJz of ww4_s1hJD { __DEFAULT ->
                 GHC.Types.I# ww4_s1hJD
                 }
                 }
                 }}]
GHC.Real.^_f2
  = \ (w_s1hJr :: Int) (w1_s1hJs :: Int) ->
      case w_s1hJr of { I# ww1_s1hJv ->
      case w1_s1hJs of { I# ww3_s1hJz ->
      case GHC.Real.$wf1 ww1_s1hJv ww3_s1hJz of ww4_s1hJD { __DEFAULT ->
      GHC.Types.I# ww4_s1hJD
      }
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Real.^3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Real.^3 = GHC.Types.I# 1#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Real.^2 :: Int
[GblId, Str=x]
GHC.Real.^2
  = errorWithoutStackTrace
      @ 'LiftedRep @ Int (unpackCString# lvl5_r1j3O)

-- RHS size: {terms: 27, types: 9, coercions: 0, joins: 0/0}
GHC.Real.^_$s^2 [InlPrag=NOUSERINLINE[1]] :: Int -> Int -> Int
[GblId,
 Arity=2,
 Str=<L,1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x0_a1dQF [Occ=Once] :: Int)
                 (y0_a1dQG [Occ=Once!] :: Int) ->
                 case y0_a1dQG of wild_alN7 { I# x_alN9 ->
                 case <# x_alN9 0# of {
                   __DEFAULT ->
                     case x_alN9 of {
                       __DEFAULT -> GHC.Real.^_f2 x0_a1dQF wild_alN7;
                       0# -> GHC.Real.^3
                     };
                   1# -> GHC.Real.^2
                 }
                 }}]
GHC.Real.^_$s^2
  = \ (x0_a1dQF :: Int) (y0_a1dQG :: Int) ->
      case y0_a1dQG of { I# x_alN9 ->
      case <# x_alN9 0# of {
        __DEFAULT ->
          case x_alN9 of wild1_Xfm {
            __DEFAULT ->
              case x0_a1dQF of { I# ww1_s1hJv ->
              case GHC.Real.$wf1 ww1_s1hJv wild1_Xfm of ww2_s1hJD { __DEFAULT ->
              GHC.Types.I# ww2_s1hJD
              }
              };
            0# -> GHC.Real.^3
          };
        1# -> GHC.Real.^2
      }
      }

Rec {
-- RHS size: {terms: 34, types: 5, coercions: 0, joins: 0/0}
$wg1_r1j3Q :: Integer -> Int# -> Integer -> Integer
[GblId, Arity=3, Str=<S,U><S,U><S,1*U>, Unf=OtherCon []]
$wg1_r1j3Q
  = \ (w_s1hJF :: Integer)
      (ww_s1hJK :: Int#)
      (w1_s1hJH :: Integer) ->
      case remInt# ww_s1hJK 2# of {
        __DEFAULT ->
          case ww_s1hJK of wild1_Xfy {
            __DEFAULT ->
              $wg1_r1j3Q
                (timesInteger w_s1hJF w_s1hJF)
                (quotInt# wild1_Xfy 2#)
                (timesInteger w_s1hJF w1_s1hJH);
            1# -> timesInteger w_s1hJF w1_s1hJH
          };
        0# ->
          $wg1_r1j3Q
            (timesInteger w_s1hJF w_s1hJF) (quotInt# ww_s1hJK 2#) w1_s1hJH
      }
end Rec }

Rec {
-- RHS size: {terms: 28, types: 4, coercions: 0, joins: 0/0}
GHC.Real.$wf [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: Integer -> Int# -> Integer
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []]
GHC.Real.$wf
  = \ (w_s1hJN :: Integer) (ww_s1hJR :: Int#) ->
      case remInt# ww_s1hJR 2# of {
        __DEFAULT ->
          case ww_s1hJR of wild1_Xfy {
            __DEFAULT ->
              $wg1_r1j3Q
                (timesInteger w_s1hJN w_s1hJN) (quotInt# wild1_Xfy 2#) w_s1hJN;
            1# -> w_s1hJN
          };
        0# ->
          GHC.Real.$wf (timesInteger w_s1hJN w_s1hJN) (quotInt# ww_s1hJR 2#)
      }
end Rec }

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
GHC.Real.^_f1 [InlPrag=NOUSERINLINE[0]]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<S,U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s1hJN [Occ=Once] :: Integer)
                 (w1_s1hJO [Occ=Once!] :: Int) ->
                 case w1_s1hJO of { I# ww1_s1hJR [Occ=Once] ->
                 GHC.Real.$wf w_s1hJN ww1_s1hJR
                 }}]
GHC.Real.^_f1
  = \ (w_s1hJN :: Integer) (w1_s1hJO :: Int) ->
      case w1_s1hJO of { I# ww1_s1hJR -> GHC.Real.$wf w_s1hJN ww1_s1hJR }

-- RHS size: {terms: 20, types: 6, coercions: 0, joins: 0/0}
GHC.Real.^_$s^1 [InlPrag=NOUSERINLINE[1]]
  :: Integer -> Int -> Integer
[GblId,
 Arity=2,
 Str=<L,U><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x0_a1dQF [Occ=Once] :: Integer)
                 (y0_a1dQG [Occ=Once!] :: Int) ->
                 case y0_a1dQG of wild_alN7 { I# x_alN9 ->
                 case <# x_alN9 0# of {
                   __DEFAULT ->
                     case x_alN9 of {
                       __DEFAULT -> GHC.Real.^_f1 x0_a1dQF wild_alN7;
                       0# -> GHC.Real.$fEnumRatio1
                     };
                   1# -> GHC.Real.^1
                 }
                 }}]
GHC.Real.^_$s^1
  = \ (x0_a1dQF :: Integer) (y0_a1dQG :: Int) ->
      case y0_a1dQG of { I# x_alN9 ->
      case <# x_alN9 0# of {
        __DEFAULT ->
          case x_alN9 of wild1_Xfz {
            __DEFAULT -> GHC.Real.$wf x0_a1dQF wild1_Xfz;
            0# -> GHC.Real.$fEnumRatio1
          };
        1# -> GHC.Real.^1
      }
      }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl6_r1j3R :: Rational
[GblId, Str=x]
lvl6_r1j3R
  = errorWithoutStackTrace
      @ 'LiftedRep @ Rational (unpackCString# lvl5_r1j3O)

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
lvl7_r1j3S :: forall a. a
[GblId, Str=x]
lvl7_r1j3S
  = \ (@ a_a1eqp) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a1eqp (unpackCString# lvl5_r1j3O)

Rec {
-- RHS size: {terms: 144, types: 75, coercions: 0, joins: 4/10}
^ [InlPrag=INLINABLE[1]]
  :: forall a b. (Num a, Integral b) => a -> b -> a
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))><S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER
         Tmpl= \ (@ a_a1eqp)
                 (@ b_a1eqq)
                 ($dNum_a1eqs :: Num a_a1eqp)
                 ($dIntegral_a1eqt :: Integral b_a1eqq) ->
                 let {
                   $dReal_a1eWL :: Real b_a1eqq
                   [LclId]
                   $dReal_a1eWL = GHC.Real.$p1Integral @ b_a1eqq $dIntegral_a1eqt } in
                 let {
                   $dNum1_a1eWN :: Num b_a1eqq
                   [LclId]
                   $dNum1_a1eWN = GHC.Real.$p1Real @ b_a1eqq $dReal_a1eWL } in
                 let {
                   $dOrd_a1eWO :: Ord b_a1eqq
                   [LclId]
                   $dOrd_a1eWO = GHC.Real.$p2Real @ b_a1eqq $dReal_a1eWL } in
                 let {
                   $dEq_a1esI [Occ=OnceL] :: Eq b_a1eqq
                   [LclId]
                   $dEq_a1esI = GHC.Classes.$p1Ord @ b_a1eqq $dOrd_a1eWO } in
                 \ (x0_a1dQF [Occ=Once] :: a_a1eqp) (y0_a1dQG :: b_a1eqq) ->
                   case < @ b_a1eqq
                          $dOrd_a1eWO
                          y0_a1dQG
                          (fromInteger @ b_a1eqq $dNum1_a1eWN 0)
                   of {
                     False ->
                       case ==
                              @ b_a1eqq
                              $dEq_a1esI
                              y0_a1dQG
                              (fromInteger @ b_a1eqq $dNum1_a1eWN 0)
                       of {
                         False ->
                           let {
                             $dReal1_a1eWV :: Real b_a1eqq
                             [LclId]
                             $dReal1_a1eWV
                               = GHC.Real.$p1Integral @ b_a1eqq $dIntegral_a1eqt } in
                           let {
                             $dNum2_a1es2 :: Num b_a1eqq
                             [LclId]
                             $dNum2_a1es2 = GHC.Real.$p1Real @ b_a1eqq $dReal1_a1eWV } in
                           let {
                             $dEq1_s1fAU [Occ=OnceL] :: Ord b_a1eqq
                             [LclId]
                             $dEq1_s1fAU = GHC.Real.$p2Real @ b_a1eqq $dReal1_a1eWV } in
                           let {
                             $dEq2_a1es4 [Occ=OnceL] :: Eq b_a1eqq
                             [LclId]
                             $dEq2_a1es4 = GHC.Classes.$p1Ord @ b_a1eqq $dEq1_s1fAU } in
                           joinrec {
                             f_a1erD [Occ=LoopBreakerT[2]] :: a_a1eqp -> b_a1eqq -> a_a1eqp
                             [LclId[JoinId(2)], Arity=2, Unf=OtherCon []]
                             f_a1erD (x_a1dQJ :: a_a1eqp) (y_a1dQK :: b_a1eqq)
                               = case even @ b_a1eqq $dIntegral_a1eqt y_a1dQK of {
                                   False ->
                                     case ==
                                            @ b_a1eqq
                                            $dEq2_a1es4
                                            y_a1dQK
                                            (fromInteger @ b_a1eqq $dNum2_a1es2 1)
                                     of {
                                       False ->
                                         let {
                                           $dReal2_a1eWQ :: Real b_a1eqq
                                           [LclId]
                                           $dReal2_a1eWQ
                                             = GHC.Real.$p1Integral @ b_a1eqq $dIntegral_a1eqt } in
                                         let {
                                           $dNum3_a1eqY :: Num b_a1eqq
                                           [LclId]
                                           $dNum3_a1eqY
                                             = GHC.Real.$p1Real @ b_a1eqq $dReal2_a1eWQ } in
                                         let {
                                           $dEq3_s1fAX [Occ=OnceL] :: Ord b_a1eqq
                                           [LclId]
                                           $dEq3_s1fAX
                                             = GHC.Real.$p2Real @ b_a1eqq $dReal2_a1eWQ } in
                                         let {
                                           $dEq4_a1er4 [Occ=OnceL] :: Eq b_a1eqq
                                           [LclId]
                                           $dEq4_a1er4
                                             = GHC.Classes.$p1Ord @ b_a1eqq $dEq3_s1fAX } in
                                         joinrec {
                                           g1_a1eqw [Occ=LoopBreakerT[3]]
                                             :: a_a1eqp -> b_a1eqq -> a_a1eqp -> a_a1eqp
                                           [LclId[JoinId(3)], Arity=3, Unf=OtherCon []]
                                           g1_a1eqw (x1_a1dQL :: a_a1eqp)
                                                    (y1_a1dQM :: b_a1eqq)
                                                    (z_a1dQN [Occ=Once*] :: a_a1eqp)
                                             = case even @ b_a1eqq $dIntegral_a1eqt y1_a1dQM of {
                                                 False ->
                                                   case ==
                                                          @ b_a1eqq
                                                          $dEq4_a1er4
                                                          y1_a1dQM
                                                          (fromInteger @ b_a1eqq $dNum3_a1eqY 1)
                                                   of {
                                                     False ->
                                                       jump g1_a1eqw
                                                         (* @ a_a1eqp $dNum_a1eqs x1_a1dQL x1_a1dQL)
                                                         (quot
                                                            @ b_a1eqq
                                                            $dIntegral_a1eqt
                                                            y1_a1dQM
                                                            (fromInteger @ b_a1eqq $dNum3_a1eqY 2))
                                                         (* @ a_a1eqp $dNum_a1eqs x1_a1dQL z_a1dQN);
                                                     True ->
                                                       * @ a_a1eqp $dNum_a1eqs x1_a1dQL z_a1dQN
                                                   };
                                                 True ->
                                                   jump g1_a1eqw
                                                     (* @ a_a1eqp $dNum_a1eqs x1_a1dQL x1_a1dQL)
                                                     (quot
                                                        @ b_a1eqq
                                                        $dIntegral_a1eqt
                                                        y1_a1dQM
                                                        (fromInteger @ b_a1eqq $dNum3_a1eqY 2))
                                                     z_a1dQN
                                               }; } in
                                         jump g1_a1eqw
                                           (* @ a_a1eqp $dNum_a1eqs x_a1dQJ x_a1dQJ)
                                           (quot
                                              @ b_a1eqq
                                              $dIntegral_a1eqt
                                              y_a1dQK
                                              (fromInteger @ b_a1eqq $dNum2_a1es2 2))
                                           x_a1dQJ;
                                       True -> x_a1dQJ
                                     };
                                   True ->
                                     jump f_a1erD
                                       (* @ a_a1eqp $dNum_a1eqs x_a1dQJ x_a1dQJ)
                                       (quot
                                          @ b_a1eqq
                                          $dIntegral_a1eqt
                                          y_a1dQK
                                          (fromInteger @ b_a1eqq $dNum2_a1es2 2))
                                 }; } in
                           jump f_a1erD x0_a1dQF y0_a1dQG;
                         True -> fromInteger @ a_a1eqp $dNum_a1eqs 1
                       };
                     True ->
                       errorWithoutStackTrace
                         @ 'LiftedRep @ a_a1eqp (unpackCString# "Negative exponent"#)
                   }}]
^ = \ (@ a_a1eqp)
      (@ b_a1eqq)
      ($dNum_a1eqs :: Num a_a1eqp)
      ($dIntegral_a1eqt :: Integral b_a1eqq)
      (eta_B2 :: a_a1eqp)
      (eta1_B1 :: b_a1eqq) ->
      let {
        $dReal_s1fSc [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
          :: Real b_a1eqq
        [LclId]
        $dReal_s1fSc = GHC.Real.$p1Integral @ b_a1eqq $dIntegral_a1eqt } in
      let {
        $dNum1_s1fSb [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num b_a1eqq
        [LclId]
        $dNum1_s1fSb = GHC.Real.$p1Real @ b_a1eqq $dReal_s1fSc } in
      let {
        $dOrd_s1fSa [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
          :: Ord b_a1eqq
        [LclId]
        $dOrd_s1fSa = GHC.Real.$p2Real @ b_a1eqq $dReal_s1fSc } in
      case < @ b_a1eqq
             $dOrd_s1fSa
             eta1_B1
             (fromInteger @ b_a1eqq $dNum1_s1fSb GHC.Real.even1)
      of {
        False ->
          case ==
                 @ b_a1eqq
                 (GHC.Classes.$p1Ord @ b_a1eqq $dOrd_s1fSa)
                 eta1_B1
                 (fromInteger @ b_a1eqq $dNum1_s1fSb GHC.Real.even1)
          of {
            False ->
              let {
                lvl8_s1g2O :: b_a1eqq
                [LclId]
                lvl8_s1g2O = fromInteger @ b_a1eqq $dNum1_s1fSb GHC.Real.even2 } in
              join {
                exit_X7M [Dmd=<C(C(S)),C(C1(U))>] :: a_a1eqp -> b_a1eqq -> a_a1eqp
                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>]
                exit_X7M (x_a1dQJ [OS=OneShot] :: a_a1eqp)
                         (y_a1dQK [OS=OneShot] :: b_a1eqq)
                  = let {
                      $dEq_s1fSd [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq b_a1eqq
                      [LclId]
                      $dEq_s1fSd = GHC.Classes.$p1Ord @ b_a1eqq $dOrd_s1fSa } in
                    let {
                      lvl9_s1g2w :: b_a1eqq
                      [LclId]
                      lvl9_s1g2w
                        = fromInteger @ b_a1eqq $dNum1_s1fSb GHC.Real.$fEnumRatio1 } in
                    case == @ b_a1eqq $dEq_s1fSd y_a1dQK lvl9_s1g2w of {
                      False ->
                        join {
                          exit1_X7T [Dmd=<C(C(S)),C(C1(U))>] :: a_a1eqp -> a_a1eqp -> a_a1eqp
                          [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>]
                          exit1_X7T (x1_a1dQL [OS=OneShot] :: a_a1eqp)
                                    (z_a1dQN [OS=OneShot] :: a_a1eqp)
                            = * @ a_a1eqp $dNum_a1eqs x1_a1dQL z_a1dQN } in
                        joinrec {
                          g1_s1fSm [Occ=LoopBreaker]
                            :: a_a1eqp -> b_a1eqq -> a_a1eqp -> a_a1eqp
                          [LclId[JoinId(3)], Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
                          g1_s1fSm (x1_a1dQL :: a_a1eqp)
                                   (y1_a1dQM :: b_a1eqq)
                                   (z_a1dQN :: a_a1eqp)
                            = case even @ b_a1eqq $dIntegral_a1eqt y1_a1dQM of {
                                False ->
                                  case == @ b_a1eqq $dEq_s1fSd y1_a1dQM lvl9_s1g2w of {
                                    False ->
                                      jump g1_s1fSm
                                        (* @ a_a1eqp $dNum_a1eqs x1_a1dQL x1_a1dQL)
                                        (quot @ b_a1eqq $dIntegral_a1eqt y1_a1dQM lvl8_s1g2O)
                                        (* @ a_a1eqp $dNum_a1eqs x1_a1dQL z_a1dQN);
                                    True -> jump exit1_X7T x1_a1dQL z_a1dQN
                                  };
                                True ->
                                  jump g1_s1fSm
                                    (* @ a_a1eqp $dNum_a1eqs x1_a1dQL x1_a1dQL)
                                    (quot @ b_a1eqq $dIntegral_a1eqt y1_a1dQM lvl8_s1g2O)
                                    z_a1dQN
                              }; } in
                        jump g1_s1fSm
                          (* @ a_a1eqp $dNum_a1eqs x_a1dQJ x_a1dQJ)
                          (quot @ b_a1eqq $dIntegral_a1eqt y_a1dQK lvl8_s1g2O)
                          x_a1dQJ;
                      True -> x_a1dQJ
                    } } in
              joinrec {
                f_s1fS9 [Occ=LoopBreaker] :: a_a1eqp -> b_a1eqq -> a_a1eqp
                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []]
                f_s1fS9 (x_a1dQJ :: a_a1eqp) (y_a1dQK :: b_a1eqq)
                  = case even @ b_a1eqq $dIntegral_a1eqt y_a1dQK of {
                      False -> jump exit_X7M x_a1dQJ y_a1dQK;
                      True ->
                        jump f_s1fS9
                          (* @ a_a1eqp $dNum_a1eqs x_a1dQJ x_a1dQJ)
                          (quot @ b_a1eqq $dIntegral_a1eqt y_a1dQK lvl8_s1g2O)
                    }; } in
              jump f_s1fS9 eta_B2 eta1_B1;
            True -> fromInteger @ a_a1eqp $dNum_a1eqs GHC.Real.$fEnumRatio1
          };
        True -> lvl7_r1j3S @ a_a1eqp
      }

-- RHS size: {terms: 17, types: 18, coercions: 0, joins: 0/0}
^%^ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a. Integral a => Rational -> a -> Rational
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hK5)
                 (w_s1hK6 [Occ=Once] :: Integral a_s1hK5)
                 (w1_s1hK7 [Occ=Once!] :: Rational)
                 (w2_s1hK8 [Occ=Once] :: a_s1hK5) ->
                 case w1_s1hK7 of { :% ww1_s1hKb [Occ=Once] ww2_s1hKc [Occ=Once] ->
                 case GHC.Real.$w^%^ @ a_s1hK5 w_s1hK6 ww1_s1hKb ww2_s1hKc w2_s1hK8
                 of
                 { (# ww4_s1hMc [Occ=Once], ww5_s1hMd [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww4_s1hMc ww5_s1hMd
                 }
                 }}]
^%^
  = \ (@ a_s1hK5)
      (w_s1hK6 :: Integral a_s1hK5)
      (w1_s1hK7 :: Rational)
      (w2_s1hK8 :: a_s1hK5) ->
      case w1_s1hK7 of { :% ww1_s1hKb ww2_s1hKc ->
      case GHC.Real.$w^%^ @ a_s1hK5 w_s1hK6 ww1_s1hKb ww2_s1hKc w2_s1hK8
      of
      { (# ww4_s1hMc, ww5_s1hMd #) ->
      GHC.Real.:% @ Integer ww4_s1hMc ww5_s1hMd
      }
      }

-- RHS size: {terms: 55, types: 38, coercions: 0, joins: 0/3}
GHC.Real.$w^%^ [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a.
     Integral a =>
     Integer -> Integer -> a -> (# Integer, Integer #)
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []]
GHC.Real.$w^%^
  = \ (@ a_s1hK5)
      (w_s1hK6 :: Integral a_s1hK5)
      (ww_s1hKb
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hKc
         :: Integer
         Unf=OtherCon [])
      (w1_s1hK8 :: a_s1hK5) ->
      let {
        $dReal_s1fSw [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
          :: Real a_s1hK5
        [LclId]
        $dReal_s1fSw = GHC.Real.$p1Integral @ a_s1hK5 w_s1hK6 } in
      let {
        $dNum_s1fSv [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: Num a_s1hK5
        [LclId]
        $dNum_s1fSv = GHC.Real.$p1Real @ a_s1hK5 $dReal_s1fSw } in
      let {
        $dOrd_s1fSu [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
          :: Ord a_s1hK5
        [LclId]
        $dOrd_s1fSu = GHC.Real.$p2Real @ a_s1hK5 $dReal_s1fSw } in
      case < @ a_s1hK5
             $dOrd_s1fSu
             w1_s1hK8
             (fromInteger @ a_s1hK5 $dNum_s1fSv GHC.Real.even1)
      of {
        False ->
          case ==
                 @ a_s1hK5
                 (GHC.Classes.$p1Ord @ a_s1hK5 $dOrd_s1fSu)
                 w1_s1hK8
                 (fromInteger @ a_s1hK5 $dNum_s1fSv GHC.Real.even1)
          of {
            False ->
              case ^ @ Integer
                     @ a_s1hK5
                     GHC.Num.$fNumInteger
                     w_s1hK6
                     ww_s1hKb
                     w1_s1hK8
              of dt_X1e9U
              { __DEFAULT ->
              case ^ @ Integer
                     @ a_s1hK5
                     GHC.Num.$fNumInteger
                     w_s1hK6
                     ww1_s1hKc
                     w1_s1hK8
              of dt1_X1e9Z
              { __DEFAULT ->
              (# dt_X1e9U, dt1_X1e9Z #)
              }
              };
            True -> (# GHC.Real.$fEnumRatio1, GHC.Real.$fEnumRatio1 #)
          };
        True -> case lvl6_r1j3R of wild1_00 { }
      }
end Rec }

-- RHS size: {terms: 130, types: 76, coercions: 0, joins: 0/5}
GHC.Real.$w^^%^^ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Integral a =>
     Integer -> Integer -> a -> (# Integer, Integer #)
[GblId,
 Arity=4,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLLLL),U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,1*C1(C1(U)),A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=OtherCon []]
GHC.Real.$w^^%^^
  = \ (@ a_s1hKi)
      (w_s1hKj :: Integral a_s1hKi)
      (ww_s1hKo
         :: Integer
         Unf=OtherCon [])
      (ww1_s1hKp
         :: Integer
         Unf=OtherCon [])
      (w1_s1hKl :: a_s1hKi) ->
      let {
        $dReal_s1fRW [Dmd=<S(LS(LLLLC(C(S))LLL)L),U(1*U(A,A,A,C(U),A,A,C(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,1*C1(C1(U)),A,A,A),A)>]
          :: Real a_s1hKi
        [LclId]
        $dReal_s1fRW = GHC.Real.$p1Integral @ a_s1hKi w_s1hKj } in
      let {
        $dNum_s1fRV [Dmd=<L,U(A,A,A,C(U),A,A,C(U))>] :: Num a_s1hKi
        [LclId]
        $dNum_s1fRV = GHC.Real.$p1Real @ a_s1hKi $dReal_s1fRW } in
      let {
        $dOrd_s1fRU [Dmd=<S(LLLLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,A,A,1*C1(C1(U)),A,A,A)>]
          :: Ord a_s1hKi
        [LclId]
        $dOrd_s1fRU = GHC.Real.$p2Real @ a_s1hKi $dReal_s1fRW } in
      case > @ a_s1hKi
             $dOrd_s1fRU
             w1_s1hKl
             (fromInteger @ a_s1hKi $dNum_s1fRV GHC.Real.even1)
      of {
        False ->
          case ==
                 @ a_s1hKi
                 (GHC.Classes.$p1Ord @ a_s1hKi $dOrd_s1fRU)
                 w1_s1hKl
                 (fromInteger @ a_s1hKi $dNum_s1fRV GHC.Real.even1)
          of {
            False ->
              case gtInteger# ww_s1hKo GHC.Real.even1 of {
                __DEFAULT ->
                  case eqInteger# ww_s1hKo GHC.Real.even1 of {
                    __DEFAULT ->
                      let {
                        dd_s1fS0 [Dmd=<S,1*U>] :: Integer
                        [LclId]
                        dd_s1fS0
                          = ^ @ Integer
                              @ a_s1hKi
                              GHC.Num.$fNumInteger
                              w_s1hKj
                              (negateInteger ww_s1hKo)
                              (negate @ a_s1hKi $dNum_s1fRV w1_s1hKl) } in
                      let {
                        nn_s1fRZ [Dmd=<S,1*U>] :: Integer
                        [LclId]
                        nn_s1fRZ
                          = ^ @ Integer
                              @ a_s1hKi
                              GHC.Num.$fNumInteger
                              w_s1hKj
                              ww1_s1hKp
                              (negate @ a_s1hKi $dNum_s1fRV w1_s1hKl) } in
                      case even @ a_s1hKi w_s1hKj w1_s1hKl of {
                        False ->
                          case negateInteger nn_s1fRZ of dt_X1ean { __DEFAULT ->
                          case dd_s1fS0 of dt1_X1eas { __DEFAULT ->
                          (# dt_X1ean, dt1_X1eas #)
                          }
                          };
                        True ->
                          case nn_s1fRZ of dt_X1e90 { __DEFAULT ->
                          case dd_s1fS0 of dt1_X1e95 { __DEFAULT ->
                          (# dt_X1e90, dt1_X1e95 #)
                          }
                          }
                      };
                    1# -> case ratioZeroDenominatorError of wild4_00 { }
                  };
                1# ->
                  case ^ @ Integer
                         @ a_s1hKi
                         GHC.Num.$fNumInteger
                         w_s1hKj
                         ww1_s1hKp
                         (negate @ a_s1hKi $dNum_s1fRV w1_s1hKl)
                  of dt_X1eaa
                  { __DEFAULT ->
                  case ^ @ Integer
                         @ a_s1hKi
                         GHC.Num.$fNumInteger
                         w_s1hKj
                         ww_s1hKo
                         (negate @ a_s1hKi $dNum_s1fRV w1_s1hKl)
                  of dt1_X1eaf
                  { __DEFAULT ->
                  (# dt_X1eaa, dt1_X1eaf #)
                  }
                  }
              };
            True -> (# GHC.Real.$fEnumRatio1, GHC.Real.$fEnumRatio1 #)
          };
        True ->
          case ^ @ Integer
                 @ a_s1hKi
                 GHC.Num.$fNumInteger
                 w_s1hKj
                 ww_s1hKo
                 w1_s1hKl
          of dt_X1ea1
          { __DEFAULT ->
          case ^ @ Integer
                 @ a_s1hKi
                 GHC.Num.$fNumInteger
                 w_s1hKj
                 ww1_s1hKp
                 w1_s1hKl
          of dt1_X1ea6
          { __DEFAULT ->
          (# dt_X1ea1, dt1_X1ea6 #)
          }
          }
      }

-- RHS size: {terms: 17, types: 18, coercions: 0, joins: 0/0}
^^%^^ [InlPrag=NOUSERINLINE[0]]
  :: forall a. Integral a => Rational -> a -> Rational
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLLC(C(S))LLL)L)LLLLLLLL),U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(SS),1*U(U,U)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s1hKi)
                 (w_s1hKj [Occ=Once] :: Integral a_s1hKi)
                 (w1_s1hKk [Occ=Once!] :: Rational)
                 (w2_s1hKl [Occ=Once] :: a_s1hKi) ->
                 case w1_s1hKk of { :% ww1_s1hKo [Occ=Once] ww2_s1hKp [Occ=Once] ->
                 case GHC.Real.$w^^%^^
                        @ a_s1hKi w_s1hKj ww1_s1hKo ww2_s1hKp w2_s1hKl
                 of
                 { (# ww4_s1hMf [Occ=Once], ww5_s1hMg [Occ=Once] #) ->
                 GHC.Real.:% @ Integer ww4_s1hMf ww5_s1hMg
                 }
                 }}]
^^%^^
  = \ (@ a_s1hKi)
      (w_s1hKj :: Integral a_s1hKi)
      (w1_s1hKk :: Rational)
      (w2_s1hKl :: a_s1hKi) ->
      case w1_s1hKk of { :% ww1_s1hKo ww2_s1hKp ->
      case GHC.Real.$w^^%^^
             @ a_s1hKi w_s1hKj ww1_s1hKo ww2_s1hKp w2_s1hKl
      of
      { (# ww4_s1hMf, ww5_s1hMg #) ->
      GHC.Real.:% @ Integer ww4_s1hMf ww5_s1hMg
      }
      }

-- RHS size: {terms: 38, types: 28, coercions: 0, joins: 0/2}
^^ [InlPrag=INLINABLE[1]]
  :: forall a b. (Fractional a, Integral b) => a -> b -> a
[GblId,
 Arity=4,
 Str=<L,U(1*U(A,A,C(C1(U)),A,A,A,1*C1(U)),A,1*C1(U),A)><S(S(LS(LLLLLC(C(S))LL)L)LLLLLLLL),U(U(U(A,A,A,1*C1(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,1*C1(C1(U)),A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 30] 490 60
         Tmpl= \ (@ a_a1etv)
                 (@ b_a1etw)
                 ($dFractional_a1ety :: Fractional a_a1etv)
                 ($dIntegral_a1etz :: Integral b_a1etw) ->
                 let {
                   $dReal_a1eX1 :: Real b_a1etw
                   [LclId]
                   $dReal_a1eX1 = GHC.Real.$p1Integral @ b_a1etw $dIntegral_a1etz } in
                 let {
                   $dNum_a1eX3 :: Num b_a1etw
                   [LclId]
                   $dNum_a1eX3 = GHC.Real.$p1Real @ b_a1etw $dReal_a1eX1 } in
                 let {
                   $dOrd_a1etB [Occ=OnceL] :: Ord b_a1etw
                   [LclId]
                   $dOrd_a1etB = GHC.Real.$p2Real @ b_a1etw $dReal_a1eX1 } in
                 let {
                   $dNum1_a1eX0 [Occ=OnceL*] :: Num a_a1etv
                   [LclId]
                   $dNum1_a1eX0
                     = GHC.Real.$p1Fractional @ a_a1etv $dFractional_a1ety } in
                 \ (x_a1dQO [Occ=Once*] :: a_a1etv) (n_a1dQP :: b_a1etw) ->
                   case >=
                          @ b_a1etw $dOrd_a1etB n_a1dQP (fromInteger @ b_a1etw $dNum_a1eX3 0)
                   of {
                     False ->
                       recip
                         @ a_a1etv
                         $dFractional_a1ety
                         (^ @ a_a1etv
                            @ b_a1etw
                            $dNum1_a1eX0
                            $dIntegral_a1etz
                            x_a1dQO
                            (negate @ b_a1etw $dNum_a1eX3 n_a1dQP));
                     True ->
                       ^ @ a_a1etv @ b_a1etw $dNum1_a1eX0 $dIntegral_a1etz x_a1dQO n_a1dQP
                   }}]
^^
  = \ (@ a_a1etv)
      (@ b_a1etw)
      ($dFractional_a1ety :: Fractional a_a1etv)
      ($dIntegral_a1etz :: Integral b_a1etw)
      (eta_B2 :: a_a1etv)
      (eta1_B1 :: b_a1etw) ->
      let {
        $dReal_s1fRQ [Dmd=<S(LS(LLLLLC(C(S))LL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,A,A,A,1*C1(C1(U)),A,A),A)>]
          :: Real b_a1etw
        [LclId]
        $dReal_s1fRQ = GHC.Real.$p1Integral @ b_a1etw $dIntegral_a1etz } in
      let {
        $dNum_s1fRP [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>] :: Num b_a1etw
        [LclId]
        $dNum_s1fRP = GHC.Real.$p1Real @ b_a1etw $dReal_s1fRQ } in
      case >=
             @ b_a1etw
             (GHC.Real.$p2Real @ b_a1etw $dReal_s1fRQ)
             eta1_B1
             (fromInteger @ b_a1etw $dNum_s1fRP GHC.Real.even1)
      of {
        False ->
          recip
            @ a_a1etv
            $dFractional_a1ety
            (^ @ a_a1etv
               @ b_a1etw
               (GHC.Real.$p1Fractional @ a_a1etv $dFractional_a1ety)
               $dIntegral_a1etz
               eta_B2
               (negate @ b_a1etw $dNum_s1fRP eta1_B1));
        True ->
          ^ @ a_a1etv
            @ b_a1etw
            (GHC.Real.$p1Fractional @ a_a1etv $dFractional_a1ety)
            $dIntegral_a1etz
            eta_B2
            eta1_B1
      }


------ Local rules for imported ids --------
"SPEC $c== @ Integer"
    forall ($dEq_s1fY1 :: Eq Integer).
      GHC.Real.$fEqRatio_$c== @ Integer $dEq_s1fY1
      = GHC.Real.$fEqRatio_$s$c==
"SPEC $c/= @ Integer"
    forall ($dEq_s1fXZ :: Eq Integer).
      GHC.Real.$fEqRatio_$c/= @ Integer $dEq_s1fXZ
      = GHC.Real.$fOrdRatio_$s$c/=
"SPEC $fEqRatio @ Integer"
    forall ($dEq_s1fXX :: Eq Integer).
      GHC.Real.$fEqRatio @ Integer $dEq_s1fXX
      = GHC.Real.$fOrdRatio_$s$fEqRatio
"SPEC numericEnumFrom @ (Ratio Integer)"
    forall ($dFractional_s1fXs :: Fractional (Ratio Integer)).
      numericEnumFrom @ (Ratio Integer) $dFractional_s1fXs
      = GHC.Real.$fEnumRatio_$snumericEnumFrom
"SPEC numericEnumFromTo @ (Ratio Integer)"
    forall ($dFractional_s1fXi :: Fractional (Ratio Integer))
           ($dOrd_s1fXh :: Ord (Ratio Integer)).
      numericEnumFromTo @ (Ratio Integer) $dOrd_s1fXh $dFractional_s1fXi
      = GHC.Real.$fEnumRatio_$snumericEnumFromTo
"SPEC numericEnumFromThen @ (Ratio Integer)"
    forall ($dFractional_s1fX6 :: Fractional (Ratio Integer)).
      numericEnumFromThen @ (Ratio Integer) $dFractional_s1fX6
      = GHC.Real.$fEnumRatio_$snumericEnumFromThen
"SPEC numericEnumFromThenTo @ (Ratio Integer)"
    forall ($dFractional_s1fWS :: Fractional (Ratio Integer))
           ($dOrd_s1fWR :: Ord (Ratio Integer)).
      numericEnumFromThenTo @ (Ratio Integer)
                            $dOrd_s1fWR
                            $dFractional_s1fWS
      = GHC.Real.$fEnumRatio_$snumericEnumFromThenTo
"fromIntegral/Int->Int"
    forall ($dIntegral_a1eVv :: Integral Int) ($dNum_a1eVw :: Num Int).
      fromIntegral @ Int @ Int $dIntegral_a1eVv $dNum_a1eVw
      = id @ Int
"fromIntegral/Word->Word"
    forall ($dIntegral_a1eVa :: Integral Word)
           ($dNum_a1eVb :: Num Word).
      fromIntegral @ Word @ Word $dIntegral_a1eVa $dNum_a1eVb
      = id @ Word
"fromIntegral/Word->Int"
    forall ($dIntegral_a1eUZ :: Integral Word)
           ($dNum_a1eV0 :: Num Int).
      fromIntegral @ Word @ Int $dIntegral_a1eUZ $dNum_a1eV0
      = \ (ds_d1fnK :: Word) ->
          case ds_d1fnK of { W# x#_a1dRx ->
          GHC.Types.I# (word2Int# x#_a1dRx)
          }
"fromIntegral/Int->Word"
    forall ($dIntegral_a1eUO :: Integral Int)
           ($dNum_a1eUP :: Num Word).
      fromIntegral @ Int @ Word $dIntegral_a1eUO $dNum_a1eUP
      = \ (ds_d1fnG :: Int) ->
          case ds_d1fnG of { I# x#_a1dRw ->
          GHC.Types.W# (int2Word# x#_a1dRw)
          }
"SPEC $c<"
    forall ($dIntegral_a1eJ7 :: Integral Integer).
      GHC.Real.$fOrdRatio_$c< @ Integer $dIntegral_a1eJ7
      = GHC.Real.$fOrdRatio_$s$c<
"SPEC $c<="
    forall ($dIntegral_a1eJ7 :: Integral Integer).
      GHC.Real.$fOrdRatio_$c<= @ Integer $dIntegral_a1eJ7
      = GHC.Real.$fEnumRatio_$s$c<=
"SPEC $cmax"
    forall ($dIntegral_a1eJ7 :: Integral Integer).
      GHC.Real.$fOrdRatio_$cmax @ Integer $dIntegral_a1eJ7
      = GHC.Real.$fOrdRatio_$s$cmax
"SPEC $cmin"
    forall ($dIntegral_a1eJ7 :: Integral Integer).
      GHC.Real.$fOrdRatio_$cmin @ Integer $dIntegral_a1eJ7
      = GHC.Real.$fOrdRatio_$s$cmin
"SPEC $ccompare"
    forall ($dIntegral_a1eJ7 :: Integral Integer).
      GHC.Real.$fOrdRatio_$ccompare @ Integer $dIntegral_a1eJ7
      = GHC.Real.$fEnumRatio_$s$ccompare
"SPEC $c>"
    forall ($dIntegral_a1eJ7 :: Integral Integer).
      GHC.Real.$fOrdRatio_$c> @ Integer $dIntegral_a1eJ7
      = GHC.Real.$fOrdRatio_$s$c>
"SPEC $c>="
    forall ($dIntegral_a1eJ7 :: Integral Integer).
      GHC.Real.$fOrdRatio_$c>= @ Integer $dIntegral_a1eJ7
      = GHC.Real.$fEnumRatio_$s$c>=
"SPEC $fOrdRatio"
    forall ($dIntegral_a1eJ7 :: Integral Integer).
      GHC.Real.$fOrdRatio @ Integer $dIntegral_a1eJ7
      = GHC.Real.$fOrdRatio_$s$fOrdRatio
"SPEC $cnegate"
    forall ($dIntegral_a1eHR :: Integral Integer).
      GHC.Real.$fNumRatio_$cnegate @ Integer $dIntegral_a1eHR
      = GHC.Real.$fFractionalRatio_$s$cnegate
"SPEC $cabs"
    forall ($dIntegral_a1eHR :: Integral Integer).
      GHC.Real.$fNumRatio_$cabs @ Integer $dIntegral_a1eHR
      = GHC.Real.$fFractionalRatio_$s$cabs
"SPEC $csignum"
    forall ($dIntegral_a1eHR :: Integral Integer).
      GHC.Real.$fNumRatio_$csignum @ Integer $dIntegral_a1eHR
      = GHC.Real.$fFractionalRatio_$s$csignum
"SPEC $cfromInteger"
    forall ($dIntegral_a1eHR :: Integral Integer).
      GHC.Real.$fNumRatio_$cfromInteger @ Integer $dIntegral_a1eHR
      = GHC.Real.$fFractionalRatio_$s$cfromInteger
"SPEC $ctoRational"
    forall ($dIntegral_a1eHs :: Integral Integer).
      GHC.Real.$fRealRatio_$ctoRational @ Integer $dIntegral_a1eHs
      = GHC.Real.$fRealRatio_$s$ctoRational
"SPEC $crecip"
    forall ($dIntegral_a1eGD :: Integral Integer).
      GHC.Real.$fFractionalRatio_$crecip @ Integer $dIntegral_a1eGD
      = GHC.Real.$fFractionalRatio_$s$crecip
"SPEC $cproperFraction"
    forall ($dIntegral_a1eFh :: Integral Integer).
      GHC.Real.$fEnumRatio_$cproperFraction @ Integer $dIntegral_a1eFh
      = GHC.Real.$fEnumRatio_$s$cproperFraction
"SPEC reduce"
    forall ($dIntegral_a1ext :: Integral Integer).
      reduce @ Integer $dIntegral_a1ext
      = GHC.Real.reduce_$sreduce
"SPEC %"
    forall ($dIntegral_a1exQ :: Integral Integer).
      % @ Integer $dIntegral_a1exQ
      = GHC.Real.%_$s%
"SPEC $c/"
    forall ($dIntegral_a1eGD :: Integral Integer).
      GHC.Real.$fFractionalRatio_$c/ @ Integer $dIntegral_a1eGD
      = GHC.Real.$fFractionalRatio_$s$c/
"SPEC $cfromRational"
    forall ($dIntegral_a1eGD :: Integral Integer).
      GHC.Real.$fFractionalRatio_$cfromRational @ Integer
                                                $dIntegral_a1eGD
      = GHC.Real.$fFractionalRatio_$s$cfromRational
"SPEC $c+"
    forall ($dIntegral_a1eHR :: Integral Integer).
      GHC.Real.$fNumRatio_$c+ @ Integer $dIntegral_a1eHR
      = GHC.Real.$fEnumRatio_$s$c+
"SPEC $c-"
    forall ($dIntegral_a1eHR :: Integral Integer).
      GHC.Real.$fNumRatio_$c- @ Integer $dIntegral_a1eHR
      = GHC.Real.$fEnumRatio_$s$c-
"SPEC $c*"
    forall ($dIntegral_a1eHR :: Integral Integer).
      GHC.Real.$fNumRatio_$c* @ Integer $dIntegral_a1eHR
      = GHC.Real.$fFractionalRatio_$s$c*
"SPEC $fNumRatio"
    forall ($dIntegral_a1eHR :: Integral Integer).
      GHC.Real.$fNumRatio @ Integer $dIntegral_a1eHR
      = GHC.Real.$fFractionalRatio_$s$fNumRatio
"SPEC $csucc"
    forall ($dIntegral_a1eE5 :: Integral Integer).
      GHC.Real.$fEnumRatio_$csucc @ Integer $dIntegral_a1eE5
      = GHC.Real.$fEnumRatio_$s$csucc
"SPEC $cpred"
    forall ($dIntegral_a1eE5 :: Integral Integer).
      GHC.Real.$fEnumRatio_$cpred @ Integer $dIntegral_a1eE5
      = GHC.Real.$fEnumRatio_$s$cpred
"SPEC $fFractionalRatio"
    forall ($dIntegral_a1eGD :: Integral Integer).
      GHC.Real.$fFractionalRatio @ Integer $dIntegral_a1eGD
      = GHC.Real.$fFractionalRatio_$s$fFractionalRatio
"SPEC $cenumFrom"
    forall ($dIntegral_a1eE5 :: Integral Integer).
      GHC.Real.$fEnumRatio_$cenumFrom @ Integer $dIntegral_a1eE5
      = GHC.Real.$fEnumRatio_$snumericEnumFrom
"SPEC $cenumFromThen"
    forall ($dIntegral_a1eE5 :: Integral Integer).
      GHC.Real.$fEnumRatio_$cenumFromThen @ Integer $dIntegral_a1eE5
      = GHC.Real.$fEnumRatio_$snumericEnumFromThen
"SPEC $cenumFromTo"
    forall ($dIntegral_a1eE5 :: Integral Integer).
      GHC.Real.$fEnumRatio_$cenumFromTo @ Integer $dIntegral_a1eE5
      = GHC.Real.$fEnumRatio_$snumericEnumFromTo
"SPEC $cenumFromThenTo"
    forall ($dIntegral_a1eE5 :: Integral Integer).
      GHC.Real.$fEnumRatio_$cenumFromThenTo @ Integer $dIntegral_a1eE5
      = GHC.Real.$fEnumRatio_$snumericEnumFromThenTo
"SPEC $fRealRatio"
    forall ($dIntegral_a1eHs :: Integral Integer).
      GHC.Real.$fRealRatio @ Integer $dIntegral_a1eHs
      = GHC.Real.$fRealFracRatio_$s$fRealRatio
"SPEC $cceiling"
    forall ($dIntegral_a1eFh :: Integral Integer).
      GHC.Real.$fRealFracRatio_$cceiling @ Integer $dIntegral_a1eFh
      = GHC.Real.$fRealFracRatio_$s$cceiling
"SPEC $cfloor"
    forall ($dIntegral_a1eFh :: Integral Integer).
      GHC.Real.$fRealFracRatio_$cfloor @ Integer $dIntegral_a1eFh
      = GHC.Real.$fRealFracRatio_$s$cfloor
"SPEC $cround"
    forall ($dIntegral_a1eFh :: Integral Integer).
      GHC.Real.$fRealFracRatio_$cround @ Integer $dIntegral_a1eFh
      = GHC.Real.$fRealFracRatio_$s$cround
"SPEC $ctruncate @ Integer"
    forall ($dIntegral_s1fT9 :: Integral Integer).
      GHC.Real.$fRealFracRatio_$ctruncate @ Integer $dIntegral_s1fT9
      = GHC.Real.$fRealFracRatio_$s$ctruncate
"SPEC $fRealFracRatio"
    forall ($dIntegral_a1eFh :: Integral Integer).
      GHC.Real.$fRealFracRatio @ Integer $dIntegral_a1eFh
      = GHC.Real.$fRealFracRatio_$s$fRealFracRatio
"SPEC $cfromEnum"
    forall ($dIntegral_a1eE5 :: Integral Integer).
      GHC.Real.$fEnumRatio_$cfromEnum @ Integer $dIntegral_a1eE5
      = GHC.Real.$fEnumRatio_$s$cfromEnum
"SPEC $cshowsPrec"
    forall ($dShow_a1ePq :: Show Integer).
      GHC.Real.$fShowRatio_$cshowsPrec @ Integer $dShow_a1ePq
      = GHC.Real.$fShowRatio_$s$cshowsPrec
"SPEC $cshowList"
    forall ($dShow_a1ePq :: Show Integer).
      GHC.Real.$fShowRatio_$cshowList @ Integer $dShow_a1ePq
      = GHC.Real.$fShowRatio_$s$cshowList
"SPEC $cshow"
    forall ($dShow_a1ePq :: Show Integer).
      GHC.Real.$fShowRatio_$cshow @ Integer $dShow_a1ePq
      = GHC.Real.$fShowRatio_$s$cshow
"SPEC $fShowRatio"
    forall ($dShow_a1ePq :: Show Integer).
      GHC.Real.$fShowRatio @ Integer $dShow_a1ePq
      = GHC.Real.$fShowRatio_$s$fShowRatio
"SPEC lcm" [1]
    forall ($dIntegral_X1et8 :: Integral Int).
      lcm @ Int $dIntegral_X1et8
      = GHC.Real.lcm_$slcm1
"SPEC lcm" [1]
    forall ($dIntegral_X1etj :: Integral Word).
      lcm @ Word $dIntegral_X1etj
      = GHC.Real.lcm_$slcm
"SPEC $ctoEnum"
    forall ($dIntegral_a1eE5 :: Integral Integer).
      GHC.Real.$fEnumRatio_$ctoEnum @ Integer $dIntegral_a1eE5
      = GHC.Real.$fEnumRatio_$ctoRational
"SPEC $fEnumRatio"
    forall ($dIntegral_a1eE5 :: Integral Integer).
      GHC.Real.$fEnumRatio @ Integer $dIntegral_a1eE5
      = GHC.Real.$fEnumRatio_$s$fEnumRatio
"^5/Integer"
    forall (@ a_a1eUt)
           ($dNum_a1eUe :: Num a_a1eUt)
           ($dIntegral_a1eUf :: Integral Integer)
           (x_a1dRu :: a_a1eUt).
      ^ @ a_a1eUt @ Integer $dNum_a1eUe $dIntegral_a1eUf x_a1dRu 5
      = * @ a_a1eUt
          $dNum_a1eUe
          (* @ a_a1eUt
             $dNum_a1eUe
             (* @ a_a1eUt
                $dNum_a1eUe
                (* @ a_a1eUt $dNum_a1eUe x_a1dRu x_a1dRu)
                x_a1dRu)
             x_a1dRu)
          x_a1dRu
"^4/Integer"
    forall (@ a_a1eTV)
           ($dNum_a1eTG :: Num a_a1eTV)
           ($dIntegral_a1eTH :: Integral Integer)
           (x_a1dRs :: a_a1eTV).
      ^ @ a_a1eTV @ Integer $dNum_a1eTG $dIntegral_a1eTH x_a1dRs 4
      = * @ a_a1eTV
          $dNum_a1eTG
          (* @ a_a1eTV
             $dNum_a1eTG
             (* @ a_a1eTV $dNum_a1eTG x_a1dRs x_a1dRs)
             x_a1dRs)
          x_a1dRs
"^3/Integer"
    forall (@ a_a1eTq)
           ($dNum_a1eTb :: Num a_a1eTq)
           ($dIntegral_a1eTc :: Integral Integer)
           (x_a1dRq :: a_a1eTq).
      ^ @ a_a1eTq @ Integer $dNum_a1eTb $dIntegral_a1eTc x_a1dRq 3
      = * @ a_a1eTq
          $dNum_a1eTb
          (* @ a_a1eTq $dNum_a1eTb x_a1dRq x_a1dRq)
          x_a1dRq
"^2/Integer"
    forall (@ a_a1eSY)
           ($dNum_a1eSJ :: Num a_a1eSY)
           ($dIntegral_a1eSK :: Integral Integer)
           (x_a1dRo :: a_a1eSY).
      ^ @ a_a1eSY @ Integer $dNum_a1eSJ $dIntegral_a1eSK x_a1dRo 2
      = * @ a_a1eSY $dNum_a1eSJ x_a1dRo x_a1dRo
"^5/Int"
    forall (@ a_a1eSn)
           ($dNum_a1eS8 :: Num a_a1eSn)
           ($dIntegral_a1eS9 :: Integral Int)
           (x_a1dRm :: a_a1eSn).
      ^ @ a_a1eSn
        @ Int
        $dNum_a1eS8
        $dIntegral_a1eS9
        x_a1dRm
        (GHC.Types.I# 5#)
      = * @ a_a1eSn
          $dNum_a1eS8
          (* @ a_a1eSn
             $dNum_a1eS8
             (* @ a_a1eSn
                $dNum_a1eS8
                (* @ a_a1eSn $dNum_a1eS8 x_a1dRm x_a1dRm)
                x_a1dRm)
             x_a1dRm)
          x_a1dRm
"^4/Int"
    forall (@ a_a1eRP)
           ($dNum_a1eRA :: Num a_a1eRP)
           ($dIntegral_a1eRB :: Integral Int)
           (x_a1dRk :: a_a1eRP).
      ^ @ a_a1eRP
        @ Int
        $dNum_a1eRA
        $dIntegral_a1eRB
        x_a1dRk
        (GHC.Types.I# 4#)
      = * @ a_a1eRP
          $dNum_a1eRA
          (* @ a_a1eRP
             $dNum_a1eRA
             (* @ a_a1eRP $dNum_a1eRA x_a1dRk x_a1dRk)
             x_a1dRk)
          x_a1dRk
"^3/Int"
    forall (@ a_a1eRk)
           ($dNum_a1eR5 :: Num a_a1eRk)
           ($dIntegral_a1eR6 :: Integral Int)
           (x_a1dRi :: a_a1eRk).
      ^ @ a_a1eRk
        @ Int
        $dNum_a1eR5
        $dIntegral_a1eR6
        x_a1dRi
        (GHC.Types.I# 3#)
      = * @ a_a1eRk
          $dNum_a1eR5
          (* @ a_a1eRk $dNum_a1eR5 x_a1dRi x_a1dRi)
          x_a1dRi
"^2/Int"
    forall (@ a_a1eQS)
           ($dNum_a1eQD :: Num a_a1eQS)
           ($dIntegral_a1eQE :: Integral Int)
           (x_a1dRg :: a_a1eQS).
      ^ @ a_a1eQS
        @ Int
        $dNum_a1eQD
        $dIntegral_a1eQE
        x_a1dRg
        (GHC.Types.I# 2#)
      = * @ a_a1eQS $dNum_a1eQD x_a1dRg x_a1dRg
"(^)/Rational"
    forall (@ a_a1eQp)
           ($dNum_a1eQn :: Num Rational)
           ($dIntegral_a1eQo :: Integral a_a1eQp).
      ^ @ Rational @ a_a1eQp $dNum_a1eQn $dIntegral_a1eQo
      = ^%^ @ a_a1eQp $dIntegral_a1eQo
"SPEC ^" [1]
    forall ($dIntegral_a1et4 :: Integral Int) ($dNum_a1et3 :: Num Int).
      ^ @ Int @ Int $dNum_a1et3 $dIntegral_a1et4
      = GHC.Real.^_$s^2
"SPEC ^" [1]
    forall ($dIntegral_a1eth :: Integral Int)
           ($dNum_a1etg :: Num Integer).
      ^ @ Integer @ Int $dNum_a1etg $dIntegral_a1eth
      = GHC.Real.^_$s^1
"SPEC ^" [1]
    forall ($dIntegral_a1etu :: Integral Integer)
           ($dNum_a1ett :: Num Integer).
      ^ @ Integer @ Integer $dNum_a1ett $dIntegral_a1etu
      = GHC.Real.^_$s^
"(^^)/Rational"
    forall (@ a_a1eQa)
           ($dFractional_a1eQ8 :: Fractional Rational)
           ($dIntegral_a1eQ9 :: Integral a_a1eQa).
      ^^ @ Rational @ a_a1eQa $dFractional_a1eQ8 $dIntegral_a1eQ9
      = ^^%^^ @ a_a1eQa $dIntegral_a1eQ9
"fromRational/id"
    forall ($dFractional_a1eVN :: Fractional Rational).
      fromRational @ Rational $dFractional_a1eVN
      = id @ Rational

