
==================== Pre unarise: ====================
2018-03-16 15:54:40.03672939 UTC

GHC.Err.error
  :: forall (a :: TYPE r).
     GHC.Stack.Types.HasCallStack =>
     [GHC.Types.Char] -> a
[GblId, Arity=2, Str=<B,U><B,U>x, Unf=OtherCon []] =
    [] \r [$dIP_s2Tj s_s2Tk]
        let {
          sat_s2Tl [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [$dIP_s2Tj s_s2Tk] \u []
                  GHC.Exception.errorCallWithCallStackException s_s2Tk $dIP_s2Tj;
        } in  raise# [sat_s2Tl];

lvl_r2T3 :: GHC.Stack.Types.CallStack
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.FreezeCallStack! [GHC.Stack.Types.EmptyCallStack];

GHC.Err.errorWithoutStackTrace
  :: forall (a :: TYPE r). [GHC.Types.Char] -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [s_s2Tm]
        let {
          sat_s2Tn [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [s_s2Tm] \u []
                  GHC.Exception.errorCallWithCallStackException s_s2Tm lvl_r2T3;
        } in  raise# [sat_s2Tn];

lvl1_r2T4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Oops! The program has entered an `absent' argument!\n"#;

lvl2_r2T5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl1_r2T4;

GHC.Err.absentErr :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace lvl2_r2T5;

lvl3_r2T6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Prelude.undefined"#;

lvl4_r2T7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl3_r2T6;

lvl5_r2T8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

lvl6_r2T9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl5_r2T8;

GHC.Err.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl7_r2Ta :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Err.$trModule4;

GHC.Err.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Err"#;

lvl8_r2Tb :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Err.$trModule2;

lvl9_r2Tc :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./GHC/Err.hs"#;

lvl10_r2Td :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl9_r2Tc;

lvl11_r2Te :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [79#];

lvl12_r2Tf :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [14#];

lvl13_r2Tg :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [39#];

lvl14_r2Th :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl7_r2Ta
                                           lvl8_r2Tb
                                           lvl10_r2Td
                                           lvl11_r2Te
                                           lvl12_r2Tf
                                           lvl11_r2Te
                                           lvl13_r2Tg];

GHC.Err.undefined
  :: forall (a :: TYPE r). GHC.Stack.Types.HasCallStack => a
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []] =
    [] \r [$dIP_s2To]
        let {
          sat_s2Ts [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [$dIP_s2To] \u []
                  let {
                    sat_s2Tr [Occ=Once] :: GHC.Stack.Types.CallStack
                    [LclId] =
                        [$dIP_s2To] \u []
                            case $dIP_s2To of wild1_s2Tp {
                              __DEFAULT ->
                                  GHC.Stack.Types.PushCallStack [lvl6_r2T9 lvl14_r2Th wild1_s2Tp];
                              GHC.Stack.Types.FreezeCallStack _ [Occ=Dead] -> wild1_s2Tp;
                            };
                  } in 
                    GHC.Exception.errorCallWithCallStackException lvl4_r2T7 sat_s2Tr;
        } in  raise# [sat_s2Ts];

GHC.Err.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Err.$trModule4];

GHC.Err.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Err.$trModule2];

GHC.Err.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Err.$trModule3
                                     GHC.Err.$trModule1];


==================== STG syntax: ====================
2018-03-16 15:54:40.039491885 UTC

GHC.Err.error
  :: forall (a :: TYPE r).
     GHC.Stack.Types.HasCallStack =>
     [GHC.Types.Char] -> a
[GblId, Arity=2, Str=<B,U><B,U>x, Unf=OtherCon []] =
    [] \r [$dIP_s2Tj s_s2Tk]
        let {
          sat_s2Tl [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [$dIP_s2Tj s_s2Tk] \u []
                  GHC.Exception.errorCallWithCallStackException s_s2Tk $dIP_s2Tj;
        } in  raise# [sat_s2Tl];

lvl_r2T3 :: GHC.Stack.Types.CallStack
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.FreezeCallStack! [GHC.Stack.Types.EmptyCallStack];

GHC.Err.errorWithoutStackTrace
  :: forall (a :: TYPE r). [GHC.Types.Char] -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [s_s2Tm]
        let {
          sat_s2Tn [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [s_s2Tm] \u []
                  GHC.Exception.errorCallWithCallStackException s_s2Tm lvl_r2T3;
        } in  raise# [sat_s2Tn];

lvl1_r2T4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Oops! The program has entered an `absent' argument!\n"#;

lvl2_r2T5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl1_r2T4;

GHC.Err.absentErr :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace lvl2_r2T5;

lvl3_r2T6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Prelude.undefined"#;

lvl4_r2T7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl3_r2T6;

lvl5_r2T8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

lvl6_r2T9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl5_r2T8;

GHC.Err.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl7_r2Ta :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Err.$trModule4;

GHC.Err.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Err"#;

lvl8_r2Tb :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Err.$trModule2;

lvl9_r2Tc :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./GHC/Err.hs"#;

lvl10_r2Td :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl9_r2Tc;

lvl11_r2Te :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [79#];

lvl12_r2Tf :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [14#];

lvl13_r2Tg :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [39#];

lvl14_r2Th :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl7_r2Ta
                                           lvl8_r2Tb
                                           lvl10_r2Td
                                           lvl11_r2Te
                                           lvl12_r2Tf
                                           lvl11_r2Te
                                           lvl13_r2Tg];

GHC.Err.undefined
  :: forall (a :: TYPE r). GHC.Stack.Types.HasCallStack => a
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []] =
    [] \r [$dIP_s2To]
        let {
          sat_s2Ts [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [$dIP_s2To] \u []
                  let {
                    sat_s2Tr [Occ=Once] :: GHC.Stack.Types.CallStack
                    [LclId] =
                        [$dIP_s2To] \u []
                            case $dIP_s2To of wild1_s2Tp {
                              __DEFAULT ->
                                  GHC.Stack.Types.PushCallStack [lvl6_r2T9 lvl14_r2Th wild1_s2Tp];
                              GHC.Stack.Types.FreezeCallStack _ [Occ=Dead] -> wild1_s2Tp;
                            };
                  } in 
                    GHC.Exception.errorCallWithCallStackException lvl4_r2T7 sat_s2Tr;
        } in  raise# [sat_s2Ts];

GHC.Err.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Err.$trModule4];

GHC.Err.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Err.$trModule2];

GHC.Err.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Err.$trModule3
                                     GHC.Err.$trModule1];


==================== Pre unarise: ====================
2018-03-16 15:54:40.290119086 UTC

GHC.Err.error
  :: forall (a :: TYPE r).
     GHC.Stack.Types.HasCallStack =>
     [GHC.Types.Char] -> a
[GblId, Arity=2, Str=<B,U><B,U>x, Unf=OtherCon []] =
    [] \r [$dIP_s31K s_s31L]
        let {
          sat_s31M [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [$dIP_s31K s_s31L] \u []
                  GHC.Exception.errorCallWithCallStackException s_s31L $dIP_s31K;
        } in  raise# [sat_s31M];

lvl_r2T3 :: GHC.Stack.Types.CallStack
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.FreezeCallStack! [GHC.Stack.Types.EmptyCallStack];

GHC.Err.errorWithoutStackTrace
  :: forall (a :: TYPE r). [GHC.Types.Char] -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [s_s31N]
        let {
          sat_s31O [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [s_s31N] \u []
                  GHC.Exception.errorCallWithCallStackException s_s31N lvl_r2T3;
        } in  raise# [sat_s31O];

lvl1_r2T4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Oops! The program has entered an `absent' argument!\n"#;

lvl2_r2T5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl1_r2T4;

GHC.Err.absentErr :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace lvl2_r2T5;

lvl3_r2T6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Prelude.undefined"#;

lvl4_r2T7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl3_r2T6;

lvl5_r2T8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

lvl6_r2T9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl5_r2T8;

GHC.Err.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl7_r2Ta :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Err.$trModule4;

GHC.Err.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Err"#;

lvl8_r2Tb :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Err.$trModule2;

lvl9_r2Tc :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./GHC/Err.hs"#;

lvl10_r2Td :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl9_r2Tc;

lvl11_r2Te :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [79#];

lvl12_r2Tf :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [14#];

lvl13_r2Tg :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [39#];

lvl14_r2Th :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl7_r2Ta
                                           lvl8_r2Tb
                                           lvl10_r2Td
                                           lvl11_r2Te
                                           lvl12_r2Tf
                                           lvl11_r2Te
                                           lvl13_r2Tg];

GHC.Err.undefined
  :: forall (a :: TYPE r). GHC.Stack.Types.HasCallStack => a
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []] =
    [] \r [$dIP_s31P]
        let {
          sat_s31T [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [$dIP_s31P] \u []
                  let {
                    sat_s31S [Occ=Once] :: GHC.Stack.Types.CallStack
                    [LclId] =
                        [$dIP_s31P] \u []
                            case $dIP_s31P of wild1_s31Q {
                              __DEFAULT ->
                                  GHC.Stack.Types.PushCallStack [lvl6_r2T9 lvl14_r2Th wild1_s31Q];
                              GHC.Stack.Types.FreezeCallStack _ [Occ=Dead] -> wild1_s31Q;
                            };
                  } in 
                    GHC.Exception.errorCallWithCallStackException lvl4_r2T7 sat_s31S;
        } in  raise# [sat_s31T];

GHC.Err.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Err.$trModule4];

GHC.Err.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Err.$trModule2];

GHC.Err.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Err.$trModule3
                                     GHC.Err.$trModule1];


==================== STG syntax: ====================
2018-03-16 15:54:40.294918823 UTC

GHC.Err.error
  :: forall (a :: TYPE r).
     GHC.Stack.Types.HasCallStack =>
     [GHC.Types.Char] -> a
[GblId, Arity=2, Str=<B,U><B,U>x, Unf=OtherCon []] =
    [] \r [$dIP_s31K s_s31L]
        let {
          sat_s31M [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [$dIP_s31K s_s31L] \u []
                  GHC.Exception.errorCallWithCallStackException s_s31L $dIP_s31K;
        } in  raise# [sat_s31M];

lvl_r2T3 :: GHC.Stack.Types.CallStack
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.FreezeCallStack! [GHC.Stack.Types.EmptyCallStack];

GHC.Err.errorWithoutStackTrace
  :: forall (a :: TYPE r). [GHC.Types.Char] -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [s_s31N]
        let {
          sat_s31O [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [s_s31N] \u []
                  GHC.Exception.errorCallWithCallStackException s_s31N lvl_r2T3;
        } in  raise# [sat_s31O];

lvl1_r2T4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Oops! The program has entered an `absent' argument!\n"#;

lvl2_r2T5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl1_r2T4;

GHC.Err.absentErr :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace lvl2_r2T5;

lvl3_r2T6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Prelude.undefined"#;

lvl4_r2T7 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl3_r2T6;

lvl5_r2T8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

lvl6_r2T9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl5_r2T8;

GHC.Err.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl7_r2Ta :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Err.$trModule4;

GHC.Err.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Err"#;

lvl8_r2Tb :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Err.$trModule2;

lvl9_r2Tc :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./GHC/Err.hs"#;

lvl10_r2Td :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl9_r2Tc;

lvl11_r2Te :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [79#];

lvl12_r2Tf :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [14#];

lvl13_r2Tg :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [39#];

lvl14_r2Th :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl7_r2Ta
                                           lvl8_r2Tb
                                           lvl10_r2Td
                                           lvl11_r2Te
                                           lvl12_r2Tf
                                           lvl11_r2Te
                                           lvl13_r2Tg];

GHC.Err.undefined
  :: forall (a :: TYPE r). GHC.Stack.Types.HasCallStack => a
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []] =
    [] \r [$dIP_s31P]
        let {
          sat_s31T [Occ=Once] :: GHC.Exception.SomeException
          [LclId] =
              [$dIP_s31P] \u []
                  let {
                    sat_s31S [Occ=Once] :: GHC.Stack.Types.CallStack
                    [LclId] =
                        [$dIP_s31P] \u []
                            case $dIP_s31P of wild1_s31Q {
                              __DEFAULT ->
                                  GHC.Stack.Types.PushCallStack [lvl6_r2T9 lvl14_r2Th wild1_s31Q];
                              GHC.Stack.Types.FreezeCallStack _ [Occ=Dead] -> wild1_s31Q;
                            };
                  } in 
                    GHC.Exception.errorCallWithCallStackException lvl4_r2T7 sat_s31S;
        } in  raise# [sat_s31T];

GHC.Err.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Err.$trModule4];

GHC.Err.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Err.$trModule2];

GHC.Err.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Err.$trModule3
                                     GHC.Err.$trModule1];

