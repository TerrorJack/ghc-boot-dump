
==================== Raw Cmm ====================
2018-03-16 15:59:00.391443619 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:59:00.392565189 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr4_closure" {
     GHC.Ptr.$fShowFunPtr4_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.394376435 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr3_closure" {
     GHC.Ptr.$fShowFunPtr3_closure:
         const GHC.Types.C#_con_info;
         const 120;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.400977262 UTC

[section ""data" . GHC.Ptr.$w$cshowsPrec_closure" {
     GHC.Ptr.$w$cshowsPrec_closure:
         const GHC.Ptr.$w$cshowsPrec_info;
         const 0;
 },
 sat_s47xV_entry() //  [R1]
         { []
         }
     {offset
       c483C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c483D; else goto c483E;
       c483D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c483E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s47xV_info" {
     sat_s47xV_info:
         const sat_s47xV_entry;
         const 4294967296;
         const 17;
 },
 ls_s47xS_entry() //  [R1]
         { []
         }
     {offset
       c483H: // global
           _s47xS::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c483I; else goto c483J;
       c483J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c483L; else goto c483K;
       c483L: // global
           HpAlloc = 24;
           goto c483I;
       c483I: // global
           R1 = _s47xS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c483K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s47xS::P64;
           _s47xQ::I64 = I64[_s47xS::P64 + 16];
           I64[Hp - 16] = sat_s47xV_info;
           I64[Hp] = _s47xQ::I64;
           R6 = Hp - 16;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Numeric.showHex1_closure;
           R3 = GHC.Show.$fShowInteger_closure;
           R2 = GHC.Real.$fIntegralInteger_closure;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 32, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ls_s47xS_info" {
     ls_s47xS_info:
         const ls_s47xS_entry;
         const 4294967296;
         const 133143986193;
         const S47CQ_srt;
 },
 n_s47xZ_entry() //  [R1]
         { []
         }
     {offset
       c4845: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4846; else goto c4847;
       c4846: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4847: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . n_s47xZ_info" {
     n_s47xZ_info:
         const n_s47xZ_entry;
         const 2;
         const 18;
 },
 sat_s47y5_entry() //  [R1]
         { []
         }
     {offset
       c484m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c484n; else goto c484o;
       c484n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c484o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_s47y1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s47y5_info" {
     sat_s47y5_info:
         const sat_s47y5_entry;
         const 4294967297;
         const 19;
 },
 $wxs_s47y1_entry() //  [R1, R2]
         { []
         }
     {offset
       c484s: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c484w; else goto c484v;
       c484w: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c484v: // global
           if (R2 == 1) goto c484r; else goto c484q;
       c484r: // global
           _s47y0::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _s47y0::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c484q: // global
           I64[Hp - 48] = sat_s47y5_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wxs_s47y1_info" {
     $wxs_s47y1_info:
         const $wxs_s47y1_entry;
         const 1;
         const 9;
         const 4294967300;
 },
 sat_s47y6_entry() //  [R1]
         { []
         }
     {offset
       c484y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c484z; else goto c484A;
       c484z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c484A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c483Q_info;
           R3 = 0;
           _s47xS::P64 = P64[R1 + 24];
           R2 = _s47xS::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s47xS::P64;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s47y6_info" {
     sat_s47y6_info:
         const sat_s47y6_entry;
         const 2;
         const 18;
 },
 _c483Q() //  [R1]
         { []
         }
     {offset
       c483Q: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c484D; else goto c484C;
       c484D: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c484C: // global
           _s47xR::P64 = P64[Sp + 8];
           _s47xS::P64 = P64[Sp + 16];
           _s47xX::I64 = 16 - R1;
           if (%MO_S_Ge_W64(0, _s47xX::I64)) goto c484F; else goto c484G;
       c484F: // global
           Hp = Hp - 72;
           R3 = _s47xR::P64;
           R2 = _s47xS::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c484G: // global
           I64[Hp - 64] = n_s47xZ_info;
           P64[Hp - 48] = _s47xR::P64;
           P64[Hp - 40] = _s47xS::P64;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp - 16] = Hp - 64;
           I64[Hp - 8] = $wxs_s47y1_info;
           P64[Hp] = Hp - 30;
           R2 = _s47xX::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call $wxs_s47y1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c483Q_info" {
     block_c483Q_info:
         const _c483Q;
         const 2;
         const 30;
 },
 GHC.Ptr.$w$cshowsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c484I: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c484M; else goto c484L;
       c484M: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c484L: // global
           I64[Hp - 72] = ls_s47xS_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s47y6_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr3_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = GHC.Ptr.$fShowFunPtr4_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$w$cshowsPrec_info" {
     GHC.Ptr.$w$cshowsPrec_info:
         const GHC.Ptr.$w$cshowsPrec_entry;
         const 0;
         const 270582939662;
         const 8589934605;
         const S47CQ_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.418926251 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c485z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c485F; else goto c485G;
       c485F: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c485G: // global
           I64[Sp - 16] = block_c485w_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u485L; else goto c485x;
       u485L: // global
           call _c485w(R1) args: 0, res: 0, upd: 0;
       c485x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowFunPtr_$cshowsPrec_info" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec_info:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S47CQ_srt+40;
 },
 _c485w() //  [R1]
         { []
         }
     {offset
       c485w: // global
           _s47ya::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c485C_info;
           R3 = _s47ya::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c485w_info" {
     block_c485w_info:
         const _c485w;
         const 1;
         const 4294967326;
         const S47CQ_srt+40;
 },
 _c485C() //  [R1, R2]
         { []
         }
     {offset
       c485C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c485K; else goto c485J;
       c485K: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c485J: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c485C_info" {
     block_c485C_info:
         const _c485C;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.425982262 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr2_closure" {
     GHC.Ptr.$fShowFunPtr2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.429059656 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshow_closure" {
     GHC.Ptr.$fShowPtr_$cshow_closure:
         const GHC.Ptr.$fShowPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c4867: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c486d; else goto c486e;
       c486d: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c486e: // global
           I64[Sp - 8] = block_c4864_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u486j; else goto c4865;
       u486j: // global
           call _c4864(R1) args: 0, res: 0, upd: 0;
       c4865: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowPtr_$cshow_info" {
     GHC.Ptr.$fShowPtr_$cshow_info:
         const GHC.Ptr.$fShowPtr_$cshow_entry;
         const 0;
         const 21474836494;
         const 4294967301;
         const S47CQ_srt+40;
 },
 _c4864() //  [R1]
         { []
         }
     {offset
       c4864: // global
           I64[Sp] = block_c486a_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c4864_info" {
     block_c4864_info:
         const _c4864;
         const 0;
         const 4294967326;
         const S47CQ_srt+40;
 },
 _c486a() //  [R1, R2]
         { []
         }
     {offset
       c486a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c486i; else goto c486h;
       c486i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c486h: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c486a_info" {
     block_c486a_info:
         const _c486a;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.436720409 UTC

[section ""data" . GHC.Ptr.$fShowPtr1_closure" {
     GHC.Ptr.$fShowPtr1_closure:
         const GHC.Ptr.$fShowPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr1_entry() //  [R2, R3]
         { []
         }
     {offset
       c486E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c486K; else goto c486L;
       c486K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c486L: // global
           I64[Sp - 16] = block_c486B_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u486Q; else goto c486C;
       u486Q: // global
           call _c486B(R1) args: 0, res: 0, upd: 0;
       c486C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowPtr1_info" {
     GHC.Ptr.$fShowPtr1_info:
         const GHC.Ptr.$fShowPtr1_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const S47CQ_srt+40;
 },
 _c486B() //  [R1]
         { []
         }
     {offset
       c486B: // global
           _s47yn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c486H_info;
           R3 = _s47yn::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c486B_info" {
     block_c486B_info:
         const _c486B;
         const 1;
         const 4294967326;
         const S47CQ_srt+40;
 },
 _c486H() //  [R1, R2]
         { []
         }
     {offset
       c486H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c486P; else goto c486O;
       c486P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c486O: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c486H_info" {
     block_c486H_info:
         const _c486H;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.444559796 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshowList_closure" {
     GHC.Ptr.$fShowPtr_$cshowList_closure:
         const GHC.Ptr.$fShowPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c4878: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowPtr_$cshowList_info" {
     GHC.Ptr.$fShowPtr_$cshowList_info:
         const GHC.Ptr.$fShowPtr_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S47CQ_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.447751855 UTC

[section ""data" . GHC.Ptr.$fShowPtr_closure" {
     GHC.Ptr.$fShowPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure+3;
         const GHC.Ptr.$fShowPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.450560896 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<_entry() //  [R2, R3]
         { []
         }
     {offset
       c487n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c487r; else goto c487s;
       c487r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c487s: // global
           I64[Sp - 16] = block_c487k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u487B; else goto c487l;
       u487B: // global
           call _c487k(R1) args: 0, res: 0, upd: 0;
       c487l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$c<_info" {
     GHC.Ptr.$fOrdFunPtr_$c<_info:
         const GHC.Ptr.$fOrdFunPtr_$c<_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c487k() //  [R1]
         { []
         }
     {offset
       c487k: // global
           I64[Sp] = block_c487q_info;
           _s47yy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yy::I64;
           if (R1 & 7 != 0) goto u487A; else goto c487u;
       u487A: // global
           call _c487q(R1) args: 0, res: 0, upd: 0;
       c487u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c487k_info" {
     block_c487k_info:
         const _c487k;
         const 1;
         const 30;
 },
 _c487q() //  [R1]
         { []
         }
     {offset
       c487q: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c487q_info" {
     block_c487q_info:
         const _c487q;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.458627246 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdFunPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdFunPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdFunPtr_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c4880: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4884; else goto c4885;
       c4884: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4885: // global
           I64[Sp - 16] = block_c487X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u488o; else goto c487Y;
       u488o: // global
           call _c487X(R1) args: 0, res: 0, upd: 0;
       c487Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$ccompare_info" {
     GHC.Ptr.$fOrdFunPtr_$ccompare_info:
         const GHC.Ptr.$fOrdFunPtr_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c487X() //  [R1]
         { []
         }
     {offset
       c487X: // global
           I64[Sp] = block_c4883_info;
           _s47yF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yF::I64;
           if (R1 & 7 != 0) goto u488n; else goto c4887;
       u488n: // global
           call _c4883(R1) args: 0, res: 0, upd: 0;
       c4887: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c487X_info" {
     block_c487X_info:
         const _c487X;
         const 1;
         const 30;
 },
 _c4883() //  [R1]
         { []
         }
     {offset
       c4883: // global
           _s47yF::I64 = I64[Sp + 8];
           _s47yH::I64 = I64[R1 + 7];
           if (_s47yF::I64 >= _s47yH::I64) goto c488l; else goto c488m;
       c488l: // global
           if (_s47yF::I64 == _s47yH::I64) goto c488j; else goto c488i;
       c488j: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c488i: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c488m: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c4883_info" {
     block_c4883_info:
         const _c4883;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.466757609 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c==_closure" {
     GHC.Ptr.$fEqFunPtr_$c==_closure:
         const GHC.Ptr.$fEqFunPtr_$c==_info;
 },
 GHC.Ptr.$fEqFunPtr_$c==_entry() //  [R2, R3]
         { []
         }
     {offset
       c488M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c488Q; else goto c488R;
       c488Q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c488R: // global
           I64[Sp - 16] = block_c488J_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4890; else goto c488K;
       u4890: // global
           call _c488J(R1) args: 0, res: 0, upd: 0;
       c488K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fEqFunPtr_$c==_info" {
     GHC.Ptr.$fEqFunPtr_$c==_info:
         const GHC.Ptr.$fEqFunPtr_$c==_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c488J() //  [R1]
         { []
         }
     {offset
       c488J: // global
           I64[Sp] = block_c488P_info;
           _s47yN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yN::I64;
           if (R1 & 7 != 0) goto u488Z; else goto c488T;
       u488Z: // global
           call _c488P(R1) args: 0, res: 0, upd: 0;
       c488T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c488J_info" {
     block_c488J_info:
         const _c488J;
         const 1;
         const 30;
 },
 _c488P() //  [R1]
         { []
         }
     {offset
       c488P: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c488P_info" {
     block_c488P_info:
         const _c488P;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.474365112 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c/=_closure" {
     GHC.Ptr.$fEqFunPtr_$c/=_closure:
         const GHC.Ptr.$fEqFunPtr_$c/=_info;
 },
 GHC.Ptr.$fEqFunPtr_$c/=_entry() //  [R2, R3]
         { []
         }
     {offset
       c489p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c489t; else goto c489u;
       c489t: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c489u: // global
           I64[Sp - 16] = block_c489m_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u489H; else goto c489n;
       u489H: // global
           call _c489m(R1) args: 0, res: 0, upd: 0;
       c489n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fEqFunPtr_$c/=_info" {
     GHC.Ptr.$fEqFunPtr_$c/=_info:
         const GHC.Ptr.$fEqFunPtr_$c/=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c489m() //  [R1]
         { []
         }
     {offset
       c489m: // global
           I64[Sp] = block_c489s_info;
           _s47yU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yU::I64;
           if (R1 & 7 != 0) goto u489G; else goto c489w;
       u489G: // global
           call _c489s(R1) args: 0, res: 0, upd: 0;
       c489w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c489m_info" {
     block_c489m_info:
         const _c489m;
         const 1;
         const 30;
 },
 _c489s() //  [R1]
         { []
         }
     {offset
       c489s: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c489F; else goto c489E;
       c489F: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c489E: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c489s_info" {
     block_c489s_info:
         const _c489s;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.4816617 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_closure" {
     GHC.Ptr.$fEqFunPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqFunPtr_$c==_closure+2;
         const GHC.Ptr.$fEqFunPtr_$c/=_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.484552638 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48a6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48aa; else goto c48ab;
       c48aa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48ab: // global
           I64[Sp - 16] = block_c48a3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48ao; else goto c48a4;
       u48ao: // global
           call _c48a3(R1) args: 0, res: 0, upd: 0;
       c48a4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$c<=_info" {
     GHC.Ptr.$fOrdFunPtr_$c<=_info:
         const GHC.Ptr.$fOrdFunPtr_$c<=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48a3() //  [R1]
         { []
         }
     {offset
       c48a3: // global
           I64[Sp] = block_c48a9_info;
           _s47z1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47z1::I64;
           if (R1 & 7 != 0) goto u48an; else goto c48ad;
       u48an: // global
           call _c48a9(R1) args: 0, res: 0, upd: 0;
       c48ad: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48a3_info" {
     block_c48a3_info:
         const _c48a3;
         const 1;
         const 30;
 },
 _c48a9() //  [R1]
         { []
         }
     {offset
       c48a9: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48al; else goto c48am;
       c48al: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48am: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48a9_info" {
     block_c48a9_info:
         const _c48a9;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.492533056 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmax_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmax_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c48aM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48aQ; else goto c48aR;
       c48aQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48aR: // global
           I64[Sp - 16] = block_c48aJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48b4; else goto c48aK;
       u48b4: // global
           call _c48aJ(R1) args: 0, res: 0, upd: 0;
       c48aK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$cmax_info" {
     GHC.Ptr.$fOrdFunPtr_$cmax_info:
         const GHC.Ptr.$fOrdFunPtr_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48aJ() //  [R1]
         { []
         }
     {offset
       c48aJ: // global
           I64[Sp - 8] = block_c48aP_info;
           _s47z7::P64 = R1;
           _s47z8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47z8::I64;
           P64[Sp + 8] = _s47z7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48b3; else goto c48aT;
       u48b3: // global
           call _c48aP(R1) args: 0, res: 0, upd: 0;
       c48aT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48aJ_info" {
     block_c48aJ_info:
         const _c48aJ;
         const 1;
         const 30;
 },
 _c48aP() //  [R1]
         { []
         }
     {offset
       c48aP: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48b1; else goto c48b2;
       c48b1: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48b2: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48aP_info" {
     block_c48aP_info:
         const _c48aP;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.500221043 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48bu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48by; else goto c48bz;
       c48by: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48bz: // global
           I64[Sp - 16] = block_c48br_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48bM; else goto c48bs;
       u48bM: // global
           call _c48br(R1) args: 0, res: 0, upd: 0;
       c48bs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$c>=_info" {
     GHC.Ptr.$fOrdFunPtr_$c>=_info:
         const GHC.Ptr.$fOrdFunPtr_$c>=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48br() //  [R1]
         { []
         }
     {offset
       c48br: // global
           I64[Sp] = block_c48bx_info;
           _s47zf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zf::I64;
           if (R1 & 7 != 0) goto u48bL; else goto c48bB;
       u48bL: // global
           call _c48bx(R1) args: 0, res: 0, upd: 0;
       c48bB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48br_info" {
     block_c48br_info:
         const _c48br;
         const 1;
         const 30;
 },
 _c48bx() //  [R1]
         { []
         }
     {offset
       c48bx: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48bJ; else goto c48bK;
       c48bJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48bK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48bx_info" {
     block_c48bx_info:
         const _c48bx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.507951265 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>_entry() //  [R2, R3]
         { []
         }
     {offset
       c48ca: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48ce; else goto c48cf;
       c48ce: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48cf: // global
           I64[Sp - 16] = block_c48c7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48co; else goto c48c8;
       u48co: // global
           call _c48c7(R1) args: 0, res: 0, upd: 0;
       c48c8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$c>_info" {
     GHC.Ptr.$fOrdFunPtr_$c>_info:
         const GHC.Ptr.$fOrdFunPtr_$c>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48c7() //  [R1]
         { []
         }
     {offset
       c48c7: // global
           I64[Sp] = block_c48cd_info;
           _s47zm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zm::I64;
           if (R1 & 7 != 0) goto u48cn; else goto c48ch;
       u48cn: // global
           call _c48cd(R1) args: 0, res: 0, upd: 0;
       c48ch: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48c7_info" {
     block_c48c7_info:
         const _c48c7;
         const 1;
         const 30;
 },
 _c48cd() //  [R1]
         { []
         }
     {offset
       c48cd: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48cd_info" {
     block_c48cd_info:
         const _c48cd;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.51645301 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmin_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmin_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c48cN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48cR; else goto c48cS;
       c48cR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48cS: // global
           I64[Sp - 16] = block_c48cK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48d5; else goto c48cL;
       u48d5: // global
           call _c48cK(R1) args: 0, res: 0, upd: 0;
       c48cL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$cmin_info" {
     GHC.Ptr.$fOrdFunPtr_$cmin_info:
         const GHC.Ptr.$fOrdFunPtr_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48cK() //  [R1]
         { []
         }
     {offset
       c48cK: // global
           I64[Sp - 8] = block_c48cQ_info;
           _s47zs::P64 = R1;
           _s47zt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47zt::I64;
           P64[Sp + 8] = _s47zs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48d4; else goto c48cU;
       u48d4: // global
           call _c48cQ(R1) args: 0, res: 0, upd: 0;
       c48cU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48cK_info" {
     block_c48cK_info:
         const _c48cK;
         const 1;
         const 30;
 },
 _c48cQ() //  [R1]
         { []
         }
     {offset
       c48cQ: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48d2; else goto c48d3;
       c48d2: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48d3: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48cQ_info" {
     block_c48cQ_info:
         const _c48cQ;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.522974639 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_closure" {
     GHC.Ptr.$fOrdFunPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqFunPtr_closure+1;
         const GHC.Ptr.$fOrdFunPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.526014707 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<_closure" {
     GHC.Ptr.$fOrdPtr_$c<_closure:
         const GHC.Ptr.$fOrdPtr_$c<_info;
 },
 GHC.Ptr.$fOrdPtr_$c<_entry() //  [R2, R3]
         { []
         }
     {offset
       c48dw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48dA; else goto c48dB;
       c48dA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48dB: // global
           I64[Sp - 16] = block_c48dt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48dK; else goto c48du;
       u48dK: // global
           call _c48dt(R1) args: 0, res: 0, upd: 0;
       c48du: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$c<_info" {
     GHC.Ptr.$fOrdPtr_$c<_info:
         const GHC.Ptr.$fOrdPtr_$c<_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48dt() //  [R1]
         { []
         }
     {offset
       c48dt: // global
           I64[Sp] = block_c48dz_info;
           _s47zA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zA::I64;
           if (R1 & 7 != 0) goto u48dJ; else goto c48dD;
       u48dJ: // global
           call _c48dz(R1) args: 0, res: 0, upd: 0;
       c48dD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48dt_info" {
     block_c48dt_info:
         const _c48dt;
         const 1;
         const 30;
 },
 _c48dz() //  [R1]
         { []
         }
     {offset
       c48dz: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48dz_info" {
     block_c48dz_info:
         const _c48dz;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.534053506 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdPtr_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c48e9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48ed; else goto c48ee;
       c48ed: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48ee: // global
           I64[Sp - 16] = block_c48e6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48ex; else goto c48e7;
       u48ex: // global
           call _c48e6(R1) args: 0, res: 0, upd: 0;
       c48e7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$ccompare_info" {
     GHC.Ptr.$fOrdPtr_$ccompare_info:
         const GHC.Ptr.$fOrdPtr_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48e6() //  [R1]
         { []
         }
     {offset
       c48e6: // global
           I64[Sp] = block_c48ec_info;
           _s47zH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zH::I64;
           if (R1 & 7 != 0) goto u48ew; else goto c48eg;
       u48ew: // global
           call _c48ec(R1) args: 0, res: 0, upd: 0;
       c48eg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48e6_info" {
     block_c48e6_info:
         const _c48e6;
         const 1;
         const 30;
 },
 _c48ec() //  [R1]
         { []
         }
     {offset
       c48ec: // global
           _s47zH::I64 = I64[Sp + 8];
           _s47zJ::I64 = I64[R1 + 7];
           if (_s47zH::I64 >= _s47zJ::I64) goto c48eu; else goto c48ev;
       c48eu: // global
           if (_s47zH::I64 == _s47zJ::I64) goto c48es; else goto c48er;
       c48es: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48er: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48ev: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48ec_info" {
     block_c48ec_info:
         const _c48ec;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.542121008 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c==_closure" {
     GHC.Ptr.$fEqPtr_$c==_closure:
         const GHC.Ptr.$fEqPtr_$c==_info;
 },
 GHC.Ptr.$fEqPtr_$c==_entry() //  [R2, R3]
         { []
         }
     {offset
       c48eV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48eZ; else goto c48f0;
       c48eZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48f0: // global
           I64[Sp - 16] = block_c48eS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48f9; else goto c48eT;
       u48f9: // global
           call _c48eS(R1) args: 0, res: 0, upd: 0;
       c48eT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fEqPtr_$c==_info" {
     GHC.Ptr.$fEqPtr_$c==_info:
         const GHC.Ptr.$fEqPtr_$c==_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48eS() //  [R1]
         { []
         }
     {offset
       c48eS: // global
           I64[Sp] = block_c48eY_info;
           _s47zP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zP::I64;
           if (R1 & 7 != 0) goto u48f8; else goto c48f2;
       u48f8: // global
           call _c48eY(R1) args: 0, res: 0, upd: 0;
       c48f2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48eS_info" {
     block_c48eS_info:
         const _c48eS;
         const 1;
         const 30;
 },
 _c48eY() //  [R1]
         { []
         }
     {offset
       c48eY: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48eY_info" {
     block_c48eY_info:
         const _c48eY;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.550176619 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c/=_closure" {
     GHC.Ptr.$fEqPtr_$c/=_closure:
         const GHC.Ptr.$fEqPtr_$c/=_info;
 },
 GHC.Ptr.$fEqPtr_$c/=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48fy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48fC; else goto c48fD;
       c48fC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48fD: // global
           I64[Sp - 16] = block_c48fv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48fQ; else goto c48fw;
       u48fQ: // global
           call _c48fv(R1) args: 0, res: 0, upd: 0;
       c48fw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fEqPtr_$c/=_info" {
     GHC.Ptr.$fEqPtr_$c/=_info:
         const GHC.Ptr.$fEqPtr_$c/=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48fv() //  [R1]
         { []
         }
     {offset
       c48fv: // global
           I64[Sp] = block_c48fB_info;
           _s47zW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zW::I64;
           if (R1 & 7 != 0) goto u48fP; else goto c48fF;
       u48fP: // global
           call _c48fB(R1) args: 0, res: 0, upd: 0;
       c48fF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48fv_info" {
     block_c48fv_info:
         const _c48fv;
         const 1;
         const 30;
 },
 _c48fB() //  [R1]
         { []
         }
     {offset
       c48fB: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c48fO; else goto c48fN;
       c48fO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48fN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48fB_info" {
     block_c48fB_info:
         const _c48fB;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.556671236 UTC

[section ""data" . GHC.Ptr.$fEqPtr_closure" {
     GHC.Ptr.$fEqPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqPtr_$c==_closure+2;
         const GHC.Ptr.$fEqPtr_$c/=_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.559603756 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<=_closure" {
     GHC.Ptr.$fOrdPtr_$c<=_closure:
         const GHC.Ptr.$fOrdPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdPtr_$c<=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48gf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48gj; else goto c48gk;
       c48gj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48gk: // global
           I64[Sp - 16] = block_c48gc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48gx; else goto c48gd;
       u48gx: // global
           call _c48gc(R1) args: 0, res: 0, upd: 0;
       c48gd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$c<=_info" {
     GHC.Ptr.$fOrdPtr_$c<=_info:
         const GHC.Ptr.$fOrdPtr_$c<=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48gc() //  [R1]
         { []
         }
     {offset
       c48gc: // global
           I64[Sp] = block_c48gi_info;
           _s47A3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47A3::I64;
           if (R1 & 7 != 0) goto u48gw; else goto c48gm;
       u48gw: // global
           call _c48gi(R1) args: 0, res: 0, upd: 0;
       c48gm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48gc_info" {
     block_c48gc_info:
         const _c48gc;
         const 1;
         const 30;
 },
 _c48gi() //  [R1]
         { []
         }
     {offset
       c48gi: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48gu; else goto c48gv;
       c48gu: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48gv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48gi_info" {
     block_c48gi_info:
         const _c48gi;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.567235262 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmax_closure" {
     GHC.Ptr.$fOrdPtr_$cmax_closure:
         const GHC.Ptr.$fOrdPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdPtr_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c48gV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48gZ; else goto c48h0;
       c48gZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48h0: // global
           I64[Sp - 16] = block_c48gS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48hd; else goto c48gT;
       u48hd: // global
           call _c48gS(R1) args: 0, res: 0, upd: 0;
       c48gT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$cmax_info" {
     GHC.Ptr.$fOrdPtr_$cmax_info:
         const GHC.Ptr.$fOrdPtr_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48gS() //  [R1]
         { []
         }
     {offset
       c48gS: // global
           I64[Sp - 8] = block_c48gY_info;
           _s47A9::P64 = R1;
           _s47Aa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47Aa::I64;
           P64[Sp + 8] = _s47A9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48hc; else goto c48h2;
       u48hc: // global
           call _c48gY(R1) args: 0, res: 0, upd: 0;
       c48h2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48gS_info" {
     block_c48gS_info:
         const _c48gS;
         const 1;
         const 30;
 },
 _c48gY() //  [R1]
         { []
         }
     {offset
       c48gY: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48ha; else goto c48hb;
       c48ha: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48hb: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48gY_info" {
     block_c48gY_info:
         const _c48gY;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.575083532 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>=_closure" {
     GHC.Ptr.$fOrdPtr_$c>=_closure:
         const GHC.Ptr.$fOrdPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdPtr_$c>=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48hD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48hH; else goto c48hI;
       c48hH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48hI: // global
           I64[Sp - 16] = block_c48hA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48hV; else goto c48hB;
       u48hV: // global
           call _c48hA(R1) args: 0, res: 0, upd: 0;
       c48hB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$c>=_info" {
     GHC.Ptr.$fOrdPtr_$c>=_info:
         const GHC.Ptr.$fOrdPtr_$c>=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48hA() //  [R1]
         { []
         }
     {offset
       c48hA: // global
           I64[Sp] = block_c48hG_info;
           _s47Ah::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47Ah::I64;
           if (R1 & 7 != 0) goto u48hU; else goto c48hK;
       u48hU: // global
           call _c48hG(R1) args: 0, res: 0, upd: 0;
       c48hK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48hA_info" {
     block_c48hA_info:
         const _c48hA;
         const 1;
         const 30;
 },
 _c48hG() //  [R1]
         { []
         }
     {offset
       c48hG: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48hS; else goto c48hT;
       c48hS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48hT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48hG_info" {
     block_c48hG_info:
         const _c48hG;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.582915146 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>_closure" {
     GHC.Ptr.$fOrdPtr_$c>_closure:
         const GHC.Ptr.$fOrdPtr_$c>_info;
 },
 GHC.Ptr.$fOrdPtr_$c>_entry() //  [R2, R3]
         { []
         }
     {offset
       c48ij: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48in; else goto c48io;
       c48in: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48io: // global
           I64[Sp - 16] = block_c48ig_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48ix; else goto c48ih;
       u48ix: // global
           call _c48ig(R1) args: 0, res: 0, upd: 0;
       c48ih: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$c>_info" {
     GHC.Ptr.$fOrdPtr_$c>_info:
         const GHC.Ptr.$fOrdPtr_$c>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48ig() //  [R1]
         { []
         }
     {offset
       c48ig: // global
           I64[Sp] = block_c48im_info;
           _s47Ao::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47Ao::I64;
           if (R1 & 7 != 0) goto u48iw; else goto c48iq;
       u48iw: // global
           call _c48im(R1) args: 0, res: 0, upd: 0;
       c48iq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48ig_info" {
     block_c48ig_info:
         const _c48ig;
         const 1;
         const 30;
 },
 _c48im() //  [R1]
         { []
         }
     {offset
       c48im: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48im_info" {
     block_c48im_info:
         const _c48im;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.59230949 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmin_closure" {
     GHC.Ptr.$fOrdPtr_$cmin_closure:
         const GHC.Ptr.$fOrdPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdPtr_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c48iW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48j0; else goto c48j1;
       c48j0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48j1: // global
           I64[Sp - 16] = block_c48iT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48je; else goto c48iU;
       u48je: // global
           call _c48iT(R1) args: 0, res: 0, upd: 0;
       c48iU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$cmin_info" {
     GHC.Ptr.$fOrdPtr_$cmin_info:
         const GHC.Ptr.$fOrdPtr_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48iT() //  [R1]
         { []
         }
     {offset
       c48iT: // global
           I64[Sp - 8] = block_c48iZ_info;
           _s47Au::P64 = R1;
           _s47Av::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47Av::I64;
           P64[Sp + 8] = _s47Au::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48jd; else goto c48j3;
       u48jd: // global
           call _c48iZ(R1) args: 0, res: 0, upd: 0;
       c48j3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48iT_info" {
     block_c48iT_info:
         const _c48iT;
         const 1;
         const 30;
 },
 _c48iZ() //  [R1]
         { []
         }
     {offset
       c48iZ: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48jb; else goto c48jc;
       c48jb: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48jc: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48iZ_info" {
     block_c48iZ_info:
         const _c48iZ;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.600319448 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_closure" {
     GHC.Ptr.$fOrdPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqPtr_closure+1;
         const GHC.Ptr.$fOrdPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.602317107 UTC

[section ""data" . GHC.Ptr.nullPtr_closure" {
     GHC.Ptr.nullPtr_closure:
         const GHC.Ptr.Ptr_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.604612679 UTC

[section ""data" . GHC.Ptr.castPtr1_closure" {
     GHC.Ptr.castPtr1_closure:
         const GHC.Ptr.castPtr1_info;
 },
 GHC.Ptr.castPtr1_entry() //  [R2]
         { []
         }
     {offset
       c48jD: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castPtr1_info" {
     GHC.Ptr.castPtr1_info:
         const GHC.Ptr.castPtr1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.608599528 UTC

[section ""data" . GHC.Ptr.castPtr_closure" {
     GHC.Ptr.castPtr_closure:
         const GHC.Ptr.castPtr_info;
 },
 GHC.Ptr.castPtr_entry() //  [R2]
         { []
         }
     {offset
       c48jQ: // global
           R2 = R2;
           call GHC.Ptr.castPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castPtr_info" {
     GHC.Ptr.castPtr_info:
         const GHC.Ptr.castPtr_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.613199118 UTC

[section ""data" . GHC.Ptr.plusPtr_closure" {
     GHC.Ptr.plusPtr_closure:
         const GHC.Ptr.plusPtr_info;
 },
 GHC.Ptr.plusPtr_entry() //  [R2, R3]
         { []
         }
     {offset
       c48k4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48kg; else goto c48kh;
       c48kg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.plusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48kh: // global
           I64[Sp - 16] = block_c48k1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48kn; else goto c48k2;
       u48kn: // global
           call _c48k1(R1) args: 0, res: 0, upd: 0;
       c48k2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.plusPtr_info" {
     GHC.Ptr.plusPtr_info:
         const GHC.Ptr.plusPtr_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48k1() //  [R1]
         { []
         }
     {offset
       c48k1: // global
           I64[Sp] = block_c48k7_info;
           _s47AD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47AD::I64;
           if (R1 & 7 != 0) goto u48km; else goto c48k8;
       u48km: // global
           call _c48k7(R1) args: 0, res: 0, upd: 0;
       c48k8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48k1_info" {
     block_c48k1_info:
         const _c48k1;
         const 1;
         const 30;
 },
 _c48k7() //  [R1]
         { []
         }
     {offset
       c48k7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48kl; else goto c48kk;
       c48kl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48kk: // global
           _s47AG::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s47AG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48k7_info" {
     block_c48k7_info:
         const _c48k7;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.622639223 UTC

[section ""data" . GHC.Ptr.alignPtr_closure" {
     GHC.Ptr.alignPtr_closure:
         const GHC.Ptr.alignPtr_info;
 },
 GHC.Ptr.alignPtr_entry() //  [R2, R3]
         { []
         }
     {offset
       c48kL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48kP; else goto c48kQ;
       c48kP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.alignPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48kQ: // global
           I64[Sp - 16] = block_c48kI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48lo; else goto c48kJ;
       u48lo: // global
           call _c48kI(R1) args: 0, res: 0, upd: 0;
       c48kJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.alignPtr_info" {
     GHC.Ptr.alignPtr_info:
         const GHC.Ptr.alignPtr_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48kI() //  [R1]
         { []
         }
     {offset
       c48kI: // global
           I64[Sp - 8] = block_c48kO_info;
           _s47AJ::P64 = R1;
           _s47AK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47AK::I64;
           P64[Sp + 8] = _s47AJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48ln; else goto c48kS;
       u48ln: // global
           call _c48kO(R1) args: 0, res: 0, upd: 0;
       c48kS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48kI_info" {
     block_c48kI_info:
         const _c48kI;
         const 1;
         const 30;
 },
 _c48kO() //  [R1]
         { []
         }
     {offset
       c48kO: // global
           _s47AM::I64 = I64[R1 + 7];
           _s47AN::I64 = I64[Sp + 8] % _s47AM::I64;
           if (_s47AN::I64 != 0) goto u48ll; else goto c48lh;
       u48ll: // global
           I64[Sp] = _s47AN::I64;
           I64[Sp + 16] = _s47AM::I64;
           call _c48l1() args: 0, res: 0, upd: 0;
       c48lh: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48kO_info" {
     block_c48kO_info:
         const _c48kO;
         const 66;
         const 30;
 },
 _c48l1() //  []
         { []
         }
     {offset
       c48l1: // global
           Hp = Hp + 16;
           _s47AN::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c48le; else goto c48ld;
       c48le: // global
           HpAlloc = 16;
           I64[Sp] = block_c48l0_info;
           R1 = _s47AN::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c48ld: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + (I64[Sp + 16] - _s47AN::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c48l0() //  [R1]
         { []
         }
     {offset
       c48l0: // global
           I64[Sp] = R1;
           call _c48l1() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c48l0_info" {
     block_c48l0_info:
         const _c48l0;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.633991925 UTC

[section ""data" . GHC.Ptr.minusPtr_closure" {
     GHC.Ptr.minusPtr_closure:
         const GHC.Ptr.minusPtr_info;
 },
 GHC.Ptr.minusPtr_entry() //  [R2, R3]
         { []
         }
     {offset
       c48lX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48m9; else goto c48ma;
       c48m9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.minusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48ma: // global
           I64[Sp - 16] = block_c48lU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48mg; else goto c48lV;
       u48mg: // global
           call _c48lU(R1) args: 0, res: 0, upd: 0;
       c48lV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.minusPtr_info" {
     GHC.Ptr.minusPtr_info:
         const GHC.Ptr.minusPtr_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48lU() //  [R1]
         { []
         }
     {offset
       c48lU: // global
           I64[Sp] = block_c48m0_info;
           _s47AT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47AT::I64;
           if (R1 & 7 != 0) goto u48mf; else goto c48m1;
       u48mf: // global
           call _c48m0(R1) args: 0, res: 0, upd: 0;
       c48m1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48lU_info" {
     block_c48lU_info:
         const _c48lU;
         const 1;
         const 30;
 },
 _c48m0() //  [R1]
         { []
         }
     {offset
       c48m0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48me; else goto c48md;
       c48me: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48md: // global
           _s47AW::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s47AW::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48m0_info" {
     block_c48m0_info:
         const _c48m0;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.640663683 UTC

[section ""data" . GHC.Ptr.nullFunPtr_closure" {
     GHC.Ptr.nullFunPtr_closure:
         const GHC.Ptr.FunPtr_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.642810579 UTC

[section ""data" . GHC.Ptr.castFunPtr1_closure" {
     GHC.Ptr.castFunPtr1_closure:
         const GHC.Ptr.castFunPtr1_info;
 },
 GHC.Ptr.castFunPtr1_entry() //  [R2]
         { []
         }
     {offset
       c48mC: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castFunPtr1_info" {
     GHC.Ptr.castFunPtr1_info:
         const GHC.Ptr.castFunPtr1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.646129601 UTC

[section ""data" . GHC.Ptr.castFunPtr_closure" {
     GHC.Ptr.castFunPtr_closure:
         const GHC.Ptr.castFunPtr_info;
 },
 GHC.Ptr.castFunPtr_entry() //  [R2]
         { []
         }
     {offset
       c48mP: // global
           R2 = R2;
           call GHC.Ptr.castFunPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castFunPtr_info" {
     GHC.Ptr.castFunPtr_info:
         const GHC.Ptr.castFunPtr_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.650023166 UTC

[section ""data" . GHC.Ptr.castFunPtrToPtr_closure" {
     GHC.Ptr.castFunPtrToPtr_closure:
         const GHC.Ptr.castFunPtrToPtr_info;
 },
 GHC.Ptr.castFunPtrToPtr_entry() //  [R2]
         { []
         }
     {offset
       c48n3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48n7; else goto c48n8;
       c48n7: // global
           R2 = R2;
           R1 = GHC.Ptr.castFunPtrToPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48n8: // global
           I64[Sp - 8] = block_c48n0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48nc; else goto c48n1;
       u48nc: // global
           call _c48n0(R1) args: 0, res: 0, upd: 0;
       c48n1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castFunPtrToPtr_info" {
     GHC.Ptr.castFunPtrToPtr_info:
         const GHC.Ptr.castFunPtrToPtr_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c48n0() //  [R1]
         { []
         }
     {offset
       c48n0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48nb; else goto c48na;
       c48nb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48na: // global
           _s47B0::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s47B0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48n0_info" {
     block_c48n0_info:
         const _c48n0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.656639123 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c48nu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48nA; else goto c48nB;
       c48nA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c48nB: // global
           I64[Sp - 16] = block_c48nr_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48nG; else goto c48ns;
       u48nG: // global
           call _c48nr(R1) args: 0, res: 0, upd: 0;
       c48ns: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_entry;
         const 0;
         const 73014444046;
         const 12884901911;
         const S47CQ_srt+40;
 },
 _c48nr() //  [R1]
         { []
         }
     {offset
       c48nr: // global
           _s47B3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48nx_info;
           R3 = _s47B3::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48nr_info" {
     block_c48nr_info:
         const _c48nr;
         const 1;
         const 4294967326;
         const S47CQ_srt+40;
 },
 _c48nx() //  [R1, R2]
         { []
         }
     {offset
       c48nx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48nF; else goto c48nE;
       c48nF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48nE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48nx_info" {
     block_c48nx_info:
         const _c48nx;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.664829219 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshow_closure" {
     GHC.Ptr.$fShowFunPtr_$cshow_closure:
         const GHC.Ptr.$fShowFunPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c48o1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48o7; else goto c48o8;
       c48o7: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48o8: // global
           I64[Sp - 8] = block_c48nY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48od; else goto c48nZ;
       u48od: // global
           call _c48nY(R1) args: 0, res: 0, upd: 0;
       c48nZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowFunPtr_$cshow_info" {
     GHC.Ptr.$fShowFunPtr_$cshow_info:
         const GHC.Ptr.$fShowFunPtr_$cshow_entry;
         const 0;
         const 141733920782;
         const 4294967301;
         const S47CQ_srt+40;
 },
 _c48nY() //  [R1]
         { []
         }
     {offset
       c48nY: // global
           I64[Sp] = block_c48o4_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48nY_info" {
     block_c48nY_info:
         const _c48nY;
         const 0;
         const 4294967326;
         const S47CQ_srt+40;
 },
 _c48o4() //  [R1, R2]
         { []
         }
     {offset
       c48o4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48oc; else goto c48ob;
       c48oc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48ob: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48o4_info" {
     block_c48o4_info:
         const _c48o4;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.67239088 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr1_closure" {
     GHC.Ptr.$fShowFunPtr1_closure:
         const GHC.Ptr.$fShowFunPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr1_entry() //  [R2, R3]
         { []
         }
     {offset
       c48oy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48oE; else goto c48oF;
       c48oE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48oF: // global
           I64[Sp - 16] = block_c48ov_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48oK; else goto c48ow;
       u48oK: // global
           call _c48ov(R1) args: 0, res: 0, upd: 0;
       c48ow: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowFunPtr1_info" {
     GHC.Ptr.$fShowFunPtr1_info:
         const GHC.Ptr.$fShowFunPtr1_entry;
         const 0;
         const 279172874254;
         const 8589934607;
         const S47CQ_srt+40;
 },
 _c48ov() //  [R1]
         { []
         }
     {offset
       c48ov: // global
           _s47Bg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48oB_info;
           R3 = _s47Bg::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48ov_info" {
     block_c48ov_info:
         const _c48ov;
         const 1;
         const 4294967326;
         const S47CQ_srt+40;
 },
 _c48oB() //  [R1, R2]
         { []
         }
     {offset
       c48oB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48oJ; else goto c48oI;
       c48oJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48oI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48oB_info" {
     block_c48oB_info:
         const _c48oB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.679238081 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowList_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowList_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c48p2: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowFunPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowFunPtr_$cshowList_info" {
     GHC.Ptr.$fShowFunPtr_$cshowList_info:
         const GHC.Ptr.$fShowFunPtr_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S47CQ_srt+88;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.682312314 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_closure" {
     GHC.Ptr.$fShowFunPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure+3;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowFunPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.684818227 UTC

[section ""data" . GHC.Ptr.castPtrToFunPtr_closure" {
     GHC.Ptr.castPtrToFunPtr_closure:
         const GHC.Ptr.castPtrToFunPtr_info;
 },
 GHC.Ptr.castPtrToFunPtr_entry() //  [R2]
         { []
         }
     {offset
       c48ph: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48pl; else goto c48pm;
       c48pl: // global
           R2 = R2;
           R1 = GHC.Ptr.castPtrToFunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48pm: // global
           I64[Sp - 8] = block_c48pe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48pq; else goto c48pf;
       u48pq: // global
           call _c48pe(R1) args: 0, res: 0, upd: 0;
       c48pf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castPtrToFunPtr_info" {
     GHC.Ptr.castPtrToFunPtr_info:
         const GHC.Ptr.castPtrToFunPtr_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c48pe() //  [R1]
         { []
         }
     {offset
       c48pe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48pp; else goto c48po;
       c48pp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48po: // global
           _s47Bq::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s47Bq::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48pe_info" {
     block_c48pe_info:
         const _c48pe;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.690078655 UTC

[section ""cstring" . GHC.Ptr.$trModule4_bytes" {
     GHC.Ptr.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.691698689 UTC

[section ""data" . GHC.Ptr.$trModule3_closure" {
     GHC.Ptr.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.694258895 UTC

[section ""cstring" . GHC.Ptr.$trModule2_bytes" {
     GHC.Ptr.$trModule2_bytes:
         I8[] [71,72,67,46,80,116,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.695955043 UTC

[section ""data" . GHC.Ptr.$trModule1_closure" {
     GHC.Ptr.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.697625661 UTC

[section ""data" . GHC.Ptr.$trModule_closure" {
     GHC.Ptr.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Ptr.$trModule3_closure+1;
         const GHC.Ptr.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.699301548 UTC

[section ""data" . $krep_r47xK_closure" {
     $krep_r47xK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.700899976 UTC

[section ""data" . $krep1_r47xL_closure" {
     $krep1_r47xL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcAddr#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.702587798 UTC

[section ""cstring" . GHC.Ptr.$tcPtr2_bytes" {
     GHC.Ptr.$tcPtr2_bytes:
         I8[] [80,116,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.704191243 UTC

[section ""data" . GHC.Ptr.$tcPtr1_closure" {
     GHC.Ptr.$tcPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcPtr2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.706320793 UTC

[section ""data" . GHC.Ptr.$tcPtr_closure" {
     GHC.Ptr.$tcPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13939499724423561315;
         const 16316673677148652216;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.708055624 UTC

[section ""data" . $krep2_r47xM_closure" {
     $krep2_r47xM_closure:
         const :_con_info;
         const $krep_r47xK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.709764568 UTC

[section ""data" . $krep3_r47xN_closure" {
     $krep3_r47xN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.71138712 UTC

[section ""data" . GHC.Ptr.$tc'Ptr1_closure" {
     GHC.Ptr.$tc'Ptr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep3_r47xN_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.71301325 UTC

[section ""cstring" . GHC.Ptr.$tc'Ptr3_bytes" {
     GHC.Ptr.$tc'Ptr3_bytes:
         I8[] [39,80,116,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.714603249 UTC

[section ""data" . GHC.Ptr.$tc'Ptr2_closure" {
     GHC.Ptr.$tc'Ptr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'Ptr3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.716270368 UTC

[section ""data" . GHC.Ptr.$tc'Ptr_closure" {
     GHC.Ptr.$tc'Ptr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'Ptr2_closure+1;
         const GHC.Ptr.$tc'Ptr1_closure+4;
         const 2332306090346040376;
         const 13491728187967991297;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.718015516 UTC

[section ""cstring" . GHC.Ptr.$tcFunPtr2_bytes" {
     GHC.Ptr.$tcFunPtr2_bytes:
         I8[] [70,117,110,80,116,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.720172236 UTC

[section ""data" . GHC.Ptr.$tcFunPtr1_closure" {
     GHC.Ptr.$tcFunPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcFunPtr2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.722469758 UTC

[section ""data" . GHC.Ptr.$tcFunPtr_closure" {
     GHC.Ptr.$tcFunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcFunPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 38956960673620606;
         const 4307950889093819770;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.724179413 UTC

[section ""data" . $krep4_r47xO_closure" {
     $krep4_r47xO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcFunPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.725930256 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr1_closure" {
     GHC.Ptr.$tc'FunPtr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep4_r47xO_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.727646681 UTC

[section ""cstring" . GHC.Ptr.$tc'FunPtr3_bytes" {
     GHC.Ptr.$tc'FunPtr3_bytes:
         I8[] [39,70,117,110,80,116,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.729336787 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr2_closure" {
     GHC.Ptr.$tc'FunPtr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'FunPtr3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.731073796 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr_closure" {
     GHC.Ptr.$tc'FunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'FunPtr2_closure+1;
         const GHC.Ptr.$tc'FunPtr1_closure+4;
         const 15722333564603238588;
         const 12100865307857439187;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.73367025 UTC

[section ""data" . GHC.Ptr.Ptr_closure" {
     GHC.Ptr.Ptr_closure:
         const GHC.Ptr.Ptr_info;
 },
 GHC.Ptr.Ptr_entry() //  [R2]
         { []
         }
     {offset
       c48q4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48q8; else goto c48q7;
       c48q8: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.Ptr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48q7: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.Ptr_info" {
     GHC.Ptr.Ptr_info:
         const GHC.Ptr.Ptr_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.737523496 UTC

[section ""data" . GHC.Ptr.FunPtr_closure" {
     GHC.Ptr.FunPtr_closure:
         const GHC.Ptr.FunPtr_info;
 },
 GHC.Ptr.FunPtr_entry() //  [R2]
         { []
         }
     {offset
       c48qj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48qn; else goto c48qm;
       c48qn: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.FunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48qm: // global
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.FunPtr_info" {
     GHC.Ptr.FunPtr_info:
         const GHC.Ptr.FunPtr_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.740922556 UTC

[section ""cstring" . i483j_str" {
     i483j_str:
         I8[] [98,97,115,101,58,71,72,67,46,80,116,114,46,80,116,114]
 },
 GHC.Ptr.Ptr_con_entry() //  [R1]
         { []
         }
     {offset
       c48qt: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.Ptr_con_info" {
     GHC.Ptr.Ptr_con_info:
         const GHC.Ptr.Ptr_con_entry;
         const 4294967296;
         const 3;
         const i483j_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.744112847 UTC

[section ""cstring" . i483l_str" {
     i483l_str:
         I8[] [98,97,115,101,58,71,72,67,46,80,116,114,46,70,117,110,80,116,114]
 },
 GHC.Ptr.FunPtr_con_entry() //  [R1]
         { []
         }
     {offset
       c48qz: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.FunPtr_con_info" {
     GHC.Ptr.FunPtr_con_info:
         const GHC.Ptr.FunPtr_con_entry;
         const 4294967296;
         const 3;
         const i483l_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:00.748202382 UTC

[section ""relreadonly" . S47CQ_srt" {
     S47CQ_srt:
         const GHC.Show.intToDigit_closure;
         const GHC.Show.$fShowInteger_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Numeric.showIntAtBase_closure;
         const Numeric.showHex1_closure;
         const GHC.Ptr.$w$cshowsPrec_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
         const GHC.Ptr.$fShowPtr_$cshow_closure;
         const GHC.Ptr.$fShowPtr1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure;
         const GHC.Ptr.$fShowFunPtr1_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.371872827 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:59:01.372998926 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr4_closure" {
     GHC.Ptr.$fShowFunPtr4_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.374773096 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr3_closure" {
     GHC.Ptr.$fShowFunPtr3_closure:
         const GHC.Types.C#_con_info;
         const 120;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.380826316 UTC

[section ""data" . GHC.Ptr.$w$cshowsPrec_closure" {
     GHC.Ptr.$w$cshowsPrec_closure:
         const GHC.Ptr.$w$cshowsPrec_info;
         const 0;
 },
 sat_s48qL_entry() //  [R1]
         { []
         }
     {offset
       c48ux: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48uy; else goto c48uz;
       c48uy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48uz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s48qL_info" {
     sat_s48qL_info:
         const sat_s48qL_entry;
         const 4294967296;
         const 17;
 },
 ls_s48qI_entry() //  [R1]
         { []
         }
     {offset
       c48uC: // global
           _s48qI::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c48uD; else goto c48uE;
       c48uE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48uG; else goto c48uF;
       c48uG: // global
           HpAlloc = 24;
           goto c48uD;
       c48uD: // global
           R1 = _s48qI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48uF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s48qI::P64;
           _s48qG::I64 = I64[_s48qI::P64 + 16];
           I64[Hp - 16] = sat_s48qL_info;
           I64[Hp] = _s48qG::I64;
           R6 = Hp - 16;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Numeric.showHex1_closure;
           R3 = GHC.Show.$fShowInteger_closure;
           R2 = GHC.Real.$fIntegralInteger_closure;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 32, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ls_s48qI_info" {
     ls_s48qI_info:
         const ls_s48qI_entry;
         const 4294967296;
         const 133143986193;
         const S48vI_srt;
 },
 n_s48qP_entry() //  [R1]
         { []
         }
     {offset
       c48v0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48v1; else goto c48v2;
       c48v1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48v2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . n_s48qP_info" {
     n_s48qP_info:
         const n_s48qP_entry;
         const 2;
         const 18;
 },
 sat_s48qV_entry() //  [R1]
         { []
         }
     {offset
       c48vh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48vi; else goto c48vj;
       c48vi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48vj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_s48qR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s48qV_info" {
     sat_s48qV_info:
         const sat_s48qV_entry;
         const 4294967297;
         const 19;
 },
 $wxs_s48qR_entry() //  [R1, R2]
         { []
         }
     {offset
       c48vn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c48vr; else goto c48vq;
       c48vr: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48vq: // global
           if (R2 == 1) goto c48vm; else goto c48vl;
       c48vm: // global
           _s48qQ::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _s48qQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48vl: // global
           I64[Hp - 48] = sat_s48qV_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wxs_s48qR_info" {
     $wxs_s48qR_info:
         const $wxs_s48qR_entry;
         const 1;
         const 9;
         const 4294967300;
 },
 sat_s48qW_entry() //  [R1]
         { []
         }
     {offset
       c48vt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c48vu; else goto c48vv;
       c48vu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48vv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c48uL_info;
           R3 = 0;
           _s48qI::P64 = P64[R1 + 24];
           R2 = _s48qI::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s48qI::P64;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s48qW_info" {
     sat_s48qW_info:
         const sat_s48qW_entry;
         const 2;
         const 18;
 },
 _c48uL() //  [R1]
         { []
         }
     {offset
       c48uL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c48vy; else goto c48vx;
       c48vy: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c48vx: // global
           _s48qH::P64 = P64[Sp + 8];
           _s48qI::P64 = P64[Sp + 16];
           _s48qN::I64 = 16 - R1;
           if (%MO_S_Ge_W64(0, _s48qN::I64)) goto c48vA; else goto c48vB;
       c48vA: // global
           Hp = Hp - 72;
           R3 = _s48qH::P64;
           R2 = _s48qI::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c48vB: // global
           I64[Hp - 64] = n_s48qP_info;
           P64[Hp - 48] = _s48qH::P64;
           P64[Hp - 40] = _s48qI::P64;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp - 16] = Hp - 64;
           I64[Hp - 8] = $wxs_s48qR_info;
           P64[Hp] = Hp - 30;
           R2 = _s48qN::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call $wxs_s48qR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_c48uL_info" {
     block_c48uL_info:
         const _c48uL;
         const 2;
         const 30;
 },
 GHC.Ptr.$w$cshowsPrec_entry() //  [R2, R3]
         { []
         }
     {offset
       c48vD: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c48vH; else goto c48vG;
       c48vH: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48vG: // global
           I64[Hp - 72] = ls_s48qI_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s48qW_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr3_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = GHC.Ptr.$fShowFunPtr4_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$w$cshowsPrec_info" {
     GHC.Ptr.$w$cshowsPrec_info:
         const GHC.Ptr.$w$cshowsPrec_entry;
         const 0;
         const 270582939662;
         const 8589934605;
         const S48vI_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.400055793 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c48wQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48wW; else goto c48wX;
       c48wW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c48wX: // global
           I64[Sp - 16] = block_c48wN_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48x2; else goto c48wO;
       u48x2: // global
           call _c48wN(R1) args: 0, res: 0, upd: 0;
       c48wO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowFunPtr_$cshowsPrec_info" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec_info:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_entry;
         const 0;
         const 12884901902;
         const 12884901911;
         const S48vI_srt+40;
 },
 _c48wN() //  [R1]
         { []
         }
     {offset
       c48wN: // global
           _s48r0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48wT_info;
           R3 = _s48r0::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48wN_info" {
     block_c48wN_info:
         const _c48wN;
         const 1;
         const 4294967326;
         const S48vI_srt+40;
 },
 _c48wT() //  [R1, R2]
         { []
         }
     {offset
       c48wT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48x1; else goto c48x0;
       c48x1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48x0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48wT_info" {
     block_c48wT_info:
         const _c48wT;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.407196297 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr2_closure" {
     GHC.Ptr.$fShowFunPtr2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.410150766 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshow_closure" {
     GHC.Ptr.$fShowPtr_$cshow_closure:
         const GHC.Ptr.$fShowPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c48xr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48xx; else goto c48xy;
       c48xx: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48xy: // global
           I64[Sp - 8] = block_c48xo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48xD; else goto c48xp;
       u48xD: // global
           call _c48xo(R1) args: 0, res: 0, upd: 0;
       c48xp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowPtr_$cshow_info" {
     GHC.Ptr.$fShowPtr_$cshow_info:
         const GHC.Ptr.$fShowPtr_$cshow_entry;
         const 0;
         const 21474836494;
         const 4294967301;
         const S48vI_srt+40;
 },
 _c48xo() //  [R1]
         { []
         }
     {offset
       c48xo: // global
           I64[Sp] = block_c48xu_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48xo_info" {
     block_c48xo_info:
         const _c48xo;
         const 0;
         const 4294967326;
         const S48vI_srt+40;
 },
 _c48xu() //  [R1, R2]
         { []
         }
     {offset
       c48xu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48xC; else goto c48xB;
       c48xC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48xB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48xu_info" {
     block_c48xu_info:
         const _c48xu;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.418976785 UTC

[section ""data" . GHC.Ptr.$fShowPtr1_closure" {
     GHC.Ptr.$fShowPtr1_closure:
         const GHC.Ptr.$fShowPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr1_entry() //  [R2, R3]
         { []
         }
     {offset
       c48y2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48y8; else goto c48y9;
       c48y8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48y9: // global
           I64[Sp - 16] = block_c48xZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48ye; else goto c48y0;
       u48ye: // global
           call _c48xZ(R1) args: 0, res: 0, upd: 0;
       c48y0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowPtr1_info" {
     GHC.Ptr.$fShowPtr1_info:
         const GHC.Ptr.$fShowPtr1_entry;
         const 0;
         const 38654705678;
         const 8589934607;
         const S48vI_srt+40;
 },
 _c48xZ() //  [R1]
         { []
         }
     {offset
       c48xZ: // global
           _s48rd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48y5_info;
           R3 = _s48rd::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48xZ_info" {
     block_c48xZ_info:
         const _c48xZ;
         const 1;
         const 4294967326;
         const S48vI_srt+40;
 },
 _c48y5() //  [R1, R2]
         { []
         }
     {offset
       c48y5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48yd; else goto c48yc;
       c48yd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48yc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48y5_info" {
     block_c48y5_info:
         const _c48y5;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.426146276 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshowList_closure" {
     GHC.Ptr.$fShowPtr_$cshowList_closure:
         const GHC.Ptr.$fShowPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c48yz: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowPtr_$cshowList_info" {
     GHC.Ptr.$fShowPtr_$cshowList_info:
         const GHC.Ptr.$fShowPtr_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S48vI_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.430088329 UTC

[section ""data" . GHC.Ptr.$fShowPtr_closure" {
     GHC.Ptr.$fShowPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure+3;
         const GHC.Ptr.$fShowPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.432889314 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<_entry() //  [R2, R3]
         { []
         }
     {offset
       c48yO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48yS; else goto c48yT;
       c48yS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48yT: // global
           I64[Sp - 16] = block_c48yL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48z2; else goto c48yM;
       u48z2: // global
           call _c48yL(R1) args: 0, res: 0, upd: 0;
       c48yM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$c<_info" {
     GHC.Ptr.$fOrdFunPtr_$c<_info:
         const GHC.Ptr.$fOrdFunPtr_$c<_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48yL() //  [R1]
         { []
         }
     {offset
       c48yL: // global
           I64[Sp] = block_c48yR_info;
           _s48ro::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48ro::I64;
           if (R1 & 7 != 0) goto u48z1; else goto c48yV;
       u48z1: // global
           call _c48yR(R1) args: 0, res: 0, upd: 0;
       c48yV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48yL_info" {
     block_c48yL_info:
         const _c48yL;
         const 1;
         const 30;
 },
 _c48yR() //  [R1]
         { []
         }
     {offset
       c48yR: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48yR_info" {
     block_c48yR_info:
         const _c48yR;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.44145782 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdFunPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdFunPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdFunPtr_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c48zu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48zy; else goto c48zz;
       c48zy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48zz: // global
           I64[Sp - 16] = block_c48zr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48zS; else goto c48zs;
       u48zS: // global
           call _c48zr(R1) args: 0, res: 0, upd: 0;
       c48zs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$ccompare_info" {
     GHC.Ptr.$fOrdFunPtr_$ccompare_info:
         const GHC.Ptr.$fOrdFunPtr_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48zr() //  [R1]
         { []
         }
     {offset
       c48zr: // global
           I64[Sp] = block_c48zx_info;
           _s48rv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48rv::I64;
           if (R1 & 7 != 0) goto u48zR; else goto c48zB;
       u48zR: // global
           call _c48zx(R1) args: 0, res: 0, upd: 0;
       c48zB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48zr_info" {
     block_c48zr_info:
         const _c48zr;
         const 1;
         const 30;
 },
 _c48zx() //  [R1]
         { []
         }
     {offset
       c48zx: // global
           _s48rv::I64 = I64[Sp + 8];
           _s48rx::I64 = I64[R1 + 7];
           if (_s48rv::I64 >= _s48rx::I64) goto c48zP; else goto c48zQ;
       c48zP: // global
           if (_s48rv::I64 == _s48rx::I64) goto c48zN; else goto c48zM;
       c48zN: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48zM: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48zQ: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48zx_info" {
     block_c48zx_info:
         const _c48zx;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.449570944 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c==_closure" {
     GHC.Ptr.$fEqFunPtr_$c==_closure:
         const GHC.Ptr.$fEqFunPtr_$c==_info;
 },
 GHC.Ptr.$fEqFunPtr_$c==_entry() //  [R2, R3]
         { []
         }
     {offset
       c48Al: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Ap; else goto c48Aq;
       c48Ap: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Aq: // global
           I64[Sp - 16] = block_c48Ai_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Az; else goto c48Aj;
       u48Az: // global
           call _c48Ai(R1) args: 0, res: 0, upd: 0;
       c48Aj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fEqFunPtr_$c==_info" {
     GHC.Ptr.$fEqFunPtr_$c==_info:
         const GHC.Ptr.$fEqFunPtr_$c==_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48Ai() //  [R1]
         { []
         }
     {offset
       c48Ai: // global
           I64[Sp] = block_c48Ao_info;
           _s48rD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48rD::I64;
           if (R1 & 7 != 0) goto u48Ay; else goto c48As;
       u48Ay: // global
           call _c48Ao(R1) args: 0, res: 0, upd: 0;
       c48As: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Ai_info" {
     block_c48Ai_info:
         const _c48Ai;
         const 1;
         const 30;
 },
 _c48Ao() //  [R1]
         { []
         }
     {offset
       c48Ao: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Ao_info" {
     block_c48Ao_info:
         const _c48Ao;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.457751652 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c/=_closure" {
     GHC.Ptr.$fEqFunPtr_$c/=_closure:
         const GHC.Ptr.$fEqFunPtr_$c/=_info;
 },
 GHC.Ptr.$fEqFunPtr_$c/=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48B1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48B5; else goto c48B6;
       c48B5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48B6: // global
           I64[Sp - 16] = block_c48AY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Bj; else goto c48AZ;
       u48Bj: // global
           call _c48AY(R1) args: 0, res: 0, upd: 0;
       c48AZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fEqFunPtr_$c/=_info" {
     GHC.Ptr.$fEqFunPtr_$c/=_info:
         const GHC.Ptr.$fEqFunPtr_$c/=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48AY() //  [R1]
         { []
         }
     {offset
       c48AY: // global
           I64[Sp] = block_c48B4_info;
           _s48rK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48rK::I64;
           if (R1 & 7 != 0) goto u48Bi; else goto c48B8;
       u48Bi: // global
           call _c48B4(R1) args: 0, res: 0, upd: 0;
       c48B8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48AY_info" {
     block_c48AY_info:
         const _c48AY;
         const 1;
         const 30;
 },
 _c48B4() //  [R1]
         { []
         }
     {offset
       c48B4: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c48Bh; else goto c48Bg;
       c48Bh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48Bg: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48B4_info" {
     block_c48B4_info:
         const _c48B4;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.46495714 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_closure" {
     GHC.Ptr.$fEqFunPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqFunPtr_$c==_closure+2;
         const GHC.Ptr.$fEqFunPtr_$c/=_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.468469438 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48BM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48BQ; else goto c48BR;
       c48BQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48BR: // global
           I64[Sp - 16] = block_c48BJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48C4; else goto c48BK;
       u48C4: // global
           call _c48BJ(R1) args: 0, res: 0, upd: 0;
       c48BK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$c<=_info" {
     GHC.Ptr.$fOrdFunPtr_$c<=_info:
         const GHC.Ptr.$fOrdFunPtr_$c<=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48BJ() //  [R1]
         { []
         }
     {offset
       c48BJ: // global
           I64[Sp] = block_c48BP_info;
           _s48rR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48rR::I64;
           if (R1 & 7 != 0) goto u48C3; else goto c48BT;
       u48C3: // global
           call _c48BP(R1) args: 0, res: 0, upd: 0;
       c48BT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48BJ_info" {
     block_c48BJ_info:
         const _c48BJ;
         const 1;
         const 30;
 },
 _c48BP() //  [R1]
         { []
         }
     {offset
       c48BP: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48C1; else goto c48C2;
       c48C1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48C2: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48BP_info" {
     block_c48BP_info:
         const _c48BP;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.477013012 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmax_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmax_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c48Cw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48CA; else goto c48CB;
       c48CA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48CB: // global
           I64[Sp - 16] = block_c48Ct_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48CO; else goto c48Cu;
       u48CO: // global
           call _c48Ct(R1) args: 0, res: 0, upd: 0;
       c48Cu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$cmax_info" {
     GHC.Ptr.$fOrdFunPtr_$cmax_info:
         const GHC.Ptr.$fOrdFunPtr_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48Ct() //  [R1]
         { []
         }
     {offset
       c48Ct: // global
           I64[Sp - 8] = block_c48Cz_info;
           _s48rX::P64 = R1;
           _s48rY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s48rY::I64;
           P64[Sp + 8] = _s48rX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48CN; else goto c48CD;
       u48CN: // global
           call _c48Cz(R1) args: 0, res: 0, upd: 0;
       c48CD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Ct_info" {
     block_c48Ct_info:
         const _c48Ct;
         const 1;
         const 30;
 },
 _c48Cz() //  [R1]
         { []
         }
     {offset
       c48Cz: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48CL; else goto c48CM;
       c48CL: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48CM: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Cz_info" {
     block_c48Cz_info:
         const _c48Cz;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.485147408 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48Dg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Dk; else goto c48Dl;
       c48Dk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Dl: // global
           I64[Sp - 16] = block_c48Dd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Dy; else goto c48De;
       u48Dy: // global
           call _c48Dd(R1) args: 0, res: 0, upd: 0;
       c48De: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$c>=_info" {
     GHC.Ptr.$fOrdFunPtr_$c>=_info:
         const GHC.Ptr.$fOrdFunPtr_$c>=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48Dd() //  [R1]
         { []
         }
     {offset
       c48Dd: // global
           I64[Sp] = block_c48Dj_info;
           _s48s5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48s5::I64;
           if (R1 & 7 != 0) goto u48Dx; else goto c48Dn;
       u48Dx: // global
           call _c48Dj(R1) args: 0, res: 0, upd: 0;
       c48Dn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Dd_info" {
     block_c48Dd_info:
         const _c48Dd;
         const 1;
         const 30;
 },
 _c48Dj() //  [R1]
         { []
         }
     {offset
       c48Dj: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48Dv; else goto c48Dw;
       c48Dv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48Dw: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Dj_info" {
     block_c48Dj_info:
         const _c48Dj;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.494179943 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>_entry() //  [R2, R3]
         { []
         }
     {offset
       c48E0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48E4; else goto c48E5;
       c48E4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48E5: // global
           I64[Sp - 16] = block_c48DX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Ee; else goto c48DY;
       u48Ee: // global
           call _c48DX(R1) args: 0, res: 0, upd: 0;
       c48DY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$c>_info" {
     GHC.Ptr.$fOrdFunPtr_$c>_info:
         const GHC.Ptr.$fOrdFunPtr_$c>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48DX() //  [R1]
         { []
         }
     {offset
       c48DX: // global
           I64[Sp] = block_c48E3_info;
           _s48sc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sc::I64;
           if (R1 & 7 != 0) goto u48Ed; else goto c48E7;
       u48Ed: // global
           call _c48E3(R1) args: 0, res: 0, upd: 0;
       c48E7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48DX_info" {
     block_c48DX_info:
         const _c48DX;
         const 1;
         const 30;
 },
 _c48E3() //  [R1]
         { []
         }
     {offset
       c48E3: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48E3_info" {
     block_c48E3_info:
         const _c48E3;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.502543885 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmin_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmin_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c48EG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48EK; else goto c48EL;
       c48EK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48EL: // global
           I64[Sp - 16] = block_c48ED_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48EY; else goto c48EE;
       u48EY: // global
           call _c48ED(R1) args: 0, res: 0, upd: 0;
       c48EE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdFunPtr_$cmin_info" {
     GHC.Ptr.$fOrdFunPtr_$cmin_info:
         const GHC.Ptr.$fOrdFunPtr_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48ED() //  [R1]
         { []
         }
     {offset
       c48ED: // global
           I64[Sp - 8] = block_c48EJ_info;
           _s48si::P64 = R1;
           _s48sj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s48sj::I64;
           P64[Sp + 8] = _s48si::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48EX; else goto c48EN;
       u48EX: // global
           call _c48EJ(R1) args: 0, res: 0, upd: 0;
       c48EN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48ED_info" {
     block_c48ED_info:
         const _c48ED;
         const 1;
         const 30;
 },
 _c48EJ() //  [R1]
         { []
         }
     {offset
       c48EJ: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48EV; else goto c48EW;
       c48EV: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48EW: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48EJ_info" {
     block_c48EJ_info:
         const _c48EJ;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.509411085 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_closure" {
     GHC.Ptr.$fOrdFunPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqFunPtr_closure+1;
         const GHC.Ptr.$fOrdFunPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.512709831 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<_closure" {
     GHC.Ptr.$fOrdPtr_$c<_closure:
         const GHC.Ptr.$fOrdPtr_$c<_info;
 },
 GHC.Ptr.$fOrdPtr_$c<_entry() //  [R2, R3]
         { []
         }
     {offset
       c48Fr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Fv; else goto c48Fw;
       c48Fv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Fw: // global
           I64[Sp - 16] = block_c48Fo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48FF; else goto c48Fp;
       u48FF: // global
           call _c48Fo(R1) args: 0, res: 0, upd: 0;
       c48Fp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$c<_info" {
     GHC.Ptr.$fOrdPtr_$c<_info:
         const GHC.Ptr.$fOrdPtr_$c<_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48Fo() //  [R1]
         { []
         }
     {offset
       c48Fo: // global
           I64[Sp] = block_c48Fu_info;
           _s48sq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sq::I64;
           if (R1 & 7 != 0) goto u48FE; else goto c48Fy;
       u48FE: // global
           call _c48Fu(R1) args: 0, res: 0, upd: 0;
       c48Fy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Fo_info" {
     block_c48Fo_info:
         const _c48Fo;
         const 1;
         const 30;
 },
 _c48Fu() //  [R1]
         { []
         }
     {offset
       c48Fu: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Fu_info" {
     block_c48Fu_info:
         const _c48Fu;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.521061262 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdPtr_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       c48G7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Gb; else goto c48Gc;
       c48Gb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Gc: // global
           I64[Sp - 16] = block_c48G4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Gv; else goto c48G5;
       u48Gv: // global
           call _c48G4(R1) args: 0, res: 0, upd: 0;
       c48G5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$ccompare_info" {
     GHC.Ptr.$fOrdPtr_$ccompare_info:
         const GHC.Ptr.$fOrdPtr_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48G4() //  [R1]
         { []
         }
     {offset
       c48G4: // global
           I64[Sp] = block_c48Ga_info;
           _s48sx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sx::I64;
           if (R1 & 7 != 0) goto u48Gu; else goto c48Ge;
       u48Gu: // global
           call _c48Ga(R1) args: 0, res: 0, upd: 0;
       c48Ge: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48G4_info" {
     block_c48G4_info:
         const _c48G4;
         const 1;
         const 30;
 },
 _c48Ga() //  [R1]
         { []
         }
     {offset
       c48Ga: // global
           _s48sx::I64 = I64[Sp + 8];
           _s48sz::I64 = I64[R1 + 7];
           if (_s48sx::I64 >= _s48sz::I64) goto c48Gs; else goto c48Gt;
       c48Gs: // global
           if (_s48sx::I64 == _s48sz::I64) goto c48Gq; else goto c48Gp;
       c48Gq: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48Gp: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48Gt: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Ga_info" {
     block_c48Ga_info:
         const _c48Ga;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.529827635 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c==_closure" {
     GHC.Ptr.$fEqPtr_$c==_closure:
         const GHC.Ptr.$fEqPtr_$c==_info;
 },
 GHC.Ptr.$fEqPtr_$c==_entry() //  [R2, R3]
         { []
         }
     {offset
       c48GY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48H2; else goto c48H3;
       c48H2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48H3: // global
           I64[Sp - 16] = block_c48GV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Hc; else goto c48GW;
       u48Hc: // global
           call _c48GV(R1) args: 0, res: 0, upd: 0;
       c48GW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fEqPtr_$c==_info" {
     GHC.Ptr.$fEqPtr_$c==_info:
         const GHC.Ptr.$fEqPtr_$c==_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48GV() //  [R1]
         { []
         }
     {offset
       c48GV: // global
           I64[Sp] = block_c48H1_info;
           _s48sF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sF::I64;
           if (R1 & 7 != 0) goto u48Hb; else goto c48H5;
       u48Hb: // global
           call _c48H1(R1) args: 0, res: 0, upd: 0;
       c48H5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48GV_info" {
     block_c48GV_info:
         const _c48GV;
         const 1;
         const 30;
 },
 _c48H1() //  [R1]
         { []
         }
     {offset
       c48H1: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48H1_info" {
     block_c48H1_info:
         const _c48H1;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.538058917 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c/=_closure" {
     GHC.Ptr.$fEqPtr_$c/=_closure:
         const GHC.Ptr.$fEqPtr_$c/=_info;
 },
 GHC.Ptr.$fEqPtr_$c/=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48HE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48HI; else goto c48HJ;
       c48HI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48HJ: // global
           I64[Sp - 16] = block_c48HB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48HW; else goto c48HC;
       u48HW: // global
           call _c48HB(R1) args: 0, res: 0, upd: 0;
       c48HC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fEqPtr_$c/=_info" {
     GHC.Ptr.$fEqPtr_$c/=_info:
         const GHC.Ptr.$fEqPtr_$c/=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48HB() //  [R1]
         { []
         }
     {offset
       c48HB: // global
           I64[Sp] = block_c48HH_info;
           _s48sM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sM::I64;
           if (R1 & 7 != 0) goto u48HV; else goto c48HL;
       u48HV: // global
           call _c48HH(R1) args: 0, res: 0, upd: 0;
       c48HL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48HB_info" {
     block_c48HB_info:
         const _c48HB;
         const 1;
         const 30;
 },
 _c48HH() //  [R1]
         { []
         }
     {offset
       c48HH: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c48HU; else goto c48HT;
       c48HU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48HT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48HH_info" {
     block_c48HH_info:
         const _c48HH;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.546244353 UTC

[section ""data" . GHC.Ptr.$fEqPtr_closure" {
     GHC.Ptr.$fEqPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqPtr_$c==_closure+2;
         const GHC.Ptr.$fEqPtr_$c/=_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.550488845 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<=_closure" {
     GHC.Ptr.$fOrdPtr_$c<=_closure:
         const GHC.Ptr.$fOrdPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdPtr_$c<=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48Ip: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48It; else goto c48Iu;
       c48It: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Iu: // global
           I64[Sp - 16] = block_c48Im_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48IH; else goto c48In;
       u48IH: // global
           call _c48Im(R1) args: 0, res: 0, upd: 0;
       c48In: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$c<=_info" {
     GHC.Ptr.$fOrdPtr_$c<=_info:
         const GHC.Ptr.$fOrdPtr_$c<=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48Im() //  [R1]
         { []
         }
     {offset
       c48Im: // global
           I64[Sp] = block_c48Is_info;
           _s48sT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sT::I64;
           if (R1 & 7 != 0) goto u48IG; else goto c48Iw;
       u48IG: // global
           call _c48Is(R1) args: 0, res: 0, upd: 0;
       c48Iw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Im_info" {
     block_c48Im_info:
         const _c48Im;
         const 1;
         const 30;
 },
 _c48Is() //  [R1]
         { []
         }
     {offset
       c48Is: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48IE; else goto c48IF;
       c48IE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48IF: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Is_info" {
     block_c48Is_info:
         const _c48Is;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.558938517 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmax_closure" {
     GHC.Ptr.$fOrdPtr_$cmax_closure:
         const GHC.Ptr.$fOrdPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdPtr_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       c48J9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48Jd; else goto c48Je;
       c48Jd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Je: // global
           I64[Sp - 16] = block_c48J6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Jr; else goto c48J7;
       u48Jr: // global
           call _c48J6(R1) args: 0, res: 0, upd: 0;
       c48J7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$cmax_info" {
     GHC.Ptr.$fOrdPtr_$cmax_info:
         const GHC.Ptr.$fOrdPtr_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48J6() //  [R1]
         { []
         }
     {offset
       c48J6: // global
           I64[Sp - 8] = block_c48Jc_info;
           _s48sZ::P64 = R1;
           _s48t0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s48t0::I64;
           P64[Sp + 8] = _s48sZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48Jq; else goto c48Jg;
       u48Jq: // global
           call _c48Jc(R1) args: 0, res: 0, upd: 0;
       c48Jg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48J6_info" {
     block_c48J6_info:
         const _c48J6;
         const 1;
         const 30;
 },
 _c48Jc() //  [R1]
         { []
         }
     {offset
       c48Jc: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48Jo; else goto c48Jp;
       c48Jo: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48Jp: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Jc_info" {
     block_c48Jc_info:
         const _c48Jc;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.567133144 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>=_closure" {
     GHC.Ptr.$fOrdPtr_$c>=_closure:
         const GHC.Ptr.$fOrdPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdPtr_$c>=_entry() //  [R2, R3]
         { []
         }
     {offset
       c48JT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48JX; else goto c48JY;
       c48JX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48JY: // global
           I64[Sp - 16] = block_c48JQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Kb; else goto c48JR;
       u48Kb: // global
           call _c48JQ(R1) args: 0, res: 0, upd: 0;
       c48JR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$c>=_info" {
     GHC.Ptr.$fOrdPtr_$c>=_info:
         const GHC.Ptr.$fOrdPtr_$c>=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48JQ() //  [R1]
         { []
         }
     {offset
       c48JQ: // global
           I64[Sp] = block_c48JW_info;
           _s48t7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48t7::I64;
           if (R1 & 7 != 0) goto u48Ka; else goto c48K0;
       u48Ka: // global
           call _c48JW(R1) args: 0, res: 0, upd: 0;
       c48K0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48JQ_info" {
     block_c48JQ_info:
         const _c48JQ;
         const 1;
         const 30;
 },
 _c48JW() //  [R1]
         { []
         }
     {offset
       c48JW: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48K8; else goto c48K9;
       c48K8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48K9: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48JW_info" {
     block_c48JW_info:
         const _c48JW;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.575409019 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>_closure" {
     GHC.Ptr.$fOrdPtr_$c>_closure:
         const GHC.Ptr.$fOrdPtr_$c>_info;
 },
 GHC.Ptr.$fOrdPtr_$c>_entry() //  [R2, R3]
         { []
         }
     {offset
       c48KD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48KH; else goto c48KI;
       c48KH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48KI: // global
           I64[Sp - 16] = block_c48KA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48KR; else goto c48KB;
       u48KR: // global
           call _c48KA(R1) args: 0, res: 0, upd: 0;
       c48KB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$c>_info" {
     GHC.Ptr.$fOrdPtr_$c>_info:
         const GHC.Ptr.$fOrdPtr_$c>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48KA() //  [R1]
         { []
         }
     {offset
       c48KA: // global
           I64[Sp] = block_c48KG_info;
           _s48te::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48te::I64;
           if (R1 & 7 != 0) goto u48KQ; else goto c48KK;
       u48KQ: // global
           call _c48KG(R1) args: 0, res: 0, upd: 0;
       c48KK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48KA_info" {
     block_c48KA_info:
         const _c48KA;
         const 1;
         const 30;
 },
 _c48KG() //  [R1]
         { []
         }
     {offset
       c48KG: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48KG_info" {
     block_c48KG_info:
         const _c48KG;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.58359125 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmin_closure" {
     GHC.Ptr.$fOrdPtr_$cmin_closure:
         const GHC.Ptr.$fOrdPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdPtr_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       c48Lj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48Ln; else goto c48Lo;
       c48Ln: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Lo: // global
           I64[Sp - 16] = block_c48Lg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48LB; else goto c48Lh;
       u48LB: // global
           call _c48Lg(R1) args: 0, res: 0, upd: 0;
       c48Lh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fOrdPtr_$cmin_info" {
     GHC.Ptr.$fOrdPtr_$cmin_info:
         const GHC.Ptr.$fOrdPtr_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48Lg() //  [R1]
         { []
         }
     {offset
       c48Lg: // global
           I64[Sp - 8] = block_c48Lm_info;
           _s48tk::P64 = R1;
           _s48tl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s48tl::I64;
           P64[Sp + 8] = _s48tk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48LA; else goto c48Lq;
       u48LA: // global
           call _c48Lm(R1) args: 0, res: 0, upd: 0;
       c48Lq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Lg_info" {
     block_c48Lg_info:
         const _c48Lg;
         const 1;
         const 30;
 },
 _c48Lm() //  [R1]
         { []
         }
     {offset
       c48Lm: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48Ly; else goto c48Lz;
       c48Ly: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48Lz: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Lm_info" {
     block_c48Lm_info:
         const _c48Lm;
         const 66;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.590590118 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_closure" {
     GHC.Ptr.$fOrdPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqPtr_closure+1;
         const GHC.Ptr.$fOrdPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.592368666 UTC

[section ""data" . GHC.Ptr.nullPtr_closure" {
     GHC.Ptr.nullPtr_closure:
         const GHC.Ptr.Ptr_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.594501822 UTC

[section ""data" . GHC.Ptr.castPtr1_closure" {
     GHC.Ptr.castPtr1_closure:
         const GHC.Ptr.castPtr1_info;
 },
 GHC.Ptr.castPtr1_entry() //  [R2]
         { []
         }
     {offset
       c48M2: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castPtr1_info" {
     GHC.Ptr.castPtr1_info:
         const GHC.Ptr.castPtr1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.597943523 UTC

[section ""data" . GHC.Ptr.castPtr_closure" {
     GHC.Ptr.castPtr_closure:
         const GHC.Ptr.castPtr_info;
 },
 GHC.Ptr.castPtr_entry() //  [R2]
         { []
         }
     {offset
       c48Mf: // global
           R2 = R2;
           call GHC.Ptr.castPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castPtr_info" {
     GHC.Ptr.castPtr_info:
         const GHC.Ptr.castPtr_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.602971876 UTC

[section ""data" . GHC.Ptr.plusPtr_closure" {
     GHC.Ptr.plusPtr_closure:
         const GHC.Ptr.plusPtr_info;
 },
 GHC.Ptr.plusPtr_entry() //  [R2, R3]
         { []
         }
     {offset
       c48Mt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48MF; else goto c48MG;
       c48MF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.plusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48MG: // global
           I64[Sp - 16] = block_c48Mq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48MM; else goto c48Mr;
       u48MM: // global
           call _c48Mq(R1) args: 0, res: 0, upd: 0;
       c48Mr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.plusPtr_info" {
     GHC.Ptr.plusPtr_info:
         const GHC.Ptr.plusPtr_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48Mq() //  [R1]
         { []
         }
     {offset
       c48Mq: // global
           I64[Sp] = block_c48Mw_info;
           _s48tt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48tt::I64;
           if (R1 & 7 != 0) goto u48ML; else goto c48Mx;
       u48ML: // global
           call _c48Mw(R1) args: 0, res: 0, upd: 0;
       c48Mx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Mq_info" {
     block_c48Mq_info:
         const _c48Mq;
         const 1;
         const 30;
 },
 _c48Mw() //  [R1]
         { []
         }
     {offset
       c48Mw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48MK; else goto c48MJ;
       c48MK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48MJ: // global
           _s48tw::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s48tw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Mw_info" {
     block_c48Mw_info:
         const _c48Mw;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.611617866 UTC

[section ""data" . GHC.Ptr.alignPtr_closure" {
     GHC.Ptr.alignPtr_closure:
         const GHC.Ptr.alignPtr_info;
 },
 GHC.Ptr.alignPtr_entry() //  [R2, R3]
         { []
         }
     {offset
       c48Nd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48Nh; else goto c48Ni;
       c48Nh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.alignPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Ni: // global
           I64[Sp - 16] = block_c48Na_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48NQ; else goto c48Nb;
       u48NQ: // global
           call _c48Na(R1) args: 0, res: 0, upd: 0;
       c48Nb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.alignPtr_info" {
     GHC.Ptr.alignPtr_info:
         const GHC.Ptr.alignPtr_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48Na() //  [R1]
         { []
         }
     {offset
       c48Na: // global
           I64[Sp - 8] = block_c48Ng_info;
           _s48tz::P64 = R1;
           _s48tA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s48tA::I64;
           P64[Sp + 8] = _s48tz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48NP; else goto c48Nk;
       u48NP: // global
           call _c48Ng(R1) args: 0, res: 0, upd: 0;
       c48Nk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Na_info" {
     block_c48Na_info:
         const _c48Na;
         const 1;
         const 30;
 },
 _c48Ng() //  [R1]
         { []
         }
     {offset
       c48Ng: // global
           _s48tC::I64 = I64[R1 + 7];
           _s48tD::I64 = I64[Sp + 8] % _s48tC::I64;
           if (_s48tD::I64 != 0) goto u48NN; else goto c48NJ;
       u48NN: // global
           I64[Sp] = _s48tD::I64;
           I64[Sp + 16] = _s48tC::I64;
           call _c48Nt() args: 0, res: 0, upd: 0;
       c48NJ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Ng_info" {
     block_c48Ng_info:
         const _c48Ng;
         const 66;
         const 30;
 },
 _c48Nt() //  []
         { []
         }
     {offset
       c48Nt: // global
           Hp = Hp + 16;
           _s48tD::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c48NG; else goto c48NF;
       c48NG: // global
           HpAlloc = 16;
           I64[Sp] = block_c48Ns_info;
           R1 = _s48tD::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c48NF: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + (I64[Sp + 16] - _s48tD::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c48Ns() //  [R1]
         { []
         }
     {offset
       c48Ns: // global
           I64[Sp] = R1;
           call _c48Nt() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_c48Ns_info" {
     block_c48Ns_info:
         const _c48Ns;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.622631995 UTC

[section ""data" . GHC.Ptr.minusPtr_closure" {
     GHC.Ptr.minusPtr_closure:
         const GHC.Ptr.minusPtr_info;
 },
 GHC.Ptr.minusPtr_entry() //  [R2, R3]
         { []
         }
     {offset
       c48Ot: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48OF; else goto c48OG;
       c48OF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.minusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48OG: // global
           I64[Sp - 16] = block_c48Oq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48OM; else goto c48Or;
       u48OM: // global
           call _c48Oq(R1) args: 0, res: 0, upd: 0;
       c48Or: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.minusPtr_info" {
     GHC.Ptr.minusPtr_info:
         const GHC.Ptr.minusPtr_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _c48Oq() //  [R1]
         { []
         }
     {offset
       c48Oq: // global
           I64[Sp] = block_c48Ow_info;
           _s48tJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48tJ::I64;
           if (R1 & 7 != 0) goto u48OL; else goto c48Ox;
       u48OL: // global
           call _c48Ow(R1) args: 0, res: 0, upd: 0;
       c48Ox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Oq_info" {
     block_c48Oq_info:
         const _c48Oq;
         const 1;
         const 30;
 },
 _c48Ow() //  [R1]
         { []
         }
     {offset
       c48Ow: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48OK; else goto c48OJ;
       c48OK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48OJ: // global
           _s48tM::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s48tM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Ow_info" {
     block_c48Ow_info:
         const _c48Ow;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.630076555 UTC

[section ""data" . GHC.Ptr.nullFunPtr_closure" {
     GHC.Ptr.nullFunPtr_closure:
         const GHC.Ptr.FunPtr_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.632292929 UTC

[section ""data" . GHC.Ptr.castFunPtr1_closure" {
     GHC.Ptr.castFunPtr1_closure:
         const GHC.Ptr.castFunPtr1_info;
 },
 GHC.Ptr.castFunPtr1_entry() //  [R2]
         { []
         }
     {offset
       c48Pb: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castFunPtr1_info" {
     GHC.Ptr.castFunPtr1_info:
         const GHC.Ptr.castFunPtr1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.637009824 UTC

[section ""data" . GHC.Ptr.castFunPtr_closure" {
     GHC.Ptr.castFunPtr_closure:
         const GHC.Ptr.castFunPtr_info;
 },
 GHC.Ptr.castFunPtr_entry() //  [R2]
         { []
         }
     {offset
       c48Po: // global
           R2 = R2;
           call GHC.Ptr.castFunPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castFunPtr_info" {
     GHC.Ptr.castFunPtr_info:
         const GHC.Ptr.castFunPtr_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.640827209 UTC

[section ""data" . GHC.Ptr.castFunPtrToPtr_closure" {
     GHC.Ptr.castFunPtrToPtr_closure:
         const GHC.Ptr.castFunPtrToPtr_info;
 },
 GHC.Ptr.castFunPtrToPtr_entry() //  [R2]
         { []
         }
     {offset
       c48PC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48PG; else goto c48PH;
       c48PG: // global
           R2 = R2;
           R1 = GHC.Ptr.castFunPtrToPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48PH: // global
           I64[Sp - 8] = block_c48Pz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48PL; else goto c48PA;
       u48PL: // global
           call _c48Pz(R1) args: 0, res: 0, upd: 0;
       c48PA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castFunPtrToPtr_info" {
     GHC.Ptr.castFunPtrToPtr_info:
         const GHC.Ptr.castFunPtrToPtr_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c48Pz() //  [R1]
         { []
         }
     {offset
       c48Pz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48PK; else goto c48PJ;
       c48PK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48PJ: // global
           _s48tQ::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s48tQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Pz_info" {
     block_c48Pz_info:
         const _c48Pz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.647773518 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       c48Q5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Qb; else goto c48Qc;
       c48Qb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Qc: // global
           I64[Sp - 16] = block_c48Q2_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Qh; else goto c48Q3;
       u48Qh: // global
           call _c48Q2(R1) args: 0, res: 0, upd: 0;
       c48Q3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_entry;
         const 0;
         const 73014444046;
         const 12884901911;
         const S48vI_srt+40;
 },
 _c48Q2() //  [R1]
         { []
         }
     {offset
       c48Q2: // global
           _s48tT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48Q8_info;
           R3 = _s48tT::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Q2_info" {
     block_c48Q2_info:
         const _c48Q2;
         const 1;
         const 4294967326;
         const S48vI_srt+40;
 },
 _c48Q8() //  [R1, R2]
         { []
         }
     {offset
       c48Q8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48Qg; else goto c48Qf;
       c48Qg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48Qf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Q8_info" {
     block_c48Q8_info:
         const _c48Q8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.655734872 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshow_closure" {
     GHC.Ptr.$fShowFunPtr_$cshow_closure:
         const GHC.Ptr.$fShowFunPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshow_entry() //  [R2]
         { []
         }
     {offset
       c48QF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48QL; else goto c48QM;
       c48QL: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48QM: // global
           I64[Sp - 8] = block_c48QC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48QR; else goto c48QD;
       u48QR: // global
           call _c48QC(R1) args: 0, res: 0, upd: 0;
       c48QD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowFunPtr_$cshow_info" {
     GHC.Ptr.$fShowFunPtr_$cshow_info:
         const GHC.Ptr.$fShowFunPtr_$cshow_entry;
         const 0;
         const 141733920782;
         const 4294967301;
         const S48vI_srt+40;
 },
 _c48QC() //  [R1]
         { []
         }
     {offset
       c48QC: // global
           I64[Sp] = block_c48QI_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48QC_info" {
     block_c48QC_info:
         const _c48QC;
         const 0;
         const 4294967326;
         const S48vI_srt+40;
 },
 _c48QI() //  [R1, R2]
         { []
         }
     {offset
       c48QI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48QQ; else goto c48QP;
       c48QQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48QP: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48QI_info" {
     block_c48QI_info:
         const _c48QI;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.663827855 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr1_closure" {
     GHC.Ptr.$fShowFunPtr1_closure:
         const GHC.Ptr.$fShowFunPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr1_entry() //  [R2, R3]
         { []
         }
     {offset
       c48Rg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Rm; else goto c48Rn;
       c48Rm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Rn: // global
           I64[Sp - 16] = block_c48Rd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Rs; else goto c48Re;
       u48Rs: // global
           call _c48Rd(R1) args: 0, res: 0, upd: 0;
       c48Re: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowFunPtr1_info" {
     GHC.Ptr.$fShowFunPtr1_info:
         const GHC.Ptr.$fShowFunPtr1_entry;
         const 0;
         const 279172874254;
         const 8589934607;
         const S48vI_srt+40;
 },
 _c48Rd() //  [R1]
         { []
         }
     {offset
       c48Rd: // global
           _s48u6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48Rj_info;
           R3 = _s48u6::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Rd_info" {
     block_c48Rd_info:
         const _c48Rd;
         const 1;
         const 4294967326;
         const S48vI_srt+40;
 },
 _c48Rj() //  [R1, R2]
         { []
         }
     {offset
       c48Rj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48Rr; else goto c48Rq;
       c48Rr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48Rq: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48Rj_info" {
     block_c48Rj_info:
         const _c48Rj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.671539062 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowList_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowList_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       c48RN: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowFunPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.$fShowFunPtr_$cshowList_info" {
     GHC.Ptr.$fShowFunPtr_$cshowList_info:
         const GHC.Ptr.$fShowFunPtr_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S48vI_srt+88;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.674711984 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_closure" {
     GHC.Ptr.$fShowFunPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure+3;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowFunPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.677413807 UTC

[section ""data" . GHC.Ptr.castPtrToFunPtr_closure" {
     GHC.Ptr.castPtrToFunPtr_closure:
         const GHC.Ptr.castPtrToFunPtr_info;
 },
 GHC.Ptr.castPtrToFunPtr_entry() //  [R2]
         { []
         }
     {offset
       c48S2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48S6; else goto c48S7;
       c48S6: // global
           R2 = R2;
           R1 = GHC.Ptr.castPtrToFunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48S7: // global
           I64[Sp - 8] = block_c48RZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48Sb; else goto c48S0;
       u48Sb: // global
           call _c48RZ(R1) args: 0, res: 0, upd: 0;
       c48S0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.castPtrToFunPtr_info" {
     GHC.Ptr.castPtrToFunPtr_info:
         const GHC.Ptr.castPtrToFunPtr_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _c48RZ() //  [R1]
         { []
         }
     {offset
       c48RZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48Sa; else goto c48S9;
       c48Sa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48S9: // global
           _s48ug::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s48ug::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_c48RZ_info" {
     block_c48RZ_info:
         const _c48RZ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.682849655 UTC

[section ""cstring" . GHC.Ptr.$trModule4_bytes" {
     GHC.Ptr.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.684540868 UTC

[section ""data" . GHC.Ptr.$trModule3_closure" {
     GHC.Ptr.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.686307956 UTC

[section ""cstring" . GHC.Ptr.$trModule2_bytes" {
     GHC.Ptr.$trModule2_bytes:
         I8[] [71,72,67,46,80,116,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.688020534 UTC

[section ""data" . GHC.Ptr.$trModule1_closure" {
     GHC.Ptr.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.690512728 UTC

[section ""data" . GHC.Ptr.$trModule_closure" {
     GHC.Ptr.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Ptr.$trModule3_closure+1;
         const GHC.Ptr.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.692162914 UTC

[section ""data" . $krep_r47xK_closure" {
     $krep_r47xK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.693868593 UTC

[section ""data" . $krep1_r47xL_closure" {
     $krep1_r47xL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcAddr#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.695472485 UTC

[section ""cstring" . GHC.Ptr.$tcPtr2_bytes" {
     GHC.Ptr.$tcPtr2_bytes:
         I8[] [80,116,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.697198712 UTC

[section ""data" . GHC.Ptr.$tcPtr1_closure" {
     GHC.Ptr.$tcPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcPtr2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.699026812 UTC

[section ""data" . GHC.Ptr.$tcPtr_closure" {
     GHC.Ptr.$tcPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13939499724423561315;
         const 16316673677148652216;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.701147579 UTC

[section ""data" . $krep2_r47xM_closure" {
     $krep2_r47xM_closure:
         const :_con_info;
         const $krep_r47xK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.70293114 UTC

[section ""data" . $krep3_r47xN_closure" {
     $krep3_r47xN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.704619068 UTC

[section ""data" . GHC.Ptr.$tc'Ptr1_closure" {
     GHC.Ptr.$tc'Ptr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep3_r47xN_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.706927901 UTC

[section ""cstring" . GHC.Ptr.$tc'Ptr3_bytes" {
     GHC.Ptr.$tc'Ptr3_bytes:
         I8[] [39,80,116,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.708602617 UTC

[section ""data" . GHC.Ptr.$tc'Ptr2_closure" {
     GHC.Ptr.$tc'Ptr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'Ptr3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.710739259 UTC

[section ""data" . GHC.Ptr.$tc'Ptr_closure" {
     GHC.Ptr.$tc'Ptr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'Ptr2_closure+1;
         const GHC.Ptr.$tc'Ptr1_closure+4;
         const 2332306090346040376;
         const 13491728187967991297;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.712467011 UTC

[section ""cstring" . GHC.Ptr.$tcFunPtr2_bytes" {
     GHC.Ptr.$tcFunPtr2_bytes:
         I8[] [70,117,110,80,116,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.714120039 UTC

[section ""data" . GHC.Ptr.$tcFunPtr1_closure" {
     GHC.Ptr.$tcFunPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcFunPtr2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.715886738 UTC

[section ""data" . GHC.Ptr.$tcFunPtr_closure" {
     GHC.Ptr.$tcFunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcFunPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 38956960673620606;
         const 4307950889093819770;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.717807331 UTC

[section ""data" . $krep4_r47xO_closure" {
     $krep4_r47xO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcFunPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.719794103 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr1_closure" {
     GHC.Ptr.$tc'FunPtr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep4_r47xO_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.721521737 UTC

[section ""cstring" . GHC.Ptr.$tc'FunPtr3_bytes" {
     GHC.Ptr.$tc'FunPtr3_bytes:
         I8[] [39,70,117,110,80,116,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.723208414 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr2_closure" {
     GHC.Ptr.$tc'FunPtr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'FunPtr3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.725019689 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr_closure" {
     GHC.Ptr.$tc'FunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'FunPtr2_closure+1;
         const GHC.Ptr.$tc'FunPtr1_closure+4;
         const 15722333564603238588;
         const 12100865307857439187;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.727614285 UTC

[section ""data" . GHC.Ptr.Ptr_closure" {
     GHC.Ptr.Ptr_closure:
         const GHC.Ptr.Ptr_info;
 },
 GHC.Ptr.Ptr_entry() //  [R2]
         { []
         }
     {offset
       c48SR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48SV; else goto c48SU;
       c48SV: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.Ptr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48SU: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.Ptr_info" {
     GHC.Ptr.Ptr_info:
         const GHC.Ptr.Ptr_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.731969458 UTC

[section ""data" . GHC.Ptr.FunPtr_closure" {
     GHC.Ptr.FunPtr_closure:
         const GHC.Ptr.FunPtr_info;
 },
 GHC.Ptr.FunPtr_entry() //  [R2]
         { []
         }
     {offset
       c48T7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48Tb; else goto c48Ta;
       c48Tb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.FunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48Ta: // global
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.FunPtr_info" {
     GHC.Ptr.FunPtr_info:
         const GHC.Ptr.FunPtr_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.73582357 UTC

[section ""cstring" . i48Tj_str" {
     i48Tj_str:
         I8[] [98,97,115,101,58,71,72,67,46,80,116,114,46,80,116,114]
 },
 GHC.Ptr.Ptr_con_entry() //  [R1]
         { []
         }
     {offset
       c48Ti: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.Ptr_con_info" {
     GHC.Ptr.Ptr_con_info:
         const GHC.Ptr.Ptr_con_entry;
         const 4294967296;
         const 3;
         const i48Tj_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.739156235 UTC

[section ""cstring" . i48Tq_str" {
     i48Tq_str:
         I8[] [98,97,115,101,58,71,72,67,46,80,116,114,46,70,117,110,80,116,114]
 },
 GHC.Ptr.FunPtr_con_entry() //  [R1]
         { []
         }
     {offset
       c48Tp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Ptr.FunPtr_con_info" {
     GHC.Ptr.FunPtr_con_info:
         const GHC.Ptr.FunPtr_con_entry;
         const 4294967296;
         const 3;
         const i48Tq_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:59:01.742836772 UTC

[section ""relreadonly" . S48vI_srt" {
     S48vI_srt:
         const GHC.Show.intToDigit_closure;
         const GHC.Show.$fShowInteger_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Numeric.showIntAtBase_closure;
         const Numeric.showHex1_closure;
         const GHC.Ptr.$w$cshowsPrec_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
         const GHC.Ptr.$fShowPtr_$cshow_closure;
         const GHC.Ptr.$fShowPtr1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure;
         const GHC.Ptr.$fShowFunPtr1_closure;
 }]

